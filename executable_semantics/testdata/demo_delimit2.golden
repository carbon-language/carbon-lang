********** source program **********
fn main () -> Int {
delimit
{
yield 0;
return 1;

}

with (v, k)
{
return v;

}



}
********** type checking **********
--- step exp Int --->
--- step exp Int --->

********** type checking complete **********
fn main () -> Int {
delimit
{
yield 0;
return 1;
}

with (v, k)
{
return v;
}


}
********** starting execution **********
********** initializing globals **********
--- step exp () --->
********** calling main function **********
{
stack: top{main()<-1>}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step exp main() --->
{
stack: top{main<-1> :: main()<0>}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step exp main --->
{
stack: top{fun<main><-1> :: main()<0>}
heap: fun<main>, 
env: main: fun<main>, 
}
--- handle value fun<main> with main()<1>(fun<main>,) --->
{
stack: top{()<-1> :: main()<1>(fun<main>,)}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step exp () --->
{
stack: top{()<-1> :: main()<1>(fun<main>,)}
heap: fun<main>, 
env: main: fun<main>, 
}
--- handle value () with main()<2>(fun<main>,(),) --->
pattern_match((), ())
{
stack: main{delimit
 ... 
with (v, k)
 ... 
<-1>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step stmt delimit
 ... 
with (v, k)
 ... 
 --->
{
stack: main{{
 ... 
}
<-1> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step stmt {
 ... 
}
 --->
{
stack: main{yield 0; ... <-1> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step stmt yield 0; ...  --->
{
stack: main{yield 0;<-1> :: return 1;<-1> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step stmt yield 0; --->
{
stack: main{0<-1> :: yield 0;<0> :: return 1;<-1> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step exp 0 --->
{
stack: main{0<-1> :: yield 0;<0> :: return 1;<-1> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- handle value 0 with yield 0;<1>(0,) --->
{
stack: main{{
 ... 
}
<-1> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 0, continuation, 
env: k: continuation, v: 0, main: fun<main>, 
}
--- step stmt {
 ... 
}
 --->
{
stack: main{{
 ... 
}
<-1> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 0, continuation, 
env: k: continuation, v: 0, main: fun<main>, 
}
--- step stmt {
 ... 
}
 --->
{
stack: main{return v;<-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 0, continuation, 
env: k: continuation, v: 0, main: fun<main>, 
}
--- step stmt return v; --->
{
stack: main{v<-1> :: return v;<0> :: {
 ... 
}
<0> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 0, continuation, 
env: k: continuation, v: 0, main: fun<main>, 
}
--- step exp v --->
{
stack: main{0<-1> :: return v;<0> :: {
 ... 
}
<0> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 0, continuation, 
env: k: continuation, v: 0, main: fun<main>, 
}
--- handle value 0 with return v;<1>(0,) --->
{
stack: top{0<-1>}
heap: fun<main>, !!0, !!continuation, 
env: main: fun<main>, 
}
result: 0
