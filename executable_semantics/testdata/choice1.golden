********** source program **********
choice Ints {
alt None ();
alt One Int;
alt Two (0 = Int, 1 = Int);
}
fn main () -> Int {
var auto: x = Ints.None();
var auto: y = Ints.One(0 = 42);
var auto: n = 0;
match (y) {
case Ints.None =>
n = (n + 2);
case Ints.One(0 = auto: x) =>
n = ((x + 1) - 42);
case Ints.Two(0 = auto: a, 1 = auto: b) =>
n = 2;
}
match (x) {
case Ints.One(0 = auto: x) =>
n = (x + 2);
case Ints.None() =>
n = (n - 1);
case Ints.Two(0 = auto: x, 1 = auto: y) =>
n = 5;
}
return n;

}
choice MoreInts {
alt None ();
alt One Int;
alt Two (0 = Int, 1 = Int);
}
********** type checking **********
--- step exp () --->
--- step exp Int --->
--- step exp (0 = Int, 1 = Int) --->
--- step exp Int --->
--- handle value Int with (0 = Int, 1 = Int)<1>(Int,) --->
--- step exp Int --->
--- handle value Int with (0 = Int, 1 = Int)<2>(Int,Int,) --->
--- step exp Int --->
--- step exp () --->
--- step exp Int --->
--- step exp (0 = Int, 1 = Int) --->
--- step exp Int --->
--- handle value Int with (0 = Int, 1 = Int)<1>(Int,) --->
--- step exp Int --->
--- handle value Int with (0 = Int, 1 = Int)<2>(Int,Int,) --->
--- step exp Int --->
--- step exp auto --->
13: type error in call
expected: Int
actual: Tuple(0 = Int)
EXIT CODE: 255
