********** source program **********
var Int : zero = 1
fn main () -> Int {
zero = 0;
return zero;

}
********** type checking **********
--- step exp Int --->
--- step exp Int --->
--- step exp Int --->
--- step exp Int --->

********** type checking complete **********
var Int : zero = 1
fn main () -> Int {
zero = 0;
return zero;
}
********** starting execution **********
********** initializing globals **********
--- step exp 1 --->
--- step exp () --->
********** calling main function **********
{
stack: top{main()<-1>}
heap: 1, fun<main>, 
env: main: fun<main>, zero: 1, 
}
--- step exp main() --->
{
stack: top{main<-1> :: main()<0>}
heap: 1, fun<main>, 
env: main: fun<main>, zero: 1, 
}
--- step exp main --->
{
stack: top{fun<main><-1> :: main()<0>}
heap: 1, fun<main>, 
env: main: fun<main>, zero: 1, 
}
--- handle value fun<main> with main()<1>(fun<main>,) --->
{
stack: top{()<-1> :: main()<1>(fun<main>,)}
heap: 1, fun<main>, 
env: main: fun<main>, zero: 1, 
}
--- step exp () --->
{
stack: top{()<-1> :: main()<1>(fun<main>,)}
heap: 1, fun<main>, 
env: main: fun<main>, zero: 1, 
}
--- handle value () with main()<2>(fun<main>,(),) --->
pattern_match((), ())
{
stack: main{zero = 0; ... <-1>} :: top{}
heap: 1, fun<main>, 
env: main: fun<main>, zero: 1, 
}
--- step stmt zero = 0; ...  --->
{
stack: main{zero = 0;<-1> :: return zero;<-1>} :: top{}
heap: 1, fun<main>, 
env: main: fun<main>, zero: 1, 
}
--- step stmt zero = 0; --->
{
stack: main{zero<-1> :: zero = 0;<0> :: return zero;<-1>} :: top{}
heap: 1, fun<main>, 
env: main: fun<main>, zero: 1, 
}
--- step lvalue zero --->
{
stack: main{ptr<0><-1> :: zero = 0;<0> :: return zero;<-1>} :: top{}
heap: 1, fun<main>, 
env: main: fun<main>, zero: 1, 
}
--- handle value ptr<0> with zero = 0;<1>(ptr<0>,) --->
{
stack: main{0<-1> :: zero = 0;<1>(ptr<0>,) :: return zero;<-1>} :: top{}
heap: 1, fun<main>, 
env: main: fun<main>, zero: 1, 
}
--- step exp 0 --->
{
stack: main{0<-1> :: zero = 0;<1>(ptr<0>,) :: return zero;<-1>} :: top{}
heap: 1, fun<main>, 
env: main: fun<main>, zero: 1, 
}
--- handle value 0 with zero = 0;<2>(ptr<0>,0,) --->
{
stack: main{return zero;<-1>} :: top{}
heap: 0, fun<main>, 
env: main: fun<main>, zero: 0, 
}
--- step stmt return zero; --->
{
stack: main{zero<-1> :: return zero;<0>} :: top{}
heap: 0, fun<main>, 
env: main: fun<main>, zero: 0, 
}
--- step exp zero --->
{
stack: main{0<-1> :: return zero;<0>} :: top{}
heap: 0, fun<main>, 
env: main: fun<main>, zero: 0, 
}
--- handle value 0 with return zero;<1>(0,) --->
{
stack: top{0<-1>}
heap: 0, fun<main>, 
env: main: fun<main>, zero: 0, 
}
result: 0
