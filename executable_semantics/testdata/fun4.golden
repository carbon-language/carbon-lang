********** source program **********
fn f () -> ();
fn main () -> Int {
f();
return 0;

}
********** type checking **********
--- step exp () --->
--- step exp Int --->
--- step exp () --->
--- step exp Int --->

********** type checking complete **********
fn f () -> () {
return ();
}
fn main () -> Int {
f();
return 0;
}
********** starting execution **********
********** initializing globals **********
--- step exp () --->
--- step exp () --->
********** calling main function **********
{
stack: top{main()<-1>}
heap: fun<f>, fun<main>, 
env: main: fun<main>, f: fun<f>, 
}
--- step exp main() --->
{
stack: top{main<-1> :: main()<0>}
heap: fun<f>, fun<main>, 
env: main: fun<main>, f: fun<f>, 
}
--- step exp main --->
{
stack: top{fun<main><-1> :: main()<0>}
heap: fun<f>, fun<main>, 
env: main: fun<main>, f: fun<f>, 
}
--- handle value fun<main> with main()<1>(fun<main>,) --->
{
stack: top{()<-1> :: main()<1>(fun<main>,)}
heap: fun<f>, fun<main>, 
env: main: fun<main>, f: fun<f>, 
}
--- step exp () --->
{
stack: top{()<-1> :: main()<1>(fun<main>,)}
heap: fun<f>, fun<main>, 
env: main: fun<main>, f: fun<f>, 
}
--- handle value () with main()<2>(fun<main>,(),) --->
pattern_match((), ())
{
stack: main{f(); ... <-1>} :: top{}
heap: fun<f>, fun<main>, 
env: main: fun<main>, f: fun<f>, 
}
--- step stmt f(); ...  --->
{
stack: main{f();<-1> :: return 0;<-1>} :: top{}
heap: fun<f>, fun<main>, 
env: main: fun<main>, f: fun<f>, 
}
--- step stmt f(); --->
{
stack: main{f()<-1> :: f();<-1> :: return 0;<-1>} :: top{}
heap: fun<f>, fun<main>, 
env: main: fun<main>, f: fun<f>, 
}
--- step exp f() --->
{
stack: main{f<-1> :: f()<0> :: f();<-1> :: return 0;<-1>} :: top{}
heap: fun<f>, fun<main>, 
env: main: fun<main>, f: fun<f>, 
}
--- step exp f --->
{
stack: main{fun<f><-1> :: f()<0> :: f();<-1> :: return 0;<-1>} :: top{}
heap: fun<f>, fun<main>, 
env: main: fun<main>, f: fun<f>, 
}
--- handle value fun<f> with f()<1>(fun<f>,) --->
{
stack: main{()<-1> :: f()<1>(fun<f>,) :: f();<-1> :: return 0;<-1>} :: top{}
heap: fun<f>, fun<main>, 
env: main: fun<main>, f: fun<f>, 
}
--- step exp () --->
{
stack: main{()<-1> :: f()<1>(fun<f>,) :: f();<-1> :: return 0;<-1>} :: top{}
heap: fun<f>, fun<main>, 
env: main: fun<main>, f: fun<f>, 
}
--- handle value () with f()<2>(fun<f>,(),) --->
pattern_match((), ())
{
stack: f{return ();<-1>} :: main{f();<-1> :: return 0;<-1>} :: top{}
heap: fun<f>, fun<main>, 
env: main: fun<main>, f: fun<f>, 
}
--- step stmt return (); --->
{
stack: f{()<-1> :: return ();<0>} :: main{f();<-1> :: return 0;<-1>} :: top{}
heap: fun<f>, fun<main>, 
env: main: fun<main>, f: fun<f>, 
}
--- step exp () --->
{
stack: f{()<-1> :: return ();<0>} :: main{f();<-1> :: return 0;<-1>} :: top{}
heap: fun<f>, fun<main>, 
env: main: fun<main>, f: fun<f>, 
}
--- handle value () with return ();<1>((),) --->
{
stack: main{()<-1> :: f();<-1> :: return 0;<-1>} :: top{}
heap: fun<f>, fun<main>, 
env: main: fun<main>, f: fun<f>, 
}
--- handle value () with f();<0>((),) --->
{
stack: main{return 0;<-1>} :: top{}
heap: fun<f>, fun<main>, 
env: main: fun<main>, f: fun<f>, 
}
--- step stmt return 0; --->
{
stack: main{0<-1> :: return 0;<0>} :: top{}
heap: fun<f>, fun<main>, 
env: main: fun<main>, f: fun<f>, 
}
--- step exp 0 --->
{
stack: main{0<-1> :: return 0;<0>} :: top{}
heap: fun<f>, fun<main>, 
env: main: fun<main>, f: fun<f>, 
}
--- handle value 0 with return 0;<1>(0,) --->
{
stack: top{0<-1>}
heap: fun<f>, fun<main>, 
env: main: fun<main>, f: fun<f>, 
}
result: 0
