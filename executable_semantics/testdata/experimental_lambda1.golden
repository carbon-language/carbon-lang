********** source program **********
fn main () -> Int {
var Int: x = 42;
var auto: f = fn (0 = Int: y)Int{ return (x + y);
};
return (f(0 = 10) - 52);

}
********** type checking **********
--- step exp Int --->
--- step exp Int --->
--- step exp Int --->
--- step exp Int --->
--- step exp Int --->
--- step exp auto --->

********** type checking complete **********
fn main () -> Int {
var Int: x = 42;
var auto: f = fn (0 = Int: y)Int{ return (x + y);
};
return (f(0 = 10) - 52);
}
********** starting execution **********
********** initializing globals **********
--- step exp () --->
********** calling main function **********
{
stack: top{main()<-1>}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step exp main() --->
{
stack: top{main<-1> :: main()<0>}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step exp main --->
{
stack: top{fun<main><-1> :: main()<0>}
heap: fun<main>, 
env: main: fun<main>, 
}
--- handle value fun<main> with main()<1>(fun<main>,) --->
{
stack: top{()<-1> :: main()<1>(fun<main>,)}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step exp () --->
{
stack: top{()<-1> :: main()<1>(fun<main>,)}
heap: fun<main>, 
env: main: fun<main>, 
}
--- handle value () with main()<2>(fun<main>,(),) --->
pattern_match((), ())
{
stack: main{var Int: x = 42; ... <-1>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step stmt var Int: x = 42; ...  --->
{
stack: main{var Int: x = 42;<-1> :: var auto: f = fn (0 = Int: y)Int{ return (x + y);
}; ... <-1>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step stmt var Int: x = 42; --->
{
stack: main{42<-1> :: var Int: x = 42;<0> :: var auto: f = fn (0 = Int: y)Int{ return (x + y);
}; ... <-1>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step exp 42 --->
{
stack: main{42<-1> :: var Int: x = 42;<0> :: var auto: f = fn (0 = Int: y)Int{ return (x + y);
}; ... <-1>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- handle value 42 with var Int: x = 42;<1>(42,) --->
{
stack: main{Int: x<-1> :: var Int: x = 42;<1>(42,) :: var auto: f = fn (0 = Int: y)Int{ return (x + y);
}; ... <-1>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step exp Int: x --->
{
stack: main{Int<-1> :: Int: x<0> :: var Int: x = 42;<1>(42,) :: var auto: f = fn (0 = Int: y)Int{ return (x + y);
}; ... <-1>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step exp Int --->
{
stack: main{Int<-1> :: Int: x<0> :: var Int: x = 42;<1>(42,) :: var auto: f = fn (0 = Int: y)Int{ return (x + y);
}; ... <-1>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- handle value Int with Int: x<1>(Int,) --->
{
stack: main{Int: x<-1> :: var Int: x = 42;<1>(42,) :: var auto: f = fn (0 = Int: y)Int{ return (x + y);
}; ... <-1>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- handle value Int: x with var Int: x = 42;<2>(42,Int: x,) --->
pattern_match(Int: x, 42)
{
stack: main{var auto: f = fn (0 = Int: y)Int{ return (x + y);
}; ... <-1>} :: top{}
heap: fun<main>, 42, 
env: x: 42, main: fun<main>, 
}
--- step stmt var auto: f = fn (0 = Int: y)Int{ return (x + y);
}; ...  --->
{
stack: main{var auto: f = fn (0 = Int: y)Int{ return (x + y);
};<-1> :: return (f(0 = 10) - 52);<-1>} :: top{}
heap: fun<main>, 42, 
env: x: 42, main: fun<main>, 
}
--- step stmt var auto: f = fn (0 = Int: y)Int{ return (x + y);
}; --->
{
stack: main{fn (0 = Int: y)Int{ return (x + y);
}<-1> :: var auto: f = fn (0 = Int: y)Int{ return (x + y);
};<0> :: return (f(0 = 10) - 52);<-1>} :: top{}
heap: fun<main>, 42, 
env: x: 42, main: fun<main>, 
}
--- step exp fn (0 = Int: y)Int{ return (x + y);
} --->
{
stack: main{(0 = Int: y)<-1> :: fn (0 = Int: y)Int{ return (x + y);
}<0> :: var auto: f = fn (0 = Int: y)Int{ return (x + y);
};<0> :: return (f(0 = 10) - 52);<-1>} :: top{}
heap: fun<main>, 42, 
env: x: 42, main: fun<main>, 
}
--- step exp (0 = Int: y) --->
{
stack: main{Int: y<-1> :: (0 = Int: y)<0> :: fn (0 = Int: y)Int{ return (x + y);
}<0> :: var auto: f = fn (0 = Int: y)Int{ return (x + y);
};<0> :: return (f(0 = 10) - 52);<-1>} :: top{}
heap: fun<main>, 42, 
env: x: 42, main: fun<main>, 
}
--- step exp Int: y --->
{
stack: main{Int<-1> :: Int: y<0> :: (0 = Int: y)<0> :: fn (0 = Int: y)Int{ return (x + y);
}<0> :: var auto: f = fn (0 = Int: y)Int{ return (x + y);
};<0> :: return (f(0 = 10) - 52);<-1>} :: top{}
heap: fun<main>, 42, 
env: x: 42, main: fun<main>, 
}
--- step exp Int --->
{
stack: main{Int<-1> :: Int: y<0> :: (0 = Int: y)<0> :: fn (0 = Int: y)Int{ return (x + y);
}<0> :: var auto: f = fn (0 = Int: y)Int{ return (x + y);
};<0> :: return (f(0 = 10) - 52);<-1>} :: top{}
heap: fun<main>, 42, 
env: x: 42, main: fun<main>, 
}
--- handle value Int with Int: y<1>(Int,) --->
{
stack: main{Int: y<-1> :: (0 = Int: y)<0> :: fn (0 = Int: y)Int{ return (x + y);
}<0> :: var auto: f = fn (0 = Int: y)Int{ return (x + y);
};<0> :: return (f(0 = 10) - 52);<-1>} :: top{}
heap: fun<main>, 42, 
env: x: 42, main: fun<main>, 
}
--- handle value Int: y with (0 = Int: y)<1>(Int: y,) --->
{
stack: main{(0 = Int: y@2)<-1> :: fn (0 = Int: y)Int{ return (x + y);
}<0> :: var auto: f = fn (0 = Int: y)Int{ return (x + y);
};<0> :: return (f(0 = 10) - 52);<-1>} :: top{}
heap: fun<main>, 42, Int: y, 
env: x: 42, main: fun<main>, 
}
--- handle value (0 = Int: y@2) with fn (0 = Int: y)Int{ return (x + y);
}<1>((0 = Int: y@2),) --->
{
stack: main{fn (0 = Int: y@2) {
return (x + y);}
<-1> :: var auto: f = fn (0 = Int: y)Int{ return (x + y);
};<0> :: return (f(0 = 10) - 52);<-1>} :: top{}
heap: fun<main>, 42, Int: y, 42, 
env: x: 42, main: fun<main>, 
}
--- handle value fn (0 = Int: y@2) {
return (x + y);}
 with var auto: f = fn (0 = Int: y)Int{ return (x + y);
};<1>(fn (0 = Int: y@2) {
return (x + y);}
,) --->
{
stack: main{auto: f<-1> :: var auto: f = fn (0 = Int: y)Int{ return (x + y);
};<1>(fn (0 = Int: y@2) {
return (x + y);}
,) :: return (f(0 = 10) - 52);<-1>} :: top{}
heap: fun<main>, 42, Int: y, 42, 
env: x: 42, main: fun<main>, 
}
--- step exp auto: f --->
{
stack: main{auto<-1> :: auto: f<0> :: var auto: f = fn (0 = Int: y)Int{ return (x + y);
};<1>(fn (0 = Int: y@2) {
return (x + y);}
,) :: return (f(0 = 10) - 52);<-1>} :: top{}
heap: fun<main>, 42, Int: y, 42, 
env: x: 42, main: fun<main>, 
}
--- step exp auto --->
{
stack: main{auto<-1> :: auto: f<0> :: var auto: f = fn (0 = Int: y)Int{ return (x + y);
};<1>(fn (0 = Int: y@2) {
return (x + y);}
,) :: return (f(0 = 10) - 52);<-1>} :: top{}
heap: fun<main>, 42, Int: y, 42, 
env: x: 42, main: fun<main>, 
}
--- handle value auto with auto: f<1>(auto,) --->
{
stack: main{auto: f<-1> :: var auto: f = fn (0 = Int: y)Int{ return (x + y);
};<1>(fn (0 = Int: y@2) {
return (x + y);}
,) :: return (f(0 = 10) - 52);<-1>} :: top{}
heap: fun<main>, 42, Int: y, 42, 
env: x: 42, main: fun<main>, 
}
--- handle value auto: f with var auto: f = fn (0 = Int: y)Int{ return (x + y);
};<2>(fn (0 = Int: y@2) {
return (x + y);}
,auto: f,) --->
pattern_match(auto: f, fn (0 = Int: y@2) {
return (x + y);}
)
{
stack: main{return (f(0 = 10) - 52);<-1>} :: top{}
heap: fun<main>, 42, Int: y, 42, fn (0 = Int: y@2) {
return (x + y);}
, 
env: f: fn (0 = Int: y@2) {
return (x + y);}
, x: 42, main: fun<main>, 
}
--- step stmt return (f(0 = 10) - 52); --->
{
stack: main{(f(0 = 10) - 52)<-1> :: return (f(0 = 10) - 52);<0>} :: top{}
heap: fun<main>, 42, Int: y, 42, fn (0 = Int: y@2) {
return (x + y);}
, 
env: f: fn (0 = Int: y@2) {
return (x + y);}
, x: 42, main: fun<main>, 
}
--- step exp (f(0 = 10) - 52) --->
{
stack: main{f(0 = 10)<-1> :: (f(0 = 10) - 52)<0> :: return (f(0 = 10) - 52);<0>} :: top{}
heap: fun<main>, 42, Int: y, 42, fn (0 = Int: y@2) {
return (x + y);}
, 
env: f: fn (0 = Int: y@2) {
return (x + y);}
, x: 42, main: fun<main>, 
}
--- step exp f(0 = 10) --->
{
stack: main{f<-1> :: f(0 = 10)<0> :: (f(0 = 10) - 52)<0> :: return (f(0 = 10) - 52);<0>} :: top{}
heap: fun<main>, 42, Int: y, 42, fn (0 = Int: y@2) {
return (x + y);}
, 
env: f: fn (0 = Int: y@2) {
return (x + y);}
, x: 42, main: fun<main>, 
}
--- step exp f --->
{
stack: main{fn (0 = Int: y@2) {
return (x + y);}
<-1> :: f(0 = 10)<0> :: (f(0 = 10) - 52)<0> :: return (f(0 = 10) - 52);<0>} :: top{}
heap: fun<main>, 42, Int: y, 42, fn (0 = Int: y@2) {
return (x + y);}
, 
env: f: fn (0 = Int: y@2) {
return (x + y);}
, x: 42, main: fun<main>, 
}
--- handle value fn (0 = Int: y@2) {
return (x + y);}
 with f(0 = 10)<1>(fn (0 = Int: y@2) {
return (x + y);}
,) --->
{
stack: main{(0 = 10)<-1> :: f(0 = 10)<1>(fn (0 = Int: y@2) {
return (x + y);}
,) :: (f(0 = 10) - 52)<0> :: return (f(0 = 10) - 52);<0>} :: top{}
heap: fun<main>, 42, Int: y, 42, fn (0 = Int: y@2) {
return (x + y);}
, 
env: f: fn (0 = Int: y@2) {
return (x + y);}
, x: 42, main: fun<main>, 
}
--- step exp (0 = 10) --->
{
stack: main{10<-1> :: (0 = 10)<0> :: f(0 = 10)<1>(fn (0 = Int: y@2) {
return (x + y);}
,) :: (f(0 = 10) - 52)<0> :: return (f(0 = 10) - 52);<0>} :: top{}
heap: fun<main>, 42, Int: y, 42, fn (0 = Int: y@2) {
return (x + y);}
, 
env: f: fn (0 = Int: y@2) {
return (x + y);}
, x: 42, main: fun<main>, 
}
--- step exp 10 --->
{
stack: main{10<-1> :: (0 = 10)<0> :: f(0 = 10)<1>(fn (0 = Int: y@2) {
return (x + y);}
,) :: (f(0 = 10) - 52)<0> :: return (f(0 = 10) - 52);<0>} :: top{}
heap: fun<main>, 42, Int: y, 42, fn (0 = Int: y@2) {
return (x + y);}
, 
env: f: fn (0 = Int: y@2) {
return (x + y);}
, x: 42, main: fun<main>, 
}
--- handle value 10 with (0 = 10)<1>(10,) --->
{
stack: main{(0 = 10@5)<-1> :: f(0 = 10)<1>(fn (0 = Int: y@2) {
return (x + y);}
,) :: (f(0 = 10) - 52)<0> :: return (f(0 = 10) - 52);<0>} :: top{}
heap: fun<main>, 42, Int: y, 42, fn (0 = Int: y@2) {
return (x + y);}
, 10, 
env: f: fn (0 = Int: y@2) {
return (x + y);}
, x: 42, main: fun<main>, 
}
--- handle value (0 = 10@5) with f(0 = 10)<2>(fn (0 = Int: y@2) {
return (x + y);}
,(0 = 10@5),) --->
pattern_match((0 = Int: y@2), (0 = 10@5))
pattern_match(Int: y, 10)
{
stack: fn{return (x + y);<-1>} :: main{(f(0 = 10) - 52)<0> :: return (f(0 = 10) - 52);<0>} :: top{}
heap: fun<main>, 42, Int: y, 42, fn (0 = Int: y@2) {
return (x + y);}
, 10, 10, 
env: y: 10, x: 42, 
}
--- step stmt return (x + y); --->
{
stack: fn{return (x + y);<-1>} :: main{(f(0 = 10) - 52)<0> :: return (f(0 = 10) - 52);<0>} :: top{}
heap: fun<main>, 42, Int: y, 42, fn (0 = Int: y@2) {
return (x + y);}
, 10, 10, 
env: y: 10, x: 42, 
}
--- step stmt return (x + y); --->
{
stack: fn{(x + y)<-1> :: return (x + y);<0>} :: main{(f(0 = 10) - 52)<0> :: return (f(0 = 10) - 52);<0>} :: top{}
heap: fun<main>, 42, Int: y, 42, fn (0 = Int: y@2) {
return (x + y);}
, 10, 10, 
env: y: 10, x: 42, 
}
--- step exp (x + y) --->
{
stack: fn{x<-1> :: (x + y)<0> :: return (x + y);<0>} :: main{(f(0 = 10) - 52)<0> :: return (f(0 = 10) - 52);<0>} :: top{}
heap: fun<main>, 42, Int: y, 42, fn (0 = Int: y@2) {
return (x + y);}
, 10, 10, 
env: y: 10, x: 42, 
}
--- step exp x --->
{
stack: fn{42<-1> :: (x + y)<0> :: return (x + y);<0>} :: main{(f(0 = 10) - 52)<0> :: return (f(0 = 10) - 52);<0>} :: top{}
heap: fun<main>, 42, Int: y, 42, fn (0 = Int: y@2) {
return (x + y);}
, 10, 10, 
env: y: 10, x: 42, 
}
--- handle value 42 with (x + y)<1>(42,) --->
{
stack: fn{y<-1> :: (x + y)<1>(42,) :: return (x + y);<0>} :: main{(f(0 = 10) - 52)<0> :: return (f(0 = 10) - 52);<0>} :: top{}
heap: fun<main>, 42, Int: y, 42, fn (0 = Int: y@2) {
return (x + y);}
, 10, 10, 
env: y: 10, x: 42, 
}
--- step exp y --->
{
stack: fn{10<-1> :: (x + y)<1>(42,) :: return (x + y);<0>} :: main{(f(0 = 10) - 52)<0> :: return (f(0 = 10) - 52);<0>} :: top{}
heap: fun<main>, 42, Int: y, 42, fn (0 = Int: y@2) {
return (x + y);}
, 10, 10, 
env: y: 10, x: 42, 
}
--- handle value 10 with (x + y)<2>(42,10,) --->
{
stack: fn{52<-1> :: return (x + y);<0>} :: main{(f(0 = 10) - 52)<0> :: return (f(0 = 10) - 52);<0>} :: top{}
heap: fun<main>, 42, Int: y, 42, fn (0 = Int: y@2) {
return (x + y);}
, 10, 10, 
env: y: 10, x: 42, 
}
--- handle value 52 with return (x + y);<1>(52,) --->
{
stack: main{52<-1> :: (f(0 = 10) - 52)<0> :: return (f(0 = 10) - 52);<0>} :: top{}
heap: fun<main>, 42, Int: y, 42, fn (0 = Int: y@2) {
return (x + y);}
, 10, !!10, 
env: f: fn (0 = Int: y@2) {
return (x + y);}
, x: 42, main: fun<main>, 
}
--- handle value 52 with (f(0 = 10) - 52)<1>(52,) --->
{
stack: main{52<-1> :: (f(0 = 10) - 52)<1>(52,) :: return (f(0 = 10) - 52);<0>} :: top{}
heap: fun<main>, 42, Int: y, 42, fn (0 = Int: y@2) {
return (x + y);}
, 10, !!10, 
env: f: fn (0 = Int: y@2) {
return (x + y);}
, x: 42, main: fun<main>, 
}
--- step exp 52 --->
{
stack: main{52<-1> :: (f(0 = 10) - 52)<1>(52,) :: return (f(0 = 10) - 52);<0>} :: top{}
heap: fun<main>, 42, Int: y, 42, fn (0 = Int: y@2) {
return (x + y);}
, 10, !!10, 
env: f: fn (0 = Int: y@2) {
return (x + y);}
, x: 42, main: fun<main>, 
}
--- handle value 52 with (f(0 = 10) - 52)<2>(52,52,) --->
{
stack: main{0<-1> :: return (f(0 = 10) - 52);<0>} :: top{}
heap: fun<main>, 42, Int: y, 42, fn (0 = Int: y@2) {
return (x + y);}
, 10, !!10, 
env: f: fn (0 = Int: y@2) {
return (x + y);}
, x: 42, main: fun<main>, 
}
--- handle value 0 with return (f(0 = 10) - 52);<1>(0,) --->
{
stack: top{0<-1>}
heap: fun<main>, !!42, Int: y, 42, !!fn (0 = Int: y@2) {
return (x + y);}
, 10, !!10, 
env: main: fun<main>, 
}
result: 0
