********** source program **********
fn main () -> Int {
var auto: t = 5;
match (t) {
case 5 =>
return 0;
case auto: _ =>
return 1;
}

}
********** type checking **********
--- step exp Int --->
--- step exp Int --->
--- step exp auto --->
--- step exp auto --->

********** type checking complete **********
fn main () -> Int {
var auto: t = 5;
match (t) {
case 5 =>
return 0;
case auto: _ =>
return 1;
}
}
********** starting execution **********
********** initializing globals **********
--- step exp () --->
********** calling main function **********
{
stack: top{main()<-1>}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step exp main() --->
{
stack: top{main<-1> :: main()<0>}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step exp main --->
{
stack: top{fun<main><-1> :: main()<0>}
heap: fun<main>, 
env: main: fun<main>, 
}
--- handle value fun<main> with main()<1>(fun<main>,) --->
{
stack: top{()<-1> :: main()<1>(fun<main>,)}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step exp () --->
{
stack: top{()<-1> :: main()<1>(fun<main>,)}
heap: fun<main>, 
env: main: fun<main>, 
}
--- handle value () with main()<2>(fun<main>,(),) --->
pattern_match((), ())
{
stack: main{var auto: t = 5; ... <-1>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step stmt var auto: t = 5; ...  --->
{
stack: main{var auto: t = 5;<-1> :: match (t) {...}<-1>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step stmt var auto: t = 5; --->
{
stack: main{5<-1> :: var auto: t = 5;<0> :: match (t) {...}<-1>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step exp 5 --->
{
stack: main{5<-1> :: var auto: t = 5;<0> :: match (t) {...}<-1>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- handle value 5 with var auto: t = 5;<1>(5,) --->
{
stack: main{auto: t<-1> :: var auto: t = 5;<1>(5,) :: match (t) {...}<-1>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step exp auto: t --->
{
stack: main{auto<-1> :: auto: t<0> :: var auto: t = 5;<1>(5,) :: match (t) {...}<-1>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step exp auto --->
{
stack: main{auto<-1> :: auto: t<0> :: var auto: t = 5;<1>(5,) :: match (t) {...}<-1>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- handle value auto with auto: t<1>(auto,) --->
{
stack: main{auto: t<-1> :: var auto: t = 5;<1>(5,) :: match (t) {...}<-1>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- handle value auto: t with var auto: t = 5;<2>(5,auto: t,) --->
pattern_match(auto: t, 5)
{
stack: main{match (t) {...}<-1>} :: top{}
heap: fun<main>, 5, 
env: t: 5, main: fun<main>, 
}
--- step stmt match (t) {...} --->
{
stack: main{t<-1> :: match (t) {...}<0>} :: top{}
heap: fun<main>, 5, 
env: t: 5, main: fun<main>, 
}
--- step exp t --->
{
stack: main{5<-1> :: match (t) {...}<0>} :: top{}
heap: fun<main>, 5, 
env: t: 5, main: fun<main>, 
}
--- handle value 5 with match (t) {...}<1>(5,) --->
{
stack: main{5<-1> :: match (t) {...}<1>(5,)} :: top{}
heap: fun<main>, 5, 
env: t: 5, main: fun<main>, 
}
--- step exp 5 --->
{
stack: main{5<-1> :: match (t) {...}<1>(5,)} :: top{}
heap: fun<main>, 5, 
env: t: 5, main: fun<main>, 
}
--- handle value 5 with match (t) {...}<2>(5,5,) --->
pattern_match(5, 5)
{
stack: main{return 0;<-1> :: {
 ... 
}
<0>} :: top{}
heap: fun<main>, 5, 
env: t: 5, main: fun<main>, 
}
--- step stmt return 0; --->
{
stack: main{0<-1> :: return 0;<0> :: {
 ... 
}
<0>} :: top{}
heap: fun<main>, 5, 
env: t: 5, main: fun<main>, 
}
--- step exp 0 --->
{
stack: main{0<-1> :: return 0;<0> :: {
 ... 
}
<0>} :: top{}
heap: fun<main>, 5, 
env: t: 5, main: fun<main>, 
}
--- handle value 0 with return 0;<1>(0,) --->
{
stack: top{0<-1>}
heap: fun<main>, !!5, 
env: main: fun<main>, 
}
result: 0
