********** source program **********
fn main () -> Int {
var auto: t = fn (0 = Int, 1 = Int) -> ();
var Int: x = 0;
match (t) {
case fn (0 = Int, 1 = Int) -> (): z =>
x = (x + 1);
}
match (t) {
case fn (0 = Type: a, 1 = Type: b) -> () =>
x = (x - 1);
}
return x;

}
********** type checking **********
--- step exp Int --->
--- step exp Int --->
--- step exp (0 = Int, 1 = Int) --->
--- step exp Int --->
--- handle value Int with (0 = Int, 1 = Int)<1>(Int,) --->
--- step exp Int --->
--- handle value Int with (0 = Int, 1 = Int)<2>(Int,Int,) --->
--- step exp () --->
--- step exp auto --->
--- step exp Int --->
--- step exp fn (0 = Int, 1 = Int) -> () --->
--- step exp (0 = Int, 1 = Int) --->
--- step exp Int --->
--- handle value Int with (0 = Int, 1 = Int)<1>(Int,) --->
--- step exp Int --->
--- handle value Int with (0 = Int, 1 = Int)<2>(Int,Int,) --->
--- handle value (0 = Int@2, 1 = Int@3) with fn (0 = Int, 1 = Int) -> ()<1>((0 = Int@2, 1 = Int@3),) --->
--- step exp () --->
--- handle value () with fn (0 = Int, 1 = Int) -> ()<2>((0 = Int@2, 1 = Int@3),(),) --->
--- step exp Type --->
--- step exp Type --->

********** type checking complete **********
fn main () -> Int {
var auto: t = fn (0 = Int, 1 = Int) -> ();
var Int: x = 0;
match (t) {
case fn (0 = Int, 1 = Int) -> (): z =>
x = (x + 1);
}
match (t) {
case fn (0 = Type: a, 1 = Type: b) -> () =>
x = (x - 1);
}
return x;
}
********** starting execution **********
********** initializing globals **********
--- step exp () --->
********** calling main function **********
{
stack: top{main()<-1>}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step exp main() --->
{
stack: top{main<-1> :: main()<0>}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step exp main --->
{
stack: top{fun<main><-1> :: main()<0>}
heap: fun<main>, 
env: main: fun<main>, 
}
--- handle value fun<main> with main()<1>(fun<main>,) --->
{
stack: top{()<-1> :: main()<1>(fun<main>,)}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step exp () --->
{
stack: top{()<-1> :: main()<1>(fun<main>,)}
heap: fun<main>, 
env: main: fun<main>, 
}
--- handle value () with main()<2>(fun<main>,(),) --->
pattern_match((), ())
{
stack: main{var auto: t = fn (0 = Int, 1 = Int) -> (); ... <-1>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step stmt var auto: t = fn (0 = Int, 1 = Int) -> (); ...  --->
{
stack: main{var auto: t = fn (0 = Int, 1 = Int) -> ();<-1> :: var Int: x = 0; ... <-1>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step stmt var auto: t = fn (0 = Int, 1 = Int) -> (); --->
{
stack: main{fn (0 = Int, 1 = Int) -> ()<-1> :: var auto: t = fn (0 = Int, 1 = Int) -> ();<0> :: var Int: x = 0; ... <-1>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step exp fn (0 = Int, 1 = Int) -> () --->
{
stack: main{(0 = Int, 1 = Int)<-1> :: fn (0 = Int, 1 = Int) -> ()<0> :: var auto: t = fn (0 = Int, 1 = Int) -> ();<0> :: var Int: x = 0; ... <-1>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step exp (0 = Int, 1 = Int) --->
{
stack: main{Int<-1> :: (0 = Int, 1 = Int)<0> :: fn (0 = Int, 1 = Int) -> ()<0> :: var auto: t = fn (0 = Int, 1 = Int) -> ();<0> :: var Int: x = 0; ... <-1>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step exp Int --->
{
stack: main{Int<-1> :: (0 = Int, 1 = Int)<0> :: fn (0 = Int, 1 = Int) -> ()<0> :: var auto: t = fn (0 = Int, 1 = Int) -> ();<0> :: var Int: x = 0; ... <-1>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- handle value Int with (0 = Int, 1 = Int)<1>(Int,) --->
{
stack: main{Int<-1> :: (0 = Int, 1 = Int)<1>(Int,) :: fn (0 = Int, 1 = Int) -> ()<0> :: var auto: t = fn (0 = Int, 1 = Int) -> ();<0> :: var Int: x = 0; ... <-1>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step exp Int --->
{
stack: main{Int<-1> :: (0 = Int, 1 = Int)<1>(Int,) :: fn (0 = Int, 1 = Int) -> ()<0> :: var auto: t = fn (0 = Int, 1 = Int) -> ();<0> :: var Int: x = 0; ... <-1>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- handle value Int with (0 = Int, 1 = Int)<2>(Int,Int,) --->
{
stack: main{(0 = Int@1, 1 = Int@2)<-1> :: fn (0 = Int, 1 = Int) -> ()<0> :: var auto: t = fn (0 = Int, 1 = Int) -> ();<0> :: var Int: x = 0; ... <-1>} :: top{}
heap: fun<main>, Int, Int, 
env: main: fun<main>, 
}
--- handle value (0 = Int@1, 1 = Int@2) with fn (0 = Int, 1 = Int) -> ()<1>((0 = Int@1, 1 = Int@2),) --->
{
stack: main{()<-1> :: fn (0 = Int, 1 = Int) -> ()<1>((0 = Int@1, 1 = Int@2),) :: var auto: t = fn (0 = Int, 1 = Int) -> ();<0> :: var Int: x = 0; ... <-1>} :: top{}
heap: fun<main>, Int, Int, 
env: main: fun<main>, 
}
--- step exp () --->
{
stack: main{()<-1> :: fn (0 = Int, 1 = Int) -> ()<1>((0 = Int@1, 1 = Int@2),) :: var auto: t = fn (0 = Int, 1 = Int) -> ();<0> :: var Int: x = 0; ... <-1>} :: top{}
heap: fun<main>, Int, Int, 
env: main: fun<main>, 
}
--- handle value () with fn (0 = Int, 1 = Int) -> ()<2>((0 = Int@1, 1 = Int@2),(),) --->
{
stack: main{fn (0 = Int@1, 1 = Int@2) -> ()<-1> :: var auto: t = fn (0 = Int, 1 = Int) -> ();<0> :: var Int: x = 0; ... <-1>} :: top{}
heap: fun<main>, Int, Int, 
env: main: fun<main>, 
}
--- handle value fn (0 = Int@1, 1 = Int@2) -> () with var auto: t = fn (0 = Int, 1 = Int) -> ();<1>(fn (0 = Int@1, 1 = Int@2) -> (),) --->
{
stack: main{auto: t<-1> :: var auto: t = fn (0 = Int, 1 = Int) -> ();<1>(fn (0 = Int@1, 1 = Int@2) -> (),) :: var Int: x = 0; ... <-1>} :: top{}
heap: fun<main>, Int, Int, 
env: main: fun<main>, 
}
--- step exp auto: t --->
{
stack: main{auto<-1> :: auto: t<0> :: var auto: t = fn (0 = Int, 1 = Int) -> ();<1>(fn (0 = Int@1, 1 = Int@2) -> (),) :: var Int: x = 0; ... <-1>} :: top{}
heap: fun<main>, Int, Int, 
env: main: fun<main>, 
}
--- step exp auto --->
{
stack: main{auto<-1> :: auto: t<0> :: var auto: t = fn (0 = Int, 1 = Int) -> ();<1>(fn (0 = Int@1, 1 = Int@2) -> (),) :: var Int: x = 0; ... <-1>} :: top{}
heap: fun<main>, Int, Int, 
env: main: fun<main>, 
}
--- handle value auto with auto: t<1>(auto,) --->
{
stack: main{auto: t<-1> :: var auto: t = fn (0 = Int, 1 = Int) -> ();<1>(fn (0 = Int@1, 1 = Int@2) -> (),) :: var Int: x = 0; ... <-1>} :: top{}
heap: fun<main>, Int, Int, 
env: main: fun<main>, 
}
--- handle value auto: t with var auto: t = fn (0 = Int, 1 = Int) -> ();<2>(fn (0 = Int@1, 1 = Int@2) -> (),auto: t,) --->
pattern_match(auto: t, fn (0 = Int@1, 1 = Int@2) -> ())
{
stack: main{var Int: x = 0; ... <-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 
env: t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- step stmt var Int: x = 0; ...  --->
{
stack: main{var Int: x = 0;<-1> :: match (t) {...} ... <-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 
env: t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- step stmt var Int: x = 0; --->
{
stack: main{0<-1> :: var Int: x = 0;<0> :: match (t) {...} ... <-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 
env: t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- step exp 0 --->
{
stack: main{0<-1> :: var Int: x = 0;<0> :: match (t) {...} ... <-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 
env: t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- handle value 0 with var Int: x = 0;<1>(0,) --->
{
stack: main{Int: x<-1> :: var Int: x = 0;<1>(0,) :: match (t) {...} ... <-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 
env: t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- step exp Int: x --->
{
stack: main{Int<-1> :: Int: x<0> :: var Int: x = 0;<1>(0,) :: match (t) {...} ... <-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 
env: t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- step exp Int --->
{
stack: main{Int<-1> :: Int: x<0> :: var Int: x = 0;<1>(0,) :: match (t) {...} ... <-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 
env: t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- handle value Int with Int: x<1>(Int,) --->
{
stack: main{Int: x<-1> :: var Int: x = 0;<1>(0,) :: match (t) {...} ... <-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 
env: t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- handle value Int: x with var Int: x = 0;<2>(0,Int: x,) --->
pattern_match(Int: x, 0)
{
stack: main{match (t) {...} ... <-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 0, 
env: x: 0, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- step stmt match (t) {...} ...  --->
{
stack: main{match (t) {...}<-1> :: match (t) {...} ... <-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 0, 
env: x: 0, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- step stmt match (t) {...} --->
{
stack: main{t<-1> :: match (t) {...}<0> :: match (t) {...} ... <-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 0, 
env: x: 0, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- step exp t --->
{
stack: main{fn (0 = Int@3, 1 = Int@4) -> ()<-1> :: match (t) {...}<0> :: match (t) {...} ... <-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 0, 
env: x: 0, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- handle value fn (0 = Int@3, 1 = Int@4) -> () with match (t) {...}<1>(fn (0 = Int@3, 1 = Int@4) -> (),) --->
{
stack: main{fn (0 = Int, 1 = Int) -> (): z<-1> :: match (t) {...}<1>(fn (0 = Int@3, 1 = Int@4) -> (),) :: match (t) {...} ... <-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 0, 
env: x: 0, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- step exp fn (0 = Int, 1 = Int) -> (): z --->
{
stack: main{fn (0 = Int, 1 = Int) -> ()<-1> :: fn (0 = Int, 1 = Int) -> (): z<0> :: match (t) {...}<1>(fn (0 = Int@3, 1 = Int@4) -> (),) :: match (t) {...} ... <-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 0, 
env: x: 0, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- step exp fn (0 = Int, 1 = Int) -> () --->
{
stack: main{(0 = Int, 1 = Int)<-1> :: fn (0 = Int, 1 = Int) -> ()<0> :: fn (0 = Int, 1 = Int) -> (): z<0> :: match (t) {...}<1>(fn (0 = Int@3, 1 = Int@4) -> (),) :: match (t) {...} ... <-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 0, 
env: x: 0, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- step exp (0 = Int, 1 = Int) --->
{
stack: main{Int<-1> :: (0 = Int, 1 = Int)<0> :: fn (0 = Int, 1 = Int) -> ()<0> :: fn (0 = Int, 1 = Int) -> (): z<0> :: match (t) {...}<1>(fn (0 = Int@3, 1 = Int@4) -> (),) :: match (t) {...} ... <-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 0, 
env: x: 0, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- step exp Int --->
{
stack: main{Int<-1> :: (0 = Int, 1 = Int)<0> :: fn (0 = Int, 1 = Int) -> ()<0> :: fn (0 = Int, 1 = Int) -> (): z<0> :: match (t) {...}<1>(fn (0 = Int@3, 1 = Int@4) -> (),) :: match (t) {...} ... <-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 0, 
env: x: 0, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- handle value Int with (0 = Int, 1 = Int)<1>(Int,) --->
{
stack: main{Int<-1> :: (0 = Int, 1 = Int)<1>(Int,) :: fn (0 = Int, 1 = Int) -> ()<0> :: fn (0 = Int, 1 = Int) -> (): z<0> :: match (t) {...}<1>(fn (0 = Int@3, 1 = Int@4) -> (),) :: match (t) {...} ... <-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 0, 
env: x: 0, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- step exp Int --->
{
stack: main{Int<-1> :: (0 = Int, 1 = Int)<1>(Int,) :: fn (0 = Int, 1 = Int) -> ()<0> :: fn (0 = Int, 1 = Int) -> (): z<0> :: match (t) {...}<1>(fn (0 = Int@3, 1 = Int@4) -> (),) :: match (t) {...} ... <-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 0, 
env: x: 0, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- handle value Int with (0 = Int, 1 = Int)<2>(Int,Int,) --->
{
stack: main{(0 = Int@7, 1 = Int@8)<-1> :: fn (0 = Int, 1 = Int) -> ()<0> :: fn (0 = Int, 1 = Int) -> (): z<0> :: match (t) {...}<1>(fn (0 = Int@3, 1 = Int@4) -> (),) :: match (t) {...} ... <-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 0, Int, Int, 
env: x: 0, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- handle value (0 = Int@7, 1 = Int@8) with fn (0 = Int, 1 = Int) -> ()<1>((0 = Int@7, 1 = Int@8),) --->
{
stack: main{()<-1> :: fn (0 = Int, 1 = Int) -> ()<1>((0 = Int@7, 1 = Int@8),) :: fn (0 = Int, 1 = Int) -> (): z<0> :: match (t) {...}<1>(fn (0 = Int@3, 1 = Int@4) -> (),) :: match (t) {...} ... <-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 0, Int, Int, 
env: x: 0, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- step exp () --->
{
stack: main{()<-1> :: fn (0 = Int, 1 = Int) -> ()<1>((0 = Int@7, 1 = Int@8),) :: fn (0 = Int, 1 = Int) -> (): z<0> :: match (t) {...}<1>(fn (0 = Int@3, 1 = Int@4) -> (),) :: match (t) {...} ... <-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 0, Int, Int, 
env: x: 0, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- handle value () with fn (0 = Int, 1 = Int) -> ()<2>((0 = Int@7, 1 = Int@8),(),) --->
{
stack: main{fn (0 = Int@7, 1 = Int@8) -> ()<-1> :: fn (0 = Int, 1 = Int) -> (): z<0> :: match (t) {...}<1>(fn (0 = Int@3, 1 = Int@4) -> (),) :: match (t) {...} ... <-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 0, Int, Int, 
env: x: 0, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- handle value fn (0 = Int@7, 1 = Int@8) -> () with fn (0 = Int, 1 = Int) -> (): z<1>(fn (0 = Int@7, 1 = Int@8) -> (),) --->
{
stack: main{fn (0 = Int@7, 1 = Int@8) -> (): z<-1> :: match (t) {...}<1>(fn (0 = Int@3, 1 = Int@4) -> (),) :: match (t) {...} ... <-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 0, Int, Int, 
env: x: 0, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- handle value fn (0 = Int@7, 1 = Int@8) -> (): z with match (t) {...}<2>(fn (0 = Int@3, 1 = Int@4) -> (),fn (0 = Int@7, 1 = Int@8) -> (): z,) --->
pattern_match(fn (0 = Int@7, 1 = Int@8) -> (): z, fn (0 = Int@3, 1 = Int@4) -> ())
{
stack: main{x = (x + 1);<-1> :: {
 ... 
}
<0> :: match (t) {...} ... <-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 0, Int, Int, Int, Int, fn (0 = Int@9, 1 = Int@10) -> (), 
env: z: fn (0 = Int@9, 1 = Int@10) -> (), x: 0, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- step stmt x = (x + 1); --->
{
stack: main{x<-1> :: x = (x + 1);<0> :: {
 ... 
}
<0> :: match (t) {...} ... <-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 0, Int, Int, Int, Int, fn (0 = Int@9, 1 = Int@10) -> (), 
env: z: fn (0 = Int@9, 1 = Int@10) -> (), x: 0, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- step lvalue x --->
{
stack: main{ptr<6><-1> :: x = (x + 1);<0> :: {
 ... 
}
<0> :: match (t) {...} ... <-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 0, Int, Int, Int, Int, fn (0 = Int@9, 1 = Int@10) -> (), 
env: z: fn (0 = Int@9, 1 = Int@10) -> (), x: 0, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- handle value ptr<6> with x = (x + 1);<1>(ptr<6>,) --->
{
stack: main{(x + 1)<-1> :: x = (x + 1);<1>(ptr<6>,) :: {
 ... 
}
<0> :: match (t) {...} ... <-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 0, Int, Int, Int, Int, fn (0 = Int@9, 1 = Int@10) -> (), 
env: z: fn (0 = Int@9, 1 = Int@10) -> (), x: 0, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- step exp (x + 1) --->
{
stack: main{x<-1> :: (x + 1)<0> :: x = (x + 1);<1>(ptr<6>,) :: {
 ... 
}
<0> :: match (t) {...} ... <-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 0, Int, Int, Int, Int, fn (0 = Int@9, 1 = Int@10) -> (), 
env: z: fn (0 = Int@9, 1 = Int@10) -> (), x: 0, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- step exp x --->
{
stack: main{0<-1> :: (x + 1)<0> :: x = (x + 1);<1>(ptr<6>,) :: {
 ... 
}
<0> :: match (t) {...} ... <-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 0, Int, Int, Int, Int, fn (0 = Int@9, 1 = Int@10) -> (), 
env: z: fn (0 = Int@9, 1 = Int@10) -> (), x: 0, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- handle value 0 with (x + 1)<1>(0,) --->
{
stack: main{1<-1> :: (x + 1)<1>(0,) :: x = (x + 1);<1>(ptr<6>,) :: {
 ... 
}
<0> :: match (t) {...} ... <-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 0, Int, Int, Int, Int, fn (0 = Int@9, 1 = Int@10) -> (), 
env: z: fn (0 = Int@9, 1 = Int@10) -> (), x: 0, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- step exp 1 --->
{
stack: main{1<-1> :: (x + 1)<1>(0,) :: x = (x + 1);<1>(ptr<6>,) :: {
 ... 
}
<0> :: match (t) {...} ... <-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 0, Int, Int, Int, Int, fn (0 = Int@9, 1 = Int@10) -> (), 
env: z: fn (0 = Int@9, 1 = Int@10) -> (), x: 0, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- handle value 1 with (x + 1)<2>(0,1,) --->
{
stack: main{1<-1> :: x = (x + 1);<1>(ptr<6>,) :: {
 ... 
}
<0> :: match (t) {...} ... <-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 0, Int, Int, Int, Int, fn (0 = Int@9, 1 = Int@10) -> (), 
env: z: fn (0 = Int@9, 1 = Int@10) -> (), x: 0, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- handle value 1 with x = (x + 1);<2>(ptr<6>,1,) --->
{
stack: main{{
 ... 
}
<0> :: match (t) {...} ... <-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 1, Int, Int, Int, Int, fn (0 = Int@9, 1 = Int@10) -> (), 
env: z: fn (0 = Int@9, 1 = Int@10) -> (), x: 1, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- step stmt {
 ... 
}
 --->
{
stack: main{match (t) {...} ... <-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 1, Int, Int, Int, Int, !!fn (0 = Int@9, 1 = Int@10) -> (), 
env: x: 1, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- step stmt match (t) {...} ...  --->
{
stack: main{match (t) {...}<-1> :: return x;<-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 1, Int, Int, Int, Int, !!fn (0 = Int@9, 1 = Int@10) -> (), 
env: x: 1, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- step stmt match (t) {...} --->
{
stack: main{t<-1> :: match (t) {...}<0> :: return x;<-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 1, Int, Int, Int, Int, !!fn (0 = Int@9, 1 = Int@10) -> (), 
env: x: 1, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- step exp t --->
{
stack: main{fn (0 = Int@3, 1 = Int@4) -> ()<-1> :: match (t) {...}<0> :: return x;<-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 1, Int, Int, Int, Int, !!fn (0 = Int@9, 1 = Int@10) -> (), 
env: x: 1, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- handle value fn (0 = Int@3, 1 = Int@4) -> () with match (t) {...}<1>(fn (0 = Int@3, 1 = Int@4) -> (),) --->
{
stack: main{fn (0 = Type: a, 1 = Type: b) -> ()<-1> :: match (t) {...}<1>(fn (0 = Int@3, 1 = Int@4) -> (),) :: return x;<-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 1, Int, Int, Int, Int, !!fn (0 = Int@9, 1 = Int@10) -> (), 
env: x: 1, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- step exp fn (0 = Type: a, 1 = Type: b) -> () --->
{
stack: main{(0 = Type: a, 1 = Type: b)<-1> :: fn (0 = Type: a, 1 = Type: b) -> ()<0> :: match (t) {...}<1>(fn (0 = Int@3, 1 = Int@4) -> (),) :: return x;<-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 1, Int, Int, Int, Int, !!fn (0 = Int@9, 1 = Int@10) -> (), 
env: x: 1, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- step exp (0 = Type: a, 1 = Type: b) --->
{
stack: main{Type: a<-1> :: (0 = Type: a, 1 = Type: b)<0> :: fn (0 = Type: a, 1 = Type: b) -> ()<0> :: match (t) {...}<1>(fn (0 = Int@3, 1 = Int@4) -> (),) :: return x;<-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 1, Int, Int, Int, Int, !!fn (0 = Int@9, 1 = Int@10) -> (), 
env: x: 1, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- step exp Type: a --->
{
stack: main{Type<-1> :: Type: a<0> :: (0 = Type: a, 1 = Type: b)<0> :: fn (0 = Type: a, 1 = Type: b) -> ()<0> :: match (t) {...}<1>(fn (0 = Int@3, 1 = Int@4) -> (),) :: return x;<-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 1, Int, Int, Int, Int, !!fn (0 = Int@9, 1 = Int@10) -> (), 
env: x: 1, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- step exp Type --->
{
stack: main{Type<-1> :: Type: a<0> :: (0 = Type: a, 1 = Type: b)<0> :: fn (0 = Type: a, 1 = Type: b) -> ()<0> :: match (t) {...}<1>(fn (0 = Int@3, 1 = Int@4) -> (),) :: return x;<-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 1, Int, Int, Int, Int, !!fn (0 = Int@9, 1 = Int@10) -> (), 
env: x: 1, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- handle value Type with Type: a<1>(Type,) --->
{
stack: main{Type: a<-1> :: (0 = Type: a, 1 = Type: b)<0> :: fn (0 = Type: a, 1 = Type: b) -> ()<0> :: match (t) {...}<1>(fn (0 = Int@3, 1 = Int@4) -> (),) :: return x;<-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 1, Int, Int, Int, Int, !!fn (0 = Int@9, 1 = Int@10) -> (), 
env: x: 1, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- handle value Type: a with (0 = Type: a, 1 = Type: b)<1>(Type: a,) --->
{
stack: main{Type: b<-1> :: (0 = Type: a, 1 = Type: b)<1>(Type: a,) :: fn (0 = Type: a, 1 = Type: b) -> ()<0> :: match (t) {...}<1>(fn (0 = Int@3, 1 = Int@4) -> (),) :: return x;<-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 1, Int, Int, Int, Int, !!fn (0 = Int@9, 1 = Int@10) -> (), 
env: x: 1, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- step exp Type: b --->
{
stack: main{Type<-1> :: Type: b<0> :: (0 = Type: a, 1 = Type: b)<1>(Type: a,) :: fn (0 = Type: a, 1 = Type: b) -> ()<0> :: match (t) {...}<1>(fn (0 = Int@3, 1 = Int@4) -> (),) :: return x;<-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 1, Int, Int, Int, Int, !!fn (0 = Int@9, 1 = Int@10) -> (), 
env: x: 1, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- step exp Type --->
{
stack: main{Type<-1> :: Type: b<0> :: (0 = Type: a, 1 = Type: b)<1>(Type: a,) :: fn (0 = Type: a, 1 = Type: b) -> ()<0> :: match (t) {...}<1>(fn (0 = Int@3, 1 = Int@4) -> (),) :: return x;<-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 1, Int, Int, Int, Int, !!fn (0 = Int@9, 1 = Int@10) -> (), 
env: x: 1, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- handle value Type with Type: b<1>(Type,) --->
{
stack: main{Type: b<-1> :: (0 = Type: a, 1 = Type: b)<1>(Type: a,) :: fn (0 = Type: a, 1 = Type: b) -> ()<0> :: match (t) {...}<1>(fn (0 = Int@3, 1 = Int@4) -> (),) :: return x;<-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 1, Int, Int, Int, Int, !!fn (0 = Int@9, 1 = Int@10) -> (), 
env: x: 1, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- handle value Type: b with (0 = Type: a, 1 = Type: b)<2>(Type: a,Type: b,) --->
{
stack: main{(0 = Type: a@12, 1 = Type: b@13)<-1> :: fn (0 = Type: a, 1 = Type: b) -> ()<0> :: match (t) {...}<1>(fn (0 = Int@3, 1 = Int@4) -> (),) :: return x;<-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 1, Int, Int, Int, Int, !!fn (0 = Int@9, 1 = Int@10) -> (), Type: a, Type: b, 
env: x: 1, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- handle value (0 = Type: a@12, 1 = Type: b@13) with fn (0 = Type: a, 1 = Type: b) -> ()<1>((0 = Type: a@12, 1 = Type: b@13),) --->
{
stack: main{()<-1> :: fn (0 = Type: a, 1 = Type: b) -> ()<1>((0 = Type: a@12, 1 = Type: b@13),) :: match (t) {...}<1>(fn (0 = Int@3, 1 = Int@4) -> (),) :: return x;<-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 1, Int, Int, Int, Int, !!fn (0 = Int@9, 1 = Int@10) -> (), Type: a, Type: b, 
env: x: 1, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- step exp () --->
{
stack: main{()<-1> :: fn (0 = Type: a, 1 = Type: b) -> ()<1>((0 = Type: a@12, 1 = Type: b@13),) :: match (t) {...}<1>(fn (0 = Int@3, 1 = Int@4) -> (),) :: return x;<-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 1, Int, Int, Int, Int, !!fn (0 = Int@9, 1 = Int@10) -> (), Type: a, Type: b, 
env: x: 1, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- handle value () with fn (0 = Type: a, 1 = Type: b) -> ()<2>((0 = Type: a@12, 1 = Type: b@13),(),) --->
{
stack: main{fn (0 = Type: a@12, 1 = Type: b@13) -> ()<-1> :: match (t) {...}<1>(fn (0 = Int@3, 1 = Int@4) -> (),) :: return x;<-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 1, Int, Int, Int, Int, !!fn (0 = Int@9, 1 = Int@10) -> (), Type: a, Type: b, 
env: x: 1, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- handle value fn (0 = Type: a@12, 1 = Type: b@13) -> () with match (t) {...}<2>(fn (0 = Int@3, 1 = Int@4) -> (),fn (0 = Type: a@12, 1 = Type: b@13) -> (),) --->
pattern_match(fn (0 = Type: a@12, 1 = Type: b@13) -> (), fn (0 = Int@3, 1 = Int@4) -> ())
pattern_match((0 = Type: a@12, 1 = Type: b@13), (0 = Int@3, 1 = Int@4))
pattern_match(Type: a, Int)
pattern_match(Type: b, Int)
pattern_match((), ())
{
stack: main{x = (x - 1);<-1> :: {
 ... 
}
<0> :: return x;<-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 1, Int, Int, Int, Int, !!fn (0 = Int@9, 1 = Int@10) -> (), Type: a, Type: b, Int, Int, 
env: b: Int, a: Int, x: 1, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- step stmt x = (x - 1); --->
{
stack: main{x<-1> :: x = (x - 1);<0> :: {
 ... 
}
<0> :: return x;<-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 1, Int, Int, Int, Int, !!fn (0 = Int@9, 1 = Int@10) -> (), Type: a, Type: b, Int, Int, 
env: b: Int, a: Int, x: 1, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- step lvalue x --->
{
stack: main{ptr<6><-1> :: x = (x - 1);<0> :: {
 ... 
}
<0> :: return x;<-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 1, Int, Int, Int, Int, !!fn (0 = Int@9, 1 = Int@10) -> (), Type: a, Type: b, Int, Int, 
env: b: Int, a: Int, x: 1, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- handle value ptr<6> with x = (x - 1);<1>(ptr<6>,) --->
{
stack: main{(x - 1)<-1> :: x = (x - 1);<1>(ptr<6>,) :: {
 ... 
}
<0> :: return x;<-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 1, Int, Int, Int, Int, !!fn (0 = Int@9, 1 = Int@10) -> (), Type: a, Type: b, Int, Int, 
env: b: Int, a: Int, x: 1, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- step exp (x - 1) --->
{
stack: main{x<-1> :: (x - 1)<0> :: x = (x - 1);<1>(ptr<6>,) :: {
 ... 
}
<0> :: return x;<-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 1, Int, Int, Int, Int, !!fn (0 = Int@9, 1 = Int@10) -> (), Type: a, Type: b, Int, Int, 
env: b: Int, a: Int, x: 1, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- step exp x --->
{
stack: main{1<-1> :: (x - 1)<0> :: x = (x - 1);<1>(ptr<6>,) :: {
 ... 
}
<0> :: return x;<-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 1, Int, Int, Int, Int, !!fn (0 = Int@9, 1 = Int@10) -> (), Type: a, Type: b, Int, Int, 
env: b: Int, a: Int, x: 1, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- handle value 1 with (x - 1)<1>(1,) --->
{
stack: main{1<-1> :: (x - 1)<1>(1,) :: x = (x - 1);<1>(ptr<6>,) :: {
 ... 
}
<0> :: return x;<-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 1, Int, Int, Int, Int, !!fn (0 = Int@9, 1 = Int@10) -> (), Type: a, Type: b, Int, Int, 
env: b: Int, a: Int, x: 1, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- step exp 1 --->
{
stack: main{1<-1> :: (x - 1)<1>(1,) :: x = (x - 1);<1>(ptr<6>,) :: {
 ... 
}
<0> :: return x;<-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 1, Int, Int, Int, Int, !!fn (0 = Int@9, 1 = Int@10) -> (), Type: a, Type: b, Int, Int, 
env: b: Int, a: Int, x: 1, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- handle value 1 with (x - 1)<2>(1,1,) --->
{
stack: main{0<-1> :: x = (x - 1);<1>(ptr<6>,) :: {
 ... 
}
<0> :: return x;<-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 1, Int, Int, Int, Int, !!fn (0 = Int@9, 1 = Int@10) -> (), Type: a, Type: b, Int, Int, 
env: b: Int, a: Int, x: 1, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- handle value 0 with x = (x - 1);<2>(ptr<6>,0,) --->
{
stack: main{{
 ... 
}
<0> :: return x;<-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 0, Int, Int, Int, Int, !!fn (0 = Int@9, 1 = Int@10) -> (), Type: a, Type: b, Int, Int, 
env: b: Int, a: Int, x: 0, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- step stmt {
 ... 
}
 --->
{
stack: main{return x;<-1>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 0, Int, Int, Int, Int, !!fn (0 = Int@9, 1 = Int@10) -> (), Type: a, Type: b, !!Int, !!Int, 
env: x: 0, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- step stmt return x; --->
{
stack: main{x<-1> :: return x;<0>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 0, Int, Int, Int, Int, !!fn (0 = Int@9, 1 = Int@10) -> (), Type: a, Type: b, !!Int, !!Int, 
env: x: 0, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- step exp x --->
{
stack: main{0<-1> :: return x;<0>} :: top{}
heap: fun<main>, Int, Int, Int, Int, fn (0 = Int@3, 1 = Int@4) -> (), 0, Int, Int, Int, Int, !!fn (0 = Int@9, 1 = Int@10) -> (), Type: a, Type: b, !!Int, !!Int, 
env: x: 0, t: fn (0 = Int@3, 1 = Int@4) -> (), main: fun<main>, 
}
--- handle value 0 with return x;<1>(0,) --->
{
stack: top{0<-1>}
heap: fun<main>, Int, Int, Int, Int, !!fn (0 = Int@3, 1 = Int@4) -> (), !!0, Int, Int, Int, Int, !!fn (0 = Int@9, 1 = Int@10) -> (), Type: a, Type: b, !!Int, !!Int, 
env: main: fun<main>, 
}
result: 0
