********** source program **********
fn main () -> Int {
var (0 = auto: x, 1 = auto: y) = (0 = 2, 1 = 3);
return ((y - x) - 1);

}
********** type checking **********
--- step exp Int --->
--- step exp Int --->
--- step exp auto --->
--- step exp auto --->

********** type checking complete **********
fn main () -> Int {
var (0 = auto: x, 1 = auto: y) = (0 = 2, 1 = 3);
return ((y - x) - 1);
}
********** starting execution **********
********** initializing globals **********
--- step exp () --->
********** calling main function **********
{
stack: top{main()<-1>}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step exp main() --->
{
stack: top{main<-1> :: main()<0>}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step exp main --->
{
stack: top{fun<main><-1> :: main()<0>}
heap: fun<main>, 
env: main: fun<main>, 
}
--- handle value fun<main> with main()<1>(fun<main>,) --->
{
stack: top{()<-1> :: main()<1>(fun<main>,)}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step exp () --->
{
stack: top{()<-1> :: main()<1>(fun<main>,)}
heap: fun<main>, 
env: main: fun<main>, 
}
--- handle value () with main()<2>(fun<main>,(),) --->
pattern_match((), ())
{
stack: main{var (0 = auto: x, 1 = auto: y) = (0 = 2, 1 = 3); ... <-1>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step stmt var (0 = auto: x, 1 = auto: y) = (0 = 2, 1 = 3); ...  --->
{
stack: main{var (0 = auto: x, 1 = auto: y) = (0 = 2, 1 = 3);<-1> :: return ((y - x) - 1);<-1>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step stmt var (0 = auto: x, 1 = auto: y) = (0 = 2, 1 = 3); --->
{
stack: main{(0 = 2, 1 = 3)<-1> :: var (0 = auto: x, 1 = auto: y) = (0 = 2, 1 = 3);<0> :: return ((y - x) - 1);<-1>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step exp (0 = 2, 1 = 3) --->
{
stack: main{2<-1> :: (0 = 2, 1 = 3)<0> :: var (0 = auto: x, 1 = auto: y) = (0 = 2, 1 = 3);<0> :: return ((y - x) - 1);<-1>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step exp 2 --->
{
stack: main{2<-1> :: (0 = 2, 1 = 3)<0> :: var (0 = auto: x, 1 = auto: y) = (0 = 2, 1 = 3);<0> :: return ((y - x) - 1);<-1>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- handle value 2 with (0 = 2, 1 = 3)<1>(2,) --->
{
stack: main{3<-1> :: (0 = 2, 1 = 3)<1>(2,) :: var (0 = auto: x, 1 = auto: y) = (0 = 2, 1 = 3);<0> :: return ((y - x) - 1);<-1>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step exp 3 --->
{
stack: main{3<-1> :: (0 = 2, 1 = 3)<1>(2,) :: var (0 = auto: x, 1 = auto: y) = (0 = 2, 1 = 3);<0> :: return ((y - x) - 1);<-1>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- handle value 3 with (0 = 2, 1 = 3)<2>(2,3,) --->
{
stack: main{(0 = 2@1, 1 = 3@2)<-1> :: var (0 = auto: x, 1 = auto: y) = (0 = 2, 1 = 3);<0> :: return ((y - x) - 1);<-1>} :: top{}
heap: fun<main>, 2, 3, 
env: main: fun<main>, 
}
--- handle value (0 = 2@1, 1 = 3@2) with var (0 = auto: x, 1 = auto: y) = (0 = 2, 1 = 3);<1>((0 = 2@1, 1 = 3@2),) --->
{
stack: main{(0 = auto: x, 1 = auto: y)<-1> :: var (0 = auto: x, 1 = auto: y) = (0 = 2, 1 = 3);<1>((0 = 2@1, 1 = 3@2),) :: return ((y - x) - 1);<-1>} :: top{}
heap: fun<main>, 2, 3, 
env: main: fun<main>, 
}
--- step exp (0 = auto: x, 1 = auto: y) --->
{
stack: main{auto: x<-1> :: (0 = auto: x, 1 = auto: y)<0> :: var (0 = auto: x, 1 = auto: y) = (0 = 2, 1 = 3);<1>((0 = 2@1, 1 = 3@2),) :: return ((y - x) - 1);<-1>} :: top{}
heap: fun<main>, 2, 3, 
env: main: fun<main>, 
}
--- step exp auto: x --->
{
stack: main{auto<-1> :: auto: x<0> :: (0 = auto: x, 1 = auto: y)<0> :: var (0 = auto: x, 1 = auto: y) = (0 = 2, 1 = 3);<1>((0 = 2@1, 1 = 3@2),) :: return ((y - x) - 1);<-1>} :: top{}
heap: fun<main>, 2, 3, 
env: main: fun<main>, 
}
--- step exp auto --->
{
stack: main{auto<-1> :: auto: x<0> :: (0 = auto: x, 1 = auto: y)<0> :: var (0 = auto: x, 1 = auto: y) = (0 = 2, 1 = 3);<1>((0 = 2@1, 1 = 3@2),) :: return ((y - x) - 1);<-1>} :: top{}
heap: fun<main>, 2, 3, 
env: main: fun<main>, 
}
--- handle value auto with auto: x<1>(auto,) --->
{
stack: main{auto: x<-1> :: (0 = auto: x, 1 = auto: y)<0> :: var (0 = auto: x, 1 = auto: y) = (0 = 2, 1 = 3);<1>((0 = 2@1, 1 = 3@2),) :: return ((y - x) - 1);<-1>} :: top{}
heap: fun<main>, 2, 3, 
env: main: fun<main>, 
}
--- handle value auto: x with (0 = auto: x, 1 = auto: y)<1>(auto: x,) --->
{
stack: main{auto: y<-1> :: (0 = auto: x, 1 = auto: y)<1>(auto: x,) :: var (0 = auto: x, 1 = auto: y) = (0 = 2, 1 = 3);<1>((0 = 2@1, 1 = 3@2),) :: return ((y - x) - 1);<-1>} :: top{}
heap: fun<main>, 2, 3, 
env: main: fun<main>, 
}
--- step exp auto: y --->
{
stack: main{auto<-1> :: auto: y<0> :: (0 = auto: x, 1 = auto: y)<1>(auto: x,) :: var (0 = auto: x, 1 = auto: y) = (0 = 2, 1 = 3);<1>((0 = 2@1, 1 = 3@2),) :: return ((y - x) - 1);<-1>} :: top{}
heap: fun<main>, 2, 3, 
env: main: fun<main>, 
}
--- step exp auto --->
{
stack: main{auto<-1> :: auto: y<0> :: (0 = auto: x, 1 = auto: y)<1>(auto: x,) :: var (0 = auto: x, 1 = auto: y) = (0 = 2, 1 = 3);<1>((0 = 2@1, 1 = 3@2),) :: return ((y - x) - 1);<-1>} :: top{}
heap: fun<main>, 2, 3, 
env: main: fun<main>, 
}
--- handle value auto with auto: y<1>(auto,) --->
{
stack: main{auto: y<-1> :: (0 = auto: x, 1 = auto: y)<1>(auto: x,) :: var (0 = auto: x, 1 = auto: y) = (0 = 2, 1 = 3);<1>((0 = 2@1, 1 = 3@2),) :: return ((y - x) - 1);<-1>} :: top{}
heap: fun<main>, 2, 3, 
env: main: fun<main>, 
}
--- handle value auto: y with (0 = auto: x, 1 = auto: y)<2>(auto: x,auto: y,) --->
{
stack: main{(0 = auto: x@3, 1 = auto: y@4)<-1> :: var (0 = auto: x, 1 = auto: y) = (0 = 2, 1 = 3);<1>((0 = 2@1, 1 = 3@2),) :: return ((y - x) - 1);<-1>} :: top{}
heap: fun<main>, 2, 3, auto: x, auto: y, 
env: main: fun<main>, 
}
--- handle value (0 = auto: x@3, 1 = auto: y@4) with var (0 = auto: x, 1 = auto: y) = (0 = 2, 1 = 3);<2>((0 = 2@1, 1 = 3@2),(0 = auto: x@3, 1 = auto: y@4),) --->
pattern_match((0 = auto: x@3, 1 = auto: y@4), (0 = 2@1, 1 = 3@2))
pattern_match(auto: x, 2)
pattern_match(auto: y, 3)
{
stack: main{return ((y - x) - 1);<-1>} :: top{}
heap: fun<main>, 2, 3, auto: x, auto: y, 2, 3, 
env: y: 3, x: 2, main: fun<main>, 
}
--- step stmt return ((y - x) - 1); --->
{
stack: main{((y - x) - 1)<-1> :: return ((y - x) - 1);<0>} :: top{}
heap: fun<main>, 2, 3, auto: x, auto: y, 2, 3, 
env: y: 3, x: 2, main: fun<main>, 
}
--- step exp ((y - x) - 1) --->
{
stack: main{(y - x)<-1> :: ((y - x) - 1)<0> :: return ((y - x) - 1);<0>} :: top{}
heap: fun<main>, 2, 3, auto: x, auto: y, 2, 3, 
env: y: 3, x: 2, main: fun<main>, 
}
--- step exp (y - x) --->
{
stack: main{y<-1> :: (y - x)<0> :: ((y - x) - 1)<0> :: return ((y - x) - 1);<0>} :: top{}
heap: fun<main>, 2, 3, auto: x, auto: y, 2, 3, 
env: y: 3, x: 2, main: fun<main>, 
}
--- step exp y --->
{
stack: main{3<-1> :: (y - x)<0> :: ((y - x) - 1)<0> :: return ((y - x) - 1);<0>} :: top{}
heap: fun<main>, 2, 3, auto: x, auto: y, 2, 3, 
env: y: 3, x: 2, main: fun<main>, 
}
--- handle value 3 with (y - x)<1>(3,) --->
{
stack: main{x<-1> :: (y - x)<1>(3,) :: ((y - x) - 1)<0> :: return ((y - x) - 1);<0>} :: top{}
heap: fun<main>, 2, 3, auto: x, auto: y, 2, 3, 
env: y: 3, x: 2, main: fun<main>, 
}
--- step exp x --->
{
stack: main{2<-1> :: (y - x)<1>(3,) :: ((y - x) - 1)<0> :: return ((y - x) - 1);<0>} :: top{}
heap: fun<main>, 2, 3, auto: x, auto: y, 2, 3, 
env: y: 3, x: 2, main: fun<main>, 
}
--- handle value 2 with (y - x)<2>(3,2,) --->
{
stack: main{1<-1> :: ((y - x) - 1)<0> :: return ((y - x) - 1);<0>} :: top{}
heap: fun<main>, 2, 3, auto: x, auto: y, 2, 3, 
env: y: 3, x: 2, main: fun<main>, 
}
--- handle value 1 with ((y - x) - 1)<1>(1,) --->
{
stack: main{1<-1> :: ((y - x) - 1)<1>(1,) :: return ((y - x) - 1);<0>} :: top{}
heap: fun<main>, 2, 3, auto: x, auto: y, 2, 3, 
env: y: 3, x: 2, main: fun<main>, 
}
--- step exp 1 --->
{
stack: main{1<-1> :: ((y - x) - 1)<1>(1,) :: return ((y - x) - 1);<0>} :: top{}
heap: fun<main>, 2, 3, auto: x, auto: y, 2, 3, 
env: y: 3, x: 2, main: fun<main>, 
}
--- handle value 1 with ((y - x) - 1)<2>(1,1,) --->
{
stack: main{0<-1> :: return ((y - x) - 1);<0>} :: top{}
heap: fun<main>, 2, 3, auto: x, auto: y, 2, 3, 
env: y: 3, x: 2, main: fun<main>, 
}
--- handle value 0 with return ((y - x) - 1);<1>(0,) --->
{
stack: top{0<-1>}
heap: fun<main>, 2, 3, auto: x, auto: y, !!2, !!3, 
env: main: fun<main>, 
}
result: 0
