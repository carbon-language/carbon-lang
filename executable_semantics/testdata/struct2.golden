********** source program **********
struct Point {
var x : Int;
var y : Int;
}
fn main () -> Int {
var auto: p1 = Point(x = 1, y = 2);
var auto: p2 = p1;
p2.x = 3;
return (p1.x - 1);

}
********** type checking **********
--- step exp Int --->
--- step exp Int --->
--- step exp Int --->
--- step exp Int --->
--- step exp auto --->
--- step exp auto --->

********** type checking complete **********
struct Point {
var x : Int;
var y : Int;
}
fn main () -> Int {
var auto: p1 = Point(x = 1, y = 2);
var auto: p2 = p1;
p2.x = 3;
return (p1.x - 1);
}
********** starting execution **********
********** initializing globals **********
--- step exp Int --->
--- step exp Int --->
--- step exp () --->
********** calling main function **********
{
stack: top{main()<-1>}
heap: struct Point, fun<main>, 
env: main: fun<main>, Point: struct Point, 
}
--- step exp main() --->
{
stack: top{main<-1> :: main()<0>}
heap: struct Point, fun<main>, 
env: main: fun<main>, Point: struct Point, 
}
--- step exp main --->
{
stack: top{fun<main><-1> :: main()<0>}
heap: struct Point, fun<main>, 
env: main: fun<main>, Point: struct Point, 
}
--- handle value fun<main> with main()<1>(fun<main>,) --->
{
stack: top{()<-1> :: main()<1>(fun<main>,)}
heap: struct Point, fun<main>, 
env: main: fun<main>, Point: struct Point, 
}
--- step exp () --->
{
stack: top{()<-1> :: main()<1>(fun<main>,)}
heap: struct Point, fun<main>, 
env: main: fun<main>, Point: struct Point, 
}
--- handle value () with main()<2>(fun<main>,(),) --->
pattern_match((), ())
{
stack: main{var auto: p1 = Point(x = 1, y = 2); ... <-1>} :: top{}
heap: struct Point, fun<main>, 
env: main: fun<main>, Point: struct Point, 
}
--- step stmt var auto: p1 = Point(x = 1, y = 2); ...  --->
{
stack: main{var auto: p1 = Point(x = 1, y = 2);<-1> :: var auto: p2 = p1; ... <-1>} :: top{}
heap: struct Point, fun<main>, 
env: main: fun<main>, Point: struct Point, 
}
--- step stmt var auto: p1 = Point(x = 1, y = 2); --->
{
stack: main{Point(x = 1, y = 2)<-1> :: var auto: p1 = Point(x = 1, y = 2);<0> :: var auto: p2 = p1; ... <-1>} :: top{}
heap: struct Point, fun<main>, 
env: main: fun<main>, Point: struct Point, 
}
--- step exp Point(x = 1, y = 2) --->
{
stack: main{Point<-1> :: Point(x = 1, y = 2)<0> :: var auto: p1 = Point(x = 1, y = 2);<0> :: var auto: p2 = p1; ... <-1>} :: top{}
heap: struct Point, fun<main>, 
env: main: fun<main>, Point: struct Point, 
}
--- step exp Point --->
{
stack: main{struct Point<-1> :: Point(x = 1, y = 2)<0> :: var auto: p1 = Point(x = 1, y = 2);<0> :: var auto: p2 = p1; ... <-1>} :: top{}
heap: struct Point, fun<main>, 
env: main: fun<main>, Point: struct Point, 
}
--- handle value struct Point with Point(x = 1, y = 2)<1>(struct Point,) --->
{
stack: main{(x = 1, y = 2)<-1> :: Point(x = 1, y = 2)<1>(struct Point,) :: var auto: p1 = Point(x = 1, y = 2);<0> :: var auto: p2 = p1; ... <-1>} :: top{}
heap: struct Point, fun<main>, 
env: main: fun<main>, Point: struct Point, 
}
--- step exp (x = 1, y = 2) --->
{
stack: main{1<-1> :: (x = 1, y = 2)<0> :: Point(x = 1, y = 2)<1>(struct Point,) :: var auto: p1 = Point(x = 1, y = 2);<0> :: var auto: p2 = p1; ... <-1>} :: top{}
heap: struct Point, fun<main>, 
env: main: fun<main>, Point: struct Point, 
}
--- step exp 1 --->
{
stack: main{1<-1> :: (x = 1, y = 2)<0> :: Point(x = 1, y = 2)<1>(struct Point,) :: var auto: p1 = Point(x = 1, y = 2);<0> :: var auto: p2 = p1; ... <-1>} :: top{}
heap: struct Point, fun<main>, 
env: main: fun<main>, Point: struct Point, 
}
--- handle value 1 with (x = 1, y = 2)<1>(1,) --->
{
stack: main{2<-1> :: (x = 1, y = 2)<1>(1,) :: Point(x = 1, y = 2)<1>(struct Point,) :: var auto: p1 = Point(x = 1, y = 2);<0> :: var auto: p2 = p1; ... <-1>} :: top{}
heap: struct Point, fun<main>, 
env: main: fun<main>, Point: struct Point, 
}
--- step exp 2 --->
{
stack: main{2<-1> :: (x = 1, y = 2)<1>(1,) :: Point(x = 1, y = 2)<1>(struct Point,) :: var auto: p1 = Point(x = 1, y = 2);<0> :: var auto: p2 = p1; ... <-1>} :: top{}
heap: struct Point, fun<main>, 
env: main: fun<main>, Point: struct Point, 
}
--- handle value 2 with (x = 1, y = 2)<2>(1,2,) --->
{
stack: main{(x = 1@2, y = 2@3)<-1> :: Point(x = 1, y = 2)<1>(struct Point,) :: var auto: p1 = Point(x = 1, y = 2);<0> :: var auto: p2 = p1; ... <-1>} :: top{}
heap: struct Point, fun<main>, 1, 2, 
env: main: fun<main>, Point: struct Point, 
}
--- handle value (x = 1@2, y = 2@3) with Point(x = 1, y = 2)<2>(struct Point,(x = 1@2, y = 2@3),) --->
{
stack: main{Point(x = 1@4, y = 2@5)<-1> :: var auto: p1 = Point(x = 1, y = 2);<0> :: var auto: p2 = p1; ... <-1>} :: top{}
heap: struct Point, fun<main>, 1, 2, 1, 2, 
env: main: fun<main>, Point: struct Point, 
}
--- handle value Point(x = 1@4, y = 2@5) with var auto: p1 = Point(x = 1, y = 2);<1>(Point(x = 1@4, y = 2@5),) --->
{
stack: main{auto: p1<-1> :: var auto: p1 = Point(x = 1, y = 2);<1>(Point(x = 1@4, y = 2@5),) :: var auto: p2 = p1; ... <-1>} :: top{}
heap: struct Point, fun<main>, 1, 2, 1, 2, 
env: main: fun<main>, Point: struct Point, 
}
--- step exp auto: p1 --->
{
stack: main{auto<-1> :: auto: p1<0> :: var auto: p1 = Point(x = 1, y = 2);<1>(Point(x = 1@4, y = 2@5),) :: var auto: p2 = p1; ... <-1>} :: top{}
heap: struct Point, fun<main>, 1, 2, 1, 2, 
env: main: fun<main>, Point: struct Point, 
}
--- step exp auto --->
{
stack: main{auto<-1> :: auto: p1<0> :: var auto: p1 = Point(x = 1, y = 2);<1>(Point(x = 1@4, y = 2@5),) :: var auto: p2 = p1; ... <-1>} :: top{}
heap: struct Point, fun<main>, 1, 2, 1, 2, 
env: main: fun<main>, Point: struct Point, 
}
--- handle value auto with auto: p1<1>(auto,) --->
{
stack: main{auto: p1<-1> :: var auto: p1 = Point(x = 1, y = 2);<1>(Point(x = 1@4, y = 2@5),) :: var auto: p2 = p1; ... <-1>} :: top{}
heap: struct Point, fun<main>, 1, 2, 1, 2, 
env: main: fun<main>, Point: struct Point, 
}
--- handle value auto: p1 with var auto: p1 = Point(x = 1, y = 2);<2>(Point(x = 1@4, y = 2@5),auto: p1,) --->
pattern_match(auto: p1, Point(x = 1@4, y = 2@5))
{
stack: main{var auto: p2 = p1; ... <-1>} :: top{}
heap: struct Point, fun<main>, 1, 2, 1, 2, 1, 2, Point(x = 1@6, y = 2@7), 
env: p1: Point(x = 1@6, y = 2@7), main: fun<main>, Point: struct Point, 
}
--- step stmt var auto: p2 = p1; ...  --->
{
stack: main{var auto: p2 = p1;<-1> :: p2.x = 3; ... <-1>} :: top{}
heap: struct Point, fun<main>, 1, 2, 1, 2, 1, 2, Point(x = 1@6, y = 2@7), 
env: p1: Point(x = 1@6, y = 2@7), main: fun<main>, Point: struct Point, 
}
--- step stmt var auto: p2 = p1; --->
{
stack: main{p1<-1> :: var auto: p2 = p1;<0> :: p2.x = 3; ... <-1>} :: top{}
heap: struct Point, fun<main>, 1, 2, 1, 2, 1, 2, Point(x = 1@6, y = 2@7), 
env: p1: Point(x = 1@6, y = 2@7), main: fun<main>, Point: struct Point, 
}
--- step exp p1 --->
{
stack: main{Point(x = 1@6, y = 2@7)<-1> :: var auto: p2 = p1;<0> :: p2.x = 3; ... <-1>} :: top{}
heap: struct Point, fun<main>, 1, 2, 1, 2, 1, 2, Point(x = 1@6, y = 2@7), 
env: p1: Point(x = 1@6, y = 2@7), main: fun<main>, Point: struct Point, 
}
--- handle value Point(x = 1@6, y = 2@7) with var auto: p2 = p1;<1>(Point(x = 1@6, y = 2@7),) --->
{
stack: main{auto: p2<-1> :: var auto: p2 = p1;<1>(Point(x = 1@6, y = 2@7),) :: p2.x = 3; ... <-1>} :: top{}
heap: struct Point, fun<main>, 1, 2, 1, 2, 1, 2, Point(x = 1@6, y = 2@7), 
env: p1: Point(x = 1@6, y = 2@7), main: fun<main>, Point: struct Point, 
}
--- step exp auto: p2 --->
{
stack: main{auto<-1> :: auto: p2<0> :: var auto: p2 = p1;<1>(Point(x = 1@6, y = 2@7),) :: p2.x = 3; ... <-1>} :: top{}
heap: struct Point, fun<main>, 1, 2, 1, 2, 1, 2, Point(x = 1@6, y = 2@7), 
env: p1: Point(x = 1@6, y = 2@7), main: fun<main>, Point: struct Point, 
}
--- step exp auto --->
{
stack: main{auto<-1> :: auto: p2<0> :: var auto: p2 = p1;<1>(Point(x = 1@6, y = 2@7),) :: p2.x = 3; ... <-1>} :: top{}
heap: struct Point, fun<main>, 1, 2, 1, 2, 1, 2, Point(x = 1@6, y = 2@7), 
env: p1: Point(x = 1@6, y = 2@7), main: fun<main>, Point: struct Point, 
}
--- handle value auto with auto: p2<1>(auto,) --->
{
stack: main{auto: p2<-1> :: var auto: p2 = p1;<1>(Point(x = 1@6, y = 2@7),) :: p2.x = 3; ... <-1>} :: top{}
heap: struct Point, fun<main>, 1, 2, 1, 2, 1, 2, Point(x = 1@6, y = 2@7), 
env: p1: Point(x = 1@6, y = 2@7), main: fun<main>, Point: struct Point, 
}
--- handle value auto: p2 with var auto: p2 = p1;<2>(Point(x = 1@6, y = 2@7),auto: p2,) --->
pattern_match(auto: p2, Point(x = 1@6, y = 2@7))
{
stack: main{p2.x = 3; ... <-1>} :: top{}
heap: struct Point, fun<main>, 1, 2, 1, 2, 1, 2, Point(x = 1@6, y = 2@7), 1, 2, Point(x = 1@9, y = 2@10), 
env: p2: Point(x = 1@9, y = 2@10), p1: Point(x = 1@6, y = 2@7), main: fun<main>, Point: struct Point, 
}
--- step stmt p2.x = 3; ...  --->
{
stack: main{p2.x = 3;<-1> :: return (p1.x - 1);<-1>} :: top{}
heap: struct Point, fun<main>, 1, 2, 1, 2, 1, 2, Point(x = 1@6, y = 2@7), 1, 2, Point(x = 1@9, y = 2@10), 
env: p2: Point(x = 1@9, y = 2@10), p1: Point(x = 1@6, y = 2@7), main: fun<main>, Point: struct Point, 
}
--- step stmt p2.x = 3; --->
{
stack: main{p2.x<-1> :: p2.x = 3;<0> :: return (p1.x - 1);<-1>} :: top{}
heap: struct Point, fun<main>, 1, 2, 1, 2, 1, 2, Point(x = 1@6, y = 2@7), 1, 2, Point(x = 1@9, y = 2@10), 
env: p2: Point(x = 1@9, y = 2@10), p1: Point(x = 1@6, y = 2@7), main: fun<main>, Point: struct Point, 
}
--- step lvalue p2.x --->
{
stack: main{p2<-1> :: p2.x<0> :: p2.x = 3;<0> :: return (p1.x - 1);<-1>} :: top{}
heap: struct Point, fun<main>, 1, 2, 1, 2, 1, 2, Point(x = 1@6, y = 2@7), 1, 2, Point(x = 1@9, y = 2@10), 
env: p2: Point(x = 1@9, y = 2@10), p1: Point(x = 1@6, y = 2@7), main: fun<main>, Point: struct Point, 
}
--- step lvalue p2 --->
{
stack: main{ptr<11><-1> :: p2.x<0> :: p2.x = 3;<0> :: return (p1.x - 1);<-1>} :: top{}
heap: struct Point, fun<main>, 1, 2, 1, 2, 1, 2, Point(x = 1@6, y = 2@7), 1, 2, Point(x = 1@9, y = 2@10), 
env: p2: Point(x = 1@9, y = 2@10), p1: Point(x = 1@6, y = 2@7), main: fun<main>, Point: struct Point, 
}
--- handle value ptr<11> with p2.x<1>(ptr<11>,) --->
{
stack: main{ptr<9><-1> :: p2.x = 3;<0> :: return (p1.x - 1);<-1>} :: top{}
heap: struct Point, fun<main>, 1, 2, 1, 2, 1, 2, Point(x = 1@6, y = 2@7), 1, 2, Point(x = 1@9, y = 2@10), 
env: p2: Point(x = 1@9, y = 2@10), p1: Point(x = 1@6, y = 2@7), main: fun<main>, Point: struct Point, 
}
--- handle value ptr<9> with p2.x = 3;<1>(ptr<9>,) --->
{
stack: main{3<-1> :: p2.x = 3;<1>(ptr<9>,) :: return (p1.x - 1);<-1>} :: top{}
heap: struct Point, fun<main>, 1, 2, 1, 2, 1, 2, Point(x = 1@6, y = 2@7), 1, 2, Point(x = 1@9, y = 2@10), 
env: p2: Point(x = 1@9, y = 2@10), p1: Point(x = 1@6, y = 2@7), main: fun<main>, Point: struct Point, 
}
--- step exp 3 --->
{
stack: main{3<-1> :: p2.x = 3;<1>(ptr<9>,) :: return (p1.x - 1);<-1>} :: top{}
heap: struct Point, fun<main>, 1, 2, 1, 2, 1, 2, Point(x = 1@6, y = 2@7), 1, 2, Point(x = 1@9, y = 2@10), 
env: p2: Point(x = 1@9, y = 2@10), p1: Point(x = 1@6, y = 2@7), main: fun<main>, Point: struct Point, 
}
--- handle value 3 with p2.x = 3;<2>(ptr<9>,3,) --->
{
stack: main{return (p1.x - 1);<-1>} :: top{}
heap: struct Point, fun<main>, 1, 2, 1, 2, 1, 2, Point(x = 1@6, y = 2@7), 3, 2, Point(x = 3@9, y = 2@10), 
env: p2: Point(x = 3@9, y = 2@10), p1: Point(x = 1@6, y = 2@7), main: fun<main>, Point: struct Point, 
}
--- step stmt return (p1.x - 1); --->
{
stack: main{(p1.x - 1)<-1> :: return (p1.x - 1);<0>} :: top{}
heap: struct Point, fun<main>, 1, 2, 1, 2, 1, 2, Point(x = 1@6, y = 2@7), 3, 2, Point(x = 3@9, y = 2@10), 
env: p2: Point(x = 3@9, y = 2@10), p1: Point(x = 1@6, y = 2@7), main: fun<main>, Point: struct Point, 
}
--- step exp (p1.x - 1) --->
{
stack: main{p1.x<-1> :: (p1.x - 1)<0> :: return (p1.x - 1);<0>} :: top{}
heap: struct Point, fun<main>, 1, 2, 1, 2, 1, 2, Point(x = 1@6, y = 2@7), 3, 2, Point(x = 3@9, y = 2@10), 
env: p2: Point(x = 3@9, y = 2@10), p1: Point(x = 1@6, y = 2@7), main: fun<main>, Point: struct Point, 
}
--- step exp p1.x --->
{
stack: main{p1<-1> :: p1.x<0> :: (p1.x - 1)<0> :: return (p1.x - 1);<0>} :: top{}
heap: struct Point, fun<main>, 1, 2, 1, 2, 1, 2, Point(x = 1@6, y = 2@7), 3, 2, Point(x = 3@9, y = 2@10), 
env: p2: Point(x = 3@9, y = 2@10), p1: Point(x = 1@6, y = 2@7), main: fun<main>, Point: struct Point, 
}
--- step lvalue p1 --->
{
stack: main{ptr<8><-1> :: p1.x<0> :: (p1.x - 1)<0> :: return (p1.x - 1);<0>} :: top{}
heap: struct Point, fun<main>, 1, 2, 1, 2, 1, 2, Point(x = 1@6, y = 2@7), 3, 2, Point(x = 3@9, y = 2@10), 
env: p2: Point(x = 3@9, y = 2@10), p1: Point(x = 1@6, y = 2@7), main: fun<main>, Point: struct Point, 
}
--- handle value ptr<8> with p1.x<1>(ptr<8>,) --->
{
stack: main{1<-1> :: (p1.x - 1)<0> :: return (p1.x - 1);<0>} :: top{}
heap: struct Point, fun<main>, 1, 2, 1, 2, 1, 2, Point(x = 1@6, y = 2@7), 3, 2, Point(x = 3@9, y = 2@10), 
env: p2: Point(x = 3@9, y = 2@10), p1: Point(x = 1@6, y = 2@7), main: fun<main>, Point: struct Point, 
}
--- handle value 1 with (p1.x - 1)<1>(1,) --->
{
stack: main{1<-1> :: (p1.x - 1)<1>(1,) :: return (p1.x - 1);<0>} :: top{}
heap: struct Point, fun<main>, 1, 2, 1, 2, 1, 2, Point(x = 1@6, y = 2@7), 3, 2, Point(x = 3@9, y = 2@10), 
env: p2: Point(x = 3@9, y = 2@10), p1: Point(x = 1@6, y = 2@7), main: fun<main>, Point: struct Point, 
}
--- step exp 1 --->
{
stack: main{1<-1> :: (p1.x - 1)<1>(1,) :: return (p1.x - 1);<0>} :: top{}
heap: struct Point, fun<main>, 1, 2, 1, 2, 1, 2, Point(x = 1@6, y = 2@7), 3, 2, Point(x = 3@9, y = 2@10), 
env: p2: Point(x = 3@9, y = 2@10), p1: Point(x = 1@6, y = 2@7), main: fun<main>, Point: struct Point, 
}
--- handle value 1 with (p1.x - 1)<2>(1,1,) --->
{
stack: main{0<-1> :: return (p1.x - 1);<0>} :: top{}
heap: struct Point, fun<main>, 1, 2, 1, 2, 1, 2, Point(x = 1@6, y = 2@7), 3, 2, Point(x = 3@9, y = 2@10), 
env: p2: Point(x = 3@9, y = 2@10), p1: Point(x = 1@6, y = 2@7), main: fun<main>, Point: struct Point, 
}
--- handle value 0 with return (p1.x - 1);<1>(0,) --->
{
stack: top{0<-1>}
heap: struct Point, fun<main>, 1, 2, 1, 2, !!1, !!2, !!Point!!(x = !!1@6, y = !!2@7), !!3, !!2, !!Point!!(x = !!3@9, y = !!2@10), 
env: main: fun<main>, Point: struct Point, 
}
result: 0
