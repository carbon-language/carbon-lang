********** source program **********
fn main () -> Int {
var Int: x = 0;
delimit
{
x = (x + 1);
suspend;
x = (x + 1);
return (x - 3);

}

with (k)
{
x = (x + 1);
resume k;
return 1;

}



}
********** type checking **********
--- step exp Int --->
--- step exp Int --->
--- step exp Int --->

********** type checking complete **********
fn main () -> Int {
var Int: x = 0;
delimit
{
x = (x + 1);
suspend;
x = (x + 1);
return (x - 3);
}

with (k)
{
x = (x + 1);
resume k;
return 1;
}


}
********** starting execution **********
********** initializing globals **********
--- step exp () --->
********** calling main function **********
{
stack: top{main()<-1>}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step exp main() --->
{
stack: top{main<-1> :: main()<0>}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step exp main --->
{
stack: top{fun<main><-1> :: main()<0>}
heap: fun<main>, 
env: main: fun<main>, 
}
--- handle value fun<main> with main()<1>(fun<main>,) --->
{
stack: top{()<-1> :: main()<1>(fun<main>,)}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step exp () --->
{
stack: top{()<-1> :: main()<1>(fun<main>,)}
heap: fun<main>, 
env: main: fun<main>, 
}
--- handle value () with main()<2>(fun<main>,(),) --->
pattern_match((), ())
{
stack: main{var Int: x = 0; ... <-1>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step stmt var Int: x = 0; ...  --->
{
stack: main{var Int: x = 0;<-1> :: delimit
 ... 
with (k)
 ... 
<-1>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step stmt var Int: x = 0; --->
{
stack: main{0<-1> :: var Int: x = 0;<0> :: delimit
 ... 
with (k)
 ... 
<-1>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step exp 0 --->
{
stack: main{0<-1> :: var Int: x = 0;<0> :: delimit
 ... 
with (k)
 ... 
<-1>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- handle value 0 with var Int: x = 0;<1>(0,) --->
{
stack: main{Int: x<-1> :: var Int: x = 0;<1>(0,) :: delimit
 ... 
with (k)
 ... 
<-1>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step exp Int: x --->
{
stack: main{Int<-1> :: Int: x<0> :: var Int: x = 0;<1>(0,) :: delimit
 ... 
with (k)
 ... 
<-1>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step exp Int --->
{
stack: main{Int<-1> :: Int: x<0> :: var Int: x = 0;<1>(0,) :: delimit
 ... 
with (k)
 ... 
<-1>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- handle value Int with Int: x<1>(Int,) --->
{
stack: main{Int: x<-1> :: var Int: x = 0;<1>(0,) :: delimit
 ... 
with (k)
 ... 
<-1>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- handle value Int: x with var Int: x = 0;<2>(0,Int: x,) --->
pattern_match(Int: x, 0)
{
stack: main{delimit
 ... 
with (k)
 ... 
<-1>} :: top{}
heap: fun<main>, 0, 
env: x: 0, main: fun<main>, 
}
--- step stmt delimit
 ... 
with (k)
 ... 
 --->
{
stack: main{{
 ... 
}
<-1> :: delimit
 ... 
with (k)
 ... 
<0>} :: top{}
heap: fun<main>, 0, 
env: x: 0, main: fun<main>, 
}
--- step stmt {
 ... 
}
 --->
{
stack: main{x = (x + 1); ... <-1> :: {
 ... 
}
<0> :: delimit
 ... 
with (k)
 ... 
<0>} :: top{}
heap: fun<main>, 0, 
env: x: 0, main: fun<main>, 
}
--- step stmt x = (x + 1); ...  --->
{
stack: main{x = (x + 1);<-1> :: suspend; ... <-1> :: {
 ... 
}
<0> :: delimit
 ... 
with (k)
 ... 
<0>} :: top{}
heap: fun<main>, 0, 
env: x: 0, main: fun<main>, 
}
--- step stmt x = (x + 1); --->
{
stack: main{x<-1> :: x = (x + 1);<0> :: suspend; ... <-1> :: {
 ... 
}
<0> :: delimit
 ... 
with (k)
 ... 
<0>} :: top{}
heap: fun<main>, 0, 
env: x: 0, main: fun<main>, 
}
--- step lvalue x --->
{
stack: main{ptr<1><-1> :: x = (x + 1);<0> :: suspend; ... <-1> :: {
 ... 
}
<0> :: delimit
 ... 
with (k)
 ... 
<0>} :: top{}
heap: fun<main>, 0, 
env: x: 0, main: fun<main>, 
}
--- handle value ptr<1> with x = (x + 1);<1>(ptr<1>,) --->
{
stack: main{(x + 1)<-1> :: x = (x + 1);<1>(ptr<1>,) :: suspend; ... <-1> :: {
 ... 
}
<0> :: delimit
 ... 
with (k)
 ... 
<0>} :: top{}
heap: fun<main>, 0, 
env: x: 0, main: fun<main>, 
}
--- step exp (x + 1) --->
{
stack: main{x<-1> :: (x + 1)<0> :: x = (x + 1);<1>(ptr<1>,) :: suspend; ... <-1> :: {
 ... 
}
<0> :: delimit
 ... 
with (k)
 ... 
<0>} :: top{}
heap: fun<main>, 0, 
env: x: 0, main: fun<main>, 
}
--- step exp x --->
{
stack: main{0<-1> :: (x + 1)<0> :: x = (x + 1);<1>(ptr<1>,) :: suspend; ... <-1> :: {
 ... 
}
<0> :: delimit
 ... 
with (k)
 ... 
<0>} :: top{}
heap: fun<main>, 0, 
env: x: 0, main: fun<main>, 
}
--- handle value 0 with (x + 1)<1>(0,) --->
{
stack: main{1<-1> :: (x + 1)<1>(0,) :: x = (x + 1);<1>(ptr<1>,) :: suspend; ... <-1> :: {
 ... 
}
<0> :: delimit
 ... 
with (k)
 ... 
<0>} :: top{}
heap: fun<main>, 0, 
env: x: 0, main: fun<main>, 
}
--- step exp 1 --->
{
stack: main{1<-1> :: (x + 1)<1>(0,) :: x = (x + 1);<1>(ptr<1>,) :: suspend; ... <-1> :: {
 ... 
}
<0> :: delimit
 ... 
with (k)
 ... 
<0>} :: top{}
heap: fun<main>, 0, 
env: x: 0, main: fun<main>, 
}
--- handle value 1 with (x + 1)<2>(0,1,) --->
{
stack: main{1<-1> :: x = (x + 1);<1>(ptr<1>,) :: suspend; ... <-1> :: {
 ... 
}
<0> :: delimit
 ... 
with (k)
 ... 
<0>} :: top{}
heap: fun<main>, 0, 
env: x: 0, main: fun<main>, 
}
--- handle value 1 with x = (x + 1);<2>(ptr<1>,1,) --->
{
stack: main{suspend; ... <-1> :: {
 ... 
}
<0> :: delimit
 ... 
with (k)
 ... 
<0>} :: top{}
heap: fun<main>, 1, 
env: x: 1, main: fun<main>, 
}
--- step stmt suspend; ...  --->
{
stack: main{suspend;<-1> :: x = (x + 1); ... <-1> :: {
 ... 
}
<0> :: delimit
 ... 
with (k)
 ... 
<0>} :: top{}
heap: fun<main>, 1, 
env: x: 1, main: fun<main>, 
}
--- step stmt suspend; --->
{
stack: main{continuation<-1> :: delimit
 ... 
with (k)
 ... 
<0>} :: top{}
heap: fun<main>, 1, 
env: x: 1, main: fun<main>, 
}
--- handle value continuation with delimit
 ... 
with (k)
 ... 
<1>(continuation,) --->
{
stack: main{{
 ... 
}
<-1>} :: top{}
heap: fun<main>, 1, continuation, 
env: k: continuation, x: 1, main: fun<main>, 
}
--- step stmt {
 ... 
}
 --->
{
stack: main{{
 ... 
}
<-1> :: {
 ... 
}
<0>} :: top{}
heap: fun<main>, 1, continuation, 
env: k: continuation, x: 1, main: fun<main>, 
}
--- step stmt {
 ... 
}
 --->
{
stack: main{x = (x + 1); ... <-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0>} :: top{}
heap: fun<main>, 1, continuation, 
env: k: continuation, x: 1, main: fun<main>, 
}
--- step stmt x = (x + 1); ...  --->
{
stack: main{x = (x + 1);<-1> :: resume k; ... <-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0>} :: top{}
heap: fun<main>, 1, continuation, 
env: k: continuation, x: 1, main: fun<main>, 
}
--- step stmt x = (x + 1); --->
{
stack: main{x<-1> :: x = (x + 1);<0> :: resume k; ... <-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0>} :: top{}
heap: fun<main>, 1, continuation, 
env: k: continuation, x: 1, main: fun<main>, 
}
--- step lvalue x --->
{
stack: main{ptr<1><-1> :: x = (x + 1);<0> :: resume k; ... <-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0>} :: top{}
heap: fun<main>, 1, continuation, 
env: k: continuation, x: 1, main: fun<main>, 
}
--- handle value ptr<1> with x = (x + 1);<1>(ptr<1>,) --->
{
stack: main{(x + 1)<-1> :: x = (x + 1);<1>(ptr<1>,) :: resume k; ... <-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0>} :: top{}
heap: fun<main>, 1, continuation, 
env: k: continuation, x: 1, main: fun<main>, 
}
--- step exp (x + 1) --->
{
stack: main{x<-1> :: (x + 1)<0> :: x = (x + 1);<1>(ptr<1>,) :: resume k; ... <-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0>} :: top{}
heap: fun<main>, 1, continuation, 
env: k: continuation, x: 1, main: fun<main>, 
}
--- step exp x --->
{
stack: main{1<-1> :: (x + 1)<0> :: x = (x + 1);<1>(ptr<1>,) :: resume k; ... <-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0>} :: top{}
heap: fun<main>, 1, continuation, 
env: k: continuation, x: 1, main: fun<main>, 
}
--- handle value 1 with (x + 1)<1>(1,) --->
{
stack: main{1<-1> :: (x + 1)<1>(1,) :: x = (x + 1);<1>(ptr<1>,) :: resume k; ... <-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0>} :: top{}
heap: fun<main>, 1, continuation, 
env: k: continuation, x: 1, main: fun<main>, 
}
--- step exp 1 --->
{
stack: main{1<-1> :: (x + 1)<1>(1,) :: x = (x + 1);<1>(ptr<1>,) :: resume k; ... <-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0>} :: top{}
heap: fun<main>, 1, continuation, 
env: k: continuation, x: 1, main: fun<main>, 
}
--- handle value 1 with (x + 1)<2>(1,1,) --->
{
stack: main{2<-1> :: x = (x + 1);<1>(ptr<1>,) :: resume k; ... <-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0>} :: top{}
heap: fun<main>, 1, continuation, 
env: k: continuation, x: 1, main: fun<main>, 
}
--- handle value 2 with x = (x + 1);<2>(ptr<1>,2,) --->
{
stack: main{resume k; ... <-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0>} :: top{}
heap: fun<main>, 2, continuation, 
env: k: continuation, x: 2, main: fun<main>, 
}
--- step stmt resume k; ...  --->
{
stack: main{resume k;<-1> :: return 1;<-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0>} :: top{}
heap: fun<main>, 2, continuation, 
env: k: continuation, x: 2, main: fun<main>, 
}
--- step stmt resume k; --->
{
stack: main{k<-1> :: resume k;<0> :: return 1;<-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0>} :: top{}
heap: fun<main>, 2, continuation, 
env: k: continuation, x: 2, main: fun<main>, 
}
--- step exp k --->
{
stack: main{continuation<-1> :: resume k;<0> :: return 1;<-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0>} :: top{}
heap: fun<main>, 2, continuation, 
env: k: continuation, x: 2, main: fun<main>, 
}
--- handle value continuation with resume k;<1>(continuation,) --->
{
stack: main{x = (x + 1); ... <-1> :: {
 ... 
}
<0> :: continuation<-1> :: resume k;<1>(continuation,) :: return 1;<-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0>} :: top{}
heap: fun<main>, 2, continuation, 
env: k: continuation, x: 2, main: fun<main>, 
}
--- step stmt x = (x + 1); ...  --->
{
stack: main{x = (x + 1);<-1> :: return (x - 3);<-1> :: {
 ... 
}
<0> :: continuation<-1> :: resume k;<1>(continuation,) :: return 1;<-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0>} :: top{}
heap: fun<main>, 2, continuation, 
env: k: continuation, x: 2, main: fun<main>, 
}
--- step stmt x = (x + 1); --->
{
stack: main{x<-1> :: x = (x + 1);<0> :: return (x - 3);<-1> :: {
 ... 
}
<0> :: continuation<-1> :: resume k;<1>(continuation,) :: return 1;<-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0>} :: top{}
heap: fun<main>, 2, continuation, 
env: k: continuation, x: 2, main: fun<main>, 
}
--- step lvalue x --->
{
stack: main{ptr<1><-1> :: x = (x + 1);<0> :: return (x - 3);<-1> :: {
 ... 
}
<0> :: continuation<-1> :: resume k;<1>(continuation,) :: return 1;<-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0>} :: top{}
heap: fun<main>, 2, continuation, 
env: k: continuation, x: 2, main: fun<main>, 
}
--- handle value ptr<1> with x = (x + 1);<1>(ptr<1>,) --->
{
stack: main{(x + 1)<-1> :: x = (x + 1);<1>(ptr<1>,) :: return (x - 3);<-1> :: {
 ... 
}
<0> :: continuation<-1> :: resume k;<1>(continuation,) :: return 1;<-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0>} :: top{}
heap: fun<main>, 2, continuation, 
env: k: continuation, x: 2, main: fun<main>, 
}
--- step exp (x + 1) --->
{
stack: main{x<-1> :: (x + 1)<0> :: x = (x + 1);<1>(ptr<1>,) :: return (x - 3);<-1> :: {
 ... 
}
<0> :: continuation<-1> :: resume k;<1>(continuation,) :: return 1;<-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0>} :: top{}
heap: fun<main>, 2, continuation, 
env: k: continuation, x: 2, main: fun<main>, 
}
--- step exp x --->
{
stack: main{2<-1> :: (x + 1)<0> :: x = (x + 1);<1>(ptr<1>,) :: return (x - 3);<-1> :: {
 ... 
}
<0> :: continuation<-1> :: resume k;<1>(continuation,) :: return 1;<-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0>} :: top{}
heap: fun<main>, 2, continuation, 
env: k: continuation, x: 2, main: fun<main>, 
}
--- handle value 2 with (x + 1)<1>(2,) --->
{
stack: main{1<-1> :: (x + 1)<1>(2,) :: x = (x + 1);<1>(ptr<1>,) :: return (x - 3);<-1> :: {
 ... 
}
<0> :: continuation<-1> :: resume k;<1>(continuation,) :: return 1;<-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0>} :: top{}
heap: fun<main>, 2, continuation, 
env: k: continuation, x: 2, main: fun<main>, 
}
--- step exp 1 --->
{
stack: main{1<-1> :: (x + 1)<1>(2,) :: x = (x + 1);<1>(ptr<1>,) :: return (x - 3);<-1> :: {
 ... 
}
<0> :: continuation<-1> :: resume k;<1>(continuation,) :: return 1;<-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0>} :: top{}
heap: fun<main>, 2, continuation, 
env: k: continuation, x: 2, main: fun<main>, 
}
--- handle value 1 with (x + 1)<2>(2,1,) --->
{
stack: main{3<-1> :: x = (x + 1);<1>(ptr<1>,) :: return (x - 3);<-1> :: {
 ... 
}
<0> :: continuation<-1> :: resume k;<1>(continuation,) :: return 1;<-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0>} :: top{}
heap: fun<main>, 2, continuation, 
env: k: continuation, x: 2, main: fun<main>, 
}
--- handle value 3 with x = (x + 1);<2>(ptr<1>,3,) --->
{
stack: main{return (x - 3);<-1> :: {
 ... 
}
<0> :: continuation<-1> :: resume k;<1>(continuation,) :: return 1;<-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0>} :: top{}
heap: fun<main>, 3, continuation, 
env: k: continuation, x: 3, main: fun<main>, 
}
--- step stmt return (x - 3); --->
{
stack: main{(x - 3)<-1> :: return (x - 3);<0> :: {
 ... 
}
<0> :: continuation<-1> :: resume k;<1>(continuation,) :: return 1;<-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0>} :: top{}
heap: fun<main>, 3, continuation, 
env: k: continuation, x: 3, main: fun<main>, 
}
--- step exp (x - 3) --->
{
stack: main{x<-1> :: (x - 3)<0> :: return (x - 3);<0> :: {
 ... 
}
<0> :: continuation<-1> :: resume k;<1>(continuation,) :: return 1;<-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0>} :: top{}
heap: fun<main>, 3, continuation, 
env: k: continuation, x: 3, main: fun<main>, 
}
--- step exp x --->
{
stack: main{3<-1> :: (x - 3)<0> :: return (x - 3);<0> :: {
 ... 
}
<0> :: continuation<-1> :: resume k;<1>(continuation,) :: return 1;<-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0>} :: top{}
heap: fun<main>, 3, continuation, 
env: k: continuation, x: 3, main: fun<main>, 
}
--- handle value 3 with (x - 3)<1>(3,) --->
{
stack: main{3<-1> :: (x - 3)<1>(3,) :: return (x - 3);<0> :: {
 ... 
}
<0> :: continuation<-1> :: resume k;<1>(continuation,) :: return 1;<-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0>} :: top{}
heap: fun<main>, 3, continuation, 
env: k: continuation, x: 3, main: fun<main>, 
}
--- step exp 3 --->
{
stack: main{3<-1> :: (x - 3)<1>(3,) :: return (x - 3);<0> :: {
 ... 
}
<0> :: continuation<-1> :: resume k;<1>(continuation,) :: return 1;<-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0>} :: top{}
heap: fun<main>, 3, continuation, 
env: k: continuation, x: 3, main: fun<main>, 
}
--- handle value 3 with (x - 3)<2>(3,3,) --->
{
stack: main{0<-1> :: return (x - 3);<0> :: {
 ... 
}
<0> :: continuation<-1> :: resume k;<1>(continuation,) :: return 1;<-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0>} :: top{}
heap: fun<main>, 3, continuation, 
env: k: continuation, x: 3, main: fun<main>, 
}
--- handle value 0 with return (x - 3);<1>(0,) --->
{
stack: top{0<-1>}
heap: fun<main>, !!3, !!continuation, 
env: main: fun<main>, 
}
result: 0
