********** source program **********
fn main () -> Int {
var Int: x = 0;
delimit
{
x = (x + 1);
yield 3;
x = (x + 2);
return (x - 6);

}

with (v, k)
{
x = (x + v);
resume k;
return 1;

}



}
********** type checking **********
--- step exp Int --->
--- step exp Int --->
--- step exp Int --->

********** type checking complete **********
fn main () -> Int {
var Int: x = 0;
delimit
{
x = (x + 1);
yield 3;
x = (x + 2);
return (x - 6);
}

with (v, k)
{
x = (x + v);
resume k;
return 1;
}


}
********** starting execution **********
********** initializing globals **********
--- step exp () --->
********** calling main function **********
{
stack: top{main()<-1>}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step exp main() --->
{
stack: top{main<-1> :: main()<0>}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step exp main --->
{
stack: top{fun<main><-1> :: main()<0>}
heap: fun<main>, 
env: main: fun<main>, 
}
--- handle value fun<main> with main()<1>(fun<main>,) --->
{
stack: top{()<-1> :: main()<1>(fun<main>,)}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step exp () --->
{
stack: top{()<-1> :: main()<1>(fun<main>,)}
heap: fun<main>, 
env: main: fun<main>, 
}
--- handle value () with main()<2>(fun<main>,(),) --->
pattern_match((), ())
{
stack: main{var Int: x = 0; ... <-1>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step stmt var Int: x = 0; ...  --->
{
stack: main{var Int: x = 0;<-1> :: delimit
 ... 
with (v, k)
 ... 
<-1>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step stmt var Int: x = 0; --->
{
stack: main{0<-1> :: var Int: x = 0;<0> :: delimit
 ... 
with (v, k)
 ... 
<-1>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step exp 0 --->
{
stack: main{0<-1> :: var Int: x = 0;<0> :: delimit
 ... 
with (v, k)
 ... 
<-1>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- handle value 0 with var Int: x = 0;<1>(0,) --->
{
stack: main{Int: x<-1> :: var Int: x = 0;<1>(0,) :: delimit
 ... 
with (v, k)
 ... 
<-1>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step exp Int: x --->
{
stack: main{Int<-1> :: Int: x<0> :: var Int: x = 0;<1>(0,) :: delimit
 ... 
with (v, k)
 ... 
<-1>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- step exp Int --->
{
stack: main{Int<-1> :: Int: x<0> :: var Int: x = 0;<1>(0,) :: delimit
 ... 
with (v, k)
 ... 
<-1>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- handle value Int with Int: x<1>(Int,) --->
{
stack: main{Int: x<-1> :: var Int: x = 0;<1>(0,) :: delimit
 ... 
with (v, k)
 ... 
<-1>} :: top{}
heap: fun<main>, 
env: main: fun<main>, 
}
--- handle value Int: x with var Int: x = 0;<2>(0,Int: x,) --->
pattern_match(Int: x, 0)
{
stack: main{delimit
 ... 
with (v, k)
 ... 
<-1>} :: top{}
heap: fun<main>, 0, 
env: x: 0, main: fun<main>, 
}
--- step stmt delimit
 ... 
with (v, k)
 ... 
 --->
{
stack: main{{
 ... 
}
<-1> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 0, 
env: x: 0, main: fun<main>, 
}
--- step stmt {
 ... 
}
 --->
{
stack: main{x = (x + 1); ... <-1> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 0, 
env: x: 0, main: fun<main>, 
}
--- step stmt x = (x + 1); ...  --->
{
stack: main{x = (x + 1);<-1> :: yield 3; ... <-1> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 0, 
env: x: 0, main: fun<main>, 
}
--- step stmt x = (x + 1); --->
{
stack: main{x<-1> :: x = (x + 1);<0> :: yield 3; ... <-1> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 0, 
env: x: 0, main: fun<main>, 
}
--- step lvalue x --->
{
stack: main{ptr<1><-1> :: x = (x + 1);<0> :: yield 3; ... <-1> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 0, 
env: x: 0, main: fun<main>, 
}
--- handle value ptr<1> with x = (x + 1);<1>(ptr<1>,) --->
{
stack: main{(x + 1)<-1> :: x = (x + 1);<1>(ptr<1>,) :: yield 3; ... <-1> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 0, 
env: x: 0, main: fun<main>, 
}
--- step exp (x + 1) --->
{
stack: main{x<-1> :: (x + 1)<0> :: x = (x + 1);<1>(ptr<1>,) :: yield 3; ... <-1> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 0, 
env: x: 0, main: fun<main>, 
}
--- step exp x --->
{
stack: main{0<-1> :: (x + 1)<0> :: x = (x + 1);<1>(ptr<1>,) :: yield 3; ... <-1> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 0, 
env: x: 0, main: fun<main>, 
}
--- handle value 0 with (x + 1)<1>(0,) --->
{
stack: main{1<-1> :: (x + 1)<1>(0,) :: x = (x + 1);<1>(ptr<1>,) :: yield 3; ... <-1> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 0, 
env: x: 0, main: fun<main>, 
}
--- step exp 1 --->
{
stack: main{1<-1> :: (x + 1)<1>(0,) :: x = (x + 1);<1>(ptr<1>,) :: yield 3; ... <-1> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 0, 
env: x: 0, main: fun<main>, 
}
--- handle value 1 with (x + 1)<2>(0,1,) --->
{
stack: main{1<-1> :: x = (x + 1);<1>(ptr<1>,) :: yield 3; ... <-1> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 0, 
env: x: 0, main: fun<main>, 
}
--- handle value 1 with x = (x + 1);<2>(ptr<1>,1,) --->
{
stack: main{yield 3; ... <-1> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 1, 
env: x: 1, main: fun<main>, 
}
--- step stmt yield 3; ...  --->
{
stack: main{yield 3;<-1> :: x = (x + 2); ... <-1> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 1, 
env: x: 1, main: fun<main>, 
}
--- step stmt yield 3; --->
{
stack: main{3<-1> :: yield 3;<0> :: x = (x + 2); ... <-1> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 1, 
env: x: 1, main: fun<main>, 
}
--- step exp 3 --->
{
stack: main{3<-1> :: yield 3;<0> :: x = (x + 2); ... <-1> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 1, 
env: x: 1, main: fun<main>, 
}
--- handle value 3 with yield 3;<1>(3,) --->
{
stack: main{{
 ... 
}
<-1> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 1, 3, continuation, 
env: k: continuation, v: 3, x: 1, main: fun<main>, 
}
--- step stmt {
 ... 
}
 --->
{
stack: main{{
 ... 
}
<-1> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 1, 3, continuation, 
env: k: continuation, v: 3, x: 1, main: fun<main>, 
}
--- step stmt {
 ... 
}
 --->
{
stack: main{x = (x + v); ... <-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 1, 3, continuation, 
env: k: continuation, v: 3, x: 1, main: fun<main>, 
}
--- step stmt x = (x + v); ...  --->
{
stack: main{x = (x + v);<-1> :: resume k; ... <-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 1, 3, continuation, 
env: k: continuation, v: 3, x: 1, main: fun<main>, 
}
--- step stmt x = (x + v); --->
{
stack: main{x<-1> :: x = (x + v);<0> :: resume k; ... <-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 1, 3, continuation, 
env: k: continuation, v: 3, x: 1, main: fun<main>, 
}
--- step lvalue x --->
{
stack: main{ptr<1><-1> :: x = (x + v);<0> :: resume k; ... <-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 1, 3, continuation, 
env: k: continuation, v: 3, x: 1, main: fun<main>, 
}
--- handle value ptr<1> with x = (x + v);<1>(ptr<1>,) --->
{
stack: main{(x + v)<-1> :: x = (x + v);<1>(ptr<1>,) :: resume k; ... <-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 1, 3, continuation, 
env: k: continuation, v: 3, x: 1, main: fun<main>, 
}
--- step exp (x + v) --->
{
stack: main{x<-1> :: (x + v)<0> :: x = (x + v);<1>(ptr<1>,) :: resume k; ... <-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 1, 3, continuation, 
env: k: continuation, v: 3, x: 1, main: fun<main>, 
}
--- step exp x --->
{
stack: main{1<-1> :: (x + v)<0> :: x = (x + v);<1>(ptr<1>,) :: resume k; ... <-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 1, 3, continuation, 
env: k: continuation, v: 3, x: 1, main: fun<main>, 
}
--- handle value 1 with (x + v)<1>(1,) --->
{
stack: main{v<-1> :: (x + v)<1>(1,) :: x = (x + v);<1>(ptr<1>,) :: resume k; ... <-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 1, 3, continuation, 
env: k: continuation, v: 3, x: 1, main: fun<main>, 
}
--- step exp v --->
{
stack: main{3<-1> :: (x + v)<1>(1,) :: x = (x + v);<1>(ptr<1>,) :: resume k; ... <-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 1, 3, continuation, 
env: k: continuation, v: 3, x: 1, main: fun<main>, 
}
--- handle value 3 with (x + v)<2>(1,3,) --->
{
stack: main{4<-1> :: x = (x + v);<1>(ptr<1>,) :: resume k; ... <-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 1, 3, continuation, 
env: k: continuation, v: 3, x: 1, main: fun<main>, 
}
--- handle value 4 with x = (x + v);<2>(ptr<1>,4,) --->
{
stack: main{resume k; ... <-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 4, 3, continuation, 
env: k: continuation, v: 3, x: 4, main: fun<main>, 
}
--- step stmt resume k; ...  --->
{
stack: main{resume k;<-1> :: return 1;<-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 4, 3, continuation, 
env: k: continuation, v: 3, x: 4, main: fun<main>, 
}
--- step stmt resume k; --->
{
stack: main{k<-1> :: resume k;<0> :: return 1;<-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 4, 3, continuation, 
env: k: continuation, v: 3, x: 4, main: fun<main>, 
}
--- step exp k --->
{
stack: main{continuation<-1> :: resume k;<0> :: return 1;<-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 4, 3, continuation, 
env: k: continuation, v: 3, x: 4, main: fun<main>, 
}
--- handle value continuation with resume k;<1>(continuation,) --->
{
stack: main{x = (x + 2); ... <-1> :: {
 ... 
}
<0> :: return 1;<-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 4, 3, continuation, 
env: x: 4, main: fun<main>, 
}
--- step stmt x = (x + 2); ...  --->
{
stack: main{x = (x + 2);<-1> :: return (x - 6);<-1> :: {
 ... 
}
<0> :: return 1;<-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 4, 3, continuation, 
env: x: 4, main: fun<main>, 
}
--- step stmt x = (x + 2); --->
{
stack: main{x<-1> :: x = (x + 2);<0> :: return (x - 6);<-1> :: {
 ... 
}
<0> :: return 1;<-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 4, 3, continuation, 
env: x: 4, main: fun<main>, 
}
--- step lvalue x --->
{
stack: main{ptr<1><-1> :: x = (x + 2);<0> :: return (x - 6);<-1> :: {
 ... 
}
<0> :: return 1;<-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 4, 3, continuation, 
env: x: 4, main: fun<main>, 
}
--- handle value ptr<1> with x = (x + 2);<1>(ptr<1>,) --->
{
stack: main{(x + 2)<-1> :: x = (x + 2);<1>(ptr<1>,) :: return (x - 6);<-1> :: {
 ... 
}
<0> :: return 1;<-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 4, 3, continuation, 
env: x: 4, main: fun<main>, 
}
--- step exp (x + 2) --->
{
stack: main{x<-1> :: (x + 2)<0> :: x = (x + 2);<1>(ptr<1>,) :: return (x - 6);<-1> :: {
 ... 
}
<0> :: return 1;<-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 4, 3, continuation, 
env: x: 4, main: fun<main>, 
}
--- step exp x --->
{
stack: main{4<-1> :: (x + 2)<0> :: x = (x + 2);<1>(ptr<1>,) :: return (x - 6);<-1> :: {
 ... 
}
<0> :: return 1;<-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 4, 3, continuation, 
env: x: 4, main: fun<main>, 
}
--- handle value 4 with (x + 2)<1>(4,) --->
{
stack: main{2<-1> :: (x + 2)<1>(4,) :: x = (x + 2);<1>(ptr<1>,) :: return (x - 6);<-1> :: {
 ... 
}
<0> :: return 1;<-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 4, 3, continuation, 
env: x: 4, main: fun<main>, 
}
--- step exp 2 --->
{
stack: main{2<-1> :: (x + 2)<1>(4,) :: x = (x + 2);<1>(ptr<1>,) :: return (x - 6);<-1> :: {
 ... 
}
<0> :: return 1;<-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 4, 3, continuation, 
env: x: 4, main: fun<main>, 
}
--- handle value 2 with (x + 2)<2>(4,2,) --->
{
stack: main{6<-1> :: x = (x + 2);<1>(ptr<1>,) :: return (x - 6);<-1> :: {
 ... 
}
<0> :: return 1;<-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 4, 3, continuation, 
env: x: 4, main: fun<main>, 
}
--- handle value 6 with x = (x + 2);<2>(ptr<1>,6,) --->
{
stack: main{return (x - 6);<-1> :: {
 ... 
}
<0> :: return 1;<-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 6, 3, continuation, 
env: x: 6, main: fun<main>, 
}
--- step stmt return (x - 6); --->
{
stack: main{(x - 6)<-1> :: return (x - 6);<0> :: {
 ... 
}
<0> :: return 1;<-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 6, 3, continuation, 
env: x: 6, main: fun<main>, 
}
--- step exp (x - 6) --->
{
stack: main{x<-1> :: (x - 6)<0> :: return (x - 6);<0> :: {
 ... 
}
<0> :: return 1;<-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 6, 3, continuation, 
env: x: 6, main: fun<main>, 
}
--- step exp x --->
{
stack: main{6<-1> :: (x - 6)<0> :: return (x - 6);<0> :: {
 ... 
}
<0> :: return 1;<-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 6, 3, continuation, 
env: x: 6, main: fun<main>, 
}
--- handle value 6 with (x - 6)<1>(6,) --->
{
stack: main{6<-1> :: (x - 6)<1>(6,) :: return (x - 6);<0> :: {
 ... 
}
<0> :: return 1;<-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 6, 3, continuation, 
env: x: 6, main: fun<main>, 
}
--- step exp 6 --->
{
stack: main{6<-1> :: (x - 6)<1>(6,) :: return (x - 6);<0> :: {
 ... 
}
<0> :: return 1;<-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 6, 3, continuation, 
env: x: 6, main: fun<main>, 
}
--- handle value 6 with (x - 6)<2>(6,6,) --->
{
stack: main{0<-1> :: return (x - 6);<0> :: {
 ... 
}
<0> :: return 1;<-1> :: {
 ... 
}
<0> :: {
 ... 
}
<0> :: delimit
 ... 
with (v, k)
 ... 
<0>} :: top{}
heap: fun<main>, 6, 3, continuation, 
env: x: 6, main: fun<main>, 
}
--- handle value 0 with return (x - 6);<1>(0,) --->
{
stack: top{0<-1>}
heap: fun<main>, !!6, !!3, !!continuation, 
env: main: fun<main>, 
}
result: 0
