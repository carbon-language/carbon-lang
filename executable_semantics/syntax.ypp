/*
# Part of the Carbon Language project, under the Apache License v2.0 with LLVM
# Exceptions. See /LICENSE for license information.
# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
*/

%{
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>

#include <algorithm>
#include <iostream>
#include <list>

#include "executable_semantics/ast.h"
#include "executable_semantics/typecheck.h"
#include "executable_semantics/interp.h"

extern FILE* yyin;
extern int yylineno;
char* input_filename;

void yyerror(char* s)  {
  fprintf(stderr, "%s:%d: %s\n", input_filename, yylineno, s);
  exit(-1);
}
// void yyerror(char *s, ...);

extern int yylex();
extern int yywrap();

static std::list<FunctionDefinition*> program;
%}
%union
 {
   char* str;
   int  num;
   Expression* expression;
   VarTypes* field_types;
   Statement* statement;
   Statement* statement_list;
   struct FunctionDefinition* function_definition;
   Declaration* declaration;
   std::list<Declaration*>* declaration_list;
   Member* member;
   std::list<Member*>* member_list;
   ExpOrFieldList* field_list;
   std::pair<std::string, Expression*>* alternative;
   std::list<std::pair<std::string, Expression* > >* alternative_list;
   std::pair<Expression*,Statement*>* clause;
   std::list< std::pair<Expression*,Statement*> >* clause_list;
   Expression* fun_type;
};

%token <num> integer_literal
%token <str> identifier
%type <str> designator
%type <declaration> declaration
%type <function_definition> function_declaration
%type <function_definition> function_definition
%type <declaration_list> declaration_list
%type <statement> statement
%type <statement_list> statement_list
%type <expression> expression
%type <expression> pattern
%type <expression> return_type
%type <expression> tuple
%type <member> member
%type <member_list> member_list
%type <field_list> field
%type <field_list> field_list
%type <alternative> alternative
%type <alternative_list> alternative_list
%type <clause> clause
%type <clause_list> clause_list
%token AND
%token OR
%token NOT
%token INT
%token BOOL
%token TYPE
%token FN
%token FNTY
%token ARROW
%token VAR
%token EQUAL
%token IF
%token ELSE
%token WHILE
%token BREAK
%token CONTINUE
%token RETURN
%token TRUE
%token FALSE
%token STRUCT
%token CHOICE
%token MATCH
%token CASE
%token DBLARROW
%token DEFAULT
%token AUTO
%nonassoc '{' '}'
%nonassoc ':' ',' DBLARROW
%left OR AND
%nonassoc EQUAL NOT
%left '+' '-'
%left '.' ARROW
%nonassoc '(' ')' '[' ']'
%start input
%locations
%%
input: declaration_list
    {
      printf("********** source program **********\n");
      PrintList($1, PrintDecl, "");
      printf("********** type checking **********\n");
      state = new State(); // compile-time state
      std::pair<TypeEnv*,Env*> p = TopLevel($1);
      TypeEnv* top = p.first;
      Env* ct_top = p.second;
      std::list<Declaration*> new_decls;
      for (auto i = $1->begin(); i != $1->end(); ++i) {
        new_decls.push_back(TypeCheckDecl(*i, top, ct_top));
      }
      printf("\n");
      printf("********** type checking complete **********\n");
      PrintList(&new_decls, PrintDecl, "");
      printf("********** starting execution **********\n");
      int result = InterpProgram(&new_decls);
      std::cout << "result: " << result << std::endl;
    }
;
pattern:
  expression
    { $$ = $1; }
;
expression:
  identifier
    { $$ = MakeVar(yylineno, $1); }
| expression designator
    { $$ = MakeGetField(yylineno, $1, $2); }
| expression '[' expression ']'
    { $$ = MakeIndex(yylineno, $1, $3); }
| expression ':' identifier
    { $$ = MakeVarPat(yylineno, $3, $1); }
| integer_literal
    { $$ = MakeInt(yylineno, $1); }
| TRUE
    { $$ = MakeBool(yylineno, true); }
| FALSE
    { $$ = MakeBool(yylineno, false); }
| INT
    { $$ = MakeIntType(yylineno); }
| BOOL
    { $$ = MakeBoolType(yylineno); }
| TYPE
    { $$ = MakeTypeType(yylineno); }
| AUTO
    { $$ = MakeAutoType(yylineno); }
| tuple { $$ = $1; }
| expression EQUAL expression
    { $$ = MakeBinOp(yylineno, Eq, $1, $3); }
| expression '+' expression
    { $$ = MakeBinOp(yylineno, Add, $1, $3); }
| expression '-' expression
    { $$ = MakeBinOp(yylineno, Sub, $1, $3); }
| expression AND expression
    { $$ = MakeBinOp(yylineno, And, $1, $3); }
| expression OR expression
    { $$ = MakeBinOp(yylineno, Or, $1, $3); }
| NOT expression
    { $$ = MakeUnOp(yylineno, Not, $2); }
| '-' expression
    { $$ = MakeUnOp(yylineno, Neg, $2); }
| expression tuple
    {
      if ($2->tag == Tuple) {
        $$ = MakeCall(yylineno, $1, $2);
      } else {
        auto vec = new std::vector<std::pair<std::string,Expression*> >();
        vec->push_back(std::make_pair("", $2));
        $$ = MakeCall(yylineno, $1, MakeTuple(yylineno, vec));
      }
    }
| FNTY tuple return_type
    { $$ = MakeFunType(yylineno, $2, $3); }
;
designator: '.' identifier { $$ = $2; }
;
tuple: '(' field_list ')'
    {
      switch ($2->tag) {
      case Exp:
        $$ = $2->u.exp;
        break;
      case FieldList:
        auto vec = new std::vector<std::pair<std::string,Expression*> >($2->u.fields->begin(),
                                                         $2->u.fields->end());
        $$ = MakeTuple(yylineno, vec);
        break;
      }
    }
;
field:
  pattern
    { $$ = MakeExp($1); }
| designator '=' pattern
    { auto fields = new std::list<std::pair<std::string,Expression*> >();
      fields->push_back(std::make_pair($1, $3));
      $$ = MakeFieldList(fields); }
;
field_list:
  /* empty */
    { $$ = MakeFieldList(new std::list<std::pair<std::string,Expression*> >()); }
| field
    { $$ = $1; }
| field ',' field_list
    { $$ = MakeConstructorField($1, $3); }
;
clause:
  CASE pattern DBLARROW statement
    { $$ = new std::pair<Expression*,Statement*>($2, $4); }
| DEFAULT DBLARROW statement
    {
      auto vp = MakeVarPat(yylineno, "_", MakeAutoType(yylineno));
      $$ = new std::pair<Expression*,Statement*>(vp, $3);
    }
;
clause_list:
  /* empty */
    { $$ = new std::list< std::pair<Expression*,Statement*> >(); }
| clause clause_list
    { $$ = $2; $$->push_front(*$1); }
;
statement:
  expression '=' expression ';'
    { $$ = MakeAssign(yylineno, $1, $3); }
| VAR pattern '=' expression ';'
    { $$ = MakeVarDef(yylineno, $2, $4); }
| expression ';'
    { $$ = MakeExpStmt(yylineno, $1); }
| IF '(' expression ')' statement ELSE statement
    { $$ = MakeIf(yylineno, $3, $5, $7); }
| WHILE '(' expression ')' statement
    { $$ = MakeWhile(yylineno, $3, $5); }
| BREAK ';'
    { $$ = MakeBreak(yylineno); }
| CONTINUE ';'
    { $$ = MakeContinue(yylineno); }
| RETURN expression ';'
    { $$ = MakeReturn(yylineno, $2); }
| '{' statement_list '}'
    { $$ = MakeBlock(yylineno, $2); }
| MATCH '(' expression ')' '{' clause_list '}'
    { $$ = MakeMatch(yylineno, $3, $6); }
;
statement_list:
  /* empty */
    { $$ = 0; }
| statement statement_list
    { $$ = MakeSeq(yylineno, $1, $2); }
;
return_type:
  /* empty */
    { $$ = MakeTuple(yylineno, new std::vector<std::pair<std::string,Expression*> >()); }
| ARROW expression
    { $$ = $2; }
;
function_definition:
  FN identifier tuple return_type '{' statement_list '}'
    { $$ = MakeFunDef(yylineno, $2, $4, $3, $6); }
| FN identifier tuple DBLARROW expression ';'
    { $$ = MakeFunDef(yylineno, $2, MakeAutoType(yylineno), $3,
                        MakeReturn(yylineno, $5)); }
;
function_declaration:
  FN identifier tuple return_type ';'
    { $$ = MakeFunDef(yylineno, $2, $4, $3, 0); }
;
member:
  VAR expression ':' identifier ';'
    { $$ = MakeField(yylineno, $4, $2); }
;
member_list:
  /* empty */
    { $$ = new std::list<Member*>(); }
| member member_list
    { $$ = $2; $$->push_front($1); }
;
alternative:
  identifier tuple ';'
    { $$ = new std::pair<std::string,Expression*>($1, $2); }
;
alternative_list:
  /* empty */
    { $$ = new std::list<std::pair<std::string, Expression*> >(); }
| alternative alternative_list
    { $$ = $2; $$->push_front(*$1); }
;
declaration:
  function_definition
    { $$ = MakeFunDecl($1); }
| function_declaration
    { $$ = MakeFunDecl($1); }
| STRUCT identifier '{' member_list '}'
    { $$ = MakeStructDecl(yylineno, $2, $4); }
| CHOICE identifier '{' alternative_list '}'
    { $$ = MakeChoiceDecl(yylineno, $2, $4); }
;
declaration_list:
  /* empty */
    { $$ = new std::list<Declaration*>(); }
| declaration declaration_list
    { $$ = $2; $$->push_front($1); }
;
%%
int main(int argc, char* argv[])  {
  /*yydebug = 1;*/

  if (argc > 1) {
    input_filename = argv[1];
    yyin = fopen(argv[1], "r");
  }
  if (argc > 2) {
    FILE* program = fopen(argv[2], "r");
    input = ReadFile(program);
  }
  yyparse();
  return 0;
}
