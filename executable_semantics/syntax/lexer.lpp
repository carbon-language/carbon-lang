/*
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
*/

%{
#include <cstdlib>
#include <iostream>
#include "executable_semantics/syntax/parse_and_lex_context.h"
%}

/* Turn off legacy bits we don't need */
%option noyywrap nounput nodefault noinput

/* maintains the number of the current line read from input in the
   global variable yylineno.
*/
%option yylineno

AND               "and"
ARROW             "->"
AUTO              "auto"
BOOL              "Bool"
BREAK             "break"
CASE              "case"
CHOICE            "choice"
ONE_LINE_COMMENT  \/\/[^\n]*\n
CONTINUE          "continue"
DBLARROW          "=>"
DEFAULT           "default"
ELSE              "else"
EQUAL_EQUAL       "=="
FALSE             "false"
FN                "fn"
FNTY              "fnty"
IF                "if"
INT               "Int"
MATCH             "match"
NOT               "not"
OR                "or"
RETURN            "return"
STRUCT            "struct"
TRUE              "true"
TYPE              "Type"
VAR               "var"
WHILE             "while"

identifier    [A-Za-z_][A-Za-z0-9_]*
integer_literal   [0-9]+
horizontal_whitespace [ \t\r]

%{
  // This macro is expanded to run each time a token is recognized.
  //
  // Advances the current token position by yyleng columns without changing
  // the line number.
  # define YY_USER_ACTION context.current_token_position.columns(yyleng);
%}

%%

%{
  // Code run each time yylex is called.

  // Begin with an empty token span starting where its previous end was.
  context.current_token_position.step();
%}

{AND}      { return yy::parser::make_and(context.current_token_position); }
{ARROW}    { return yy::parser::make_arrow(context.current_token_position); }
{AUTO}     { return yy::parser::make_auto(context.current_token_position); }
{BOOL}     { return yy::parser::make_bool(context.current_token_position); }
{BREAK}    { return yy::parser::make_break(context.current_token_position); }
{CASE}     { return yy::parser::make_case(context.current_token_position); }
{CHOICE}   { return yy::parser::make_choice(context.current_token_position); }
{CONTINUE} { return yy::parser::make_continue(context.current_token_position); }
{DBLARROW} { return yy::parser::make_dblarrow(context.current_token_position); }
{DEFAULT}  { return yy::parser::make_default(context.current_token_position); }
{ELSE}     { return yy::parser::make_else(context.current_token_position); }
"=="       { return yy::parser::make_equal_equal(context.current_token_position); }
{FALSE}    { return yy::parser::make_false(context.current_token_position); }
{FN}       { return yy::parser::make_fn(context.current_token_position); }
{FNTY}     { return yy::parser::make_fnty(context.current_token_position); }
{IF}       { return yy::parser::make_if(context.current_token_position); }
{INT}      { return yy::parser::make_int(context.current_token_position); }
{MATCH}    { return yy::parser::make_match(context.current_token_position); }
{NOT}      { return yy::parser::make_not(context.current_token_position); }
{OR}       { return yy::parser::make_or(context.current_token_position); }
{RETURN}   { return yy::parser::make_return(context.current_token_position); }
{STRUCT}   { return yy::parser::make_struct(context.current_token_position); }
{TRUE}     { return yy::parser::make_true(context.current_token_position); }
{TYPE}     { return yy::parser::make_type(context.current_token_position); }
{VAR}      { return yy::parser::make_var(context.current_token_position); }
{WHILE}    { return yy::parser::make_while(context.current_token_position); }

"=" return yy::parser::make_equal(context.current_token_position);
"-" return yy::parser::make_minus(context.current_token_position);
"+" return yy::parser::make_plus(context.current_token_position);
"*" return yy::parser::make_star(context.current_token_position);
"/" return yy::parser::make_slash(context.current_token_position);
"(" return yy::parser::make_left_parenthesis(context.current_token_position);
")" return yy::parser::make_right_parenthesis(context.current_token_position);
"{" return yy::parser::make_left_curly_brace(context.current_token_position);
"}" return yy::parser::make_right_curly_brace(context.current_token_position);
"[" return yy::parser::make_left_square_bracket(context.current_token_position);
"]" return yy::parser::make_right_square_bracket(context.current_token_position);
"." return yy::parser::make_period(context.current_token_position);
"," return yy::parser::make_comma(context.current_token_position);
";" return yy::parser::make_semicolon(context.current_token_position);
":" return yy::parser::make_colon(context.current_token_position);

{identifier} {
  int n = strlen(yytext);
  auto r = reinterpret_cast<char*>(malloc((n + 1) * sizeof(char)));
  strncpy(r, yytext, n + 1);
  return yy::parser::make_identifier(r, context.current_token_position);
}

{integer_literal} {
  auto r = atof(yytext);
  return yy::parser::make_integer_literal(r, context.current_token_position);
}

{ONE_LINE_COMMENT} {
  // Advance end by 1 line, resetting the column to zero.
  context.current_token_position.lines(1);
  // Make the span empty by setting start to end.
  context.current_token_position.step();
}

{horizontal_whitespace}+ {
  // Make the span empty by setting start to end.
  context.current_token_position.step();
}

\n+ {
  // Advance end by yyleng lines, resetting the column to zero.
  context.current_token_position.lines(yyleng);
  // Make the span empty by setting start to end.
  context.current_token_position.step();
}

. {
  std::cerr << context.current_token_position << ": invalid character '"
            << yytext[0] << "' in source file." << std::endl;
  std::exit(1);
}

<<EOF>>    {
  // A more modern Bison would give us make_eof.
  return yy::parser::make_end_of_file(context.current_token_position);
}

%%
