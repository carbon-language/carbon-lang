/*
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
*/

%{
#include <cstdlib>
#include "executable_semantics/syntax/parse_and_lex_context.h"
%}

/* Turn off legacy bits we don't need */
%option noyywrap nounput nodefault noinput

/* maintains the number of the current line read from input in the
   global variable yylineno.
*/
%option yylineno

AND      "and"
ARROW    "->"
AUTO     "auto"
BOOL     "Bool"
BREAK    "break"
CASE     "case"
CHOICE   "choice"
COMMENT  \/\/[^\n]*\n
CONTINUE "continue"
DBLARROW "=>"
DEFAULT  "default"
ELSE     "else"
EQUAL    "=="
FALSE    "false"
FN       "fn"
FNTY     "fnty"
IF       "if"
INT      "Int"
MATCH    "match"
NOT      "not"
OR       "or"
RETURN   "return"
STRUCT   "struct"
TRUE     "true"
TYPE     "Type"
VAR      "var"
WHILE    "while"

identifier    [A-Za-z_][A-Za-z0-9_]*
integer_literal   [0-9]+

%%

{AND}      { return yy::parser::token::AND; }
{ARROW}    { return yy::parser::token::ARROW; }
{AUTO}     { return yy::parser::token::AUTO; }
{BOOL}     { return yy::parser::token::BOOL; }
{BREAK}    { return yy::parser::token::BREAK; }
{CASE}     { return yy::parser::token::CASE; }
{CHOICE}   { return yy::parser::token::CHOICE; }
{COMMENT}  ;
{CONTINUE} { return yy::parser::token::CONTINUE; }
{DBLARROW} { return yy::parser::token::DBLARROW; }
{DEFAULT}  { return yy::parser::token::DEFAULT; }
{ELSE}     { return yy::parser::token::ELSE; }
{EQUAL}    { return yy::parser::token::EQUAL; }
{FALSE}    { return yy::parser::token::FALSE; }
{FN}       { return yy::parser::token::FN; }
{FNTY}     { return yy::parser::token::FNTY; }
{IF}       { return yy::parser::token::IF; }
{INT}      { return yy::parser::token::INT; }
{MATCH}    { return yy::parser::token::MATCH; }
{NOT}      { return yy::parser::token::NOT; }
{OR}       { return yy::parser::token::OR; }
{RETURN}   { return yy::parser::token::RETURN; }
{STRUCT}   { return yy::parser::token::STRUCT; }
{TRUE}     { return yy::parser::token::TRUE; }
{TYPE}     { return yy::parser::token::TYPE; }
{VAR}      { return yy::parser::token::VAR; }
{WHILE}    { return yy::parser::token::WHILE; }

{identifier} {
  int n = strlen(yytext);
  yylval->identifier = reinterpret_cast<char*>(malloc((n + 1) * sizeof(char)));
  strncpy(yylval->identifier, yytext, n + 1);
  return yy::parser::token::identifier;
}
{integer_literal} {
  yylval->integer_literal = atof(yytext);
  return yy::parser::token::integer_literal;
}

[ \t\n]+ ;
. { return yytext[0]; }

%%
