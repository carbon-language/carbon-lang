<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
          "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
  <title>Clang - Getting Started</title>
  <link type="text/css" rel="stylesheet" href="menu.css" />
  <link type="text/css" rel="stylesheet" href="content.css" />
</head>
<body>

<!--#include virtual="menu.html.incl"-->

<div id="content">

<h1>Getting Started: Building and Running Clang</h1>


<p>This page gives you the shortest path to checking out clang and demos a few
options.  This should get you up and running with the minimum of muss and fuss.
If you like what you see, please consider <a href="get_involved.html">getting
involved</a> with the clang community.</p>


<h2>A word of warning</h2>

<p>While this work aims to provide a fully functional C/C++/ObjC front-end, it
is <em>still early work</em> and is under heavy development. In particular,
there is no real C++ support yet (this is obviously a big project), and C/ObjC
support is still missing some features. Some of the more notable missing pieces
of C support are:</p>

<ol>
  <li>The semantic analyzer does not produce all of the warnings and errors it
      should.</li>
  <li>The LLVM code generator is still missing important features.  clang is not
      ready to be used as a general purpose C code generator yet, but if you
      hit problems and report them to cfe-dev, we'll fix them :).</li>
  <li>We don't consider the API to be stable yet, and reserve the right to
      change fundamental things.</li>
</ol>

<p>Our plan is to continue chipping away at these issues until C works really
well, but we'd love help from other interested contributors.  We expect C to be
in good shape by mid to late 2008.</p>

<h2 id="build">Building clang / working with the code</h2>

<p>If you would like to check out and build the project, the current scheme
is:</p>

<ol>
  <li><a href="http://www.llvm.org/docs/GettingStarted.html#checkout">Checkout
   and build LLVM</a> from SVN head:</li>

  <ul>
    <li><tt>svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm</tt></li>
    <li><tt>cd llvm</tt></li>
    <li><tt>./configure; make</tt></li>
  </ul>
  <li>Checkout clang:</li>
  <ul>
     <li>From within the <tt>llvm</tt> directory (where you
     built llvm):</li>
     <li><tt>cd tools</tt>
     <li><tt>svn co http://llvm.org/svn/llvm-project/cfe/trunk clang</tt></li>

  </ul>
  <li>Non-mac users: Paths to system header files are currently hard coded
      into clang; as a result, if clang can't find your system headers,
      please follow these instructions:</li>

  <ul>
    <li>'<tt>touch empty.c; gcc -v empty.c -fsyntax-only</tt>' to get the
    path.</li>
    <li>Look for the comment "FIXME: temporary hack:
    hard-coded paths" in <tt>clang/lib/Driver/InitHeaderSearch.cpp</tt> and
    change the lines below to include that path.</li>
  </ul>

  <li>Build clang:</li>
  <ul>
    <li><tt>cd clang</tt> (assuming that you are in <tt>llvm/tools</tt>)</li>
    <li><tt>make</tt> (this will give you a debug build)</li>
  </ul>

  <li>Try it out (assuming you add llvm/Debug/bin to your path):</li>
  <ul>
    <li><tt>clang --help</tt></li>
    <li><tt>clang file.c -fsyntax-only</tt> (check for correctness)</li>
    <li><tt>clang file.c -ast-dump</tt> (internal debug dump of ast)</li>
    <li><tt>clang file.c -ast-view</tt> (<a
    href="http://llvm.org/docs/ProgrammersManual.html#ViewGraph">set up graphviz
     and rebuild llvm first</a>)</li>
    <li><tt>clang file.c -emit-llvm</tt> (print out unoptimized llvm code)</li>
    <li><tt>clang file.c -emit-llvm -o - | llvm-as | opt -std-compile-opts |
         llvm-dis</tt> (print out optimized llvm code)</li>
    <li><tt>clang file.c -emit-llvm -o - | llvm-as | opt -std-compile-opts | llc
         &gt; file.s</tt> (output native machine code)</li>
  </ul>
</ol>

<p>Note that the C front-end uses LLVM, but does not depend on
  llvm-gcc.  If you encounter problems with building clang, make
  sure you have the latest SVN version of LLVM.  LLVM contains
  support libraries for clang that will be updated as well as
  development on clang progresses.</p>
  
<h3>Building clang while building llvm:</h3>
   <p>Since you've checked out clang into the llvm source tree you can
   build them all at once with a simple Makefile change. This moves
   Step 1 above to Step 4.</p>
  <ul>
    <li><tt>cd llvm/tools</tt></li>
    <li>then edit <tt>Makefile</tt> to have a clang target in <tt>PARALLEL_DIRS</tt>
        just like <tt>llvm-config</tt></li>
    <li>then just build llvm normally as above and clang will build at
        the same time</li>
    <li><em>Note:</em> you can update your toplevel project and all (possibly unrelated)
        projects inside it with <tt><b>make update</b></tt>. This will run
	<tt>svn update</tt> on all subdirectories related to subversion.</li>
  </ul>

<h2>Examples of using clang</h2>

<p>The clang driver takes a lot of GCC compatible options, which you can see
with 'clang --help'. Here are a few examples:</p>
<!-- Thanks to
 http://shiflett.org/blog/2006/oct/formatting-and-highlighting-php-code-listings
Site suggested using pre in CSS, but doesn't work in IE, so went for the <pre>
tag. -->

<pre class="code">
$ <b>cat ~/t.c</b>
typedef float V __attribute__((vector_size(16)));
V foo(V a, V b) { return a+b*a; }
</pre>


<h3>Preprocessing:</h3>

<pre class="code">
$ <b>clang ~/t.c -E</b>
# 1 "/Users/sabre/t.c" 1

typedef float V __attribute__((vector_size(16)));

V foo(V a, V b) { return a+b*a; }
</pre>


<h3>Type checking:</h3>

<pre class="code">
$ <b>clang -fsyntax-only ~/t.c</b>
</pre>


<h3>GCC options:</h3>

<pre class="code">
$ <b>clang -fsyntax-only ~/t.c -pedantic</b>
/Users/sabre/t.c:2:17: warning: extension used
typedef float V __attribute__((vector_size(16)));
                ^
1 diagnostic generated.
</pre>


<h3>Pretty printing from the AST:</h3>

<pre class="code">
$ <b>clang ~/t.c -ast-print</b>
typedef float V __attribute__(( vector_size(16) ));
V foo(V a, V b) {
   return a + b * a;
}
</pre>


<h3>Code generation with LLVM:</h3>

<pre class="code">
$ <b>clang ~/t.c -emit-llvm -o - | llvm-as | opt -std-compile-opts | llvm-dis</b>
define &lt;4 x float&gt; @foo(&lt;4 x float&gt; %a, &lt;4 x float&gt; %b) {
entry:
         %mul = mul &lt;4 x float&gt; %b, %a
         %add = add &lt;4 x float&gt; %mul, %a
         ret &lt;4 x float&gt; %add
}
$ <b>clang ~/t.c -emit-llvm -o - | llvm-as | opt -std-compile-opts | llc -march=ppc32 -mcpu=g5</b>
..
_foo:
         vmaddfp v2, v3, v2, v2
         blr
$ <b>clang ~/t.c -emit-llvm -o - | llvm-as | opt -std-compile-opts | llc -march=x86 -mcpu=yonah</b>
..
_foo:
         mulps %xmm0, %xmm1
         addps %xmm0, %xmm1
         movaps %xmm1, %xmm0
         ret
</pre>

<h3>GCC "Emulation" Driver</h3>

<p>While the <tt>clang</tt> executable is a compiler driver that can perform
code generation, program analysis, and other actions, it is not designed to be a
drop-in replacement for GCC's <tt>cc</tt>. There is interest in developing such
a driver for clang, but in the interim the clang source tree includes a Python
script <tt>ccc</tt> in the <tt>utils</tt> subdirectory that provides some of
this functionality (the script is intended to be used where GCC's <tt>cc</tt>
could be used). It is currently a work in progress, and eventually will likely
be replaced by a more complete driver.</p>

<p>Example use:</p>

<pre class="code">
$ <b>ccc t.c</b>
clang -emit-llvm-bc -o t.o -U__GNUC__ t.c
llvm-ld -native -o a.out t.o
$ <b>ls</b>
a.out a.out.bc t.c t.o
</pre>




</div>
</body>
</html>
