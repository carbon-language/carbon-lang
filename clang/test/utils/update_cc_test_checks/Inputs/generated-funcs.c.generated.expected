// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --include-generated-funcs
// Check that the CHECK lines are generated for clang-generated functions
// RUN: %clang_cc1 -triple x86_64-unknown-linux-gnu -fopenmp %s -emit-llvm -o - | FileCheck --check-prefix=OMP %s
// RUN: %clang_cc1 -triple x86_64-unknown-linux-gnu %s -emit-llvm -o - | FileCheck --check-prefix=NOOMP %s

const int size = 1024 * 1024 * 32;

double A[size];

void foo(void);

int main() {
  int i = 0;

#pragma omp parallel for
  for (i = 0; i < size; ++i) {
    A[i] = 0.0;
  }

  foo();

  return 0;
}

void foo(void) {
  int i = 0;

#pragma omp parallel for
  for (i = 0; i < size; ++i) {
    A[i] = 1.0;
  }
}
// OMP-LABEL: @foo(
// OMP-NEXT:  entry:
// OMP-NEXT:    [[I:%.*]] = alloca i32, align 4
// OMP-NEXT:    store i32 0, i32* [[I]], align 4
// OMP-NEXT:    call void (%struct.ident_t*, i32, void (i32*, i32*, ...)*, ...) @__kmpc_fork_call(%struct.ident_t* [[GLOB2:@.*]], i32 0, void (i32*, i32*, ...)* bitcast (void (i32*, i32*)* @.omp_outlined. to void (i32*, i32*, ...)*))
// OMP-NEXT:    ret void
//
//
// OMP-LABEL: @.omp_outlined.(
// OMP-NEXT:  entry:
// OMP-NEXT:    [[DOTGLOBAL_TID__ADDR:%.*]] = alloca i32*, align 8
// OMP-NEXT:    [[DOTBOUND_TID__ADDR:%.*]] = alloca i32*, align 8
// OMP-NEXT:    [[DOTOMP_IV:%.*]] = alloca i32, align 4
// OMP-NEXT:    [[TMP:%.*]] = alloca i32, align 4
// OMP-NEXT:    [[DOTOMP_LB:%.*]] = alloca i32, align 4
// OMP-NEXT:    [[DOTOMP_UB:%.*]] = alloca i32, align 4
// OMP-NEXT:    [[DOTOMP_STRIDE:%.*]] = alloca i32, align 4
// OMP-NEXT:    [[DOTOMP_IS_LAST:%.*]] = alloca i32, align 4
// OMP-NEXT:    [[I:%.*]] = alloca i32, align 4
// OMP-NEXT:    store i32* [[DOTGLOBAL_TID_:%.*]], i32** [[DOTGLOBAL_TID__ADDR]], align 8
// OMP-NEXT:    store i32* [[DOTBOUND_TID_:%.*]], i32** [[DOTBOUND_TID__ADDR]], align 8
// OMP-NEXT:    store i32 0, i32* [[DOTOMP_LB]], align 4
// OMP-NEXT:    store i32 33554431, i32* [[DOTOMP_UB]], align 4
// OMP-NEXT:    store i32 1, i32* [[DOTOMP_STRIDE]], align 4
// OMP-NEXT:    store i32 0, i32* [[DOTOMP_IS_LAST]], align 4
// OMP-NEXT:    [[TMP0:%.*]] = load i32*, i32** [[DOTGLOBAL_TID__ADDR]], align 8
// OMP-NEXT:    [[TMP1:%.*]] = load i32, i32* [[TMP0]], align 4
// OMP-NEXT:    call void @__kmpc_for_static_init_4(%struct.ident_t* [[GLOB1:@.*]], i32 [[TMP1]], i32 34, i32* [[DOTOMP_IS_LAST]], i32* [[DOTOMP_LB]], i32* [[DOTOMP_UB]], i32* [[DOTOMP_STRIDE]], i32 1, i32 1)
// OMP-NEXT:    [[TMP2:%.*]] = load i32, i32* [[DOTOMP_UB]], align 4
// OMP-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[TMP2]], 33554431
// OMP-NEXT:    br i1 [[CMP]], label [[COND_TRUE:%.*]], label [[COND_FALSE:%.*]]
// OMP:       cond.true:
// OMP-NEXT:    br label [[COND_END:%.*]]
// OMP:       cond.false:
// OMP-NEXT:    [[TMP3:%.*]] = load i32, i32* [[DOTOMP_UB]], align 4
// OMP-NEXT:    br label [[COND_END]]
// OMP:       cond.end:
// OMP-NEXT:    [[COND:%.*]] = phi i32 [ 33554431, [[COND_TRUE]] ], [ [[TMP3]], [[COND_FALSE]] ]
// OMP-NEXT:    store i32 [[COND]], i32* [[DOTOMP_UB]], align 4
// OMP-NEXT:    [[TMP4:%.*]] = load i32, i32* [[DOTOMP_LB]], align 4
// OMP-NEXT:    store i32 [[TMP4]], i32* [[DOTOMP_IV]], align 4
// OMP-NEXT:    br label [[OMP_INNER_FOR_COND:%.*]]
// OMP:       omp.inner.for.cond:
// OMP-NEXT:    [[TMP5:%.*]] = load i32, i32* [[DOTOMP_IV]], align 4
// OMP-NEXT:    [[TMP6:%.*]] = load i32, i32* [[DOTOMP_UB]], align 4
// OMP-NEXT:    [[CMP1:%.*]] = icmp sle i32 [[TMP5]], [[TMP6]]
// OMP-NEXT:    br i1 [[CMP1]], label [[OMP_INNER_FOR_BODY:%.*]], label [[OMP_INNER_FOR_END:%.*]]
// OMP:       omp.inner.for.body:
// OMP-NEXT:    [[TMP7:%.*]] = load i32, i32* [[DOTOMP_IV]], align 4
// OMP-NEXT:    [[MUL:%.*]] = mul nsw i32 [[TMP7]], 1
// OMP-NEXT:    [[ADD:%.*]] = add nsw i32 0, [[MUL]]
// OMP-NEXT:    store i32 [[ADD]], i32* [[I]], align 4
// OMP-NEXT:    [[TMP8:%.*]] = load i32, i32* [[I]], align 4
// OMP-NEXT:    [[IDXPROM:%.*]] = sext i32 [[TMP8]] to i64
// OMP-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [33554432 x double], [33554432 x double]* @A, i64 0, i64 [[IDXPROM]]
// OMP-NEXT:    store double 1.000000e+00, double* [[ARRAYIDX]], align 8
// OMP-NEXT:    br label [[OMP_BODY_CONTINUE:%.*]]
// OMP:       omp.body.continue:
// OMP-NEXT:    br label [[OMP_INNER_FOR_INC:%.*]]
// OMP:       omp.inner.for.inc:
// OMP-NEXT:    [[TMP9:%.*]] = load i32, i32* [[DOTOMP_IV]], align 4
// OMP-NEXT:    [[ADD2:%.*]] = add nsw i32 [[TMP9]], 1
// OMP-NEXT:    store i32 [[ADD2]], i32* [[DOTOMP_IV]], align 4
// OMP-NEXT:    br label [[OMP_INNER_FOR_COND]]
// OMP:       omp.inner.for.end:
// OMP-NEXT:    br label [[OMP_LOOP_EXIT:%.*]]
// OMP:       omp.loop.exit:
// OMP-NEXT:    call void @__kmpc_for_static_fini(%struct.ident_t* [[GLOB1]], i32 [[TMP1]])
// OMP-NEXT:    ret void
//
//
// OMP-LABEL: @main(
// OMP-NEXT:  entry:
// OMP-NEXT:    [[RETVAL:%.*]] = alloca i32, align 4
// OMP-NEXT:    [[I:%.*]] = alloca i32, align 4
// OMP-NEXT:    store i32 0, i32* [[RETVAL]], align 4
// OMP-NEXT:    store i32 0, i32* [[I]], align 4
// OMP-NEXT:    call void (%struct.ident_t*, i32, void (i32*, i32*, ...)*, ...) @__kmpc_fork_call(%struct.ident_t* [[GLOB2]], i32 0, void (i32*, i32*, ...)* bitcast (void (i32*, i32*)* @.omp_outlined..1 to void (i32*, i32*, ...)*))
// OMP-NEXT:    call void @foo()
// OMP-NEXT:    ret i32 0
//
//
// OMP-LABEL: @.omp_outlined..1(
// OMP-NEXT:  entry:
// OMP-NEXT:    [[DOTGLOBAL_TID__ADDR:%.*]] = alloca i32*, align 8
// OMP-NEXT:    [[DOTBOUND_TID__ADDR:%.*]] = alloca i32*, align 8
// OMP-NEXT:    [[DOTOMP_IV:%.*]] = alloca i32, align 4
// OMP-NEXT:    [[TMP:%.*]] = alloca i32, align 4
// OMP-NEXT:    [[DOTOMP_LB:%.*]] = alloca i32, align 4
// OMP-NEXT:    [[DOTOMP_UB:%.*]] = alloca i32, align 4
// OMP-NEXT:    [[DOTOMP_STRIDE:%.*]] = alloca i32, align 4
// OMP-NEXT:    [[DOTOMP_IS_LAST:%.*]] = alloca i32, align 4
// OMP-NEXT:    [[I:%.*]] = alloca i32, align 4
// OMP-NEXT:    store i32* [[DOTGLOBAL_TID_:%.*]], i32** [[DOTGLOBAL_TID__ADDR]], align 8
// OMP-NEXT:    store i32* [[DOTBOUND_TID_:%.*]], i32** [[DOTBOUND_TID__ADDR]], align 8
// OMP-NEXT:    store i32 0, i32* [[DOTOMP_LB]], align 4
// OMP-NEXT:    store i32 33554431, i32* [[DOTOMP_UB]], align 4
// OMP-NEXT:    store i32 1, i32* [[DOTOMP_STRIDE]], align 4
// OMP-NEXT:    store i32 0, i32* [[DOTOMP_IS_LAST]], align 4
// OMP-NEXT:    [[TMP0:%.*]] = load i32*, i32** [[DOTGLOBAL_TID__ADDR]], align 8
// OMP-NEXT:    [[TMP1:%.*]] = load i32, i32* [[TMP0]], align 4
// OMP-NEXT:    call void @__kmpc_for_static_init_4(%struct.ident_t* [[GLOB1]], i32 [[TMP1]], i32 34, i32* [[DOTOMP_IS_LAST]], i32* [[DOTOMP_LB]], i32* [[DOTOMP_UB]], i32* [[DOTOMP_STRIDE]], i32 1, i32 1)
// OMP-NEXT:    [[TMP2:%.*]] = load i32, i32* [[DOTOMP_UB]], align 4
// OMP-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[TMP2]], 33554431
// OMP-NEXT:    br i1 [[CMP]], label [[COND_TRUE:%.*]], label [[COND_FALSE:%.*]]
// OMP:       cond.true:
// OMP-NEXT:    br label [[COND_END:%.*]]
// OMP:       cond.false:
// OMP-NEXT:    [[TMP3:%.*]] = load i32, i32* [[DOTOMP_UB]], align 4
// OMP-NEXT:    br label [[COND_END]]
// OMP:       cond.end:
// OMP-NEXT:    [[COND:%.*]] = phi i32 [ 33554431, [[COND_TRUE]] ], [ [[TMP3]], [[COND_FALSE]] ]
// OMP-NEXT:    store i32 [[COND]], i32* [[DOTOMP_UB]], align 4
// OMP-NEXT:    [[TMP4:%.*]] = load i32, i32* [[DOTOMP_LB]], align 4
// OMP-NEXT:    store i32 [[TMP4]], i32* [[DOTOMP_IV]], align 4
// OMP-NEXT:    br label [[OMP_INNER_FOR_COND:%.*]]
// OMP:       omp.inner.for.cond:
// OMP-NEXT:    [[TMP5:%.*]] = load i32, i32* [[DOTOMP_IV]], align 4
// OMP-NEXT:    [[TMP6:%.*]] = load i32, i32* [[DOTOMP_UB]], align 4
// OMP-NEXT:    [[CMP1:%.*]] = icmp sle i32 [[TMP5]], [[TMP6]]
// OMP-NEXT:    br i1 [[CMP1]], label [[OMP_INNER_FOR_BODY:%.*]], label [[OMP_INNER_FOR_END:%.*]]
// OMP:       omp.inner.for.body:
// OMP-NEXT:    [[TMP7:%.*]] = load i32, i32* [[DOTOMP_IV]], align 4
// OMP-NEXT:    [[MUL:%.*]] = mul nsw i32 [[TMP7]], 1
// OMP-NEXT:    [[ADD:%.*]] = add nsw i32 0, [[MUL]]
// OMP-NEXT:    store i32 [[ADD]], i32* [[I]], align 4
// OMP-NEXT:    [[TMP8:%.*]] = load i32, i32* [[I]], align 4
// OMP-NEXT:    [[IDXPROM:%.*]] = sext i32 [[TMP8]] to i64
// OMP-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [33554432 x double], [33554432 x double]* @A, i64 0, i64 [[IDXPROM]]
// OMP-NEXT:    store double 0.000000e+00, double* [[ARRAYIDX]], align 8
// OMP-NEXT:    br label [[OMP_BODY_CONTINUE:%.*]]
// OMP:       omp.body.continue:
// OMP-NEXT:    br label [[OMP_INNER_FOR_INC:%.*]]
// OMP:       omp.inner.for.inc:
// OMP-NEXT:    [[TMP9:%.*]] = load i32, i32* [[DOTOMP_IV]], align 4
// OMP-NEXT:    [[ADD2:%.*]] = add nsw i32 [[TMP9]], 1
// OMP-NEXT:    store i32 [[ADD2]], i32* [[DOTOMP_IV]], align 4
// OMP-NEXT:    br label [[OMP_INNER_FOR_COND]]
// OMP:       omp.inner.for.end:
// OMP-NEXT:    br label [[OMP_LOOP_EXIT:%.*]]
// OMP:       omp.loop.exit:
// OMP-NEXT:    call void @__kmpc_for_static_fini(%struct.ident_t* [[GLOB1]], i32 [[TMP1]])
// OMP-NEXT:    ret void
//
//
// NOOMP-LABEL: @main(
// NOOMP-NEXT:  entry:
// NOOMP-NEXT:    [[RETVAL:%.*]] = alloca i32, align 4
// NOOMP-NEXT:    [[I:%.*]] = alloca i32, align 4
// NOOMP-NEXT:    store i32 0, i32* [[RETVAL]], align 4
// NOOMP-NEXT:    store i32 0, i32* [[I]], align 4
// NOOMP-NEXT:    store i32 0, i32* [[I]], align 4
// NOOMP-NEXT:    br label [[FOR_COND:%.*]]
// NOOMP:       for.cond:
// NOOMP-NEXT:    [[TMP0:%.*]] = load i32, i32* [[I]], align 4
// NOOMP-NEXT:    [[CMP:%.*]] = icmp slt i32 [[TMP0]], 33554432
// NOOMP-NEXT:    br i1 [[CMP]], label [[FOR_BODY:%.*]], label [[FOR_END:%.*]]
// NOOMP:       for.body:
// NOOMP-NEXT:    [[TMP1:%.*]] = load i32, i32* [[I]], align 4
// NOOMP-NEXT:    [[IDXPROM:%.*]] = sext i32 [[TMP1]] to i64
// NOOMP-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [33554432 x double], [33554432 x double]* @A, i64 0, i64 [[IDXPROM]]
// NOOMP-NEXT:    store double 0.000000e+00, double* [[ARRAYIDX]], align 8
// NOOMP-NEXT:    br label [[FOR_INC:%.*]]
// NOOMP:       for.inc:
// NOOMP-NEXT:    [[TMP2:%.*]] = load i32, i32* [[I]], align 4
// NOOMP-NEXT:    [[INC:%.*]] = add nsw i32 [[TMP2]], 1
// NOOMP-NEXT:    store i32 [[INC]], i32* [[I]], align 4
// NOOMP-NEXT:    br label [[FOR_COND]]
// NOOMP:       for.end:
// NOOMP-NEXT:    call void @foo()
// NOOMP-NEXT:    ret i32 0
//
//
// NOOMP-LABEL: @foo(
// NOOMP-NEXT:  entry:
// NOOMP-NEXT:    [[I:%.*]] = alloca i32, align 4
// NOOMP-NEXT:    store i32 0, i32* [[I]], align 4
// NOOMP-NEXT:    store i32 0, i32* [[I]], align 4
// NOOMP-NEXT:    br label [[FOR_COND:%.*]]
// NOOMP:       for.cond:
// NOOMP-NEXT:    [[TMP0:%.*]] = load i32, i32* [[I]], align 4
// NOOMP-NEXT:    [[CMP:%.*]] = icmp slt i32 [[TMP0]], 33554432
// NOOMP-NEXT:    br i1 [[CMP]], label [[FOR_BODY:%.*]], label [[FOR_END:%.*]]
// NOOMP:       for.body:
// NOOMP-NEXT:    [[TMP1:%.*]] = load i32, i32* [[I]], align 4
// NOOMP-NEXT:    [[IDXPROM:%.*]] = sext i32 [[TMP1]] to i64
// NOOMP-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [33554432 x double], [33554432 x double]* @A, i64 0, i64 [[IDXPROM]]
// NOOMP-NEXT:    store double 1.000000e+00, double* [[ARRAYIDX]], align 8
// NOOMP-NEXT:    br label [[FOR_INC:%.*]]
// NOOMP:       for.inc:
// NOOMP-NEXT:    [[TMP2:%.*]] = load i32, i32* [[I]], align 4
// NOOMP-NEXT:    [[INC:%.*]] = add nsw i32 [[TMP2]], 1
// NOOMP-NEXT:    store i32 [[INC]], i32* [[I]], align 4
// NOOMP-NEXT:    br label [[FOR_COND]]
// NOOMP:       for.end:
// NOOMP-NEXT:    ret void
//
