e112151a35826 (Nick Lewycky             2013-01-24 01:12:16 +0000     1) //===--- SemaOverload.cpp - C++ Overloading -------------------------------===//
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000     2) //
2946cd7010674 (Chandler Carruth         2019-01-19 08:50:56 +0000     3) // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
2946cd7010674 (Chandler Carruth         2019-01-19 08:50:56 +0000     4) // See https://llvm.org/LICENSE.txt for license information.
2946cd7010674 (Chandler Carruth         2019-01-19 08:50:56 +0000     5) // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000     6) //
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000     7) //===----------------------------------------------------------------------===//
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000     8) //
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000     9) // This file provides Sema routines for C++ overloading.
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000    10) //
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000    11) //===----------------------------------------------------------------------===//
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000    12) 
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000    13) #include "clang/AST/ASTContext.h"
36d1b14ddedb3 (Douglas Gregor           2009-10-06 17:59:45 +0000    14) #include "clang/AST/CXXInheritance.h"
de6836a384d86 (John McCall              2010-08-24 07:21:54 +0000    15) #include "clang/AST/DeclObjC.h"
67d25914b2a42 (Haojian Wu               2020-03-16 13:43:40 +0100    16) #include "clang/AST/DependenceFlags.h"
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000    17) #include "clang/AST/Expr.h"
91cea0ad1e4cd (Douglas Gregor           2008-11-19 21:05:33 +0000    18) #include "clang/AST/ExprCXX.h"
e26a872b02740 (John McCall              2010-12-04 08:14:53 +0000    19) #include "clang/AST/ExprObjC.h"
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000    20) #include "clang/AST/TypeOrdering.h"
3a02247dc9e39 (Chandler Carruth         2012-12-04 09:13:33 +0000    21) #include "clang/Basic/Diagnostic.h"
f3ca2698393c5 (Benjamin Kramer          2014-05-10 16:31:55 +0000    22) #include "clang/Basic/DiagnosticOptions.h"
d624e16833af6 (Anders Carlsson          2009-08-26 23:45:07 +0000    23) #include "clang/Basic/PartialDiagnostic.h"
86565c1309423 (Reid Kleckner            2020-02-27 11:01:58 -0800    24) #include "clang/Basic/SourceManager.h"
c729b0b50669e (David Majnemer           2013-09-16 22:44:20 +0000    25) #include "clang/Basic/TargetInfo.h"
3a02247dc9e39 (Chandler Carruth         2012-12-04 09:13:33 +0000    26) #include "clang/Sema/Initialization.h"
3a02247dc9e39 (Chandler Carruth         2012-12-04 09:13:33 +0000    27) #include "clang/Sema/Lookup.h"
ec3060c72de6a (Ilya Biryukov            2020-03-02 16:07:09 +0100    28) #include "clang/Sema/Overload.h"
3a02247dc9e39 (Chandler Carruth         2012-12-04 09:13:33 +0000    29) #include "clang/Sema/SemaInternal.h"
3a02247dc9e39 (Chandler Carruth         2012-12-04 09:13:33 +0000    30) #include "clang/Sema/Template.h"
3a02247dc9e39 (Chandler Carruth         2012-12-04 09:13:33 +0000    31) #include "clang/Sema/TemplateDeduction.h"
2bbc0266e0749 (Douglas Gregor           2010-09-12 04:28:07 +0000    32) #include "llvm/ADT/DenseSet.h"
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000    33) #include "llvm/ADT/Optional.h"
3a02247dc9e39 (Chandler Carruth         2012-12-04 09:13:33 +0000    34) #include "llvm/ADT/STLExtras.h"
58e008d2a61a7 (Douglas Gregor           2008-11-13 20:12:29 +0000    35) #include "llvm/ADT/SmallPtrSet.h"
9ca6461f5a9ac (Richard Smith            2012-05-07 09:03:25 +0000    36) #include "llvm/ADT/SmallString.h"
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000    37) #include <algorithm>
8ad22e6a5cb2c (David Blaikie            2014-05-01 23:01:41 +0000    38) #include <cstdlib>
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000    39) 
17c00b43288dc (Richard Smith            2014-11-12 01:24:00 +0000    40) using namespace clang;
19c1bfd1b0750 (John McCall              2010-08-25 05:32:35 +0000    41) using namespace sema;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000    42) 
d28763cad06e6 (Richard Smith            2020-01-29 12:07:14 -0800    43) using AllowedExplicit = Sema::AllowedExplicit;
d28763cad06e6 (Richard Smith            2020-01-29 12:07:14 -0800    44) 
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000    45) static bool functionHasPassObjectSizeParams(const FunctionDecl *FD) {
21081364f84dc (George Burgess IV        2016-07-24 23:12:40 +0000    46)   return llvm::any_of(FD->parameters(), [](const ParmVarDecl *P) {
21081364f84dc (George Burgess IV        2016-07-24 23:12:40 +0000    47)     return P->hasAttr<PassObjectSizeAttr>();
21081364f84dc (George Burgess IV        2016-07-24 23:12:40 +0000    48)   });
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000    49) }
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000    50) 
134af91b06493 (Nick Lewycky             2013-02-07 05:08:22 +0000    51) /// A convenience routine for creating a decayed reference to a function.
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000    52) static ExprResult
134af91b06493 (Nick Lewycky             2013-02-07 05:08:22 +0000    53) CreateFunctionRefExpr(Sema &S, FunctionDecl *Fn, NamedDecl *FoundDecl,
2246167362bf3 (Akira Hatanaka           2017-07-13 06:08:27 +0000    54)                       const Expr *Base, bool HadMultipleCandidates,
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000    55)                       SourceLocation Loc = SourceLocation(),
e9d62935d3c42 (Douglas Gregor           2011-07-15 16:25:15 +0000    56)                       const DeclarationNameLoc &LocInfo = DeclarationNameLoc()){
22262abd78af0 (Richard Smith            2013-05-04 06:44:46 +0000    57)   if (S.DiagnoseUseOfDecl(FoundDecl, Loc))
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000    58)     return ExprError();
d667641542527 (Faisal Vali              2013-06-15 11:54:37 +0000    59)   // If FoundDecl is different from Fn (such as if one is a template
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000    60)   // and the other a specialization), make sure DiagnoseUseOfDecl is
d667641542527 (Faisal Vali              2013-06-15 11:54:37 +0000    61)   // called on both.
d667641542527 (Faisal Vali              2013-06-15 11:54:37 +0000    62)   // FIXME: This would be more comprehensively addressed by modifying
d667641542527 (Faisal Vali              2013-06-15 11:54:37 +0000    63)   // DiagnoseUseOfDecl to accept both the FoundDecl and the decl
d667641542527 (Faisal Vali              2013-06-15 11:54:37 +0000    64)   // being used.
d667641542527 (Faisal Vali              2013-06-15 11:54:37 +0000    65)   if (FoundDecl != Fn && S.DiagnoseUseOfDecl(Fn, Loc))
22262abd78af0 (Richard Smith            2013-05-04 06:44:46 +0000    66)     return ExprError();
5fc4db75798c8 (Bruno Ricci              2018-12-21 14:10:18 +0000    67)   DeclRefExpr *DRE = new (S.Context)
5fc4db75798c8 (Bruno Ricci              2018-12-21 14:10:18 +0000    68)       DeclRefExpr(S.Context, Fn, false, Fn->getType(), VK_LValue, Loc, LocInfo);
635ed24e1dad8 (Abramo Bagnara           2011-10-05 07:56:41 +0000    69)   if (HadMultipleCandidates)
635ed24e1dad8 (Abramo Bagnara           2011-10-05 07:56:41 +0000    70)     DRE->setHadMultipleCandidates(true);
134af91b06493 (Nick Lewycky             2013-02-07 05:08:22 +0000    71) 
2246167362bf3 (Akira Hatanaka           2017-07-13 06:08:27 +0000    72)   S.MarkDeclRefReferenced(DRE, Base);
0ec1e99001291 (Richard Smith            2019-12-13 14:06:24 -0800    73)   if (auto *FPT = DRE->getType()->getAs<FunctionProtoType>()) {
0ec1e99001291 (Richard Smith            2019-12-13 14:06:24 -0800    74)     if (isUnresolvedExceptionSpec(FPT->getExceptionSpecType())) {
0ec1e99001291 (Richard Smith            2019-12-13 14:06:24 -0800    75)       S.ResolveExceptionSpec(Loc, FPT);
0ec1e99001291 (Richard Smith            2019-12-13 14:06:24 -0800    76)       DRE->setType(Fn->getType());
0ec1e99001291 (Richard Smith            2019-12-13 14:06:24 -0800    77)     }
0ec1e99001291 (Richard Smith            2019-12-13 14:06:24 -0800    78)   }
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000    79)   return S.ImpCastExprToType(DRE, S.Context.getPointerType(DRE->getType()),
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000    80)                              CK_FunctionToPointerDecay);
7decc9e4ea6c5 (John McCall              2010-11-18 06:31:45 +0000    81) }
7decc9e4ea6c5 (John McCall              2010-11-18 06:31:45 +0000    82) 
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000    83) static bool IsStandardConversion(Sema &S, Expr* From, QualType ToType,
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000    84)                                  bool InOverloadResolution,
582813596a100 (Douglas Gregor           2011-01-27 00:58:17 +0000    85)                                  StandardConversionSequence &SCS,
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000    86)                                  bool CStyle,
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000    87)                                  bool AllowObjCWritebackConversion);
04390a63c89b0 (Sam Panzer               2012-08-16 02:38:47 +0000    88) 
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000    89) static bool IsTransparentUnionStandardConversion(Sema &S, Expr* From,
16f92ce539d49 (Fariborz Jahanian        2011-03-23 19:50:54 +0000    90)                                                  QualType &ToType,
16f92ce539d49 (Fariborz Jahanian        2011-03-23 19:50:54 +0000    91)                                                  bool InOverloadResolution,
16f92ce539d49 (Fariborz Jahanian        2011-03-23 19:50:54 +0000    92)                                                  StandardConversionSequence &SCS,
16f92ce539d49 (Fariborz Jahanian        2011-03-23 19:50:54 +0000    93)                                                  bool CStyle);
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000    94) static OverloadingResult
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000    95) IsUserDefinedConversion(Sema &S, Expr *From, QualType ToType,
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000    96)                         UserDefinedConversionSequence& User,
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000    97)                         OverloadCandidateSet& Conversions,
d28763cad06e6 (Richard Smith            2020-01-29 12:07:14 -0800    98)                         AllowedExplicit AllowExplicit,
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000    99)                         bool AllowObjCConversionOnExplicit);
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000   100) 
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000   101) static ImplicitConversionSequence::CompareKind
0f59cb38e7f31 (Richard Smith            2015-12-18 21:45:41 +0000   102) CompareStandardConversionSequences(Sema &S, SourceLocation Loc,
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000   103)                                    const StandardConversionSequence& SCS1,
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000   104)                                    const StandardConversionSequence& SCS2);
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000   105) 
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000   106) static ImplicitConversionSequence::CompareKind
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000   107) CompareQualificationConversions(Sema &S,
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000   108)                                 const StandardConversionSequence& SCS1,
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000   109)                                 const StandardConversionSequence& SCS2);
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000   110) 
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000   111) static ImplicitConversionSequence::CompareKind
0f59cb38e7f31 (Richard Smith            2015-12-18 21:45:41 +0000   112) CompareDerivedToBaseConversions(Sema &S, SourceLocation Loc,
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000   113)                                 const StandardConversionSequence& SCS1,
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000   114)                                 const StandardConversionSequence& SCS2);
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000   115) 
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   116) /// GetConversionRank - Retrieve the implicit conversion rank
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   117) /// corresponding to the given implicit conversion kind.
17c00b43288dc (Richard Smith            2014-11-12 01:24:00 +0000   118) ImplicitConversionRank clang::GetConversionRank(ImplicitConversionKind Kind) {
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   119)   static const ImplicitConversionRank
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   120)     Rank[(int)ICK_Num_Conversion_Kinds] = {
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   121)     ICR_Exact_Match,
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   122)     ICR_Exact_Match,
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   123)     ICR_Exact_Match,
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   124)     ICR_Exact_Match,
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   125)     ICR_Exact_Match,
40cb9ad391af6 (Douglas Gregor           2009-12-09 00:47:37 +0000   126)     ICR_Exact_Match,
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   127)     ICR_Promotion,
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   128)     ICR_Promotion,
78ca74d81d935 (Douglas Gregor           2009-02-12 00:15:05 +0000   129)     ICR_Promotion,
78ca74d81d935 (Douglas Gregor           2009-02-12 00:15:05 +0000   130)     ICR_Conversion,
78ca74d81d935 (Douglas Gregor           2009-02-12 00:15:05 +0000   131)     ICR_Conversion,
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   132)     ICR_Conversion,
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   133)     ICR_Conversion,
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   134)     ICR_Conversion,
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   135)     ICR_Conversion,
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   136)     ICR_Conversion,
786ab2119f288 (Douglas Gregor           2008-10-29 02:00:59 +0000   137)     ICR_Conversion,
4e5cbdcbed0b0 (Douglas Gregor           2009-02-11 23:02:49 +0000   138)     ICR_Conversion,
4618868a7d0de (Douglas Gregor           2010-05-18 22:42:18 +0000   139)     ICR_Conversion,
feed5a7239d8e (Cullen Rhodes            2020-08-11 13:04:21 +0000   140)     ICR_Conversion,
c217f37cb663b (Egor Churaev             2017-03-21 12:55:55 +0000   141)     ICR_OCL_Scalar_Widening,
16f92ce539d49 (Fariborz Jahanian        2011-03-23 19:50:54 +0000   142)     ICR_Complex_Real_Conversion,
16f92ce539d49 (Fariborz Jahanian        2011-03-23 19:50:54 +0000   143)     ICR_Conversion,
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000   144)     ICR_Conversion,
4546181e12c89 (George Burgess IV        2015-10-11 20:13:20 +0000   145)     ICR_Writeback_Conversion,
4546181e12c89 (George Burgess IV        2015-10-11 20:13:20 +0000   146)     ICR_Exact_Match, // NOTE(gbiv): This may not be completely right --
4546181e12c89 (George Burgess IV        2015-10-11 20:13:20 +0000   147)                      // it was omitted by the patch that added
4546181e12c89 (George Burgess IV        2015-10-11 20:13:20 +0000   148)                      // ICK_Zero_Event_Conversion
2099b54102e7d (George Burgess IV        2016-09-02 22:59:57 +0000   149)     ICR_C_Conversion,
2099b54102e7d (George Burgess IV        2016-09-02 22:59:57 +0000   150)     ICR_C_Conversion_Extension
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   151)   };
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   152)   return Rank[(int)Kind];
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   153) }
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   154) 
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   155) /// GetImplicitConversionName - Return the name of this kind of
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   156) /// implicit conversion.
17c00b43288dc (Richard Smith            2014-11-12 01:24:00 +0000   157) static const char* GetImplicitConversionName(ImplicitConversionKind Kind) {
cfca1f0dc1cda (Nuno Lopes               2009-12-23 17:49:57 +0000   158)   static const char* const Name[(int)ICK_Num_Conversion_Kinds] = {
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   159)     "No conversion",
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   160)     "Lvalue-to-rvalue",
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   161)     "Array-to-pointer",
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   162)     "Function-to-pointer",
3c4f8d2e96c4b (Richard Smith            2016-10-16 17:54:23 +0000   163)     "Function pointer conversion",
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   164)     "Qualification",
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   165)     "Integral promotion",
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   166)     "Floating point promotion",
78ca74d81d935 (Douglas Gregor           2009-02-12 00:15:05 +0000   167)     "Complex promotion",
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   168)     "Integral conversion",
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   169)     "Floating conversion",
78ca74d81d935 (Douglas Gregor           2009-02-12 00:15:05 +0000   170)     "Complex conversion",
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   171)     "Floating-integral conversion",
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   172)     "Pointer conversion",
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   173)     "Pointer-to-member conversion",
786ab2119f288 (Douglas Gregor           2008-10-29 02:00:59 +0000   174)     "Boolean conversion",
4e5cbdcbed0b0 (Douglas Gregor           2009-02-11 23:02:49 +0000   175)     "Compatible-types conversion",
4618868a7d0de (Douglas Gregor           2010-05-18 22:42:18 +0000   176)     "Derived-to-base conversion",
4618868a7d0de (Douglas Gregor           2010-05-18 22:42:18 +0000   177)     "Vector conversion",
feed5a7239d8e (Cullen Rhodes            2020-08-11 13:04:21 +0000   178)     "SVE Vector conversion",
4618868a7d0de (Douglas Gregor           2010-05-18 22:42:18 +0000   179)     "Vector splat",
16f92ce539d49 (Fariborz Jahanian        2011-03-23 19:50:54 +0000   180)     "Complex-real conversion",
16f92ce539d49 (Fariborz Jahanian        2011-03-23 19:50:54 +0000   181)     "Block Pointer conversion",
55635cea27f25 (Sylvestre Ledru          2014-11-17 19:41:49 +0000   182)     "Transparent Union Conversion",
4546181e12c89 (George Burgess IV        2015-10-11 20:13:20 +0000   183)     "Writeback conversion",
4546181e12c89 (George Burgess IV        2015-10-11 20:13:20 +0000   184)     "OpenCL Zero Event Conversion",
2099b54102e7d (George Burgess IV        2016-09-02 22:59:57 +0000   185)     "C specific type conversion",
2099b54102e7d (George Burgess IV        2016-09-02 22:59:57 +0000   186)     "Incompatible pointer conversion"
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   187)   };
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   188)   return Name[Kind];
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   189) }
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   190) 
26bee0b326227 (Douglas Gregor           2008-10-31 16:23:19 +0000   191) /// StandardConversionSequence - Set the standard conversion
26bee0b326227 (Douglas Gregor           2008-10-31 16:23:19 +0000   192) /// sequence to the identity conversion.
26bee0b326227 (Douglas Gregor           2008-10-31 16:23:19 +0000   193) void StandardConversionSequence::setAsIdentityConversion() {
26bee0b326227 (Douglas Gregor           2008-10-31 16:23:19 +0000   194)   First = ICK_Identity;
26bee0b326227 (Douglas Gregor           2008-10-31 16:23:19 +0000   195)   Second = ICK_Identity;
26bee0b326227 (Douglas Gregor           2008-10-31 16:23:19 +0000   196)   Third = ICK_Identity;
e489a7d3d3972 (Douglas Gregor           2010-02-28 18:30:25 +0000   197)   DeprecatedStringLiteralToCharPtr = false;
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000   198)   QualificationIncludesObjCLifetime = false;
26bee0b326227 (Douglas Gregor           2008-10-31 16:23:19 +0000   199)   ReferenceBinding = false;
26bee0b326227 (Douglas Gregor           2008-10-31 16:23:19 +0000   200)   DirectBinding = false;
e696ebbd70b3d (Douglas Gregor           2011-01-26 14:52:12 +0000   201)   IsLvalueReference = true;
e696ebbd70b3d (Douglas Gregor           2011-01-26 14:52:12 +0000   202)   BindsToFunctionLvalue = false;
e696ebbd70b3d (Douglas Gregor           2011-01-26 14:52:12 +0000   203)   BindsToRvalue = false;
e1a47c176656a (Douglas Gregor           2011-01-26 19:41:18 +0000   204)   BindsImplicitObjectArgumentWithoutRefQualifier = false;
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000   205)   ObjCLifetimeConversionBinding = false;
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000   206)   CopyConstructor = nullptr;
26bee0b326227 (Douglas Gregor           2008-10-31 16:23:19 +0000   207) }
26bee0b326227 (Douglas Gregor           2008-10-31 16:23:19 +0000   208) 
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   209) /// getRank - Retrieve the rank of this standard conversion sequence
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   210) /// (C++ 13.3.3.1.1p3). The rank is the largest rank of each of the
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   211) /// implicit conversions.
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   212) ImplicitConversionRank StandardConversionSequence::getRank() const {
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   213)   ImplicitConversionRank Rank = ICR_Exact_Match;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   214)   if  (GetConversionRank(First) > Rank)
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   215)     Rank = GetConversionRank(First);
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   216)   if  (GetConversionRank(Second) > Rank)
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   217)     Rank = GetConversionRank(Second);
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   218)   if  (GetConversionRank(Third) > Rank)
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   219)     Rank = GetConversionRank(Third);
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   220)   return Rank;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   221) }
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   222) 
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   223) /// isPointerConversionToBool - Determines whether this conversion is
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   224) /// a conversion of a pointer or pointer-to-member to bool. This is
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000   225) /// used as part of the ranking of standard conversion sequences
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   226) /// (C++ 13.3.3.2p4).
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000   227) bool StandardConversionSequence::isPointerConversionToBool() const {
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   228)   // Note that FromType has not necessarily been transformed by the
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   229)   // array-to-pointer or function-to-pointer implicit conversions, so
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   230)   // check for their presence as well as checking whether FromType is
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   231)   // a pointer.
3edc4d5ec3fdc (Douglas Gregor           2010-01-27 03:51:04 +0000   232)   if (getToType(1)->isBooleanType() &&
6d1116ac4967b (John McCall              2010-06-11 10:04:22 +0000   233)       (getFromType()->isPointerType() ||
2fcbe9283fb9f (Erich Keane              2018-06-12 13:59:32 +0000   234)        getFromType()->isMemberPointerType() ||
6d1116ac4967b (John McCall              2010-06-11 10:04:22 +0000   235)        getFromType()->isObjCObjectPointerType() ||
6d1116ac4967b (John McCall              2010-06-11 10:04:22 +0000   236)        getFromType()->isBlockPointerType() ||
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   237)        First == ICK_Array_To_Pointer || First == ICK_Function_To_Pointer))
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   238)     return true;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   239) 
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   240)   return false;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   241) }
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   242) 
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000   243) /// isPointerConversionToVoidPointer - Determines whether this
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000   244) /// conversion is a conversion of a pointer to a void pointer. This is
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000   245) /// used as part of the ranking of standard conversion sequences (C++
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000   246) /// 13.3.3.2p4).
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000   247) bool
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000   248) StandardConversionSequence::
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000   249) isPointerConversionToVoidPointer(ASTContext& Context) const {
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000   250)   QualType FromType = getFromType();
3edc4d5ec3fdc (Douglas Gregor           2010-01-27 03:51:04 +0000   251)   QualType ToType = getToType(1);
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000   252) 
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000   253)   // Note that FromType has not necessarily been transformed by the
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000   254)   // array-to-pointer implicit conversion, so check for its presence
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000   255)   // and redo the conversion to get a pointer.
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000   256)   if (First == ICK_Array_To_Pointer)
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000   257)     FromType = Context.getArrayDecayedType(FromType);
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000   258) 
5d3d3fa33d44a (Douglas Gregor           2011-04-15 20:45:44 +0000   259)   if (Second == ICK_Pointer_Conversion && FromType->isAnyPointerType())
c23c7e6a51927 (Ted Kremenek             2009-07-29 21:53:49 +0000   260)     if (const PointerType* ToPtrType = ToType->getAs<PointerType>())
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000   261)       return ToPtrType->getPointeeType()->isVoidType();
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000   262) 
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000   263)   return false;
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000   264) }
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000   265) 
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   266) /// Skip any implicit casts which could be either part of a narrowing conversion
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   267) /// or after one in an implicit conversion.
40c3d6e335900 (Richard Smith            2019-09-19 22:00:16 +0000   268) static const Expr *IgnoreNarrowingConversion(ASTContext &Ctx,
40c3d6e335900 (Richard Smith            2019-09-19 22:00:16 +0000   269)                                              const Expr *Converted) {
40c3d6e335900 (Richard Smith            2019-09-19 22:00:16 +0000   270)   // We can have cleanups wrapping the converted expression; these need to be
40c3d6e335900 (Richard Smith            2019-09-19 22:00:16 +0000   271)   // preserved so that destructors run if necessary.
40c3d6e335900 (Richard Smith            2019-09-19 22:00:16 +0000   272)   if (auto *EWC = dyn_cast<ExprWithCleanups>(Converted)) {
40c3d6e335900 (Richard Smith            2019-09-19 22:00:16 +0000   273)     Expr *Inner =
40c3d6e335900 (Richard Smith            2019-09-19 22:00:16 +0000   274)         const_cast<Expr *>(IgnoreNarrowingConversion(Ctx, EWC->getSubExpr()));
40c3d6e335900 (Richard Smith            2019-09-19 22:00:16 +0000   275)     return ExprWithCleanups::Create(Ctx, Inner, EWC->cleanupsHaveSideEffects(),
40c3d6e335900 (Richard Smith            2019-09-19 22:00:16 +0000   276)                                     EWC->getObjects());
40c3d6e335900 (Richard Smith            2019-09-19 22:00:16 +0000   277)   }
40c3d6e335900 (Richard Smith            2019-09-19 22:00:16 +0000   278) 
40c3d6e335900 (Richard Smith            2019-09-19 22:00:16 +0000   279)   while (auto *ICE = dyn_cast<ImplicitCastExpr>(Converted)) {
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   280)     switch (ICE->getCastKind()) {
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   281)     case CK_NoOp:
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   282)     case CK_IntegralCast:
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   283)     case CK_IntegralToBoolean:
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   284)     case CK_IntegralToFloating:
df1ed0099ba6c (George Burgess IV        2016-01-13 01:52:39 +0000   285)     case CK_BooleanToSignedIntegral:
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   286)     case CK_FloatingToIntegral:
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   287)     case CK_FloatingToBoolean:
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   288)     case CK_FloatingCast:
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   289)       Converted = ICE->getSubExpr();
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   290)       continue;
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   291) 
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   292)     default:
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   293)       return Converted;
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   294)     }
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   295)   }
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   296) 
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   297)   return Converted;
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   298) }
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   299) 
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   300) /// Check if this standard conversion sequence represents a narrowing
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   301) /// conversion, according to C++11 [dcl.init.list]p7.
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   302) ///
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   303) /// \param Ctx  The AST context.
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   304) /// \param Converted  The result of applying this standard conversion sequence.
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   305) /// \param ConstantValue  If this is an NK_Constant_Narrowing conversion, the
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   306) ///        value of the expression prior to the narrowing conversion.
5614ca77153b2 (Richard Smith            2012-03-23 23:55:39 +0000   307) /// \param ConstantType  If this is an NK_Constant_Narrowing conversion, the
5614ca77153b2 (Richard Smith            2012-03-23 23:55:39 +0000   308) ///        type of the expression prior to the narrowing conversion.
0683c0e68d31d (Eric Fiselier            2018-05-07 21:07:10 +0000   309) /// \param IgnoreFloatToIntegralConversion If true type-narrowing conversions
0683c0e68d31d (Eric Fiselier            2018-05-07 21:07:10 +0000   310) ///        from floating point types to integral types should be ignored.
0683c0e68d31d (Eric Fiselier            2018-05-07 21:07:10 +0000   311) NarrowingKind StandardConversionSequence::getNarrowingKind(
0683c0e68d31d (Eric Fiselier            2018-05-07 21:07:10 +0000   312)     ASTContext &Ctx, const Expr *Converted, APValue &ConstantValue,
0683c0e68d31d (Eric Fiselier            2018-05-07 21:07:10 +0000   313)     QualType &ConstantType, bool IgnoreFloatToIntegralConversion) const {
bbafb8a745736 (David Blaikie            2012-03-11 07:00:24 +0000   314)   assert(Ctx.getLangOpts().CPlusPlus && "narrowing check outside C++");
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   315) 
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   316)   // C++11 [dcl.init.list]p7:
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   317)   //   A narrowing conversion is an implicit conversion ...
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   318)   QualType FromType = getToType(0);
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   319)   QualType ToType = getToType(1);
ed638864d3e19 (Richard Smith            2016-03-28 06:08:37 +0000   320) 
ed638864d3e19 (Richard Smith            2016-03-28 06:08:37 +0000   321)   // A conversion to an enumeration type is narrowing if the conversion to
ed638864d3e19 (Richard Smith            2016-03-28 06:08:37 +0000   322)   // the underlying type is narrowing. This only arises for expressions of
ed638864d3e19 (Richard Smith            2016-03-28 06:08:37 +0000   323)   // the form 'Enum{init}'.
ed638864d3e19 (Richard Smith            2016-03-28 06:08:37 +0000   324)   if (auto *ET = ToType->getAs<EnumType>())
ed638864d3e19 (Richard Smith            2016-03-28 06:08:37 +0000   325)     ToType = ET->getDecl()->getIntegerType();
ed638864d3e19 (Richard Smith            2016-03-28 06:08:37 +0000   326) 
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   327)   switch (Second) {
64ecacf6cb4d6 (Richard Smith            2015-02-19 00:39:05 +0000   328)   // 'bool' is an integral type; dispatch to the right place to handle it.
64ecacf6cb4d6 (Richard Smith            2015-02-19 00:39:05 +0000   329)   case ICK_Boolean_Conversion:
64ecacf6cb4d6 (Richard Smith            2015-02-19 00:39:05 +0000   330)     if (FromType->isRealFloatingType())
64ecacf6cb4d6 (Richard Smith            2015-02-19 00:39:05 +0000   331)       goto FloatingIntegralConversion;
64ecacf6cb4d6 (Richard Smith            2015-02-19 00:39:05 +0000   332)     if (FromType->isIntegralOrUnscopedEnumerationType())
64ecacf6cb4d6 (Richard Smith            2015-02-19 00:39:05 +0000   333)       goto IntegralConversion;
7ef45f45f6721 (Richard Smith            2020-02-10 07:22:51 -0800   334)     // -- from a pointer type or pointer-to-member type to bool, or
7ef45f45f6721 (Richard Smith            2020-02-10 07:22:51 -0800   335)     return NK_Type_Narrowing;
64ecacf6cb4d6 (Richard Smith            2015-02-19 00:39:05 +0000   336) 
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   337)   // -- from a floating-point type to an integer type, or
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   338)   //
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   339)   // -- from an integer type or unscoped enumeration type to a floating-point
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   340)   //    type, except where the source is a constant expression and the actual
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   341)   //    value after conversion will fit into the target type and will produce
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   342)   //    the original value when converted back to the original type, or
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   343)   case ICK_Floating_Integral:
64ecacf6cb4d6 (Richard Smith            2015-02-19 00:39:05 +0000   344)   FloatingIntegralConversion:
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   345)     if (FromType->isRealFloatingType() && ToType->isIntegralType(Ctx)) {
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   346)       return NK_Type_Narrowing;
7b1a950c4af4e (Mikhail Maltsev          2018-02-21 10:08:18 +0000   347)     } else if (FromType->isIntegralOrUnscopedEnumerationType() &&
7b1a950c4af4e (Mikhail Maltsev          2018-02-21 10:08:18 +0000   348)                ToType->isRealFloatingType()) {
0683c0e68d31d (Eric Fiselier            2018-05-07 21:07:10 +0000   349)       if (IgnoreFloatToIntegralConversion)
0683c0e68d31d (Eric Fiselier            2018-05-07 21:07:10 +0000   350)         return NK_Not_Narrowing;
40c3d6e335900 (Richard Smith            2019-09-19 22:00:16 +0000   351)       const Expr *Initializer = IgnoreNarrowingConversion(Ctx, Converted);
f940987a4e21b (Simon Pilgrim            2017-06-01 18:13:02 +0000   352)       assert(Initializer && "Unknown conversion expression");
52e624f3ecbe1 (Richard Smith            2016-12-21 21:42:57 +0000   353) 
52e624f3ecbe1 (Richard Smith            2016-12-21 21:42:57 +0000   354)       // If it's value-dependent, we can't tell whether it's narrowing.
52e624f3ecbe1 (Richard Smith            2016-12-21 21:42:57 +0000   355)       if (Initializer->isValueDependent())
52e624f3ecbe1 (Richard Smith            2016-12-21 21:42:57 +0000   356)         return NK_Dependent_Narrowing;
52e624f3ecbe1 (Richard Smith            2016-12-21 21:42:57 +0000   357) 
36036aa70ec1d (David Blaikie            2020-07-12 20:31:08 -0700   358)       if (Optional<llvm::APSInt> IntConstantValue =
36036aa70ec1d (David Blaikie            2020-07-12 20:31:08 -0700   359)               Initializer->getIntegerConstantExpr(Ctx)) {
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   360)         // Convert the integer to the floating type.
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   361)         llvm::APFloat Result(Ctx.getFloatTypeSemantics(ToType));
36036aa70ec1d (David Blaikie            2020-07-12 20:31:08 -0700   362)         Result.convertFromAPInt(*IntConstantValue, IntConstantValue->isSigned(),
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   363)                                 llvm::APFloat::rmNearestTiesToEven);
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   364)         // And back.
36036aa70ec1d (David Blaikie            2020-07-12 20:31:08 -0700   365)         llvm::APSInt ConvertedValue = *IntConstantValue;
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   366)         bool ignored;
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   367)         Result.convertToInteger(ConvertedValue,
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   368)                                 llvm::APFloat::rmTowardZero, &ignored);
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   369)         // If the resulting value is different, this was a narrowing conversion.
36036aa70ec1d (David Blaikie            2020-07-12 20:31:08 -0700   370)         if (*IntConstantValue != ConvertedValue) {
36036aa70ec1d (David Blaikie            2020-07-12 20:31:08 -0700   371)           ConstantValue = APValue(*IntConstantValue);
5614ca77153b2 (Richard Smith            2012-03-23 23:55:39 +0000   372)           ConstantType = Initializer->getType();
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   373)           return NK_Constant_Narrowing;
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   374)         }
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   375)       } else {
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   376)         // Variables are always narrowings.
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   377)         return NK_Variable_Narrowing;
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   378)       }
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   379)     }
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   380)     return NK_Not_Narrowing;
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   381) 
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   382)   // -- from long double to double or float, or from double to float, except
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   383)   //    where the source is a constant expression and the actual value after
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   384)   //    conversion is within the range of values that can be represented (even
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   385)   //    if it cannot be represented exactly), or
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   386)   case ICK_Floating_Conversion:
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   387)     if (FromType->isRealFloatingType() && ToType->isRealFloatingType() &&
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   388)         Ctx.getFloatingTypeOrder(FromType, ToType) == 1) {
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   389)       // FromType is larger than ToType.
40c3d6e335900 (Richard Smith            2019-09-19 22:00:16 +0000   390)       const Expr *Initializer = IgnoreNarrowingConversion(Ctx, Converted);
52e624f3ecbe1 (Richard Smith            2016-12-21 21:42:57 +0000   391) 
52e624f3ecbe1 (Richard Smith            2016-12-21 21:42:57 +0000   392)       // If it's value-dependent, we can't tell whether it's narrowing.
52e624f3ecbe1 (Richard Smith            2016-12-21 21:42:57 +0000   393)       if (Initializer->isValueDependent())
52e624f3ecbe1 (Richard Smith            2016-12-21 21:42:57 +0000   394)         return NK_Dependent_Narrowing;
52e624f3ecbe1 (Richard Smith            2016-12-21 21:42:57 +0000   395) 
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   396)       if (Initializer->isCXX11ConstantExpr(Ctx, &ConstantValue)) {
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   397)         // Constant!
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   398)         assert(ConstantValue.isFloat());
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   399)         llvm::APFloat FloatVal = ConstantValue.getFloat();
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   400)         // Convert the source value into the target type.
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   401)         bool ignored;
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   402)         llvm::APFloat::opStatus ConvertStatus = FloatVal.convert(
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   403)           Ctx.getFloatTypeSemantics(ToType),
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   404)           llvm::APFloat::rmNearestTiesToEven, &ignored);
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   405)         // If there was no overflow, the source value is within the range of
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   406)         // values that can be represented.
5614ca77153b2 (Richard Smith            2012-03-23 23:55:39 +0000   407)         if (ConvertStatus & llvm::APFloat::opOverflow) {
5614ca77153b2 (Richard Smith            2012-03-23 23:55:39 +0000   408)           ConstantType = Initializer->getType();
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   409)           return NK_Constant_Narrowing;
5614ca77153b2 (Richard Smith            2012-03-23 23:55:39 +0000   410)         }
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   411)       } else {
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   412)         return NK_Variable_Narrowing;
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   413)       }
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   414)     }
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   415)     return NK_Not_Narrowing;
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   416) 
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   417)   // -- from an integer type or unscoped enumeration type to an integer type
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   418)   //    that cannot represent all the values of the original type, except where
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   419)   //    the source is a constant expression and the actual value after
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   420)   //    conversion will fit into the target type and will produce the original
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   421)   //    value when converted back to the original type.
64ecacf6cb4d6 (Richard Smith            2015-02-19 00:39:05 +0000   422)   case ICK_Integral_Conversion:
64ecacf6cb4d6 (Richard Smith            2015-02-19 00:39:05 +0000   423)   IntegralConversion: {
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   424)     assert(FromType->isIntegralOrUnscopedEnumerationType());
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   425)     assert(ToType->isIntegralOrUnscopedEnumerationType());
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   426)     const bool FromSigned = FromType->isSignedIntegerOrEnumerationType();
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   427)     const unsigned FromWidth = Ctx.getIntWidth(FromType);
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   428)     const bool ToSigned = ToType->isSignedIntegerOrEnumerationType();
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   429)     const unsigned ToWidth = Ctx.getIntWidth(ToType);
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   430) 
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   431)     if (FromWidth > ToWidth ||
25a80d424bb29 (Richard Smith            2012-06-13 01:07:41 +0000   432)         (FromWidth == ToWidth && FromSigned != ToSigned) ||
25a80d424bb29 (Richard Smith            2012-06-13 01:07:41 +0000   433)         (FromSigned && !ToSigned)) {
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   434)       // Not all values of FromType can be represented in ToType.
40c3d6e335900 (Richard Smith            2019-09-19 22:00:16 +0000   435)       const Expr *Initializer = IgnoreNarrowingConversion(Ctx, Converted);
52e624f3ecbe1 (Richard Smith            2016-12-21 21:42:57 +0000   436) 
52e624f3ecbe1 (Richard Smith            2016-12-21 21:42:57 +0000   437)       // If it's value-dependent, we can't tell whether it's narrowing.
52e624f3ecbe1 (Richard Smith            2016-12-21 21:42:57 +0000   438)       if (Initializer->isValueDependent())
52e624f3ecbe1 (Richard Smith            2016-12-21 21:42:57 +0000   439)         return NK_Dependent_Narrowing;
52e624f3ecbe1 (Richard Smith            2016-12-21 21:42:57 +0000   440) 
36036aa70ec1d (David Blaikie            2020-07-12 20:31:08 -0700   441)       Optional<llvm::APSInt> OptInitializerValue;
36036aa70ec1d (David Blaikie            2020-07-12 20:31:08 -0700   442)       if (!(OptInitializerValue = Initializer->getIntegerConstantExpr(Ctx))) {
25a80d424bb29 (Richard Smith            2012-06-13 01:07:41 +0000   443)         // Such conversions on variables are always narrowing.
25a80d424bb29 (Richard Smith            2012-06-13 01:07:41 +0000   444)         return NK_Variable_Narrowing;
72cd8ea5e5521 (Richard Smith            2012-06-19 21:28:35 +0000   445)       }
36036aa70ec1d (David Blaikie            2020-07-12 20:31:08 -0700   446)       llvm::APSInt &InitializerValue = *OptInitializerValue;
72cd8ea5e5521 (Richard Smith            2012-06-19 21:28:35 +0000   447)       bool Narrowing = false;
72cd8ea5e5521 (Richard Smith            2012-06-19 21:28:35 +0000   448)       if (FromWidth < ToWidth) {
25a80d424bb29 (Richard Smith            2012-06-13 01:07:41 +0000   449)         // Negative -> unsigned is narrowing. Otherwise, more bits is never
25a80d424bb29 (Richard Smith            2012-06-13 01:07:41 +0000   450)         // narrowing.
25a80d424bb29 (Richard Smith            2012-06-13 01:07:41 +0000   451)         if (InitializerValue.isSigned() && InitializerValue.isNegative())
72cd8ea5e5521 (Richard Smith            2012-06-19 21:28:35 +0000   452)           Narrowing = true;
25a80d424bb29 (Richard Smith            2012-06-13 01:07:41 +0000   453)       } else {
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   454)         // Add a bit to the InitializerValue so we don't have to worry about
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   455)         // signed vs. unsigned comparisons.
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   456)         InitializerValue = InitializerValue.extend(
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   457)           InitializerValue.getBitWidth() + 1);
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   458)         // Convert the initializer to and from the target width and signed-ness.
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   459)         llvm::APSInt ConvertedValue = InitializerValue;
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   460)         ConvertedValue = ConvertedValue.trunc(ToWidth);
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   461)         ConvertedValue.setIsSigned(ToSigned);
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   462)         ConvertedValue = ConvertedValue.extend(InitializerValue.getBitWidth());
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   463)         ConvertedValue.setIsSigned(InitializerValue.isSigned());
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   464)         // If the result is different, this was a narrowing conversion.
72cd8ea5e5521 (Richard Smith            2012-06-19 21:28:35 +0000   465)         if (ConvertedValue != InitializerValue)
72cd8ea5e5521 (Richard Smith            2012-06-19 21:28:35 +0000   466)           Narrowing = true;
72cd8ea5e5521 (Richard Smith            2012-06-19 21:28:35 +0000   467)       }
72cd8ea5e5521 (Richard Smith            2012-06-19 21:28:35 +0000   468)       if (Narrowing) {
72cd8ea5e5521 (Richard Smith            2012-06-19 21:28:35 +0000   469)         ConstantType = Initializer->getType();
72cd8ea5e5521 (Richard Smith            2012-06-19 21:28:35 +0000   470)         ConstantValue = APValue(InitializerValue);
72cd8ea5e5521 (Richard Smith            2012-06-19 21:28:35 +0000   471)         return NK_Constant_Narrowing;
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   472)       }
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   473)     }
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   474)     return NK_Not_Narrowing;
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   475)   }
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   476) 
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   477)   default:
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   478)     // Other kinds of conversions are not narrowings.
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   479)     return NK_Not_Narrowing;
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   480)   }
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   481) }
66e05fe63099d (Richard Smith            2012-01-18 05:21:49 +0000   482) 
9f2ed47133fa2 (Douglas Gregor           2013-11-08 02:16:10 +0000   483) /// dump - Print this standard conversion sequence to standard
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   484) /// error. Useful for debugging overloading issues.
cdae941e0330d (Yaron Keren              2016-01-29 19:38:18 +0000   485) LLVM_DUMP_METHOD void StandardConversionSequence::dump() const {
0e62c1cc0b47c (Chris Lattner            2011-07-23 10:55:15 +0000   486)   raw_ostream &OS = llvm::errs();
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   487)   bool PrintedSomething = false;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   488)   if (First != ICK_Identity) {
42e3df065e862 (Daniel Dunbar            2010-01-22 02:04:41 +0000   489)     OS << GetImplicitConversionName(First);
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   490)     PrintedSomething = true;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   491)   }
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   492) 
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   493)   if (Second != ICK_Identity) {
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   494)     if (PrintedSomething) {
42e3df065e862 (Daniel Dunbar            2010-01-22 02:04:41 +0000   495)       OS << " -> ";
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   496)     }
42e3df065e862 (Daniel Dunbar            2010-01-22 02:04:41 +0000   497)     OS << GetImplicitConversionName(Second);
2fe9883a961df (Douglas Gregor           2008-11-03 19:09:14 +0000   498) 
2fe9883a961df (Douglas Gregor           2008-11-03 19:09:14 +0000   499)     if (CopyConstructor) {
42e3df065e862 (Daniel Dunbar            2010-01-22 02:04:41 +0000   500)       OS << " (by copy constructor)";
2fe9883a961df (Douglas Gregor           2008-11-03 19:09:14 +0000   501)     } else if (DirectBinding) {
42e3df065e862 (Daniel Dunbar            2010-01-22 02:04:41 +0000   502)       OS << " (direct reference binding)";
2fe9883a961df (Douglas Gregor           2008-11-03 19:09:14 +0000   503)     } else if (ReferenceBinding) {
42e3df065e862 (Daniel Dunbar            2010-01-22 02:04:41 +0000   504)       OS << " (reference binding)";
2fe9883a961df (Douglas Gregor           2008-11-03 19:09:14 +0000   505)     }
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   506)     PrintedSomething = true;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   507)   }
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   508) 
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   509)   if (Third != ICK_Identity) {
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   510)     if (PrintedSomething) {
42e3df065e862 (Daniel Dunbar            2010-01-22 02:04:41 +0000   511)       OS << " -> ";
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   512)     }
42e3df065e862 (Daniel Dunbar            2010-01-22 02:04:41 +0000   513)     OS << GetImplicitConversionName(Third);
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   514)     PrintedSomething = true;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   515)   }
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   516) 
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   517)   if (!PrintedSomething) {
42e3df065e862 (Daniel Dunbar            2010-01-22 02:04:41 +0000   518)     OS << "No conversions required";
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   519)   }
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   520) }
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   521) 
9f2ed47133fa2 (Douglas Gregor           2013-11-08 02:16:10 +0000   522) /// dump - Print this user-defined conversion sequence to standard
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   523) /// error. Useful for debugging overloading issues.
9f2ed47133fa2 (Douglas Gregor           2013-11-08 02:16:10 +0000   524) void UserDefinedConversionSequence::dump() const {
0e62c1cc0b47c (Chris Lattner            2011-07-23 10:55:15 +0000   525)   raw_ostream &OS = llvm::errs();
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   526)   if (Before.First || Before.Second || Before.Third) {
9f2ed47133fa2 (Douglas Gregor           2013-11-08 02:16:10 +0000   527)     Before.dump();
42e3df065e862 (Daniel Dunbar            2010-01-22 02:04:41 +0000   528)     OS << " -> ";
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   529)   }
72ef7bc2b580f (Sebastian Redl           2011-11-01 15:53:09 +0000   530)   if (ConversionFunction)
72ef7bc2b580f (Sebastian Redl           2011-11-01 15:53:09 +0000   531)     OS << '\'' << *ConversionFunction << '\'';
72ef7bc2b580f (Sebastian Redl           2011-11-01 15:53:09 +0000   532)   else
72ef7bc2b580f (Sebastian Redl           2011-11-01 15:53:09 +0000   533)     OS << "aggregate initialization";
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   534)   if (After.First || After.Second || After.Third) {
42e3df065e862 (Daniel Dunbar            2010-01-22 02:04:41 +0000   535)     OS << " -> ";
9f2ed47133fa2 (Douglas Gregor           2013-11-08 02:16:10 +0000   536)     After.dump();
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   537)   }
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   538) }
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   539) 
9f2ed47133fa2 (Douglas Gregor           2013-11-08 02:16:10 +0000   540) /// dump - Print this implicit conversion sequence to standard
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   541) /// error. Useful for debugging overloading issues.
9f2ed47133fa2 (Douglas Gregor           2013-11-08 02:16:10 +0000   542) void ImplicitConversionSequence::dump() const {
0e62c1cc0b47c (Chris Lattner            2011-07-23 10:55:15 +0000   543)   raw_ostream &OS = llvm::errs();
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700   544)   if (isInitializerListToType())
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700   545)     OS << "Worst list element conversion: ";
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   546)   switch (ConversionKind) {
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   547)   case StandardConversion:
42e3df065e862 (Daniel Dunbar            2010-01-22 02:04:41 +0000   548)     OS << "Standard conversion: ";
9f2ed47133fa2 (Douglas Gregor           2013-11-08 02:16:10 +0000   549)     Standard.dump();
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   550)     break;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   551)   case UserDefinedConversion:
42e3df065e862 (Daniel Dunbar            2010-01-22 02:04:41 +0000   552)     OS << "User-defined conversion: ";
9f2ed47133fa2 (Douglas Gregor           2013-11-08 02:16:10 +0000   553)     UserDefined.dump();
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   554)     break;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   555)   case EllipsisConversion:
42e3df065e862 (Daniel Dunbar            2010-01-22 02:04:41 +0000   556)     OS << "Ellipsis conversion";
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   557)     break;
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000   558)   case AmbiguousConversion:
42e3df065e862 (Daniel Dunbar            2010-01-22 02:04:41 +0000   559)     OS << "Ambiguous conversion";
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000   560)     break;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   561)   case BadConversion:
42e3df065e862 (Daniel Dunbar            2010-01-22 02:04:41 +0000   562)     OS << "Bad conversion";
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   563)     break;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   564)   }
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   565) 
42e3df065e862 (Daniel Dunbar            2010-01-22 02:04:41 +0000   566)   OS << "\n";
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   567) }
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000   568) 
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000   569) void AmbiguousConversionSequence::construct() {
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000   570)   new (&conversions()) ConversionSet();
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000   571) }
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000   572) 
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000   573) void AmbiguousConversionSequence::destruct() {
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000   574)   conversions().~ConversionSet();
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000   575) }
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000   576) 
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000   577) void
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000   578) AmbiguousConversionSequence::copyFrom(const AmbiguousConversionSequence &O) {
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000   579)   FromTypePtr = O.FromTypePtr;
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000   580)   ToTypePtr = O.ToTypePtr;
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000   581)   new (&conversions()) ConversionSet(O.conversions());
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000   582) }
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000   583) 
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   584) namespace {
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000   585)   // Structure used by DeductionFailureInfo to store
44ecdbdc6134c (Richard Smith            2013-01-31 05:19:49 +0000   586)   // template argument information.
44ecdbdc6134c (Richard Smith            2013-01-31 05:19:49 +0000   587)   struct DFIArguments {
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   588)     TemplateArgument FirstArg;
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   589)     TemplateArgument SecondArg;
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   590)   };
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000   591)   // Structure used by DeductionFailureInfo to store
44ecdbdc6134c (Richard Smith            2013-01-31 05:19:49 +0000   592)   // template parameter and template argument information.
44ecdbdc6134c (Richard Smith            2013-01-31 05:19:49 +0000   593)   struct DFIParamWithArguments : DFIArguments {
44ecdbdc6134c (Richard Smith            2013-01-31 05:19:49 +0000   594)     TemplateParameter Param;
44ecdbdc6134c (Richard Smith            2013-01-31 05:19:49 +0000   595)   };
9b534547250a3 (Richard Smith            2015-12-31 02:02:54 +0000   596)   // Structure used by DeductionFailureInfo to store template argument
9b534547250a3 (Richard Smith            2015-12-31 02:02:54 +0000   597)   // information and the index of the problematic call argument.
9b534547250a3 (Richard Smith            2015-12-31 02:02:54 +0000   598)   struct DFIDeducedMismatchArgs : DFIArguments {
9b534547250a3 (Richard Smith            2015-12-31 02:02:54 +0000   599)     TemplateArgumentList *TemplateArgs;
9b534547250a3 (Richard Smith            2015-12-31 02:02:54 +0000   600)     unsigned CallArgIndex;
9b534547250a3 (Richard Smith            2015-12-31 02:02:54 +0000   601)   };
fdf80e86a5284 (Saar Raz                 2019-12-06 01:30:21 +0200   602)   // Structure used by DeductionFailureInfo to store information about
fdf80e86a5284 (Saar Raz                 2019-12-06 01:30:21 +0200   603)   // unsatisfied constraints.
fdf80e86a5284 (Saar Raz                 2019-12-06 01:30:21 +0200   604)   struct CNSInfo {
fdf80e86a5284 (Saar Raz                 2019-12-06 01:30:21 +0200   605)     TemplateArgumentList *TemplateArgs;
fdf80e86a5284 (Saar Raz                 2019-12-06 01:30:21 +0200   606)     ConstraintSatisfaction Satisfaction;
fdf80e86a5284 (Saar Raz                 2019-12-06 01:30:21 +0200   607)   };
ab9db51042d1b (Alexander Kornienko      2015-06-22 23:07:51 +0000   608) }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000   609) 
9fc8faf9e6197 (Adrian Prantl            2018-05-09 01:00:01 +0000   610) /// Convert from Sema's representation of template deduction information
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   611) /// to the form used in overload-candidate information.
17c00b43288dc (Richard Smith            2014-11-12 01:24:00 +0000   612) DeductionFailureInfo
17c00b43288dc (Richard Smith            2014-11-12 01:24:00 +0000   613) clang::MakeDeductionFailureInfo(ASTContext &Context,
17c00b43288dc (Richard Smith            2014-11-12 01:24:00 +0000   614)                                 Sema::TemplateDeductionResult TDK,
17c00b43288dc (Richard Smith            2014-11-12 01:24:00 +0000   615)                                 TemplateDeductionInfo &Info) {
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000   616)   DeductionFailureInfo Result;
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   617)   Result.Result = static_cast<unsigned>(TDK);
9ca6461f5a9ac (Richard Smith            2012-05-07 09:03:25 +0000   618)   Result.HasDiagnostic = false;
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   619)   switch (TDK) {
c5c01a60c2e3f (Douglas Gregor           2012-09-13 21:01:57 +0000   620)   case Sema::TDK_Invalid:
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   621)   case Sema::TDK_InstantiationDepth:
461761d68f739 (Douglas Gregor           2010-05-08 18:20:53 +0000   622)   case Sema::TDK_TooManyArguments:
461761d68f739 (Douglas Gregor           2010-05-08 18:20:53 +0000   623)   case Sema::TDK_TooFewArguments:
9b534547250a3 (Richard Smith            2015-12-31 02:02:54 +0000   624)   case Sema::TDK_MiscellaneousDeductionFailure:
13e9b4d76851d (Artem Belevich           2016-12-07 19:27:16 +0000   625)   case Sema::TDK_CUDATargetMismatch:
9b534547250a3 (Richard Smith            2015-12-31 02:02:54 +0000   626)     Result.Data = nullptr;
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   627)     break;
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000   628) 
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   629)   case Sema::TDK_Incomplete:
1d72edd7c55a8 (Douglas Gregor           2010-05-08 19:15:54 +0000   630)   case Sema::TDK_InvalidExplicitArguments:
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   631)     Result.Data = Info.Param.getOpaqueValue();
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   632)     break;
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000   633) 
c92d206ce4419 (Richard Smith            2017-01-05 23:02:44 +0000   634)   case Sema::TDK_DeducedMismatch:
c92d206ce4419 (Richard Smith            2017-01-05 23:02:44 +0000   635)   case Sema::TDK_DeducedMismatchNested: {
9b534547250a3 (Richard Smith            2015-12-31 02:02:54 +0000   636)     // FIXME: Should allocate from normal heap so that we can free this later.
9b534547250a3 (Richard Smith            2015-12-31 02:02:54 +0000   637)     auto *Saved = new (Context) DFIDeducedMismatchArgs;
9b534547250a3 (Richard Smith            2015-12-31 02:02:54 +0000   638)     Saved->FirstArg = Info.FirstArg;
9b534547250a3 (Richard Smith            2015-12-31 02:02:54 +0000   639)     Saved->SecondArg = Info.SecondArg;
9b534547250a3 (Richard Smith            2015-12-31 02:02:54 +0000   640)     Saved->TemplateArgs = Info.take();
9b534547250a3 (Richard Smith            2015-12-31 02:02:54 +0000   641)     Saved->CallArgIndex = Info.CallArgIndex;
9b534547250a3 (Richard Smith            2015-12-31 02:02:54 +0000   642)     Result.Data = Saved;
9b534547250a3 (Richard Smith            2015-12-31 02:02:54 +0000   643)     break;
9b534547250a3 (Richard Smith            2015-12-31 02:02:54 +0000   644)   }
9b534547250a3 (Richard Smith            2015-12-31 02:02:54 +0000   645) 
44ecdbdc6134c (Richard Smith            2013-01-31 05:19:49 +0000   646)   case Sema::TDK_NonDeducedMismatch: {
44ecdbdc6134c (Richard Smith            2013-01-31 05:19:49 +0000   647)     // FIXME: Should allocate from normal heap so that we can free this later.
44ecdbdc6134c (Richard Smith            2013-01-31 05:19:49 +0000   648)     DFIArguments *Saved = new (Context) DFIArguments;
44ecdbdc6134c (Richard Smith            2013-01-31 05:19:49 +0000   649)     Saved->FirstArg = Info.FirstArg;
44ecdbdc6134c (Richard Smith            2013-01-31 05:19:49 +0000   650)     Saved->SecondArg = Info.SecondArg;
44ecdbdc6134c (Richard Smith            2013-01-31 05:19:49 +0000   651)     Result.Data = Saved;
44ecdbdc6134c (Richard Smith            2013-01-31 05:19:49 +0000   652)     break;
44ecdbdc6134c (Richard Smith            2013-01-31 05:19:49 +0000   653)   }
44ecdbdc6134c (Richard Smith            2013-01-31 05:19:49 +0000   654) 
4a8f3518cb144 (Richard Smith            2018-07-19 19:00:37 +0000   655)   case Sema::TDK_IncompletePack:
4a8f3518cb144 (Richard Smith            2018-07-19 19:00:37 +0000   656)     // FIXME: It's slightly wasteful to allocate two TemplateArguments for this.
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   657)   case Sema::TDK_Inconsistent:
42d7d19710d09 (John McCall              2010-08-05 09:05:08 +0000   658)   case Sema::TDK_Underqualified: {
90cf2c98bbca9 (Douglas Gregor           2010-05-08 20:18:54 +0000   659)     // FIXME: Should allocate from normal heap so that we can free this later.
90cf2c98bbca9 (Douglas Gregor           2010-05-08 20:18:54 +0000   660)     DFIParamWithArguments *Saved = new (Context) DFIParamWithArguments;
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   661)     Saved->Param = Info.Param;
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   662)     Saved->FirstArg = Info.FirstArg;
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   663)     Saved->SecondArg = Info.SecondArg;
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   664)     Result.Data = Saved;
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   665)     break;
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   666)   }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000   667) 
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   668)   case Sema::TDK_SubstitutionFailure:
d09efd43d3f84 (Douglas Gregor           2010-05-08 20:07:26 +0000   669)     Result.Data = Info.take();
9ca6461f5a9ac (Richard Smith            2012-05-07 09:03:25 +0000   670)     if (Info.hasSFINAEDiagnostic()) {
9ca6461f5a9ac (Richard Smith            2012-05-07 09:03:25 +0000   671)       PartialDiagnosticAt *Diag = new (Result.Diagnostic) PartialDiagnosticAt(
9ca6461f5a9ac (Richard Smith            2012-05-07 09:03:25 +0000   672)           SourceLocation(), PartialDiagnostic::NullDiagnostic());
9ca6461f5a9ac (Richard Smith            2012-05-07 09:03:25 +0000   673)       Info.takeSFINAEDiagnostic(*Diag);
9ca6461f5a9ac (Richard Smith            2012-05-07 09:03:25 +0000   674)       Result.HasDiagnostic = true;
9ca6461f5a9ac (Richard Smith            2012-05-07 09:03:25 +0000   675)     }
d09efd43d3f84 (Douglas Gregor           2010-05-08 20:07:26 +0000   676)     break;
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000   677) 
fdf80e86a5284 (Saar Raz                 2019-12-06 01:30:21 +0200   678)   case Sema::TDK_ConstraintsNotSatisfied: {
fdf80e86a5284 (Saar Raz                 2019-12-06 01:30:21 +0200   679)     CNSInfo *Saved = new (Context) CNSInfo;
fdf80e86a5284 (Saar Raz                 2019-12-06 01:30:21 +0200   680)     Saved->TemplateArgs = Info.take();
fdf80e86a5284 (Saar Raz                 2019-12-06 01:30:21 +0200   681)     Saved->Satisfaction = Info.AssociatedConstraintsSatisfaction;
fdf80e86a5284 (Saar Raz                 2019-12-06 01:30:21 +0200   682)     Result.Data = Saved;
fdf80e86a5284 (Saar Raz                 2019-12-06 01:30:21 +0200   683)     break;
fdf80e86a5284 (Saar Raz                 2019-12-06 01:30:21 +0200   684)   }
fdf80e86a5284 (Saar Raz                 2019-12-06 01:30:21 +0200   685) 
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000   686)   case Sema::TDK_Success:
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000   687)   case Sema::TDK_NonDependentConversionFailure:
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000   688)     llvm_unreachable("not a deduction failure");
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   689)   }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000   690) 
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   691)   return Result;
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   692) }
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   693) 
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000   694) void DeductionFailureInfo::Destroy() {
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   695)   switch (static_cast<Sema::TemplateDeductionResult>(Result)) {
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   696)   case Sema::TDK_Success:
c5c01a60c2e3f (Douglas Gregor           2012-09-13 21:01:57 +0000   697)   case Sema::TDK_Invalid:
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   698)   case Sema::TDK_InstantiationDepth:
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   699)   case Sema::TDK_Incomplete:
461761d68f739 (Douglas Gregor           2010-05-08 18:20:53 +0000   700)   case Sema::TDK_TooManyArguments:
461761d68f739 (Douglas Gregor           2010-05-08 18:20:53 +0000   701)   case Sema::TDK_TooFewArguments:
1d72edd7c55a8 (Douglas Gregor           2010-05-08 19:15:54 +0000   702)   case Sema::TDK_InvalidExplicitArguments:
13e9b4d76851d (Artem Belevich           2016-12-07 19:27:16 +0000   703)   case Sema::TDK_CUDATargetMismatch:
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000   704)   case Sema::TDK_NonDependentConversionFailure:
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   705)     break;
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000   706) 
4a8f3518cb144 (Richard Smith            2018-07-19 19:00:37 +0000   707)   case Sema::TDK_IncompletePack:
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   708)   case Sema::TDK_Inconsistent:
42d7d19710d09 (John McCall              2010-08-05 09:05:08 +0000   709)   case Sema::TDK_Underqualified:
9b534547250a3 (Richard Smith            2015-12-31 02:02:54 +0000   710)   case Sema::TDK_DeducedMismatch:
c92d206ce4419 (Richard Smith            2017-01-05 23:02:44 +0000   711)   case Sema::TDK_DeducedMismatchNested:
44ecdbdc6134c (Richard Smith            2013-01-31 05:19:49 +0000   712)   case Sema::TDK_NonDeducedMismatch:
b02d6b3b94de4 (Douglas Gregor           2010-05-08 20:20:05 +0000   713)     // FIXME: Destroy the data?
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000   714)     Data = nullptr;
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   715)     break;
d09efd43d3f84 (Douglas Gregor           2010-05-08 20:07:26 +0000   716) 
d09efd43d3f84 (Douglas Gregor           2010-05-08 20:07:26 +0000   717)   case Sema::TDK_SubstitutionFailure:
9ca6461f5a9ac (Richard Smith            2012-05-07 09:03:25 +0000   718)     // FIXME: Destroy the template argument list?
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000   719)     Data = nullptr;
9ca6461f5a9ac (Richard Smith            2012-05-07 09:03:25 +0000   720)     if (PartialDiagnosticAt *Diag = getSFINAEDiagnostic()) {
9ca6461f5a9ac (Richard Smith            2012-05-07 09:03:25 +0000   721)       Diag->~PartialDiagnosticAt();
9ca6461f5a9ac (Richard Smith            2012-05-07 09:03:25 +0000   722)       HasDiagnostic = false;
9ca6461f5a9ac (Richard Smith            2012-05-07 09:03:25 +0000   723)     }
d09efd43d3f84 (Douglas Gregor           2010-05-08 20:07:26 +0000   724)     break;
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000   725) 
fdf80e86a5284 (Saar Raz                 2019-12-06 01:30:21 +0200   726)   case Sema::TDK_ConstraintsNotSatisfied:
fdf80e86a5284 (Saar Raz                 2019-12-06 01:30:21 +0200   727)     // FIXME: Destroy the template argument list?
fdf80e86a5284 (Saar Raz                 2019-12-06 01:30:21 +0200   728)     Data = nullptr;
fdf80e86a5284 (Saar Raz                 2019-12-06 01:30:21 +0200   729)     if (PartialDiagnosticAt *Diag = getSFINAEDiagnostic()) {
fdf80e86a5284 (Saar Raz                 2019-12-06 01:30:21 +0200   730)       Diag->~PartialDiagnosticAt();
fdf80e86a5284 (Saar Raz                 2019-12-06 01:30:21 +0200   731)       HasDiagnostic = false;
fdf80e86a5284 (Saar Raz                 2019-12-06 01:30:21 +0200   732)     }
fdf80e86a5284 (Saar Raz                 2019-12-06 01:30:21 +0200   733)     break;
fdf80e86a5284 (Saar Raz                 2019-12-06 01:30:21 +0200   734) 
461761d68f739 (Douglas Gregor           2010-05-08 18:20:53 +0000   735)   // Unhandled
44ecdbdc6134c (Richard Smith            2013-01-31 05:19:49 +0000   736)   case Sema::TDK_MiscellaneousDeductionFailure:
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   737)     break;
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   738)   }
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   739) }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000   740) 
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000   741) PartialDiagnosticAt *DeductionFailureInfo::getSFINAEDiagnostic() {
9ca6461f5a9ac (Richard Smith            2012-05-07 09:03:25 +0000   742)   if (HasDiagnostic)
9ca6461f5a9ac (Richard Smith            2012-05-07 09:03:25 +0000   743)     return static_cast<PartialDiagnosticAt*>(static_cast<void*>(Diagnostic));
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000   744)   return nullptr;
9ca6461f5a9ac (Richard Smith            2012-05-07 09:03:25 +0000   745) }
9ca6461f5a9ac (Richard Smith            2012-05-07 09:03:25 +0000   746) 
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000   747) TemplateParameter DeductionFailureInfo::getTemplateParameter() {
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   748)   switch (static_cast<Sema::TemplateDeductionResult>(Result)) {
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   749)   case Sema::TDK_Success:
c5c01a60c2e3f (Douglas Gregor           2012-09-13 21:01:57 +0000   750)   case Sema::TDK_Invalid:
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   751)   case Sema::TDK_InstantiationDepth:
461761d68f739 (Douglas Gregor           2010-05-08 18:20:53 +0000   752)   case Sema::TDK_TooManyArguments:
461761d68f739 (Douglas Gregor           2010-05-08 18:20:53 +0000   753)   case Sema::TDK_TooFewArguments:
d09efd43d3f84 (Douglas Gregor           2010-05-08 20:07:26 +0000   754)   case Sema::TDK_SubstitutionFailure:
9b534547250a3 (Richard Smith            2015-12-31 02:02:54 +0000   755)   case Sema::TDK_DeducedMismatch:
c92d206ce4419 (Richard Smith            2017-01-05 23:02:44 +0000   756)   case Sema::TDK_DeducedMismatchNested:
44ecdbdc6134c (Richard Smith            2013-01-31 05:19:49 +0000   757)   case Sema::TDK_NonDeducedMismatch:
13e9b4d76851d (Artem Belevich           2016-12-07 19:27:16 +0000   758)   case Sema::TDK_CUDATargetMismatch:
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000   759)   case Sema::TDK_NonDependentConversionFailure:
fdf80e86a5284 (Saar Raz                 2019-12-06 01:30:21 +0200   760)   case Sema::TDK_ConstraintsNotSatisfied:
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   761)     return TemplateParameter();
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000   762) 
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   763)   case Sema::TDK_Incomplete:
1d72edd7c55a8 (Douglas Gregor           2010-05-08 19:15:54 +0000   764)   case Sema::TDK_InvalidExplicitArguments:
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000   765)     return TemplateParameter::getFromOpaqueValue(Data);
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   766) 
4a8f3518cb144 (Richard Smith            2018-07-19 19:00:37 +0000   767)   case Sema::TDK_IncompletePack:
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   768)   case Sema::TDK_Inconsistent:
42d7d19710d09 (John McCall              2010-08-05 09:05:08 +0000   769)   case Sema::TDK_Underqualified:
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   770)     return static_cast<DFIParamWithArguments*>(Data)->Param;
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000   771) 
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   772)   // Unhandled
44ecdbdc6134c (Richard Smith            2013-01-31 05:19:49 +0000   773)   case Sema::TDK_MiscellaneousDeductionFailure:
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   774)     break;
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   775)   }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000   776) 
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   777)   return TemplateParameter();
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   778) }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000   779) 
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000   780) TemplateArgumentList *DeductionFailureInfo::getTemplateArgumentList() {
d09efd43d3f84 (Douglas Gregor           2010-05-08 20:07:26 +0000   781)   switch (static_cast<Sema::TemplateDeductionResult>(Result)) {
44ecdbdc6134c (Richard Smith            2013-01-31 05:19:49 +0000   782)   case Sema::TDK_Success:
44ecdbdc6134c (Richard Smith            2013-01-31 05:19:49 +0000   783)   case Sema::TDK_Invalid:
44ecdbdc6134c (Richard Smith            2013-01-31 05:19:49 +0000   784)   case Sema::TDK_InstantiationDepth:
44ecdbdc6134c (Richard Smith            2013-01-31 05:19:49 +0000   785)   case Sema::TDK_TooManyArguments:
44ecdbdc6134c (Richard Smith            2013-01-31 05:19:49 +0000   786)   case Sema::TDK_TooFewArguments:
44ecdbdc6134c (Richard Smith            2013-01-31 05:19:49 +0000   787)   case Sema::TDK_Incomplete:
4a8f3518cb144 (Richard Smith            2018-07-19 19:00:37 +0000   788)   case Sema::TDK_IncompletePack:
44ecdbdc6134c (Richard Smith            2013-01-31 05:19:49 +0000   789)   case Sema::TDK_InvalidExplicitArguments:
44ecdbdc6134c (Richard Smith            2013-01-31 05:19:49 +0000   790)   case Sema::TDK_Inconsistent:
44ecdbdc6134c (Richard Smith            2013-01-31 05:19:49 +0000   791)   case Sema::TDK_Underqualified:
44ecdbdc6134c (Richard Smith            2013-01-31 05:19:49 +0000   792)   case Sema::TDK_NonDeducedMismatch:
13e9b4d76851d (Artem Belevich           2016-12-07 19:27:16 +0000   793)   case Sema::TDK_CUDATargetMismatch:
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000   794)   case Sema::TDK_NonDependentConversionFailure:
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000   795)     return nullptr;
44ecdbdc6134c (Richard Smith            2013-01-31 05:19:49 +0000   796) 
9b534547250a3 (Richard Smith            2015-12-31 02:02:54 +0000   797)   case Sema::TDK_DeducedMismatch:
c92d206ce4419 (Richard Smith            2017-01-05 23:02:44 +0000   798)   case Sema::TDK_DeducedMismatchNested:
9b534547250a3 (Richard Smith            2015-12-31 02:02:54 +0000   799)     return static_cast<DFIDeducedMismatchArgs*>(Data)->TemplateArgs;
9b534547250a3 (Richard Smith            2015-12-31 02:02:54 +0000   800) 
44ecdbdc6134c (Richard Smith            2013-01-31 05:19:49 +0000   801)   case Sema::TDK_SubstitutionFailure:
44ecdbdc6134c (Richard Smith            2013-01-31 05:19:49 +0000   802)     return static_cast<TemplateArgumentList*>(Data);
44ecdbdc6134c (Richard Smith            2013-01-31 05:19:49 +0000   803) 
fdf80e86a5284 (Saar Raz                 2019-12-06 01:30:21 +0200   804)   case Sema::TDK_ConstraintsNotSatisfied:
fdf80e86a5284 (Saar Raz                 2019-12-06 01:30:21 +0200   805)     return static_cast<CNSInfo*>(Data)->TemplateArgs;
fdf80e86a5284 (Saar Raz                 2019-12-06 01:30:21 +0200   806) 
44ecdbdc6134c (Richard Smith            2013-01-31 05:19:49 +0000   807)   // Unhandled
44ecdbdc6134c (Richard Smith            2013-01-31 05:19:49 +0000   808)   case Sema::TDK_MiscellaneousDeductionFailure:
44ecdbdc6134c (Richard Smith            2013-01-31 05:19:49 +0000   809)     break;
d09efd43d3f84 (Douglas Gregor           2010-05-08 20:07:26 +0000   810)   }
d09efd43d3f84 (Douglas Gregor           2010-05-08 20:07:26 +0000   811) 
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000   812)   return nullptr;
d09efd43d3f84 (Douglas Gregor           2010-05-08 20:07:26 +0000   813) }
d09efd43d3f84 (Douglas Gregor           2010-05-08 20:07:26 +0000   814) 
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000   815) const TemplateArgument *DeductionFailureInfo::getFirstArg() {
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   816)   switch (static_cast<Sema::TemplateDeductionResult>(Result)) {
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   817)   case Sema::TDK_Success:
c5c01a60c2e3f (Douglas Gregor           2012-09-13 21:01:57 +0000   818)   case Sema::TDK_Invalid:
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   819)   case Sema::TDK_InstantiationDepth:
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   820)   case Sema::TDK_Incomplete:
461761d68f739 (Douglas Gregor           2010-05-08 18:20:53 +0000   821)   case Sema::TDK_TooManyArguments:
461761d68f739 (Douglas Gregor           2010-05-08 18:20:53 +0000   822)   case Sema::TDK_TooFewArguments:
1d72edd7c55a8 (Douglas Gregor           2010-05-08 19:15:54 +0000   823)   case Sema::TDK_InvalidExplicitArguments:
d09efd43d3f84 (Douglas Gregor           2010-05-08 20:07:26 +0000   824)   case Sema::TDK_SubstitutionFailure:
13e9b4d76851d (Artem Belevich           2016-12-07 19:27:16 +0000   825)   case Sema::TDK_CUDATargetMismatch:
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000   826)   case Sema::TDK_NonDependentConversionFailure:
fdf80e86a5284 (Saar Raz                 2019-12-06 01:30:21 +0200   827)   case Sema::TDK_ConstraintsNotSatisfied:
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000   828)     return nullptr;
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   829) 
4a8f3518cb144 (Richard Smith            2018-07-19 19:00:37 +0000   830)   case Sema::TDK_IncompletePack:
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   831)   case Sema::TDK_Inconsistent:
42d7d19710d09 (John McCall              2010-08-05 09:05:08 +0000   832)   case Sema::TDK_Underqualified:
9b534547250a3 (Richard Smith            2015-12-31 02:02:54 +0000   833)   case Sema::TDK_DeducedMismatch:
c92d206ce4419 (Richard Smith            2017-01-05 23:02:44 +0000   834)   case Sema::TDK_DeducedMismatchNested:
44ecdbdc6134c (Richard Smith            2013-01-31 05:19:49 +0000   835)   case Sema::TDK_NonDeducedMismatch:
44ecdbdc6134c (Richard Smith            2013-01-31 05:19:49 +0000   836)     return &static_cast<DFIArguments*>(Data)->FirstArg;
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   837) 
461761d68f739 (Douglas Gregor           2010-05-08 18:20:53 +0000   838)   // Unhandled
44ecdbdc6134c (Richard Smith            2013-01-31 05:19:49 +0000   839)   case Sema::TDK_MiscellaneousDeductionFailure:
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   840)     break;
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   841)   }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000   842) 
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000   843)   return nullptr;
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000   844) }
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000   845) 
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000   846) const TemplateArgument *DeductionFailureInfo::getSecondArg() {
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   847)   switch (static_cast<Sema::TemplateDeductionResult>(Result)) {
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   848)   case Sema::TDK_Success:
c5c01a60c2e3f (Douglas Gregor           2012-09-13 21:01:57 +0000   849)   case Sema::TDK_Invalid:
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   850)   case Sema::TDK_InstantiationDepth:
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   851)   case Sema::TDK_Incomplete:
4a8f3518cb144 (Richard Smith            2018-07-19 19:00:37 +0000   852)   case Sema::TDK_IncompletePack:
461761d68f739 (Douglas Gregor           2010-05-08 18:20:53 +0000   853)   case Sema::TDK_TooManyArguments:
461761d68f739 (Douglas Gregor           2010-05-08 18:20:53 +0000   854)   case Sema::TDK_TooFewArguments:
1d72edd7c55a8 (Douglas Gregor           2010-05-08 19:15:54 +0000   855)   case Sema::TDK_InvalidExplicitArguments:
d09efd43d3f84 (Douglas Gregor           2010-05-08 20:07:26 +0000   856)   case Sema::TDK_SubstitutionFailure:
13e9b4d76851d (Artem Belevich           2016-12-07 19:27:16 +0000   857)   case Sema::TDK_CUDATargetMismatch:
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000   858)   case Sema::TDK_NonDependentConversionFailure:
fdf80e86a5284 (Saar Raz                 2019-12-06 01:30:21 +0200   859)   case Sema::TDK_ConstraintsNotSatisfied:
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000   860)     return nullptr;
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   861) 
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   862)   case Sema::TDK_Inconsistent:
42d7d19710d09 (John McCall              2010-08-05 09:05:08 +0000   863)   case Sema::TDK_Underqualified:
9b534547250a3 (Richard Smith            2015-12-31 02:02:54 +0000   864)   case Sema::TDK_DeducedMismatch:
c92d206ce4419 (Richard Smith            2017-01-05 23:02:44 +0000   865)   case Sema::TDK_DeducedMismatchNested:
44ecdbdc6134c (Richard Smith            2013-01-31 05:19:49 +0000   866)   case Sema::TDK_NonDeducedMismatch:
44ecdbdc6134c (Richard Smith            2013-01-31 05:19:49 +0000   867)     return &static_cast<DFIArguments*>(Data)->SecondArg;
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   868) 
461761d68f739 (Douglas Gregor           2010-05-08 18:20:53 +0000   869)   // Unhandled
44ecdbdc6134c (Richard Smith            2013-01-31 05:19:49 +0000   870)   case Sema::TDK_MiscellaneousDeductionFailure:
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   871)     break;
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   872)   }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000   873) 
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000   874)   return nullptr;
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   875) }
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   876) 
9b534547250a3 (Richard Smith            2015-12-31 02:02:54 +0000   877) llvm::Optional<unsigned> DeductionFailureInfo::getCallArgIndex() {
c92d206ce4419 (Richard Smith            2017-01-05 23:02:44 +0000   878)   switch (static_cast<Sema::TemplateDeductionResult>(Result)) {
c92d206ce4419 (Richard Smith            2017-01-05 23:02:44 +0000   879)   case Sema::TDK_DeducedMismatch:
c92d206ce4419 (Richard Smith            2017-01-05 23:02:44 +0000   880)   case Sema::TDK_DeducedMismatchNested:
9b534547250a3 (Richard Smith            2015-12-31 02:02:54 +0000   881)     return static_cast<DFIDeducedMismatchArgs*>(Data)->CallArgIndex;
9b534547250a3 (Richard Smith            2015-12-31 02:02:54 +0000   882) 
c92d206ce4419 (Richard Smith            2017-01-05 23:02:44 +0000   883)   default:
c92d206ce4419 (Richard Smith            2017-01-05 23:02:44 +0000   884)     return llvm::None;
c92d206ce4419 (Richard Smith            2017-01-05 23:02:44 +0000   885)   }
9b534547250a3 (Richard Smith            2015-12-31 02:02:54 +0000   886) }
9b534547250a3 (Richard Smith            2015-12-31 02:02:54 +0000   887) 
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000   888) bool OverloadCandidateSet::OperatorRewriteInfo::shouldAddReversed(
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000   889)     OverloadedOperatorKind Op) {
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000   890)   if (!AllowRewrittenCandidates)
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000   891)     return false;
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000   892)   return Op == OO_EqualEqual || Op == OO_Spaceship;
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000   893) }
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000   894) 
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000   895) bool OverloadCandidateSet::OperatorRewriteInfo::shouldAddReversed(
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000   896)     ASTContext &Ctx, const FunctionDecl *FD) {
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000   897)   if (!shouldAddReversed(FD->getDeclName().getCXXOverloadedOperator()))
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000   898)     return false;
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000   899)   // Don't bother adding a reversed candidate that can never be a better
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000   900)   // match than the non-reversed version.
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000   901)   return FD->getNumParams() != 2 ||
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000   902)          !Ctx.hasSameUnqualifiedType(FD->getParamDecl(0)->getType(),
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000   903)                                      FD->getParamDecl(1)->getType()) ||
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000   904)          FD->hasAttr<EnableIfAttr>();
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000   905) }
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000   906) 
97e5949068f77 (Benjamin Kramer          2012-10-09 15:52:25 +0000   907) void OverloadCandidateSet::destroyCandidates() {
0bf93aa6b1429 (Richard Smith            2012-07-18 23:52:59 +0000   908)   for (iterator i = begin(), e = end(); i != e; ++i) {
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000   909)     for (auto &C : i->Conversions)
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000   910)       C.~ImplicitConversionSequence();
0bf93aa6b1429 (Richard Smith            2012-07-18 23:52:59 +0000   911)     if (!i->Viable && i->FailureKind == ovl_fail_bad_deduction)
0bf93aa6b1429 (Richard Smith            2012-07-18 23:52:59 +0000   912)       i->DeductionFailure.Destroy();
0bf93aa6b1429 (Richard Smith            2012-07-18 23:52:59 +0000   913)   }
97e5949068f77 (Benjamin Kramer          2012-10-09 15:52:25 +0000   914) }
97e5949068f77 (Benjamin Kramer          2012-10-09 15:52:25 +0000   915) 
67ef14fe486e1 (Richard Smith            2017-09-26 18:37:55 +0000   916) void OverloadCandidateSet::clear(CandidateSetKind CSK) {
97e5949068f77 (Benjamin Kramer          2012-10-09 15:52:25 +0000   917)   destroyCandidates();
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000   918)   SlabAllocator.Reset();
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000   919)   NumInlineBytesUsed = 0;
fb761ff54452f (Benjamin Kramer          2012-01-14 16:31:55 +0000   920)   Candidates.clear();
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   921)   Functions.clear();
67ef14fe486e1 (Richard Smith            2017-09-26 18:37:55 +0000   922)   Kind = CSK;
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000   923) }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000   924) 
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   925) namespace {
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   926)   class UnbridgedCastsSet {
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   927)     struct Entry {
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   928)       Expr **Addr;
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   929)       Expr *Saved;
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   930)     };
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   931)     SmallVector<Entry, 2> Entries;
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000   932) 
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   933)   public:
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   934)     void save(Sema &S, Expr *&E) {
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   935)       assert(E->hasPlaceholderType(BuiltinType::ARCUnbridgedCast));
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   936)       Entry entry = { &E, E };
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   937)       Entries.push_back(entry);
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   938)       E = S.stripARCUnbridgedCast(E);
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   939)     }
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   940) 
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   941)     void restore() {
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   942)       for (SmallVectorImpl<Entry>::iterator
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000   943)              i = Entries.begin(), e = Entries.end(); i != e; ++i)
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   944)         *i->Addr = i->Saved;
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   945)     }
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   946)   };
ab9db51042d1b (Alexander Kornienko      2015-06-22 23:07:51 +0000   947) }
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   948) 
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   949) /// checkPlaceholderForOverload - Do any interesting placeholder-like
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   950) /// preprocessing on the given expression.
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   951) ///
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   952) /// \param unbridgedCasts a collection to which to add unbridged casts;
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   953) ///   without this, they will be immediately diagnosed as errors
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   954) ///
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   955) /// Return true on unrecoverable error.
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000   956) static bool
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000   957) checkPlaceholderForOverload(Sema &S, Expr *&E,
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000   958)                             UnbridgedCastsSet *unbridgedCasts = nullptr) {
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   959)   if (const BuiltinType *placeholder =  E->getType()->getAsPlaceholderType()) {
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   960)     // We can't handle overloaded expressions here because overload
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   961)     // resolution might reasonably tweak them.
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   962)     if (placeholder->getKind() == BuiltinType::Overload) return false;
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   963) 
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   964)     // If the context potentially accepts unbridged ARC casts, strip
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   965)     // the unbridged cast and add it to the collection for later restoration.
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   966)     if (placeholder->getKind() == BuiltinType::ARCUnbridgedCast &&
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   967)         unbridgedCasts) {
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   968)       unbridgedCasts->save(S, E);
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   969)       return false;
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   970)     }
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   971) 
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   972)     // Go ahead and check everything else.
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   973)     ExprResult result = S.CheckPlaceholderExpr(E);
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   974)     if (result.isInvalid())
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   975)       return true;
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   976) 
01a7598561561 (Nikola Smiljanic         2014-05-29 10:55:11 +0000   977)     E = result.get();
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   978)     return false;
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   979)   }
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   980) 
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   981)   // Nothing to do.
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   982)   return false;
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   983) }
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   984) 
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   985) /// checkArgPlaceholdersForOverload - Check a set of call operands for
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   986) /// placeholders.
9c785c217b3f9 (Dmitri Gribenko          2013-05-09 21:02:07 +0000   987) static bool checkArgPlaceholdersForOverload(Sema &S,
9c785c217b3f9 (Dmitri Gribenko          2013-05-09 21:02:07 +0000   988)                                             MultiExprArg Args,
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   989)                                             UnbridgedCastsSet &unbridged) {
9c785c217b3f9 (Dmitri Gribenko          2013-05-09 21:02:07 +0000   990)   for (unsigned i = 0, e = Args.size(); i != e; ++i)
9c785c217b3f9 (Dmitri Gribenko          2013-05-09 21:02:07 +0000   991)     if (checkPlaceholderForOverload(S, Args[i], &unbridged))
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   992)       return true;
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   993) 
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   994)   return false;
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   995) }
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000   996) 
2d82b091d9660 (George Burgess IV        2017-04-06 00:23:31 +0000   997) /// Determine whether the given New declaration is an overload of the
2d82b091d9660 (George Burgess IV        2017-04-06 00:23:31 +0000   998) /// declarations in Old. This routine returns Ovl_Match or Ovl_NonFunction if
2d82b091d9660 (George Burgess IV        2017-04-06 00:23:31 +0000   999) /// New and Old cannot be overloaded, e.g., if New has the same signature as
2d82b091d9660 (George Burgess IV        2017-04-06 00:23:31 +0000  1000) /// some function in Old (C++ 1.3.10) or if the Old declarations aren't
2d82b091d9660 (George Burgess IV        2017-04-06 00:23:31 +0000  1001) /// functions (or function templates) at all. When it does return Ovl_Match or
2d82b091d9660 (George Burgess IV        2017-04-06 00:23:31 +0000  1002) /// Ovl_NonFunction, MatchedDecl will point to the decl that New cannot be
2d82b091d9660 (George Burgess IV        2017-04-06 00:23:31 +0000  1003) /// overloaded with. This decl may be a UsingShadowDecl on top of the underlying
2d82b091d9660 (George Burgess IV        2017-04-06 00:23:31 +0000  1004) /// declaration.
2d82b091d9660 (George Burgess IV        2017-04-06 00:23:31 +0000  1005) ///
2d82b091d9660 (George Burgess IV        2017-04-06 00:23:31 +0000  1006) /// Example: Given the following input:
2d82b091d9660 (George Burgess IV        2017-04-06 00:23:31 +0000  1007) ///
2d82b091d9660 (George Burgess IV        2017-04-06 00:23:31 +0000  1008) ///   void f(int, float); // #1
2d82b091d9660 (George Burgess IV        2017-04-06 00:23:31 +0000  1009) ///   void f(int, int); // #2
2d82b091d9660 (George Burgess IV        2017-04-06 00:23:31 +0000  1010) ///   int f(int, int); // #3
2d82b091d9660 (George Burgess IV        2017-04-06 00:23:31 +0000  1011) ///
2d82b091d9660 (George Burgess IV        2017-04-06 00:23:31 +0000  1012) /// When we process #1, there is no previous declaration of "f", so IsOverload
2d82b091d9660 (George Burgess IV        2017-04-06 00:23:31 +0000  1013) /// will not be used.
2d82b091d9660 (George Burgess IV        2017-04-06 00:23:31 +0000  1014) ///
2d82b091d9660 (George Burgess IV        2017-04-06 00:23:31 +0000  1015) /// When we process #2, Old contains only the FunctionDecl for #1. By comparing
2d82b091d9660 (George Burgess IV        2017-04-06 00:23:31 +0000  1016) /// the parameter types, we see that #1 and #2 are overloaded (since they have
2d82b091d9660 (George Burgess IV        2017-04-06 00:23:31 +0000  1017) /// different signatures), so this routine returns Ovl_Overload; MatchedDecl is
2d82b091d9660 (George Burgess IV        2017-04-06 00:23:31 +0000  1018) /// unchanged.
2d82b091d9660 (George Burgess IV        2017-04-06 00:23:31 +0000  1019) ///
2d82b091d9660 (George Burgess IV        2017-04-06 00:23:31 +0000  1020) /// When we process #3, Old is an overload set containing #1 and #2. We compare
2d82b091d9660 (George Burgess IV        2017-04-06 00:23:31 +0000  1021) /// the signatures of #3 to #1 (they're overloaded, so we do nothing) and then
2d82b091d9660 (George Burgess IV        2017-04-06 00:23:31 +0000  1022) /// #3 to #2. Since the signatures of #3 and #2 are identical (return types of
2d82b091d9660 (George Burgess IV        2017-04-06 00:23:31 +0000  1023) /// functions are not part of the signature), IsOverload returns Ovl_Match and
2d82b091d9660 (George Burgess IV        2017-04-06 00:23:31 +0000  1024) /// MatchedDecl will be set to point to the FunctionDecl for #2.
2d82b091d9660 (George Burgess IV        2017-04-06 00:23:31 +0000  1025) ///
2d82b091d9660 (George Burgess IV        2017-04-06 00:23:31 +0000  1026) /// 'NewIsUsingShadowDecl' indicates that 'New' is being introduced into a class
2d82b091d9660 (George Burgess IV        2017-04-06 00:23:31 +0000  1027) /// by a using declaration. The rules for whether to hide shadow declarations
2d82b091d9660 (George Burgess IV        2017-04-06 00:23:31 +0000  1028) /// ignore some properties which otherwise figure into a function template's
2d82b091d9660 (George Burgess IV        2017-04-06 00:23:31 +0000  1029) /// signature.
daa3d6bb502a3 (John McCall              2009-12-09 03:35:25 +0000  1030) Sema::OverloadKind
e9cccd86da2fe (John McCall              2010-06-16 08:42:20 +0000  1031) Sema::CheckOverload(Scope *S, FunctionDecl *New, const LookupResult &Old,
e9cccd86da2fe (John McCall              2010-06-16 08:42:20 +0000  1032)                     NamedDecl *&Match, bool NewIsUsingDecl) {
3d988d9042ffc (John McCall              2009-12-02 08:47:38 +0000  1033)   for (LookupResult::iterator I = Old.begin(), E = Old.end();
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1034)          I != E; ++I) {
e9cccd86da2fe (John McCall              2010-06-16 08:42:20 +0000  1035)     NamedDecl *OldD = *I;
e9cccd86da2fe (John McCall              2010-06-16 08:42:20 +0000  1036) 
e9cccd86da2fe (John McCall              2010-06-16 08:42:20 +0000  1037)     bool OldIsUsingDecl = false;
e9cccd86da2fe (John McCall              2010-06-16 08:42:20 +0000  1038)     if (isa<UsingShadowDecl>(OldD)) {
e9cccd86da2fe (John McCall              2010-06-16 08:42:20 +0000  1039)       OldIsUsingDecl = true;
e9cccd86da2fe (John McCall              2010-06-16 08:42:20 +0000  1040) 
e9cccd86da2fe (John McCall              2010-06-16 08:42:20 +0000  1041)       // We can always introduce two using declarations into the same
e9cccd86da2fe (John McCall              2010-06-16 08:42:20 +0000  1042)       // context, even if they have identical signatures.
e9cccd86da2fe (John McCall              2010-06-16 08:42:20 +0000  1043)       if (NewIsUsingDecl) continue;
e9cccd86da2fe (John McCall              2010-06-16 08:42:20 +0000  1044) 
e9cccd86da2fe (John McCall              2010-06-16 08:42:20 +0000  1045)       OldD = cast<UsingShadowDecl>(OldD)->getTargetDecl();
e9cccd86da2fe (John McCall              2010-06-16 08:42:20 +0000  1046)     }
e9cccd86da2fe (John McCall              2010-06-16 08:42:20 +0000  1047) 
f091e129dbf75 (Richard Smith            2015-09-15 01:28:55 +0000  1048)     // A using-declaration does not conflict with another declaration
f091e129dbf75 (Richard Smith            2015-09-15 01:28:55 +0000  1049)     // if one of them is hidden.
f091e129dbf75 (Richard Smith            2015-09-15 01:28:55 +0000  1050)     if ((OldIsUsingDecl || NewIsUsingDecl) && !isVisible(*I))
f091e129dbf75 (Richard Smith            2015-09-15 01:28:55 +0000  1051)       continue;
f091e129dbf75 (Richard Smith            2015-09-15 01:28:55 +0000  1052) 
e9cccd86da2fe (John McCall              2010-06-16 08:42:20 +0000  1053)     // If either declaration was introduced by a using declaration,
e9cccd86da2fe (John McCall              2010-06-16 08:42:20 +0000  1054)     // we'll need to use slightly different rules for matching.
e9cccd86da2fe (John McCall              2010-06-16 08:42:20 +0000  1055)     // Essentially, these rules are the normal rules, except that
e9cccd86da2fe (John McCall              2010-06-16 08:42:20 +0000  1056)     // function templates hide function templates with different
e9cccd86da2fe (John McCall              2010-06-16 08:42:20 +0000  1057)     // return types or template parameter lists.
e9cccd86da2fe (John McCall              2010-06-16 08:42:20 +0000  1058)     bool UseMemberUsingDeclRules =
c70fca60dab47 (John McCall              2013-04-03 21:19:47 +0000  1059)       (OldIsUsingDecl || NewIsUsingDecl) && CurContext->isRecord() &&
c70fca60dab47 (John McCall              2013-04-03 21:19:47 +0000  1060)       !New->getFriendObjectKind();
e9cccd86da2fe (John McCall              2010-06-16 08:42:20 +0000  1061) 
a2794f9f36336 (Alp Toker                2014-01-22 07:29:52 +0000  1062)     if (FunctionDecl *OldF = OldD->getAsFunction()) {
e9cccd86da2fe (John McCall              2010-06-16 08:42:20 +0000  1063)       if (!IsOverload(New, OldF, UseMemberUsingDeclRules)) {
e9cccd86da2fe (John McCall              2010-06-16 08:42:20 +0000  1064)         if (UseMemberUsingDeclRules && OldIsUsingDecl) {
e9cccd86da2fe (John McCall              2010-06-16 08:42:20 +0000  1065)           HideUsingShadowDecl(S, cast<UsingShadowDecl>(*I));
e9cccd86da2fe (John McCall              2010-06-16 08:42:20 +0000  1066)           continue;
e9cccd86da2fe (John McCall              2010-06-16 08:42:20 +0000  1067)         }
e9cccd86da2fe (John McCall              2010-06-16 08:42:20 +0000  1068) 
a2794f9f36336 (Alp Toker                2014-01-22 07:29:52 +0000  1069)         if (!isa<FunctionTemplateDecl>(OldD) &&
a2794f9f36336 (Alp Toker                2014-01-22 07:29:52 +0000  1070)             !shouldLinkPossiblyHiddenDecl(*I, New))
5bddd6a92a0e8 (Rafael Espindola         2013-04-15 12:49:13 +0000  1071)           continue;
5bddd6a92a0e8 (Rafael Espindola         2013-04-15 12:49:13 +0000  1072) 
daa3d6bb502a3 (John McCall              2009-12-09 03:35:25 +0000  1073)         Match = *I;
daa3d6bb502a3 (John McCall              2009-12-09 03:35:25 +0000  1074)         return Ovl_Match;
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1075)       }
41af97137572a (Erich Keane              2018-04-16 21:30:08 +0000  1076) 
41af97137572a (Erich Keane              2018-04-16 21:30:08 +0000  1077)       // Builtins that have custom typechecking or have a reference should
41af97137572a (Erich Keane              2018-04-16 21:30:08 +0000  1078)       // not be overloadable or redeclarable.
41af97137572a (Erich Keane              2018-04-16 21:30:08 +0000  1079)       if (!getASTContext().canBuiltinBeRedeclared(OldF)) {
41af97137572a (Erich Keane              2018-04-16 21:30:08 +0000  1080)         Match = *I;
41af97137572a (Erich Keane              2018-04-16 21:30:08 +0000  1081)         return Ovl_NonFunction;
41af97137572a (Erich Keane              2018-04-16 21:30:08 +0000  1082)       }
151c4568581f1 (Richard Smith            2016-12-20 21:35:28 +0000  1083)     } else if (isa<UsingDecl>(OldD) || isa<UsingPackDecl>(OldD)) {
84d8767c1582d (John McCall              2009-12-10 09:41:52 +0000  1084)       // We can overload with these, which can show up when doing
84d8767c1582d (John McCall              2009-12-10 09:41:52 +0000  1085)       // redeclaration checks for UsingDecls.
84d8767c1582d (John McCall              2009-12-10 09:41:52 +0000  1086)       assert(Old.getLookupKind() == LookupUsingDeclName);
a8987a294da6d (John McCall              2010-11-10 03:01:53 +0000  1087)     } else if (isa<TagDecl>(OldD)) {
a8987a294da6d (John McCall              2010-11-10 03:01:53 +0000  1088)       // We can always overload with tags by hiding them.
d8a9e375582fe (Richard Smith            2016-12-18 21:39:37 +0000  1089)     } else if (auto *UUD = dyn_cast<UnresolvedUsingValueDecl>(OldD)) {
84d8767c1582d (John McCall              2009-12-10 09:41:52 +0000  1090)       // Optimistically assume that an unresolved using decl will
84d8767c1582d (John McCall              2009-12-10 09:41:52 +0000  1091)       // overload; if it doesn't, we'll have to diagnose during
84d8767c1582d (John McCall              2009-12-10 09:41:52 +0000  1092)       // template instantiation.
d8a9e375582fe (Richard Smith            2016-12-18 21:39:37 +0000  1093)       //
d8a9e375582fe (Richard Smith            2016-12-18 21:39:37 +0000  1094)       // Exception: if the scope is dependent and this is not a class
d8a9e375582fe (Richard Smith            2016-12-18 21:39:37 +0000  1095)       // member, the using declaration can only introduce an enumerator.
d8a9e375582fe (Richard Smith            2016-12-18 21:39:37 +0000  1096)       if (UUD->getQualifier()->isDependent() && !UUD->isCXXClassMember()) {
d8a9e375582fe (Richard Smith            2016-12-18 21:39:37 +0000  1097)         Match = *I;
d8a9e375582fe (Richard Smith            2016-12-18 21:39:37 +0000  1098)         return Ovl_NonFunction;
d8a9e375582fe (Richard Smith            2016-12-18 21:39:37 +0000  1099)       }
84d8767c1582d (John McCall              2009-12-10 09:41:52 +0000  1100)     } else {
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1101)       // (C++ 13p1):
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1102)       //   Only function declarations can be overloaded; object and type
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1103)       //   declarations cannot be overloaded.
daa3d6bb502a3 (John McCall              2009-12-09 03:35:25 +0000  1104)       Match = *I;
daa3d6bb502a3 (John McCall              2009-12-09 03:35:25 +0000  1105)       return Ovl_NonFunction;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1106)     }
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1107)   }
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1108) 
8ce732b46f557 (Richard Smith            2019-01-07 06:00:46 +0000  1109)   // C++ [temp.friend]p1:
8ce732b46f557 (Richard Smith            2019-01-07 06:00:46 +0000  1110)   //   For a friend function declaration that is not a template declaration:
8ce732b46f557 (Richard Smith            2019-01-07 06:00:46 +0000  1111)   //    -- if the name of the friend is a qualified or unqualified template-id,
8ce732b46f557 (Richard Smith            2019-01-07 06:00:46 +0000  1112)   //       [...], otherwise
8ce732b46f557 (Richard Smith            2019-01-07 06:00:46 +0000  1113)   //    -- if the name of the friend is a qualified-id and a matching
8ce732b46f557 (Richard Smith            2019-01-07 06:00:46 +0000  1114)   //       non-template function is found in the specified class or namespace,
8ce732b46f557 (Richard Smith            2019-01-07 06:00:46 +0000  1115)   //       the friend declaration refers to that function, otherwise,
8ce732b46f557 (Richard Smith            2019-01-07 06:00:46 +0000  1116)   //    -- if the name of the friend is a qualified-id and a matching function
8ce732b46f557 (Richard Smith            2019-01-07 06:00:46 +0000  1117)   //       template is found in the specified class or namespace, the friend
8ce732b46f557 (Richard Smith            2019-01-07 06:00:46 +0000  1118)   //       declaration refers to the deduced specialization of that function
8ce732b46f557 (Richard Smith            2019-01-07 06:00:46 +0000  1119)   //       template, otherwise
8ce732b46f557 (Richard Smith            2019-01-07 06:00:46 +0000  1120)   //    -- the name shall be an unqualified-id [...]
8ce732b46f557 (Richard Smith            2019-01-07 06:00:46 +0000  1121)   // If we get here for a qualified friend declaration, we've just reached the
8ce732b46f557 (Richard Smith            2019-01-07 06:00:46 +0000  1122)   // third bullet. If the type of the friend is dependent, skip this lookup
8ce732b46f557 (Richard Smith            2019-01-07 06:00:46 +0000  1123)   // until instantiation.
8ce732b46f557 (Richard Smith            2019-01-07 06:00:46 +0000  1124)   if (New->getFriendObjectKind() && New->getQualifier() &&
bac77806c5881 (Richard Smith            2019-05-02 00:49:05 +0000  1125)       !New->getDescribedFunctionTemplate() &&
64095fc07c737 (Richard Smith            2019-01-11 01:59:33 +0000  1126)       !New->getDependentSpecializationInfo() &&
8ce732b46f557 (Richard Smith            2019-01-07 06:00:46 +0000  1127)       !New->getType()->isDependentType()) {
8ce732b46f557 (Richard Smith            2019-01-07 06:00:46 +0000  1128)     LookupResult TemplateSpecResult(LookupResult::Temporary, Old);
8ce732b46f557 (Richard Smith            2019-01-07 06:00:46 +0000  1129)     TemplateSpecResult.addAllDecls(Old);
8ce732b46f557 (Richard Smith            2019-01-07 06:00:46 +0000  1130)     if (CheckFunctionTemplateSpecialization(New, nullptr, TemplateSpecResult,
8ce732b46f557 (Richard Smith            2019-01-07 06:00:46 +0000  1131)                                             /*QualifiedFriend*/true)) {
8ce732b46f557 (Richard Smith            2019-01-07 06:00:46 +0000  1132)       New->setInvalidDecl();
8ce732b46f557 (Richard Smith            2019-01-07 06:00:46 +0000  1133)       return Ovl_Overload;
8ce732b46f557 (Richard Smith            2019-01-07 06:00:46 +0000  1134)     }
8ce732b46f557 (Richard Smith            2019-01-07 06:00:46 +0000  1135) 
8ce732b46f557 (Richard Smith            2019-01-07 06:00:46 +0000  1136)     Match = TemplateSpecResult.getAsSingle<FunctionDecl>();
8ce732b46f557 (Richard Smith            2019-01-07 06:00:46 +0000  1137)     return Ovl_Match;
8ce732b46f557 (Richard Smith            2019-01-07 06:00:46 +0000  1138)   }
8ce732b46f557 (Richard Smith            2019-01-07 06:00:46 +0000  1139) 
daa3d6bb502a3 (John McCall              2009-12-09 03:35:25 +0000  1140)   return Ovl_Overload;
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1141) }
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1142) 
ac974a3c76fbe (Richard Smith            2013-06-30 09:48:50 +0000  1143) bool Sema::IsOverload(FunctionDecl *New, FunctionDecl *Old,
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  1144)                       bool UseMemberUsingDeclRules, bool ConsiderCudaAttrs,
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  1145)                       bool ConsiderRequiresClauses) {
ac974a3c76fbe (Richard Smith            2013-06-30 09:48:50 +0000  1146)   // C++ [basic.start.main]p2: This function shall not be overloaded.
ac974a3c76fbe (Richard Smith            2013-06-30 09:48:50 +0000  1147)   if (New->isMain())
7cf35ef8f6a0e (Rafael Espindola         2013-01-12 01:47:40 +0000  1148)     return false;
7cf35ef8f6a0e (Rafael Espindola         2013-01-12 01:47:40 +0000  1149) 
c729b0b50669e (David Majnemer           2013-09-16 22:44:20 +0000  1150)   // MSVCRT user defined entry points cannot be overloaded.
c729b0b50669e (David Majnemer           2013-09-16 22:44:20 +0000  1151)   if (New->isMSVCRTEntryPoint())
c729b0b50669e (David Majnemer           2013-09-16 22:44:20 +0000  1152)     return false;
c729b0b50669e (David Majnemer           2013-09-16 22:44:20 +0000  1153) 
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1154)   FunctionTemplateDecl *OldTemplate = Old->getDescribedFunctionTemplate();
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1155)   FunctionTemplateDecl *NewTemplate = New->getDescribedFunctionTemplate();
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1156) 
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1157)   // C++ [temp.fct]p2:
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1158)   //   A function template can be overloaded with other function templates
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1159)   //   and with normal (non-template) functions.
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000  1160)   if ((OldTemplate == nullptr) != (NewTemplate == nullptr))
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1161)     return true;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1162) 
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1163)   // Is the function New an overload of the function Old?
ac974a3c76fbe (Richard Smith            2013-06-30 09:48:50 +0000  1164)   QualType OldQType = Context.getCanonicalType(Old->getType());
ac974a3c76fbe (Richard Smith            2013-06-30 09:48:50 +0000  1165)   QualType NewQType = Context.getCanonicalType(New->getType());
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1166) 
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1167)   // Compare the signatures (C++ 1.3.10) of the two functions to
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1168)   // determine whether they are overloads. If we find any mismatch
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1169)   // in the signature, they are overloads.
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1170) 
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1171)   // If either of these functions is a K&R-style function (no
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1172)   // prototype), then we consider them to have matching signatures.
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1173)   if (isa<FunctionNoProtoType>(OldQType.getTypePtr()) ||
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1174)       isa<FunctionNoProtoType>(NewQType.getTypePtr()))
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1175)     return false;
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1176) 
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  1177)   const FunctionProtoType *OldType = cast<FunctionProtoType>(OldQType);
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  1178)   const FunctionProtoType *NewType = cast<FunctionProtoType>(NewQType);
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1179) 
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1180)   // The signature of a function includes the types of its
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1181)   // parameters (C++ 1.3.10), which includes the presence or absence
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1182)   // of the ellipsis; see C++ DR 357).
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1183)   if (OldQType != NewQType &&
9cacbabd33eea (Alp Toker                2014-01-20 20:26:09 +0000  1184)       (OldType->getNumParams() != NewType->getNumParams() ||
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1185)        OldType->isVariadic() != NewType->isVariadic() ||
9cacbabd33eea (Alp Toker                2014-01-20 20:26:09 +0000  1186)        !FunctionParamTypesAreEqual(OldType, NewType)))
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1187)     return true;
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1188) 
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1189)   // C++ [temp.over.link]p4:
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1190)   //   The signature of a function template consists of its function
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1191)   //   signature, its return type and its template parameter list. The names
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1192)   //   of the template parameters are significant only for establishing the
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1193)   //   relationship between the template parameters and the rest of the
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1194)   //   signature.
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1195)   //
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1196)   // We check the return type and template parameter lists for function
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1197)   // templates first; the remaining checks follow.
e9cccd86da2fe (John McCall              2010-06-16 08:42:20 +0000  1198)   //
e9cccd86da2fe (John McCall              2010-06-16 08:42:20 +0000  1199)   // However, we don't consider either of these when deciding whether
e9cccd86da2fe (John McCall              2010-06-16 08:42:20 +0000  1200)   // a member introduced by a shadow declaration is hidden.
39fd529935dff (Justin Lebar             2016-03-30 20:41:05 +0000  1201)   if (!UseMemberUsingDeclRules && NewTemplate &&
ac974a3c76fbe (Richard Smith            2013-06-30 09:48:50 +0000  1202)       (!TemplateParameterListsAreEqual(NewTemplate->getTemplateParameters(),
ac974a3c76fbe (Richard Smith            2013-06-30 09:48:50 +0000  1203)                                        OldTemplate->getTemplateParameters(),
ac974a3c76fbe (Richard Smith            2013-06-30 09:48:50 +0000  1204)                                        false, TPL_TemplateMatch) ||
4576a77b80964 (Richard Smith            2018-09-10 06:35:32 +0000  1205)        !Context.hasSameType(Old->getDeclaredReturnType(),
4576a77b80964 (Richard Smith            2018-09-10 06:35:32 +0000  1206)                             New->getDeclaredReturnType())))
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1207)     return true;
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1208) 
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1209)   // If the function is a class member, its signature includes the
b2f8aa9556bf9 (Douglas Gregor           2011-01-26 17:47:49 +0000  1210)   // cv-qualifiers (if any) and ref-qualifier (if any) on the function itself.
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1211)   //
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1212)   // As part of this, also check whether one of the member functions
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1213)   // is static, in which case they are not overloads (C++
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1214)   // 13.1p2). While not part of the definition of the signature,
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1215)   // this check is important to determine whether these functions
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1216)   // can be overloaded.
574f4f6a1d861 (Richard Smith            2013-01-14 05:37:29 +0000  1217)   CXXMethodDecl *OldMethod = dyn_cast<CXXMethodDecl>(Old);
574f4f6a1d861 (Richard Smith            2013-01-14 05:37:29 +0000  1218)   CXXMethodDecl *NewMethod = dyn_cast<CXXMethodDecl>(New);
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1219)   if (OldMethod && NewMethod &&
574f4f6a1d861 (Richard Smith            2013-01-14 05:37:29 +0000  1220)       !OldMethod->isStatic() && !NewMethod->isStatic()) {
574f4f6a1d861 (Richard Smith            2013-01-14 05:37:29 +0000  1221)     if (OldMethod->getRefQualifier() != NewMethod->getRefQualifier()) {
39fd529935dff (Justin Lebar             2016-03-30 20:41:05 +0000  1222)       if (!UseMemberUsingDeclRules &&
574f4f6a1d861 (Richard Smith            2013-01-14 05:37:29 +0000  1223)           (OldMethod->getRefQualifier() == RQ_None ||
574f4f6a1d861 (Richard Smith            2013-01-14 05:37:29 +0000  1224)            NewMethod->getRefQualifier() == RQ_None)) {
574f4f6a1d861 (Richard Smith            2013-01-14 05:37:29 +0000  1225)         // C++0x [over.load]p2:
574f4f6a1d861 (Richard Smith            2013-01-14 05:37:29 +0000  1226)         //   - Member function declarations with the same name and the same
574f4f6a1d861 (Richard Smith            2013-01-14 05:37:29 +0000  1227)         //     parameter-type-list as well as member function template
574f4f6a1d861 (Richard Smith            2013-01-14 05:37:29 +0000  1228)         //     declarations with the same name, the same parameter-type-list, and
574f4f6a1d861 (Richard Smith            2013-01-14 05:37:29 +0000  1229)         //     the same template parameter lists cannot be overloaded if any of
574f4f6a1d861 (Richard Smith            2013-01-14 05:37:29 +0000  1230)         //     them, but not all, have a ref-qualifier (8.3.5).
ac974a3c76fbe (Richard Smith            2013-06-30 09:48:50 +0000  1231)         Diag(NewMethod->getLocation(), diag::err_ref_qualifier_overload)
574f4f6a1d861 (Richard Smith            2013-01-14 05:37:29 +0000  1232)           << NewMethod->getRefQualifier() << OldMethod->getRefQualifier();
ac974a3c76fbe (Richard Smith            2013-06-30 09:48:50 +0000  1233)         Diag(OldMethod->getLocation(), diag::note_previous_declaration);
574f4f6a1d861 (Richard Smith            2013-01-14 05:37:29 +0000  1234)       }
574f4f6a1d861 (Richard Smith            2013-01-14 05:37:29 +0000  1235)       return true;
c83f9865a0dae (Douglas Gregor           2011-01-26 21:20:37 +0000  1236)     }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  1237) 
574f4f6a1d861 (Richard Smith            2013-01-14 05:37:29 +0000  1238)     // We may not have applied the implicit const for a constexpr member
574f4f6a1d861 (Richard Smith            2013-01-14 05:37:29 +0000  1239)     // function yet (because we haven't yet resolved whether this is a static
574f4f6a1d861 (Richard Smith            2013-01-14 05:37:29 +0000  1240)     // or non-static member function). Add it now, on the assumption that this
574f4f6a1d861 (Richard Smith            2013-01-14 05:37:29 +0000  1241)     // is a redeclaration of OldMethod.
c61eaa5920161 (Anastasia Stulova        2019-01-28 11:37:49 +0000  1242)     auto OldQuals = OldMethod->getMethodQualifiers();
c61eaa5920161 (Anastasia Stulova        2019-01-28 11:37:49 +0000  1243)     auto NewQuals = NewMethod->getMethodQualifiers();
dd69ef38dba72 (Aaron Ballman            2014-08-19 15:55:55 +0000  1244)     if (!getLangOpts().CPlusPlus14 && NewMethod->isConstexpr() &&
e83b1d3e7aa36 (Richard Smith            2013-06-25 18:46:26 +0000  1245)         !isa<CXXConstructorDecl>(NewMethod))
5cffa45401149 (Anastasia Stulova        2019-01-21 16:01:38 +0000  1246)       NewQuals.addConst();
42350dfcc82c0 (David Majnemer           2013-11-03 23:51:28 +0000  1247)     // We do not allow overloading based off of '__restrict'.
5cffa45401149 (Anastasia Stulova        2019-01-21 16:01:38 +0000  1248)     OldQuals.removeRestrict();
5cffa45401149 (Anastasia Stulova        2019-01-21 16:01:38 +0000  1249)     NewQuals.removeRestrict();
42350dfcc82c0 (David Majnemer           2013-11-03 23:51:28 +0000  1250)     if (OldQuals != NewQuals)
574f4f6a1d861 (Richard Smith            2013-01-14 05:37:29 +0000  1251)       return true;
c83f9865a0dae (Douglas Gregor           2011-01-26 21:20:37 +0000  1252)   }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  1253) 
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000  1254)   // Though pass_object_size is placed on parameters and takes an argument, we
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000  1255)   // consider it to be a function-level modifier for the sake of function
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000  1256)   // identity. Either the function has one or more parameters with
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000  1257)   // pass_object_size or it doesn't.
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000  1258)   if (functionHasPassObjectSizeParams(New) !=
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000  1259)       functionHasPassObjectSizeParams(Old))
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000  1260)     return true;
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000  1261) 
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  1262)   // enable_if attributes are an order-sensitive part of the signature.
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  1263)   for (specific_attr_iterator<EnableIfAttr>
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  1264)          NewI = New->specific_attr_begin<EnableIfAttr>(),
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  1265)          NewE = New->specific_attr_end<EnableIfAttr>(),
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  1266)          OldI = Old->specific_attr_begin<EnableIfAttr>(),
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  1267)          OldE = Old->specific_attr_end<EnableIfAttr>();
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  1268)        NewI != NewE || OldI != OldE; ++NewI, ++OldI) {
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  1269)     if (NewI == NewE || OldI == OldE)
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  1270)       return true;
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  1271)     llvm::FoldingSetNodeID NewID, OldID;
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  1272)     NewI->getCond()->Profile(NewID, Context, true);
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  1273)     OldI->getCond()->Profile(OldID, Context, true);
d950ae74a3619 (Nick Lewycky             2014-01-21 01:30:30 +0000  1274)     if (NewID != OldID)
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  1275)       return true;
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  1276)   }
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  1277) 
ba122ab42fe54 (Justin Lebar             2016-03-30 23:30:21 +0000  1278)   if (getLangOpts().CUDA && ConsiderCudaAttrs) {
e060feb7b1a98 (Justin Lebar             2016-10-03 16:48:23 +0000  1279)     // Don't allow overloading of destructors.  (In theory we could, but it
e060feb7b1a98 (Justin Lebar             2016-10-03 16:48:23 +0000  1280)     // would be a giant change to clang.)
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  1281)     if (!isa<CXXDestructorDecl>(New)) {
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  1282)       CUDAFunctionTarget NewTarget = IdentifyCUDATarget(New),
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  1283)                          OldTarget = IdentifyCUDATarget(Old);
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  1284)       if (NewTarget != CFT_InvalidTarget) {
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  1285)         assert((OldTarget != CFT_InvalidTarget) &&
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  1286)                "Unexpected invalid target.");
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  1287) 
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  1288)         // Allow overloading of functions with same signature and different CUDA
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  1289)         // target attributes.
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  1290)         if (NewTarget != OldTarget)
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  1291)           return true;
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  1292)       }
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  1293)     }
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  1294)   }
94a55e8169a1e (Artem Belevich           2015-09-22 17:22:59 +0000  1295) 
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  1296)   if (ConsiderRequiresClauses) {
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  1297)     Expr *NewRC = New->getTrailingRequiresClause(),
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  1298)          *OldRC = Old->getTrailingRequiresClause();
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  1299)     if ((NewRC != nullptr) != (OldRC != nullptr))
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  1300)       // RC are most certainly different - these are overloads.
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  1301)       return true;
94a55e8169a1e (Artem Belevich           2015-09-22 17:22:59 +0000  1302) 
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  1303)     if (NewRC) {
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  1304)       llvm::FoldingSetNodeID NewID, OldID;
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  1305)       NewRC->Profile(NewID, Context, /*Canonical=*/true);
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  1306)       OldRC->Profile(OldID, Context, /*Canonical=*/true);
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  1307)       if (NewID != OldID)
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  1308)         // RCs are not equivalent - these are overloads.
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  1309)         return true;
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  1310)     }
94a55e8169a1e (Artem Belevich           2015-09-22 17:22:59 +0000  1311)   }
94a55e8169a1e (Artem Belevich           2015-09-22 17:22:59 +0000  1312) 
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1313)   // The signatures match; this is not an overload.
1f82f2462de79 (John McCall              2009-11-18 22:49:29 +0000  1314)   return false;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1315) }
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1316) 
9fc8faf9e6197 (Adrian Prantl            2018-05-09 01:00:01 +0000  1317) /// Tries a user-defined conversion from From to ToType.
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1318) ///
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1319) /// Produces an implicit conversion sequence for when a standard conversion
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1320) /// is not an option. See TryImplicitConversion for more information.
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1321) static ImplicitConversionSequence
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1322) TryUserDefinedConversion(Sema &S, Expr *From, QualType ToType,
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1323)                          bool SuppressUserConversions,
d28763cad06e6 (Richard Smith            2020-01-29 12:07:14 -0800  1324)                          AllowedExplicit AllowExplicit,
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1325)                          bool InOverloadResolution,
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1326)                          bool CStyle,
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  1327)                          bool AllowObjCWritebackConversion,
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  1328)                          bool AllowObjCConversionOnExplicit) {
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1329)   ImplicitConversionSequence ICS;
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1330) 
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1331)   if (SuppressUserConversions) {
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1332)     // We're not in the case above, so there is no conversion that
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1333)     // we can perform.
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1334)     ICS.setBad(BadConversionSequence::no_conversion, From, ToType);
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1335)     return ICS;
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1336)   }
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1337) 
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1338)   // Attempt user-defined conversion.
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000  1339)   OverloadCandidateSet Conversions(From->getExprLoc(),
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000  1340)                                    OverloadCandidateSet::CSK_Normal);
48372b68fefb9 (Richard Smith            2015-01-27 03:30:40 +0000  1341)   switch (IsUserDefinedConversion(S, From, ToType, ICS.UserDefined,
48372b68fefb9 (Richard Smith            2015-01-27 03:30:40 +0000  1342)                                   Conversions, AllowExplicit,
48372b68fefb9 (Richard Smith            2015-01-27 03:30:40 +0000  1343)                                   AllowObjCConversionOnExplicit)) {
48372b68fefb9 (Richard Smith            2015-01-27 03:30:40 +0000  1344)   case OR_Success:
48372b68fefb9 (Richard Smith            2015-01-27 03:30:40 +0000  1345)   case OR_Deleted:
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1346)     ICS.setUserDefined();
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1347)     // C++ [over.ics.user]p4:
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1348)     //   A conversion of an expression of class type to the same class
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1349)     //   type is given Exact Match rank, and a conversion of an
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1350)     //   expression of class type to a base class of that type is
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1351)     //   given Conversion rank, in spite of the fact that a copy
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1352)     //   constructor (i.e., a user-defined conversion function) is
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1353)     //   called for those cases.
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1354)     if (CXXConstructorDecl *Constructor
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1355)           = dyn_cast<CXXConstructorDecl>(ICS.UserDefined.ConversionFunction)) {
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1356)       QualType FromCanon
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1357)         = S.Context.getCanonicalType(From->getType().getUnqualifiedType());
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1358)       QualType ToCanon
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1359)         = S.Context.getCanonicalType(ToType).getUnqualifiedType();
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1360)       if (Constructor->isCopyConstructor() &&
0f59cb38e7f31 (Richard Smith            2015-12-18 21:45:41 +0000  1361)           (FromCanon == ToCanon ||
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  1362)            S.IsDerivedFrom(From->getBeginLoc(), FromCanon, ToCanon))) {
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1363)         // Turn this into a "standard" conversion sequence, so that it
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1364)         // gets ranked with standard conversion sequences.
c2bebe9acab26 (Richard Smith            2016-05-11 20:37:46 +0000  1365)         DeclAccessPair Found = ICS.UserDefined.FoundConversionFunction;
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1366)         ICS.setStandard();
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1367)         ICS.Standard.setAsIdentityConversion();
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1368)         ICS.Standard.setFromType(From->getType());
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1369)         ICS.Standard.setAllToTypes(ToType);
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1370)         ICS.Standard.CopyConstructor = Constructor;
c2bebe9acab26 (Richard Smith            2016-05-11 20:37:46 +0000  1371)         ICS.Standard.FoundCopyConstructor = Found;
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1372)         if (ToCanon != FromCanon)
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1373)           ICS.Standard.Second = ICK_Derived_To_Base;
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1374)       }
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1375)     }
48372b68fefb9 (Richard Smith            2015-01-27 03:30:40 +0000  1376)     break;
48372b68fefb9 (Richard Smith            2015-01-27 03:30:40 +0000  1377) 
48372b68fefb9 (Richard Smith            2015-01-27 03:30:40 +0000  1378)   case OR_Ambiguous:
1bbaba874633e (Richard Smith            2015-01-27 23:23:39 +0000  1379)     ICS.setAmbiguous();
1bbaba874633e (Richard Smith            2015-01-27 23:23:39 +0000  1380)     ICS.Ambiguous.setFromType(From->getType());
1bbaba874633e (Richard Smith            2015-01-27 23:23:39 +0000  1381)     ICS.Ambiguous.setToType(ToType);
1bbaba874633e (Richard Smith            2015-01-27 23:23:39 +0000  1382)     for (OverloadCandidateSet::iterator Cand = Conversions.begin();
1bbaba874633e (Richard Smith            2015-01-27 23:23:39 +0000  1383)          Cand != Conversions.end(); ++Cand)
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700  1384)       if (Cand->Best)
c2bebe9acab26 (Richard Smith            2016-05-11 20:37:46 +0000  1385)         ICS.Ambiguous.addConversion(Cand->FoundDecl, Cand->Function);
1bbaba874633e (Richard Smith            2015-01-27 23:23:39 +0000  1386)     break;
48372b68fefb9 (Richard Smith            2015-01-27 03:30:40 +0000  1387) 
48372b68fefb9 (Richard Smith            2015-01-27 03:30:40 +0000  1388)     // Fall through.
48372b68fefb9 (Richard Smith            2015-01-27 03:30:40 +0000  1389)   case OR_No_Viable_Function:
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1390)     ICS.setBad(BadConversionSequence::no_conversion, From, ToType);
48372b68fefb9 (Richard Smith            2015-01-27 03:30:40 +0000  1391)     break;
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1392)   }
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1393) 
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1394)   return ICS;
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1395) }
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1396) 
8e1cf608dc587 (Douglas Gregor           2008-10-29 00:13:59 +0000  1397) /// TryImplicitConversion - Attempt to perform an implicit conversion
8e1cf608dc587 (Douglas Gregor           2008-10-29 00:13:59 +0000  1398) /// from the given expression (Expr) to the given type (ToType). This
8e1cf608dc587 (Douglas Gregor           2008-10-29 00:13:59 +0000  1399) /// function returns an implicit conversion sequence that can be used
8e1cf608dc587 (Douglas Gregor           2008-10-29 00:13:59 +0000  1400) /// to perform the initialization. Given
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1401) ///
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1402) ///   void f(float f);
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1403) ///   void g(int i) { f(i); }
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1404) ///
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1405) /// this routine would produce an implicit conversion sequence to
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1406) /// describe the initialization of f from i, which will be a standard
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1407) /// conversion sequence containing an lvalue-to-rvalue conversion (C++
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1408) /// 4.1) followed by a floating-integral conversion (C++ 4.9).
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1409) //
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1410) /// Note that this routine only determines how the conversion can be
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1411) /// performed; it does not actually perform the conversion. As such,
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1412) /// it will not produce any diagnostics if no conversion is available,
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1413) /// but will instead return an implicit conversion sequence of kind
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1414) /// "BadConversion".
2fe9883a961df (Douglas Gregor           2008-11-03 19:09:14 +0000  1415) ///
2fe9883a961df (Douglas Gregor           2008-11-03 19:09:14 +0000  1416) /// If @p SuppressUserConversions, then user-defined conversions are
2fe9883a961df (Douglas Gregor           2008-11-03 19:09:14 +0000  1417) /// not permitted.
5fb53972380f5 (Douglas Gregor           2009-01-14 15:45:31 +0000  1418) /// If @p AllowExplicit, then explicit user-defined conversions are
5fb53972380f5 (Douglas Gregor           2009-01-14 15:45:31 +0000  1419) /// permitted.
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  1420) ///
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  1421) /// \param AllowObjCWritebackConversion Whether we allow the Objective-C
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  1422) /// writeback conversion, which allows __autoreleasing id* parameters to
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  1423) /// be initialized with __strong id* or __weak id* arguments.
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  1424) static ImplicitConversionSequence
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  1425) TryImplicitConversion(Sema &S, Expr *From, QualType ToType,
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  1426)                       bool SuppressUserConversions,
d28763cad06e6 (Richard Smith            2020-01-29 12:07:14 -0800  1427)                       AllowedExplicit AllowExplicit,
582813596a100 (Douglas Gregor           2011-01-27 00:58:17 +0000  1428)                       bool InOverloadResolution,
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  1429)                       bool CStyle,
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  1430)                       bool AllowObjCWritebackConversion,
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  1431)                       bool AllowObjCConversionOnExplicit) {
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1432)   ImplicitConversionSequence ICS;
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  1433)   if (IsStandardConversion(S, From, ToType, InOverloadResolution,
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  1434)                            ICS.Standard, CStyle, AllowObjCWritebackConversion)){
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000  1435)     ICS.setStandard();
bc077cf5897af (John McCall              2010-02-08 23:07:23 +0000  1436)     return ICS;
bc077cf5897af (John McCall              2010-02-08 23:07:23 +0000  1437)   }
bc077cf5897af (John McCall              2010-02-08 23:07:23 +0000  1438) 
bbafb8a745736 (David Blaikie            2012-03-11 07:00:24 +0000  1439)   if (!S.getLangOpts().CPlusPlus) {
65eb879d22cc9 (John McCall              2010-02-25 01:37:24 +0000  1440)     ICS.setBad(BadConversionSequence::no_conversion, From, ToType);
bc077cf5897af (John McCall              2010-02-08 23:07:23 +0000  1441)     return ICS;
bc077cf5897af (John McCall              2010-02-08 23:07:23 +0000  1442)   }
bc077cf5897af (John McCall              2010-02-08 23:07:23 +0000  1443) 
836a7e8468a76 (Douglas Gregor           2010-08-11 02:15:33 +0000  1444)   // C++ [over.ics.user]p4:
836a7e8468a76 (Douglas Gregor           2010-08-11 02:15:33 +0000  1445)   //   A conversion of an expression of class type to the same class
836a7e8468a76 (Douglas Gregor           2010-08-11 02:15:33 +0000  1446)   //   type is given Exact Match rank, and a conversion of an
836a7e8468a76 (Douglas Gregor           2010-08-11 02:15:33 +0000  1447)   //   expression of class type to a base class of that type is
836a7e8468a76 (Douglas Gregor           2010-08-11 02:15:33 +0000  1448)   //   given Conversion rank, in spite of the fact that a copy/move
836a7e8468a76 (Douglas Gregor           2010-08-11 02:15:33 +0000  1449)   //   constructor (i.e., a user-defined conversion function) is
836a7e8468a76 (Douglas Gregor           2010-08-11 02:15:33 +0000  1450)   //   called for those cases.
836a7e8468a76 (Douglas Gregor           2010-08-11 02:15:33 +0000  1451)   QualType FromType = From->getType();
836a7e8468a76 (Douglas Gregor           2010-08-11 02:15:33 +0000  1452)   if (ToType->getAs<RecordType>() && FromType->getAs<RecordType>() &&
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  1453)       (S.Context.hasSameUnqualifiedType(FromType, ToType) ||
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  1454)        S.IsDerivedFrom(From->getBeginLoc(), FromType, ToType))) {
5ab116553171e (Douglas Gregor           2010-04-17 22:01:05 +0000  1455)     ICS.setStandard();
5ab116553171e (Douglas Gregor           2010-04-17 22:01:05 +0000  1456)     ICS.Standard.setAsIdentityConversion();
5ab116553171e (Douglas Gregor           2010-04-17 22:01:05 +0000  1457)     ICS.Standard.setFromType(FromType);
5ab116553171e (Douglas Gregor           2010-04-17 22:01:05 +0000  1458)     ICS.Standard.setAllToTypes(ToType);
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  1459) 
5ab116553171e (Douglas Gregor           2010-04-17 22:01:05 +0000  1460)     // We don't actually check at this point whether there is a valid
5ab116553171e (Douglas Gregor           2010-04-17 22:01:05 +0000  1461)     // copy/move constructor, since overloading just assumes that it
5ab116553171e (Douglas Gregor           2010-04-17 22:01:05 +0000  1462)     // exists. When we actually perform initialization, we'll find the
5ab116553171e (Douglas Gregor           2010-04-17 22:01:05 +0000  1463)     // appropriate constructor to copy the returned object, if needed.
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000  1464)     ICS.Standard.CopyConstructor = nullptr;
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  1465) 
5ab116553171e (Douglas Gregor           2010-04-17 22:01:05 +0000  1466)     // Determine whether this is considered a derived-to-base conversion.
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  1467)     if (!S.Context.hasSameUnqualifiedType(FromType, ToType))
5ab116553171e (Douglas Gregor           2010-04-17 22:01:05 +0000  1468)       ICS.Standard.Second = ICK_Derived_To_Base;
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  1469) 
836a7e8468a76 (Douglas Gregor           2010-08-11 02:15:33 +0000  1470)     return ICS;
836a7e8468a76 (Douglas Gregor           2010-08-11 02:15:33 +0000  1471)   }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  1472) 
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1473)   return TryUserDefinedConversion(S, From, ToType, SuppressUserConversions,
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  1474)                                   AllowExplicit, InOverloadResolution, CStyle,
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  1475)                                   AllowObjCWritebackConversion,
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  1476)                                   AllowObjCConversionOnExplicit);
26bee0b326227 (Douglas Gregor           2008-10-31 16:23:19 +0000  1477) }
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1478) 
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  1479) ImplicitConversionSequence
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  1480) Sema::TryImplicitConversion(Expr *From, QualType ToType,
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  1481)                             bool SuppressUserConversions,
d28763cad06e6 (Richard Smith            2020-01-29 12:07:14 -0800  1482)                             AllowedExplicit AllowExplicit,
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  1483)                             bool InOverloadResolution,
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  1484)                             bool CStyle,
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  1485)                             bool AllowObjCWritebackConversion) {
d28763cad06e6 (Richard Smith            2020-01-29 12:07:14 -0800  1486)   return ::TryImplicitConversion(*this, From, ToType, SuppressUserConversions,
d28763cad06e6 (Richard Smith            2020-01-29 12:07:14 -0800  1487)                                  AllowExplicit, InOverloadResolution, CStyle,
17c00b43288dc (Richard Smith            2014-11-12 01:24:00 +0000  1488)                                  AllowObjCWritebackConversion,
17c00b43288dc (Richard Smith            2014-11-12 01:24:00 +0000  1489)                                  /*AllowObjCConversionOnExplicit=*/false);
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  1490) }
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  1491) 
ae4b5df81751e (Douglas Gregor           2010-04-16 22:27:05 +0000  1492) /// PerformImplicitConversion - Perform an implicit conversion of the
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000  1493) /// expression From to the type ToType. Returns the
ae4b5df81751e (Douglas Gregor           2010-04-16 22:27:05 +0000  1494) /// converted expression. Flavor is the kind of conversion we're
ae4b5df81751e (Douglas Gregor           2010-04-16 22:27:05 +0000  1495) /// performing, used in the error message. If @p AllowExplicit,
ae4b5df81751e (Douglas Gregor           2010-04-16 22:27:05 +0000  1496) /// explicit user-defined conversions are permitted.
052dbe226cb35 (Richard Smith            2020-09-03 15:33:07 -0700  1497) ExprResult Sema::PerformImplicitConversion(Expr *From, QualType ToType,
052dbe226cb35 (Richard Smith            2020-09-03 15:33:07 -0700  1498)                                            AssignmentAction Action,
052dbe226cb35 (Richard Smith            2020-09-03 15:33:07 -0700  1499)                                            bool AllowExplicit) {
526ab47a55734 (John McCall              2011-10-25 17:37:35 +0000  1500)   if (checkPlaceholderForOverload(*this, From))
526ab47a55734 (John McCall              2011-10-25 17:37:35 +0000  1501)     return ExprError();
526ab47a55734 (John McCall              2011-10-25 17:37:35 +0000  1502) 
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  1503)   // Objective-C ARC: Determine whether we will allow the writeback conversion.
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  1504)   bool AllowObjCWritebackConversion
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  1505)     = getLangOpts().ObjCAutoRefCount &&
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  1506)       (Action == AA_Passing || Action == AA_Sending);
fa98390b3c314 (Erik Pilkington          2018-10-30 20:31:30 +0000  1507)   if (getLangOpts().ObjC)
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  1508)     CheckObjCBridgeRelatedConversions(From->getBeginLoc(), ToType,
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  1509)                                       From->getType(), From);
052dbe226cb35 (Richard Smith            2020-09-03 15:33:07 -0700  1510)   ImplicitConversionSequence ICS = ::TryImplicitConversion(
052dbe226cb35 (Richard Smith            2020-09-03 15:33:07 -0700  1511)       *this, From, ToType,
052dbe226cb35 (Richard Smith            2020-09-03 15:33:07 -0700  1512)       /*SuppressUserConversions=*/false,
052dbe226cb35 (Richard Smith            2020-09-03 15:33:07 -0700  1513)       AllowExplicit ? AllowedExplicit::All : AllowedExplicit::None,
052dbe226cb35 (Richard Smith            2020-09-03 15:33:07 -0700  1514)       /*InOverloadResolution=*/false,
052dbe226cb35 (Richard Smith            2020-09-03 15:33:07 -0700  1515)       /*CStyle=*/false, AllowObjCWritebackConversion,
052dbe226cb35 (Richard Smith            2020-09-03 15:33:07 -0700  1516)       /*AllowObjCConversionOnExplicit=*/false);
ae4b5df81751e (Douglas Gregor           2010-04-16 22:27:05 +0000  1517)   return PerformImplicitConversion(From, ToType, ICS, Action);
ae4b5df81751e (Douglas Gregor           2010-04-16 22:27:05 +0000  1518) }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  1519) 
9fc8faf9e6197 (Adrian Prantl            2018-05-09 01:00:01 +0000  1520) /// Determine whether the conversion from FromType to ToType is a valid
3c4f8d2e96c4b (Richard Smith            2016-10-16 17:54:23 +0000  1521) /// conversion that strips "noexcept" or "noreturn" off the nested function
3c4f8d2e96c4b (Richard Smith            2016-10-16 17:54:23 +0000  1522) /// type.
3c4f8d2e96c4b (Richard Smith            2016-10-16 17:54:23 +0000  1523) bool Sema::IsFunctionConversion(QualType FromType, QualType ToType,
53e61b05cedec (Chandler Carruth         2011-06-18 01:19:03 +0000  1524)                                 QualType &ResultTy) {
40cb9ad391af6 (Douglas Gregor           2009-12-09 00:47:37 +0000  1525)   if (Context.hasSameUnqualifiedType(FromType, ToType))
40cb9ad391af6 (Douglas Gregor           2009-12-09 00:47:37 +0000  1526)     return false;
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  1527) 
991eb4b3191ae (John McCall              2010-12-21 00:44:39 +0000  1528)   // Permit the conversion F(t __attribute__((noreturn))) -> F(t)
3c4f8d2e96c4b (Richard Smith            2016-10-16 17:54:23 +0000  1529)   //                    or F(t noexcept) -> F(t)
991eb4b3191ae (John McCall              2010-12-21 00:44:39 +0000  1530)   // where F adds one of the following at most once:
991eb4b3191ae (John McCall              2010-12-21 00:44:39 +0000  1531)   //   - a pointer
991eb4b3191ae (John McCall              2010-12-21 00:44:39 +0000  1532)   //   - a member pointer
991eb4b3191ae (John McCall              2010-12-21 00:44:39 +0000  1533)   //   - a block pointer
eb7ef2e1cae45 (Richard Smith            2016-10-20 21:53:09 +0000  1534)   // Changes here need matching changes in FindCompositePointerType.
991eb4b3191ae (John McCall              2010-12-21 00:44:39 +0000  1535)   CanQualType CanTo = Context.getCanonicalType(ToType);
991eb4b3191ae (John McCall              2010-12-21 00:44:39 +0000  1536)   CanQualType CanFrom = Context.getCanonicalType(FromType);
991eb4b3191ae (John McCall              2010-12-21 00:44:39 +0000  1537)   Type::TypeClass TyClass = CanTo->getTypeClass();
991eb4b3191ae (John McCall              2010-12-21 00:44:39 +0000  1538)   if (TyClass != CanFrom->getTypeClass()) return false;
991eb4b3191ae (John McCall              2010-12-21 00:44:39 +0000  1539)   if (TyClass != Type::FunctionProto && TyClass != Type::FunctionNoProto) {
991eb4b3191ae (John McCall              2010-12-21 00:44:39 +0000  1540)     if (TyClass == Type::Pointer) {
ed3b68e0dc3c0 (Simon Pilgrim            2019-10-02 14:02:27 +0000  1541)       CanTo = CanTo.castAs<PointerType>()->getPointeeType();
ed3b68e0dc3c0 (Simon Pilgrim            2019-10-02 14:02:27 +0000  1542)       CanFrom = CanFrom.castAs<PointerType>()->getPointeeType();
991eb4b3191ae (John McCall              2010-12-21 00:44:39 +0000  1543)     } else if (TyClass == Type::BlockPointer) {
ed3b68e0dc3c0 (Simon Pilgrim            2019-10-02 14:02:27 +0000  1544)       CanTo = CanTo.castAs<BlockPointerType>()->getPointeeType();
ed3b68e0dc3c0 (Simon Pilgrim            2019-10-02 14:02:27 +0000  1545)       CanFrom = CanFrom.castAs<BlockPointerType>()->getPointeeType();
991eb4b3191ae (John McCall              2010-12-21 00:44:39 +0000  1546)     } else if (TyClass == Type::MemberPointer) {
ed3b68e0dc3c0 (Simon Pilgrim            2019-10-02 14:02:27 +0000  1547)       auto ToMPT = CanTo.castAs<MemberPointerType>();
ed3b68e0dc3c0 (Simon Pilgrim            2019-10-02 14:02:27 +0000  1548)       auto FromMPT = CanFrom.castAs<MemberPointerType>();
eb7ef2e1cae45 (Richard Smith            2016-10-20 21:53:09 +0000  1549)       // A function pointer conversion cannot change the class of the function.
eb7ef2e1cae45 (Richard Smith            2016-10-20 21:53:09 +0000  1550)       if (ToMPT->getClass() != FromMPT->getClass())
eb7ef2e1cae45 (Richard Smith            2016-10-20 21:53:09 +0000  1551)         return false;
eb7ef2e1cae45 (Richard Smith            2016-10-20 21:53:09 +0000  1552)       CanTo = ToMPT->getPointeeType();
eb7ef2e1cae45 (Richard Smith            2016-10-20 21:53:09 +0000  1553)       CanFrom = FromMPT->getPointeeType();
991eb4b3191ae (John McCall              2010-12-21 00:44:39 +0000  1554)     } else {
991eb4b3191ae (John McCall              2010-12-21 00:44:39 +0000  1555)       return false;
991eb4b3191ae (John McCall              2010-12-21 00:44:39 +0000  1556)     }
991eb4b3191ae (John McCall              2010-12-21 00:44:39 +0000  1557) 
991eb4b3191ae (John McCall              2010-12-21 00:44:39 +0000  1558)     TyClass = CanTo->getTypeClass();
991eb4b3191ae (John McCall              2010-12-21 00:44:39 +0000  1559)     if (TyClass != CanFrom->getTypeClass()) return false;
991eb4b3191ae (John McCall              2010-12-21 00:44:39 +0000  1560)     if (TyClass != Type::FunctionProto && TyClass != Type::FunctionNoProto)
991eb4b3191ae (John McCall              2010-12-21 00:44:39 +0000  1561)       return false;
991eb4b3191ae (John McCall              2010-12-21 00:44:39 +0000  1562)   }
991eb4b3191ae (John McCall              2010-12-21 00:44:39 +0000  1563) 
3c4f8d2e96c4b (Richard Smith            2016-10-16 17:54:23 +0000  1564)   const auto *FromFn = cast<FunctionType>(CanFrom);
3c4f8d2e96c4b (Richard Smith            2016-10-16 17:54:23 +0000  1565)   FunctionType::ExtInfo FromEInfo = FromFn->getExtInfo();
3c4f8d2e96c4b (Richard Smith            2016-10-16 17:54:23 +0000  1566) 
6f42740707bb0 (Richard Smith            2016-10-20 00:01:36 +0000  1567)   const auto *ToFn = cast<FunctionType>(CanTo);
3c4f8d2e96c4b (Richard Smith            2016-10-16 17:54:23 +0000  1568)   FunctionType::ExtInfo ToEInfo = ToFn->getExtInfo();
3c4f8d2e96c4b (Richard Smith            2016-10-16 17:54:23 +0000  1569) 
3c4f8d2e96c4b (Richard Smith            2016-10-16 17:54:23 +0000  1570)   bool Changed = false;
3c4f8d2e96c4b (Richard Smith            2016-10-16 17:54:23 +0000  1571) 
3c4f8d2e96c4b (Richard Smith            2016-10-16 17:54:23 +0000  1572)   // Drop 'noreturn' if not present in target type.
3c4f8d2e96c4b (Richard Smith            2016-10-16 17:54:23 +0000  1573)   if (FromEInfo.getNoReturn() && !ToEInfo.getNoReturn()) {
3c4f8d2e96c4b (Richard Smith            2016-10-16 17:54:23 +0000  1574)     FromFn = Context.adjustFunctionType(FromFn, FromEInfo.withNoReturn(false));
3c4f8d2e96c4b (Richard Smith            2016-10-16 17:54:23 +0000  1575)     Changed = true;
3c4f8d2e96c4b (Richard Smith            2016-10-16 17:54:23 +0000  1576)   }
3c4f8d2e96c4b (Richard Smith            2016-10-16 17:54:23 +0000  1577) 
3c4f8d2e96c4b (Richard Smith            2016-10-16 17:54:23 +0000  1578)   // Drop 'noexcept' if not present in target type.
3c4f8d2e96c4b (Richard Smith            2016-10-16 17:54:23 +0000  1579)   if (const auto *FromFPT = dyn_cast<FunctionProtoType>(FromFn)) {
6f42740707bb0 (Richard Smith            2016-10-20 00:01:36 +0000  1580)     const auto *ToFPT = cast<FunctionProtoType>(ToFn);
eaf11ad709046 (Richard Smith            2018-05-03 03:58:32 +0000  1581)     if (FromFPT->isNothrow() && !ToFPT->isNothrow()) {
3c4f8d2e96c4b (Richard Smith            2016-10-16 17:54:23 +0000  1582)       FromFn = cast<FunctionType>(
8c85bca5a5db8 (Stephan Bergmann         2018-01-05 07:57:12 +0000  1583)           Context.getFunctionTypeWithExceptionSpec(QualType(FromFPT, 0),
8c85bca5a5db8 (Stephan Bergmann         2018-01-05 07:57:12 +0000  1584)                                                    EST_None)
3c4f8d2e96c4b (Richard Smith            2016-10-16 17:54:23 +0000  1585)                  .getTypePtr());
3c4f8d2e96c4b (Richard Smith            2016-10-16 17:54:23 +0000  1586)       Changed = true;
3c4f8d2e96c4b (Richard Smith            2016-10-16 17:54:23 +0000  1587)     }
55ebd6cc26422 (Artem Belevich           2018-04-03 18:29:31 +0000  1588) 
98a49337be3fd (Akira Hatanaka           2017-09-22 00:41:05 +0000  1589)     // Convert FromFPT's ExtParameterInfo if necessary. The conversion is valid
98a49337be3fd (Akira Hatanaka           2017-09-22 00:41:05 +0000  1590)     // only if the ExtParameterInfo lists of the two function prototypes can be
98a49337be3fd (Akira Hatanaka           2017-09-22 00:41:05 +0000  1591)     // merged and the merged list is identical to ToFPT's ExtParameterInfo list.
98a49337be3fd (Akira Hatanaka           2017-09-22 00:41:05 +0000  1592)     SmallVector<FunctionProtoType::ExtParameterInfo, 4> NewParamInfos;
98a49337be3fd (Akira Hatanaka           2017-09-22 00:41:05 +0000  1593)     bool CanUseToFPT, CanUseFromFPT;
98a49337be3fd (Akira Hatanaka           2017-09-22 00:41:05 +0000  1594)     if (Context.mergeExtParameterInfo(ToFPT, FromFPT, CanUseToFPT,
98a49337be3fd (Akira Hatanaka           2017-09-22 00:41:05 +0000  1595)                                       CanUseFromFPT, NewParamInfos) &&
98a49337be3fd (Akira Hatanaka           2017-09-22 00:41:05 +0000  1596)         CanUseToFPT && !CanUseFromFPT) {
98a49337be3fd (Akira Hatanaka           2017-09-22 00:41:05 +0000  1597)       FunctionProtoType::ExtProtoInfo ExtInfo = FromFPT->getExtProtoInfo();
98a49337be3fd (Akira Hatanaka           2017-09-22 00:41:05 +0000  1598)       ExtInfo.ExtParameterInfos =
98a49337be3fd (Akira Hatanaka           2017-09-22 00:41:05 +0000  1599)           NewParamInfos.empty() ? nullptr : NewParamInfos.data();
98a49337be3fd (Akira Hatanaka           2017-09-22 00:41:05 +0000  1600)       QualType QT = Context.getFunctionType(FromFPT->getReturnType(),
98a49337be3fd (Akira Hatanaka           2017-09-22 00:41:05 +0000  1601)                                             FromFPT->getParamTypes(), ExtInfo);
98a49337be3fd (Akira Hatanaka           2017-09-22 00:41:05 +0000  1602)       FromFn = QT->getAs<FunctionType>();
98a49337be3fd (Akira Hatanaka           2017-09-22 00:41:05 +0000  1603)       Changed = true;
98a49337be3fd (Akira Hatanaka           2017-09-22 00:41:05 +0000  1604)     }
3c4f8d2e96c4b (Richard Smith            2016-10-16 17:54:23 +0000  1605)   }
3c4f8d2e96c4b (Richard Smith            2016-10-16 17:54:23 +0000  1606) 
3c4f8d2e96c4b (Richard Smith            2016-10-16 17:54:23 +0000  1607)   if (!Changed)
3c4f8d2e96c4b (Richard Smith            2016-10-16 17:54:23 +0000  1608)     return false;
991eb4b3191ae (John McCall              2010-12-21 00:44:39 +0000  1609) 
991eb4b3191ae (John McCall              2010-12-21 00:44:39 +0000  1610)   assert(QualType(FromFn, 0).isCanonical());
991eb4b3191ae (John McCall              2010-12-21 00:44:39 +0000  1611)   if (QualType(FromFn, 0) != CanTo) return false;
40cb9ad391af6 (Douglas Gregor           2009-12-09 00:47:37 +0000  1612) 
991eb4b3191ae (John McCall              2010-12-21 00:44:39 +0000  1613)   ResultTy = ToType;
40cb9ad391af6 (Douglas Gregor           2009-12-09 00:47:37 +0000  1614)   return true;
40cb9ad391af6 (Douglas Gregor           2009-12-09 00:47:37 +0000  1615) }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  1616) 
9fc8faf9e6197 (Adrian Prantl            2018-05-09 01:00:01 +0000  1617) /// Determine whether the conversion from FromType to ToType is a valid
4618868a7d0de (Douglas Gregor           2010-05-18 22:42:18 +0000  1618) /// vector conversion.
4618868a7d0de (Douglas Gregor           2010-05-18 22:42:18 +0000  1619) ///
4618868a7d0de (Douglas Gregor           2010-05-18 22:42:18 +0000  1620) /// \param ICK Will be set to the vector conversion kind, if this is a vector
4618868a7d0de (Douglas Gregor           2010-05-18 22:42:18 +0000  1621) /// conversion.
9b595db16d614 (John McCall              2014-02-04 23:58:19 +0000  1622) static bool IsVectorConversion(Sema &S, QualType FromType,
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  1623)                                QualType ToType, ImplicitConversionKind &ICK) {
4618868a7d0de (Douglas Gregor           2010-05-18 22:42:18 +0000  1624)   // We need at least one of these types to be a vector type to have a vector
4618868a7d0de (Douglas Gregor           2010-05-18 22:42:18 +0000  1625)   // conversion.
4618868a7d0de (Douglas Gregor           2010-05-18 22:42:18 +0000  1626)   if (!ToType->isVectorType() && !FromType->isVectorType())
4618868a7d0de (Douglas Gregor           2010-05-18 22:42:18 +0000  1627)     return false;
4618868a7d0de (Douglas Gregor           2010-05-18 22:42:18 +0000  1628) 
4618868a7d0de (Douglas Gregor           2010-05-18 22:42:18 +0000  1629)   // Identical types require no conversions.
9b595db16d614 (John McCall              2014-02-04 23:58:19 +0000  1630)   if (S.Context.hasSameUnqualifiedType(FromType, ToType))
4618868a7d0de (Douglas Gregor           2010-05-18 22:42:18 +0000  1631)     return false;
4618868a7d0de (Douglas Gregor           2010-05-18 22:42:18 +0000  1632) 
4618868a7d0de (Douglas Gregor           2010-05-18 22:42:18 +0000  1633)   // There are no conversions between extended vector types, only identity.
4618868a7d0de (Douglas Gregor           2010-05-18 22:42:18 +0000  1634)   if (ToType->isExtVectorType()) {
4618868a7d0de (Douglas Gregor           2010-05-18 22:42:18 +0000  1635)     // There are no conversions between extended vector types other than the
4618868a7d0de (Douglas Gregor           2010-05-18 22:42:18 +0000  1636)     // identity conversion.
4618868a7d0de (Douglas Gregor           2010-05-18 22:42:18 +0000  1637)     if (FromType->isExtVectorType())
4618868a7d0de (Douglas Gregor           2010-05-18 22:42:18 +0000  1638)       return false;
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  1639) 
4618868a7d0de (Douglas Gregor           2010-05-18 22:42:18 +0000  1640)     // Vector splat from any arithmetic type to a vector.
a3208f9e7c5d9 (Douglas Gregor           2010-06-22 23:41:02 +0000  1641)     if (FromType->isArithmeticType()) {
4618868a7d0de (Douglas Gregor           2010-05-18 22:42:18 +0000  1642)       ICK = ICK_Vector_Splat;
4618868a7d0de (Douglas Gregor           2010-05-18 22:42:18 +0000  1643)       return true;
4618868a7d0de (Douglas Gregor           2010-05-18 22:42:18 +0000  1644)     }
4618868a7d0de (Douglas Gregor           2010-05-18 22:42:18 +0000  1645)   }
59e8b3bd7bf2c (Douglas Gregor           2010-08-06 10:14:59 +0000  1646) 
23a96b84a8d98 (Joe Ellis                2020-11-17 14:34:31 +0000  1647)   if (ToType->isSizelessBuiltinType() || FromType->isSizelessBuiltinType())
23a96b84a8d98 (Joe Ellis                2020-11-17 14:34:31 +0000  1648)     if (S.Context.areCompatibleSveTypes(FromType, ToType) ||
23a96b84a8d98 (Joe Ellis                2020-11-17 14:34:31 +0000  1649)         S.Context.areLaxCompatibleSveTypes(FromType, ToType)) {
23a96b84a8d98 (Joe Ellis                2020-11-17 14:34:31 +0000  1650)       ICK = ICK_SVE_Vector_Conversion;
23a96b84a8d98 (Joe Ellis                2020-11-17 14:34:31 +0000  1651)       return true;
23a96b84a8d98 (Joe Ellis                2020-11-17 14:34:31 +0000  1652)     }
feed5a7239d8e (Cullen Rhodes            2020-08-11 13:04:21 +0000  1653) 
59e8b3bd7bf2c (Douglas Gregor           2010-08-06 10:14:59 +0000  1654)   // We can perform the conversion between vector types in the following cases:
59e8b3bd7bf2c (Douglas Gregor           2010-08-06 10:14:59 +0000  1655)   // 1)vector types are equivalent AltiVec and GCC vector types
59e8b3bd7bf2c (Douglas Gregor           2010-08-06 10:14:59 +0000  1656)   // 2)lax vector conversions are permitted and the vector types are of the
59e8b3bd7bf2c (Douglas Gregor           2010-08-06 10:14:59 +0000  1657)   //   same size
ada01d1b86976 (Simon Tatham             2020-01-15 14:07:04 +0000  1658)   // 3)the destination type does not have the ARM MVE strict-polymorphism
ada01d1b86976 (Simon Tatham             2020-01-15 14:07:04 +0000  1659)   //   attribute, which inhibits lax vector conversion for overload resolution
ada01d1b86976 (Simon Tatham             2020-01-15 14:07:04 +0000  1660)   //   only
59e8b3bd7bf2c (Douglas Gregor           2010-08-06 10:14:59 +0000  1661)   if (ToType->isVectorType() && FromType->isVectorType()) {
9b595db16d614 (John McCall              2014-02-04 23:58:19 +0000  1662)     if (S.Context.areCompatibleVectorTypes(FromType, ToType) ||
ada01d1b86976 (Simon Tatham             2020-01-15 14:07:04 +0000  1663)         (S.isLaxVectorConversion(FromType, ToType) &&
ada01d1b86976 (Simon Tatham             2020-01-15 14:07:04 +0000  1664)          !ToType->hasAttr(attr::ArmMveStrictPolymorphism))) {
59e8b3bd7bf2c (Douglas Gregor           2010-08-06 10:14:59 +0000  1665)       ICK = ICK_Vector_Conversion;
59e8b3bd7bf2c (Douglas Gregor           2010-08-06 10:14:59 +0000  1666)       return true;
59e8b3bd7bf2c (Douglas Gregor           2010-08-06 10:14:59 +0000  1667)     }
4618868a7d0de (Douglas Gregor           2010-05-18 22:42:18 +0000  1668)   }
59e8b3bd7bf2c (Douglas Gregor           2010-08-06 10:14:59 +0000  1669) 
4618868a7d0de (Douglas Gregor           2010-05-18 22:42:18 +0000  1670)   return false;
4618868a7d0de (Douglas Gregor           2010-05-18 22:42:18 +0000  1671) }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  1672) 
f9e36cccb5910 (Douglas Gregor           2012-04-12 20:48:09 +0000  1673) static bool tryAtomicConversion(Sema &S, Expr *From, QualType ToType,
f9e36cccb5910 (Douglas Gregor           2012-04-12 20:48:09 +0000  1674)                                 bool InOverloadResolution,
f9e36cccb5910 (Douglas Gregor           2012-04-12 20:48:09 +0000  1675)                                 StandardConversionSequence &SCS,
f9e36cccb5910 (Douglas Gregor           2012-04-12 20:48:09 +0000  1676)                                 bool CStyle);
4546181e12c89 (George Burgess IV        2015-10-11 20:13:20 +0000  1677) 
26bee0b326227 (Douglas Gregor           2008-10-31 16:23:19 +0000  1678) /// IsStandardConversion - Determines whether there is a standard
26bee0b326227 (Douglas Gregor           2008-10-31 16:23:19 +0000  1679) /// conversion sequence (C++ [conv], C++ [over.ics.scs]) from the
26bee0b326227 (Douglas Gregor           2008-10-31 16:23:19 +0000  1680) /// expression From to the type ToType. Standard conversion sequences
26bee0b326227 (Douglas Gregor           2008-10-31 16:23:19 +0000  1681) /// only consider non-class types; for conversions that involve class
26bee0b326227 (Douglas Gregor           2008-10-31 16:23:19 +0000  1682) /// types, use TryImplicitConversion. If a conversion exists, SCS will
26bee0b326227 (Douglas Gregor           2008-10-31 16:23:19 +0000  1683) /// contain the standard conversion sequence required to perform this
26bee0b326227 (Douglas Gregor           2008-10-31 16:23:19 +0000  1684) /// conversion and this routine will return true. Otherwise, this
26bee0b326227 (Douglas Gregor           2008-10-31 16:23:19 +0000  1685) /// routine will return false and the value of SCS is unspecified.
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  1686) static bool IsStandardConversion(Sema &S, Expr* From, QualType ToType,
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  1687)                                  bool InOverloadResolution,
582813596a100 (Douglas Gregor           2011-01-27 00:58:17 +0000  1688)                                  StandardConversionSequence &SCS,
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  1689)                                  bool CStyle,
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  1690)                                  bool AllowObjCWritebackConversion) {
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1691)   QualType FromType = From->getType();
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  1692) 
26bee0b326227 (Douglas Gregor           2008-10-31 16:23:19 +0000  1693)   // Standard conversions (C++ [conv])
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  1694)   SCS.setAsIdentityConversion();
47d3f2742a3b6 (Douglas Gregor           2008-12-19 17:40:08 +0000  1695)   SCS.IncompatibleObjC = false;
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000  1696)   SCS.setFromType(FromType);
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000  1697)   SCS.CopyConstructor = nullptr;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1698) 
4e5cbdcbed0b0 (Douglas Gregor           2009-02-11 23:02:49 +0000  1699)   // There are no standard conversions for class types in C++, so
4546181e12c89 (George Burgess IV        2015-10-11 20:13:20 +0000  1700)   // abort early. When overloading in C, however, we do permit them.
4546181e12c89 (George Burgess IV        2015-10-11 20:13:20 +0000  1701)   if (S.getLangOpts().CPlusPlus &&
4546181e12c89 (George Burgess IV        2015-10-11 20:13:20 +0000  1702)       (FromType->isRecordType() || ToType->isRecordType()))
4546181e12c89 (George Burgess IV        2015-10-11 20:13:20 +0000  1703)     return false;
4e5cbdcbed0b0 (Douglas Gregor           2009-02-11 23:02:49 +0000  1704) 
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1705)   // The first conversion can be an lvalue-to-rvalue conversion,
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1706)   // array-to-pointer conversion, or function-to-pointer conversion
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1707)   // (C++ 4p1).
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1708) 
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  1709)   if (FromType == S.Context.OverloadTy) {
980fb16f9a05f (Douglas Gregor           2010-04-29 18:24:40 +0000  1710)     DeclAccessPair AccessPair;
980fb16f9a05f (Douglas Gregor           2010-04-29 18:24:40 +0000  1711)     if (FunctionDecl *Fn
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  1712)           = S.ResolveAddressOfOverloadedFunction(From, ToType, false,
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  1713)                                                  AccessPair)) {
980fb16f9a05f (Douglas Gregor           2010-04-29 18:24:40 +0000  1714)       // We were able to resolve the address of the overloaded function,
980fb16f9a05f (Douglas Gregor           2010-04-29 18:24:40 +0000  1715)       // so we can convert to the type of that function.
980fb16f9a05f (Douglas Gregor           2010-04-29 18:24:40 +0000  1716)       FromType = Fn->getType();
c3ad3bab61919 (Ehsan Akhgari            2014-07-22 20:20:14 +0000  1717)       SCS.setFromType(FromType);
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000  1718) 
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000  1719)       // we can sometimes resolve &foo<int> regardless of ToType, so check
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000  1720)       // if the type matches (identity) or we are converting to bool
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000  1721)       if (!S.Context.hasSameUnqualifiedType(
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000  1722)                       S.ExtractUnqualifiedFunctionType(ToType), FromType)) {
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000  1723)         QualType resultTy;
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000  1724)         // if the function type matches except for [[noreturn]], it's ok
3c4f8d2e96c4b (Richard Smith            2016-10-16 17:54:23 +0000  1725)         if (!S.IsFunctionConversion(FromType,
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000  1726)               S.ExtractUnqualifiedFunctionType(ToType), resultTy))
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  1727)           // otherwise, only a boolean conversion is standard
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  1728)           if (!ToType->isBooleanType())
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  1729)             return false;
980fb16f9a05f (Douglas Gregor           2010-04-29 18:24:40 +0000  1730)       }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  1731) 
ffce245700488 (Chandler Carruth         2011-03-29 08:08:18 +0000  1732)       // Check if the "from" expression is taking the address of an overloaded
ffce245700488 (Chandler Carruth         2011-03-29 08:08:18 +0000  1733)       // function and recompute the FromType accordingly. Take advantage of the
ffce245700488 (Chandler Carruth         2011-03-29 08:08:18 +0000  1734)       // fact that non-static member functions *must* have such an address-of
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  1735)       // expression.
ffce245700488 (Chandler Carruth         2011-03-29 08:08:18 +0000  1736)       CXXMethodDecl *Method = dyn_cast<CXXMethodDecl>(Fn);
ffce245700488 (Chandler Carruth         2011-03-29 08:08:18 +0000  1737)       if (Method && !Method->isStatic()) {
ffce245700488 (Chandler Carruth         2011-03-29 08:08:18 +0000  1738)         assert(isa<UnaryOperator>(From->IgnoreParens()) &&
ffce245700488 (Chandler Carruth         2011-03-29 08:08:18 +0000  1739)                "Non-unary operator on non-static member address");
ffce245700488 (Chandler Carruth         2011-03-29 08:08:18 +0000  1740)         assert(cast<UnaryOperator>(From->IgnoreParens())->getOpcode()
ffce245700488 (Chandler Carruth         2011-03-29 08:08:18 +0000  1741)                == UO_AddrOf &&
ffce245700488 (Chandler Carruth         2011-03-29 08:08:18 +0000  1742)                "Non-address-of operator on non-static member address");
ffce245700488 (Chandler Carruth         2011-03-29 08:08:18 +0000  1743)         const Type *ClassType
ffce245700488 (Chandler Carruth         2011-03-29 08:08:18 +0000  1744)           = S.Context.getTypeDeclType(Method->getParent()).getTypePtr();
ffce245700488 (Chandler Carruth         2011-03-29 08:08:18 +0000  1745)         FromType = S.Context.getMemberPointerType(FromType, ClassType);
7750f7694c26a (Chandler Carruth         2011-03-29 18:38:10 +0000  1746)       } else if (isa<UnaryOperator>(From->IgnoreParens())) {
7750f7694c26a (Chandler Carruth         2011-03-29 18:38:10 +0000  1747)         assert(cast<UnaryOperator>(From->IgnoreParens())->getOpcode() ==
7750f7694c26a (Chandler Carruth         2011-03-29 18:38:10 +0000  1748)                UO_AddrOf &&
ffce245700488 (Chandler Carruth         2011-03-29 08:08:18 +0000  1749)                "Non-address-of operator for overloaded function expression");
ffce245700488 (Chandler Carruth         2011-03-29 08:08:18 +0000  1750)         FromType = S.Context.getPointerType(FromType);
ffce245700488 (Chandler Carruth         2011-03-29 08:08:18 +0000  1751)       }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  1752) 
980fb16f9a05f (Douglas Gregor           2010-04-29 18:24:40 +0000  1753)       // Check that we've computed the proper type after overload resolution.
9095e5bf7e4fc (Richard Smith            2016-11-01 01:31:23 +0000  1754)       // FIXME: FixOverloadedFunctionReference has side-effects; we shouldn't
9095e5bf7e4fc (Richard Smith            2016-11-01 01:31:23 +0000  1755)       // be calling it from within an NDEBUG block.
ffce245700488 (Chandler Carruth         2011-03-29 08:08:18 +0000  1756)       assert(S.Context.hasSameType(
ffce245700488 (Chandler Carruth         2011-03-29 08:08:18 +0000  1757)         FromType,
ffce245700488 (Chandler Carruth         2011-03-29 08:08:18 +0000  1758)         S.FixOverloadedFunctionReference(From, AccessPair, Fn)->getType()));
980fb16f9a05f (Douglas Gregor           2010-04-29 18:24:40 +0000  1759)     } else {
980fb16f9a05f (Douglas Gregor           2010-04-29 18:24:40 +0000  1760)       return false;
980fb16f9a05f (Douglas Gregor           2010-04-29 18:24:40 +0000  1761)     }
ba37e1eb49c41 (Anders Carlsson          2010-11-04 05:28:09 +0000  1762)   }
154a2fd3cb187 (John McCall              2011-08-30 00:57:29 +0000  1763)   // Lvalue-to-rvalue conversion (C++11 4.1):
154a2fd3cb187 (John McCall              2011-08-30 00:57:29 +0000  1764)   //   A glvalue (3.10) of a non-function, non-array type T can
154a2fd3cb187 (John McCall              2011-08-30 00:57:29 +0000  1765)   //   be converted to a prvalue.
154a2fd3cb187 (John McCall              2011-08-30 00:57:29 +0000  1766)   bool argIsLValue = From->isGLValue();
086a464e24de0 (John McCall              2010-11-24 05:12:34 +0000  1767)   if (argIsLValue &&
cd695e500de7e (Douglas Gregor           2008-11-10 20:40:00 +0000  1768)       !FromType->isFunctionType() && !FromType->isArrayType() &&
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  1769)       S.Context.getCanonicalType(FromType) != S.Context.OverloadTy) {
26bee0b326227 (Douglas Gregor           2008-10-31 16:23:19 +0000  1770)     SCS.First = ICK_Lvalue_To_Rvalue;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1771) 
c79862f017e37 (Douglas Gregor           2012-04-12 17:51:55 +0000  1772)     // C11 6.3.2.1p2:
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  1773)     //   ... if the lvalue has atomic type, the value has the non-atomic version
c79862f017e37 (Douglas Gregor           2012-04-12 17:51:55 +0000  1774)     //   of the type of the lvalue ...
c79862f017e37 (Douglas Gregor           2012-04-12 17:51:55 +0000  1775)     if (const AtomicType *Atomic = FromType->getAs<AtomicType>())
c79862f017e37 (Douglas Gregor           2012-04-12 17:51:55 +0000  1776)       FromType = Atomic->getValueType();
c79862f017e37 (Douglas Gregor           2012-04-12 17:51:55 +0000  1777) 
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1778)     // If T is a non-class type, the type of the rvalue is the
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1779)     // cv-unqualified version of T. Otherwise, the type of the rvalue
4e5cbdcbed0b0 (Douglas Gregor           2009-02-11 23:02:49 +0000  1780)     // is T (C++ 4.1p1). C++ can't get here with class types; in C, we
4e5cbdcbed0b0 (Douglas Gregor           2009-02-11 23:02:49 +0000  1781)     // just strip the qualifiers because they don't matter.
26bee0b326227 (Douglas Gregor           2008-10-31 16:23:19 +0000  1782)     FromType = FromType.getUnqualifiedType();
12b8ce168d4e3 (Mike Stump               2009-08-04 21:02:39 +0000  1783)   } else if (FromType->isArrayType()) {
12b8ce168d4e3 (Mike Stump               2009-08-04 21:02:39 +0000  1784)     // Array-to-pointer conversion (C++ 4.2)
26bee0b326227 (Douglas Gregor           2008-10-31 16:23:19 +0000  1785)     SCS.First = ICK_Array_To_Pointer;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1786) 
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1787)     // An lvalue or rvalue of type "array of N T" or "array of unknown
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1788)     // bound of T" can be converted to an rvalue of type "pointer to
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1789)     // T" (C++ 4.2p1).
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  1790)     FromType = S.Context.getArrayDecayedType(FromType);
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1791) 
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  1792)     if (S.IsStringLiteralToNonConstPointerConversion(From, ToType)) {
1121de36c26b9 (Ismail Pazarbasi         2014-01-17 21:08:52 +0000  1793)       // This conversion is deprecated in C++03 (D.4)
e489a7d3d3972 (Douglas Gregor           2010-02-28 18:30:25 +0000  1794)       SCS.DeprecatedStringLiteralToCharPtr = true;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1795) 
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1796)       // For the purpose of ranking in overload resolution
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1797)       // (13.3.3.1.1), this conversion is considered an
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1798)       // array-to-pointer conversion followed by a qualification
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1799)       // conversion (4.4). (C++ 4.2p2)
26bee0b326227 (Douglas Gregor           2008-10-31 16:23:19 +0000  1800)       SCS.Second = ICK_Identity;
26bee0b326227 (Douglas Gregor           2008-10-31 16:23:19 +0000  1801)       SCS.Third = ICK_Qualification;
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  1802)       SCS.QualificationIncludesObjCLifetime = false;
3edc4d5ec3fdc (Douglas Gregor           2010-01-27 03:51:04 +0000  1803)       SCS.setAllToTypes(FromType);
26bee0b326227 (Douglas Gregor           2008-10-31 16:23:19 +0000  1804)       return true;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1805)     }
086a464e24de0 (John McCall              2010-11-24 05:12:34 +0000  1806)   } else if (FromType->isFunctionType() && argIsLValue) {
12b8ce168d4e3 (Mike Stump               2009-08-04 21:02:39 +0000  1807)     // Function-to-pointer conversion (C++ 4.3).
26bee0b326227 (Douglas Gregor           2008-10-31 16:23:19 +0000  1808)     SCS.First = ICK_Function_To_Pointer;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1809) 
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000  1810)     if (auto *DRE = dyn_cast<DeclRefExpr>(From->IgnoreParenCasts()))
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000  1811)       if (auto *FD = dyn_cast<FunctionDecl>(DRE->getDecl()))
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000  1812)         if (!S.checkAddressOfFunctionIsAvailable(FD))
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000  1813)           return false;
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000  1814) 
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1815)     // An lvalue of function type T can be converted to an rvalue of
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1816)     // type "pointer to T." The result is a pointer to the
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1817)     // function. (C++ 4.3p1).
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  1818)     FromType = S.Context.getPointerType(FromType);
12b8ce168d4e3 (Mike Stump               2009-08-04 21:02:39 +0000  1819)   } else {
12b8ce168d4e3 (Mike Stump               2009-08-04 21:02:39 +0000  1820)     // We don't require any conversions for the first step.
26bee0b326227 (Douglas Gregor           2008-10-31 16:23:19 +0000  1821)     SCS.First = ICK_Identity;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1822)   }
3edc4d5ec3fdc (Douglas Gregor           2010-01-27 03:51:04 +0000  1823)   SCS.setToType(0, FromType);
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1824) 
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1825)   // The second conversion can be an integral promotion, floating
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1826)   // point promotion, integral conversion, floating point conversion,
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1827)   // floating-integral conversion, pointer conversion,
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1828)   // pointer-to-member conversion, or boolean conversion (C++ 4p1).
4e5cbdcbed0b0 (Douglas Gregor           2009-02-11 23:02:49 +0000  1829)   // For overloading in C, this can also be a "compatible-type"
4e5cbdcbed0b0 (Douglas Gregor           2009-02-11 23:02:49 +0000  1830)   // conversion.
47d3f2742a3b6 (Douglas Gregor           2008-12-19 17:40:08 +0000  1831)   bool IncompatibleObjC = false;
4618868a7d0de (Douglas Gregor           2010-05-18 22:42:18 +0000  1832)   ImplicitConversionKind SecondICK = ICK_Identity;
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  1833)   if (S.Context.hasSameUnqualifiedType(FromType, ToType)) {
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1834)     // The unqualified versions of the types are the same: there's no
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1835)     // conversion to do.
26bee0b326227 (Douglas Gregor           2008-10-31 16:23:19 +0000  1836)     SCS.Second = ICK_Identity;
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  1837)   } else if (S.IsIntegralPromotion(From, FromType, ToType)) {
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  1838)     // Integral promotion (C++ 4.5).
26bee0b326227 (Douglas Gregor           2008-10-31 16:23:19 +0000  1839)     SCS.Second = ICK_Integral_Promotion;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1840)     FromType = ToType.getUnqualifiedType();
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  1841)   } else if (S.IsFloatingPointPromotion(FromType, ToType)) {
12b8ce168d4e3 (Mike Stump               2009-08-04 21:02:39 +0000  1842)     // Floating point promotion (C++ 4.6).
26bee0b326227 (Douglas Gregor           2008-10-31 16:23:19 +0000  1843)     SCS.Second = ICK_Floating_Promotion;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1844)     FromType = ToType.getUnqualifiedType();
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  1845)   } else if (S.IsComplexPromotion(FromType, ToType)) {
12b8ce168d4e3 (Mike Stump               2009-08-04 21:02:39 +0000  1846)     // Complex promotion (Clang extension)
78ca74d81d935 (Douglas Gregor           2009-02-12 00:15:05 +0000  1847)     SCS.Second = ICK_Complex_Promotion;
78ca74d81d935 (Douglas Gregor           2009-02-12 00:15:05 +0000  1848)     FromType = ToType.getUnqualifiedType();
8cb679e4e1e20 (John McCall              2010-11-15 09:13:47 +0000  1849)   } else if (ToType->isBooleanType() &&
8cb679e4e1e20 (John McCall              2010-11-15 09:13:47 +0000  1850)              (FromType->isArithmeticType() ||
8cb679e4e1e20 (John McCall              2010-11-15 09:13:47 +0000  1851)               FromType->isAnyPointerType() ||
8cb679e4e1e20 (John McCall              2010-11-15 09:13:47 +0000  1852)               FromType->isBlockPointerType() ||
9ce6dc9872be4 (Richard Smith            2020-02-11 06:09:18 -0800  1853)               FromType->isMemberPointerType())) {
8cb679e4e1e20 (John McCall              2010-11-15 09:13:47 +0000  1854)     // Boolean conversions (C++ 4.12).
8cb679e4e1e20 (John McCall              2010-11-15 09:13:47 +0000  1855)     SCS.Second = ICK_Boolean_Conversion;
8cb679e4e1e20 (John McCall              2010-11-15 09:13:47 +0000  1856)     FromType = S.Context.BoolTy;
0bf3140424a0a (Douglas Gregor           2010-10-08 23:50:27 +0000  1857)   } else if (FromType->isIntegralOrUnscopedEnumerationType() &&
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  1858)              ToType->isIntegralType(S.Context)) {
12b8ce168d4e3 (Mike Stump               2009-08-04 21:02:39 +0000  1859)     // Integral conversions (C++ 4.7).
26bee0b326227 (Douglas Gregor           2008-10-31 16:23:19 +0000  1860)     SCS.Second = ICK_Integral_Conversion;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1861)     FromType = ToType.getUnqualifiedType();
b8a98241fce39 (Richard Smith            2013-05-10 20:29:50 +0000  1862)   } else if (FromType->isAnyComplexType() && ToType->isAnyComplexType()) {
12b8ce168d4e3 (Mike Stump               2009-08-04 21:02:39 +0000  1863)     // Complex conversions (C99 6.3.1.6)
78ca74d81d935 (Douglas Gregor           2009-02-12 00:15:05 +0000  1864)     SCS.Second = ICK_Complex_Conversion;
78ca74d81d935 (Douglas Gregor           2009-02-12 00:15:05 +0000  1865)     FromType = ToType.getUnqualifiedType();
8cb679e4e1e20 (John McCall              2010-11-15 09:13:47 +0000  1866)   } else if ((FromType->isAnyComplexType() && ToType->isArithmeticType()) ||
8cb679e4e1e20 (John McCall              2010-11-15 09:13:47 +0000  1867)              (ToType->isAnyComplexType() && FromType->isArithmeticType())) {
8fa1e7eec4d0a (Chandler Carruth         2010-02-25 07:20:54 +0000  1868)     // Complex-real conversions (C99 6.3.1.7)
8fa1e7eec4d0a (Chandler Carruth         2010-02-25 07:20:54 +0000  1869)     SCS.Second = ICK_Complex_Real;
8fa1e7eec4d0a (Chandler Carruth         2010-02-25 07:20:54 +0000  1870)     FromType = ToType.getUnqualifiedType();
49b4d73451955 (Douglas Gregor           2010-06-22 23:07:26 +0000  1871)   } else if (FromType->isRealFloatingType() && ToType->isRealFloatingType()) {
bb1ea2d6139a7 (Nemanja Ivanovic         2016-05-09 08:52:33 +0000  1872)     // FIXME: disable conversions between long double and __float128 if
bb1ea2d6139a7 (Nemanja Ivanovic         2016-05-09 08:52:33 +0000  1873)     // their representation is different until there is back end support
bb1ea2d6139a7 (Nemanja Ivanovic         2016-05-09 08:52:33 +0000  1874)     // We of course allow this conversion if long double is really double.
ecd682bbf5e69 (Ties Stuij               2020-06-05 00:20:02 +0100  1875) 
ecd682bbf5e69 (Ties Stuij               2020-06-05 00:20:02 +0100  1876)     // Conversions between bfloat and other floats are not permitted.
ecd682bbf5e69 (Ties Stuij               2020-06-05 00:20:02 +0100  1877)     if (FromType == S.Context.BFloat16Ty || ToType == S.Context.BFloat16Ty)
ecd682bbf5e69 (Ties Stuij               2020-06-05 00:20:02 +0100  1878)       return false;
bb1ea2d6139a7 (Nemanja Ivanovic         2016-05-09 08:52:33 +0000  1879)     if (&S.Context.getFloatTypeSemantics(FromType) !=
bb1ea2d6139a7 (Nemanja Ivanovic         2016-05-09 08:52:33 +0000  1880)         &S.Context.getFloatTypeSemantics(ToType)) {
bb1ea2d6139a7 (Nemanja Ivanovic         2016-05-09 08:52:33 +0000  1881)       bool Float128AndLongDouble = ((FromType == S.Context.Float128Ty &&
bb1ea2d6139a7 (Nemanja Ivanovic         2016-05-09 08:52:33 +0000  1882)                                     ToType == S.Context.LongDoubleTy) ||
bb1ea2d6139a7 (Nemanja Ivanovic         2016-05-09 08:52:33 +0000  1883)                                    (FromType == S.Context.LongDoubleTy &&
bb1ea2d6139a7 (Nemanja Ivanovic         2016-05-09 08:52:33 +0000  1884)                                     ToType == S.Context.Float128Ty));
bb1ea2d6139a7 (Nemanja Ivanovic         2016-05-09 08:52:33 +0000  1885)       if (Float128AndLongDouble &&
980579504ae2d (Benjamin Kramer          2018-01-17 22:56:57 +0000  1886)           (&S.Context.getFloatTypeSemantics(S.Context.LongDoubleTy) ==
980579504ae2d (Benjamin Kramer          2018-01-17 22:56:57 +0000  1887)            &llvm::APFloat::PPCDoubleDouble()))
bb1ea2d6139a7 (Nemanja Ivanovic         2016-05-09 08:52:33 +0000  1888)         return false;
bb1ea2d6139a7 (Nemanja Ivanovic         2016-05-09 08:52:33 +0000  1889)     }
8fa1e7eec4d0a (Chandler Carruth         2010-02-25 07:20:54 +0000  1890)     // Floating point conversions (C++ 4.8).
8fa1e7eec4d0a (Chandler Carruth         2010-02-25 07:20:54 +0000  1891)     SCS.Second = ICK_Floating_Conversion;
8fa1e7eec4d0a (Chandler Carruth         2010-02-25 07:20:54 +0000  1892)     FromType = ToType.getUnqualifiedType();
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  1893)   } else if ((FromType->isRealFloatingType() &&
8cb679e4e1e20 (John McCall              2010-11-15 09:13:47 +0000  1894)               ToType->isIntegralType(S.Context)) ||
0bf3140424a0a (Douglas Gregor           2010-10-08 23:50:27 +0000  1895)              (FromType->isIntegralOrUnscopedEnumerationType() &&
49b4d73451955 (Douglas Gregor           2010-06-22 23:07:26 +0000  1896)               ToType->isRealFloatingType())) {
ecd682bbf5e69 (Ties Stuij               2020-06-05 00:20:02 +0100  1897)     // Conversions between bfloat and int are not permitted.
ecd682bbf5e69 (Ties Stuij               2020-06-05 00:20:02 +0100  1898)     if (FromType->isBFloat16Type() || ToType->isBFloat16Type())
ecd682bbf5e69 (Ties Stuij               2020-06-05 00:20:02 +0100  1899)       return false;
ecd682bbf5e69 (Ties Stuij               2020-06-05 00:20:02 +0100  1900) 
12b8ce168d4e3 (Mike Stump               2009-08-04 21:02:39 +0000  1901)     // Floating-integral conversions (C++ 4.9).
26bee0b326227 (Douglas Gregor           2008-10-31 16:23:19 +0000  1902)     SCS.Second = ICK_Floating_Integral;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1903)     FromType = ToType.getUnqualifiedType();
42455ea935b04 (Fariborz Jahanian        2011-02-12 19:07:46 +0000  1904)   } else if (S.IsBlockPointerConversion(FromType, ToType, FromType)) {
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  1905)     SCS.Second = ICK_Block_Pointer_Conversion;
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  1906)   } else if (AllowObjCWritebackConversion &&
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  1907)              S.isObjCWritebackConversion(FromType, ToType, FromType)) {
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  1908)     SCS.Second = ICK_Writeback_Conversion;
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  1909)   } else if (S.IsPointerConversion(From, FromType, ToType, InOverloadResolution,
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  1910)                                    FromType, IncompatibleObjC)) {
12b8ce168d4e3 (Mike Stump               2009-08-04 21:02:39 +0000  1911)     // Pointer conversions (C++ 4.10).
26bee0b326227 (Douglas Gregor           2008-10-31 16:23:19 +0000  1912)     SCS.Second = ICK_Pointer_Conversion;
47d3f2742a3b6 (Douglas Gregor           2008-12-19 17:40:08 +0000  1913)     SCS.IncompatibleObjC = IncompatibleObjC;
aec25847606fd (Douglas Gregor           2011-04-26 23:16:46 +0000  1914)     FromType = FromType.getUnqualifiedType();
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  1915)   } else if (S.IsMemberPointerConversion(From, FromType, ToType,
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  1916)                                          InOverloadResolution, FromType)) {
12b8ce168d4e3 (Mike Stump               2009-08-04 21:02:39 +0000  1917)     // Pointer to member conversions (4.11).
72b597d6b6ae7 (Sebastian Redl           2009-01-25 19:43:20 +0000  1918)     SCS.Second = ICK_Pointer_Member;
9b595db16d614 (John McCall              2014-02-04 23:58:19 +0000  1919)   } else if (IsVectorConversion(S, FromType, ToType, SecondICK)) {
4618868a7d0de (Douglas Gregor           2010-05-18 22:42:18 +0000  1920)     SCS.Second = SecondICK;
4618868a7d0de (Douglas Gregor           2010-05-18 22:42:18 +0000  1921)     FromType = ToType.getUnqualifiedType();
bbafb8a745736 (David Blaikie            2012-03-11 07:00:24 +0000  1922)   } else if (!S.getLangOpts().CPlusPlus &&
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  1923)              S.Context.typesAreCompatible(ToType, FromType)) {
12b8ce168d4e3 (Mike Stump               2009-08-04 21:02:39 +0000  1924)     // Compatible conversions (Clang extension for C function overloading)
4e5cbdcbed0b0 (Douglas Gregor           2009-02-11 23:02:49 +0000  1925)     SCS.Second = ICK_Compatible_Conversion;
4618868a7d0de (Douglas Gregor           2010-05-18 22:42:18 +0000  1926)     FromType = ToType.getUnqualifiedType();
16f92ce539d49 (Fariborz Jahanian        2011-03-23 19:50:54 +0000  1927)   } else if (IsTransparentUnionStandardConversion(S, From, ToType,
16f92ce539d49 (Fariborz Jahanian        2011-03-23 19:50:54 +0000  1928)                                              InOverloadResolution,
16f92ce539d49 (Fariborz Jahanian        2011-03-23 19:50:54 +0000  1929)                                              SCS, CStyle)) {
16f92ce539d49 (Fariborz Jahanian        2011-03-23 19:50:54 +0000  1930)     SCS.Second = ICK_TransparentUnionConversion;
16f92ce539d49 (Fariborz Jahanian        2011-03-23 19:50:54 +0000  1931)     FromType = ToType;
f9e36cccb5910 (Douglas Gregor           2012-04-12 20:48:09 +0000  1932)   } else if (tryAtomicConversion(S, From, ToType, InOverloadResolution, SCS,
f9e36cccb5910 (Douglas Gregor           2012-04-12 20:48:09 +0000  1933)                                  CStyle)) {
f9e36cccb5910 (Douglas Gregor           2012-04-12 20:48:09 +0000  1934)     // tryAtomicConversion has updated the standard conversion sequence
c79862f017e37 (Douglas Gregor           2012-04-12 17:51:55 +0000  1935)     // appropriately.
c79862f017e37 (Douglas Gregor           2012-04-12 17:51:55 +0000  1936)     return true;
4546181e12c89 (George Burgess IV        2015-10-11 20:13:20 +0000  1937)   } else if (ToType->isEventT() &&
259f9f4531e5c (Guy Benyei               2013-02-07 16:05:33 +0000  1938)              From->isIntegerConstantExpr(S.getASTContext()) &&
4546181e12c89 (George Burgess IV        2015-10-11 20:13:20 +0000  1939)              From->EvaluateKnownConstInt(S.getASTContext()) == 0) {
259f9f4531e5c (Guy Benyei               2013-02-07 16:05:33 +0000  1940)     SCS.Second = ICK_Zero_Event_Conversion;
259f9f4531e5c (Guy Benyei               2013-02-07 16:05:33 +0000  1941)     FromType = ToType;
89831421af27b (Egor Churaev             2016-12-23 14:55:49 +0000  1942)   } else if (ToType->isQueueT() &&
89831421af27b (Egor Churaev             2016-12-23 14:55:49 +0000  1943)              From->isIntegerConstantExpr(S.getASTContext()) &&
89831421af27b (Egor Churaev             2016-12-23 14:55:49 +0000  1944)              (From->EvaluateKnownConstInt(S.getASTContext()) == 0)) {
89831421af27b (Egor Churaev             2016-12-23 14:55:49 +0000  1945)     SCS.Second = ICK_Zero_Queue_Conversion;
89831421af27b (Egor Churaev             2016-12-23 14:55:49 +0000  1946)     FromType = ToType;
8ece3b6719948 (Neil Hickey              2019-07-16 14:57:32 +0000  1947)   } else if (ToType->isSamplerT() &&
8ece3b6719948 (Neil Hickey              2019-07-16 14:57:32 +0000  1948)              From->isIntegerConstantExpr(S.getASTContext())) {
8ece3b6719948 (Neil Hickey              2019-07-16 14:57:32 +0000  1949)     SCS.Second = ICK_Compatible_Conversion;
8ece3b6719948 (Neil Hickey              2019-07-16 14:57:32 +0000  1950)     FromType = ToType;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1951)   } else {
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1952)     // No second conversion required.
26bee0b326227 (Douglas Gregor           2008-10-31 16:23:19 +0000  1953)     SCS.Second = ICK_Identity;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1954)   }
3edc4d5ec3fdc (Douglas Gregor           2010-01-27 03:51:04 +0000  1955)   SCS.setToType(1, FromType);
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1956) 
eb7ef2e1cae45 (Richard Smith            2016-10-20 21:53:09 +0000  1957)   // The third conversion can be a function pointer conversion or a
eb7ef2e1cae45 (Richard Smith            2016-10-20 21:53:09 +0000  1958)   // qualification conversion (C++ [conv.fctptr], [conv.qual]).
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  1959)   bool ObjCLifetimeConversion;
eb7ef2e1cae45 (Richard Smith            2016-10-20 21:53:09 +0000  1960)   if (S.IsFunctionConversion(FromType, ToType, FromType)) {
eb7ef2e1cae45 (Richard Smith            2016-10-20 21:53:09 +0000  1961)     // Function pointer conversions (removing 'noexcept') including removal of
eb7ef2e1cae45 (Richard Smith            2016-10-20 21:53:09 +0000  1962)     // 'noreturn' (Clang extension).
eb7ef2e1cae45 (Richard Smith            2016-10-20 21:53:09 +0000  1963)     SCS.Third = ICK_Function_Conversion;
eb7ef2e1cae45 (Richard Smith            2016-10-20 21:53:09 +0000  1964)   } else if (S.IsQualificationConversion(FromType, ToType, CStyle,
eb7ef2e1cae45 (Richard Smith            2016-10-20 21:53:09 +0000  1965)                                          ObjCLifetimeConversion)) {
26bee0b326227 (Douglas Gregor           2008-10-31 16:23:19 +0000  1966)     SCS.Third = ICK_Qualification;
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  1967)     SCS.QualificationIncludesObjCLifetime = ObjCLifetimeConversion;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1968)     FromType = ToType;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1969)   } else {
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1970)     // No conversion required
26bee0b326227 (Douglas Gregor           2008-10-31 16:23:19 +0000  1971)     SCS.Third = ICK_Identity;
eb7ef2e1cae45 (Richard Smith            2016-10-20 21:53:09 +0000  1972)   }
26bee0b326227 (Douglas Gregor           2008-10-31 16:23:19 +0000  1973) 
eb7ef2e1cae45 (Richard Smith            2016-10-20 21:53:09 +0000  1974)   // C++ [over.best.ics]p6:
eb7ef2e1cae45 (Richard Smith            2016-10-20 21:53:09 +0000  1975)   //   [...] Any difference in top-level cv-qualification is
eb7ef2e1cae45 (Richard Smith            2016-10-20 21:53:09 +0000  1976)   //   subsumed by the initialization itself and does not constitute
eb7ef2e1cae45 (Richard Smith            2016-10-20 21:53:09 +0000  1977)   //   a conversion. [...]
eb7ef2e1cae45 (Richard Smith            2016-10-20 21:53:09 +0000  1978)   QualType CanonFrom = S.Context.getCanonicalType(FromType);
eb7ef2e1cae45 (Richard Smith            2016-10-20 21:53:09 +0000  1979)   QualType CanonTo = S.Context.getCanonicalType(ToType);
eb7ef2e1cae45 (Richard Smith            2016-10-20 21:53:09 +0000  1980)   if (CanonFrom.getLocalUnqualifiedType()
eb7ef2e1cae45 (Richard Smith            2016-10-20 21:53:09 +0000  1981)                                      == CanonTo.getLocalUnqualifiedType() &&
eb7ef2e1cae45 (Richard Smith            2016-10-20 21:53:09 +0000  1982)       CanonFrom.getLocalQualifiers() != CanonTo.getLocalQualifiers()) {
eb7ef2e1cae45 (Richard Smith            2016-10-20 21:53:09 +0000  1983)     FromType = ToType;
eb7ef2e1cae45 (Richard Smith            2016-10-20 21:53:09 +0000  1984)     CanonFrom = CanonTo;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1985)   }
eb7ef2e1cae45 (Richard Smith            2016-10-20 21:53:09 +0000  1986) 
3edc4d5ec3fdc (Douglas Gregor           2010-01-27 03:51:04 +0000  1987)   SCS.setToType(2, FromType);
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1988) 
4546181e12c89 (George Burgess IV        2015-10-11 20:13:20 +0000  1989)   if (CanonFrom == CanonTo)
4546181e12c89 (George Burgess IV        2015-10-11 20:13:20 +0000  1990)     return true;
4546181e12c89 (George Burgess IV        2015-10-11 20:13:20 +0000  1991) 
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  1992)   // If we have not converted the argument type to the parameter type,
4546181e12c89 (George Burgess IV        2015-10-11 20:13:20 +0000  1993)   // this is a bad conversion sequence, unless we're resolving an overload in C.
4546181e12c89 (George Burgess IV        2015-10-11 20:13:20 +0000  1994)   if (S.getLangOpts().CPlusPlus || !InOverloadResolution)
4546181e12c89 (George Burgess IV        2015-10-11 20:13:20 +0000  1995)     return false;
4546181e12c89 (George Burgess IV        2015-10-11 20:13:20 +0000  1996) 
4546181e12c89 (George Burgess IV        2015-10-11 20:13:20 +0000  1997)   ExprResult ER = ExprResult{From};
2099b54102e7d (George Burgess IV        2016-09-02 22:59:57 +0000  1998)   Sema::AssignConvertType Conv =
2099b54102e7d (George Burgess IV        2016-09-02 22:59:57 +0000  1999)       S.CheckSingleAssignmentConstraints(ToType, ER,
2099b54102e7d (George Burgess IV        2016-09-02 22:59:57 +0000  2000)                                          /*Diagnose=*/false,
2099b54102e7d (George Burgess IV        2016-09-02 22:59:57 +0000  2001)                                          /*DiagnoseCFAudited=*/false,
2099b54102e7d (George Burgess IV        2016-09-02 22:59:57 +0000  2002)                                          /*ConvertRHS=*/false);
6098fd1989f6b (George Burgess IV        2016-09-03 00:28:25 +0000  2003)   ImplicitConversionKind SecondConv;
2099b54102e7d (George Burgess IV        2016-09-02 22:59:57 +0000  2004)   switch (Conv) {
2099b54102e7d (George Burgess IV        2016-09-02 22:59:57 +0000  2005)   case Sema::Compatible:
6098fd1989f6b (George Burgess IV        2016-09-03 00:28:25 +0000  2006)     SecondConv = ICK_C_Only_Conversion;
2099b54102e7d (George Burgess IV        2016-09-02 22:59:57 +0000  2007)     break;
2099b54102e7d (George Burgess IV        2016-09-02 22:59:57 +0000  2008)   // For our purposes, discarding qualifiers is just as bad as using an
2099b54102e7d (George Burgess IV        2016-09-02 22:59:57 +0000  2009)   // incompatible pointer. Note that an IncompatiblePointer conversion can drop
2099b54102e7d (George Burgess IV        2016-09-02 22:59:57 +0000  2010)   // qualifiers, as well.
2099b54102e7d (George Burgess IV        2016-09-02 22:59:57 +0000  2011)   case Sema::CompatiblePointerDiscardsQualifiers:
2099b54102e7d (George Burgess IV        2016-09-02 22:59:57 +0000  2012)   case Sema::IncompatiblePointer:
2099b54102e7d (George Burgess IV        2016-09-02 22:59:57 +0000  2013)   case Sema::IncompatiblePointerSign:
6098fd1989f6b (George Burgess IV        2016-09-03 00:28:25 +0000  2014)     SecondConv = ICK_Incompatible_Pointer_Conversion;
2099b54102e7d (George Burgess IV        2016-09-02 22:59:57 +0000  2015)     break;
2099b54102e7d (George Burgess IV        2016-09-02 22:59:57 +0000  2016)   default:
26bee0b326227 (Douglas Gregor           2008-10-31 16:23:19 +0000  2017)     return false;
2099b54102e7d (George Burgess IV        2016-09-02 22:59:57 +0000  2018)   }
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2019) 
6098fd1989f6b (George Burgess IV        2016-09-03 00:28:25 +0000  2020)   // First can only be an lvalue conversion, so we pretend that this was the
6098fd1989f6b (George Burgess IV        2016-09-03 00:28:25 +0000  2021)   // second conversion. First should already be valid from earlier in the
6098fd1989f6b (George Burgess IV        2016-09-03 00:28:25 +0000  2022)   // function.
6098fd1989f6b (George Burgess IV        2016-09-03 00:28:25 +0000  2023)   SCS.Second = SecondConv;
6098fd1989f6b (George Burgess IV        2016-09-03 00:28:25 +0000  2024)   SCS.setToType(1, ToType);
6098fd1989f6b (George Burgess IV        2016-09-03 00:28:25 +0000  2025) 
6098fd1989f6b (George Burgess IV        2016-09-03 00:28:25 +0000  2026)   // Third is Identity, because Second should rank us worse than any other
6098fd1989f6b (George Burgess IV        2016-09-03 00:28:25 +0000  2027)   // conversion. This could also be ICK_Qualification, but it's simpler to just
6098fd1989f6b (George Burgess IV        2016-09-03 00:28:25 +0000  2028)   // lump everything in with the second conversion, and we don't gain anything
6098fd1989f6b (George Burgess IV        2016-09-03 00:28:25 +0000  2029)   // from making this ICK_Qualification.
6098fd1989f6b (George Burgess IV        2016-09-03 00:28:25 +0000  2030)   SCS.Third = ICK_Identity;
6098fd1989f6b (George Burgess IV        2016-09-03 00:28:25 +0000  2031)   SCS.setToType(2, ToType);
26bee0b326227 (Douglas Gregor           2008-10-31 16:23:19 +0000  2032)   return true;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2033) }
2099b54102e7d (George Burgess IV        2016-09-02 22:59:57 +0000  2034) 
16f92ce539d49 (Fariborz Jahanian        2011-03-23 19:50:54 +0000  2035) static bool
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  2036) IsTransparentUnionStandardConversion(Sema &S, Expr* From,
16f92ce539d49 (Fariborz Jahanian        2011-03-23 19:50:54 +0000  2037)                                      QualType &ToType,
16f92ce539d49 (Fariborz Jahanian        2011-03-23 19:50:54 +0000  2038)                                      bool InOverloadResolution,
16f92ce539d49 (Fariborz Jahanian        2011-03-23 19:50:54 +0000  2039)                                      StandardConversionSequence &SCS,
16f92ce539d49 (Fariborz Jahanian        2011-03-23 19:50:54 +0000  2040)                                      bool CStyle) {
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  2041) 
16f92ce539d49 (Fariborz Jahanian        2011-03-23 19:50:54 +0000  2042)   const RecordType *UT = ToType->getAsUnionType();
16f92ce539d49 (Fariborz Jahanian        2011-03-23 19:50:54 +0000  2043)   if (!UT || !UT->getDecl()->hasAttr<TransparentUnionAttr>())
16f92ce539d49 (Fariborz Jahanian        2011-03-23 19:50:54 +0000  2044)     return false;
16f92ce539d49 (Fariborz Jahanian        2011-03-23 19:50:54 +0000  2045)   // The field to initialize within the transparent union.
16f92ce539d49 (Fariborz Jahanian        2011-03-23 19:50:54 +0000  2046)   RecordDecl *UD = UT->getDecl();
16f92ce539d49 (Fariborz Jahanian        2011-03-23 19:50:54 +0000  2047)   // It's compatible if the expression matches any of the fields.
e8a8baef44c4d (Aaron Ballman            2014-03-08 20:12:42 +0000  2048)   for (const auto *it : UD->fields()) {
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2049)     if (IsStandardConversion(S, From, it->getType(), InOverloadResolution, SCS,
49a3ad21d6034 (Rui Ueyama               2019-07-16 04:46:31 +0000  2050)                              CStyle, /*AllowObjCWritebackConversion=*/false)) {
16f92ce539d49 (Fariborz Jahanian        2011-03-23 19:50:54 +0000  2051)       ToType = it->getType();
16f92ce539d49 (Fariborz Jahanian        2011-03-23 19:50:54 +0000  2052)       return true;
16f92ce539d49 (Fariborz Jahanian        2011-03-23 19:50:54 +0000  2053)     }
16f92ce539d49 (Fariborz Jahanian        2011-03-23 19:50:54 +0000  2054)   }
16f92ce539d49 (Fariborz Jahanian        2011-03-23 19:50:54 +0000  2055)   return false;
16f92ce539d49 (Fariborz Jahanian        2011-03-23 19:50:54 +0000  2056) }
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2057) 
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2058) /// IsIntegralPromotion - Determines whether the conversion from the
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2059) /// expression From (whose potentially-adjusted type is FromType) to
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2060) /// ToType is an integral promotion (C++ 4.5). If so, returns true and
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2061) /// sets PromotedType to the promoted type.
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  2062) bool Sema::IsIntegralPromotion(Expr *From, QualType FromType, QualType ToType) {
9dd450bb78148 (John McCall              2009-09-21 23:43:11 +0000  2063)   const BuiltinType *To = ToType->getAs<BuiltinType>();
ee54797234ec4 (Sebastian Redl           2008-11-04 15:59:10 +0000  2064)   // All integers are built-in.
72b8aef613170 (Sebastian Redl           2008-10-31 14:43:28 +0000  2065)   if (!To) {
72b8aef613170 (Sebastian Redl           2008-10-31 14:43:28 +0000  2066)     return false;
72b8aef613170 (Sebastian Redl           2008-10-31 14:43:28 +0000  2067)   }
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2068) 
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2069)   // An rvalue of type char, signed char, unsigned char, short int, or
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2070)   // unsigned short int can be converted to an rvalue of type int if
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2071)   // int can represent all the values of the source type; otherwise,
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2072)   // the source rvalue can be converted to an rvalue of type unsigned
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2073)   // int (C++ 4.5p1).
a71cc1536167f (Douglas Gregor           2010-02-02 20:10:50 +0000  2074)   if (FromType->isPromotableIntegerType() && !FromType->isBooleanType() &&
a71cc1536167f (Douglas Gregor           2010-02-02 20:10:50 +0000  2075)       !FromType->isEnumeralType()) {
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2076)     if (// We can promote any signed, promotable integer type to an int
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2077)         (FromType->isSignedIntegerType() ||
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2078)          // We can promote any unsigned integer type whose size is
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2079)          // less than int to an int.
5ff6747e04021 (Benjamin Kramer          2016-04-11 08:26:13 +0000  2080)          Context.getTypeSize(FromType) < Context.getTypeSize(ToType))) {
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2081)       return To->getKind() == BuiltinType::Int;
72b8aef613170 (Sebastian Redl           2008-10-31 14:43:28 +0000  2082)     }
72b8aef613170 (Sebastian Redl           2008-10-31 14:43:28 +0000  2083) 
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2084)     return To->getKind() == BuiltinType::UInt;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2085)   }
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2086) 
b9c5a60045681 (Richard Smith            2012-09-13 21:18:54 +0000  2087)   // C++11 [conv.prom]p3:
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  2088)   //   A prvalue of an unscoped enumeration type whose underlying type is not
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  2089)   //   fixed (7.2) can be converted to an rvalue a prvalue of the first of the
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  2090)   //   following types that can represent all the values of the enumeration
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  2091)   //   (i.e., the values in the range bmin to bmax as described in 7.2): int,
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  2092)   //   unsigned int, long int, unsigned long int, long long int, or unsigned
cd1d0b4f98805 (Douglas Gregor           2010-10-21 18:04:08 +0000  2093)   //   long long int. If none of the types in that list can represent all the
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  2094)   //   values of the enumeration, an rvalue a prvalue of an unscoped enumeration
cd1d0b4f98805 (Douglas Gregor           2010-10-21 18:04:08 +0000  2095)   //   type can be converted to an rvalue a prvalue of the extended integer type
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  2096)   //   with lowest integer conversion rank (4.13) greater than the rank of long
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  2097)   //   long in which all the values of the enumeration can be represented. If
cd1d0b4f98805 (Douglas Gregor           2010-10-21 18:04:08 +0000  2098)   //   there are two such extended types, the signed one is chosen.
b9c5a60045681 (Richard Smith            2012-09-13 21:18:54 +0000  2099)   // C++11 [conv.prom]p4:
b9c5a60045681 (Richard Smith            2012-09-13 21:18:54 +0000  2100)   //   A prvalue of an unscoped enumeration type whose underlying type is fixed
b9c5a60045681 (Richard Smith            2012-09-13 21:18:54 +0000  2101)   //   can be converted to a prvalue of its underlying type. Moreover, if
b9c5a60045681 (Richard Smith            2012-09-13 21:18:54 +0000  2102)   //   integral promotion can be applied to its underlying type, a prvalue of an
b9c5a60045681 (Richard Smith            2012-09-13 21:18:54 +0000  2103)   //   unscoped enumeration type whose underlying type is fixed can also be
b9c5a60045681 (Richard Smith            2012-09-13 21:18:54 +0000  2104)   //   converted to a prvalue of the promoted underlying type.
0bf3140424a0a (Douglas Gregor           2010-10-08 23:50:27 +0000  2105)   if (const EnumType *FromEnumType = FromType->getAs<EnumType>()) {
0bf3140424a0a (Douglas Gregor           2010-10-08 23:50:27 +0000  2106)     // C++0x 7.2p9: Note that this implicit enum to int conversion is not
0bf3140424a0a (Douglas Gregor           2010-10-08 23:50:27 +0000  2107)     // provided for a scoped enumeration.
0bf3140424a0a (Douglas Gregor           2010-10-08 23:50:27 +0000  2108)     if (FromEnumType->getDecl()->isScoped())
0bf3140424a0a (Douglas Gregor           2010-10-08 23:50:27 +0000  2109)       return false;
0bf3140424a0a (Douglas Gregor           2010-10-08 23:50:27 +0000  2110) 
b9c5a60045681 (Richard Smith            2012-09-13 21:18:54 +0000  2111)     // We can perform an integral promotion to the underlying type of the enum,
ac8c17533f5dd (Richard Smith            2015-03-28 00:31:40 +0000  2112)     // even if that's not the promoted type. Note that the check for promoting
ac8c17533f5dd (Richard Smith            2015-03-28 00:31:40 +0000  2113)     // the underlying type is based on the type alone, and does not consider
ac8c17533f5dd (Richard Smith            2015-03-28 00:31:40 +0000  2114)     // the bitfield-ness of the actual source expression.
b9c5a60045681 (Richard Smith            2012-09-13 21:18:54 +0000  2115)     if (FromEnumType->getDecl()->isFixed()) {
b9c5a60045681 (Richard Smith            2012-09-13 21:18:54 +0000  2116)       QualType Underlying = FromEnumType->getDecl()->getIntegerType();
b9c5a60045681 (Richard Smith            2012-09-13 21:18:54 +0000  2117)       return Context.hasSameUnqualifiedType(Underlying, ToType) ||
ac8c17533f5dd (Richard Smith            2015-03-28 00:31:40 +0000  2118)              IsIntegralPromotion(nullptr, Underlying, ToType);
b9c5a60045681 (Richard Smith            2012-09-13 21:18:54 +0000  2119)     }
b9c5a60045681 (Richard Smith            2012-09-13 21:18:54 +0000  2120) 
cd1d0b4f98805 (Douglas Gregor           2010-10-21 18:04:08 +0000  2121)     // We have already pre-calculated the promotion type, so this is trivial.
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  2122)     if (ToType->isIntegerType() &&
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  2123)         isCompleteType(From->getBeginLoc(), FromType))
88f4bba21e9ea (Richard Smith            2015-03-26 00:16:07 +0000  2124)       return Context.hasSameUnqualifiedType(
88f4bba21e9ea (Richard Smith            2015-03-26 00:16:07 +0000  2125)           ToType, FromEnumType->getDecl()->getPromotionType());
aadb254a79558 (Richard Smith            2018-06-28 21:17:55 +0000  2126) 
aadb254a79558 (Richard Smith            2018-06-28 21:17:55 +0000  2127)     // C++ [conv.prom]p5:
aadb254a79558 (Richard Smith            2018-06-28 21:17:55 +0000  2128)     //   If the bit-field has an enumerated type, it is treated as any other
aadb254a79558 (Richard Smith            2018-06-28 21:17:55 +0000  2129)     //   value of that type for promotion purposes.
aadb254a79558 (Richard Smith            2018-06-28 21:17:55 +0000  2130)     //
aadb254a79558 (Richard Smith            2018-06-28 21:17:55 +0000  2131)     // ... so do not fall through into the bit-field checks below in C++.
aadb254a79558 (Richard Smith            2018-06-28 21:17:55 +0000  2132)     if (getLangOpts().CPlusPlus)
aadb254a79558 (Richard Smith            2018-06-28 21:17:55 +0000  2133)       return false;
0bf3140424a0a (Douglas Gregor           2010-10-08 23:50:27 +0000  2134)   }
5677499fbffe3 (John McCall              2009-12-09 09:09:27 +0000  2135) 
cd1d0b4f98805 (Douglas Gregor           2010-10-21 18:04:08 +0000  2136)   // C++0x [conv.prom]p2:
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  2137)   //   A prvalue of type char16_t, char32_t, or wchar_t (3.9.1) can be converted
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  2138)   //   to an rvalue a prvalue of the first of the following types that can
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  2139)   //   represent all the values of its underlying type: int, unsigned int,
cd1d0b4f98805 (Douglas Gregor           2010-10-21 18:04:08 +0000  2140)   //   long int, unsigned long int, long long int, or unsigned long long int.
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  2141)   //   If none of the types in that list can represent all the values of its
cd1d0b4f98805 (Douglas Gregor           2010-10-21 18:04:08 +0000  2142)   //   underlying type, an rvalue a prvalue of type char16_t, char32_t,
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  2143)   //   or wchar_t can be converted to an rvalue a prvalue of its underlying
cd1d0b4f98805 (Douglas Gregor           2010-10-21 18:04:08 +0000  2144)   //   type.
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  2145)   if (FromType->isAnyCharacterType() && !FromType->isCharType() &&
cd1d0b4f98805 (Douglas Gregor           2010-10-21 18:04:08 +0000  2146)       ToType->isIntegerType()) {
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2147)     // Determine whether the type we're converting from is signed or
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2148)     // unsigned.
fa01a583e7106 (David Majnemer           2011-07-22 21:09:04 +0000  2149)     bool FromIsSigned = FromType->isSignedIntegerType();
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2150)     uint64_t FromSize = Context.getTypeSize(FromType);
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  2151) 
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2152)     // The types we'll try to promote to, in the appropriate
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2153)     // order. Try each of these types.
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  2154)     QualType PromoteTypes[6] = {
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  2155)       Context.IntTy, Context.UnsignedIntTy,
1d248c53ab1c5 (Douglas Gregor           2008-12-12 02:00:36 +0000  2156)       Context.LongTy, Context.UnsignedLongTy ,
1d248c53ab1c5 (Douglas Gregor           2008-12-12 02:00:36 +0000  2157)       Context.LongLongTy, Context.UnsignedLongLongTy
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2158)     };
1d248c53ab1c5 (Douglas Gregor           2008-12-12 02:00:36 +0000  2159)     for (int Idx = 0; Idx < 6; ++Idx) {
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2160)       uint64_t ToSize = Context.getTypeSize(PromoteTypes[Idx]);
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2161)       if (FromSize < ToSize ||
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  2162)           (FromSize == ToSize &&
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2163)            FromIsSigned == PromoteTypes[Idx]->isSignedIntegerType())) {
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2164)         // We found the type that we can promote to. If this is the
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2165)         // type we wanted, we have a promotion. Otherwise, no
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2166)         // promotion.
1b8fe5b716b8b (Douglas Gregor           2009-11-16 21:35:15 +0000  2167)         return Context.hasSameUnqualifiedType(ToType, PromoteTypes[Idx]);
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2168)       }
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2169)     }
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2170)   }
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2171) 
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2172)   // An rvalue for an integral bit-field (9.6) can be converted to an
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2173)   // rvalue of type int if int can represent all the values of the
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2174)   // bit-field; otherwise, it can be converted to unsigned int if
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2175)   // unsigned int can represent all the values of the bit-field. If
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2176)   // the bit-field is larger yet, no integral promotion applies to
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2177)   // it. If the bit-field has an enumerated type, it is treated as any
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2178)   // other value of that type for promotion purposes (C++ 4.5p3).
87c57acfb760e (Mike Stump               2009-05-16 07:39:55 +0000  2179)   // FIXME: We should delay checking of bit-fields until we actually perform the
87c57acfb760e (Mike Stump               2009-05-16 07:39:55 +0000  2180)   // conversion.
aadb254a79558 (Richard Smith            2018-06-28 21:17:55 +0000  2181)   //
aadb254a79558 (Richard Smith            2018-06-28 21:17:55 +0000  2182)   // FIXME: In C, only bit-fields of types _Bool, int, or unsigned int may be
aadb254a79558 (Richard Smith            2018-06-28 21:17:55 +0000  2183)   // promoted, per C11 6.3.1.1/2. We promote all bit-fields (including enum
aadb254a79558 (Richard Smith            2018-06-28 21:17:55 +0000  2184)   // bit-fields and those whose underlying type is larger than int) for GCC
aadb254a79558 (Richard Smith            2018-06-28 21:17:55 +0000  2185)   // compatibility.
88f4bba21e9ea (Richard Smith            2015-03-26 00:16:07 +0000  2186)   if (From) {
d25db7ed0f8ec (John McCall              2013-05-06 21:39:12 +0000  2187)     if (FieldDecl *MemberDecl = From->getSourceBitField()) {
36036aa70ec1d (David Blaikie            2020-07-12 20:31:08 -0700  2188)       Optional<llvm::APSInt> BitWidth;
6972a62c8feda (Douglas Gregor           2010-06-16 00:35:25 +0000  2189)       if (FromType->isIntegralType(Context) &&
36036aa70ec1d (David Blaikie            2020-07-12 20:31:08 -0700  2190)           (BitWidth =
36036aa70ec1d (David Blaikie            2020-07-12 20:31:08 -0700  2191)                MemberDecl->getBitWidth()->getIntegerConstantExpr(Context))) {
36036aa70ec1d (David Blaikie            2020-07-12 20:31:08 -0700  2192)         llvm::APSInt ToSize(BitWidth->getBitWidth(), BitWidth->isUnsigned());
71235ecb7fa32 (Douglas Gregor           2009-05-02 02:18:30 +0000  2193)         ToSize = Context.getTypeSize(ToType);
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  2194) 
2eedc3aa1ce4a (Douglas Gregor           2008-12-20 23:49:58 +0000  2195)         // Are we promoting to an int from a bitfield that fits in an int?
36036aa70ec1d (David Blaikie            2020-07-12 20:31:08 -0700  2196)         if (*BitWidth < ToSize ||
36036aa70ec1d (David Blaikie            2020-07-12 20:31:08 -0700  2197)             (FromType->isSignedIntegerType() && *BitWidth <= ToSize)) {
2eedc3aa1ce4a (Douglas Gregor           2008-12-20 23:49:58 +0000  2198)           return To->getKind() == BuiltinType::Int;
2eedc3aa1ce4a (Douglas Gregor           2008-12-20 23:49:58 +0000  2199)         }
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  2200) 
2eedc3aa1ce4a (Douglas Gregor           2008-12-20 23:49:58 +0000  2201)         // Are we promoting to an unsigned int from an unsigned bitfield
2eedc3aa1ce4a (Douglas Gregor           2008-12-20 23:49:58 +0000  2202)         // that fits into an unsigned int?
36036aa70ec1d (David Blaikie            2020-07-12 20:31:08 -0700  2203)         if (FromType->isUnsignedIntegerType() && *BitWidth <= ToSize) {
2eedc3aa1ce4a (Douglas Gregor           2008-12-20 23:49:58 +0000  2204)           return To->getKind() == BuiltinType::UInt;
2eedc3aa1ce4a (Douglas Gregor           2008-12-20 23:49:58 +0000  2205)         }
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  2206) 
2eedc3aa1ce4a (Douglas Gregor           2008-12-20 23:49:58 +0000  2207)         return false;
72b8aef613170 (Sebastian Redl           2008-10-31 14:43:28 +0000  2208)       }
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2209)     }
88f4bba21e9ea (Richard Smith            2015-03-26 00:16:07 +0000  2210)   }
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  2211) 
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2212)   // An rvalue of type bool can be converted to an rvalue of type int,
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2213)   // with false becoming zero and true becoming one (C++ 4.5p4).
72b8aef613170 (Sebastian Redl           2008-10-31 14:43:28 +0000  2214)   if (FromType->isBooleanType() && To->getKind() == BuiltinType::Int) {
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2215)     return true;
72b8aef613170 (Sebastian Redl           2008-10-31 14:43:28 +0000  2216)   }
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2217) 
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2218)   return false;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2219) }
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2220) 
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2221) /// IsFloatingPointPromotion - Determines whether the conversion from
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2222) /// FromType to ToType is a floating point promotion (C++ 4.6). If so,
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2223) /// returns true and sets PromotedType to the promoted type.
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  2224) bool Sema::IsFloatingPointPromotion(QualType FromType, QualType ToType) {
9dd450bb78148 (John McCall              2009-09-21 23:43:11 +0000  2225)   if (const BuiltinType *FromBuiltin = FromType->getAs<BuiltinType>())
9dd450bb78148 (John McCall              2009-09-21 23:43:11 +0000  2226)     if (const BuiltinType *ToBuiltin = ToType->getAs<BuiltinType>()) {
f0c267e6e05c2 (Anton Korobeynikov       2011-10-14 23:23:15 +0000  2227)       /// An rvalue of type float can be converted to an rvalue of type
f0c267e6e05c2 (Anton Korobeynikov       2011-10-14 23:23:15 +0000  2228)       /// double. (C++ 4.6p1).
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2229)       if (FromBuiltin->getKind() == BuiltinType::Float &&
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2230)           ToBuiltin->getKind() == BuiltinType::Double)
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2231)         return true;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2232) 
78ca74d81d935 (Douglas Gregor           2009-02-12 00:15:05 +0000  2233)       // C99 6.3.1.5p1:
78ca74d81d935 (Douglas Gregor           2009-02-12 00:15:05 +0000  2234)       //   When a float is promoted to double or long double, or a
78ca74d81d935 (Douglas Gregor           2009-02-12 00:15:05 +0000  2235)       //   double is promoted to long double [...].
bbafb8a745736 (David Blaikie            2012-03-11 07:00:24 +0000  2236)       if (!getLangOpts().CPlusPlus &&
78ca74d81d935 (Douglas Gregor           2009-02-12 00:15:05 +0000  2237)           (FromBuiltin->getKind() == BuiltinType::Float ||
78ca74d81d935 (Douglas Gregor           2009-02-12 00:15:05 +0000  2238)            FromBuiltin->getKind() == BuiltinType::Double) &&
bb1ea2d6139a7 (Nemanja Ivanovic         2016-05-09 08:52:33 +0000  2239)           (ToBuiltin->getKind() == BuiltinType::LongDouble ||
bb1ea2d6139a7 (Nemanja Ivanovic         2016-05-09 08:52:33 +0000  2240)            ToBuiltin->getKind() == BuiltinType::Float128))
78ca74d81d935 (Douglas Gregor           2009-02-12 00:15:05 +0000  2241)         return true;
f0c267e6e05c2 (Anton Korobeynikov       2011-10-14 23:23:15 +0000  2242) 
f0c267e6e05c2 (Anton Korobeynikov       2011-10-14 23:23:15 +0000  2243)       // Half can be promoted to float.
dd7f4566b1a8b (Joey Gouly               2013-01-23 11:56:20 +0000  2244)       if (!getLangOpts().NativeHalfType &&
dd7f4566b1a8b (Joey Gouly               2013-01-23 11:56:20 +0000  2245)            FromBuiltin->getKind() == BuiltinType::Half &&
f0c267e6e05c2 (Anton Korobeynikov       2011-10-14 23:23:15 +0000  2246)           ToBuiltin->getKind() == BuiltinType::Float)
f0c267e6e05c2 (Anton Korobeynikov       2011-10-14 23:23:15 +0000  2247)         return true;
78ca74d81d935 (Douglas Gregor           2009-02-12 00:15:05 +0000  2248)     }
78ca74d81d935 (Douglas Gregor           2009-02-12 00:15:05 +0000  2249) 
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2250)   return false;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2251) }
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2252) 
9fc8faf9e6197 (Adrian Prantl            2018-05-09 01:00:01 +0000  2253) /// Determine if a conversion is a complex promotion.
78ca74d81d935 (Douglas Gregor           2009-02-12 00:15:05 +0000  2254) ///
78ca74d81d935 (Douglas Gregor           2009-02-12 00:15:05 +0000  2255) /// A complex promotion is defined as a complex -> complex conversion
78ca74d81d935 (Douglas Gregor           2009-02-12 00:15:05 +0000  2256) /// where the conversion between the underlying real types is a
6752502b81367 (Douglas Gregor           2009-02-12 00:26:06 +0000  2257) /// floating-point or integral promotion.
78ca74d81d935 (Douglas Gregor           2009-02-12 00:15:05 +0000  2258) bool Sema::IsComplexPromotion(QualType FromType, QualType ToType) {
9dd450bb78148 (John McCall              2009-09-21 23:43:11 +0000  2259)   const ComplexType *FromComplex = FromType->getAs<ComplexType>();
78ca74d81d935 (Douglas Gregor           2009-02-12 00:15:05 +0000  2260)   if (!FromComplex)
78ca74d81d935 (Douglas Gregor           2009-02-12 00:15:05 +0000  2261)     return false;
78ca74d81d935 (Douglas Gregor           2009-02-12 00:15:05 +0000  2262) 
9dd450bb78148 (John McCall              2009-09-21 23:43:11 +0000  2263)   const ComplexType *ToComplex = ToType->getAs<ComplexType>();
78ca74d81d935 (Douglas Gregor           2009-02-12 00:15:05 +0000  2264)   if (!ToComplex)
78ca74d81d935 (Douglas Gregor           2009-02-12 00:15:05 +0000  2265)     return false;
78ca74d81d935 (Douglas Gregor           2009-02-12 00:15:05 +0000  2266) 
78ca74d81d935 (Douglas Gregor           2009-02-12 00:15:05 +0000  2267)   return IsFloatingPointPromotion(FromComplex->getElementType(),
6752502b81367 (Douglas Gregor           2009-02-12 00:26:06 +0000  2268)                                   ToComplex->getElementType()) ||
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000  2269)     IsIntegralPromotion(nullptr, FromComplex->getElementType(),
6752502b81367 (Douglas Gregor           2009-02-12 00:26:06 +0000  2270)                         ToComplex->getElementType());
78ca74d81d935 (Douglas Gregor           2009-02-12 00:15:05 +0000  2271) }
78ca74d81d935 (Douglas Gregor           2009-02-12 00:15:05 +0000  2272) 
237f96c40f6bf (Douglas Gregor           2008-11-26 23:31:11 +0000  2273) /// BuildSimilarlyQualifiedPointerType - In a pointer conversion from
237f96c40f6bf (Douglas Gregor           2008-11-26 23:31:11 +0000  2274) /// the pointer type FromPtr to a pointer to type ToPointee, with the
237f96c40f6bf (Douglas Gregor           2008-11-26 23:31:11 +0000  2275) /// same type qualifiers as FromPtr has on its pointee type. ToType,
237f96c40f6bf (Douglas Gregor           2008-11-26 23:31:11 +0000  2276) /// if non-empty, will be a pointer to ToType that may or may not have
237f96c40f6bf (Douglas Gregor           2008-11-26 23:31:11 +0000  2277) /// the right set of qualifiers on its pointee.
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2278) ///
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  2279) static QualType
8d6d06761fcb7 (Douglas Gregor           2010-12-01 21:43:58 +0000  2280) BuildSimilarlyQualifiedPointerType(const Type *FromPtr,
237f96c40f6bf (Douglas Gregor           2008-11-26 23:31:11 +0000  2281)                                    QualType ToPointee, QualType ToType,
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2282)                                    ASTContext &Context,
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2283)                                    bool StripObjCLifetime = false) {
8d6d06761fcb7 (Douglas Gregor           2010-12-01 21:43:58 +0000  2284)   assert((FromPtr->getTypeClass() == Type::Pointer ||
8d6d06761fcb7 (Douglas Gregor           2010-12-01 21:43:58 +0000  2285)           FromPtr->getTypeClass() == Type::ObjCObjectPointer) &&
8d6d06761fcb7 (Douglas Gregor           2010-12-01 21:43:58 +0000  2286)          "Invalid similarly-qualified pointer type");
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  2287) 
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2288)   /// Conversions to 'id' subsume cv-qualifier conversions.
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  2289)   if (ToType->isObjCIdType() || ToType->isObjCQualifiedIdType())
c6bd1d32bf20b (Douglas Gregor           2010-12-06 22:09:19 +0000  2290)     return ToType.getUnqualifiedType();
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  2291) 
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  2292)   QualType CanonFromPointee
8d6d06761fcb7 (Douglas Gregor           2010-12-01 21:43:58 +0000  2293)     = Context.getCanonicalType(FromPtr->getPointeeType());
237f96c40f6bf (Douglas Gregor           2008-11-26 23:31:11 +0000  2294)   QualType CanonToPointee = Context.getCanonicalType(ToPointee);
8ccfcb51ee020 (John McCall              2009-09-24 19:53:00 +0000  2295)   Qualifiers Quals = CanonFromPointee.getQualifiers();
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  2296) 
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2297)   if (StripObjCLifetime)
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2298)     Quals.removeObjCLifetime();
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  2299) 
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  2300)   // Exact qualifier match -> return the pointer type we're converting to.
1b8fe5b716b8b (Douglas Gregor           2009-11-16 21:35:15 +0000  2301)   if (CanonToPointee.getLocalQualifiers() == Quals) {
237f96c40f6bf (Douglas Gregor           2008-11-26 23:31:11 +0000  2302)     // ToType is exactly what we need. Return it.
8ccfcb51ee020 (John McCall              2009-09-24 19:53:00 +0000  2303)     if (!ToType.isNull())
b9f907bafc77c (Douglas Gregor           2010-05-25 15:31:05 +0000  2304)       return ToType.getUnqualifiedType();
237f96c40f6bf (Douglas Gregor           2008-11-26 23:31:11 +0000  2305) 
237f96c40f6bf (Douglas Gregor           2008-11-26 23:31:11 +0000  2306)     // Build a pointer to ToPointee. It has the right qualifiers
237f96c40f6bf (Douglas Gregor           2008-11-26 23:31:11 +0000  2307)     // already.
8d6d06761fcb7 (Douglas Gregor           2010-12-01 21:43:58 +0000  2308)     if (isa<ObjCObjectPointerType>(ToType))
8d6d06761fcb7 (Douglas Gregor           2010-12-01 21:43:58 +0000  2309)       return Context.getObjCObjectPointerType(ToPointee);
237f96c40f6bf (Douglas Gregor           2008-11-26 23:31:11 +0000  2310)     return Context.getPointerType(ToPointee);
237f96c40f6bf (Douglas Gregor           2008-11-26 23:31:11 +0000  2311)   }
237f96c40f6bf (Douglas Gregor           2008-11-26 23:31:11 +0000  2312) 
237f96c40f6bf (Douglas Gregor           2008-11-26 23:31:11 +0000  2313)   // Just build a canonical type that has the right qualifiers.
8d6d06761fcb7 (Douglas Gregor           2010-12-01 21:43:58 +0000  2314)   QualType QualifiedCanonToPointee
8d6d06761fcb7 (Douglas Gregor           2010-12-01 21:43:58 +0000  2315)     = Context.getQualifiedType(CanonToPointee.getLocalUnqualifiedType(), Quals);
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  2316) 
8d6d06761fcb7 (Douglas Gregor           2010-12-01 21:43:58 +0000  2317)   if (isa<ObjCObjectPointerType>(ToType))
8d6d06761fcb7 (Douglas Gregor           2010-12-01 21:43:58 +0000  2318)     return Context.getObjCObjectPointerType(QualifiedCanonToPointee);
8d6d06761fcb7 (Douglas Gregor           2010-12-01 21:43:58 +0000  2319)   return Context.getPointerType(QualifiedCanonToPointee);
01cbe441b31f3 (Fariborz Jahanian        2009-12-16 23:13:33 +0000  2320) }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  2321) 
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  2322) static bool isNullPointerConstantForConversion(Expr *Expr,
759b78951e44e (Anders Carlsson          2009-08-28 15:55:56 +0000  2323)                                                bool InOverloadResolution,
759b78951e44e (Anders Carlsson          2009-08-28 15:55:56 +0000  2324)                                                ASTContext &Context) {
759b78951e44e (Anders Carlsson          2009-08-28 15:55:56 +0000  2325)   // Handle value-dependent integral null pointer constants correctly.
759b78951e44e (Anders Carlsson          2009-08-28 15:55:56 +0000  2326)   // http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#903
759b78951e44e (Anders Carlsson          2009-08-28 15:55:56 +0000  2327)   if (Expr->isValueDependent() && !Expr->isTypeDependent() &&
b90df60b3b0f7 (Douglas Gregor           2010-06-16 00:17:44 +0000  2328)       Expr->getType()->isIntegerType() && !Expr->getType()->isEnumeralType())
759b78951e44e (Anders Carlsson          2009-08-28 15:55:56 +0000  2329)     return !InOverloadResolution;
759b78951e44e (Anders Carlsson          2009-08-28 15:55:56 +0000  2330) 
56751b5981c3b (Douglas Gregor           2009-09-25 04:25:58 +0000  2331)   return Expr->isNullPointerConstant(Context,
56751b5981c3b (Douglas Gregor           2009-09-25 04:25:58 +0000  2332)                     InOverloadResolution? Expr::NPC_ValueDependentIsNotNull
56751b5981c3b (Douglas Gregor           2009-09-25 04:25:58 +0000  2333)                                         : Expr::NPC_ValueDependentIsNull);
759b78951e44e (Anders Carlsson          2009-08-28 15:55:56 +0000  2334) }
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  2335) 
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2336) /// IsPointerConversion - Determines whether the conversion of the
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2337) /// expression From, which has the (possibly adjusted) type FromType,
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2338) /// can be converted to the type ToType via a pointer conversion (C++
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2339) /// 4.10). If so, returns true and places the converted type (that
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2340) /// might differ from ToType in its cv-qualifiers at some level) into
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2341) /// ConvertedType.
231d1c6f8f4e4 (Douglas Gregor           2008-11-27 00:15:41 +0000  2342) ///
a29dc05eafe20 (Douglas Gregor           2008-11-27 01:19:21 +0000  2343) /// This routine also supports conversions to and from block pointers
a29dc05eafe20 (Douglas Gregor           2008-11-27 01:19:21 +0000  2344) /// and conversions with Objective-C's 'id', 'id<protocols...>', and
a29dc05eafe20 (Douglas Gregor           2008-11-27 01:19:21 +0000  2345) /// pointers to interfaces. FIXME: Once we've determined the
a29dc05eafe20 (Douglas Gregor           2008-11-27 01:19:21 +0000  2346) /// appropriate overloading rules for Objective-C, we may want to
a29dc05eafe20 (Douglas Gregor           2008-11-27 01:19:21 +0000  2347) /// split the Objective-C checks into a different routine; however,
a29dc05eafe20 (Douglas Gregor           2008-11-27 01:19:21 +0000  2348) /// GCC seems to consider all of these conversions to be pointer
47d3f2742a3b6 (Douglas Gregor           2008-12-19 17:40:08 +0000  2349) /// conversions, so for now they live here. IncompatibleObjC will be
47d3f2742a3b6 (Douglas Gregor           2008-12-19 17:40:08 +0000  2350) /// set if the conversion is an allowed Objective-C conversion that
47d3f2742a3b6 (Douglas Gregor           2008-12-19 17:40:08 +0000  2351) /// should result in a warning.
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2352) bool Sema::IsPointerConversion(Expr *From, QualType FromType, QualType ToType,
228eea36a3598 (Anders Carlsson          2009-08-28 15:33:32 +0000  2353)                                bool InOverloadResolution,
47d3f2742a3b6 (Douglas Gregor           2008-12-19 17:40:08 +0000  2354)                                QualType& ConvertedType,
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  2355)                                bool &IncompatibleObjC) {
47d3f2742a3b6 (Douglas Gregor           2008-12-19 17:40:08 +0000  2356)   IncompatibleObjC = false;
8e543b3d46932 (Chandler Carruth         2010-12-12 08:17:55 +0000  2357)   if (isObjCPointerConversion(FromType, ToType, ConvertedType,
8e543b3d46932 (Chandler Carruth         2010-12-12 08:17:55 +0000  2358)                               IncompatibleObjC))
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2359)     return true;
47d3f2742a3b6 (Douglas Gregor           2008-12-19 17:40:08 +0000  2360) 
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  2361)   // Conversion from a null pointer constant to any Objective-C pointer type.
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  2362)   if (ToType->isObjCObjectPointerType() &&
759b78951e44e (Anders Carlsson          2009-08-28 15:55:56 +0000  2363)       isNullPointerConstantForConversion(From, InOverloadResolution, Context)) {
79a6b01802bdb (Douglas Gregor           2008-12-22 20:51:52 +0000  2364)     ConvertedType = ToType;
79a6b01802bdb (Douglas Gregor           2008-12-22 20:51:52 +0000  2365)     return true;
79a6b01802bdb (Douglas Gregor           2008-12-22 20:51:52 +0000  2366)   }
79a6b01802bdb (Douglas Gregor           2008-12-22 20:51:52 +0000  2367) 
231d1c6f8f4e4 (Douglas Gregor           2008-11-27 00:15:41 +0000  2368)   // Blocks: Block pointers can be converted to void*.
231d1c6f8f4e4 (Douglas Gregor           2008-11-27 00:15:41 +0000  2369)   if (FromType->isBlockPointerType() && ToType->isPointerType() &&
ed3b68e0dc3c0 (Simon Pilgrim            2019-10-02 14:02:27 +0000  2370)       ToType->castAs<PointerType>()->getPointeeType()->isVoidType()) {
231d1c6f8f4e4 (Douglas Gregor           2008-11-27 00:15:41 +0000  2371)     ConvertedType = ToType;
231d1c6f8f4e4 (Douglas Gregor           2008-11-27 00:15:41 +0000  2372)     return true;
231d1c6f8f4e4 (Douglas Gregor           2008-11-27 00:15:41 +0000  2373)   }
231d1c6f8f4e4 (Douglas Gregor           2008-11-27 00:15:41 +0000  2374)   // Blocks: A null pointer constant can be converted to a block
231d1c6f8f4e4 (Douglas Gregor           2008-11-27 00:15:41 +0000  2375)   // pointer type.
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  2376)   if (ToType->isBlockPointerType() &&
759b78951e44e (Anders Carlsson          2009-08-28 15:55:56 +0000  2377)       isNullPointerConstantForConversion(From, InOverloadResolution, Context)) {
231d1c6f8f4e4 (Douglas Gregor           2008-11-27 00:15:41 +0000  2378)     ConvertedType = ToType;
231d1c6f8f4e4 (Douglas Gregor           2008-11-27 00:15:41 +0000  2379)     return true;
231d1c6f8f4e4 (Douglas Gregor           2008-11-27 00:15:41 +0000  2380)   }
231d1c6f8f4e4 (Douglas Gregor           2008-11-27 00:15:41 +0000  2381) 
576fd424dfe20 (Sebastian Redl           2009-05-10 18:38:11 +0000  2382)   // If the left-hand-side is nullptr_t, the right side can be a null
576fd424dfe20 (Sebastian Redl           2009-05-10 18:38:11 +0000  2383)   // pointer constant.
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  2384)   if (ToType->isNullPtrType() &&
759b78951e44e (Anders Carlsson          2009-08-28 15:55:56 +0000  2385)       isNullPointerConstantForConversion(From, InOverloadResolution, Context)) {
576fd424dfe20 (Sebastian Redl           2009-05-10 18:38:11 +0000  2386)     ConvertedType = ToType;
576fd424dfe20 (Sebastian Redl           2009-05-10 18:38:11 +0000  2387)     return true;
576fd424dfe20 (Sebastian Redl           2009-05-10 18:38:11 +0000  2388)   }
576fd424dfe20 (Sebastian Redl           2009-05-10 18:38:11 +0000  2389) 
c23c7e6a51927 (Ted Kremenek             2009-07-29 21:53:49 +0000  2390)   const PointerType* ToTypePtr = ToType->getAs<PointerType>();
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2391)   if (!ToTypePtr)
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2392)     return false;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2393) 
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2394)   // A null pointer constant can be converted to a pointer type (C++ 4.10p1).
759b78951e44e (Anders Carlsson          2009-08-28 15:55:56 +0000  2395)   if (isNullPointerConstantForConversion(From, InOverloadResolution, Context)) {
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2396)     ConvertedType = ToType;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2397)     return true;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2398)   }
72b8aef613170 (Sebastian Redl           2008-10-31 14:43:28 +0000  2399) 
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  2400)   // Beyond this point, both types need to be pointers
01cbe441b31f3 (Fariborz Jahanian        2009-12-16 23:13:33 +0000  2401)   // , including objective-c pointers.
01cbe441b31f3 (Fariborz Jahanian        2009-12-16 23:13:33 +0000  2402)   QualType ToPointeeType = ToTypePtr->getPointeeType();
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2403)   if (FromType->isObjCObjectPointerType() && ToPointeeType->isVoidType() &&
bbafb8a745736 (David Blaikie            2012-03-11 07:00:24 +0000  2404)       !getLangOpts().ObjCAutoRefCount) {
8d6d06761fcb7 (Douglas Gregor           2010-12-01 21:43:58 +0000  2405)     ConvertedType = BuildSimilarlyQualifiedPointerType(
8d6d06761fcb7 (Douglas Gregor           2010-12-01 21:43:58 +0000  2406)                                       FromType->getAs<ObjCObjectPointerType>(),
8d6d06761fcb7 (Douglas Gregor           2010-12-01 21:43:58 +0000  2407)                                                        ToPointeeType,
01cbe441b31f3 (Fariborz Jahanian        2009-12-16 23:13:33 +0000  2408)                                                        ToType, Context);
01cbe441b31f3 (Fariborz Jahanian        2009-12-16 23:13:33 +0000  2409)     return true;
01cbe441b31f3 (Fariborz Jahanian        2009-12-16 23:13:33 +0000  2410)   }
c23c7e6a51927 (Ted Kremenek             2009-07-29 21:53:49 +0000  2411)   const PointerType *FromTypePtr = FromType->getAs<PointerType>();
237f96c40f6bf (Douglas Gregor           2008-11-26 23:31:11 +0000  2412)   if (!FromTypePtr)
237f96c40f6bf (Douglas Gregor           2008-11-26 23:31:11 +0000  2413)     return false;
237f96c40f6bf (Douglas Gregor           2008-11-26 23:31:11 +0000  2414) 
237f96c40f6bf (Douglas Gregor           2008-11-26 23:31:11 +0000  2415)   QualType FromPointeeType = FromTypePtr->getPointeeType();
237f96c40f6bf (Douglas Gregor           2008-11-26 23:31:11 +0000  2416) 
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  2417)   // If the unqualified pointee types are the same, this can't be a
fb640869ed14e (Douglas Gregor           2010-08-18 21:25:30 +0000  2418)   // pointer conversion, so don't do all of the work below.
fb640869ed14e (Douglas Gregor           2010-08-18 21:25:30 +0000  2419)   if (Context.hasSameUnqualifiedType(FromPointeeType, ToPointeeType))
fb640869ed14e (Douglas Gregor           2010-08-18 21:25:30 +0000  2420)     return false;
fb640869ed14e (Douglas Gregor           2010-08-18 21:25:30 +0000  2421) 
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2422)   // An rvalue of type "pointer to cv T," where T is an object type,
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2423)   // can be converted to an rvalue of type "pointer to cv void" (C++
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2424)   // 4.10p2).
a170cd62575d8 (Eli Friedman             2010-08-05 02:49:48 +0000  2425)   if (FromPointeeType->isIncompleteOrObjectType() &&
a170cd62575d8 (Eli Friedman             2010-08-05 02:49:48 +0000  2426)       ToPointeeType->isVoidType()) {
bc6ebb5b76827 (Francois Pichet          2011-05-08 22:52:41 +0000  2427)     ConvertedType = BuildSimilarlyQualifiedPointerType(FromTypePtr,
bc6ebb5b76827 (Francois Pichet          2011-05-08 22:52:41 +0000  2428)                                                        ToPointeeType,
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2429)                                                        ToType, Context,
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2430)                                                    /*StripObjCLifetime=*/true);
bc6ebb5b76827 (Francois Pichet          2011-05-08 22:52:41 +0000  2431)     return true;
bc6ebb5b76827 (Francois Pichet          2011-05-08 22:52:41 +0000  2432)   }
bc6ebb5b76827 (Francois Pichet          2011-05-08 22:52:41 +0000  2433) 
bc6ebb5b76827 (Francois Pichet          2011-05-08 22:52:41 +0000  2434)   // MSVC allows implicit function to void* type conversion.
6bf02820bced5 (David Majnemer           2015-10-31 08:42:14 +0000  2435)   if (getLangOpts().MSVCCompat && FromPointeeType->isFunctionType() &&
bc6ebb5b76827 (Francois Pichet          2011-05-08 22:52:41 +0000  2436)       ToPointeeType->isVoidType()) {
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  2437)     ConvertedType = BuildSimilarlyQualifiedPointerType(FromTypePtr,
bb9bf88fa4a0d (Douglas Gregor           2008-11-27 00:52:49 +0000  2438)                                                        ToPointeeType,
237f96c40f6bf (Douglas Gregor           2008-11-26 23:31:11 +0000  2439)                                                        ToType, Context);
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2440)     return true;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2441)   }
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2442) 
4e5cbdcbed0b0 (Douglas Gregor           2009-02-11 23:02:49 +0000  2443)   // When we're overloading in C, we allow a special kind of pointer
4e5cbdcbed0b0 (Douglas Gregor           2009-02-11 23:02:49 +0000  2444)   // conversion for compatible-but-not-identical pointee types.
bbafb8a745736 (David Blaikie            2012-03-11 07:00:24 +0000  2445)   if (!getLangOpts().CPlusPlus &&
4e5cbdcbed0b0 (Douglas Gregor           2009-02-11 23:02:49 +0000  2446)       Context.typesAreCompatible(FromPointeeType, ToPointeeType)) {
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  2447)     ConvertedType = BuildSimilarlyQualifiedPointerType(FromTypePtr,
4e5cbdcbed0b0 (Douglas Gregor           2009-02-11 23:02:49 +0000  2448)                                                        ToPointeeType,
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  2449)                                                        ToType, Context);
4e5cbdcbed0b0 (Douglas Gregor           2009-02-11 23:02:49 +0000  2450)     return true;
4e5cbdcbed0b0 (Douglas Gregor           2009-02-11 23:02:49 +0000  2451)   }
4e5cbdcbed0b0 (Douglas Gregor           2009-02-11 23:02:49 +0000  2452) 
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000  2453)   // C++ [conv.ptr]p3:
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  2454)   //
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000  2455)   //   An rvalue of type "pointer to cv D," where D is a class type,
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000  2456)   //   can be converted to an rvalue of type "pointer to cv B," where
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000  2457)   //   B is a base class (clause 10) of D. If B is an inaccessible
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000  2458)   //   (clause 11) or ambiguous (10.2) base class of D, a program that
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000  2459)   //   necessitates this conversion is ill-formed. The result of the
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000  2460)   //   conversion is a pointer to the base class sub-object of the
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000  2461)   //   derived class object. The null pointer value is converted to
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000  2462)   //   the null pointer value of the destination type.
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000  2463)   //
39c16d445e8e3 (Douglas Gregor           2008-10-24 04:54:22 +0000  2464)   // Note that we do not check for ambiguity or inaccessibility
39c16d445e8e3 (Douglas Gregor           2008-10-24 04:54:22 +0000  2465)   // here. That is handled by CheckPointerConversion.
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  2466)   if (getLangOpts().CPlusPlus && FromPointeeType->isRecordType() &&
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  2467)       ToPointeeType->isRecordType() &&
d28f0412e4061 (Douglas Gregor           2010-02-22 17:06:41 +0000  2468)       !Context.hasSameUnqualifiedType(FromPointeeType, ToPointeeType) &&
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  2469)       IsDerivedFrom(From->getBeginLoc(), FromPointeeType, ToPointeeType)) {
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  2470)     ConvertedType = BuildSimilarlyQualifiedPointerType(FromTypePtr,
bb9bf88fa4a0d (Douglas Gregor           2008-11-27 00:52:49 +0000  2471)                                                        ToPointeeType,
237f96c40f6bf (Douglas Gregor           2008-11-26 23:31:11 +0000  2472)                                                        ToType, Context);
237f96c40f6bf (Douglas Gregor           2008-11-26 23:31:11 +0000  2473)     return true;
237f96c40f6bf (Douglas Gregor           2008-11-26 23:31:11 +0000  2474)   }
237f96c40f6bf (Douglas Gregor           2008-11-26 23:31:11 +0000  2475) 
bc2ee9382c82d (Fariborz Jahanian        2011-04-14 20:33:36 +0000  2476)   if (FromPointeeType->isVectorType() && ToPointeeType->isVectorType() &&
bc2ee9382c82d (Fariborz Jahanian        2011-04-14 20:33:36 +0000  2477)       Context.areCompatibleVectorTypes(FromPointeeType, ToPointeeType)) {
bc2ee9382c82d (Fariborz Jahanian        2011-04-14 20:33:36 +0000  2478)     ConvertedType = BuildSimilarlyQualifiedPointerType(FromTypePtr,
bc2ee9382c82d (Fariborz Jahanian        2011-04-14 20:33:36 +0000  2479)                                                        ToPointeeType,
bc2ee9382c82d (Fariborz Jahanian        2011-04-14 20:33:36 +0000  2480)                                                        ToType, Context);
bc2ee9382c82d (Fariborz Jahanian        2011-04-14 20:33:36 +0000  2481)     return true;
bc2ee9382c82d (Fariborz Jahanian        2011-04-14 20:33:36 +0000  2482)   }
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  2483) 
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2484)   return false;
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2485) }
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  2486) 
9fc8faf9e6197 (Adrian Prantl            2018-05-09 01:00:01 +0000  2487) /// Adopt the given qualifiers for the given type.
aec25847606fd (Douglas Gregor           2011-04-26 23:16:46 +0000  2488) static QualType AdoptQualifiers(ASTContext &Context, QualType T, Qualifiers Qs){
aec25847606fd (Douglas Gregor           2011-04-26 23:16:46 +0000  2489)   Qualifiers TQs = T.getQualifiers();
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  2490) 
aec25847606fd (Douglas Gregor           2011-04-26 23:16:46 +0000  2491)   // Check whether qualifiers already match.
aec25847606fd (Douglas Gregor           2011-04-26 23:16:46 +0000  2492)   if (TQs == Qs)
aec25847606fd (Douglas Gregor           2011-04-26 23:16:46 +0000  2493)     return T;
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  2494) 
aec25847606fd (Douglas Gregor           2011-04-26 23:16:46 +0000  2495)   if (Qs.compatiblyIncludes(TQs))
aec25847606fd (Douglas Gregor           2011-04-26 23:16:46 +0000  2496)     return Context.getQualifiedType(T, Qs);
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  2497) 
aec25847606fd (Douglas Gregor           2011-04-26 23:16:46 +0000  2498)   return Context.getQualifiedType(T.getUnqualifiedType(), Qs);
aec25847606fd (Douglas Gregor           2011-04-26 23:16:46 +0000  2499) }
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2500) 
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2501) /// isObjCPointerConversion - Determines whether this is an
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2502) /// Objective-C pointer conversion. Subroutine of IsPointerConversion,
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2503) /// with the same arguments and return values.
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  2504) bool Sema::isObjCPointerConversion(QualType FromType, QualType ToType,
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2505)                                    QualType& ConvertedType,
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2506)                                    bool &IncompatibleObjC) {
fa98390b3c314 (Erik Pilkington          2018-10-30 20:31:30 +0000  2507)   if (!getLangOpts().ObjC)
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2508)     return false;
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  2509) 
aec25847606fd (Douglas Gregor           2011-04-26 23:16:46 +0000  2510)   // The set of qualifiers on the type we're converting from.
aec25847606fd (Douglas Gregor           2011-04-26 23:16:46 +0000  2511)   Qualifiers FromQualifiers = FromType.getQualifiers();
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  2512) 
7cae42b07a3aa (Steve Naroff             2009-07-10 23:34:53 +0000  2513)   // First, we handle all conversions on ObjC object pointer types.
8e543b3d46932 (Chandler Carruth         2010-12-12 08:17:55 +0000  2514)   const ObjCObjectPointerType* ToObjCPtr =
8e543b3d46932 (Chandler Carruth         2010-12-12 08:17:55 +0000  2515)     ToType->getAs<ObjCObjectPointerType>();
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  2516)   const ObjCObjectPointerType *FromObjCPtr =
9dd450bb78148 (John McCall              2009-09-21 23:43:11 +0000  2517)     FromType->getAs<ObjCObjectPointerType>();
7cae42b07a3aa (Steve Naroff             2009-07-10 23:34:53 +0000  2518) 
7cae42b07a3aa (Steve Naroff             2009-07-10 23:34:53 +0000  2519)   if (ToObjCPtr && FromObjCPtr) {
8d6d06761fcb7 (Douglas Gregor           2010-12-01 21:43:58 +0000  2520)     // If the pointee types are the same (ignoring qualifications),
8d6d06761fcb7 (Douglas Gregor           2010-12-01 21:43:58 +0000  2521)     // then this is not a pointer conversion.
8d6d06761fcb7 (Douglas Gregor           2010-12-01 21:43:58 +0000  2522)     if (Context.hasSameUnqualifiedType(ToObjCPtr->getPointeeType(),
8d6d06761fcb7 (Douglas Gregor           2010-12-01 21:43:58 +0000  2523)                                        FromObjCPtr->getPointeeType()))
8d6d06761fcb7 (Douglas Gregor           2010-12-01 21:43:58 +0000  2524)       return false;
8d6d06761fcb7 (Douglas Gregor           2010-12-01 21:43:58 +0000  2525) 
ab209d83be5da (Douglas Gregor           2015-07-07 03:58:42 +0000  2526)     // Conversion between Objective-C pointers.
7cae42b07a3aa (Steve Naroff             2009-07-10 23:34:53 +0000  2527)     if (Context.canAssignObjCInterfaces(ToObjCPtr, FromObjCPtr)) {
b397e43dea379 (Fariborz Jahanian        2010-03-15 18:36:00 +0000  2528)       const ObjCInterfaceType* LHS = ToObjCPtr->getInterfaceType();
b397e43dea379 (Fariborz Jahanian        2010-03-15 18:36:00 +0000  2529)       const ObjCInterfaceType* RHS = FromObjCPtr->getInterfaceType();
bbafb8a745736 (David Blaikie            2012-03-11 07:00:24 +0000  2530)       if (getLangOpts().CPlusPlus && LHS && RHS &&
b397e43dea379 (Fariborz Jahanian        2010-03-15 18:36:00 +0000  2531)           !ToObjCPtr->getPointeeType().isAtLeastAsQualifiedAs(
b397e43dea379 (Fariborz Jahanian        2010-03-15 18:36:00 +0000  2532)                                                 FromObjCPtr->getPointeeType()))
b397e43dea379 (Fariborz Jahanian        2010-03-15 18:36:00 +0000  2533)         return false;
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  2534)       ConvertedType = BuildSimilarlyQualifiedPointerType(FromObjCPtr,
8d6d06761fcb7 (Douglas Gregor           2010-12-01 21:43:58 +0000  2535)                                                    ToObjCPtr->getPointeeType(),
8d6d06761fcb7 (Douglas Gregor           2010-12-01 21:43:58 +0000  2536)                                                          ToType, Context);
aec25847606fd (Douglas Gregor           2011-04-26 23:16:46 +0000  2537)       ConvertedType = AdoptQualifiers(Context, ConvertedType, FromQualifiers);
7cae42b07a3aa (Steve Naroff             2009-07-10 23:34:53 +0000  2538)       return true;
7cae42b07a3aa (Steve Naroff             2009-07-10 23:34:53 +0000  2539)     }
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2540) 
7cae42b07a3aa (Steve Naroff             2009-07-10 23:34:53 +0000  2541)     if (Context.canAssignObjCInterfaces(FromObjCPtr, ToObjCPtr)) {
7cae42b07a3aa (Steve Naroff             2009-07-10 23:34:53 +0000  2542)       // Okay: this is some kind of implicit downcast of Objective-C
7cae42b07a3aa (Steve Naroff             2009-07-10 23:34:53 +0000  2543)       // interfaces, which is permitted. However, we're going to
7cae42b07a3aa (Steve Naroff             2009-07-10 23:34:53 +0000  2544)       // complain about it.
7cae42b07a3aa (Steve Naroff             2009-07-10 23:34:53 +0000  2545)       IncompatibleObjC = true;
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  2546)       ConvertedType = BuildSimilarlyQualifiedPointerType(FromObjCPtr,
8d6d06761fcb7 (Douglas Gregor           2010-12-01 21:43:58 +0000  2547)                                                    ToObjCPtr->getPointeeType(),
8d6d06761fcb7 (Douglas Gregor           2010-12-01 21:43:58 +0000  2548)                                                          ToType, Context);
aec25847606fd (Douglas Gregor           2011-04-26 23:16:46 +0000  2549)       ConvertedType = AdoptQualifiers(Context, ConvertedType, FromQualifiers);
7cae42b07a3aa (Steve Naroff             2009-07-10 23:34:53 +0000  2550)       return true;
7cae42b07a3aa (Steve Naroff             2009-07-10 23:34:53 +0000  2551)     }
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  2552)   }
7cae42b07a3aa (Steve Naroff             2009-07-10 23:34:53 +0000  2553)   // Beyond this point, both types need to be C pointers or block pointers.
033f56d5335ab (Douglas Gregor           2008-12-23 00:53:59 +0000  2554)   QualType ToPointeeType;
c23c7e6a51927 (Ted Kremenek             2009-07-29 21:53:49 +0000  2555)   if (const PointerType *ToCPtr = ToType->getAs<PointerType>())
7cae42b07a3aa (Steve Naroff             2009-07-10 23:34:53 +0000  2556)     ToPointeeType = ToCPtr->getPointeeType();
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  2557)   else if (const BlockPointerType *ToBlockPtr =
4efdec067731b (Fariborz Jahanian        2010-01-20 22:54:38 +0000  2558)             ToType->getAs<BlockPointerType>()) {
879cc735fc670 (Fariborz Jahanian        2010-01-21 00:08:17 +0000  2559)     // Objective C++: We're able to convert from a pointer to any object
4efdec067731b (Fariborz Jahanian        2010-01-20 22:54:38 +0000  2560)     // to a block pointer type.
4efdec067731b (Fariborz Jahanian        2010-01-20 22:54:38 +0000  2561)     if (FromObjCPtr && FromObjCPtr->isObjCBuiltinType()) {
aec25847606fd (Douglas Gregor           2011-04-26 23:16:46 +0000  2562)       ConvertedType = AdoptQualifiers(Context, ToType, FromQualifiers);
4efdec067731b (Fariborz Jahanian        2010-01-20 22:54:38 +0000  2563)       return true;
4efdec067731b (Fariborz Jahanian        2010-01-20 22:54:38 +0000  2564)     }
033f56d5335ab (Douglas Gregor           2008-12-23 00:53:59 +0000  2565)     ToPointeeType = ToBlockPtr->getPointeeType();
4efdec067731b (Fariborz Jahanian        2010-01-20 22:54:38 +0000  2566)   }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  2567)   else if (FromType->getAs<BlockPointerType>() &&
e4951fdc4b958 (Fariborz Jahanian        2010-01-21 00:05:09 +0000  2568)            ToObjCPtr && ToObjCPtr->isObjCBuiltinType()) {
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  2569)     // Objective C++: We're able to convert from a block pointer type to a
879cc735fc670 (Fariborz Jahanian        2010-01-21 00:08:17 +0000  2570)     // pointer to any object.
aec25847606fd (Douglas Gregor           2011-04-26 23:16:46 +0000  2571)     ConvertedType = AdoptQualifiers(Context, ToType, FromQualifiers);
e4951fdc4b958 (Fariborz Jahanian        2010-01-21 00:05:09 +0000  2572)     return true;
e4951fdc4b958 (Fariborz Jahanian        2010-01-21 00:05:09 +0000  2573)   }
033f56d5335ab (Douglas Gregor           2008-12-23 00:53:59 +0000  2574)   else
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2575)     return false;
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2576) 
033f56d5335ab (Douglas Gregor           2008-12-23 00:53:59 +0000  2577)   QualType FromPointeeType;
c23c7e6a51927 (Ted Kremenek             2009-07-29 21:53:49 +0000  2578)   if (const PointerType *FromCPtr = FromType->getAs<PointerType>())
7cae42b07a3aa (Steve Naroff             2009-07-10 23:34:53 +0000  2579)     FromPointeeType = FromCPtr->getPointeeType();
8e543b3d46932 (Chandler Carruth         2010-12-12 08:17:55 +0000  2580)   else if (const BlockPointerType *FromBlockPtr =
8e543b3d46932 (Chandler Carruth         2010-12-12 08:17:55 +0000  2581)            FromType->getAs<BlockPointerType>())
033f56d5335ab (Douglas Gregor           2008-12-23 00:53:59 +0000  2582)     FromPointeeType = FromBlockPtr->getPointeeType();
033f56d5335ab (Douglas Gregor           2008-12-23 00:53:59 +0000  2583)   else
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2584)     return false;
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2585) 
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2586)   // If we have pointers to pointers, recursively check whether this
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2587)   // is an Objective-C conversion.
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2588)   if (FromPointeeType->isPointerType() && ToPointeeType->isPointerType() &&
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2589)       isObjCPointerConversion(FromPointeeType, ToPointeeType, ConvertedType,
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2590)                               IncompatibleObjC)) {
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2591)     // We always complain about this conversion.
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2592)     IncompatibleObjC = true;
8d6d06761fcb7 (Douglas Gregor           2010-12-01 21:43:58 +0000  2593)     ConvertedType = Context.getPointerType(ConvertedType);
aec25847606fd (Douglas Gregor           2011-04-26 23:16:46 +0000  2594)     ConvertedType = AdoptQualifiers(Context, ConvertedType, FromQualifiers);
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2595)     return true;
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2596)   }
42ffdb32fb546 (Fariborz Jahanian        2010-01-18 22:59:22 +0000  2597)   // Allow conversion of pointee being objective-c pointer to another one;
42ffdb32fb546 (Fariborz Jahanian        2010-01-18 22:59:22 +0000  2598)   // as in I* to id.
42ffdb32fb546 (Fariborz Jahanian        2010-01-18 22:59:22 +0000  2599)   if (FromPointeeType->getAs<ObjCObjectPointerType>() &&
42ffdb32fb546 (Fariborz Jahanian        2010-01-18 22:59:22 +0000  2600)       ToPointeeType->getAs<ObjCObjectPointerType>() &&
42ffdb32fb546 (Fariborz Jahanian        2010-01-18 22:59:22 +0000  2601)       isObjCPointerConversion(FromPointeeType, ToPointeeType, ConvertedType,
42ffdb32fb546 (Fariborz Jahanian        2010-01-18 22:59:22 +0000  2602)                               IncompatibleObjC)) {
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  2603) 
8d6d06761fcb7 (Douglas Gregor           2010-12-01 21:43:58 +0000  2604)     ConvertedType = Context.getPointerType(ConvertedType);
aec25847606fd (Douglas Gregor           2011-04-26 23:16:46 +0000  2605)     ConvertedType = AdoptQualifiers(Context, ConvertedType, FromQualifiers);
42ffdb32fb546 (Fariborz Jahanian        2010-01-18 22:59:22 +0000  2606)     return true;
42ffdb32fb546 (Fariborz Jahanian        2010-01-18 22:59:22 +0000  2607)   }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  2608) 
033f56d5335ab (Douglas Gregor           2008-12-23 00:53:59 +0000  2609)   // If we have pointers to functions or blocks, check whether the only
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2610)   // differences in the argument and result types are in Objective-C
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2611)   // pointer conversions. If so, we permit the conversion (but
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2612)   // complain about it).
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  2613)   const FunctionProtoType *FromFunctionType
9dd450bb78148 (John McCall              2009-09-21 23:43:11 +0000  2614)     = FromPointeeType->getAs<FunctionProtoType>();
deaad8cc34239 (Douglas Gregor           2009-02-26 23:50:07 +0000  2615)   const FunctionProtoType *ToFunctionType
9dd450bb78148 (John McCall              2009-09-21 23:43:11 +0000  2616)     = ToPointeeType->getAs<FunctionProtoType>();
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2617)   if (FromFunctionType && ToFunctionType) {
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2618)     // If the function types are exactly the same, this isn't an
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2619)     // Objective-C pointer conversion.
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2620)     if (Context.getCanonicalType(FromPointeeType)
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2621)           == Context.getCanonicalType(ToPointeeType))
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2622)       return false;
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2623) 
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2624)     // Perform the quick checks that will tell us whether these
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2625)     // function types are obviously different.
9cacbabd33eea (Alp Toker                2014-01-20 20:26:09 +0000  2626)     if (FromFunctionType->getNumParams() != ToFunctionType->getNumParams() ||
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2627)         FromFunctionType->isVariadic() != ToFunctionType->isVariadic() ||
c61eaa5920161 (Anastasia Stulova        2019-01-28 11:37:49 +0000  2628)         FromFunctionType->getMethodQuals() != ToFunctionType->getMethodQuals())
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2629)       return false;
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2630) 
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2631)     bool HasObjCConversion = false;
314cc81b8caac (Alp Toker                2014-01-25 16:55:45 +0000  2632)     if (Context.getCanonicalType(FromFunctionType->getReturnType()) ==
314cc81b8caac (Alp Toker                2014-01-25 16:55:45 +0000  2633)         Context.getCanonicalType(ToFunctionType->getReturnType())) {
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2634)       // Okay, the types match exactly. Nothing to do.
314cc81b8caac (Alp Toker                2014-01-25 16:55:45 +0000  2635)     } else if (isObjCPointerConversion(FromFunctionType->getReturnType(),
314cc81b8caac (Alp Toker                2014-01-25 16:55:45 +0000  2636)                                        ToFunctionType->getReturnType(),
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2637)                                        ConvertedType, IncompatibleObjC)) {
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2638)       // Okay, we have an Objective-C pointer conversion.
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2639)       HasObjCConversion = true;
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2640)     } else {
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2641)       // Function types are too different. Abort.
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2642)       return false;
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2643)     }
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  2644) 
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2645)     // Check argument types.
9cacbabd33eea (Alp Toker                2014-01-20 20:26:09 +0000  2646)     for (unsigned ArgIdx = 0, NumArgs = FromFunctionType->getNumParams();
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2647)          ArgIdx != NumArgs; ++ArgIdx) {
9cacbabd33eea (Alp Toker                2014-01-20 20:26:09 +0000  2648)       QualType FromArgType = FromFunctionType->getParamType(ArgIdx);
9cacbabd33eea (Alp Toker                2014-01-20 20:26:09 +0000  2649)       QualType ToArgType = ToFunctionType->getParamType(ArgIdx);
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2650)       if (Context.getCanonicalType(FromArgType)
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2651)             == Context.getCanonicalType(ToArgType)) {
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2652)         // Okay, the types match exactly. Nothing to do.
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2653)       } else if (isObjCPointerConversion(FromArgType, ToArgType,
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2654)                                          ConvertedType, IncompatibleObjC)) {
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2655)         // Okay, we have an Objective-C pointer conversion.
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2656)         HasObjCConversion = true;
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2657)       } else {
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2658)         // Argument types are too different. Abort.
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2659)         return false;
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2660)       }
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2661)     }
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2662) 
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2663)     if (HasObjCConversion) {
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2664)       // We had an Objective-C conversion. Allow this pointer
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2665)       // conversion, but complain about it.
aec25847606fd (Douglas Gregor           2011-04-26 23:16:46 +0000  2666)       ConvertedType = AdoptQualifiers(Context, ToType, FromQualifiers);
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2667)       IncompatibleObjC = true;
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2668)       return true;
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2669)     }
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2670)   }
a119f10482c3f (Douglas Gregor           2008-12-19 19:13:09 +0000  2671) 
72b597d6b6ae7 (Sebastian Redl           2009-01-25 19:43:20 +0000  2672)   return false;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2673) }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  2674) 
9fc8faf9e6197 (Adrian Prantl            2018-05-09 01:00:01 +0000  2675) /// Determine whether this is an Objective-C writeback conversion,
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2676) /// used for parameter passing when performing automatic reference counting.
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2677) ///
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2678) /// \param FromType The type we're converting form.
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2679) ///
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2680) /// \param ToType The type we're converting to.
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2681) ///
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2682) /// \param ConvertedType The type that will be produced after applying
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2683) /// this conversion.
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2684) bool Sema::isObjCWritebackConversion(QualType FromType, QualType ToType,
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2685)                                      QualType &ConvertedType) {
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  2686)   if (!getLangOpts().ObjCAutoRefCount ||
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2687)       Context.hasSameUnqualifiedType(FromType, ToType))
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2688)     return false;
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  2689) 
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2690)   // Parameter must be a pointer to __autoreleasing (with no other qualifiers).
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2691)   QualType ToPointee;
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2692)   if (const PointerType *ToPointer = ToType->getAs<PointerType>())
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2693)     ToPointee = ToPointer->getPointeeType();
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2694)   else
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2695)     return false;
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  2696) 
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2697)   Qualifiers ToQuals = ToPointee.getQualifiers();
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  2698)   if (!ToPointee->isObjCLifetimeType() ||
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2699)       ToQuals.getObjCLifetime() != Qualifiers::OCL_Autoreleasing ||
18ce25e1ec096 (John McCall              2012-02-08 00:46:36 +0000  2700)       !ToQuals.withoutObjCLifetime().empty())
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2701)     return false;
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  2702) 
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2703)   // Argument must be a pointer to __strong to __weak.
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2704)   QualType FromPointee;
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2705)   if (const PointerType *FromPointer = FromType->getAs<PointerType>())
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2706)     FromPointee = FromPointer->getPointeeType();
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2707)   else
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2708)     return false;
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  2709) 
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2710)   Qualifiers FromQuals = FromPointee.getQualifiers();
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2711)   if (!FromPointee->isObjCLifetimeType() ||
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2712)       (FromQuals.getObjCLifetime() != Qualifiers::OCL_Strong &&
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2713)        FromQuals.getObjCLifetime() != Qualifiers::OCL_Weak))
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2714)     return false;
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  2715) 
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2716)   // Make sure that we have compatible qualifiers.
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2717)   FromQuals.setObjCLifetime(Qualifiers::OCL_Autoreleasing);
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2718)   if (!ToQuals.compatiblyIncludes(FromQuals))
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2719)     return false;
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  2720) 
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2721)   // Remove qualifiers from the pointee type we're converting from; they
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2722)   // aren't used in the compatibility check belong, and we'll be adding back
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2723)   // qualifiers (with __autoreleasing) if the compatibility check succeeds.
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2724)   FromPointee = FromPointee.getUnqualifiedType();
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  2725) 
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2726)   // The unqualified form of the pointee types must be compatible.
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2727)   ToPointee = ToPointee.getUnqualifiedType();
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2728)   bool IncompatibleObjC;
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2729)   if (Context.typesAreCompatible(FromPointee, ToPointee))
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2730)     FromPointee = ToPointee;
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2731)   else if (!isObjCPointerConversion(FromPointee, ToPointee, FromPointee,
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2732)                                     IncompatibleObjC))
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2733)     return false;
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  2734) 
9fc8faf9e6197 (Adrian Prantl            2018-05-09 01:00:01 +0000  2735)   /// Construct the type we're converting to, which is a pointer to
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2736)   /// __autoreleasing pointee.
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2737)   FromPointee = Context.getQualifiedType(FromPointee, FromQuals);
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2738)   ConvertedType = Context.getPointerType(FromPointee);
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2739)   return true;
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2740) }
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  2741) 
42455ea935b04 (Fariborz Jahanian        2011-02-12 19:07:46 +0000  2742) bool Sema::IsBlockPointerConversion(QualType FromType, QualType ToType,
42455ea935b04 (Fariborz Jahanian        2011-02-12 19:07:46 +0000  2743)                                     QualType& ConvertedType) {
42455ea935b04 (Fariborz Jahanian        2011-02-12 19:07:46 +0000  2744)   QualType ToPointeeType;
42455ea935b04 (Fariborz Jahanian        2011-02-12 19:07:46 +0000  2745)   if (const BlockPointerType *ToBlockPtr =
42455ea935b04 (Fariborz Jahanian        2011-02-12 19:07:46 +0000  2746)         ToType->getAs<BlockPointerType>())
42455ea935b04 (Fariborz Jahanian        2011-02-12 19:07:46 +0000  2747)     ToPointeeType = ToBlockPtr->getPointeeType();
42455ea935b04 (Fariborz Jahanian        2011-02-12 19:07:46 +0000  2748)   else
42455ea935b04 (Fariborz Jahanian        2011-02-12 19:07:46 +0000  2749)     return false;
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  2750) 
42455ea935b04 (Fariborz Jahanian        2011-02-12 19:07:46 +0000  2751)   QualType FromPointeeType;
42455ea935b04 (Fariborz Jahanian        2011-02-12 19:07:46 +0000  2752)   if (const BlockPointerType *FromBlockPtr =
42455ea935b04 (Fariborz Jahanian        2011-02-12 19:07:46 +0000  2753)       FromType->getAs<BlockPointerType>())
42455ea935b04 (Fariborz Jahanian        2011-02-12 19:07:46 +0000  2754)     FromPointeeType = FromBlockPtr->getPointeeType();
42455ea935b04 (Fariborz Jahanian        2011-02-12 19:07:46 +0000  2755)   else
42455ea935b04 (Fariborz Jahanian        2011-02-12 19:07:46 +0000  2756)     return false;
42455ea935b04 (Fariborz Jahanian        2011-02-12 19:07:46 +0000  2757)   // We have pointer to blocks, check whether the only
42455ea935b04 (Fariborz Jahanian        2011-02-12 19:07:46 +0000  2758)   // differences in the argument and result types are in Objective-C
42455ea935b04 (Fariborz Jahanian        2011-02-12 19:07:46 +0000  2759)   // pointer conversions. If so, we permit the conversion.
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  2760) 
42455ea935b04 (Fariborz Jahanian        2011-02-12 19:07:46 +0000  2761)   const FunctionProtoType *FromFunctionType
42455ea935b04 (Fariborz Jahanian        2011-02-12 19:07:46 +0000  2762)     = FromPointeeType->getAs<FunctionProtoType>();
42455ea935b04 (Fariborz Jahanian        2011-02-12 19:07:46 +0000  2763)   const FunctionProtoType *ToFunctionType
42455ea935b04 (Fariborz Jahanian        2011-02-12 19:07:46 +0000  2764)     = ToPointeeType->getAs<FunctionProtoType>();
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  2765) 
4de45dc6a7701 (Fariborz Jahanian        2011-02-13 20:01:48 +0000  2766)   if (!FromFunctionType || !ToFunctionType)
4de45dc6a7701 (Fariborz Jahanian        2011-02-13 20:01:48 +0000  2767)     return false;
4de45dc6a7701 (Fariborz Jahanian        2011-02-13 20:01:48 +0000  2768) 
4de45dc6a7701 (Fariborz Jahanian        2011-02-13 20:01:48 +0000  2769)   if (Context.hasSameType(FromPointeeType, ToPointeeType))
4de45dc6a7701 (Fariborz Jahanian        2011-02-13 20:01:48 +0000  2770)     return true;
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  2771) 
4de45dc6a7701 (Fariborz Jahanian        2011-02-13 20:01:48 +0000  2772)   // Perform the quick checks that will tell us whether these
4de45dc6a7701 (Fariborz Jahanian        2011-02-13 20:01:48 +0000  2773)   // function types are obviously different.
9cacbabd33eea (Alp Toker                2014-01-20 20:26:09 +0000  2774)   if (FromFunctionType->getNumParams() != ToFunctionType->getNumParams() ||
4de45dc6a7701 (Fariborz Jahanian        2011-02-13 20:01:48 +0000  2775)       FromFunctionType->isVariadic() != ToFunctionType->isVariadic())
4de45dc6a7701 (Fariborz Jahanian        2011-02-13 20:01:48 +0000  2776)     return false;
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  2777) 
4de45dc6a7701 (Fariborz Jahanian        2011-02-13 20:01:48 +0000  2778)   FunctionType::ExtInfo FromEInfo = FromFunctionType->getExtInfo();
4de45dc6a7701 (Fariborz Jahanian        2011-02-13 20:01:48 +0000  2779)   FunctionType::ExtInfo ToEInfo = ToFunctionType->getExtInfo();
4de45dc6a7701 (Fariborz Jahanian        2011-02-13 20:01:48 +0000  2780)   if (FromEInfo != ToEInfo)
4de45dc6a7701 (Fariborz Jahanian        2011-02-13 20:01:48 +0000  2781)     return false;
4de45dc6a7701 (Fariborz Jahanian        2011-02-13 20:01:48 +0000  2782) 
4de45dc6a7701 (Fariborz Jahanian        2011-02-13 20:01:48 +0000  2783)   bool IncompatibleObjC = false;
314cc81b8caac (Alp Toker                2014-01-25 16:55:45 +0000  2784)   if (Context.hasSameType(FromFunctionType->getReturnType(),
314cc81b8caac (Alp Toker                2014-01-25 16:55:45 +0000  2785)                           ToFunctionType->getReturnType())) {
4de45dc6a7701 (Fariborz Jahanian        2011-02-13 20:01:48 +0000  2786)     // Okay, the types match exactly. Nothing to do.
4de45dc6a7701 (Fariborz Jahanian        2011-02-13 20:01:48 +0000  2787)   } else {
314cc81b8caac (Alp Toker                2014-01-25 16:55:45 +0000  2788)     QualType RHS = FromFunctionType->getReturnType();
314cc81b8caac (Alp Toker                2014-01-25 16:55:45 +0000  2789)     QualType LHS = ToFunctionType->getReturnType();
bbafb8a745736 (David Blaikie            2012-03-11 07:00:24 +0000  2790)     if ((!getLangOpts().CPlusPlus || !RHS->isRecordType()) &&
4de45dc6a7701 (Fariborz Jahanian        2011-02-13 20:01:48 +0000  2791)         !RHS.hasQualifiers() && LHS.hasQualifiers())
4de45dc6a7701 (Fariborz Jahanian        2011-02-13 20:01:48 +0000  2792)        LHS = LHS.getUnqualifiedType();
4de45dc6a7701 (Fariborz Jahanian        2011-02-13 20:01:48 +0000  2793) 
4de45dc6a7701 (Fariborz Jahanian        2011-02-13 20:01:48 +0000  2794)      if (Context.hasSameType(RHS,LHS)) {
4de45dc6a7701 (Fariborz Jahanian        2011-02-13 20:01:48 +0000  2795)        // OK exact match.
4de45dc6a7701 (Fariborz Jahanian        2011-02-13 20:01:48 +0000  2796)      } else if (isObjCPointerConversion(RHS, LHS,
4de45dc6a7701 (Fariborz Jahanian        2011-02-13 20:01:48 +0000  2797)                                         ConvertedType, IncompatibleObjC)) {
4de45dc6a7701 (Fariborz Jahanian        2011-02-13 20:01:48 +0000  2798)      if (IncompatibleObjC)
4de45dc6a7701 (Fariborz Jahanian        2011-02-13 20:01:48 +0000  2799)        return false;
4de45dc6a7701 (Fariborz Jahanian        2011-02-13 20:01:48 +0000  2800)      // Okay, we have an Objective-C pointer conversion.
4de45dc6a7701 (Fariborz Jahanian        2011-02-13 20:01:48 +0000  2801)      }
4de45dc6a7701 (Fariborz Jahanian        2011-02-13 20:01:48 +0000  2802)      else
4de45dc6a7701 (Fariborz Jahanian        2011-02-13 20:01:48 +0000  2803)        return false;
4de45dc6a7701 (Fariborz Jahanian        2011-02-13 20:01:48 +0000  2804)    }
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  2805) 
4de45dc6a7701 (Fariborz Jahanian        2011-02-13 20:01:48 +0000  2806)    // Check argument types.
9cacbabd33eea (Alp Toker                2014-01-20 20:26:09 +0000  2807)    for (unsigned ArgIdx = 0, NumArgs = FromFunctionType->getNumParams();
4de45dc6a7701 (Fariborz Jahanian        2011-02-13 20:01:48 +0000  2808)         ArgIdx != NumArgs; ++ArgIdx) {
4de45dc6a7701 (Fariborz Jahanian        2011-02-13 20:01:48 +0000  2809)      IncompatibleObjC = false;
9cacbabd33eea (Alp Toker                2014-01-20 20:26:09 +0000  2810)      QualType FromArgType = FromFunctionType->getParamType(ArgIdx);
9cacbabd33eea (Alp Toker                2014-01-20 20:26:09 +0000  2811)      QualType ToArgType = ToFunctionType->getParamType(ArgIdx);
4de45dc6a7701 (Fariborz Jahanian        2011-02-13 20:01:48 +0000  2812)      if (Context.hasSameType(FromArgType, ToArgType)) {
4de45dc6a7701 (Fariborz Jahanian        2011-02-13 20:01:48 +0000  2813)        // Okay, the types match exactly. Nothing to do.
4de45dc6a7701 (Fariborz Jahanian        2011-02-13 20:01:48 +0000  2814)      } else if (isObjCPointerConversion(ToArgType, FromArgType,
4de45dc6a7701 (Fariborz Jahanian        2011-02-13 20:01:48 +0000  2815)                                         ConvertedType, IncompatibleObjC)) {
4de45dc6a7701 (Fariborz Jahanian        2011-02-13 20:01:48 +0000  2816)        if (IncompatibleObjC)
4de45dc6a7701 (Fariborz Jahanian        2011-02-13 20:01:48 +0000  2817)          return false;
4de45dc6a7701 (Fariborz Jahanian        2011-02-13 20:01:48 +0000  2818)        // Okay, we have an Objective-C pointer conversion.
4de45dc6a7701 (Fariborz Jahanian        2011-02-13 20:01:48 +0000  2819)      } else
4de45dc6a7701 (Fariborz Jahanian        2011-02-13 20:01:48 +0000  2820)        // Argument types are too different. Abort.
4de45dc6a7701 (Fariborz Jahanian        2011-02-13 20:01:48 +0000  2821)        return false;
4de45dc6a7701 (Fariborz Jahanian        2011-02-13 20:01:48 +0000  2822)    }
98a49337be3fd (Akira Hatanaka           2017-09-22 00:41:05 +0000  2823) 
98a49337be3fd (Akira Hatanaka           2017-09-22 00:41:05 +0000  2824)    SmallVector<FunctionProtoType::ExtParameterInfo, 4> NewParamInfos;
98a49337be3fd (Akira Hatanaka           2017-09-22 00:41:05 +0000  2825)    bool CanUseToFPT, CanUseFromFPT;
98a49337be3fd (Akira Hatanaka           2017-09-22 00:41:05 +0000  2826)    if (!Context.mergeExtParameterInfo(ToFunctionType, FromFunctionType,
98a49337be3fd (Akira Hatanaka           2017-09-22 00:41:05 +0000  2827)                                       CanUseToFPT, CanUseFromFPT,
98a49337be3fd (Akira Hatanaka           2017-09-22 00:41:05 +0000  2828)                                       NewParamInfos))
97676979a7eed (Fariborz Jahanian        2011-09-28 21:52:05 +0000  2829)      return false;
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  2830) 
4de45dc6a7701 (Fariborz Jahanian        2011-02-13 20:01:48 +0000  2831)    ConvertedType = ToType;
4de45dc6a7701 (Fariborz Jahanian        2011-02-13 20:01:48 +0000  2832)    return true;
42455ea935b04 (Fariborz Jahanian        2011-02-12 19:07:46 +0000  2833) }
42455ea935b04 (Fariborz Jahanian        2011-02-12 19:07:46 +0000  2834) 
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2835) enum {
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2836)   ft_default,
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2837)   ft_different_class,
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2838)   ft_parameter_arity,
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2839)   ft_parameter_mismatch,
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2840)   ft_return_type,
3c4f8d2e96c4b (Richard Smith            2016-10-16 17:54:23 +0000  2841)   ft_qualifer_mismatch,
3c4f8d2e96c4b (Richard Smith            2016-10-16 17:54:23 +0000  2842)   ft_noexcept
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2843) };
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2844) 
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000  2845) /// Attempts to get the FunctionProtoType from a Type. Handles
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000  2846) /// MemberFunctionPointers properly.
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000  2847) static const FunctionProtoType *tryGetFunctionProtoType(QualType FromType) {
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000  2848)   if (auto *FPT = FromType->getAs<FunctionProtoType>())
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000  2849)     return FPT;
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000  2850) 
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000  2851)   if (auto *MPT = FromType->getAs<MemberPointerType>())
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000  2852)     return MPT->getPointeeType()->getAs<FunctionProtoType>();
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000  2853) 
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000  2854)   return nullptr;
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000  2855) }
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000  2856) 
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2857) /// HandleFunctionTypeMismatch - Gives diagnostic information for differeing
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2858) /// function types.  Catches different number of parameter, mismatch in
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2859) /// parameter types, and different return types.
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2860) void Sema::HandleFunctionTypeMismatch(PartialDiagnostic &PDiag,
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2861)                                       QualType FromType, QualType ToType) {
96ed5b6b47666 (Richard Trieu            2011-12-13 23:19:45 +0000  2862)   // If either type is not valid, include no extra info.
96ed5b6b47666 (Richard Trieu            2011-12-13 23:19:45 +0000  2863)   if (FromType.isNull() || ToType.isNull()) {
96ed5b6b47666 (Richard Trieu            2011-12-13 23:19:45 +0000  2864)     PDiag << ft_default;
96ed5b6b47666 (Richard Trieu            2011-12-13 23:19:45 +0000  2865)     return;
96ed5b6b47666 (Richard Trieu            2011-12-13 23:19:45 +0000  2866)   }
96ed5b6b47666 (Richard Trieu            2011-12-13 23:19:45 +0000  2867) 
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2868)   // Get the function type from the pointers.
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2869)   if (FromType->isMemberPointerType() && ToType->isMemberPointerType()) {
ab9dbc1d124cd (Simon Pilgrim            2020-01-14 14:15:51 +0000  2870)     const auto *FromMember = FromType->castAs<MemberPointerType>(),
ab9dbc1d124cd (Simon Pilgrim            2020-01-14 14:15:51 +0000  2871)                *ToMember = ToType->castAs<MemberPointerType>();
9098c9f1a8220 (Richard Trieu            2014-05-22 01:39:16 +0000  2872)     if (!Context.hasSameType(FromMember->getClass(), ToMember->getClass())) {
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2873)       PDiag << ft_different_class << QualType(ToMember->getClass(), 0)
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2874)             << QualType(FromMember->getClass(), 0);
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2875)       return;
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2876)     }
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2877)     FromType = FromMember->getPointeeType();
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2878)     ToType = ToMember->getPointeeType();
96ed5b6b47666 (Richard Trieu            2011-12-13 23:19:45 +0000  2879)   }
96ed5b6b47666 (Richard Trieu            2011-12-13 23:19:45 +0000  2880) 
96ed5b6b47666 (Richard Trieu            2011-12-13 23:19:45 +0000  2881)   if (FromType->isPointerType())
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2882)     FromType = FromType->getPointeeType();
96ed5b6b47666 (Richard Trieu            2011-12-13 23:19:45 +0000  2883)   if (ToType->isPointerType())
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2884)     ToType = ToType->getPointeeType();
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2885) 
96ed5b6b47666 (Richard Trieu            2011-12-13 23:19:45 +0000  2886)   // Remove references.
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2887)   FromType = FromType.getNonReferenceType();
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2888)   ToType = ToType.getNonReferenceType();
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2889) 
96ed5b6b47666 (Richard Trieu            2011-12-13 23:19:45 +0000  2890)   // Don't print extra info for non-specialized template functions.
96ed5b6b47666 (Richard Trieu            2011-12-13 23:19:45 +0000  2891)   if (FromType->isInstantiationDependentType() &&
96ed5b6b47666 (Richard Trieu            2011-12-13 23:19:45 +0000  2892)       !FromType->getAs<TemplateSpecializationType>()) {
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2893)     PDiag << ft_default;
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2894)     return;
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2895)   }
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2896) 
96ed5b6b47666 (Richard Trieu            2011-12-13 23:19:45 +0000  2897)   // No extra info for same types.
96ed5b6b47666 (Richard Trieu            2011-12-13 23:19:45 +0000  2898)   if (Context.hasSameType(FromType, ToType)) {
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2899)     PDiag << ft_default;
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2900)     return;
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2901)   }
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2902) 
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000  2903)   const FunctionProtoType *FromFunction = tryGetFunctionProtoType(FromType),
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000  2904)                           *ToFunction = tryGetFunctionProtoType(ToType);
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2905) 
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2906)   // Both types need to be function types.
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2907)   if (!FromFunction || !ToFunction) {
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2908)     PDiag << ft_default;
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2909)     return;
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2910)   }
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2911) 
9cacbabd33eea (Alp Toker                2014-01-20 20:26:09 +0000  2912)   if (FromFunction->getNumParams() != ToFunction->getNumParams()) {
9cacbabd33eea (Alp Toker                2014-01-20 20:26:09 +0000  2913)     PDiag << ft_parameter_arity << ToFunction->getNumParams()
9cacbabd33eea (Alp Toker                2014-01-20 20:26:09 +0000  2914)           << FromFunction->getNumParams();
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2915)     return;
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2916)   }
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2917) 
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2918)   // Handle different parameter types.
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2919)   unsigned ArgPos;
9cacbabd33eea (Alp Toker                2014-01-20 20:26:09 +0000  2920)   if (!FunctionParamTypesAreEqual(FromFunction, ToFunction, &ArgPos)) {
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2921)     PDiag << ft_parameter_mismatch << ArgPos + 1
9cacbabd33eea (Alp Toker                2014-01-20 20:26:09 +0000  2922)           << ToFunction->getParamType(ArgPos)
9cacbabd33eea (Alp Toker                2014-01-20 20:26:09 +0000  2923)           << FromFunction->getParamType(ArgPos);
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2924)     return;
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2925)   }
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2926) 
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2927)   // Handle different return type.
314cc81b8caac (Alp Toker                2014-01-25 16:55:45 +0000  2928)   if (!Context.hasSameType(FromFunction->getReturnType(),
314cc81b8caac (Alp Toker                2014-01-25 16:55:45 +0000  2929)                            ToFunction->getReturnType())) {
314cc81b8caac (Alp Toker                2014-01-25 16:55:45 +0000  2930)     PDiag << ft_return_type << ToFunction->getReturnType()
314cc81b8caac (Alp Toker                2014-01-25 16:55:45 +0000  2931)           << FromFunction->getReturnType();
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2932)     return;
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2933)   }
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2934) 
c61eaa5920161 (Anastasia Stulova        2019-01-28 11:37:49 +0000  2935)   if (FromFunction->getMethodQuals() != ToFunction->getMethodQuals()) {
c61eaa5920161 (Anastasia Stulova        2019-01-28 11:37:49 +0000  2936)     PDiag << ft_qualifer_mismatch << ToFunction->getMethodQuals()
c61eaa5920161 (Anastasia Stulova        2019-01-28 11:37:49 +0000  2937)           << FromFunction->getMethodQuals();
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2938)     return;
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2939)   }
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2940) 
3c4f8d2e96c4b (Richard Smith            2016-10-16 17:54:23 +0000  2941)   // Handle exception specification differences on canonical type (in C++17
3c4f8d2e96c4b (Richard Smith            2016-10-16 17:54:23 +0000  2942)   // onwards).
3c4f8d2e96c4b (Richard Smith            2016-10-16 17:54:23 +0000  2943)   if (cast<FunctionProtoType>(FromFunction->getCanonicalTypeUnqualified())
eaf11ad709046 (Richard Smith            2018-05-03 03:58:32 +0000  2944)           ->isNothrow() !=
3c4f8d2e96c4b (Richard Smith            2016-10-16 17:54:23 +0000  2945)       cast<FunctionProtoType>(ToFunction->getCanonicalTypeUnqualified())
eaf11ad709046 (Richard Smith            2018-05-03 03:58:32 +0000  2946)           ->isNothrow()) {
3c4f8d2e96c4b (Richard Smith            2016-10-16 17:54:23 +0000  2947)     PDiag << ft_noexcept;
3c4f8d2e96c4b (Richard Smith            2016-10-16 17:54:23 +0000  2948)     return;
3c4f8d2e96c4b (Richard Smith            2016-10-16 17:54:23 +0000  2949)   }
3c4f8d2e96c4b (Richard Smith            2016-10-16 17:54:23 +0000  2950) 
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2951)   // Unable to find a difference, so add no extra info.
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2952)   PDiag << ft_default;
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2953) }
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000  2954) 
9cacbabd33eea (Alp Toker                2014-01-20 20:26:09 +0000  2955) /// FunctionParamTypesAreEqual - This routine checks two function proto types
2039ca061f07f (Douglas Gregor           2011-12-15 17:15:07 +0000  2956) /// for equality of their argument types. Caller has already checked that
5f508953bc478 (Eli Friedman             2013-06-18 22:41:37 +0000  2957) /// they have same number of arguments.  If the parameters are different,
5f508953bc478 (Eli Friedman             2013-06-18 22:41:37 +0000  2958) /// ArgPos will have the parameter index of the first different parameter.
9cacbabd33eea (Alp Toker                2014-01-20 20:26:09 +0000  2959) bool Sema::FunctionParamTypesAreEqual(const FunctionProtoType *OldType,
9cacbabd33eea (Alp Toker                2014-01-20 20:26:09 +0000  2960)                                       const FunctionProtoType *NewType,
9cacbabd33eea (Alp Toker                2014-01-20 20:26:09 +0000  2961)                                       unsigned *ArgPos) {
9cacbabd33eea (Alp Toker                2014-01-20 20:26:09 +0000  2962)   for (FunctionProtoType::param_type_iterator O = OldType->param_type_begin(),
9cacbabd33eea (Alp Toker                2014-01-20 20:26:09 +0000  2963)                                               N = NewType->param_type_begin(),
9cacbabd33eea (Alp Toker                2014-01-20 20:26:09 +0000  2964)                                               E = OldType->param_type_end();
9cacbabd33eea (Alp Toker                2014-01-20 20:26:09 +0000  2965)        O && (O != E); ++O, ++N) {
a85f5efd9597d (Amy Huang                2019-10-24 16:34:25 -0700  2966)     // Ignore address spaces in pointee type. This is to disallow overloading
a85f5efd9597d (Amy Huang                2019-10-24 16:34:25 -0700  2967)     // on __ptr32/__ptr64 address spaces.
a85f5efd9597d (Amy Huang                2019-10-24 16:34:25 -0700  2968)     QualType Old = Context.removePtrSizeAddrSpace(O->getUnqualifiedType());
a85f5efd9597d (Amy Huang                2019-10-24 16:34:25 -0700  2969)     QualType New = Context.removePtrSizeAddrSpace(N->getUnqualifiedType());
a85f5efd9597d (Amy Huang                2019-10-24 16:34:25 -0700  2970) 
a85f5efd9597d (Amy Huang                2019-10-24 16:34:25 -0700  2971)     if (!Context.hasSameType(Old, New)) {
9cacbabd33eea (Alp Toker                2014-01-20 20:26:09 +0000  2972)       if (ArgPos)
9cacbabd33eea (Alp Toker                2014-01-20 20:26:09 +0000  2973)         *ArgPos = O - OldType->param_type_begin();
4154f46c5a9aa (Larisse Voufo            2013-08-06 03:57:41 +0000  2974)       return false;
5e5998f014a2d (Fariborz Jahanian        2010-05-03 21:06:18 +0000  2975)     }
5e5998f014a2d (Fariborz Jahanian        2010-05-03 21:06:18 +0000  2976)   }
5e5998f014a2d (Fariborz Jahanian        2010-05-03 21:06:18 +0000  2977)   return true;
5e5998f014a2d (Fariborz Jahanian        2010-05-03 21:06:18 +0000  2978) }
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  2979) 
39c16d445e8e3 (Douglas Gregor           2008-10-24 04:54:22 +0000  2980) /// CheckPointerConversion - Check the pointer conversion from the
39c16d445e8e3 (Douglas Gregor           2008-10-24 04:54:22 +0000  2981) /// expression From to the type ToType. This routine checks for
9f831dbbcdfab (Sebastian Redl           2009-07-25 15:41:38 +0000  2982) /// ambiguous or inaccessible derived-to-base pointer
39c16d445e8e3 (Douglas Gregor           2008-10-24 04:54:22 +0000  2983) /// conversions for which IsPointerConversion has already returned
39c16d445e8e3 (Douglas Gregor           2008-10-24 04:54:22 +0000  2984) /// true. It returns true and produces a diagnostic if there was an
39c16d445e8e3 (Douglas Gregor           2008-10-24 04:54:22 +0000  2985) /// error, or returns false otherwise.
7ec8ccde01d1a (Anders Carlsson          2009-09-12 04:46:44 +0000  2986) bool Sema::CheckPointerConversion(Expr *From, QualType ToType,
e302792b6155b (John McCall              2010-08-25 11:45:40 +0000  2987)                                   CastKind &Kind,
cf1421650953d (John McCall              2010-08-07 06:22:56 +0000  2988)                                   CXXCastPath& BasePath,
60bc9725755e1 (George Burgess IV        2016-01-13 23:36:34 +0000  2989)                                   bool IgnoreBaseAccess,
60bc9725755e1 (George Burgess IV        2016-01-13 23:36:34 +0000  2990)                                   bool Diagnose) {
39c16d445e8e3 (Douglas Gregor           2008-10-24 04:54:22 +0000  2991)   QualType FromType = From->getType();
d6ea6bd2a3f54 (Argyrios Kyrtzidis       2010-09-28 14:54:11 +0000  2992)   bool IsCStyleOrFunctionalCast = IgnoreBaseAccess;
39c16d445e8e3 (Douglas Gregor           2008-10-24 04:54:22 +0000  2993) 
8cb679e4e1e20 (John McCall              2010-11-15 09:13:47 +0000  2994)   Kind = CK_BitCast;
8cb679e4e1e20 (John McCall              2010-11-15 09:13:47 +0000  2995) 
60bc9725755e1 (George Burgess IV        2016-01-13 23:36:34 +0000  2996)   if (Diagnose && !IsCStyleOrFunctionalCast && !FromType->isAnyPointerType() &&
3e3305dabaa26 (Argyrios Kyrtzidis       2014-02-02 05:26:43 +0000  2997)       From->isNullPointerConstant(Context, Expr::NPC_ValueDependentIsNotNull) ==
60bc9725755e1 (George Burgess IV        2016-01-13 23:36:34 +0000  2998)           Expr::NPCK_ZeroExpression) {
1c7c8f763769d (David Blaikie            2012-08-08 17:33:31 +0000  2999)     if (Context.hasSameUnqualifiedType(From->getType(), Context.BoolTy))
1c7c8f763769d (David Blaikie            2012-08-08 17:33:31 +0000  3000)       DiagRuntimeBehavior(From->getExprLoc(), From,
1c7c8f763769d (David Blaikie            2012-08-08 17:33:31 +0000  3001)                           PDiag(diag::warn_impcast_bool_to_null_pointer)
1c7c8f763769d (David Blaikie            2012-08-08 17:33:31 +0000  3002)                             << ToType << From->getSourceRange());
1c7c8f763769d (David Blaikie            2012-08-08 17:33:31 +0000  3003)     else if (!isUnevaluatedContext())
1c7c8f763769d (David Blaikie            2012-08-08 17:33:31 +0000  3004)       Diag(From->getExprLoc(), diag::warn_non_literal_null_pointer)
1c7c8f763769d (David Blaikie            2012-08-08 17:33:31 +0000  3005)         << ToType << From->getSourceRange();
1c7c8f763769d (David Blaikie            2012-08-08 17:33:31 +0000  3006)   }
9320b87cff21e (John McCall              2011-09-09 05:25:32 +0000  3007)   if (const PointerType *ToPtrType = ToType->getAs<PointerType>()) {
9320b87cff21e (John McCall              2011-09-09 05:25:32 +0000  3008)     if (const PointerType *FromPtrType = FromType->getAs<PointerType>()) {
39c16d445e8e3 (Douglas Gregor           2008-10-24 04:54:22 +0000  3009)       QualType FromPointeeType = FromPtrType->getPointeeType(),
39c16d445e8e3 (Douglas Gregor           2008-10-24 04:54:22 +0000  3010)                ToPointeeType   = ToPtrType->getPointeeType();
1e57a3fb46808 (Douglas Gregor           2008-12-18 23:43:31 +0000  3011) 
cc3f325fa69e7 (Douglas Gregor           2010-03-03 23:55:11 +0000  3012)       if (FromPointeeType->isRecordType() && ToPointeeType->isRecordType() &&
cc3f325fa69e7 (Douglas Gregor           2010-03-03 23:55:11 +0000  3013)           !Context.hasSameUnqualifiedType(FromPointeeType, ToPointeeType)) {
39c16d445e8e3 (Douglas Gregor           2008-10-24 04:54:22 +0000  3014)         // We must have a derived-to-base conversion. Check an
39c16d445e8e3 (Douglas Gregor           2008-10-24 04:54:22 +0000  3015)         // ambiguous or inaccessible conversion.
60bc9725755e1 (George Burgess IV        2016-01-13 23:36:34 +0000  3016)         unsigned InaccessibleID = 0;
68b30bc02b3a7 (Casey Carter             2020-04-28 14:50:52 -0700  3017)         unsigned AmbiguousID = 0;
60bc9725755e1 (George Burgess IV        2016-01-13 23:36:34 +0000  3018)         if (Diagnose) {
60bc9725755e1 (George Burgess IV        2016-01-13 23:36:34 +0000  3019)           InaccessibleID = diag::err_upcast_to_inaccessible_base;
68b30bc02b3a7 (Casey Carter             2020-04-28 14:50:52 -0700  3020)           AmbiguousID = diag::err_ambiguous_derived_to_base_conv;
60bc9725755e1 (George Burgess IV        2016-01-13 23:36:34 +0000  3021)         }
60bc9725755e1 (George Burgess IV        2016-01-13 23:36:34 +0000  3022)         if (CheckDerivedToBaseConversion(
68b30bc02b3a7 (Casey Carter             2020-04-28 14:50:52 -0700  3023)                 FromPointeeType, ToPointeeType, InaccessibleID, AmbiguousID,
60bc9725755e1 (George Burgess IV        2016-01-13 23:36:34 +0000  3024)                 From->getExprLoc(), From->getSourceRange(), DeclarationName(),
60bc9725755e1 (George Burgess IV        2016-01-13 23:36:34 +0000  3025)                 &BasePath, IgnoreBaseAccess))
7ec8ccde01d1a (Anders Carlsson          2009-09-12 04:46:44 +0000  3026)           return true;
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  3027) 
7ec8ccde01d1a (Anders Carlsson          2009-09-12 04:46:44 +0000  3028)         // The conversion was successful.
e302792b6155b (John McCall              2010-08-25 11:45:40 +0000  3029)         Kind = CK_DerivedToBase;
39c16d445e8e3 (Douglas Gregor           2008-10-24 04:54:22 +0000  3030)       }
6bf02820bced5 (David Majnemer           2015-10-31 08:42:14 +0000  3031) 
60bc9725755e1 (George Burgess IV        2016-01-13 23:36:34 +0000  3032)       if (Diagnose && !IsCStyleOrFunctionalCast &&
60bc9725755e1 (George Burgess IV        2016-01-13 23:36:34 +0000  3033)           FromPointeeType->isFunctionType() && ToPointeeType->isVoidType()) {
6bf02820bced5 (David Majnemer           2015-10-31 08:42:14 +0000  3034)         assert(getLangOpts().MSVCCompat &&
6bf02820bced5 (David Majnemer           2015-10-31 08:42:14 +0000  3035)                "this should only be possible with MSVCCompat!");
6bf02820bced5 (David Majnemer           2015-10-31 08:42:14 +0000  3036)         Diag(From->getExprLoc(), diag::ext_ms_impcast_fn_obj)
6bf02820bced5 (David Majnemer           2015-10-31 08:42:14 +0000  3037)             << From->getSourceRange();
6bf02820bced5 (David Majnemer           2015-10-31 08:42:14 +0000  3038)       }
39c16d445e8e3 (Douglas Gregor           2008-10-24 04:54:22 +0000  3039)     }
9320b87cff21e (John McCall              2011-09-09 05:25:32 +0000  3040)   } else if (const ObjCObjectPointerType *ToPtrType =
9320b87cff21e (John McCall              2011-09-09 05:25:32 +0000  3041)                ToType->getAs<ObjCObjectPointerType>()) {
9320b87cff21e (John McCall              2011-09-09 05:25:32 +0000  3042)     if (const ObjCObjectPointerType *FromPtrType =
9320b87cff21e (John McCall              2011-09-09 05:25:32 +0000  3043)           FromType->getAs<ObjCObjectPointerType>()) {
7cae42b07a3aa (Steve Naroff             2009-07-10 23:34:53 +0000  3044)       // Objective-C++ conversions are always okay.
7cae42b07a3aa (Steve Naroff             2009-07-10 23:34:53 +0000  3045)       // FIXME: We should have a different class of conversions for the
7cae42b07a3aa (Steve Naroff             2009-07-10 23:34:53 +0000  3046)       // Objective-C++ implicit conversions.
1329fa0ed9162 (Steve Naroff             2009-07-15 18:40:39 +0000  3047)       if (FromPtrType->isObjCBuiltinType() || ToPtrType->isObjCBuiltinType())
7cae42b07a3aa (Steve Naroff             2009-07-10 23:34:53 +0000  3048)         return false;
9320b87cff21e (John McCall              2011-09-09 05:25:32 +0000  3049)     } else if (FromType->isBlockPointerType()) {
9320b87cff21e (John McCall              2011-09-09 05:25:32 +0000  3050)       Kind = CK_BlockPointerToObjCPointerCast;
9320b87cff21e (John McCall              2011-09-09 05:25:32 +0000  3051)     } else {
9320b87cff21e (John McCall              2011-09-09 05:25:32 +0000  3052)       Kind = CK_CPointerToObjCPointerCast;
8cb679e4e1e20 (John McCall              2010-11-15 09:13:47 +0000  3053)     }
9320b87cff21e (John McCall              2011-09-09 05:25:32 +0000  3054)   } else if (ToType->isBlockPointerType()) {
9320b87cff21e (John McCall              2011-09-09 05:25:32 +0000  3055)     if (!FromType->isBlockPointerType())
9320b87cff21e (John McCall              2011-09-09 05:25:32 +0000  3056)       Kind = CK_AnyPointerToBlockPointerCast;
7cae42b07a3aa (Steve Naroff             2009-07-10 23:34:53 +0000  3057)   }
8cb679e4e1e20 (John McCall              2010-11-15 09:13:47 +0000  3058) 
8cb679e4e1e20 (John McCall              2010-11-15 09:13:47 +0000  3059)   // We shouldn't fall into this case unless it's valid for other
8cb679e4e1e20 (John McCall              2010-11-15 09:13:47 +0000  3060)   // reasons.
8cb679e4e1e20 (John McCall              2010-11-15 09:13:47 +0000  3061)   if (From->isNullPointerConstant(Context, Expr::NPC_ValueDependentIsNull))
8cb679e4e1e20 (John McCall              2010-11-15 09:13:47 +0000  3062)     Kind = CK_NullToPointer;
8cb679e4e1e20 (John McCall              2010-11-15 09:13:47 +0000  3063) 
39c16d445e8e3 (Douglas Gregor           2008-10-24 04:54:22 +0000  3064)   return false;
39c16d445e8e3 (Douglas Gregor           2008-10-24 04:54:22 +0000  3065) }
39c16d445e8e3 (Douglas Gregor           2008-10-24 04:54:22 +0000  3066) 
72b597d6b6ae7 (Sebastian Redl           2009-01-25 19:43:20 +0000  3067) /// IsMemberPointerConversion - Determines whether the conversion of the
72b597d6b6ae7 (Sebastian Redl           2009-01-25 19:43:20 +0000  3068) /// expression From, which has the (possibly adjusted) type FromType, can be
72b597d6b6ae7 (Sebastian Redl           2009-01-25 19:43:20 +0000  3069) /// converted to the type ToType via a member pointer conversion (C++ 4.11).
72b597d6b6ae7 (Sebastian Redl           2009-01-25 19:43:20 +0000  3070) /// If so, returns true and places the converted type (that might differ from
72b597d6b6ae7 (Sebastian Redl           2009-01-25 19:43:20 +0000  3071) /// ToType in its cv-qualifiers at some level) into ConvertedType.
72b597d6b6ae7 (Sebastian Redl           2009-01-25 19:43:20 +0000  3072) bool Sema::IsMemberPointerConversion(Expr *From, QualType FromType,
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  3073)                                      QualType ToType,
56751b5981c3b (Douglas Gregor           2009-09-25 04:25:58 +0000  3074)                                      bool InOverloadResolution,
56751b5981c3b (Douglas Gregor           2009-09-25 04:25:58 +0000  3075)                                      QualType &ConvertedType) {
c23c7e6a51927 (Ted Kremenek             2009-07-29 21:53:49 +0000  3076)   const MemberPointerType *ToTypePtr = ToType->getAs<MemberPointerType>();
72b597d6b6ae7 (Sebastian Redl           2009-01-25 19:43:20 +0000  3077)   if (!ToTypePtr)
72b597d6b6ae7 (Sebastian Redl           2009-01-25 19:43:20 +0000  3078)     return false;
72b597d6b6ae7 (Sebastian Redl           2009-01-25 19:43:20 +0000  3079) 
72b597d6b6ae7 (Sebastian Redl           2009-01-25 19:43:20 +0000  3080)   // A null pointer constant can be converted to a member pointer (C++ 4.11p1)
56751b5981c3b (Douglas Gregor           2009-09-25 04:25:58 +0000  3081)   if (From->isNullPointerConstant(Context,
56751b5981c3b (Douglas Gregor           2009-09-25 04:25:58 +0000  3082)                     InOverloadResolution? Expr::NPC_ValueDependentIsNotNull
56751b5981c3b (Douglas Gregor           2009-09-25 04:25:58 +0000  3083)                                         : Expr::NPC_ValueDependentIsNull)) {
72b597d6b6ae7 (Sebastian Redl           2009-01-25 19:43:20 +0000  3084)     ConvertedType = ToType;
72b597d6b6ae7 (Sebastian Redl           2009-01-25 19:43:20 +0000  3085)     return true;
72b597d6b6ae7 (Sebastian Redl           2009-01-25 19:43:20 +0000  3086)   }
72b597d6b6ae7 (Sebastian Redl           2009-01-25 19:43:20 +0000  3087) 
72b597d6b6ae7 (Sebastian Redl           2009-01-25 19:43:20 +0000  3088)   // Otherwise, both types have to be member pointers.
c23c7e6a51927 (Ted Kremenek             2009-07-29 21:53:49 +0000  3089)   const MemberPointerType *FromTypePtr = FromType->getAs<MemberPointerType>();
72b597d6b6ae7 (Sebastian Redl           2009-01-25 19:43:20 +0000  3090)   if (!FromTypePtr)
72b597d6b6ae7 (Sebastian Redl           2009-01-25 19:43:20 +0000  3091)     return false;
72b597d6b6ae7 (Sebastian Redl           2009-01-25 19:43:20 +0000  3092) 
72b597d6b6ae7 (Sebastian Redl           2009-01-25 19:43:20 +0000  3093)   // A pointer to member of B can be converted to a pointer to member of D,
72b597d6b6ae7 (Sebastian Redl           2009-01-25 19:43:20 +0000  3094)   // where D is derived from B (C++ 4.11p2).
72b597d6b6ae7 (Sebastian Redl           2009-01-25 19:43:20 +0000  3095)   QualType FromClass(FromTypePtr->getClass(), 0);
72b597d6b6ae7 (Sebastian Redl           2009-01-25 19:43:20 +0000  3096)   QualType ToClass(ToTypePtr->getClass(), 0);
72b597d6b6ae7 (Sebastian Redl           2009-01-25 19:43:20 +0000  3097) 
7f6ae6958cbc2 (Douglas Gregor           2010-12-21 21:40:41 +0000  3098)   if (!Context.hasSameUnqualifiedType(FromClass, ToClass) &&
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  3099)       IsDerivedFrom(From->getBeginLoc(), ToClass, FromClass)) {
72b597d6b6ae7 (Sebastian Redl           2009-01-25 19:43:20 +0000  3100)     ConvertedType = Context.getMemberPointerType(FromTypePtr->getPointeeType(),
72b597d6b6ae7 (Sebastian Redl           2009-01-25 19:43:20 +0000  3101)                                                  ToClass.getTypePtr());
72b597d6b6ae7 (Sebastian Redl           2009-01-25 19:43:20 +0000  3102)     return true;
72b597d6b6ae7 (Sebastian Redl           2009-01-25 19:43:20 +0000  3103)   }
72b597d6b6ae7 (Sebastian Redl           2009-01-25 19:43:20 +0000  3104) 
72b597d6b6ae7 (Sebastian Redl           2009-01-25 19:43:20 +0000  3105)   return false;
72b597d6b6ae7 (Sebastian Redl           2009-01-25 19:43:20 +0000  3106) }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  3107) 
72b597d6b6ae7 (Sebastian Redl           2009-01-25 19:43:20 +0000  3108) /// CheckMemberPointerConversion - Check the member pointer conversion from the
72b597d6b6ae7 (Sebastian Redl           2009-01-25 19:43:20 +0000  3109) /// expression From to the type ToType. This routine checks for ambiguous or
5b0829a321d56 (John McCall              2010-02-10 09:31:12 +0000  3110) /// virtual or inaccessible base-to-derived member pointer conversions
72b597d6b6ae7 (Sebastian Redl           2009-01-25 19:43:20 +0000  3111) /// for which IsMemberPointerConversion has already returned true. It returns
72b597d6b6ae7 (Sebastian Redl           2009-01-25 19:43:20 +0000  3112) /// true and produces a diagnostic if there was an error, or returns false
72b597d6b6ae7 (Sebastian Redl           2009-01-25 19:43:20 +0000  3113) /// otherwise.
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  3114) bool Sema::CheckMemberPointerConversion(Expr *From, QualType ToType,
e302792b6155b (John McCall              2010-08-25 11:45:40 +0000  3115)                                         CastKind &Kind,
cf1421650953d (John McCall              2010-08-07 06:22:56 +0000  3116)                                         CXXCastPath &BasePath,
7c353685bcb7f (Sebastian Redl           2009-11-14 21:15:49 +0000  3117)                                         bool IgnoreBaseAccess) {
72b597d6b6ae7 (Sebastian Redl           2009-01-25 19:43:20 +0000  3118)   QualType FromType = From->getType();
c23c7e6a51927 (Ted Kremenek             2009-07-29 21:53:49 +0000  3119)   const MemberPointerType *FromPtrType = FromType->getAs<MemberPointerType>();
d7923c6ed7ad6 (Anders Carlsson          2009-08-22 23:33:40 +0000  3120)   if (!FromPtrType) {
d7923c6ed7ad6 (Anders Carlsson          2009-08-22 23:33:40 +0000  3121)     // This must be a null pointer to member pointer conversion
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  3122)     assert(From->isNullPointerConstant(Context,
56751b5981c3b (Douglas Gregor           2009-09-25 04:25:58 +0000  3123)                                        Expr::NPC_ValueDependentIsNull) &&
d7923c6ed7ad6 (Anders Carlsson          2009-08-22 23:33:40 +0000  3124)            "Expr must be null pointer constant!");
e302792b6155b (John McCall              2010-08-25 11:45:40 +0000  3125)     Kind = CK_NullToMemberPointer;
ed8f2003185cc (Sebastian Redl           2009-01-28 18:33:18 +0000  3126)     return false;
d7923c6ed7ad6 (Anders Carlsson          2009-08-22 23:33:40 +0000  3127)   }
72b597d6b6ae7 (Sebastian Redl           2009-01-25 19:43:20 +0000  3128) 
c23c7e6a51927 (Ted Kremenek             2009-07-29 21:53:49 +0000  3129)   const MemberPointerType *ToPtrType = ToType->getAs<MemberPointerType>();
ed8f2003185cc (Sebastian Redl           2009-01-28 18:33:18 +0000  3130)   assert(ToPtrType && "No member pointer cast has a target type "
ed8f2003185cc (Sebastian Redl           2009-01-28 18:33:18 +0000  3131)                       "that is not a member pointer.");
ed8f2003185cc (Sebastian Redl           2009-01-28 18:33:18 +0000  3132) 
ed8f2003185cc (Sebastian Redl           2009-01-28 18:33:18 +0000  3133)   QualType FromClass = QualType(FromPtrType->getClass(), 0);
ed8f2003185cc (Sebastian Redl           2009-01-28 18:33:18 +0000  3134)   QualType ToClass   = QualType(ToPtrType->getClass(), 0);
ed8f2003185cc (Sebastian Redl           2009-01-28 18:33:18 +0000  3135) 
ed8f2003185cc (Sebastian Redl           2009-01-28 18:33:18 +0000  3136)   // FIXME: What about dependent types?
ed8f2003185cc (Sebastian Redl           2009-01-28 18:33:18 +0000  3137)   assert(FromClass->isRecordType() && "Pointer into non-class.");
ed8f2003185cc (Sebastian Redl           2009-01-28 18:33:18 +0000  3138)   assert(ToClass->isRecordType() && "Pointer into non-class.");
ed8f2003185cc (Sebastian Redl           2009-01-28 18:33:18 +0000  3139) 
7d3360f123182 (Anders Carlsson          2010-04-24 19:36:51 +0000  3140)   CXXBasePaths Paths(/*FindAmbiguities=*/true, /*RecordPaths=*/true,
36d1b14ddedb3 (Douglas Gregor           2009-10-06 17:59:45 +0000  3141)                      /*DetectVirtual=*/true);
0f59cb38e7f31 (Richard Smith            2015-12-18 21:45:41 +0000  3142)   bool DerivationOkay =
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  3143)       IsDerivedFrom(From->getBeginLoc(), ToClass, FromClass, Paths);
ed8f2003185cc (Sebastian Redl           2009-01-28 18:33:18 +0000  3144)   assert(DerivationOkay &&
ed8f2003185cc (Sebastian Redl           2009-01-28 18:33:18 +0000  3145)          "Should not have been called if derivation isn't OK.");
ed8f2003185cc (Sebastian Redl           2009-01-28 18:33:18 +0000  3146)   (void)DerivationOkay;
ed8f2003185cc (Sebastian Redl           2009-01-28 18:33:18 +0000  3147) 
ed8f2003185cc (Sebastian Redl           2009-01-28 18:33:18 +0000  3148)   if (Paths.isAmbiguous(Context.getCanonicalType(FromClass).
ed8f2003185cc (Sebastian Redl           2009-01-28 18:33:18 +0000  3149)                                   getUnqualifiedType())) {
ed8f2003185cc (Sebastian Redl           2009-01-28 18:33:18 +0000  3150)     std::string PathDisplayStr = getAmbiguousPathsDisplayString(Paths);
ed8f2003185cc (Sebastian Redl           2009-01-28 18:33:18 +0000  3151)     Diag(From->getExprLoc(), diag::err_ambiguous_memptr_conv)
ed8f2003185cc (Sebastian Redl           2009-01-28 18:33:18 +0000  3152)       << 0 << FromClass << ToClass << PathDisplayStr << From->getSourceRange();
ed8f2003185cc (Sebastian Redl           2009-01-28 18:33:18 +0000  3153)     return true;
ed8f2003185cc (Sebastian Redl           2009-01-28 18:33:18 +0000  3154)   }
72b597d6b6ae7 (Sebastian Redl           2009-01-25 19:43:20 +0000  3155) 
89ee6822d8a6a (Douglas Gregor           2009-02-28 01:32:25 +0000  3156)   if (const RecordType *VBase = Paths.getDetectedVirtual()) {
ed8f2003185cc (Sebastian Redl           2009-01-28 18:33:18 +0000  3157)     Diag(From->getExprLoc(), diag::err_memptr_conv_via_virtual)
ed8f2003185cc (Sebastian Redl           2009-01-28 18:33:18 +0000  3158)       << FromClass << ToClass << QualType(VBase, 0)
ed8f2003185cc (Sebastian Redl           2009-01-28 18:33:18 +0000  3159)       << From->getSourceRange();
ed8f2003185cc (Sebastian Redl           2009-01-28 18:33:18 +0000  3160)     return true;
72b597d6b6ae7 (Sebastian Redl           2009-01-25 19:43:20 +0000  3161)   }
ed8f2003185cc (Sebastian Redl           2009-01-28 18:33:18 +0000  3162) 
5b0829a321d56 (John McCall              2010-02-10 09:31:12 +0000  3163)   if (!IgnoreBaseAccess)
1064d7ef29922 (John McCall              2010-03-16 05:22:47 +0000  3164)     CheckBaseClassAccess(From->getExprLoc(), FromClass, ToClass,
1064d7ef29922 (John McCall              2010-03-16 05:22:47 +0000  3165)                          Paths.front(),
1064d7ef29922 (John McCall              2010-03-16 05:22:47 +0000  3166)                          diag::err_downcast_from_inaccessible_base);
5b0829a321d56 (John McCall              2010-02-10 09:31:12 +0000  3167) 
d7923c6ed7ad6 (Anders Carlsson          2009-08-22 23:33:40 +0000  3168)   // Must be a base to derived member conversion.
7d3360f123182 (Anders Carlsson          2010-04-24 19:36:51 +0000  3169)   BuildBasePathArray(Paths, BasePath);
e302792b6155b (John McCall              2010-08-25 11:45:40 +0000  3170)   Kind = CK_BaseToDerivedMemberPointer;
72b597d6b6ae7 (Sebastian Redl           2009-01-25 19:43:20 +0000  3171)   return false;
72b597d6b6ae7 (Sebastian Redl           2009-01-25 19:43:20 +0000  3172) }
72b597d6b6ae7 (Sebastian Redl           2009-01-25 19:43:20 +0000  3173) 
c9f019ab0f95e (Douglas Gregor           2013-11-08 02:04:24 +0000  3174) /// Determine whether the lifetime conversion between the two given
c9f019ab0f95e (Douglas Gregor           2013-11-08 02:04:24 +0000  3175) /// qualifiers sets is nontrivial.
c9f019ab0f95e (Douglas Gregor           2013-11-08 02:04:24 +0000  3176) static bool isNonTrivialObjCLifetimeConversion(Qualifiers FromQuals,
c9f019ab0f95e (Douglas Gregor           2013-11-08 02:04:24 +0000  3177)                                                Qualifiers ToQuals) {
c9f019ab0f95e (Douglas Gregor           2013-11-08 02:04:24 +0000  3178)   // Converting anything to const __unsafe_unretained is trivial.
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  3179)   if (ToQuals.hasConst() &&
c9f019ab0f95e (Douglas Gregor           2013-11-08 02:04:24 +0000  3180)       ToQuals.getObjCLifetime() == Qualifiers::OCL_ExplicitNone)
c9f019ab0f95e (Douglas Gregor           2013-11-08 02:04:24 +0000  3181)     return false;
c9f019ab0f95e (Douglas Gregor           2013-11-08 02:04:24 +0000  3182) 
c9f019ab0f95e (Douglas Gregor           2013-11-08 02:04:24 +0000  3183)   return true;
c9f019ab0f95e (Douglas Gregor           2013-11-08 02:04:24 +0000  3184) }
c9f019ab0f95e (Douglas Gregor           2013-11-08 02:04:24 +0000  3185) 
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3186) /// Perform a single iteration of the loop for checking if a qualification
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3187) /// conversion is valid.
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3188) ///
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3189) /// Specifically, check whether any change between the qualifiers of \p
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3190) /// FromType and \p ToType is permissible, given knowledge about whether every
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3191) /// outer layer is const-qualified.
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3192) static bool isQualificationConversionStep(QualType FromType, QualType ToType,
6064f426a1830 (Anastasia Stulova        2020-02-06 11:56:21 +0000  3193)                                           bool CStyle, bool IsTopLevel,
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3194)                                           bool &PreviousToQualsIncludeConst,
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3195)                                           bool &ObjCLifetimeConversion) {
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3196)   Qualifiers FromQuals = FromType.getQualifiers();
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3197)   Qualifiers ToQuals = ToType.getQualifiers();
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3198) 
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3199)   // Ignore __unaligned qualifier if this type is void.
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3200)   if (ToType.getUnqualifiedType()->isVoidType())
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3201)     FromQuals.removeUnaligned();
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3202) 
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3203)   // Objective-C ARC:
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3204)   //   Check Objective-C lifetime conversions.
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3205)   if (FromQuals.getObjCLifetime() != ToQuals.getObjCLifetime()) {
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3206)     if (ToQuals.compatiblyIncludesObjCLifetime(FromQuals)) {
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3207)       if (isNonTrivialObjCLifetimeConversion(FromQuals, ToQuals))
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3208)         ObjCLifetimeConversion = true;
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3209)       FromQuals.removeObjCLifetime();
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3210)       ToQuals.removeObjCLifetime();
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3211)     } else {
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3212)       // Qualification conversions cannot cast between different
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3213)       // Objective-C lifetime qualifiers.
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3214)       return false;
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3215)     }
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3216)   }
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3217) 
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3218)   // Allow addition/removal of GC attributes but not changing GC attributes.
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3219)   if (FromQuals.getObjCGCAttr() != ToQuals.getObjCGCAttr() &&
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3220)       (!FromQuals.hasObjCGCAttr() || !ToQuals.hasObjCGCAttr())) {
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3221)     FromQuals.removeObjCGCAttr();
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3222)     ToQuals.removeObjCGCAttr();
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3223)   }
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3224) 
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3225)   //   -- for every j > 0, if const is in cv 1,j then const is in cv
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3226)   //      2,j, and similarly for volatile.
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3227)   if (!CStyle && !ToQuals.compatiblyIncludes(FromQuals))
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3228)     return false;
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3229) 
6064f426a1830 (Anastasia Stulova        2020-02-06 11:56:21 +0000  3230)   // If address spaces mismatch:
6064f426a1830 (Anastasia Stulova        2020-02-06 11:56:21 +0000  3231)   //  - in top level it is only valid to convert to addr space that is a
6064f426a1830 (Anastasia Stulova        2020-02-06 11:56:21 +0000  3232)   //    superset in all cases apart from C-style casts where we allow
6064f426a1830 (Anastasia Stulova        2020-02-06 11:56:21 +0000  3233)   //    conversions between overlapping address spaces.
6064f426a1830 (Anastasia Stulova        2020-02-06 11:56:21 +0000  3234)   //  - in non-top levels it is not a valid conversion.
6064f426a1830 (Anastasia Stulova        2020-02-06 11:56:21 +0000  3235)   if (ToQuals.getAddressSpace() != FromQuals.getAddressSpace() &&
6064f426a1830 (Anastasia Stulova        2020-02-06 11:56:21 +0000  3236)       (!IsTopLevel ||
6064f426a1830 (Anastasia Stulova        2020-02-06 11:56:21 +0000  3237)        !(ToQuals.isAddressSpaceSupersetOf(FromQuals) ||
6064f426a1830 (Anastasia Stulova        2020-02-06 11:56:21 +0000  3238)          (CStyle && FromQuals.isAddressSpaceSupersetOf(ToQuals)))))
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3239)     return false;
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3240) 
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3241)   //   -- if the cv 1,j and cv 2,j are different, then const is in
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3242)   //      every cv for 0 < k < j.
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3243)   if (!CStyle && FromQuals.getCVRQualifiers() != ToQuals.getCVRQualifiers() &&
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3244)       !PreviousToQualsIncludeConst)
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3245)     return false;
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3246) 
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3247)   // Keep track of whether all prior cv-qualifiers in the "to" type
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3248)   // include const.
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3249)   PreviousToQualsIncludeConst =
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3250)       PreviousToQualsIncludeConst && ToQuals.hasConst();
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3251)   return true;
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3252) }
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3253) 
9a6579340fabd (Douglas Gregor           2008-10-21 23:43:52 +0000  3254) /// IsQualificationConversion - Determines whether the conversion from
9a6579340fabd (Douglas Gregor           2008-10-21 23:43:52 +0000  3255) /// an rvalue of type FromType to ToType is a qualification conversion
9a6579340fabd (Douglas Gregor           2008-10-21 23:43:52 +0000  3256) /// (C++ 4.4).
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  3257) ///
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  3258) /// \param ObjCLifetimeConversion Output parameter that will be set to indicate
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  3259) /// when the qualification conversion involves a change in the Objective-C
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  3260) /// object lifetime.
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  3261) bool
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  3262) Sema::IsQualificationConversion(QualType FromType, QualType ToType,
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  3263)                                 bool CStyle, bool &ObjCLifetimeConversion) {
9a6579340fabd (Douglas Gregor           2008-10-21 23:43:52 +0000  3264)   FromType = Context.getCanonicalType(FromType);
9a6579340fabd (Douglas Gregor           2008-10-21 23:43:52 +0000  3265)   ToType = Context.getCanonicalType(ToType);
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  3266)   ObjCLifetimeConversion = false;
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  3267) 
9a6579340fabd (Douglas Gregor           2008-10-21 23:43:52 +0000  3268)   // If FromType and ToType are the same type, this is not a
9a6579340fabd (Douglas Gregor           2008-10-21 23:43:52 +0000  3269)   // qualification conversion.
cbdffb15856e4 (Sebastian Redl           2010-02-03 19:36:07 +0000  3270)   if (FromType.getUnqualifiedType() == ToType.getUnqualifiedType())
9a6579340fabd (Douglas Gregor           2008-10-21 23:43:52 +0000  3271)     return false;
ed8f2003185cc (Sebastian Redl           2009-01-28 18:33:18 +0000  3272) 
9a6579340fabd (Douglas Gregor           2008-10-21 23:43:52 +0000  3273)   // (C++ 4.4p4):
9a6579340fabd (Douglas Gregor           2008-10-21 23:43:52 +0000  3274)   //   A conversion can add cv-qualifiers at levels other than the first
9a6579340fabd (Douglas Gregor           2008-10-21 23:43:52 +0000  3275)   //   in multi-level pointers, subject to the following rules: [...]
9a6579340fabd (Douglas Gregor           2008-10-21 23:43:52 +0000  3276)   bool PreviousToQualsIncludeConst = true;
9a6579340fabd (Douglas Gregor           2008-10-21 23:43:52 +0000  3277)   bool UnwrappedAnyPointer = false;
a3405ffcecc6a (Richard Smith            2018-07-11 00:19:19 +0000  3278)   while (Context.UnwrapSimilarTypes(FromType, ToType)) {
6064f426a1830 (Anastasia Stulova        2020-02-06 11:56:21 +0000  3279)     if (!isQualificationConversionStep(
6064f426a1830 (Anastasia Stulova        2020-02-06 11:56:21 +0000  3280)             FromType, ToType, CStyle, !UnwrappedAnyPointer,
6064f426a1830 (Anastasia Stulova        2020-02-06 11:56:21 +0000  3281)             PreviousToQualsIncludeConst, ObjCLifetimeConversion))
d8018233d1ea4 (David Blaikie            2019-12-27 12:17:01 -0800  3282)       return false;
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3283)     UnwrappedAnyPointer = true;
99a9f75948598 (Yaxun Liu                2018-07-20 11:32:51 +0000  3284)   }
99a9f75948598 (Yaxun Liu                2018-07-20 11:32:51 +0000  3285) 
9a6579340fabd (Douglas Gregor           2008-10-21 23:43:52 +0000  3286)   // We are left with FromType and ToType being the pointee types
9a6579340fabd (Douglas Gregor           2008-10-21 23:43:52 +0000  3287)   // after unwrapping the original FromType and ToType the same number
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  3288)   // of times. If we unwrapped any pointers, and if FromType and
9a6579340fabd (Douglas Gregor           2008-10-21 23:43:52 +0000  3289)   // ToType have the same unqualified type (since we checked
9a6579340fabd (Douglas Gregor           2008-10-21 23:43:52 +0000  3290)   // qualifiers above), then this is a qualification conversion.
1b8fe5b716b8b (Douglas Gregor           2009-11-16 21:35:15 +0000  3291)   return UnwrappedAnyPointer && Context.hasSameUnqualifiedType(FromType,ToType);
9a6579340fabd (Douglas Gregor           2008-10-21 23:43:52 +0000  3292) }
9a6579340fabd (Douglas Gregor           2008-10-21 23:43:52 +0000  3293) 
9fc8faf9e6197 (Adrian Prantl            2018-05-09 01:00:01 +0000  3294) /// - Determine whether this is a conversion from a scalar type to an
c79862f017e37 (Douglas Gregor           2012-04-12 17:51:55 +0000  3295) /// atomic type.
c79862f017e37 (Douglas Gregor           2012-04-12 17:51:55 +0000  3296) ///
c79862f017e37 (Douglas Gregor           2012-04-12 17:51:55 +0000  3297) /// If successful, updates \c SCS's second and third steps in the conversion
c79862f017e37 (Douglas Gregor           2012-04-12 17:51:55 +0000  3298) /// sequence to finish the conversion.
f9e36cccb5910 (Douglas Gregor           2012-04-12 20:48:09 +0000  3299) static bool tryAtomicConversion(Sema &S, Expr *From, QualType ToType,
f9e36cccb5910 (Douglas Gregor           2012-04-12 20:48:09 +0000  3300)                                 bool InOverloadResolution,
f9e36cccb5910 (Douglas Gregor           2012-04-12 20:48:09 +0000  3301)                                 StandardConversionSequence &SCS,
f9e36cccb5910 (Douglas Gregor           2012-04-12 20:48:09 +0000  3302)                                 bool CStyle) {
c79862f017e37 (Douglas Gregor           2012-04-12 17:51:55 +0000  3303)   const AtomicType *ToAtomic = ToType->getAs<AtomicType>();
c79862f017e37 (Douglas Gregor           2012-04-12 17:51:55 +0000  3304)   if (!ToAtomic)
c79862f017e37 (Douglas Gregor           2012-04-12 17:51:55 +0000  3305)     return false;
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  3306) 
c79862f017e37 (Douglas Gregor           2012-04-12 17:51:55 +0000  3307)   StandardConversionSequence InnerSCS;
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  3308)   if (!IsStandardConversion(S, From, ToAtomic->getValueType(),
c79862f017e37 (Douglas Gregor           2012-04-12 17:51:55 +0000  3309)                             InOverloadResolution, InnerSCS,
c79862f017e37 (Douglas Gregor           2012-04-12 17:51:55 +0000  3310)                             CStyle, /*AllowObjCWritebackConversion=*/false))
c79862f017e37 (Douglas Gregor           2012-04-12 17:51:55 +0000  3311)     return false;
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  3312) 
c79862f017e37 (Douglas Gregor           2012-04-12 17:51:55 +0000  3313)   SCS.Second = InnerSCS.Second;
c79862f017e37 (Douglas Gregor           2012-04-12 17:51:55 +0000  3314)   SCS.setToType(1, InnerSCS.getToType(1));
c79862f017e37 (Douglas Gregor           2012-04-12 17:51:55 +0000  3315)   SCS.Third = InnerSCS.Third;
c79862f017e37 (Douglas Gregor           2012-04-12 17:51:55 +0000  3316)   SCS.QualificationIncludesObjCLifetime
c79862f017e37 (Douglas Gregor           2012-04-12 17:51:55 +0000  3317)     = InnerSCS.QualificationIncludesObjCLifetime;
c79862f017e37 (Douglas Gregor           2012-04-12 17:51:55 +0000  3318)   SCS.setToType(2, InnerSCS.getToType(2));
c79862f017e37 (Douglas Gregor           2012-04-12 17:51:55 +0000  3319)   return true;
c79862f017e37 (Douglas Gregor           2012-04-12 17:51:55 +0000  3320) }
c79862f017e37 (Douglas Gregor           2012-04-12 17:51:55 +0000  3321) 
e541716286fe6 (Sebastian Redl           2012-03-27 18:33:03 +0000  3322) static bool isFirstArgumentCompatibleWithType(ASTContext &Context,
e541716286fe6 (Sebastian Redl           2012-03-27 18:33:03 +0000  3323)                                               CXXConstructorDecl *Constructor,
e541716286fe6 (Sebastian Redl           2012-03-27 18:33:03 +0000  3324)                                               QualType Type) {
ab9dbc1d124cd (Simon Pilgrim            2020-01-14 14:15:51 +0000  3325)   const auto *CtorType = Constructor->getType()->castAs<FunctionProtoType>();
9cacbabd33eea (Alp Toker                2014-01-20 20:26:09 +0000  3326)   if (CtorType->getNumParams() > 0) {
9cacbabd33eea (Alp Toker                2014-01-20 20:26:09 +0000  3327)     QualType FirstArg = CtorType->getParamType(0);
e541716286fe6 (Sebastian Redl           2012-03-27 18:33:03 +0000  3328)     if (Context.hasSameUnqualifiedType(Type, FirstArg.getNonReferenceType()))
e541716286fe6 (Sebastian Redl           2012-03-27 18:33:03 +0000  3329)       return true;
e541716286fe6 (Sebastian Redl           2012-03-27 18:33:03 +0000  3330)   }
e541716286fe6 (Sebastian Redl           2012-03-27 18:33:03 +0000  3331)   return false;
e541716286fe6 (Sebastian Redl           2012-03-27 18:33:03 +0000  3332) }
e541716286fe6 (Sebastian Redl           2012-03-27 18:33:03 +0000  3333) 
82ace98d5505e (Sebastian Redl           2012-02-11 23:51:08 +0000  3334) static OverloadingResult
82ace98d5505e (Sebastian Redl           2012-02-11 23:51:08 +0000  3335) IsInitializerListConstructorConversion(Sema &S, Expr *From, QualType ToType,
82ace98d5505e (Sebastian Redl           2012-02-11 23:51:08 +0000  3336)                                        CXXRecordDecl *To,
82ace98d5505e (Sebastian Redl           2012-02-11 23:51:08 +0000  3337)                                        UserDefinedConversionSequence &User,
82ace98d5505e (Sebastian Redl           2012-02-11 23:51:08 +0000  3338)                                        OverloadCandidateSet &CandidateSet,
82ace98d5505e (Sebastian Redl           2012-02-11 23:51:08 +0000  3339)                                        bool AllowExplicit) {
67ef14fe486e1 (Richard Smith            2017-09-26 18:37:55 +0000  3340)   CandidateSet.clear(OverloadCandidateSet::CSK_InitByUserDefinedConversion);
c2bebe9acab26 (Richard Smith            2016-05-11 20:37:46 +0000  3341)   for (auto *D : S.LookupConstructors(To)) {
c2bebe9acab26 (Richard Smith            2016-05-11 20:37:46 +0000  3342)     auto Info = getConstructorInfo(D);
5179eb78210a2 (Richard Smith            2016-06-28 19:03:57 +0000  3343)     if (!Info)
c2bebe9acab26 (Richard Smith            2016-05-11 20:37:46 +0000  3344)       continue;
82ace98d5505e (Sebastian Redl           2012-02-11 23:51:08 +0000  3345) 
c2bebe9acab26 (Richard Smith            2016-05-11 20:37:46 +0000  3346)     bool Usable = !Info.Constructor->isInvalidDecl() &&
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  3347)                   S.isInitListConstructor(Info.Constructor);
82ace98d5505e (Sebastian Redl           2012-02-11 23:51:08 +0000  3348)     if (Usable) {
40beb1f84a3d7 (Richard Smith            2021-04-22 16:48:34 -0700  3349)       bool SuppressUserConversions = false;
c2bebe9acab26 (Richard Smith            2016-05-11 20:37:46 +0000  3350)       if (Info.ConstructorTmpl)
c2bebe9acab26 (Richard Smith            2016-05-11 20:37:46 +0000  3351)         S.AddTemplateOverloadCandidate(Info.ConstructorTmpl, Info.FoundDecl,
c2bebe9acab26 (Richard Smith            2016-05-11 20:37:46 +0000  3352)                                        /*ExplicitArgs*/ nullptr, From,
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000  3353)                                        CandidateSet, SuppressUserConversions,
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000  3354)                                        /*PartialOverloading*/ false,
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000  3355)                                        AllowExplicit);
82ace98d5505e (Sebastian Redl           2012-02-11 23:51:08 +0000  3356)       else
c2bebe9acab26 (Richard Smith            2016-05-11 20:37:46 +0000  3357)         S.AddOverloadCandidate(Info.Constructor, Info.FoundDecl, From,
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000  3358)                                CandidateSet, SuppressUserConversions,
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000  3359)                                /*PartialOverloading*/ false, AllowExplicit);
82ace98d5505e (Sebastian Redl           2012-02-11 23:51:08 +0000  3360)     }
82ace98d5505e (Sebastian Redl           2012-02-11 23:51:08 +0000  3361)   }
82ace98d5505e (Sebastian Redl           2012-02-11 23:51:08 +0000  3362) 
82ace98d5505e (Sebastian Redl           2012-02-11 23:51:08 +0000  3363)   bool HadMultipleCandidates = (CandidateSet.size() > 1);
82ace98d5505e (Sebastian Redl           2012-02-11 23:51:08 +0000  3364) 
82ace98d5505e (Sebastian Redl           2012-02-11 23:51:08 +0000  3365)   OverloadCandidateSet::iterator Best;
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  3366)   switch (auto Result =
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  3367)               CandidateSet.BestViableFunction(S, From->getBeginLoc(), Best)) {
dcf06f42324a3 (Fariborz Jahanian        2015-04-14 17:21:58 +0000  3368)   case OR_Deleted:
82ace98d5505e (Sebastian Redl           2012-02-11 23:51:08 +0000  3369)   case OR_Success: {
82ace98d5505e (Sebastian Redl           2012-02-11 23:51:08 +0000  3370)     // Record the standard conversion we used and the conversion function.
82ace98d5505e (Sebastian Redl           2012-02-11 23:51:08 +0000  3371)     CXXConstructorDecl *Constructor = cast<CXXConstructorDecl>(Best->Function);
5488ab4ddd47a (Brian Gesiak             2019-01-11 01:54:53 +0000  3372)     QualType ThisType = Constructor->getThisType();
82ace98d5505e (Sebastian Redl           2012-02-11 23:51:08 +0000  3373)     // Initializer lists don't have conversions as such.
82ace98d5505e (Sebastian Redl           2012-02-11 23:51:08 +0000  3374)     User.Before.setAsIdentityConversion();
82ace98d5505e (Sebastian Redl           2012-02-11 23:51:08 +0000  3375)     User.HadMultipleCandidates = HadMultipleCandidates;
82ace98d5505e (Sebastian Redl           2012-02-11 23:51:08 +0000  3376)     User.ConversionFunction = Constructor;
82ace98d5505e (Sebastian Redl           2012-02-11 23:51:08 +0000  3377)     User.FoundConversionFunction = Best->FoundDecl;
82ace98d5505e (Sebastian Redl           2012-02-11 23:51:08 +0000  3378)     User.After.setAsIdentityConversion();
ed3b68e0dc3c0 (Simon Pilgrim            2019-10-02 14:02:27 +0000  3379)     User.After.setFromType(ThisType->castAs<PointerType>()->getPointeeType());
82ace98d5505e (Sebastian Redl           2012-02-11 23:51:08 +0000  3380)     User.After.setAllToTypes(ToType);
dcf06f42324a3 (Fariborz Jahanian        2015-04-14 17:21:58 +0000  3381)     return Result;
82ace98d5505e (Sebastian Redl           2012-02-11 23:51:08 +0000  3382)   }
82ace98d5505e (Sebastian Redl           2012-02-11 23:51:08 +0000  3383) 
82ace98d5505e (Sebastian Redl           2012-02-11 23:51:08 +0000  3384)   case OR_No_Viable_Function:
82ace98d5505e (Sebastian Redl           2012-02-11 23:51:08 +0000  3385)     return OR_No_Viable_Function;
82ace98d5505e (Sebastian Redl           2012-02-11 23:51:08 +0000  3386)   case OR_Ambiguous:
82ace98d5505e (Sebastian Redl           2012-02-11 23:51:08 +0000  3387)     return OR_Ambiguous;
82ace98d5505e (Sebastian Redl           2012-02-11 23:51:08 +0000  3388)   }
82ace98d5505e (Sebastian Redl           2012-02-11 23:51:08 +0000  3389) 
82ace98d5505e (Sebastian Redl           2012-02-11 23:51:08 +0000  3390)   llvm_unreachable("Invalid OverloadResult!");
82ace98d5505e (Sebastian Redl           2012-02-11 23:51:08 +0000  3391) }
82ace98d5505e (Sebastian Redl           2012-02-11 23:51:08 +0000  3392) 
576e98cc1e513 (Douglas Gregor           2009-01-30 23:27:23 +0000  3393) /// Determines whether there is a user-defined conversion sequence
576e98cc1e513 (Douglas Gregor           2009-01-30 23:27:23 +0000  3394) /// (C++ [over.ics.user]) that converts expression From to the type
576e98cc1e513 (Douglas Gregor           2009-01-30 23:27:23 +0000  3395) /// ToType. If such a conversion exists, User will contain the
576e98cc1e513 (Douglas Gregor           2009-01-30 23:27:23 +0000  3396) /// user-defined conversion sequence that performs such a conversion
576e98cc1e513 (Douglas Gregor           2009-01-30 23:27:23 +0000  3397) /// and this routine will return true. Otherwise, this routine returns
576e98cc1e513 (Douglas Gregor           2009-01-30 23:27:23 +0000  3398) /// false and User is unspecified.
576e98cc1e513 (Douglas Gregor           2009-01-30 23:27:23 +0000  3399) ///
576e98cc1e513 (Douglas Gregor           2009-01-30 23:27:23 +0000  3400) /// \param AllowExplicit  true if the conversion should consider C++0x
576e98cc1e513 (Douglas Gregor           2009-01-30 23:27:23 +0000  3401) /// "explicit" conversion functions as well as non-explicit conversion
576e98cc1e513 (Douglas Gregor           2009-01-30 23:27:23 +0000  3402) /// functions (C++0x [class.conv.fct]p2).
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  3403) ///
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  3404) /// \param AllowObjCConversionOnExplicit true if the conversion should
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  3405) /// allow an extra Objective-C pointer conversion on uses of explicit
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  3406) /// constructors. Requires \c AllowExplicit to also be set.
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  3407) static OverloadingResult
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  3408) IsUserDefinedConversion(Sema &S, Expr *From, QualType ToType,
82ace98d5505e (Sebastian Redl           2012-02-11 23:51:08 +0000  3409)                         UserDefinedConversionSequence &User,
82ace98d5505e (Sebastian Redl           2012-02-11 23:51:08 +0000  3410)                         OverloadCandidateSet &CandidateSet,
d28763cad06e6 (Richard Smith            2020-01-29 12:07:14 -0800  3411)                         AllowedExplicit AllowExplicit,
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  3412)                         bool AllowObjCConversionOnExplicit) {
d28763cad06e6 (Richard Smith            2020-01-29 12:07:14 -0800  3413)   assert(AllowExplicit != AllowedExplicit::None ||
d28763cad06e6 (Richard Smith            2020-01-29 12:07:14 -0800  3414)          !AllowObjCConversionOnExplicit);
67ef14fe486e1 (Richard Smith            2017-09-26 18:37:55 +0000  3415)   CandidateSet.clear(OverloadCandidateSet::CSK_InitByUserDefinedConversion);
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  3416) 
5ab116553171e (Douglas Gregor           2010-04-17 22:01:05 +0000  3417)   // Whether we will only visit constructors.
5ab116553171e (Douglas Gregor           2010-04-17 22:01:05 +0000  3418)   bool ConstructorsOnly = false;
5ab116553171e (Douglas Gregor           2010-04-17 22:01:05 +0000  3419) 
5ab116553171e (Douglas Gregor           2010-04-17 22:01:05 +0000  3420)   // If the type we are conversion to is a class type, enumerate its
5ab116553171e (Douglas Gregor           2010-04-17 22:01:05 +0000  3421)   // constructors.
c23c7e6a51927 (Ted Kremenek             2009-07-29 21:53:49 +0000  3422)   if (const RecordType *ToRecordType = ToType->getAs<RecordType>()) {
5ab116553171e (Douglas Gregor           2010-04-17 22:01:05 +0000  3423)     // C++ [over.match.ctor]p1:
5ab116553171e (Douglas Gregor           2010-04-17 22:01:05 +0000  3424)     //   When objects of class type are direct-initialized (8.5), or
5ab116553171e (Douglas Gregor           2010-04-17 22:01:05 +0000  3425)     //   copy-initialized from an expression of the same or a
5ab116553171e (Douglas Gregor           2010-04-17 22:01:05 +0000  3426)     //   derived class type (8.5), overload resolution selects the
5ab116553171e (Douglas Gregor           2010-04-17 22:01:05 +0000  3427)     //   constructor. [...] For copy-initialization, the candidate
5ab116553171e (Douglas Gregor           2010-04-17 22:01:05 +0000  3428)     //   functions are all the converting constructors (12.3.1) of
5ab116553171e (Douglas Gregor           2010-04-17 22:01:05 +0000  3429)     //   that class. The argument list is the expression-list within
5ab116553171e (Douglas Gregor           2010-04-17 22:01:05 +0000  3430)     //   the parentheses of the initializer.
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  3431)     if (S.Context.hasSameUnqualifiedType(ToType, From->getType()) ||
5ab116553171e (Douglas Gregor           2010-04-17 22:01:05 +0000  3432)         (From->getType()->getAs<RecordType>() &&
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  3433)          S.IsDerivedFrom(From->getBeginLoc(), From->getType(), ToType)))
5ab116553171e (Douglas Gregor           2010-04-17 22:01:05 +0000  3434)       ConstructorsOnly = true;
5ab116553171e (Douglas Gregor           2010-04-17 22:01:05 +0000  3435) 
db0ac5572fcf7 (Richard Smith            2015-12-18 22:40:25 +0000  3436)     if (!S.isCompleteType(From->getExprLoc(), ToType)) {
3ec1bf240d4ab (Douglas Gregor           2009-11-05 13:06:35 +0000  3437)       // We're not going to find any constructors.
3ec1bf240d4ab (Douglas Gregor           2009-11-05 13:06:35 +0000  3438)     } else if (CXXRecordDecl *ToRecordDecl
3ec1bf240d4ab (Douglas Gregor           2009-11-05 13:06:35 +0000  3439)                  = dyn_cast<CXXRecordDecl>(ToRecordType->getDecl())) {
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  3440) 
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  3441)       Expr **Args = &From;
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  3442)       unsigned NumArgs = 1;
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  3443)       bool ListInitializing = false;
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  3444)       if (InitListExpr *InitList = dyn_cast<InitListExpr>(From)) {
60509af49add1 (Benjamin Kramer          2013-09-09 14:48:42 +0000  3445)         // But first, see if there is an init-list-constructor that will work.
82ace98d5505e (Sebastian Redl           2012-02-11 23:51:08 +0000  3446)         OverloadingResult Result = IsInitializerListConstructorConversion(
d28763cad06e6 (Richard Smith            2020-01-29 12:07:14 -0800  3447)             S, From, ToType, ToRecordDecl, User, CandidateSet,
d28763cad06e6 (Richard Smith            2020-01-29 12:07:14 -0800  3448)             AllowExplicit == AllowedExplicit::All);
82ace98d5505e (Sebastian Redl           2012-02-11 23:51:08 +0000  3449)         if (Result != OR_No_Viable_Function)
82ace98d5505e (Sebastian Redl           2012-02-11 23:51:08 +0000  3450)           return Result;
82ace98d5505e (Sebastian Redl           2012-02-11 23:51:08 +0000  3451)         // Never mind.
67ef14fe486e1 (Richard Smith            2017-09-26 18:37:55 +0000  3452)         CandidateSet.clear(
67ef14fe486e1 (Richard Smith            2017-09-26 18:37:55 +0000  3453)             OverloadCandidateSet::CSK_InitByUserDefinedConversion);
82ace98d5505e (Sebastian Redl           2012-02-11 23:51:08 +0000  3454) 
82ace98d5505e (Sebastian Redl           2012-02-11 23:51:08 +0000  3455)         // If we're list-initializing, we pass the individual elements as
82ace98d5505e (Sebastian Redl           2012-02-11 23:51:08 +0000  3456)         // arguments, not the entire list.
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  3457)         Args = InitList->getInits();
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  3458)         NumArgs = InitList->getNumInits();
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  3459)         ListInitializing = true;
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  3460)       }
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  3461) 
c2bebe9acab26 (Richard Smith            2016-05-11 20:37:46 +0000  3462)       for (auto *D : S.LookupConstructors(ToRecordDecl)) {
c2bebe9acab26 (Richard Smith            2016-05-11 20:37:46 +0000  3463)         auto Info = getConstructorInfo(D);
5179eb78210a2 (Richard Smith            2016-06-28 19:03:57 +0000  3464)         if (!Info)
c2bebe9acab26 (Richard Smith            2016-05-11 20:37:46 +0000  3465)           continue;
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  3466) 
c2bebe9acab26 (Richard Smith            2016-05-11 20:37:46 +0000  3467)         bool Usable = !Info.Constructor->isInvalidDecl();
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  3468)         if (!ListInitializing)
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  3469)           Usable = Usable && Info.Constructor->isConvertingConstructor(
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  3470)                                  /*AllowExplicit*/ true);
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  3471)         if (Usable) {
d9170b09e6726 (Sebastian Redl           2012-03-20 21:24:14 +0000  3472)           bool SuppressUserConversions = !ConstructorsOnly;
40beb1f84a3d7 (Richard Smith            2021-04-22 16:48:34 -0700  3473)           // C++20 [over.best.ics.general]/4.5:
40beb1f84a3d7 (Richard Smith            2021-04-22 16:48:34 -0700  3474)           //   if the target is the first parameter of a constructor [of class
40beb1f84a3d7 (Richard Smith            2021-04-22 16:48:34 -0700  3475)           //   X] and the constructor [...] is a candidate by [...] the second
40beb1f84a3d7 (Richard Smith            2021-04-22 16:48:34 -0700  3476)           //   phase of [over.match.list] when the initializer list has exactly
40beb1f84a3d7 (Richard Smith            2021-04-22 16:48:34 -0700  3477)           //   one element that is itself an initializer list, [...] and the
40beb1f84a3d7 (Richard Smith            2021-04-22 16:48:34 -0700  3478)           //   conversion is to X or reference to cv X, user-defined conversion
40beb1f84a3d7 (Richard Smith            2021-04-22 16:48:34 -0700  3479)           //   sequences are not cnosidered.
d9170b09e6726 (Sebastian Redl           2012-03-20 21:24:14 +0000  3480)           if (SuppressUserConversions && ListInitializing) {
40beb1f84a3d7 (Richard Smith            2021-04-22 16:48:34 -0700  3481)             SuppressUserConversions =
40beb1f84a3d7 (Richard Smith            2021-04-22 16:48:34 -0700  3482)                 NumArgs == 1 && isa<InitListExpr>(Args[0]) &&
40beb1f84a3d7 (Richard Smith            2021-04-22 16:48:34 -0700  3483)                 isFirstArgumentCompatibleWithType(S.Context, Info.Constructor,
40beb1f84a3d7 (Richard Smith            2021-04-22 16:48:34 -0700  3484)                                                   ToType);
d9170b09e6726 (Sebastian Redl           2012-03-20 21:24:14 +0000  3485)           }
c2bebe9acab26 (Richard Smith            2016-05-11 20:37:46 +0000  3486)           if (Info.ConstructorTmpl)
c2bebe9acab26 (Richard Smith            2016-05-11 20:37:46 +0000  3487)             S.AddTemplateOverloadCandidate(
c2bebe9acab26 (Richard Smith            2016-05-11 20:37:46 +0000  3488)                 Info.ConstructorTmpl, Info.FoundDecl,
c2bebe9acab26 (Richard Smith            2016-05-11 20:37:46 +0000  3489)                 /*ExplicitArgs*/ nullptr, llvm::makeArrayRef(Args, NumArgs),
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000  3490)                 CandidateSet, SuppressUserConversions,
d28763cad06e6 (Richard Smith            2020-01-29 12:07:14 -0800  3491)                 /*PartialOverloading*/ false,
d28763cad06e6 (Richard Smith            2020-01-29 12:07:14 -0800  3492)                 AllowExplicit == AllowedExplicit::All);
5ed5ae476e5c7 (Douglas Gregor           2009-08-21 18:42:58 +0000  3493)           else
b3c44f9ee9e66 (Fariborz Jahanian        2009-10-01 20:39:51 +0000  3494)             // Allow one user-defined conversion when user specifies a
b3c44f9ee9e66 (Fariborz Jahanian        2009-10-01 20:39:51 +0000  3495)             // From->ToType conversion via an static cast (c-style, etc).
c2bebe9acab26 (Richard Smith            2016-05-11 20:37:46 +0000  3496)             S.AddOverloadCandidate(Info.Constructor, Info.FoundDecl,
b24b9aa298311 (Ahmed Charles            2012-02-25 11:00:22 +0000  3497)                                    llvm::makeArrayRef(Args, NumArgs),
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000  3498)                                    CandidateSet, SuppressUserConversions,
d28763cad06e6 (Richard Smith            2020-01-29 12:07:14 -0800  3499)                                    /*PartialOverloading*/ false,
d28763cad06e6 (Richard Smith            2020-01-29 12:07:14 -0800  3500)                                    AllowExplicit == AllowedExplicit::All);
5ed5ae476e5c7 (Douglas Gregor           2009-08-21 18:42:58 +0000  3501)         }
89ee6822d8a6a (Douglas Gregor           2009-02-28 01:32:25 +0000  3502)       }
26bee0b326227 (Douglas Gregor           2008-10-31 16:23:19 +0000  3503)     }
26bee0b326227 (Douglas Gregor           2008-10-31 16:23:19 +0000  3504)   }
26bee0b326227 (Douglas Gregor           2008-10-31 16:23:19 +0000  3505) 
5ab116553171e (Douglas Gregor           2010-04-17 22:01:05 +0000  3506)   // Enumerate conversion functions, if we're allowed to.
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  3507)   if (ConstructorsOnly || isa<InitListExpr>(From)) {
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  3508)   } else if (!S.isCompleteType(From->getBeginLoc(), From->getType())) {
8a2e601917708 (Douglas Gregor           2009-08-24 15:23:48 +0000  3509)     // No conversion functions from incomplete types.
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  3510)   } else if (const RecordType *FromRecordType =
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  3511)                  From->getType()->getAs<RecordType>()) {
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  3512)     if (CXXRecordDecl *FromRecordDecl
f9012a3e9d9e7 (Fariborz Jahanian        2009-09-11 18:46:22 +0000  3513)          = dyn_cast<CXXRecordDecl>(FromRecordType->getDecl())) {
f9012a3e9d9e7 (Fariborz Jahanian        2009-09-11 18:46:22 +0000  3514)       // Add all of the conversion functions as candidates.
b4ef66832dee0 (Benjamin Kramer          2015-02-06 17:25:10 +0000  3515)       const auto &Conversions = FromRecordDecl->getVisibleConversionFunctions();
b4ef66832dee0 (Benjamin Kramer          2015-02-06 17:25:10 +0000  3516)       for (auto I = Conversions.begin(), E = Conversions.end(); I != E; ++I) {
a0296f7987c0a (John McCall              2010-03-19 07:35:19 +0000  3517)         DeclAccessPair FoundDecl = I.getPair();
a0296f7987c0a (John McCall              2010-03-19 07:35:19 +0000  3518)         NamedDecl *D = FoundDecl.getDecl();
6e9f8f6374349 (John McCall              2009-12-03 04:06:58 +0000  3519)         CXXRecordDecl *ActingContext = cast<CXXRecordDecl>(D->getDeclContext());
6e9f8f6374349 (John McCall              2009-12-03 04:06:58 +0000  3520)         if (isa<UsingShadowDecl>(D))
6e9f8f6374349 (John McCall              2009-12-03 04:06:58 +0000  3521)           D = cast<UsingShadowDecl>(D)->getTargetDecl();
6e9f8f6374349 (John McCall              2009-12-03 04:06:58 +0000  3522) 
f9012a3e9d9e7 (Fariborz Jahanian        2009-09-11 18:46:22 +0000  3523)         CXXConversionDecl *Conv;
f9012a3e9d9e7 (Fariborz Jahanian        2009-09-11 18:46:22 +0000  3524)         FunctionTemplateDecl *ConvTemplate;
da4458e98f54c (John McCall              2010-03-31 01:36:47 +0000  3525)         if ((ConvTemplate = dyn_cast<FunctionTemplateDecl>(D)))
da4458e98f54c (John McCall              2010-03-31 01:36:47 +0000  3526)           Conv = cast<CXXConversionDecl>(ConvTemplate->getTemplatedDecl());
f9012a3e9d9e7 (Fariborz Jahanian        2009-09-11 18:46:22 +0000  3527)         else
da4458e98f54c (John McCall              2010-03-31 01:36:47 +0000  3528)           Conv = cast<CXXConversionDecl>(D);
f9012a3e9d9e7 (Fariborz Jahanian        2009-09-11 18:46:22 +0000  3529) 
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  3530)         if (ConvTemplate)
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  3531)           S.AddTemplateConversionCandidate(
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  3532)               ConvTemplate, FoundDecl, ActingContext, From, ToType,
d28763cad06e6 (Richard Smith            2020-01-29 12:07:14 -0800  3533)               CandidateSet, AllowObjCConversionOnExplicit,
d28763cad06e6 (Richard Smith            2020-01-29 12:07:14 -0800  3534)               AllowExplicit != AllowedExplicit::None);
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  3535)         else
d28763cad06e6 (Richard Smith            2020-01-29 12:07:14 -0800  3536)           S.AddConversionCandidate(Conv, FoundDecl, ActingContext, From, ToType,
d28763cad06e6 (Richard Smith            2020-01-29 12:07:14 -0800  3537)                                    CandidateSet, AllowObjCConversionOnExplicit,
d28763cad06e6 (Richard Smith            2020-01-29 12:07:14 -0800  3538)                                    AllowExplicit != AllowedExplicit::None);
f9012a3e9d9e7 (Fariborz Jahanian        2009-09-11 18:46:22 +0000  3539)       }
f9012a3e9d9e7 (Fariborz Jahanian        2009-09-11 18:46:22 +0000  3540)     }
a1f013e8edb82 (Douglas Gregor           2008-11-07 22:36:19 +0000  3541)   }
26bee0b326227 (Douglas Gregor           2008-10-31 16:23:19 +0000  3542) 
635ed24e1dad8 (Abramo Bagnara           2011-10-05 07:56:41 +0000  3543)   bool HadMultipleCandidates = (CandidateSet.size() > 1);
635ed24e1dad8 (Abramo Bagnara           2011-10-05 07:56:41 +0000  3544) 
26bee0b326227 (Douglas Gregor           2008-10-31 16:23:19 +0000  3545)   OverloadCandidateSet::iterator Best;
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  3546)   switch (auto Result =
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  3547)               CandidateSet.BestViableFunction(S, From->getBeginLoc(), Best)) {
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  3548)   case OR_Success:
48372b68fefb9 (Richard Smith            2015-01-27 03:30:40 +0000  3549)   case OR_Deleted:
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  3550)     // Record the standard conversion we used and the conversion function.
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  3551)     if (CXXConstructorDecl *Constructor
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  3552)           = dyn_cast<CXXConstructorDecl>(Best->Function)) {
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  3553)       // C++ [over.ics.user]p1:
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  3554)       //   If the user-defined conversion is specified by a
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  3555)       //   constructor (12.3.1), the initial standard conversion
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  3556)       //   sequence converts the source type to the type required by
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  3557)       //   the argument of the constructor.
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  3558)       //
5488ab4ddd47a (Brian Gesiak             2019-01-11 01:54:53 +0000  3559)       QualType ThisType = Constructor->getThisType();
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  3560)       if (isa<InitListExpr>(From)) {
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  3561)         // Initializer lists don't have conversions as such.
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  3562)         User.Before.setAsIdentityConversion();
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  3563)       } else {
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  3564)         if (Best->Conversions[0].isEllipsis())
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  3565)           User.EllipsisConversion = true;
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  3566)         else {
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  3567)           User.Before = Best->Conversions[0].Standard;
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  3568)           User.EllipsisConversion = false;
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  3569)         }
26bee0b326227 (Douglas Gregor           2008-10-31 16:23:19 +0000  3570)       }
635ed24e1dad8 (Abramo Bagnara           2011-10-05 07:56:41 +0000  3571)       User.HadMultipleCandidates = HadMultipleCandidates;
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  3572)       User.ConversionFunction = Constructor;
30909031a7f76 (John McCall              2011-09-21 08:36:56 +0000  3573)       User.FoundConversionFunction = Best->FoundDecl;
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  3574)       User.After.setAsIdentityConversion();
ed3b68e0dc3c0 (Simon Pilgrim            2019-10-02 14:02:27 +0000  3575)       User.After.setFromType(ThisType->castAs<PointerType>()->getPointeeType());
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  3576)       User.After.setAllToTypes(ToType);
48372b68fefb9 (Richard Smith            2015-01-27 03:30:40 +0000  3577)       return Result;
8a40f700e62b8 (David Blaikie            2012-01-17 06:56:22 +0000  3578)     }
8a40f700e62b8 (David Blaikie            2012-01-17 06:56:22 +0000  3579)     if (CXXConversionDecl *Conversion
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  3580)                  = dyn_cast<CXXConversionDecl>(Best->Function)) {
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  3581)       // C++ [over.ics.user]p1:
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  3582)       //
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  3583)       //   [...] If the user-defined conversion is specified by a
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  3584)       //   conversion function (12.3.2), the initial standard
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  3585)       //   conversion sequence converts the source type to the
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  3586)       //   implicit object parameter of the conversion function.
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  3587)       User.Before = Best->Conversions[0].Standard;
635ed24e1dad8 (Abramo Bagnara           2011-10-05 07:56:41 +0000  3588)       User.HadMultipleCandidates = HadMultipleCandidates;
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  3589)       User.ConversionFunction = Conversion;
30909031a7f76 (John McCall              2011-09-21 08:36:56 +0000  3590)       User.FoundConversionFunction = Best->FoundDecl;
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  3591)       User.EllipsisConversion = false;
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  3592) 
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  3593)       // C++ [over.ics.user]p2:
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  3594)       //   The second standard conversion sequence converts the
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  3595)       //   result of the user-defined conversion to the target type
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  3596)       //   for the sequence. Since an implicit conversion sequence
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  3597)       //   is an initialization, the special rules for
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  3598)       //   initialization by user-defined conversion apply when
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  3599)       //   selecting the best user-defined conversion for a
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  3600)       //   user-defined conversion sequence (see 13.3.3 and
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  3601)       //   13.3.3.1).
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  3602)       User.After = Best->FinalConversion;
48372b68fefb9 (Richard Smith            2015-01-27 03:30:40 +0000  3603)       return Result;
26bee0b326227 (Douglas Gregor           2008-10-31 16:23:19 +0000  3604)     }
8a40f700e62b8 (David Blaikie            2012-01-17 06:56:22 +0000  3605)     llvm_unreachable("Not a constructor or conversion function?");
26bee0b326227 (Douglas Gregor           2008-10-31 16:23:19 +0000  3606) 
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  3607)   case OR_No_Viable_Function:
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  3608)     return OR_No_Viable_Function;
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  3609) 
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  3610)   case OR_Ambiguous:
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  3611)     return OR_Ambiguous;
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  3612)   }
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  3613) 
8a40f700e62b8 (David Blaikie            2012-01-17 06:56:22 +0000  3614)   llvm_unreachable("Invalid OverloadResult!");
26bee0b326227 (Douglas Gregor           2008-10-31 16:23:19 +0000  3615) }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  3616) 
f0647a5fbcebf (Fariborz Jahanian        2009-09-22 20:24:30 +0000  3617) bool
76197416ac15c (Fariborz Jahanian        2009-11-18 18:26:29 +0000  3618) Sema::DiagnoseMultipleUserDefinedConversion(Expr *From, QualType ToType) {
f0647a5fbcebf (Fariborz Jahanian        2009-09-22 20:24:30 +0000  3619)   ImplicitConversionSequence ICS;
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000  3620)   OverloadCandidateSet CandidateSet(From->getExprLoc(),
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000  3621)                                     OverloadCandidateSet::CSK_Normal);
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  3622)   OverloadingResult OvResult =
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  3623)     IsUserDefinedConversion(*this, From, ToType, ICS.UserDefined,
d28763cad06e6 (Richard Smith            2020-01-29 12:07:14 -0800  3624)                             CandidateSet, AllowedExplicit::None, false);
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000  3625) 
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000  3626)   if (!(OvResult == OR_Ambiguous ||
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000  3627)         (OvResult == OR_No_Viable_Function && !CandidateSet.empty())))
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000  3628)     return false;
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000  3629) 
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700  3630)   auto Cands = CandidateSet.CompleteCandidates(
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700  3631)       *this,
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700  3632)       OvResult == OR_Ambiguous ? OCD_AmbiguousCandidates : OCD_AllCandidates,
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700  3633)       From);
76197416ac15c (Fariborz Jahanian        2009-11-18 18:26:29 +0000  3634)   if (OvResult == OR_Ambiguous)
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  3635)     Diag(From->getBeginLoc(), diag::err_typecheck_ambiguous_condition)
1121de36c26b9 (Ismail Pazarbasi         2014-01-17 21:08:52 +0000  3636)         << From->getType() << ToType << From->getSourceRange();
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000  3637)   else { // OR_No_Viable_Function && !CandidateSet.empty()
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  3638)     if (!RequireCompleteType(From->getBeginLoc(), ToType,
1121de36c26b9 (Ismail Pazarbasi         2014-01-17 21:08:52 +0000  3639)                              diag::err_typecheck_nonviable_condition_incomplete,
64cf3efd47bc7 (Larisse Voufo            2013-06-27 01:50:25 +0000  3640)                              From->getType(), From->getSourceRange()))
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  3641)       Diag(From->getBeginLoc(), diag::err_typecheck_nonviable_condition)
08426e2098aaa (Nick Lewycky             2015-08-25 22:18:46 +0000  3642)           << false << From->getType() << From->getSourceRange() << ToType;
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000  3643)   }
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000  3644) 
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000  3645)   CandidateSet.NoteCandidates(
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000  3646)                               *this, From, Cands);
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  3647)   return true;
f0647a5fbcebf (Fariborz Jahanian        2009-09-22 20:24:30 +0000  3648) }
26bee0b326227 (Douglas Gregor           2008-10-31 16:23:19 +0000  3649) 
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3650) // Helper for compareConversionFunctions that gets the FunctionType that the
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3651) // conversion-operator return  value 'points' to, or nullptr.
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3652) static const FunctionType *
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3653) getConversionOpReturnTyAsFunction(CXXConversionDecl *Conv) {
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3654)   const FunctionType *ConvFuncTy = Conv->getType()->castAs<FunctionType>();
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3655)   const PointerType *RetPtrTy =
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3656)       ConvFuncTy->getReturnType()->getAs<PointerType>();
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3657) 
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3658)   if (!RetPtrTy)
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3659)     return nullptr;
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3660) 
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3661)   return RetPtrTy->getPointeeType()->getAs<FunctionType>();
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3662) }
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3663) 
9fc8faf9e6197 (Adrian Prantl            2018-05-09 01:00:01 +0000  3664) /// Compare the user-defined conversion functions or constructors
2837aa2932710 (Douglas Gregor           2012-02-22 17:32:19 +0000  3665) /// of two user-defined conversion sequences to determine whether any ordering
2837aa2932710 (Douglas Gregor           2012-02-22 17:32:19 +0000  3666) /// is possible.
2837aa2932710 (Douglas Gregor           2012-02-22 17:32:19 +0000  3667) static ImplicitConversionSequence::CompareKind
1121de36c26b9 (Ismail Pazarbasi         2014-01-17 21:08:52 +0000  3668) compareConversionFunctions(Sema &S, FunctionDecl *Function1,
2837aa2932710 (Douglas Gregor           2012-02-22 17:32:19 +0000  3669)                            FunctionDecl *Function2) {
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3670)   CXXConversionDecl *Conv1 = dyn_cast_or_null<CXXConversionDecl>(Function1);
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3671)   CXXConversionDecl *Conv2 = dyn_cast_or_null<CXXConversionDecl>(Function2);
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3672)   if (!Conv1 || !Conv2)
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3673)     return ImplicitConversionSequence::Indistinguishable;
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3674) 
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3675)   if (!Conv1->getParent()->isLambda() || !Conv2->getParent()->isLambda())
2837aa2932710 (Douglas Gregor           2012-02-22 17:32:19 +0000  3676)     return ImplicitConversionSequence::Indistinguishable;
1121de36c26b9 (Ismail Pazarbasi         2014-01-17 21:08:52 +0000  3677) 
2837aa2932710 (Douglas Gregor           2012-02-22 17:32:19 +0000  3678)   // Objective-C++:
2837aa2932710 (Douglas Gregor           2012-02-22 17:32:19 +0000  3679)   //   If both conversion functions are implicitly-declared conversions from
1121de36c26b9 (Ismail Pazarbasi         2014-01-17 21:08:52 +0000  3680)   //   a lambda closure type to a function pointer and a block pointer,
2837aa2932710 (Douglas Gregor           2012-02-22 17:32:19 +0000  3681)   //   respectively, always prefer the conversion to a function pointer,
2837aa2932710 (Douglas Gregor           2012-02-22 17:32:19 +0000  3682)   //   because the function pointer is more lightweight and is more likely
2837aa2932710 (Douglas Gregor           2012-02-22 17:32:19 +0000  3683)   //   to keep code working.
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3684)   if (S.getLangOpts().ObjC && S.getLangOpts().CPlusPlus11) {
2837aa2932710 (Douglas Gregor           2012-02-22 17:32:19 +0000  3685)     bool Block1 = Conv1->getConversionType()->isBlockPointerType();
2837aa2932710 (Douglas Gregor           2012-02-22 17:32:19 +0000  3686)     bool Block2 = Conv2->getConversionType()->isBlockPointerType();
2837aa2932710 (Douglas Gregor           2012-02-22 17:32:19 +0000  3687)     if (Block1 != Block2)
1121de36c26b9 (Ismail Pazarbasi         2014-01-17 21:08:52 +0000  3688)       return Block1 ? ImplicitConversionSequence::Worse
1121de36c26b9 (Ismail Pazarbasi         2014-01-17 21:08:52 +0000  3689)                     : ImplicitConversionSequence::Better;
2837aa2932710 (Douglas Gregor           2012-02-22 17:32:19 +0000  3690)   }
2837aa2932710 (Douglas Gregor           2012-02-22 17:32:19 +0000  3691) 
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3692)   // In order to support multiple calling conventions for the lambda conversion
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3693)   // operator (such as when the free and member function calling convention is
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3694)   // different), prefer the 'free' mechanism, followed by the calling-convention
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3695)   // of operator(). The latter is in place to support the MSVC-like solution of
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3696)   // defining ALL of the possible conversions in regards to calling-convention.
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3697)   const FunctionType *Conv1FuncRet = getConversionOpReturnTyAsFunction(Conv1);
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3698)   const FunctionType *Conv2FuncRet = getConversionOpReturnTyAsFunction(Conv2);
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3699) 
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3700)   if (Conv1FuncRet && Conv2FuncRet &&
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3701)       Conv1FuncRet->getCallConv() != Conv2FuncRet->getCallConv()) {
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3702)     CallingConv Conv1CC = Conv1FuncRet->getCallConv();
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3703)     CallingConv Conv2CC = Conv2FuncRet->getCallConv();
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3704) 
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3705)     CXXMethodDecl *CallOp = Conv2->getParent()->getLambdaCallOperator();
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3706)     const FunctionProtoType *CallOpProto =
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3707)         CallOp->getType()->getAs<FunctionProtoType>();
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3708) 
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3709)     CallingConv CallOpCC =
2901dc7575873 (Simon Pilgrim            2021-04-06 12:04:01 +0100  3710)         CallOp->getType()->castAs<FunctionType>()->getCallConv();
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3711)     CallingConv DefaultFree = S.Context.getDefaultCallingConvention(
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3712)         CallOpProto->isVariadic(), /*IsCXXMethod=*/false);
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3713)     CallingConv DefaultMember = S.Context.getDefaultCallingConvention(
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3714)         CallOpProto->isVariadic(), /*IsCXXMethod=*/true);
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3715) 
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3716)     CallingConv PrefOrder[] = {DefaultFree, DefaultMember, CallOpCC};
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3717)     for (CallingConv CC : PrefOrder) {
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3718)       if (Conv1CC == CC)
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3719)         return ImplicitConversionSequence::Better;
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3720)       if (Conv2CC == CC)
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3721)         return ImplicitConversionSequence::Worse;
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3722)     }
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3723)   }
ec809e4cfe0be (Erich Keane              2020-10-16 09:09:09 -0700  3724) 
2837aa2932710 (Douglas Gregor           2012-02-22 17:32:19 +0000  3725)   return ImplicitConversionSequence::Indistinguishable;
2837aa2932710 (Douglas Gregor           2012-02-22 17:32:19 +0000  3726) }
1121de36c26b9 (Ismail Pazarbasi         2014-01-17 21:08:52 +0000  3727) 
1121de36c26b9 (Ismail Pazarbasi         2014-01-17 21:08:52 +0000  3728) static bool hasDeprecatedStringLiteralToCharPtrConversion(
1121de36c26b9 (Ismail Pazarbasi         2014-01-17 21:08:52 +0000  3729)     const ImplicitConversionSequence &ICS) {
1121de36c26b9 (Ismail Pazarbasi         2014-01-17 21:08:52 +0000  3730)   return (ICS.isStandard() && ICS.Standard.DeprecatedStringLiteralToCharPtr) ||
1121de36c26b9 (Ismail Pazarbasi         2014-01-17 21:08:52 +0000  3731)          (ICS.isUserDefined() &&
1121de36c26b9 (Ismail Pazarbasi         2014-01-17 21:08:52 +0000  3732)           ICS.UserDefined.Before.DeprecatedStringLiteralToCharPtr);
1121de36c26b9 (Ismail Pazarbasi         2014-01-17 21:08:52 +0000  3733) }
1121de36c26b9 (Ismail Pazarbasi         2014-01-17 21:08:52 +0000  3734) 
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  3735) /// CompareImplicitConversionSequences - Compare two implicit
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  3736) /// conversion sequences to determine whether one is better than the
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  3737) /// other or if they are indistinguishable (C++ 13.3.3.2).
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  3738) static ImplicitConversionSequence::CompareKind
0f59cb38e7f31 (Richard Smith            2015-12-18 21:45:41 +0000  3739) CompareImplicitConversionSequences(Sema &S, SourceLocation Loc,
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  3740)                                    const ImplicitConversionSequence& ICS1,
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  3741)                                    const ImplicitConversionSequence& ICS2)
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  3742) {
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  3743)   // (C++ 13.3.3.2p2): When comparing the basic forms of implicit
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  3744)   // conversion sequences (as defined in 13.3.3.1)
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  3745)   //   -- a standard conversion sequence (13.3.3.1.1) is a better
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  3746)   //      conversion sequence than a user-defined conversion sequence or
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  3747)   //      an ellipsis conversion sequence, and
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  3748)   //   -- a user-defined conversion sequence (13.3.3.1.2) is a better
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  3749)   //      conversion sequence than an ellipsis conversion sequence
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  3750)   //      (13.3.3.1.3).
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  3751)   //
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000  3752)   // C++0x [over.best.ics]p10:
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000  3753)   //   For the purpose of ranking implicit conversion sequences as
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000  3754)   //   described in 13.3.3.2, the ambiguous conversion sequence is
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000  3755)   //   treated as a user-defined sequence that is indistinguishable
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000  3756)   //   from any other user-defined conversion sequence.
1121de36c26b9 (Ismail Pazarbasi         2014-01-17 21:08:52 +0000  3757) 
1121de36c26b9 (Ismail Pazarbasi         2014-01-17 21:08:52 +0000  3758)   // String literal to 'char *' conversion has been deprecated in C++03. It has
1121de36c26b9 (Ismail Pazarbasi         2014-01-17 21:08:52 +0000  3759)   // been removed from C++11. We still accept this conversion, if it happens at
1121de36c26b9 (Ismail Pazarbasi         2014-01-17 21:08:52 +0000  3760)   // the best viable function. Otherwise, this conversion is considered worse
1121de36c26b9 (Ismail Pazarbasi         2014-01-17 21:08:52 +0000  3761)   // than ellipsis conversion. Consider this as an extension; this is not in the
1121de36c26b9 (Ismail Pazarbasi         2014-01-17 21:08:52 +0000  3762)   // standard. For example:
1121de36c26b9 (Ismail Pazarbasi         2014-01-17 21:08:52 +0000  3763)   //
1121de36c26b9 (Ismail Pazarbasi         2014-01-17 21:08:52 +0000  3764)   // int &f(...);    // #1
1121de36c26b9 (Ismail Pazarbasi         2014-01-17 21:08:52 +0000  3765)   // void f(char*);  // #2
1121de36c26b9 (Ismail Pazarbasi         2014-01-17 21:08:52 +0000  3766)   // void g() { int &r = f("foo"); }
1121de36c26b9 (Ismail Pazarbasi         2014-01-17 21:08:52 +0000  3767)   //
1121de36c26b9 (Ismail Pazarbasi         2014-01-17 21:08:52 +0000  3768)   // In C++03, we pick #2 as the best viable function.
1121de36c26b9 (Ismail Pazarbasi         2014-01-17 21:08:52 +0000  3769)   // In C++11, we pick #1 as the best viable function, because ellipsis
1121de36c26b9 (Ismail Pazarbasi         2014-01-17 21:08:52 +0000  3770)   // conversion is better than string-literal to char* conversion (since there
1121de36c26b9 (Ismail Pazarbasi         2014-01-17 21:08:52 +0000  3771)   // is no such conversion in C++11). If there was no #1 at all or #1 couldn't
1121de36c26b9 (Ismail Pazarbasi         2014-01-17 21:08:52 +0000  3772)   // convert arguments, #2 would be the best viable function in C++11.
1121de36c26b9 (Ismail Pazarbasi         2014-01-17 21:08:52 +0000  3773)   // If the best viable function has this conversion, a warning will be issued
1121de36c26b9 (Ismail Pazarbasi         2014-01-17 21:08:52 +0000  3774)   // in C++03, or an ExtWarn (+SFINAE failure) will be issued in C++11.
1121de36c26b9 (Ismail Pazarbasi         2014-01-17 21:08:52 +0000  3775) 
1121de36c26b9 (Ismail Pazarbasi         2014-01-17 21:08:52 +0000  3776)   if (S.getLangOpts().CPlusPlus11 && !S.getLangOpts().WritableStrings &&
1121de36c26b9 (Ismail Pazarbasi         2014-01-17 21:08:52 +0000  3777)       hasDeprecatedStringLiteralToCharPtrConversion(ICS1) !=
1121de36c26b9 (Ismail Pazarbasi         2014-01-17 21:08:52 +0000  3778)       hasDeprecatedStringLiteralToCharPtrConversion(ICS2))
1121de36c26b9 (Ismail Pazarbasi         2014-01-17 21:08:52 +0000  3779)     return hasDeprecatedStringLiteralToCharPtrConversion(ICS1)
1121de36c26b9 (Ismail Pazarbasi         2014-01-17 21:08:52 +0000  3780)                ? ImplicitConversionSequence::Worse
1121de36c26b9 (Ismail Pazarbasi         2014-01-17 21:08:52 +0000  3781)                : ImplicitConversionSequence::Better;
1121de36c26b9 (Ismail Pazarbasi         2014-01-17 21:08:52 +0000  3782) 
5ab116553171e (Douglas Gregor           2010-04-17 22:01:05 +0000  3783)   if (ICS1.getKindRank() < ICS2.getKindRank())
5ab116553171e (Douglas Gregor           2010-04-17 22:01:05 +0000  3784)     return ImplicitConversionSequence::Better;
8a40f700e62b8 (David Blaikie            2012-01-17 06:56:22 +0000  3785)   if (ICS2.getKindRank() < ICS1.getKindRank())
5ab116553171e (Douglas Gregor           2010-04-17 22:01:05 +0000  3786)     return ImplicitConversionSequence::Worse;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  3787) 
98ff7f873089b (Benjamin Kramer          2010-04-18 12:05:54 +0000  3788)   // The following checks require both conversion sequences to be of
98ff7f873089b (Benjamin Kramer          2010-04-18 12:05:54 +0000  3789)   // the same kind.
98ff7f873089b (Benjamin Kramer          2010-04-18 12:05:54 +0000  3790)   if (ICS1.getKind() != ICS2.getKind())
98ff7f873089b (Benjamin Kramer          2010-04-18 12:05:54 +0000  3791)     return ImplicitConversionSequence::Indistinguishable;
98ff7f873089b (Benjamin Kramer          2010-04-18 12:05:54 +0000  3792) 
72ef7bc2b580f (Sebastian Redl           2011-11-01 15:53:09 +0000  3793)   ImplicitConversionSequence::CompareKind Result =
72ef7bc2b580f (Sebastian Redl           2011-11-01 15:53:09 +0000  3794)       ImplicitConversionSequence::Indistinguishable;
72ef7bc2b580f (Sebastian Redl           2011-11-01 15:53:09 +0000  3795) 
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  3796)   // Two implicit conversion sequences of the same form are
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  3797)   // indistinguishable conversion sequences unless one of the
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  3798)   // following rules apply: (C++ 13.3.3.2p3):
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  3799) 
19d08672844ee (Larisse Voufo            2015-01-27 18:47:05 +0000  3800)   // List-initialization sequence L1 is a better conversion sequence than
19d08672844ee (Larisse Voufo            2015-01-27 18:47:05 +0000  3801)   // list-initialization sequence L2 if:
19d08672844ee (Larisse Voufo            2015-01-27 18:47:05 +0000  3802)   // - L1 converts to std::initializer_list<X> for some X and L2 does not, or,
19d08672844ee (Larisse Voufo            2015-01-27 18:47:05 +0000  3803)   //   if not that,
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  3804)   //  L1 and L2 convert to arrays of the same element type, and either the
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  3805)   //   number of elements n_1 initialized by L1 is less than the number of
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  3806)   //   elements n_2 initialized by L2, or (unimplemented:C++20) n_1 = n_2 and L2
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  3807)   //   converts to an array of unknown bound and L1 does not,
19d08672844ee (Larisse Voufo            2015-01-27 18:47:05 +0000  3808)   // even if one of the other rules in this paragraph would otherwise apply.
19d08672844ee (Larisse Voufo            2015-01-27 18:47:05 +0000  3809)   if (!ICS1.isBad()) {
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  3810)     bool StdInit1 = false, StdInit2 = false;
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  3811) 
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  3812)     if (ICS1.isInitializerListToType())
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  3813)       StdInit1 =
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  3814)           S.isStdInitializerList(ICS1.getInitializerListToType(), nullptr);
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  3815)     if (ICS2.isInitializerListToType())
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  3816)       StdInit2 =
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  3817)           S.isStdInitializerList(ICS2.getInitializerListToType(), nullptr);
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  3818) 
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  3819)     if (StdInit1 && !StdInit2)
19d08672844ee (Larisse Voufo            2015-01-27 18:47:05 +0000  3820)       return ImplicitConversionSequence::Better;
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  3821)     if (!StdInit1 && StdInit2)
19d08672844ee (Larisse Voufo            2015-01-27 18:47:05 +0000  3822)       return ImplicitConversionSequence::Worse;
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  3823) 
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  3824)     if (ICS1.isInitializerListToType() && ICS2.isInitializerListToType()) {
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  3825)       if (auto *AT1 =
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  3826)               S.Context.getAsArrayType(ICS1.getInitializerListToType())) {
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  3827)         if (auto *AT2 =
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  3828)                 S.Context.getAsArrayType(ICS2.getInitializerListToType())) {
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  3829)           if (AT1->getElementType() == AT2->getElementType()) {
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  3830)             if (auto CAT1 = dyn_cast<ConstantArrayType>(AT1)) {
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  3831)               if (auto CAT2 = dyn_cast<ConstantArrayType>(AT2)) {
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  3832)                 if (CAT1->getSize() != CAT2->getSize())
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  3833)                   return CAT1->getSize().ult(CAT2->getSize())
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  3834)                              ? ImplicitConversionSequence::Better
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  3835)                              : ImplicitConversionSequence::Worse;
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  3836)               }
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  3837)               llvm_unreachable("C++20 incomplete array init?");
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  3838)             } else if (isa<ConstantArrayType>(AT2))
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  3839)               llvm_unreachable("C++20 incomplete array init?");
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  3840)           }
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  3841)         }
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  3842)       }
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  3843)     }
19d08672844ee (Larisse Voufo            2015-01-27 18:47:05 +0000  3844)   }
19d08672844ee (Larisse Voufo            2015-01-27 18:47:05 +0000  3845) 
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000  3846)   if (ICS1.isStandard())
19d08672844ee (Larisse Voufo            2015-01-27 18:47:05 +0000  3847)     // Standard conversion sequence S1 is a better conversion sequence than
19d08672844ee (Larisse Voufo            2015-01-27 18:47:05 +0000  3848)     // standard conversion sequence S2 if [...]
0f59cb38e7f31 (Richard Smith            2015-12-18 21:45:41 +0000  3849)     Result = CompareStandardConversionSequences(S, Loc,
72ef7bc2b580f (Sebastian Redl           2011-11-01 15:53:09 +0000  3850)                                                 ICS1.Standard, ICS2.Standard);
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000  3851)   else if (ICS1.isUserDefined()) {
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  3852)     // User-defined conversion sequence U1 is a better conversion
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  3853)     // sequence than another user-defined conversion sequence U2 if
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  3854)     // they contain the same user-defined conversion function or
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  3855)     // constructor and if the second standard conversion sequence of
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  3856)     // U1 is better than the second standard conversion sequence of
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  3857)     // U2 (C++ 13.3.3.2p3).
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  3858)     if (ICS1.UserDefined.ConversionFunction ==
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  3859)           ICS2.UserDefined.ConversionFunction)
0f59cb38e7f31 (Richard Smith            2015-12-18 21:45:41 +0000  3860)       Result = CompareStandardConversionSequences(S, Loc,
72ef7bc2b580f (Sebastian Redl           2011-11-01 15:53:09 +0000  3861)                                                   ICS1.UserDefined.After,
72ef7bc2b580f (Sebastian Redl           2011-11-01 15:53:09 +0000  3862)                                                   ICS2.UserDefined.After);
2837aa2932710 (Douglas Gregor           2012-02-22 17:32:19 +0000  3863)     else
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  3864)       Result = compareConversionFunctions(S,
2837aa2932710 (Douglas Gregor           2012-02-22 17:32:19 +0000  3865)                                           ICS1.UserDefined.ConversionFunction,
2837aa2932710 (Douglas Gregor           2012-02-22 17:32:19 +0000  3866)                                           ICS2.UserDefined.ConversionFunction);
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  3867)   }
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  3868) 
72ef7bc2b580f (Sebastian Redl           2011-11-01 15:53:09 +0000  3869)   return Result;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  3870) }
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  3871) 
3edc4d5ec3fdc (Douglas Gregor           2010-01-27 03:51:04 +0000  3872) // Per 13.3.3.2p3, compare the given standard conversion sequences to
3edc4d5ec3fdc (Douglas Gregor           2010-01-27 03:51:04 +0000  3873) // determine if one is a proper subset of the other.
3edc4d5ec3fdc (Douglas Gregor           2010-01-27 03:51:04 +0000  3874) static ImplicitConversionSequence::CompareKind
3edc4d5ec3fdc (Douglas Gregor           2010-01-27 03:51:04 +0000  3875) compareStandardConversionSubsets(ASTContext &Context,
3edc4d5ec3fdc (Douglas Gregor           2010-01-27 03:51:04 +0000  3876)                                  const StandardConversionSequence& SCS1,
3edc4d5ec3fdc (Douglas Gregor           2010-01-27 03:51:04 +0000  3877)                                  const StandardConversionSequence& SCS2) {
3edc4d5ec3fdc (Douglas Gregor           2010-01-27 03:51:04 +0000  3878)   ImplicitConversionSequence::CompareKind Result
3edc4d5ec3fdc (Douglas Gregor           2010-01-27 03:51:04 +0000  3879)     = ImplicitConversionSequence::Indistinguishable;
3edc4d5ec3fdc (Douglas Gregor           2010-01-27 03:51:04 +0000  3880) 
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  3881)   // the identity conversion sequence is considered to be a subsequence of
e87561aa2efec (Douglas Gregor           2010-05-23 22:10:15 +0000  3882)   // any non-identity conversion sequence
377c109f21e01 (Douglas Gregor           2011-06-05 06:15:20 +0000  3883)   if (SCS1.isIdentityConversion() && !SCS2.isIdentityConversion())
377c109f21e01 (Douglas Gregor           2011-06-05 06:15:20 +0000  3884)     return ImplicitConversionSequence::Better;
377c109f21e01 (Douglas Gregor           2011-06-05 06:15:20 +0000  3885)   else if (!SCS1.isIdentityConversion() && SCS2.isIdentityConversion())
377c109f21e01 (Douglas Gregor           2011-06-05 06:15:20 +0000  3886)     return ImplicitConversionSequence::Worse;
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  3887) 
3edc4d5ec3fdc (Douglas Gregor           2010-01-27 03:51:04 +0000  3888)   if (SCS1.Second != SCS2.Second) {
3edc4d5ec3fdc (Douglas Gregor           2010-01-27 03:51:04 +0000  3889)     if (SCS1.Second == ICK_Identity)
3edc4d5ec3fdc (Douglas Gregor           2010-01-27 03:51:04 +0000  3890)       Result = ImplicitConversionSequence::Better;
3edc4d5ec3fdc (Douglas Gregor           2010-01-27 03:51:04 +0000  3891)     else if (SCS2.Second == ICK_Identity)
3edc4d5ec3fdc (Douglas Gregor           2010-01-27 03:51:04 +0000  3892)       Result = ImplicitConversionSequence::Worse;
3edc4d5ec3fdc (Douglas Gregor           2010-01-27 03:51:04 +0000  3893)     else
3edc4d5ec3fdc (Douglas Gregor           2010-01-27 03:51:04 +0000  3894)       return ImplicitConversionSequence::Indistinguishable;
a3405ffcecc6a (Richard Smith            2018-07-11 00:19:19 +0000  3895)   } else if (!Context.hasSimilarType(SCS1.getToType(1), SCS2.getToType(1)))
3edc4d5ec3fdc (Douglas Gregor           2010-01-27 03:51:04 +0000  3896)     return ImplicitConversionSequence::Indistinguishable;
3edc4d5ec3fdc (Douglas Gregor           2010-01-27 03:51:04 +0000  3897) 
3edc4d5ec3fdc (Douglas Gregor           2010-01-27 03:51:04 +0000  3898)   if (SCS1.Third == SCS2.Third) {
3edc4d5ec3fdc (Douglas Gregor           2010-01-27 03:51:04 +0000  3899)     return Context.hasSameType(SCS1.getToType(2), SCS2.getToType(2))? Result
3edc4d5ec3fdc (Douglas Gregor           2010-01-27 03:51:04 +0000  3900)                              : ImplicitConversionSequence::Indistinguishable;
3edc4d5ec3fdc (Douglas Gregor           2010-01-27 03:51:04 +0000  3901)   }
3edc4d5ec3fdc (Douglas Gregor           2010-01-27 03:51:04 +0000  3902) 
3edc4d5ec3fdc (Douglas Gregor           2010-01-27 03:51:04 +0000  3903)   if (SCS1.Third == ICK_Identity)
3edc4d5ec3fdc (Douglas Gregor           2010-01-27 03:51:04 +0000  3904)     return Result == ImplicitConversionSequence::Worse
3edc4d5ec3fdc (Douglas Gregor           2010-01-27 03:51:04 +0000  3905)              ? ImplicitConversionSequence::Indistinguishable
3edc4d5ec3fdc (Douglas Gregor           2010-01-27 03:51:04 +0000  3906)              : ImplicitConversionSequence::Better;
3edc4d5ec3fdc (Douglas Gregor           2010-01-27 03:51:04 +0000  3907) 
3edc4d5ec3fdc (Douglas Gregor           2010-01-27 03:51:04 +0000  3908)   if (SCS2.Third == ICK_Identity)
3edc4d5ec3fdc (Douglas Gregor           2010-01-27 03:51:04 +0000  3909)     return Result == ImplicitConversionSequence::Better
3edc4d5ec3fdc (Douglas Gregor           2010-01-27 03:51:04 +0000  3910)              ? ImplicitConversionSequence::Indistinguishable
3edc4d5ec3fdc (Douglas Gregor           2010-01-27 03:51:04 +0000  3911)              : ImplicitConversionSequence::Worse;
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  3912) 
3edc4d5ec3fdc (Douglas Gregor           2010-01-27 03:51:04 +0000  3913)   return ImplicitConversionSequence::Indistinguishable;
3edc4d5ec3fdc (Douglas Gregor           2010-01-27 03:51:04 +0000  3914) }
3edc4d5ec3fdc (Douglas Gregor           2010-01-27 03:51:04 +0000  3915) 
9fc8faf9e6197 (Adrian Prantl            2018-05-09 01:00:01 +0000  3916) /// Determine whether one of the given reference bindings is better
e696ebbd70b3d (Douglas Gregor           2011-01-26 14:52:12 +0000  3917) /// than the other based on what kind of bindings they are.
19172c4f70fac (Richard Smith            2014-07-14 02:28:44 +0000  3918) static bool
19172c4f70fac (Richard Smith            2014-07-14 02:28:44 +0000  3919) isBetterReferenceBindingKind(const StandardConversionSequence &SCS1,
19172c4f70fac (Richard Smith            2014-07-14 02:28:44 +0000  3920)                              const StandardConversionSequence &SCS2) {
e696ebbd70b3d (Douglas Gregor           2011-01-26 14:52:12 +0000  3921)   // C++0x [over.ics.rank]p3b4:
e696ebbd70b3d (Douglas Gregor           2011-01-26 14:52:12 +0000  3922)   //   -- S1 and S2 are reference bindings (8.5.3) and neither refers to an
e696ebbd70b3d (Douglas Gregor           2011-01-26 14:52:12 +0000  3923)   //      implicit object parameter of a non-static member function declared
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  3924)   //      without a ref-qualifier, and *either* S1 binds an rvalue reference
e696ebbd70b3d (Douglas Gregor           2011-01-26 14:52:12 +0000  3925)   //      to an rvalue and S2 binds an lvalue reference *or S1 binds an
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  3926)   //      lvalue reference to a function lvalue and S2 binds an rvalue
e696ebbd70b3d (Douglas Gregor           2011-01-26 14:52:12 +0000  3927)   //      reference*.
e696ebbd70b3d (Douglas Gregor           2011-01-26 14:52:12 +0000  3928)   //
e696ebbd70b3d (Douglas Gregor           2011-01-26 14:52:12 +0000  3929)   // FIXME: Rvalue references. We're going rogue with the above edits,
e696ebbd70b3d (Douglas Gregor           2011-01-26 14:52:12 +0000  3930)   // because the semantics in the current C++0x working paper (N3225 at the
e696ebbd70b3d (Douglas Gregor           2011-01-26 14:52:12 +0000  3931)   // time of this writing) break the standard definition of std::forward
e696ebbd70b3d (Douglas Gregor           2011-01-26 14:52:12 +0000  3932)   // and std::reference_wrapper when dealing with references to functions.
e696ebbd70b3d (Douglas Gregor           2011-01-26 14:52:12 +0000  3933)   // Proposed wording changes submitted to CWG for consideration.
e1a47c176656a (Douglas Gregor           2011-01-26 19:41:18 +0000  3934)   if (SCS1.BindsImplicitObjectArgumentWithoutRefQualifier ||
e1a47c176656a (Douglas Gregor           2011-01-26 19:41:18 +0000  3935)       SCS2.BindsImplicitObjectArgumentWithoutRefQualifier)
e1a47c176656a (Douglas Gregor           2011-01-26 19:41:18 +0000  3936)     return false;
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  3937) 
e696ebbd70b3d (Douglas Gregor           2011-01-26 14:52:12 +0000  3938)   return (!SCS1.IsLvalueReference && SCS1.BindsToRvalue &&
e696ebbd70b3d (Douglas Gregor           2011-01-26 14:52:12 +0000  3939)           SCS2.IsLvalueReference) ||
e696ebbd70b3d (Douglas Gregor           2011-01-26 14:52:12 +0000  3940)          (SCS1.IsLvalueReference && SCS1.BindsToFunctionLvalue &&
19172c4f70fac (Richard Smith            2014-07-14 02:28:44 +0000  3941)           !SCS2.IsLvalueReference && SCS2.BindsToFunctionLvalue);
e696ebbd70b3d (Douglas Gregor           2011-01-26 14:52:12 +0000  3942) }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  3943) 
344df110e56fa (Richard Smith            2019-10-06 18:50:40 +0000  3944) enum class FixedEnumPromotion {
344df110e56fa (Richard Smith            2019-10-06 18:50:40 +0000  3945)   None,
344df110e56fa (Richard Smith            2019-10-06 18:50:40 +0000  3946)   ToUnderlyingType,
344df110e56fa (Richard Smith            2019-10-06 18:50:40 +0000  3947)   ToPromotedUnderlyingType
344df110e56fa (Richard Smith            2019-10-06 18:50:40 +0000  3948) };
344df110e56fa (Richard Smith            2019-10-06 18:50:40 +0000  3949) 
344df110e56fa (Richard Smith            2019-10-06 18:50:40 +0000  3950) /// Returns kind of fixed enum promotion the \a SCS uses.
344df110e56fa (Richard Smith            2019-10-06 18:50:40 +0000  3951) static FixedEnumPromotion
344df110e56fa (Richard Smith            2019-10-06 18:50:40 +0000  3952) getFixedEnumPromtion(Sema &S, const StandardConversionSequence &SCS) {
344df110e56fa (Richard Smith            2019-10-06 18:50:40 +0000  3953) 
344df110e56fa (Richard Smith            2019-10-06 18:50:40 +0000  3954)   if (SCS.Second != ICK_Integral_Promotion)
344df110e56fa (Richard Smith            2019-10-06 18:50:40 +0000  3955)     return FixedEnumPromotion::None;
344df110e56fa (Richard Smith            2019-10-06 18:50:40 +0000  3956) 
344df110e56fa (Richard Smith            2019-10-06 18:50:40 +0000  3957)   QualType FromType = SCS.getFromType();
344df110e56fa (Richard Smith            2019-10-06 18:50:40 +0000  3958)   if (!FromType->isEnumeralType())
344df110e56fa (Richard Smith            2019-10-06 18:50:40 +0000  3959)     return FixedEnumPromotion::None;
344df110e56fa (Richard Smith            2019-10-06 18:50:40 +0000  3960) 
2901dc7575873 (Simon Pilgrim            2021-04-06 12:04:01 +0100  3961)   EnumDecl *Enum = FromType->castAs<EnumType>()->getDecl();
344df110e56fa (Richard Smith            2019-10-06 18:50:40 +0000  3962)   if (!Enum->isFixed())
344df110e56fa (Richard Smith            2019-10-06 18:50:40 +0000  3963)     return FixedEnumPromotion::None;
344df110e56fa (Richard Smith            2019-10-06 18:50:40 +0000  3964) 
344df110e56fa (Richard Smith            2019-10-06 18:50:40 +0000  3965)   QualType UnderlyingType = Enum->getIntegerType();
344df110e56fa (Richard Smith            2019-10-06 18:50:40 +0000  3966)   if (S.Context.hasSameType(SCS.getToType(1), UnderlyingType))
344df110e56fa (Richard Smith            2019-10-06 18:50:40 +0000  3967)     return FixedEnumPromotion::ToUnderlyingType;
344df110e56fa (Richard Smith            2019-10-06 18:50:40 +0000  3968) 
344df110e56fa (Richard Smith            2019-10-06 18:50:40 +0000  3969)   return FixedEnumPromotion::ToPromotedUnderlyingType;
344df110e56fa (Richard Smith            2019-10-06 18:50:40 +0000  3970) }
344df110e56fa (Richard Smith            2019-10-06 18:50:40 +0000  3971) 
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  3972) /// CompareStandardConversionSequences - Compare two standard
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  3973) /// conversion sequences to determine whether one is better than the
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  3974) /// other or if they are indistinguishable (C++ 13.3.3.2p3).
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  3975) static ImplicitConversionSequence::CompareKind
0f59cb38e7f31 (Richard Smith            2015-12-18 21:45:41 +0000  3976) CompareStandardConversionSequences(Sema &S, SourceLocation Loc,
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  3977)                                    const StandardConversionSequence& SCS1,
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  3978)                                    const StandardConversionSequence& SCS2)
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  3979) {
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  3980)   // Standard conversion sequence S1 is a better conversion sequence
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  3981)   // than standard conversion sequence S2 if (C++ 13.3.3.2p3):
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  3982) 
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  3983)   //  -- S1 is a proper subsequence of S2 (comparing the conversion
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  3984)   //     sequences in the canonical form defined by 13.3.3.1.1,
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  3985)   //     excluding any Lvalue Transformation; the identity conversion
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  3986)   //     sequence is considered to be a subsequence of any
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  3987)   //     non-identity conversion sequence) or, if not that,
3edc4d5ec3fdc (Douglas Gregor           2010-01-27 03:51:04 +0000  3988)   if (ImplicitConversionSequence::CompareKind CK
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  3989)         = compareStandardConversionSubsets(S.Context, SCS1, SCS2))
3edc4d5ec3fdc (Douglas Gregor           2010-01-27 03:51:04 +0000  3990)     return CK;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  3991) 
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  3992)   //  -- the rank of S1 is better than the rank of S2 (by the rules
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  3993)   //     defined below), or, if not that,
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  3994)   ImplicitConversionRank Rank1 = SCS1.getRank();
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  3995)   ImplicitConversionRank Rank2 = SCS2.getRank();
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  3996)   if (Rank1 < Rank2)
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  3997)     return ImplicitConversionSequence::Better;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  3998)   else if (Rank2 < Rank1)
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  3999)     return ImplicitConversionSequence::Worse;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  4000) 
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4001)   // (C++ 13.3.3.2p4): Two conversion sequences with the same rank
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4002)   // are indistinguishable unless one of the following rules
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4003)   // applies:
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  4004) 
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4005)   //   A conversion that is not a conversion of a pointer, or
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4006)   //   pointer to member, to bool is better than another conversion
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4007)   //   that is such a conversion.
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4008)   if (SCS1.isPointerConversionToBool() != SCS2.isPointerConversionToBool())
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4009)     return SCS2.isPointerConversionToBool()
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4010)              ? ImplicitConversionSequence::Better
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4011)              : ImplicitConversionSequence::Worse;
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4012) 
344df110e56fa (Richard Smith            2019-10-06 18:50:40 +0000  4013)   // C++14 [over.ics.rank]p4b2:
344df110e56fa (Richard Smith            2019-10-06 18:50:40 +0000  4014)   // This is retroactively applied to C++11 by CWG 1601.
344df110e56fa (Richard Smith            2019-10-06 18:50:40 +0000  4015)   //
344df110e56fa (Richard Smith            2019-10-06 18:50:40 +0000  4016)   //   A conversion that promotes an enumeration whose underlying type is fixed
344df110e56fa (Richard Smith            2019-10-06 18:50:40 +0000  4017)   //   to its underlying type is better than one that promotes to the promoted
344df110e56fa (Richard Smith            2019-10-06 18:50:40 +0000  4018)   //   underlying type, if the two are different.
344df110e56fa (Richard Smith            2019-10-06 18:50:40 +0000  4019)   FixedEnumPromotion FEP1 = getFixedEnumPromtion(S, SCS1);
344df110e56fa (Richard Smith            2019-10-06 18:50:40 +0000  4020)   FixedEnumPromotion FEP2 = getFixedEnumPromtion(S, SCS2);
344df110e56fa (Richard Smith            2019-10-06 18:50:40 +0000  4021)   if (FEP1 != FixedEnumPromotion::None && FEP2 != FixedEnumPromotion::None &&
344df110e56fa (Richard Smith            2019-10-06 18:50:40 +0000  4022)       FEP1 != FEP2)
344df110e56fa (Richard Smith            2019-10-06 18:50:40 +0000  4023)     return FEP1 == FixedEnumPromotion::ToUnderlyingType
344df110e56fa (Richard Smith            2019-10-06 18:50:40 +0000  4024)                ? ImplicitConversionSequence::Better
344df110e56fa (Richard Smith            2019-10-06 18:50:40 +0000  4025)                : ImplicitConversionSequence::Worse;
344df110e56fa (Richard Smith            2019-10-06 18:50:40 +0000  4026) 
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000  4027)   // C++ [over.ics.rank]p4b2:
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000  4028)   //
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000  4029)   //   If class B is derived directly or indirectly from class A,
ef30a5ff98e19 (Douglas Gregor           2008-10-29 14:50:44 +0000  4030)   //   conversion of B* to A* is better than conversion of B* to
ef30a5ff98e19 (Douglas Gregor           2008-10-29 14:50:44 +0000  4031)   //   void*, and conversion of A* to void* is better than conversion
ef30a5ff98e19 (Douglas Gregor           2008-10-29 14:50:44 +0000  4032)   //   of B* to void*.
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  4033)   bool SCS1ConvertsToVoid
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  4034)     = SCS1.isPointerConversionToVoidPointer(S.Context);
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  4035)   bool SCS2ConvertsToVoid
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  4036)     = SCS2.isPointerConversionToVoidPointer(S.Context);
ef30a5ff98e19 (Douglas Gregor           2008-10-29 14:50:44 +0000  4037)   if (SCS1ConvertsToVoid != SCS2ConvertsToVoid) {
ef30a5ff98e19 (Douglas Gregor           2008-10-29 14:50:44 +0000  4038)     // Exactly one of the conversion sequences is a conversion to
ef30a5ff98e19 (Douglas Gregor           2008-10-29 14:50:44 +0000  4039)     // a void pointer; it's the worse conversion.
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000  4040)     return SCS2ConvertsToVoid ? ImplicitConversionSequence::Better
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000  4041)                               : ImplicitConversionSequence::Worse;
ef30a5ff98e19 (Douglas Gregor           2008-10-29 14:50:44 +0000  4042)   } else if (!SCS1ConvertsToVoid && !SCS2ConvertsToVoid) {
ef30a5ff98e19 (Douglas Gregor           2008-10-29 14:50:44 +0000  4043)     // Neither conversion sequence converts to a void pointer; compare
ef30a5ff98e19 (Douglas Gregor           2008-10-29 14:50:44 +0000  4044)     // their derived-to-base conversions.
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000  4045)     if (ImplicitConversionSequence::CompareKind DerivedCK
0f59cb38e7f31 (Richard Smith            2015-12-18 21:45:41 +0000  4046)           = CompareDerivedToBaseConversions(S, Loc, SCS1, SCS2))
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000  4047)       return DerivedCK;
30ee16f5ddbdf (Douglas Gregor           2011-04-27 00:01:52 +0000  4048)   } else if (SCS1ConvertsToVoid && SCS2ConvertsToVoid &&
30ee16f5ddbdf (Douglas Gregor           2011-04-27 00:01:52 +0000  4049)              !S.Context.hasSameType(SCS1.getFromType(), SCS2.getFromType())) {
ef30a5ff98e19 (Douglas Gregor           2008-10-29 14:50:44 +0000  4050)     // Both conversion sequences are conversions to void
ef30a5ff98e19 (Douglas Gregor           2008-10-29 14:50:44 +0000  4051)     // pointers. Compare the source types to determine if there's an
ef30a5ff98e19 (Douglas Gregor           2008-10-29 14:50:44 +0000  4052)     // inheritance relationship in their sources.
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000  4053)     QualType FromType1 = SCS1.getFromType();
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000  4054)     QualType FromType2 = SCS2.getFromType();
ef30a5ff98e19 (Douglas Gregor           2008-10-29 14:50:44 +0000  4055) 
ef30a5ff98e19 (Douglas Gregor           2008-10-29 14:50:44 +0000  4056)     // Adjust the types we're converting from via the array-to-pointer
ef30a5ff98e19 (Douglas Gregor           2008-10-29 14:50:44 +0000  4057)     // conversion, if we need to.
ef30a5ff98e19 (Douglas Gregor           2008-10-29 14:50:44 +0000  4058)     if (SCS1.First == ICK_Array_To_Pointer)
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  4059)       FromType1 = S.Context.getArrayDecayedType(FromType1);
ef30a5ff98e19 (Douglas Gregor           2008-10-29 14:50:44 +0000  4060)     if (SCS2.First == ICK_Array_To_Pointer)
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  4061)       FromType2 = S.Context.getArrayDecayedType(FromType2);
ef30a5ff98e19 (Douglas Gregor           2008-10-29 14:50:44 +0000  4062) 
30ee16f5ddbdf (Douglas Gregor           2011-04-27 00:01:52 +0000  4063)     QualType FromPointee1 = FromType1->getPointeeType().getUnqualifiedType();
30ee16f5ddbdf (Douglas Gregor           2011-04-27 00:01:52 +0000  4064)     QualType FromPointee2 = FromType2->getPointeeType().getUnqualifiedType();
1aa450a07872e (Douglas Gregor           2009-12-13 21:37:05 +0000  4065) 
0f59cb38e7f31 (Richard Smith            2015-12-18 21:45:41 +0000  4066)     if (S.IsDerivedFrom(Loc, FromPointee2, FromPointee1))
1aa450a07872e (Douglas Gregor           2009-12-13 21:37:05 +0000  4067)       return ImplicitConversionSequence::Better;
0f59cb38e7f31 (Richard Smith            2015-12-18 21:45:41 +0000  4068)     else if (S.IsDerivedFrom(Loc, FromPointee1, FromPointee2))
1aa450a07872e (Douglas Gregor           2009-12-13 21:37:05 +0000  4069)       return ImplicitConversionSequence::Worse;
1aa450a07872e (Douglas Gregor           2009-12-13 21:37:05 +0000  4070) 
1aa450a07872e (Douglas Gregor           2009-12-13 21:37:05 +0000  4071)     // Objective-C++: If one interface is more specific than the
1aa450a07872e (Douglas Gregor           2009-12-13 21:37:05 +0000  4072)     // other, it is the better one.
30ee16f5ddbdf (Douglas Gregor           2011-04-27 00:01:52 +0000  4073)     const ObjCObjectPointerType* FromObjCPtr1
30ee16f5ddbdf (Douglas Gregor           2011-04-27 00:01:52 +0000  4074)       = FromType1->getAs<ObjCObjectPointerType>();
30ee16f5ddbdf (Douglas Gregor           2011-04-27 00:01:52 +0000  4075)     const ObjCObjectPointerType* FromObjCPtr2
30ee16f5ddbdf (Douglas Gregor           2011-04-27 00:01:52 +0000  4076)       = FromType2->getAs<ObjCObjectPointerType>();
30ee16f5ddbdf (Douglas Gregor           2011-04-27 00:01:52 +0000  4077)     if (FromObjCPtr1 && FromObjCPtr2) {
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  4078)       bool AssignLeft = S.Context.canAssignObjCInterfaces(FromObjCPtr1,
30ee16f5ddbdf (Douglas Gregor           2011-04-27 00:01:52 +0000  4079)                                                           FromObjCPtr2);
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  4080)       bool AssignRight = S.Context.canAssignObjCInterfaces(FromObjCPtr2,
30ee16f5ddbdf (Douglas Gregor           2011-04-27 00:01:52 +0000  4081)                                                            FromObjCPtr1);
30ee16f5ddbdf (Douglas Gregor           2011-04-27 00:01:52 +0000  4082)       if (AssignLeft != AssignRight) {
30ee16f5ddbdf (Douglas Gregor           2011-04-27 00:01:52 +0000  4083)         return AssignLeft? ImplicitConversionSequence::Better
30ee16f5ddbdf (Douglas Gregor           2011-04-27 00:01:52 +0000  4084)                          : ImplicitConversionSequence::Worse;
30ee16f5ddbdf (Douglas Gregor           2011-04-27 00:01:52 +0000  4085)       }
1aa450a07872e (Douglas Gregor           2009-12-13 21:37:05 +0000  4086)     }
ef30a5ff98e19 (Douglas Gregor           2008-10-29 14:50:44 +0000  4087)   }
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4088) 
ef30a5ff98e19 (Douglas Gregor           2008-10-29 14:50:44 +0000  4089)   if (SCS1.ReferenceBinding && SCS2.ReferenceBinding) {
e696ebbd70b3d (Douglas Gregor           2011-01-26 14:52:12 +0000  4090)     // Check for a better reference binding based on the kind of bindings.
e696ebbd70b3d (Douglas Gregor           2011-01-26 14:52:12 +0000  4091)     if (isBetterReferenceBindingKind(SCS1, SCS2))
e696ebbd70b3d (Douglas Gregor           2011-01-26 14:52:12 +0000  4092)       return ImplicitConversionSequence::Better;
e696ebbd70b3d (Douglas Gregor           2011-01-26 14:52:12 +0000  4093)     else if (isBetterReferenceBindingKind(SCS2, SCS1))
e696ebbd70b3d (Douglas Gregor           2011-01-26 14:52:12 +0000  4094)       return ImplicitConversionSequence::Worse;
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4095)   }
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4096) 
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4097)   // Compare based on qualification conversions (C++ 13.3.3.2p3,
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4098)   // bullet 3).
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4099)   if (ImplicitConversionSequence::CompareKind QualCK
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4100)         = CompareQualificationConversions(S, SCS1, SCS2))
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4101)     return QualCK;
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  4102) 
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4103)   if (SCS1.ReferenceBinding && SCS2.ReferenceBinding) {
b28b40712121c (Sebastian Redl           2009-03-22 23:49:27 +0000  4104)     // C++ [over.ics.rank]p3b4:
b28b40712121c (Sebastian Redl           2009-03-22 23:49:27 +0000  4105)     //   -- S1 and S2 are reference bindings (8.5.3), and the types to
b28b40712121c (Sebastian Redl           2009-03-22 23:49:27 +0000  4106)     //      which the references refer are the same type except for
b28b40712121c (Sebastian Redl           2009-03-22 23:49:27 +0000  4107)     //      top-level cv-qualifiers, and the type to which the reference
b28b40712121c (Sebastian Redl           2009-03-22 23:49:27 +0000  4108)     //      initialized by S2 refers is more cv-qualified than the type
b28b40712121c (Sebastian Redl           2009-03-22 23:49:27 +0000  4109)     //      to which the reference initialized by S1 refers.
3edc4d5ec3fdc (Douglas Gregor           2010-01-27 03:51:04 +0000  4110)     QualType T1 = SCS1.getToType(2);
3edc4d5ec3fdc (Douglas Gregor           2010-01-27 03:51:04 +0000  4111)     QualType T2 = SCS2.getToType(2);
d8018233d1ea4 (David Blaikie            2019-12-27 12:17:01 -0800  4112)     T1 = S.Context.getCanonicalType(T1);
d8018233d1ea4 (David Blaikie            2019-12-27 12:17:01 -0800  4113)     T2 = S.Context.getCanonicalType(T2);
d8018233d1ea4 (David Blaikie            2019-12-27 12:17:01 -0800  4114)     Qualifiers T1Quals, T2Quals;
d8018233d1ea4 (David Blaikie            2019-12-27 12:17:01 -0800  4115)     QualType UnqualT1 = S.Context.getUnqualifiedArrayType(T1, T1Quals);
d8018233d1ea4 (David Blaikie            2019-12-27 12:17:01 -0800  4116)     QualType UnqualT2 = S.Context.getUnqualifiedArrayType(T2, T2Quals);
d8018233d1ea4 (David Blaikie            2019-12-27 12:17:01 -0800  4117)     if (UnqualT1 == UnqualT2) {
d8018233d1ea4 (David Blaikie            2019-12-27 12:17:01 -0800  4118)       // Objective-C++ ARC: If the references refer to objects with different
d8018233d1ea4 (David Blaikie            2019-12-27 12:17:01 -0800  4119)       // lifetimes, prefer bindings that don't change lifetime.
d8018233d1ea4 (David Blaikie            2019-12-27 12:17:01 -0800  4120)       if (SCS1.ObjCLifetimeConversionBinding !=
d8018233d1ea4 (David Blaikie            2019-12-27 12:17:01 -0800  4121)                                           SCS2.ObjCLifetimeConversionBinding) {
d8018233d1ea4 (David Blaikie            2019-12-27 12:17:01 -0800  4122)         return SCS1.ObjCLifetimeConversionBinding
d8018233d1ea4 (David Blaikie            2019-12-27 12:17:01 -0800  4123)                                            ? ImplicitConversionSequence::Worse
d8018233d1ea4 (David Blaikie            2019-12-27 12:17:01 -0800  4124)                                            : ImplicitConversionSequence::Better;
d8018233d1ea4 (David Blaikie            2019-12-27 12:17:01 -0800  4125)       }
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  4126) 
d8018233d1ea4 (David Blaikie            2019-12-27 12:17:01 -0800  4127)       // If the type is an array type, promote the element qualifiers to the
d8018233d1ea4 (David Blaikie            2019-12-27 12:17:01 -0800  4128)       // type for comparison.
d8018233d1ea4 (David Blaikie            2019-12-27 12:17:01 -0800  4129)       if (isa<ArrayType>(T1) && T1Quals)
d8018233d1ea4 (David Blaikie            2019-12-27 12:17:01 -0800  4130)         T1 = S.Context.getQualifiedType(UnqualT1, T1Quals);
d8018233d1ea4 (David Blaikie            2019-12-27 12:17:01 -0800  4131)       if (isa<ArrayType>(T2) && T2Quals)
d8018233d1ea4 (David Blaikie            2019-12-27 12:17:01 -0800  4132)         T2 = S.Context.getQualifiedType(UnqualT2, T2Quals);
d8018233d1ea4 (David Blaikie            2019-12-27 12:17:01 -0800  4133)       if (T2.isMoreQualifiedThan(T1))
ef30a5ff98e19 (Douglas Gregor           2008-10-29 14:50:44 +0000  4134)         return ImplicitConversionSequence::Better;
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4135)       if (T1.isMoreQualifiedThan(T2))
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  4136)         return ImplicitConversionSequence::Worse;
ef30a5ff98e19 (Douglas Gregor           2008-10-29 14:50:44 +0000  4137)     }
ef30a5ff98e19 (Douglas Gregor           2008-10-29 14:50:44 +0000  4138)   }
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4139) 
2ec7f639c49fd (Marek Kurdej             2021-04-02 08:57:42 +0200  4140)   // In Microsoft mode (below 19.28), prefer an integral conversion to a
08d2fa0a78216 (Francois Pichet          2011-09-18 21:37:37 +0000  4141)   // floating-to-integral conversion if the integral conversion
08d2fa0a78216 (Francois Pichet          2011-09-18 21:37:37 +0000  4142)   // is between types of the same size.
08d2fa0a78216 (Francois Pichet          2011-09-18 21:37:37 +0000  4143)   // For example:
08d2fa0a78216 (Francois Pichet          2011-09-18 21:37:37 +0000  4144)   // void f(float);
08d2fa0a78216 (Francois Pichet          2011-09-18 21:37:37 +0000  4145)   // void f(int);
08d2fa0a78216 (Francois Pichet          2011-09-18 21:37:37 +0000  4146)   // int main {
08d2fa0a78216 (Francois Pichet          2011-09-18 21:37:37 +0000  4147)   //    long a;
08d2fa0a78216 (Francois Pichet          2011-09-18 21:37:37 +0000  4148)   //    f(a);
08d2fa0a78216 (Francois Pichet          2011-09-18 21:37:37 +0000  4149)   // }
08d2fa0a78216 (Francois Pichet          2011-09-18 21:37:37 +0000  4150)   // Here, MSVC will call f(int) instead of generating a compile error
08d2fa0a78216 (Francois Pichet          2011-09-18 21:37:37 +0000  4151)   // as clang will do in standard mode.
2ec7f639c49fd (Marek Kurdej             2021-04-02 08:57:42 +0200  4152)   if (S.getLangOpts().MSVCCompat &&
2ec7f639c49fd (Marek Kurdej             2021-04-02 08:57:42 +0200  4153)       !S.getLangOpts().isCompatibleWithMSVC(LangOptions::MSVC2019_8) &&
2ec7f639c49fd (Marek Kurdej             2021-04-02 08:57:42 +0200  4154)       SCS1.Second == ICK_Integral_Conversion &&
bfa3934f27e72 (Alp Toker                2014-01-14 12:51:41 +0000  4155)       SCS2.Second == ICK_Floating_Integral &&
08d2fa0a78216 (Francois Pichet          2011-09-18 21:37:37 +0000  4156)       S.Context.getTypeSize(SCS1.getFromType()) ==
bfa3934f27e72 (Alp Toker                2014-01-14 12:51:41 +0000  4157)           S.Context.getTypeSize(SCS1.getToType(2)))
08d2fa0a78216 (Francois Pichet          2011-09-18 21:37:37 +0000  4158)     return ImplicitConversionSequence::Better;
08d2fa0a78216 (Francois Pichet          2011-09-18 21:37:37 +0000  4159) 
64d85a29edd8d (Zi Xuan Wu               2018-11-16 03:00:00 +0000  4160)   // Prefer a compatible vector conversion over a lax vector conversion
64d85a29edd8d (Zi Xuan Wu               2018-11-16 03:00:00 +0000  4161)   // For example:
64d85a29edd8d (Zi Xuan Wu               2018-11-16 03:00:00 +0000  4162)   //
64d85a29edd8d (Zi Xuan Wu               2018-11-16 03:00:00 +0000  4163)   // typedef float __v4sf __attribute__((__vector_size__(16)));
64d85a29edd8d (Zi Xuan Wu               2018-11-16 03:00:00 +0000  4164)   // void f(vector float);
64d85a29edd8d (Zi Xuan Wu               2018-11-16 03:00:00 +0000  4165)   // void f(vector signed int);
64d85a29edd8d (Zi Xuan Wu               2018-11-16 03:00:00 +0000  4166)   // int main() {
64d85a29edd8d (Zi Xuan Wu               2018-11-16 03:00:00 +0000  4167)   //   __v4sf a;
64d85a29edd8d (Zi Xuan Wu               2018-11-16 03:00:00 +0000  4168)   //   f(a);
64d85a29edd8d (Zi Xuan Wu               2018-11-16 03:00:00 +0000  4169)   // }
64d85a29edd8d (Zi Xuan Wu               2018-11-16 03:00:00 +0000  4170)   // Here, we'd like to choose f(vector float) and not
64d85a29edd8d (Zi Xuan Wu               2018-11-16 03:00:00 +0000  4171)   // report an ambiguous call error
64d85a29edd8d (Zi Xuan Wu               2018-11-16 03:00:00 +0000  4172)   if (SCS1.Second == ICK_Vector_Conversion &&
64d85a29edd8d (Zi Xuan Wu               2018-11-16 03:00:00 +0000  4173)       SCS2.Second == ICK_Vector_Conversion) {
64d85a29edd8d (Zi Xuan Wu               2018-11-16 03:00:00 +0000  4174)     bool SCS1IsCompatibleVectorConversion = S.Context.areCompatibleVectorTypes(
64d85a29edd8d (Zi Xuan Wu               2018-11-16 03:00:00 +0000  4175)         SCS1.getFromType(), SCS1.getToType(2));
64d85a29edd8d (Zi Xuan Wu               2018-11-16 03:00:00 +0000  4176)     bool SCS2IsCompatibleVectorConversion = S.Context.areCompatibleVectorTypes(
64d85a29edd8d (Zi Xuan Wu               2018-11-16 03:00:00 +0000  4177)         SCS2.getFromType(), SCS2.getToType(2));
64d85a29edd8d (Zi Xuan Wu               2018-11-16 03:00:00 +0000  4178) 
64d85a29edd8d (Zi Xuan Wu               2018-11-16 03:00:00 +0000  4179)     if (SCS1IsCompatibleVectorConversion != SCS2IsCompatibleVectorConversion)
64d85a29edd8d (Zi Xuan Wu               2018-11-16 03:00:00 +0000  4180)       return SCS1IsCompatibleVectorConversion
64d85a29edd8d (Zi Xuan Wu               2018-11-16 03:00:00 +0000  4181)                  ? ImplicitConversionSequence::Better
64d85a29edd8d (Zi Xuan Wu               2018-11-16 03:00:00 +0000  4182)                  : ImplicitConversionSequence::Worse;
64d85a29edd8d (Zi Xuan Wu               2018-11-16 03:00:00 +0000  4183)   }
64d85a29edd8d (Zi Xuan Wu               2018-11-16 03:00:00 +0000  4184) 
feed5a7239d8e (Cullen Rhodes            2020-08-11 13:04:21 +0000  4185)   if (SCS1.Second == ICK_SVE_Vector_Conversion &&
feed5a7239d8e (Cullen Rhodes            2020-08-11 13:04:21 +0000  4186)       SCS2.Second == ICK_SVE_Vector_Conversion) {
feed5a7239d8e (Cullen Rhodes            2020-08-11 13:04:21 +0000  4187)     bool SCS1IsCompatibleSVEVectorConversion =
feed5a7239d8e (Cullen Rhodes            2020-08-11 13:04:21 +0000  4188)         S.Context.areCompatibleSveTypes(SCS1.getFromType(), SCS1.getToType(2));
feed5a7239d8e (Cullen Rhodes            2020-08-11 13:04:21 +0000  4189)     bool SCS2IsCompatibleSVEVectorConversion =
feed5a7239d8e (Cullen Rhodes            2020-08-11 13:04:21 +0000  4190)         S.Context.areCompatibleSveTypes(SCS2.getFromType(), SCS2.getToType(2));
feed5a7239d8e (Cullen Rhodes            2020-08-11 13:04:21 +0000  4191) 
feed5a7239d8e (Cullen Rhodes            2020-08-11 13:04:21 +0000  4192)     if (SCS1IsCompatibleSVEVectorConversion !=
feed5a7239d8e (Cullen Rhodes            2020-08-11 13:04:21 +0000  4193)         SCS2IsCompatibleSVEVectorConversion)
feed5a7239d8e (Cullen Rhodes            2020-08-11 13:04:21 +0000  4194)       return SCS1IsCompatibleSVEVectorConversion
feed5a7239d8e (Cullen Rhodes            2020-08-11 13:04:21 +0000  4195)                  ? ImplicitConversionSequence::Better
feed5a7239d8e (Cullen Rhodes            2020-08-11 13:04:21 +0000  4196)                  : ImplicitConversionSequence::Worse;
feed5a7239d8e (Cullen Rhodes            2020-08-11 13:04:21 +0000  4197)   }
feed5a7239d8e (Cullen Rhodes            2020-08-11 13:04:21 +0000  4198) 
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  4199)   return ImplicitConversionSequence::Indistinguishable;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  4200) }
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  4201) 
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4202) /// CompareQualificationConversions - Compares two standard conversion
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4203) /// sequences to determine whether they can be ranked based on their
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  4204) /// qualification conversions (C++ 13.3.3.2p3 bullet 3).
17c00b43288dc (Richard Smith            2014-11-12 01:24:00 +0000  4205) static ImplicitConversionSequence::CompareKind
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  4206) CompareQualificationConversions(Sema &S,
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  4207)                                 const StandardConversionSequence& SCS1,
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  4208)                                 const StandardConversionSequence& SCS2) {
4b62ec6353164 (Douglas Gregor           2008-10-22 15:04:37 +0000  4209)   // C++ 13.3.3.2p3:
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4210)   //  -- S1 and S2 differ only in their qualification conversion and
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4211)   //     yield similar types T1 and T2 (C++ 4.4), respectively, and the
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4212)   //     cv-qualification signature of type T1 is a proper subset of
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4213)   //     the cv-qualification signature of type T2, and S1 is not the
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4214)   //     deprecated string literal array-to-pointer conversion (4.2).
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4215)   if (SCS1.First != SCS2.First || SCS1.Second != SCS2.Second ||
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4216)       SCS1.Third != SCS2.Third || SCS1.Third != ICK_Qualification)
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4217)     return ImplicitConversionSequence::Indistinguishable;
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4218) 
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4219)   // FIXME: the example in the standard doesn't use a qualification
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4220)   // conversion (!)
3edc4d5ec3fdc (Douglas Gregor           2010-01-27 03:51:04 +0000  4221)   QualType T1 = SCS1.getToType(2);
3edc4d5ec3fdc (Douglas Gregor           2010-01-27 03:51:04 +0000  4222)   QualType T2 = SCS2.getToType(2);
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  4223)   T1 = S.Context.getCanonicalType(T1);
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  4224)   T2 = S.Context.getCanonicalType(T2);
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4225)   assert(!T1->isReferenceType() && !T2->isReferenceType());
607f38e05fac3 (Chandler Carruth         2009-12-29 07:16:59 +0000  4226)   Qualifiers T1Quals, T2Quals;
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  4227)   QualType UnqualT1 = S.Context.getUnqualifiedArrayType(T1, T1Quals);
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  4228)   QualType UnqualT2 = S.Context.getUnqualifiedArrayType(T2, T2Quals);
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4229) 
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4230)   // If the types are the same, we won't learn anything by unwrapping
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4231)   // them.
607f38e05fac3 (Chandler Carruth         2009-12-29 07:16:59 +0000  4232)   if (UnqualT1 == UnqualT2)
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4233)     return ImplicitConversionSequence::Indistinguishable;
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4234) 
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  4235)   ImplicitConversionSequence::CompareKind Result
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4236)     = ImplicitConversionSequence::Indistinguishable;
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  4237) 
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  4238)   // Objective-C++ ARC:
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  4239)   //   Prefer qualification conversions not involving a change in lifetime
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  4240)   //   to qualification conversions that do not change lifetime.
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  4241)   if (SCS1.QualificationIncludesObjCLifetime !=
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  4242)                                       SCS2.QualificationIncludesObjCLifetime) {
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  4243)     Result = SCS1.QualificationIncludesObjCLifetime
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  4244)                ? ImplicitConversionSequence::Worse
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  4245)                : ImplicitConversionSequence::Better;
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  4246)   }
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  4247) 
a3405ffcecc6a (Richard Smith            2018-07-11 00:19:19 +0000  4248)   while (S.Context.UnwrapSimilarTypes(T1, T2)) {
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4249)     // Within each iteration of the loop, we check the qualifiers to
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4250)     // determine if this still looks like a qualification
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4251)     // conversion. Then, if all is well, we unwrap one more level of
29a9247ec2515 (Douglas Gregor           2008-10-22 17:49:05 +0000  4252)     // pointers or pointers-to-members and do it all again
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4253)     // until there are no more pointers or pointers-to-members left
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4254)     // to unwrap. This essentially mimics what
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4255)     // IsQualificationConversion does, but here we're checking for a
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4256)     // strict subset of qualifiers.
ef19af19428b3 (Anastasia Stulova        2019-01-18 11:38:16 +0000  4257)     if (T1.getQualifiers().withoutObjCLifetime() ==
ef19af19428b3 (Anastasia Stulova        2019-01-18 11:38:16 +0000  4258)         T2.getQualifiers().withoutObjCLifetime())
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4259)       // The qualifiers are the same, so this doesn't tell us anything
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4260)       // about how the sequences rank.
ef19af19428b3 (Anastasia Stulova        2019-01-18 11:38:16 +0000  4261)       // ObjC ownership quals are omitted above as they interfere with
ef19af19428b3 (Anastasia Stulova        2019-01-18 11:38:16 +0000  4262)       // the ARC overload rule.
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4263)       ;
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4264)     else if (T2.isMoreQualifiedThan(T1)) {
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4265)       // T1 has fewer qualifiers, so it could be the better sequence.
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4266)       if (Result == ImplicitConversionSequence::Worse)
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4267)         // Neither has qualifiers that are a subset of the other's
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4268)         // qualifiers.
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4269)         return ImplicitConversionSequence::Indistinguishable;
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  4270) 
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4271)       Result = ImplicitConversionSequence::Better;
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4272)     } else if (T1.isMoreQualifiedThan(T2)) {
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4273)       // T2 has fewer qualifiers, so it could be the better sequence.
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4274)       if (Result == ImplicitConversionSequence::Better)
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4275)         // Neither has qualifiers that are a subset of the other's
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4276)         // qualifiers.
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4277)         return ImplicitConversionSequence::Indistinguishable;
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  4278) 
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4279)       Result = ImplicitConversionSequence::Worse;
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4280)     } else {
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4281)       // Qualifiers are disjoint.
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4282)       return ImplicitConversionSequence::Indistinguishable;
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4283)     }
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4284) 
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4285)     // If the types after this point are equivalent, we're done.
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  4286)     if (S.Context.hasSameUnqualifiedType(T1, T2))
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4287)       break;
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4288)   }
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4289) 
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4290)   // Check that the winning standard conversion sequence isn't using
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4291)   // the deprecated string literal array to pointer conversion.
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4292)   switch (Result) {
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4293)   case ImplicitConversionSequence::Better:
e489a7d3d3972 (Douglas Gregor           2010-02-28 18:30:25 +0000  4294)     if (SCS1.DeprecatedStringLiteralToCharPtr)
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4295)       Result = ImplicitConversionSequence::Indistinguishable;
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4296)     break;
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4297) 
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4298)   case ImplicitConversionSequence::Indistinguishable:
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4299)     break;
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4300) 
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4301)   case ImplicitConversionSequence::Worse:
e489a7d3d3972 (Douglas Gregor           2010-02-28 18:30:25 +0000  4302)     if (SCS2.DeprecatedStringLiteralToCharPtr)
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4303)       Result = ImplicitConversionSequence::Indistinguishable;
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4304)     break;
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4305)   }
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4306) 
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4307)   return Result;
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4308) }
e1eb9d8cc4c12 (Douglas Gregor           2008-10-22 14:17:15 +0000  4309) 
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000  4310) /// CompareDerivedToBaseConversions - Compares two standard conversion
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000  4311) /// sequences to determine whether they can be ranked based on their
237f96c40f6bf (Douglas Gregor           2008-11-26 23:31:11 +0000  4312) /// various kinds of derived-to-base conversions (C++
237f96c40f6bf (Douglas Gregor           2008-11-26 23:31:11 +0000  4313) /// [over.ics.rank]p4b3).  As part of these checks, we also look at
237f96c40f6bf (Douglas Gregor           2008-11-26 23:31:11 +0000  4314) /// conversions between Objective-C interface types.
17c00b43288dc (Richard Smith            2014-11-12 01:24:00 +0000  4315) static ImplicitConversionSequence::CompareKind
0f59cb38e7f31 (Richard Smith            2015-12-18 21:45:41 +0000  4316) CompareDerivedToBaseConversions(Sema &S, SourceLocation Loc,
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  4317)                                 const StandardConversionSequence& SCS1,
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  4318)                                 const StandardConversionSequence& SCS2) {
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000  4319)   QualType FromType1 = SCS1.getFromType();
3edc4d5ec3fdc (Douglas Gregor           2010-01-27 03:51:04 +0000  4320)   QualType ToType1 = SCS1.getToType(1);
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000  4321)   QualType FromType2 = SCS2.getFromType();
3edc4d5ec3fdc (Douglas Gregor           2010-01-27 03:51:04 +0000  4322)   QualType ToType2 = SCS2.getToType(1);
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000  4323) 
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000  4324)   // Adjust the types we're converting from via the array-to-pointer
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000  4325)   // conversion, if we need to.
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000  4326)   if (SCS1.First == ICK_Array_To_Pointer)
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  4327)     FromType1 = S.Context.getArrayDecayedType(FromType1);
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000  4328)   if (SCS2.First == ICK_Array_To_Pointer)
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  4329)     FromType2 = S.Context.getArrayDecayedType(FromType2);
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000  4330) 
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000  4331)   // Canonicalize all of the types.
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  4332)   FromType1 = S.Context.getCanonicalType(FromType1);
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  4333)   ToType1 = S.Context.getCanonicalType(ToType1);
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  4334)   FromType2 = S.Context.getCanonicalType(FromType2);
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  4335)   ToType2 = S.Context.getCanonicalType(ToType2);
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000  4336) 
ef30a5ff98e19 (Douglas Gregor           2008-10-29 14:50:44 +0000  4337)   // C++ [over.ics.rank]p4b3:
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000  4338)   //
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000  4339)   //   If class B is derived directly or indirectly from class A and
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000  4340)   //   class C is derived directly or indirectly from B,
237f96c40f6bf (Douglas Gregor           2008-11-26 23:31:11 +0000  4341)   //
ef30a5ff98e19 (Douglas Gregor           2008-10-29 14:50:44 +0000  4342)   // Compare based on pointer conversions.
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  4343)   if (SCS1.Second == ICK_Pointer_Conversion &&
a29dc05eafe20 (Douglas Gregor           2008-11-27 01:19:21 +0000  4344)       SCS2.Second == ICK_Pointer_Conversion &&
a29dc05eafe20 (Douglas Gregor           2008-11-27 01:19:21 +0000  4345)       /*FIXME: Remove if Objective-C id conversions get their own rank*/
a29dc05eafe20 (Douglas Gregor           2008-11-27 01:19:21 +0000  4346)       FromType1->isPointerType() && FromType2->isPointerType() &&
a29dc05eafe20 (Douglas Gregor           2008-11-27 01:19:21 +0000  4347)       ToType1->isPointerType() && ToType2->isPointerType()) {
ed3b68e0dc3c0 (Simon Pilgrim            2019-10-02 14:02:27 +0000  4348)     QualType FromPointee1 =
ed3b68e0dc3c0 (Simon Pilgrim            2019-10-02 14:02:27 +0000  4349)         FromType1->castAs<PointerType>()->getPointeeType().getUnqualifiedType();
ed3b68e0dc3c0 (Simon Pilgrim            2019-10-02 14:02:27 +0000  4350)     QualType ToPointee1 =
ed3b68e0dc3c0 (Simon Pilgrim            2019-10-02 14:02:27 +0000  4351)         ToType1->castAs<PointerType>()->getPointeeType().getUnqualifiedType();
ed3b68e0dc3c0 (Simon Pilgrim            2019-10-02 14:02:27 +0000  4352)     QualType FromPointee2 =
ed3b68e0dc3c0 (Simon Pilgrim            2019-10-02 14:02:27 +0000  4353)         FromType2->castAs<PointerType>()->getPointeeType().getUnqualifiedType();
ed3b68e0dc3c0 (Simon Pilgrim            2019-10-02 14:02:27 +0000  4354)     QualType ToPointee2 =
ed3b68e0dc3c0 (Simon Pilgrim            2019-10-02 14:02:27 +0000  4355)         ToType2->castAs<PointerType>()->getPointeeType().getUnqualifiedType();
237f96c40f6bf (Douglas Gregor           2008-11-26 23:31:11 +0000  4356) 
ef30a5ff98e19 (Douglas Gregor           2008-10-29 14:50:44 +0000  4357)     //   -- conversion of C* to B* is better than conversion of C* to A*,
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000  4358)     if (FromPointee1 == FromPointee2 && ToPointee1 != ToPointee2) {
0f59cb38e7f31 (Richard Smith            2015-12-18 21:45:41 +0000  4359)       if (S.IsDerivedFrom(Loc, ToPointee1, ToPointee2))
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000  4360)         return ImplicitConversionSequence::Better;
0f59cb38e7f31 (Richard Smith            2015-12-18 21:45:41 +0000  4361)       else if (S.IsDerivedFrom(Loc, ToPointee2, ToPointee1))
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000  4362)         return ImplicitConversionSequence::Worse;
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000  4363)     }
ef30a5ff98e19 (Douglas Gregor           2008-10-29 14:50:44 +0000  4364) 
ef30a5ff98e19 (Douglas Gregor           2008-10-29 14:50:44 +0000  4365)     //   -- conversion of B* to A* is better than conversion of C* to A*,
ef30a5ff98e19 (Douglas Gregor           2008-10-29 14:50:44 +0000  4366)     if (FromPointee1 != FromPointee2 && ToPointee1 == ToPointee2) {
0f59cb38e7f31 (Richard Smith            2015-12-18 21:45:41 +0000  4367)       if (S.IsDerivedFrom(Loc, FromPointee2, FromPointee1))
ef30a5ff98e19 (Douglas Gregor           2008-10-29 14:50:44 +0000  4368)         return ImplicitConversionSequence::Better;
0f59cb38e7f31 (Richard Smith            2015-12-18 21:45:41 +0000  4369)       else if (S.IsDerivedFrom(Loc, FromPointee1, FromPointee2))
ef30a5ff98e19 (Douglas Gregor           2008-10-29 14:50:44 +0000  4370)         return ImplicitConversionSequence::Worse;
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4371)     }
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4372)   } else if (SCS1.Second == ICK_Pointer_Conversion &&
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4373)              SCS2.Second == ICK_Pointer_Conversion) {
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4374)     const ObjCObjectPointerType *FromPtr1
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4375)       = FromType1->getAs<ObjCObjectPointerType>();
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4376)     const ObjCObjectPointerType *FromPtr2
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4377)       = FromType2->getAs<ObjCObjectPointerType>();
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4378)     const ObjCObjectPointerType *ToPtr1
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4379)       = ToType1->getAs<ObjCObjectPointerType>();
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4380)     const ObjCObjectPointerType *ToPtr2
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4381)       = ToType2->getAs<ObjCObjectPointerType>();
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  4382) 
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4383)     if (FromPtr1 && FromPtr2 && ToPtr1 && ToPtr2) {
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4384)       // Apply the same conversion ranking rules for Objective-C pointer types
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4385)       // that we do for C++ pointers to class types. However, we employ the
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4386)       // Objective-C pseudo-subtyping relationship used for assignment of
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4387)       // Objective-C pointer types.
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4388)       bool FromAssignLeft
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4389)         = S.Context.canAssignObjCInterfaces(FromPtr1, FromPtr2);
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4390)       bool FromAssignRight
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4391)         = S.Context.canAssignObjCInterfaces(FromPtr2, FromPtr1);
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4392)       bool ToAssignLeft
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4393)         = S.Context.canAssignObjCInterfaces(ToPtr1, ToPtr2);
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4394)       bool ToAssignRight
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4395)         = S.Context.canAssignObjCInterfaces(ToPtr2, ToPtr1);
a9832134597af (Alex Lorenz              2017-04-06 13:06:34 +0000  4396) 
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  4397)       // A conversion to an a non-id object pointer type or qualified 'id'
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4398)       // type is better than a conversion to 'id'.
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4399)       if (ToPtr1->isObjCIdType() &&
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4400)           (ToPtr2->isObjCQualifiedIdType() || ToPtr2->getInterfaceDecl()))
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4401)         return ImplicitConversionSequence::Worse;
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4402)       if (ToPtr2->isObjCIdType() &&
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4403)           (ToPtr1->isObjCQualifiedIdType() || ToPtr1->getInterfaceDecl()))
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4404)         return ImplicitConversionSequence::Better;
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  4405) 
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  4406)       // A conversion to a non-id object pointer type is better than a
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  4407)       // conversion to a qualified 'id' type
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4408)       if (ToPtr1->isObjCQualifiedIdType() && ToPtr2->getInterfaceDecl())
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4409)         return ImplicitConversionSequence::Worse;
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4410)       if (ToPtr2->isObjCQualifiedIdType() && ToPtr1->getInterfaceDecl())
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4411)         return ImplicitConversionSequence::Better;
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  4412) 
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  4413)       // A conversion to an a non-Class object pointer type or qualified 'Class'
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4414)       // type is better than a conversion to 'Class'.
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4415)       if (ToPtr1->isObjCClassType() &&
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4416)           (ToPtr2->isObjCQualifiedClassType() || ToPtr2->getInterfaceDecl()))
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4417)         return ImplicitConversionSequence::Worse;
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4418)       if (ToPtr2->isObjCClassType() &&
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4419)           (ToPtr1->isObjCQualifiedClassType() || ToPtr1->getInterfaceDecl()))
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4420)         return ImplicitConversionSequence::Better;
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  4421) 
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  4422)       // A conversion to a non-Class object pointer type is better than a
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4423)       // conversion to a qualified 'Class' type.
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4424)       if (ToPtr1->isObjCQualifiedClassType() && ToPtr2->getInterfaceDecl())
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4425)         return ImplicitConversionSequence::Worse;
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4426)       if (ToPtr2->isObjCQualifiedClassType() && ToPtr1->getInterfaceDecl())
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4427)         return ImplicitConversionSequence::Better;
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  4428) 
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4429)       //   -- "conversion of C* to B* is better than conversion of C* to A*,"
a9832134597af (Alex Lorenz              2017-04-06 13:06:34 +0000  4430)       if (S.Context.hasSameType(FromType1, FromType2) &&
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4431)           !FromPtr1->isObjCIdType() && !FromPtr1->isObjCClassType() &&
a9832134597af (Alex Lorenz              2017-04-06 13:06:34 +0000  4432)           (ToAssignLeft != ToAssignRight)) {
a9832134597af (Alex Lorenz              2017-04-06 13:06:34 +0000  4433)         if (FromPtr1->isSpecialized()) {
a9832134597af (Alex Lorenz              2017-04-06 13:06:34 +0000  4434)           // "conversion of B<A> * to B * is better than conversion of B * to
a9832134597af (Alex Lorenz              2017-04-06 13:06:34 +0000  4435)           // C *.
a9832134597af (Alex Lorenz              2017-04-06 13:06:34 +0000  4436)           bool IsFirstSame =
a9832134597af (Alex Lorenz              2017-04-06 13:06:34 +0000  4437)               FromPtr1->getInterfaceDecl() == ToPtr1->getInterfaceDecl();
a9832134597af (Alex Lorenz              2017-04-06 13:06:34 +0000  4438)           bool IsSecondSame =
a9832134597af (Alex Lorenz              2017-04-06 13:06:34 +0000  4439)               FromPtr1->getInterfaceDecl() == ToPtr2->getInterfaceDecl();
a9832134597af (Alex Lorenz              2017-04-06 13:06:34 +0000  4440)           if (IsFirstSame) {
a9832134597af (Alex Lorenz              2017-04-06 13:06:34 +0000  4441)             if (!IsSecondSame)
a9832134597af (Alex Lorenz              2017-04-06 13:06:34 +0000  4442)               return ImplicitConversionSequence::Better;
a9832134597af (Alex Lorenz              2017-04-06 13:06:34 +0000  4443)           } else if (IsSecondSame)
a9832134597af (Alex Lorenz              2017-04-06 13:06:34 +0000  4444)             return ImplicitConversionSequence::Worse;
a9832134597af (Alex Lorenz              2017-04-06 13:06:34 +0000  4445)         }
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4446)         return ToAssignLeft? ImplicitConversionSequence::Worse
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4447)                            : ImplicitConversionSequence::Better;
a9832134597af (Alex Lorenz              2017-04-06 13:06:34 +0000  4448)       }
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4449) 
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4450)       //   -- "conversion of B* to A* is better than conversion of C* to A*,"
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4451)       if (S.Context.hasSameUnqualifiedType(ToType1, ToType2) &&
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4452)           (FromAssignLeft != FromAssignRight))
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4453)         return FromAssignLeft? ImplicitConversionSequence::Better
058d3deab8924 (Douglas Gregor           2011-01-31 18:51:41 +0000  4454)         : ImplicitConversionSequence::Worse;
ef30a5ff98e19 (Douglas Gregor           2008-10-29 14:50:44 +0000  4455)     }
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000  4456)   }
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  4457) 
ac741ffd44eec (Fariborz Jahanian        2009-10-20 20:07:35 +0000  4458)   // Ranking of member-pointer types.
9a587b01118ed (Fariborz Jahanian        2009-10-20 20:04:46 +0000  4459)   if (SCS1.Second == ICK_Pointer_Member && SCS2.Second == ICK_Pointer_Member &&
9a587b01118ed (Fariborz Jahanian        2009-10-20 20:04:46 +0000  4460)       FromType1->isMemberPointerType() && FromType2->isMemberPointerType() &&
9a587b01118ed (Fariborz Jahanian        2009-10-20 20:04:46 +0000  4461)       ToType1->isMemberPointerType() && ToType2->isMemberPointerType()) {
ab9dbc1d124cd (Simon Pilgrim            2020-01-14 14:15:51 +0000  4462)     const auto *FromMemPointer1 = FromType1->castAs<MemberPointerType>();
ab9dbc1d124cd (Simon Pilgrim            2020-01-14 14:15:51 +0000  4463)     const auto *ToMemPointer1 = ToType1->castAs<MemberPointerType>();
ab9dbc1d124cd (Simon Pilgrim            2020-01-14 14:15:51 +0000  4464)     const auto *FromMemPointer2 = FromType2->castAs<MemberPointerType>();
ab9dbc1d124cd (Simon Pilgrim            2020-01-14 14:15:51 +0000  4465)     const auto *ToMemPointer2 = ToType2->castAs<MemberPointerType>();
9a587b01118ed (Fariborz Jahanian        2009-10-20 20:04:46 +0000  4466)     const Type *FromPointeeType1 = FromMemPointer1->getClass();
9a587b01118ed (Fariborz Jahanian        2009-10-20 20:04:46 +0000  4467)     const Type *ToPointeeType1 = ToMemPointer1->getClass();
9a587b01118ed (Fariborz Jahanian        2009-10-20 20:04:46 +0000  4468)     const Type *FromPointeeType2 = FromMemPointer2->getClass();
9a587b01118ed (Fariborz Jahanian        2009-10-20 20:04:46 +0000  4469)     const Type *ToPointeeType2 = ToMemPointer2->getClass();
9a587b01118ed (Fariborz Jahanian        2009-10-20 20:04:46 +0000  4470)     QualType FromPointee1 = QualType(FromPointeeType1, 0).getUnqualifiedType();
9a587b01118ed (Fariborz Jahanian        2009-10-20 20:04:46 +0000  4471)     QualType ToPointee1 = QualType(ToPointeeType1, 0).getUnqualifiedType();
9a587b01118ed (Fariborz Jahanian        2009-10-20 20:04:46 +0000  4472)     QualType FromPointee2 = QualType(FromPointeeType2, 0).getUnqualifiedType();
9a587b01118ed (Fariborz Jahanian        2009-10-20 20:04:46 +0000  4473)     QualType ToPointee2 = QualType(ToPointeeType2, 0).getUnqualifiedType();
ac741ffd44eec (Fariborz Jahanian        2009-10-20 20:07:35 +0000  4474)     // conversion of A::* to B::* is better than conversion of A::* to C::*,
9a587b01118ed (Fariborz Jahanian        2009-10-20 20:04:46 +0000  4475)     if (FromPointee1 == FromPointee2 && ToPointee1 != ToPointee2) {
0f59cb38e7f31 (Richard Smith            2015-12-18 21:45:41 +0000  4476)       if (S.IsDerivedFrom(Loc, ToPointee1, ToPointee2))
9a587b01118ed (Fariborz Jahanian        2009-10-20 20:04:46 +0000  4477)         return ImplicitConversionSequence::Worse;
0f59cb38e7f31 (Richard Smith            2015-12-18 21:45:41 +0000  4478)       else if (S.IsDerivedFrom(Loc, ToPointee2, ToPointee1))
9a587b01118ed (Fariborz Jahanian        2009-10-20 20:04:46 +0000  4479)         return ImplicitConversionSequence::Better;
9a587b01118ed (Fariborz Jahanian        2009-10-20 20:04:46 +0000  4480)     }
9a587b01118ed (Fariborz Jahanian        2009-10-20 20:04:46 +0000  4481)     // conversion of B::* to C::* is better than conversion of A::* to C::*
9a587b01118ed (Fariborz Jahanian        2009-10-20 20:04:46 +0000  4482)     if (ToPointee1 == ToPointee2 && FromPointee1 != FromPointee2) {
0f59cb38e7f31 (Richard Smith            2015-12-18 21:45:41 +0000  4483)       if (S.IsDerivedFrom(Loc, FromPointee1, FromPointee2))
9a587b01118ed (Fariborz Jahanian        2009-10-20 20:04:46 +0000  4484)         return ImplicitConversionSequence::Better;
0f59cb38e7f31 (Richard Smith            2015-12-18 21:45:41 +0000  4485)       else if (S.IsDerivedFrom(Loc, FromPointee2, FromPointee1))
9a587b01118ed (Fariborz Jahanian        2009-10-20 20:04:46 +0000  4486)         return ImplicitConversionSequence::Worse;
9a587b01118ed (Fariborz Jahanian        2009-10-20 20:04:46 +0000  4487)     }
9a587b01118ed (Fariborz Jahanian        2009-10-20 20:04:46 +0000  4488)   }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  4489) 
5ab116553171e (Douglas Gregor           2010-04-17 22:01:05 +0000  4490)   if (SCS1.Second == ICK_Derived_To_Base) {
2fe9883a961df (Douglas Gregor           2008-11-03 19:09:14 +0000  4491)     //   -- conversion of C to B is better than conversion of C to A,
83af86a6bc101 (Douglas Gregor           2010-02-25 19:01:05 +0000  4492)     //   -- binding of an expression of type C to a reference of type
83af86a6bc101 (Douglas Gregor           2010-02-25 19:01:05 +0000  4493)     //      B& is better than binding an expression of type C to a
83af86a6bc101 (Douglas Gregor           2010-02-25 19:01:05 +0000  4494)     //      reference of type A&,
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  4495)     if (S.Context.hasSameUnqualifiedType(FromType1, FromType2) &&
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  4496)         !S.Context.hasSameUnqualifiedType(ToType1, ToType2)) {
0f59cb38e7f31 (Richard Smith            2015-12-18 21:45:41 +0000  4497)       if (S.IsDerivedFrom(Loc, ToType1, ToType2))
2fe9883a961df (Douglas Gregor           2008-11-03 19:09:14 +0000  4498)         return ImplicitConversionSequence::Better;
0f59cb38e7f31 (Richard Smith            2015-12-18 21:45:41 +0000  4499)       else if (S.IsDerivedFrom(Loc, ToType2, ToType1))
2fe9883a961df (Douglas Gregor           2008-11-03 19:09:14 +0000  4500)         return ImplicitConversionSequence::Worse;
2fe9883a961df (Douglas Gregor           2008-11-03 19:09:14 +0000  4501)     }
ef30a5ff98e19 (Douglas Gregor           2008-10-29 14:50:44 +0000  4502) 
2fe9883a961df (Douglas Gregor           2008-11-03 19:09:14 +0000  4503)     //   -- conversion of B to A is better than conversion of C to A.
83af86a6bc101 (Douglas Gregor           2010-02-25 19:01:05 +0000  4504)     //   -- binding of an expression of type B to a reference of type
83af86a6bc101 (Douglas Gregor           2010-02-25 19:01:05 +0000  4505)     //      A& is better than binding an expression of type C to a
83af86a6bc101 (Douglas Gregor           2010-02-25 19:01:05 +0000  4506)     //      reference of type A&,
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  4507)     if (!S.Context.hasSameUnqualifiedType(FromType1, FromType2) &&
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  4508)         S.Context.hasSameUnqualifiedType(ToType1, ToType2)) {
0f59cb38e7f31 (Richard Smith            2015-12-18 21:45:41 +0000  4509)       if (S.IsDerivedFrom(Loc, FromType2, FromType1))
2fe9883a961df (Douglas Gregor           2008-11-03 19:09:14 +0000  4510)         return ImplicitConversionSequence::Better;
0f59cb38e7f31 (Richard Smith            2015-12-18 21:45:41 +0000  4511)       else if (S.IsDerivedFrom(Loc, FromType1, FromType2))
2fe9883a961df (Douglas Gregor           2008-11-03 19:09:14 +0000  4512)         return ImplicitConversionSequence::Worse;
2fe9883a961df (Douglas Gregor           2008-11-03 19:09:14 +0000  4513)     }
2fe9883a961df (Douglas Gregor           2008-11-03 19:09:14 +0000  4514)   }
ef30a5ff98e19 (Douglas Gregor           2008-10-29 14:50:44 +0000  4515) 
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000  4516)   return ImplicitConversionSequence::Indistinguishable;
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000  4517) }
5c407d9a9b8c5 (Douglas Gregor           2008-10-23 00:40:37 +0000  4518) 
9fc8faf9e6197 (Adrian Prantl            2018-05-09 01:00:01 +0000  4519) /// Determine whether the given type is valid, e.g., it is not an invalid
45bb4834e9671 (Douglas Gregor           2013-03-26 23:36:30 +0000  4520) /// C++ class.
45bb4834e9671 (Douglas Gregor           2013-03-26 23:36:30 +0000  4521) static bool isTypeValid(QualType T) {
45bb4834e9671 (Douglas Gregor           2013-03-26 23:36:30 +0000  4522)   if (CXXRecordDecl *Record = T->getAsCXXRecordDecl())
45bb4834e9671 (Douglas Gregor           2013-03-26 23:36:30 +0000  4523)     return !Record->isInvalidDecl();
45bb4834e9671 (Douglas Gregor           2013-03-26 23:36:30 +0000  4524) 
45bb4834e9671 (Douglas Gregor           2013-03-26 23:36:30 +0000  4525)   return true;
45bb4834e9671 (Douglas Gregor           2013-03-26 23:36:30 +0000  4526) }
45bb4834e9671 (Douglas Gregor           2013-03-26 23:36:30 +0000  4527) 
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4528) static QualType withoutUnaligned(ASTContext &Ctx, QualType T) {
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4529)   if (!T.getQualifiers().hasUnaligned())
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4530)     return T;
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4531) 
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4532)   Qualifiers Q;
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4533)   T = Ctx.getUnqualifiedArrayType(T, Q);
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4534)   Q.removeUnaligned();
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4535)   return Ctx.getQualifiedType(T, Q);
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4536) }
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4537) 
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4538) /// CompareReferenceRelationship - Compare the two types T1 and T2 to
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4539) /// determine whether they are reference-compatible,
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4540) /// reference-related, or incompatible, for use in C++ initialization by
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4541) /// reference (C++ [dcl.ref.init]p4). Neither type can be a reference
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4542) /// type, and the first type (T1) is the pointee type of the reference
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4543) /// type being initialized.
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4544) Sema::ReferenceCompareResult
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4545) Sema::CompareReferenceRelationship(SourceLocation Loc,
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4546)                                    QualType OrigT1, QualType OrigT2,
3ced23976aa8a (Richard Smith            2019-12-18 14:01:40 -0800  4547)                                    ReferenceConversions *ConvOut) {
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4548)   assert(!OrigT1->isReferenceType() &&
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4549)     "T1 must be the pointee type of the reference type");
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4550)   assert(!OrigT2->isReferenceType() && "T2 cannot be a reference type");
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4551) 
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4552)   QualType T1 = Context.getCanonicalType(OrigT1);
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4553)   QualType T2 = Context.getCanonicalType(OrigT2);
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4554)   Qualifiers T1Quals, T2Quals;
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4555)   QualType UnqualT1 = Context.getUnqualifiedArrayType(T1, T1Quals);
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4556)   QualType UnqualT2 = Context.getUnqualifiedArrayType(T2, T2Quals);
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4557) 
3ced23976aa8a (Richard Smith            2019-12-18 14:01:40 -0800  4558)   ReferenceConversions ConvTmp;
3ced23976aa8a (Richard Smith            2019-12-18 14:01:40 -0800  4559)   ReferenceConversions &Conv = ConvOut ? *ConvOut : ConvTmp;
3ced23976aa8a (Richard Smith            2019-12-18 14:01:40 -0800  4560)   Conv = ReferenceConversions();
3ced23976aa8a (Richard Smith            2019-12-18 14:01:40 -0800  4561) 
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4562)   // C++2a [dcl.init.ref]p4:
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4563)   //   Given types "cv1 T1" and "cv2 T2," "cv1 T1" is
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4564)   //   reference-related to "cv2 T2" if T1 is similar to T2, or
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4565)   //   T1 is a base class of T2.
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4566)   //   "cv1 T1" is reference-compatible with "cv2 T2" if
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4567)   //   a prvalue of type "pointer to cv2 T2" can be converted to the type
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4568)   //   "pointer to cv1 T1" via a standard conversion sequence.
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4569) 
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4570)   // Check for standard conversions we can apply to pointers: derived-to-base
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4571)   // conversions, ObjC pointer conversions, and function pointer conversions.
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4572)   // (Qualification conversions are checked last.)
1be59c510612d (Richard Smith            2016-10-22 01:32:19 +0000  4573)   QualType ConvertedT2;
8b2d2fe234163 (Douglas Gregor           2010-08-07 11:51:51 +0000  4574)   if (UnqualT1 == UnqualT2) {
8b2d2fe234163 (Douglas Gregor           2010-08-07 11:51:51 +0000  4575)     // Nothing to do.
db0ac5572fcf7 (Richard Smith            2015-12-18 22:40:25 +0000  4576)   } else if (isCompleteType(Loc, OrigT2) &&
45bb4834e9671 (Douglas Gregor           2013-03-26 23:36:30 +0000  4577)              isTypeValid(UnqualT1) && isTypeValid(UnqualT2) &&
0f59cb38e7f31 (Richard Smith            2015-12-18 21:45:41 +0000  4578)              IsDerivedFrom(Loc, UnqualT2, UnqualT1))
3ced23976aa8a (Richard Smith            2019-12-18 14:01:40 -0800  4579)     Conv |= ReferenceConversions::DerivedToBase;
8b2d2fe234163 (Douglas Gregor           2010-08-07 11:51:51 +0000  4580)   else if (UnqualT1->isObjCObjectOrInterfaceType() &&
8b2d2fe234163 (Douglas Gregor           2010-08-07 11:51:51 +0000  4581)            UnqualT2->isObjCObjectOrInterfaceType() &&
8b2d2fe234163 (Douglas Gregor           2010-08-07 11:51:51 +0000  4582)            Context.canBindObjCObjectType(UnqualT1, UnqualT2))
3ced23976aa8a (Richard Smith            2019-12-18 14:01:40 -0800  4583)     Conv |= ReferenceConversions::ObjC;
1be59c510612d (Richard Smith            2016-10-22 01:32:19 +0000  4584)   else if (UnqualT2->isFunctionType() &&
766f15814a012 (Peter Collingbourne      2019-10-19 00:34:54 +0000  4585)            IsFunctionConversion(UnqualT2, UnqualT1, ConvertedT2)) {
3ced23976aa8a (Richard Smith            2019-12-18 14:01:40 -0800  4586)     Conv |= ReferenceConversions::Function;
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4587)     // No need to check qualifiers; function types don't have them.
1be59c510612d (Richard Smith            2016-10-22 01:32:19 +0000  4588)     return Ref_Compatible;
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  4589)   }
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4590)   bool ConvertedReferent = Conv != 0;
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  4591) 
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4592)   // We can have a qualification conversion. Compute whether the types are
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4593)   // similar at the same time.
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4594)   bool PreviousToQualsIncludeConst = true;
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4595)   bool TopLevel = true;
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4596)   do {
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4597)     if (T1 == T2)
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4598)       break;
45d413260e82b (Andrey Bokhanko          2016-05-11 18:38:21 +0000  4599) 
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4600)     // We will need a qualification conversion.
3ced23976aa8a (Richard Smith            2019-12-18 14:01:40 -0800  4601)     Conv |= ReferenceConversions::Qualification;
3ced23976aa8a (Richard Smith            2019-12-18 14:01:40 -0800  4602) 
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4603)     // Track whether we performed a qualification conversion anywhere other
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4604)     // than the top level. This matters for ranking reference bindings in
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4605)     // overload resolution.
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4606)     if (!TopLevel)
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4607)       Conv |= ReferenceConversions::NestedQualification;
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4608) 
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4609)     // MS compiler ignores __unaligned qualifier for references; do the same.
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4610)     T1 = withoutUnaligned(Context, T1);
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4611)     T2 = withoutUnaligned(Context, T2);
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4612) 
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4613)     // If we find a qualifier mismatch, the types are not reference-compatible,
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4614)     // but are still be reference-related if they're similar.
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4615)     bool ObjCLifetimeConversion = false;
6064f426a1830 (Anastasia Stulova        2020-02-06 11:56:21 +0000  4616)     if (!isQualificationConversionStep(T2, T1, /*CStyle=*/false, TopLevel,
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4617)                                        PreviousToQualsIncludeConst,
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4618)                                        ObjCLifetimeConversion))
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4619)       return (ConvertedReferent || Context.hasSimilarType(T1, T2))
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4620)                  ? Ref_Related
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4621)                  : Ref_Incompatible;
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4622) 
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4623)     // FIXME: Should we track this for any level other than the first?
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4624)     if (ObjCLifetimeConversion)
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4625)       Conv |= ReferenceConversions::ObjCLifetime;
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4626) 
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4627)     TopLevel = false;
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4628)   } while (Context.UnwrapSimilarTypes(T1, T2));
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4629) 
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4630)   // At this point, if the types are reference-related, we must either have the
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4631)   // same inner type (ignoring qualifiers), or must have already worked out how
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4632)   // to convert the referent.
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4633)   return (ConvertedReferent || Context.hasSameUnqualifiedType(T1, T2))
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4634)              ? Ref_Compatible
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4635)              : Ref_Incompatible;
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4636) }
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4637) 
9fc8faf9e6197 (Adrian Prantl            2018-05-09 01:00:01 +0000  4638) /// Look for a user-defined conversion to a value reference-compatible
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4639) ///        with DeclType. Return true if something definite is found.
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4640) static bool
836a7e8468a76 (Douglas Gregor           2010-08-11 02:15:33 +0000  4641) FindConversionForRefInit(Sema &S, ImplicitConversionSequence &ICS,
836a7e8468a76 (Douglas Gregor           2010-08-11 02:15:33 +0000  4642)                          QualType DeclType, SourceLocation DeclLoc,
836a7e8468a76 (Douglas Gregor           2010-08-11 02:15:33 +0000  4643)                          Expr *Init, QualType T2, bool AllowRvalues,
836a7e8468a76 (Douglas Gregor           2010-08-11 02:15:33 +0000  4644)                          bool AllowExplicit) {
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4645)   assert(T2->isRecordType() && "Can only find conversions of record types.");
ab9dbc1d124cd (Simon Pilgrim            2020-01-14 14:15:51 +0000  4646)   auto *T2RecordDecl = cast<CXXRecordDecl>(T2->castAs<RecordType>()->getDecl());
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4647) 
67ef14fe486e1 (Richard Smith            2017-09-26 18:37:55 +0000  4648)   OverloadCandidateSet CandidateSet(
67ef14fe486e1 (Richard Smith            2017-09-26 18:37:55 +0000  4649)       DeclLoc, OverloadCandidateSet::CSK_InitByUserDefinedConversion);
b4ef66832dee0 (Benjamin Kramer          2015-02-06 17:25:10 +0000  4650)   const auto &Conversions = T2RecordDecl->getVisibleConversionFunctions();
b4ef66832dee0 (Benjamin Kramer          2015-02-06 17:25:10 +0000  4651)   for (auto I = Conversions.begin(), E = Conversions.end(); I != E; ++I) {
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4652)     NamedDecl *D = *I;
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4653)     CXXRecordDecl *ActingDC = cast<CXXRecordDecl>(D->getDeclContext());
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4654)     if (isa<UsingShadowDecl>(D))
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4655)       D = cast<UsingShadowDecl>(D)->getTargetDecl();
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4656) 
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4657)     FunctionTemplateDecl *ConvTemplate
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4658)       = dyn_cast<FunctionTemplateDecl>(D);
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4659)     CXXConversionDecl *Conv;
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4660)     if (ConvTemplate)
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4661)       Conv = cast<CXXConversionDecl>(ConvTemplate->getTemplatedDecl());
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4662)     else
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4663)       Conv = cast<CXXConversionDecl>(D);
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4664) 
836a7e8468a76 (Douglas Gregor           2010-08-11 02:15:33 +0000  4665)     if (AllowRvalues) {
b0e6c8a3500c1 (Douglas Gregor           2011-10-04 23:59:32 +0000  4666)       // If we are initializing an rvalue reference, don't permit conversion
b0e6c8a3500c1 (Douglas Gregor           2011-10-04 23:59:32 +0000  4667)       // functions that return lvalues.
b0e6c8a3500c1 (Douglas Gregor           2011-10-04 23:59:32 +0000  4668)       if (!ConvTemplate && DeclType->isRValueReferenceType()) {
b0e6c8a3500c1 (Douglas Gregor           2011-10-04 23:59:32 +0000  4669)         const ReferenceType *RefType
b0e6c8a3500c1 (Douglas Gregor           2011-10-04 23:59:32 +0000  4670)           = Conv->getConversionType()->getAs<LValueReferenceType>();
b0e6c8a3500c1 (Douglas Gregor           2011-10-04 23:59:32 +0000  4671)         if (RefType && !RefType->getPointeeType()->isFunctionType())
b0e6c8a3500c1 (Douglas Gregor           2011-10-04 23:59:32 +0000  4672)           continue;
b0e6c8a3500c1 (Douglas Gregor           2011-10-04 23:59:32 +0000  4673)       }
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  4674) 
836a7e8468a76 (Douglas Gregor           2010-08-11 02:15:33 +0000  4675)       if (!ConvTemplate &&
8e543b3d46932 (Chandler Carruth         2010-12-12 08:17:55 +0000  4676)           S.CompareReferenceRelationship(
766f15814a012 (Peter Collingbourne      2019-10-19 00:34:54 +0000  4677)               DeclLoc,
766f15814a012 (Peter Collingbourne      2019-10-19 00:34:54 +0000  4678)               Conv->getConversionType()
766f15814a012 (Peter Collingbourne      2019-10-19 00:34:54 +0000  4679)                   .getNonReferenceType()
766f15814a012 (Peter Collingbourne      2019-10-19 00:34:54 +0000  4680)                   .getUnqualifiedType(),
3ced23976aa8a (Richard Smith            2019-12-18 14:01:40 -0800  4681)               DeclType.getNonReferenceType().getUnqualifiedType()) ==
3ced23976aa8a (Richard Smith            2019-12-18 14:01:40 -0800  4682)               Sema::Ref_Incompatible)
836a7e8468a76 (Douglas Gregor           2010-08-11 02:15:33 +0000  4683)         continue;
836a7e8468a76 (Douglas Gregor           2010-08-11 02:15:33 +0000  4684)     } else {
836a7e8468a76 (Douglas Gregor           2010-08-11 02:15:33 +0000  4685)       // If the conversion function doesn't return a reference type,
836a7e8468a76 (Douglas Gregor           2010-08-11 02:15:33 +0000  4686)       // it can't be considered for this conversion. An rvalue reference
836a7e8468a76 (Douglas Gregor           2010-08-11 02:15:33 +0000  4687)       // is only acceptable if its referencee is a function type.
836a7e8468a76 (Douglas Gregor           2010-08-11 02:15:33 +0000  4688) 
836a7e8468a76 (Douglas Gregor           2010-08-11 02:15:33 +0000  4689)       const ReferenceType *RefType =
836a7e8468a76 (Douglas Gregor           2010-08-11 02:15:33 +0000  4690)         Conv->getConversionType()->getAs<ReferenceType>();
836a7e8468a76 (Douglas Gregor           2010-08-11 02:15:33 +0000  4691)       if (!RefType ||
836a7e8468a76 (Douglas Gregor           2010-08-11 02:15:33 +0000  4692)           (!RefType->isLValueReferenceType() &&
836a7e8468a76 (Douglas Gregor           2010-08-11 02:15:33 +0000  4693)            !RefType->getPointeeType()->isFunctionType()))
836a7e8468a76 (Douglas Gregor           2010-08-11 02:15:33 +0000  4694)         continue;
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4695)     }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  4696) 
836a7e8468a76 (Douglas Gregor           2010-08-11 02:15:33 +0000  4697)     if (ConvTemplate)
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000  4698)       S.AddTemplateConversionCandidate(
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000  4699)           ConvTemplate, I.getPair(), ActingDC, Init, DeclType, CandidateSet,
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000  4700)           /*AllowObjCConversionOnExplicit=*/false, AllowExplicit);
836a7e8468a76 (Douglas Gregor           2010-08-11 02:15:33 +0000  4701)     else
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000  4702)       S.AddConversionCandidate(
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000  4703)           Conv, I.getPair(), ActingDC, Init, DeclType, CandidateSet,
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000  4704)           /*AllowObjCConversionOnExplicit=*/false, AllowExplicit);
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4705)   }
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4706) 
635ed24e1dad8 (Abramo Bagnara           2011-10-05 07:56:41 +0000  4707)   bool HadMultipleCandidates = (CandidateSet.size() > 1);
635ed24e1dad8 (Abramo Bagnara           2011-10-05 07:56:41 +0000  4708) 
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4709)   OverloadCandidateSet::iterator Best;
67ef14fe486e1 (Richard Smith            2017-09-26 18:37:55 +0000  4710)   switch (CandidateSet.BestViableFunction(S, DeclLoc, Best)) {
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4711)   case OR_Success:
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4712)     // C++ [over.ics.ref]p1:
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4713)     //
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4714)     //   [...] If the parameter binds directly to the result of
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4715)     //   applying a conversion function to the argument
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4716)     //   expression, the implicit conversion sequence is a
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4717)     //   user-defined conversion sequence (13.3.3.1.2), with the
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4718)     //   second standard conversion sequence either an identity
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4719)     //   conversion or, if the conversion function returns an
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4720)     //   entity of a type that is a derived class of the parameter
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4721)     //   type, a derived-to-base Conversion.
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4722)     if (!Best->FinalConversion.DirectBinding)
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4723)       return false;
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4724) 
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4725)     ICS.setUserDefined();
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4726)     ICS.UserDefined.Before = Best->Conversions[0].Standard;
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4727)     ICS.UserDefined.After = Best->FinalConversion;
635ed24e1dad8 (Abramo Bagnara           2011-10-05 07:56:41 +0000  4728)     ICS.UserDefined.HadMultipleCandidates = HadMultipleCandidates;
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4729)     ICS.UserDefined.ConversionFunction = Best->Function;
30909031a7f76 (John McCall              2011-09-21 08:36:56 +0000  4730)     ICS.UserDefined.FoundConversionFunction = Best->FoundDecl;
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4731)     ICS.UserDefined.EllipsisConversion = false;
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4732)     assert(ICS.UserDefined.After.ReferenceBinding &&
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4733)            ICS.UserDefined.After.DirectBinding &&
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4734)            "Expected a direct reference binding!");
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4735)     return true;
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4736) 
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4737)   case OR_Ambiguous:
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4738)     ICS.setAmbiguous();
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4739)     for (OverloadCandidateSet::iterator Cand = CandidateSet.begin();
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4740)          Cand != CandidateSet.end(); ++Cand)
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700  4741)       if (Cand->Best)
c2bebe9acab26 (Richard Smith            2016-05-11 20:37:46 +0000  4742)         ICS.Ambiguous.addConversion(Cand->FoundDecl, Cand->Function);
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4743)     return true;
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4744) 
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4745)   case OR_No_Viable_Function:
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4746)   case OR_Deleted:
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4747)     // There was no suitable conversion, or we found a deleted
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4748)     // conversion; continue with other checks.
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4749)     return false;
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4750)   }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  4751) 
8a40f700e62b8 (David Blaikie            2012-01-17 06:56:22 +0000  4752)   llvm_unreachable("Invalid OverloadResult!");
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4753) }
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4754) 
9fc8faf9e6197 (Adrian Prantl            2018-05-09 01:00:01 +0000  4755) /// Compute an implicit conversion sequence for reference
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4756) /// initialization.
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4757) static ImplicitConversionSequence
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  4758) TryReferenceInit(Sema &S, Expr *Init, QualType DeclType,
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4759)                  SourceLocation DeclLoc,
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4760)                  bool SuppressUserConversions,
adc7a704d2a38 (Douglas Gregor           2010-04-16 17:45:54 +0000  4761)                  bool AllowExplicit) {
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4762)   assert(DeclType->isReferenceType() && "Reference init needs a reference");
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4763) 
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4764)   // Most paths end in a failed conversion.
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4765)   ImplicitConversionSequence ICS;
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4766)   ICS.setBad(BadConversionSequence::no_conversion, Init, DeclType);
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4767) 
ed3b68e0dc3c0 (Simon Pilgrim            2019-10-02 14:02:27 +0000  4768)   QualType T1 = DeclType->castAs<ReferenceType>()->getPointeeType();
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4769)   QualType T2 = Init->getType();
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4770) 
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4771)   // If the initializer is the address of an overloaded function, try
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4772)   // to resolve the overloaded function. If all goes well, T2 is the
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4773)   // type of the resulting function.
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4774)   if (S.Context.getCanonicalType(T2) == S.Context.OverloadTy) {
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4775)     DeclAccessPair Found;
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4776)     if (FunctionDecl *Fn = S.ResolveAddressOfOverloadedFunction(Init, DeclType,
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4777)                                                                 false, Found))
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4778)       T2 = Fn->getType();
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4779)   }
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4780) 
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4781)   // Compute some basic properties of the types and the initializer.
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4782)   bool isRValRef = DeclType->isRValueReferenceType();
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4783)   Expr::Classification InitCategory = Init->Classify(S.Context);
3ced23976aa8a (Richard Smith            2019-12-18 14:01:40 -0800  4784) 
3ced23976aa8a (Richard Smith            2019-12-18 14:01:40 -0800  4785)   Sema::ReferenceConversions RefConv;
3ced23976aa8a (Richard Smith            2019-12-18 14:01:40 -0800  4786)   Sema::ReferenceCompareResult RefRelationship =
3ced23976aa8a (Richard Smith            2019-12-18 14:01:40 -0800  4787)       S.CompareReferenceRelationship(DeclLoc, T1, T2, &RefConv);
3ced23976aa8a (Richard Smith            2019-12-18 14:01:40 -0800  4788) 
3ced23976aa8a (Richard Smith            2019-12-18 14:01:40 -0800  4789)   auto SetAsReferenceBinding = [&](bool BindsDirectly) {
3ced23976aa8a (Richard Smith            2019-12-18 14:01:40 -0800  4790)     ICS.setStandard();
3ced23976aa8a (Richard Smith            2019-12-18 14:01:40 -0800  4791)     ICS.Standard.First = ICK_Identity;
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4792)     // FIXME: A reference binding can be a function conversion too. We should
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4793)     // consider that when ordering reference-to-function bindings.
3ced23976aa8a (Richard Smith            2019-12-18 14:01:40 -0800  4794)     ICS.Standard.Second = (RefConv & Sema::ReferenceConversions::DerivedToBase)
3ced23976aa8a (Richard Smith            2019-12-18 14:01:40 -0800  4795)                               ? ICK_Derived_To_Base
3ced23976aa8a (Richard Smith            2019-12-18 14:01:40 -0800  4796)                               : (RefConv & Sema::ReferenceConversions::ObjC)
3ced23976aa8a (Richard Smith            2019-12-18 14:01:40 -0800  4797)                                     ? ICK_Compatible_Conversion
3ced23976aa8a (Richard Smith            2019-12-18 14:01:40 -0800  4798)                                     : ICK_Identity;
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4799)     // FIXME: As a speculative fix to a defect introduced by CWG2352, we rank
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4800)     // a reference binding that performs a non-top-level qualification
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4801)     // conversion as a qualification conversion, not as an identity conversion.
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4802)     ICS.Standard.Third = (RefConv &
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4803)                               Sema::ReferenceConversions::NestedQualification)
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4804)                              ? ICK_Qualification
f041e9ad706ae (Richard Smith            2020-01-09 15:31:56 -0800  4805)                              : ICK_Identity;
065fc1eafe7c6 (Richard Smith            2020-07-07 18:25:57 -0700  4806)     ICS.Standard.setFromType(T2);
3ced23976aa8a (Richard Smith            2019-12-18 14:01:40 -0800  4807)     ICS.Standard.setToType(0, T2);
3ced23976aa8a (Richard Smith            2019-12-18 14:01:40 -0800  4808)     ICS.Standard.setToType(1, T1);
3ced23976aa8a (Richard Smith            2019-12-18 14:01:40 -0800  4809)     ICS.Standard.setToType(2, T1);
3ced23976aa8a (Richard Smith            2019-12-18 14:01:40 -0800  4810)     ICS.Standard.ReferenceBinding = true;
3ced23976aa8a (Richard Smith            2019-12-18 14:01:40 -0800  4811)     ICS.Standard.DirectBinding = BindsDirectly;
3ced23976aa8a (Richard Smith            2019-12-18 14:01:40 -0800  4812)     ICS.Standard.IsLvalueReference = !isRValRef;
3ced23976aa8a (Richard Smith            2019-12-18 14:01:40 -0800  4813)     ICS.Standard.BindsToFunctionLvalue = T2->isFunctionType();
3ced23976aa8a (Richard Smith            2019-12-18 14:01:40 -0800  4814)     ICS.Standard.BindsToRvalue = InitCategory.isRValue();
3ced23976aa8a (Richard Smith            2019-12-18 14:01:40 -0800  4815)     ICS.Standard.BindsImplicitObjectArgumentWithoutRefQualifier = false;
3ced23976aa8a (Richard Smith            2019-12-18 14:01:40 -0800  4816)     ICS.Standard.ObjCLifetimeConversionBinding =
3ced23976aa8a (Richard Smith            2019-12-18 14:01:40 -0800  4817)         (RefConv & Sema::ReferenceConversions::ObjCLifetime) != 0;
3ced23976aa8a (Richard Smith            2019-12-18 14:01:40 -0800  4818)     ICS.Standard.CopyConstructor = nullptr;
3ced23976aa8a (Richard Smith            2019-12-18 14:01:40 -0800  4819)     ICS.Standard.DeprecatedStringLiteralToCharPtr = false;
3ced23976aa8a (Richard Smith            2019-12-18 14:01:40 -0800  4820)   };
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4821) 
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4822)   // C++0x [dcl.init.ref]p5:
870f3743e4883 (Douglas Gregor           2010-04-18 09:22:00 +0000  4823)   //   A reference to type "cv1 T1" is initialized by an expression
870f3743e4883 (Douglas Gregor           2010-04-18 09:22:00 +0000  4824)   //   of type "cv2 T2" as follows:
870f3743e4883 (Douglas Gregor           2010-04-18 09:22:00 +0000  4825) 
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4826)   //     -- If reference is an lvalue reference and the initializer expression
f143cd5051581 (Douglas Gregor           2011-01-24 16:14:37 +0000  4827)   if (!isRValRef) {
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4828)     //     -- is an lvalue (but is not a bit-field), and "cv1 T1" is
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4829)     //        reference-compatible with "cv2 T2," or
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4830)     //
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4831)     // Per C++ [over.ics.ref]p4, we don't check the bit-field property here.
ce76629905aa1 (Richard Smith            2016-10-21 23:01:55 +0000  4832)     if (InitCategory.isLValue() && RefRelationship == Sema::Ref_Compatible) {
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4833)       // C++ [over.ics.ref]p1:
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4834)       //   When a parameter of reference type binds directly (8.5.3)
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4835)       //   to an argument expression, the implicit conversion sequence
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4836)       //   is the identity conversion, unless the argument expression
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4837)       //   has a type that is a derived class of the parameter type,
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4838)       //   in which case the implicit conversion sequence is a
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4839)       //   derived-to-base Conversion (13.3.3.1).
3ced23976aa8a (Richard Smith            2019-12-18 14:01:40 -0800  4840)       SetAsReferenceBinding(/*BindsDirectly=*/true);
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4841) 
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4842)       // Nothing more to do: the inaccessibility/ambiguity check for
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4843)       // derived-to-base conversions is suppressed when we're
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4844)       // computing the implicit conversion sequence (C++
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4845)       // [over.best.ics]p2).
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4846)       return ICS;
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4847)     }
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4848) 
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4849)     //       -- has a class type (i.e., T2 is a class type), where T1 is
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4850)     //          not reference-related to T2, and can be implicitly
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4851)     //          converted to an lvalue of type "cv3 T3," where "cv1 T1"
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4852)     //          is reference-compatible with "cv3 T3" 92) (this
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4853)     //          conversion is selected by enumerating the applicable
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4854)     //          conversion functions (13.3.1.6) and choosing the best
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4855)     //          one through overload resolution (13.3)),
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4856)     if (!SuppressUserConversions && T2->isRecordType() &&
db0ac5572fcf7 (Richard Smith            2015-12-18 22:40:25 +0000  4857)         S.isCompleteType(DeclLoc, T2) &&
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4858)         RefRelationship == Sema::Ref_Incompatible) {
836a7e8468a76 (Douglas Gregor           2010-08-11 02:15:33 +0000  4859)       if (FindConversionForRefInit(S, ICS, DeclType, DeclLoc,
836a7e8468a76 (Douglas Gregor           2010-08-11 02:15:33 +0000  4860)                                    Init, T2, /*AllowRvalues=*/false,
836a7e8468a76 (Douglas Gregor           2010-08-11 02:15:33 +0000  4861)                                    AllowExplicit))
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4862)         return ICS;
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4863)     }
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4864)   }
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4865) 
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4866)   //     -- Otherwise, the reference shall be an lvalue reference to a
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4867)   //        non-volatile const type (i.e., cv1 shall be const), or the reference
f143cd5051581 (Douglas Gregor           2011-01-24 16:14:37 +0000  4868)   //        shall be an rvalue reference.
6f84779674a97 (Aaron Puchert            2020-11-15 16:11:23 +0100  4869)   if (!isRValRef && (!T1.isConstQualified() || T1.isVolatileQualified())) {
6f84779674a97 (Aaron Puchert            2020-11-15 16:11:23 +0100  4870)     if (InitCategory.isRValue() && RefRelationship != Sema::Ref_Incompatible)
6f84779674a97 (Aaron Puchert            2020-11-15 16:11:23 +0100  4871)       ICS.setBad(BadConversionSequence::lvalue_ref_to_rvalue, Init, DeclType);
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4872)     return ICS;
6f84779674a97 (Aaron Puchert            2020-11-15 16:11:23 +0100  4873)   }
d92badfd9c998 (Sebastian Redl           2010-06-30 18:13:39 +0000  4874) 
f143cd5051581 (Douglas Gregor           2011-01-24 16:14:37 +0000  4875)   //       -- If the initializer expression
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4876)   //
f143cd5051581 (Douglas Gregor           2011-01-24 16:14:37 +0000  4877)   //            -- is an xvalue, class prvalue, array prvalue or function
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  4878)   //               lvalue and "cv1 T1" is reference-compatible with "cv2 T2", or
ce76629905aa1 (Richard Smith            2016-10-21 23:01:55 +0000  4879)   if (RefRelationship == Sema::Ref_Compatible &&
f143cd5051581 (Douglas Gregor           2011-01-24 16:14:37 +0000  4880)       (InitCategory.isXValue() ||
3ced23976aa8a (Richard Smith            2019-12-18 14:01:40 -0800  4881)        (InitCategory.isPRValue() &&
3ced23976aa8a (Richard Smith            2019-12-18 14:01:40 -0800  4882)           (T2->isRecordType() || T2->isArrayType())) ||
ce76629905aa1 (Richard Smith            2016-10-21 23:01:55 +0000  4883)        (InitCategory.isLValue() && T2->isFunctionType()))) {
3ced23976aa8a (Richard Smith            2019-12-18 14:01:40 -0800  4884)     // In C++11, this is always a direct binding. In C++98/03, it's a direct
f143cd5051581 (Douglas Gregor           2011-01-24 16:14:37 +0000  4885)     // binding unless we're binding to a class prvalue.
f143cd5051581 (Douglas Gregor           2011-01-24 16:14:37 +0000  4886)     // Note: Although xvalues wouldn't normally show up in C++98/03 code, we
f143cd5051581 (Douglas Gregor           2011-01-24 16:14:37 +0000  4887)     // allow the use of rvalue references in C++98/03 for the benefit of
f143cd5051581 (Douglas Gregor           2011-01-24 16:14:37 +0000  4888)     // standard library implementors; therefore, we need the xvalue check here.
3ced23976aa8a (Richard Smith            2019-12-18 14:01:40 -0800  4889)     SetAsReferenceBinding(/*BindsDirectly=*/S.getLangOpts().CPlusPlus11 ||
3ced23976aa8a (Richard Smith            2019-12-18 14:01:40 -0800  4890)                           !(InitCategory.isPRValue() || T2->isRecordType()));
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  4891)     return ICS;
f143cd5051581 (Douglas Gregor           2011-01-24 16:14:37 +0000  4892)   }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  4893) 
f143cd5051581 (Douglas Gregor           2011-01-24 16:14:37 +0000  4894)   //            -- has a class type (i.e., T2 is a class type), where T1 is not
f143cd5051581 (Douglas Gregor           2011-01-24 16:14:37 +0000  4895)   //               reference-related to T2, and can be implicitly converted to
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  4896)   //               an xvalue, class prvalue, or function lvalue of type
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  4897)   //               "cv3 T3", where "cv1 T1" is reference-compatible with
f143cd5051581 (Douglas Gregor           2011-01-24 16:14:37 +0000  4898)   //               "cv3 T3",
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4899)   //
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  4900)   //          then the reference is bound to the value of the initializer
f143cd5051581 (Douglas Gregor           2011-01-24 16:14:37 +0000  4901)   //          expression in the first case and to the result of the conversion
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  4902)   //          in the second case (or, in either case, to an appropriate base
f143cd5051581 (Douglas Gregor           2011-01-24 16:14:37 +0000  4903)   //          class subobject).
f143cd5051581 (Douglas Gregor           2011-01-24 16:14:37 +0000  4904)   if (!SuppressUserConversions && RefRelationship == Sema::Ref_Incompatible &&
db0ac5572fcf7 (Richard Smith            2015-12-18 22:40:25 +0000  4905)       T2->isRecordType() && S.isCompleteType(DeclLoc, T2) &&
f143cd5051581 (Douglas Gregor           2011-01-24 16:14:37 +0000  4906)       FindConversionForRefInit(S, ICS, DeclType, DeclLoc,
f143cd5051581 (Douglas Gregor           2011-01-24 16:14:37 +0000  4907)                                Init, T2, /*AllowRvalues=*/true,
f143cd5051581 (Douglas Gregor           2011-01-24 16:14:37 +0000  4908)                                AllowExplicit)) {
f143cd5051581 (Douglas Gregor           2011-01-24 16:14:37 +0000  4909)     // In the second case, if the reference is an rvalue reference
f143cd5051581 (Douglas Gregor           2011-01-24 16:14:37 +0000  4910)     // and the second standard conversion sequence of the
f143cd5051581 (Douglas Gregor           2011-01-24 16:14:37 +0000  4911)     // user-defined conversion sequence includes an lvalue-to-rvalue
f143cd5051581 (Douglas Gregor           2011-01-24 16:14:37 +0000  4912)     // conversion, the program is ill-formed.
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  4913)     if (ICS.isUserDefined() && isRValRef &&
f143cd5051581 (Douglas Gregor           2011-01-24 16:14:37 +0000  4914)         ICS.UserDefined.After.First == ICK_Lvalue_To_Rvalue)
f143cd5051581 (Douglas Gregor           2011-01-24 16:14:37 +0000  4915)       ICS.setBad(BadConversionSequence::no_conversion, Init, DeclType);
cba72b1f620fd (Douglas Gregor           2011-01-21 05:18:22 +0000  4916) 
f143cd5051581 (Douglas Gregor           2011-01-24 16:14:37 +0000  4917)     return ICS;
be468d9a2b39a (Rafael Espindola         2011-01-22 15:32:35 +0000  4918)   }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  4919) 
19172c4f70fac (Richard Smith            2014-07-14 02:28:44 +0000  4920)   // A temporary of function type cannot be created; don't even try.
19172c4f70fac (Richard Smith            2014-07-14 02:28:44 +0000  4921)   if (T1->isFunctionType())
19172c4f70fac (Richard Smith            2014-07-14 02:28:44 +0000  4922)     return ICS;
19172c4f70fac (Richard Smith            2014-07-14 02:28:44 +0000  4923) 
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4924)   //       -- Otherwise, a temporary of type "cv1 T1" is created and
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4925)   //          initialized from the initializer expression using the
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4926)   //          rules for a non-reference copy initialization (8.5). The
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4927)   //          reference is then bound to the temporary. If T1 is
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4928)   //          reference-related to T2, cv1 must be the same
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4929)   //          cv-qualification as, or greater cv-qualification than,
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4930)   //          cv2; otherwise, the program is ill-formed.
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4931)   if (RefRelationship == Sema::Ref_Related) {
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4932)     // If cv1 == cv2 or cv1 is a greater cv-qualified than cv2, then
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4933)     // we would be reference-compatible or reference-compatible with
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4934)     // added qualification. But that wasn't the case, so the reference
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4935)     // initialization fails.
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  4936)     //
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  4937)     // Note that we only want to check address spaces and cvr-qualifiers here.
45d413260e82b (Andrey Bokhanko          2016-05-11 18:38:21 +0000  4938)     // ObjC GC, lifetime and unaligned qualifiers aren't important.
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  4939)     Qualifiers T1Quals = T1.getQualifiers();
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  4940)     Qualifiers T2Quals = T2.getQualifiers();
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  4941)     T1Quals.removeObjCGCAttr();
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  4942)     T1Quals.removeObjCLifetime();
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  4943)     T2Quals.removeObjCGCAttr();
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  4944)     T2Quals.removeObjCLifetime();
45d413260e82b (Andrey Bokhanko          2016-05-11 18:38:21 +0000  4945)     // MS compiler ignores __unaligned qualifier for references; do the same.
45d413260e82b (Andrey Bokhanko          2016-05-11 18:38:21 +0000  4946)     T1Quals.removeUnaligned();
45d413260e82b (Andrey Bokhanko          2016-05-11 18:38:21 +0000  4947)     T2Quals.removeUnaligned();
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  4948)     if (!T1Quals.compatiblyIncludes(T2Quals))
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  4949)       return ICS;
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4950)   }
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4951) 
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4952)   // If at least one of the types is a class type, the types are not
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4953)   // related, and we aren't allowed any user conversions, the
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4954)   // reference binding fails. This case is important for breaking
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4955)   // recursion, since TryImplicitConversion below will attempt to
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4956)   // create a temporary through the use of a copy constructor.
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4957)   if (SuppressUserConversions && RefRelationship == Sema::Ref_Incompatible &&
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4958)       (T1->isRecordType() || T2->isRecordType()))
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4959)     return ICS;
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4960) 
cba72b1f620fd (Douglas Gregor           2011-01-21 05:18:22 +0000  4961)   // If T1 is reference-related to T2 and the reference is an rvalue
cba72b1f620fd (Douglas Gregor           2011-01-21 05:18:22 +0000  4962)   // reference, the initializer expression shall not be an lvalue.
6f84779674a97 (Aaron Puchert            2020-11-15 16:11:23 +0100  4963)   if (RefRelationship >= Sema::Ref_Related && isRValRef &&
6f84779674a97 (Aaron Puchert            2020-11-15 16:11:23 +0100  4964)       Init->Classify(S.Context).isLValue()) {
6f84779674a97 (Aaron Puchert            2020-11-15 16:11:23 +0100  4965)     ICS.setBad(BadConversionSequence::rvalue_ref_to_lvalue, Init, DeclType);
cba72b1f620fd (Douglas Gregor           2011-01-21 05:18:22 +0000  4966)     return ICS;
6f84779674a97 (Aaron Puchert            2020-11-15 16:11:23 +0100  4967)   }
cba72b1f620fd (Douglas Gregor           2011-01-21 05:18:22 +0000  4968) 
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4969)   // C++ [over.ics.ref]p2:
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4970)   //   When a parameter of reference type is not bound directly to
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4971)   //   an argument expression, the conversion sequence is the one
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4972)   //   required to convert the argument expression to the
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4973)   //   underlying type of the reference according to
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4974)   //   13.3.3.1. Conceptually, this conversion sequence corresponds
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4975)   //   to copy-initializing a temporary of the underlying type with
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4976)   //   the argument expression. Any difference in top-level
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4977)   //   cv-qualification is subsumed by the initialization itself
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4978)   //   and does not constitute a conversion.
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  4979)   ICS = TryImplicitConversion(S, Init, T1, SuppressUserConversions,
d28763cad06e6 (Richard Smith            2020-01-29 12:07:14 -0800  4980)                               AllowedExplicit::None,
582813596a100 (Douglas Gregor           2011-01-27 00:58:17 +0000  4981)                               /*InOverloadResolution=*/false,
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  4982)                               /*CStyle=*/false,
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  4983)                               /*AllowObjCWritebackConversion=*/false,
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  4984)                               /*AllowObjCConversionOnExplicit=*/false);
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4985) 
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4986)   // Of course, that's still a reference binding.
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4987)   if (ICS.isStandard()) {
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4988)     ICS.Standard.ReferenceBinding = true;
e696ebbd70b3d (Douglas Gregor           2011-01-26 14:52:12 +0000  4989)     ICS.Standard.IsLvalueReference = !isRValRef;
19172c4f70fac (Richard Smith            2014-07-14 02:28:44 +0000  4990)     ICS.Standard.BindsToFunctionLvalue = false;
e696ebbd70b3d (Douglas Gregor           2011-01-26 14:52:12 +0000  4991)     ICS.Standard.BindsToRvalue = true;
e1a47c176656a (Douglas Gregor           2011-01-26 19:41:18 +0000  4992)     ICS.Standard.BindsImplicitObjectArgumentWithoutRefQualifier = false;
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  4993)     ICS.Standard.ObjCLifetimeConversionBinding = false;
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  4994)   } else if (ICS.isUserDefined()) {
19172c4f70fac (Richard Smith            2014-07-14 02:28:44 +0000  4995)     const ReferenceType *LValRefType =
19172c4f70fac (Richard Smith            2014-07-14 02:28:44 +0000  4996)         ICS.UserDefined.ConversionFunction->getReturnType()
19172c4f70fac (Richard Smith            2014-07-14 02:28:44 +0000  4997)             ->getAs<LValueReferenceType>();
19172c4f70fac (Richard Smith            2014-07-14 02:28:44 +0000  4998) 
19172c4f70fac (Richard Smith            2014-07-14 02:28:44 +0000  4999)     // C++ [over.ics.ref]p3:
19172c4f70fac (Richard Smith            2014-07-14 02:28:44 +0000  5000)     //   Except for an implicit object parameter, for which see 13.3.1, a
19172c4f70fac (Richard Smith            2014-07-14 02:28:44 +0000  5001)     //   standard conversion sequence cannot be formed if it requires [...]
19172c4f70fac (Richard Smith            2014-07-14 02:28:44 +0000  5002)     //   binding an rvalue reference to an lvalue other than a function
19172c4f70fac (Richard Smith            2014-07-14 02:28:44 +0000  5003)     //   lvalue.
19172c4f70fac (Richard Smith            2014-07-14 02:28:44 +0000  5004)     // Note that the function case is not possible here.
6f84779674a97 (Aaron Puchert            2020-11-15 16:11:23 +0100  5005)     if (isRValRef && LValRefType) {
6f84779674a97 (Aaron Puchert            2020-11-15 16:11:23 +0100  5006)       ICS.setBad(BadConversionSequence::no_conversion, Init, DeclType);
19172c4f70fac (Richard Smith            2014-07-14 02:28:44 +0000  5007)       return ICS;
b0e6c8a3500c1 (Douglas Gregor           2011-10-04 23:59:32 +0000  5008)     }
19172c4f70fac (Richard Smith            2014-07-14 02:28:44 +0000  5009) 
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  5010)     ICS.UserDefined.After.ReferenceBinding = true;
3ec7910e10b6f (Douglas Gregor           2011-08-15 13:59:46 +0000  5011)     ICS.UserDefined.After.IsLvalueReference = !isRValRef;
19172c4f70fac (Richard Smith            2014-07-14 02:28:44 +0000  5012)     ICS.UserDefined.After.BindsToFunctionLvalue = false;
19172c4f70fac (Richard Smith            2014-07-14 02:28:44 +0000  5013)     ICS.UserDefined.After.BindsToRvalue = !LValRefType;
3ec7910e10b6f (Douglas Gregor           2011-08-15 13:59:46 +0000  5014)     ICS.UserDefined.After.BindsImplicitObjectArgumentWithoutRefQualifier = false;
3ec7910e10b6f (Douglas Gregor           2011-08-15 13:59:46 +0000  5015)     ICS.UserDefined.After.ObjCLifetimeConversionBinding = false;
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  5016)   }
cba72b1f620fd (Douglas Gregor           2011-01-21 05:18:22 +0000  5017) 
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  5018)   return ICS;
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  5019) }
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  5020) 
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5021) static ImplicitConversionSequence
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5022) TryCopyInitialization(Sema &S, Expr *From, QualType ToType,
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5023)                       bool SuppressUserConversions,
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5024)                       bool InOverloadResolution,
6073dcab38e4e (Douglas Gregor           2012-02-24 23:56:31 +0000  5025)                       bool AllowObjCWritebackConversion,
6073dcab38e4e (Douglas Gregor           2012-02-24 23:56:31 +0000  5026)                       bool AllowExplicit = false);
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5027) 
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5028) /// TryListConversion - Try to copy-initialize a value of type ToType from the
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5029) /// initializer list From.
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5030) static ImplicitConversionSequence
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5031) TryListConversion(Sema &S, InitListExpr *From, QualType ToType,
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5032)                   bool SuppressUserConversions,
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5033)                   bool InOverloadResolution,
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5034)                   bool AllowObjCWritebackConversion) {
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5035)   // C++11 [over.ics.list]p1:
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5036)   //   When an argument is an initializer list, it is not an expression and
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5037)   //   special rules apply for converting it to a parameter type.
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5038) 
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5039)   ImplicitConversionSequence Result;
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5040)   Result.setBad(BadConversionSequence::no_conversion, From, ToType);
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5041) 
09edce0400716 (Sebastian Redl           2012-01-23 22:09:39 +0000  5042)   // We need a complete type for what follows. Incomplete types can never be
10f0fc04a8f50 (Sebastian Redl           2012-01-17 22:49:48 +0000  5043)   // initialized from init lists.
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  5044)   if (!S.isCompleteType(From->getBeginLoc(), ToType))
10f0fc04a8f50 (Sebastian Redl           2012-01-17 22:49:48 +0000  5045)     return Result;
10f0fc04a8f50 (Sebastian Redl           2012-01-17 22:49:48 +0000  5046) 
19d08672844ee (Larisse Voufo            2015-01-27 18:47:05 +0000  5047)   // Per DR1467:
19d08672844ee (Larisse Voufo            2015-01-27 18:47:05 +0000  5048)   //   If the parameter type is a class X and the initializer list has a single
19d08672844ee (Larisse Voufo            2015-01-27 18:47:05 +0000  5049)   //   element of type cv U, where U is X or a class derived from X, the
19d08672844ee (Larisse Voufo            2015-01-27 18:47:05 +0000  5050)   //   implicit conversion sequence is the one required to convert the element
19d08672844ee (Larisse Voufo            2015-01-27 18:47:05 +0000  5051)   //   to the parameter type.
19d08672844ee (Larisse Voufo            2015-01-27 18:47:05 +0000  5052)   //
19d08672844ee (Larisse Voufo            2015-01-27 18:47:05 +0000  5053)   //   Otherwise, if the parameter type is a character array [... ]
19d08672844ee (Larisse Voufo            2015-01-27 18:47:05 +0000  5054)   //   and the initializer list has a single element that is an
19d08672844ee (Larisse Voufo            2015-01-27 18:47:05 +0000  5055)   //   appropriately-typed string literal (8.5.2 [dcl.init.string]), the
19d08672844ee (Larisse Voufo            2015-01-27 18:47:05 +0000  5056)   //   implicit conversion sequence is the identity conversion.
19d08672844ee (Larisse Voufo            2015-01-27 18:47:05 +0000  5057)   if (From->getNumInits() == 1) {
19d08672844ee (Larisse Voufo            2015-01-27 18:47:05 +0000  5058)     if (ToType->isRecordType()) {
19d08672844ee (Larisse Voufo            2015-01-27 18:47:05 +0000  5059)       QualType InitType = From->getInit(0)->getType();
19d08672844ee (Larisse Voufo            2015-01-27 18:47:05 +0000  5060)       if (S.Context.hasSameUnqualifiedType(InitType, ToType) ||
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  5061)           S.IsDerivedFrom(From->getBeginLoc(), InitType, ToType))
19d08672844ee (Larisse Voufo            2015-01-27 18:47:05 +0000  5062)         return TryCopyInitialization(S, From->getInit(0), ToType,
19d08672844ee (Larisse Voufo            2015-01-27 18:47:05 +0000  5063)                                      SuppressUserConversions,
19d08672844ee (Larisse Voufo            2015-01-27 18:47:05 +0000  5064)                                      InOverloadResolution,
19d08672844ee (Larisse Voufo            2015-01-27 18:47:05 +0000  5065)                                      AllowObjCWritebackConversion);
19d08672844ee (Larisse Voufo            2015-01-27 18:47:05 +0000  5066)     }
0ce6d6b46eb70 (Mark de Wever            2020-10-03 14:31:46 +0200  5067) 
0ce6d6b46eb70 (Mark de Wever            2020-10-03 14:31:46 +0200  5068)     if (const auto *AT = S.Context.getAsArrayType(ToType)) {
0ce6d6b46eb70 (Mark de Wever            2020-10-03 14:31:46 +0200  5069)       if (S.IsStringInit(From->getInit(0), AT)) {
0ce6d6b46eb70 (Mark de Wever            2020-10-03 14:31:46 +0200  5070)         InitializedEntity Entity =
0ce6d6b46eb70 (Mark de Wever            2020-10-03 14:31:46 +0200  5071)           InitializedEntity::InitializeParameter(S.Context, ToType,
0ce6d6b46eb70 (Mark de Wever            2020-10-03 14:31:46 +0200  5072)                                                  /*Consumed=*/false);
0ce6d6b46eb70 (Mark de Wever            2020-10-03 14:31:46 +0200  5073)         if (S.CanPerformCopyInitialization(Entity, From)) {
0ce6d6b46eb70 (Mark de Wever            2020-10-03 14:31:46 +0200  5074)           Result.setStandard();
0ce6d6b46eb70 (Mark de Wever            2020-10-03 14:31:46 +0200  5075)           Result.Standard.setAsIdentityConversion();
0ce6d6b46eb70 (Mark de Wever            2020-10-03 14:31:46 +0200  5076)           Result.Standard.setFromType(ToType);
0ce6d6b46eb70 (Mark de Wever            2020-10-03 14:31:46 +0200  5077)           Result.Standard.setAllToTypes(ToType);
0ce6d6b46eb70 (Mark de Wever            2020-10-03 14:31:46 +0200  5078)           return Result;
0ce6d6b46eb70 (Mark de Wever            2020-10-03 14:31:46 +0200  5079)         }
19d08672844ee (Larisse Voufo            2015-01-27 18:47:05 +0000  5080)       }
19d08672844ee (Larisse Voufo            2015-01-27 18:47:05 +0000  5081)     }
19d08672844ee (Larisse Voufo            2015-01-27 18:47:05 +0000  5082)   }
19d08672844ee (Larisse Voufo            2015-01-27 18:47:05 +0000  5083) 
19d08672844ee (Larisse Voufo            2015-01-27 18:47:05 +0000  5084)   // C++14 [over.ics.list]p2: Otherwise, if the parameter type [...] (below).
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5085)   // C++11 [over.ics.list]p2:
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5086)   //   If the parameter type is std::initializer_list<X> or "array of X" and
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5087)   //   all the elements can be implicitly converted to X, the implicit
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5088)   //   conversion sequence is the worst conversion necessary to convert an
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5089)   //   element of the list to X.
19d08672844ee (Larisse Voufo            2015-01-27 18:47:05 +0000  5090)   //
19d08672844ee (Larisse Voufo            2015-01-27 18:47:05 +0000  5091)   // C++14 [over.ics.list]p3:
b01d86b3159a5 (NAKAMURA Takumi          2015-02-25 11:02:00 +0000  5092)   //   Otherwise, if the parameter type is "array of N X", if the initializer
19d08672844ee (Larisse Voufo            2015-01-27 18:47:05 +0000  5093)   //   list has exactly N elements or if it has fewer than N elements and X is
19d08672844ee (Larisse Voufo            2015-01-27 18:47:05 +0000  5094)   //   default-constructible, and if all the elements of the initializer list
19d08672844ee (Larisse Voufo            2015-01-27 18:47:05 +0000  5095)   //   can be implicitly converted to X, the implicit conversion sequence is
19d08672844ee (Larisse Voufo            2015-01-27 18:47:05 +0000  5096)   //   the worst conversion necessary to convert an element of the list to X.
1bbaba874633e (Richard Smith            2015-01-27 23:23:39 +0000  5097)   //
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  5098)   QualType InitTy = ToType;
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  5099)   ArrayType const *AT = S.Context.getAsArrayType(ToType);
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  5100)   if (AT || S.isStdInitializerList(ToType, &InitTy)) {
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  5101)     unsigned e = From->getNumInits();
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  5102)     bool Clear = true;
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  5103)     if (AT) {
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  5104)       InitTy = AT->getElementType();
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  5105)       if (ConstantArrayType const *CT = dyn_cast<ConstantArrayType>(AT)) {
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  5106)         if (CT->getSize().ult(e))
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  5107)           Clear = false; // Too many inits, fatally bad
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  5108)         else if (CT->getSize().ugt(e)) {
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  5109)           // Need an init from empty {}, is there one?
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  5110)           // FIXME: Is there a simpler way than this?
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  5111)           InitListExpr EmptyList(S.Context, From->getEndLoc(), None,
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  5112)                                  From->getEndLoc());
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  5113)           EmptyList.setType(S.Context.VoidTy);
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  5114)           auto ICS = TryListConversion(
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  5115)               S, &EmptyList, InitTy, SuppressUserConversions,
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  5116)               InOverloadResolution, AllowObjCWritebackConversion);
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  5117)           if (!ICS.isBad())
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  5118)             Result = ICS;
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  5119)           Clear = false;
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  5120)         }
10f0fc04a8f50 (Sebastian Redl           2012-01-17 22:49:48 +0000  5121)       }
10f0fc04a8f50 (Sebastian Redl           2012-01-17 22:49:48 +0000  5122)     }
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  5123)     if (Clear) {
0f5c1c01273da (Douglas Gregor           2012-04-04 23:09:20 +0000  5124)       Result.setStandard();
0f5c1c01273da (Douglas Gregor           2012-04-04 23:09:20 +0000  5125)       Result.Standard.setAsIdentityConversion();
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  5126)       Result.Standard.setFromType(InitTy);
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  5127)       Result.Standard.setAllToTypes(InitTy);
0f5c1c01273da (Douglas Gregor           2012-04-04 23:09:20 +0000  5128)     }
0f5c1c01273da (Douglas Gregor           2012-04-04 23:09:20 +0000  5129) 
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  5130)     if (!Result.isBad())
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  5131)       for (unsigned i = 0; i < e; ++i) {
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  5132)         Expr *Init = From->getInit(i);
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  5133)         ImplicitConversionSequence ICS = TryCopyInitialization(
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  5134)             S, Init, InitTy, SuppressUserConversions, InOverloadResolution,
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  5135)             AllowObjCWritebackConversion);
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  5136)         // Keep the worse conversion.
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  5137)         if (CompareImplicitConversionSequences(S, From->getBeginLoc(), ICS,
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  5138)                                                Result) ==
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  5139)             ImplicitConversionSequence::Worse) {
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  5140)           Result = ICS;
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  5141)           // Bail as soon as we find something unconvertible.
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  5142)           if (Result.isBad())
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  5143)             break;
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  5144)         }
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  5145)       }
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  5146) 
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  5147)     // Record the type being initialized so that we may compare sequences
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  5148)     Result.setInitializerListToType(ToType);
cc812d9aa51bf (Nathan Sidwell           2021-05-25 07:04:25 -0700  5149) 
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5150)     return Result;
10f0fc04a8f50 (Sebastian Redl           2012-01-17 22:49:48 +0000  5151)   }
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5152) 
19d08672844ee (Larisse Voufo            2015-01-27 18:47:05 +0000  5153)   // C++14 [over.ics.list]p4:
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5154)   // C++11 [over.ics.list]p3:
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5155)   //   Otherwise, if the parameter is a non-aggregate class X and overload
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5156)   //   resolution chooses a single best constructor [...] the implicit
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5157)   //   conversion sequence is a user-defined conversion sequence. If multiple
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5158)   //   constructors are viable but none is better than the others, the
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5159)   //   implicit conversion sequence is a user-defined conversion sequence.
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  5160)   if (ToType->isRecordType() && !ToType->isAggregateType()) {
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  5161)     // This function can deal with initializer lists.
a93f1028a07a9 (Richard Smith            2013-09-06 22:30:28 +0000  5162)     return TryUserDefinedConversion(S, From, ToType, SuppressUserConversions,
d28763cad06e6 (Richard Smith            2020-01-29 12:07:14 -0800  5163)                                     AllowedExplicit::None,
a93f1028a07a9 (Richard Smith            2013-09-06 22:30:28 +0000  5164)                                     InOverloadResolution, /*CStyle=*/false,
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  5165)                                     AllowObjCWritebackConversion,
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  5166)                                     /*AllowObjCConversionOnExplicit=*/false);
6901c0de675f3 (Sebastian Redl           2011-12-22 18:58:38 +0000  5167)   }
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5168) 
19d08672844ee (Larisse Voufo            2015-01-27 18:47:05 +0000  5169)   // C++14 [over.ics.list]p5:
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5170)   // C++11 [over.ics.list]p4:
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5171)   //   Otherwise, if the parameter has an aggregate type which can be
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5172)   //   initialized from the initializer list [...] the implicit conversion
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5173)   //   sequence is a user-defined conversion sequence.
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5174)   if (ToType->isAggregateType()) {
72ef7bc2b580f (Sebastian Redl           2011-11-01 15:53:09 +0000  5175)     // Type is an aggregate, argument is an init list. At this point it comes
72ef7bc2b580f (Sebastian Redl           2011-11-01 15:53:09 +0000  5176)     // down to checking whether the initialization works.
72ef7bc2b580f (Sebastian Redl           2011-11-01 15:53:09 +0000  5177)     // FIXME: Find out whether this parameter is consumed or not.
72ef7bc2b580f (Sebastian Redl           2011-11-01 15:53:09 +0000  5178)     InitializedEntity Entity =
72ef7bc2b580f (Sebastian Redl           2011-11-01 15:53:09 +0000  5179)         InitializedEntity::InitializeParameter(S.Context, ToType,
72ef7bc2b580f (Sebastian Redl           2011-11-01 15:53:09 +0000  5180)                                                /*Consumed=*/false);
5030928d60a1d (Richard Smith            2019-08-30 22:52:55 +0000  5181)     if (S.CanPerformAggregateInitializationForOverloadResolution(Entity,
5030928d60a1d (Richard Smith            2019-08-30 22:52:55 +0000  5182)                                                                  From)) {
72ef7bc2b580f (Sebastian Redl           2011-11-01 15:53:09 +0000  5183)       Result.setUserDefined();
72ef7bc2b580f (Sebastian Redl           2011-11-01 15:53:09 +0000  5184)       Result.UserDefined.Before.setAsIdentityConversion();
72ef7bc2b580f (Sebastian Redl           2011-11-01 15:53:09 +0000  5185)       // Initializer lists don't have a type.
72ef7bc2b580f (Sebastian Redl           2011-11-01 15:53:09 +0000  5186)       Result.UserDefined.Before.setFromType(QualType());
72ef7bc2b580f (Sebastian Redl           2011-11-01 15:53:09 +0000  5187)       Result.UserDefined.Before.setAllToTypes(QualType());
72ef7bc2b580f (Sebastian Redl           2011-11-01 15:53:09 +0000  5188) 
72ef7bc2b580f (Sebastian Redl           2011-11-01 15:53:09 +0000  5189)       Result.UserDefined.After.setAsIdentityConversion();
72ef7bc2b580f (Sebastian Redl           2011-11-01 15:53:09 +0000  5190)       Result.UserDefined.After.setFromType(ToType);
72ef7bc2b580f (Sebastian Redl           2011-11-01 15:53:09 +0000  5191)       Result.UserDefined.After.setAllToTypes(ToType);
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000  5192)       Result.UserDefined.ConversionFunction = nullptr;
72ef7bc2b580f (Sebastian Redl           2011-11-01 15:53:09 +0000  5193)     }
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5194)     return Result;
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5195)   }
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5196) 
19d08672844ee (Larisse Voufo            2015-01-27 18:47:05 +0000  5197)   // C++14 [over.ics.list]p6:
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5198)   // C++11 [over.ics.list]p5:
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5199)   //   Otherwise, if the parameter is a reference, see 13.3.3.1.4.
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5200)   if (ToType->isReferenceType()) {
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5201)     // The standard is notoriously unclear here, since 13.3.3.1.4 doesn't
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5202)     // mention initializer lists in any way. So we go by what list-
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5203)     // initialization would do and try to extrapolate from that.
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5204) 
ed3b68e0dc3c0 (Simon Pilgrim            2019-10-02 14:02:27 +0000  5205)     QualType T1 = ToType->castAs<ReferenceType>()->getPointeeType();
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5206) 
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5207)     // If the initializer list has a single element that is reference-related
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5208)     // to the parameter type, we initialize the reference from that.
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5209)     if (From->getNumInits() == 1) {
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5210)       Expr *Init = From->getInit(0);
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5211) 
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5212)       QualType T2 = Init->getType();
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5213) 
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5214)       // If the initializer is the address of an overloaded function, try
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5215)       // to resolve the overloaded function. If all goes well, T2 is the
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5216)       // type of the resulting function.
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5217)       if (S.Context.getCanonicalType(T2) == S.Context.OverloadTy) {
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5218)         DeclAccessPair Found;
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5219)         if (FunctionDecl *Fn = S.ResolveAddressOfOverloadedFunction(
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5220)                                    Init, ToType, false, Found))
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5221)           T2 = Fn->getType();
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5222)       }
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5223) 
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5224)       // Compute some basic properties of the types and the initializer.
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  5225)       Sema::ReferenceCompareResult RefRelationship =
3ced23976aa8a (Richard Smith            2019-12-18 14:01:40 -0800  5226)           S.CompareReferenceRelationship(From->getBeginLoc(), T1, T2);
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5227) 
4d2bbd78ff7eb (Richard Smith            2013-09-06 01:22:42 +0000  5228)       if (RefRelationship >= Sema::Ref_Related) {
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  5229)         return TryReferenceInit(S, Init, ToType, /*FIXME*/ From->getBeginLoc(),
a93f1028a07a9 (Richard Smith            2013-09-06 22:30:28 +0000  5230)                                 SuppressUserConversions,
a93f1028a07a9 (Richard Smith            2013-09-06 22:30:28 +0000  5231)                                 /*AllowExplicit=*/false);
4d2bbd78ff7eb (Richard Smith            2013-09-06 01:22:42 +0000  5232)       }
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5233)     }
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5234) 
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5235)     // Otherwise, we bind the reference to a temporary created from the
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5236)     // initializer list.
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5237)     Result = TryListConversion(S, From, T1, SuppressUserConversions,
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5238)                                InOverloadResolution,
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5239)                                AllowObjCWritebackConversion);
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5240)     if (Result.isFailure())
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5241)       return Result;
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5242)     assert(!Result.isEllipsis() &&
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5243)            "Sub-initialization cannot result in ellipsis conversion.");
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5244) 
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5245)     // Can we even bind to a temporary?
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5246)     if (ToType->isRValueReferenceType() ||
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5247)         (T1.isConstQualified() && !T1.isVolatileQualified())) {
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5248)       StandardConversionSequence &SCS = Result.isStandard() ? Result.Standard :
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5249)                                             Result.UserDefined.After;
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5250)       SCS.ReferenceBinding = true;
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5251)       SCS.IsLvalueReference = ToType->isLValueReferenceType();
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5252)       SCS.BindsToRvalue = true;
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5253)       SCS.BindsToFunctionLvalue = false;
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5254)       SCS.BindsImplicitObjectArgumentWithoutRefQualifier = false;
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5255)       SCS.ObjCLifetimeConversionBinding = false;
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5256)     } else
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5257)       Result.setBad(BadConversionSequence::lvalue_ref_to_rvalue,
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5258)                     From, ToType);
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5259)     return Result;
df888642733dd (Sebastian Redl           2011-12-03 14:54:30 +0000  5260)   }
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5261) 
19d08672844ee (Larisse Voufo            2015-01-27 18:47:05 +0000  5262)   // C++14 [over.ics.list]p7:
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5263)   // C++11 [over.ics.list]p6:
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5264)   //   Otherwise, if the parameter type is not a class:
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5265)   if (!ToType->isRecordType()) {
19d08672844ee (Larisse Voufo            2015-01-27 18:47:05 +0000  5266)     //    - if the initializer list has one element that is not itself an
19d08672844ee (Larisse Voufo            2015-01-27 18:47:05 +0000  5267)     //      initializer list, the implicit conversion sequence is the one
19d08672844ee (Larisse Voufo            2015-01-27 18:47:05 +0000  5268)     //      required to convert the element to the parameter type.
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5269)     unsigned NumInits = From->getNumInits();
1bbaba874633e (Richard Smith            2015-01-27 23:23:39 +0000  5270)     if (NumInits == 1 && !isa<InitListExpr>(From->getInit(0)))
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5271)       Result = TryCopyInitialization(S, From->getInit(0), ToType,
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5272)                                      SuppressUserConversions,
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5273)                                      InOverloadResolution,
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5274)                                      AllowObjCWritebackConversion);
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5275)     //    - if the initializer list has no elements, the implicit conversion
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5276)     //      sequence is the identity conversion.
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5277)     else if (NumInits == 0) {
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5278)       Result.setStandard();
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5279)       Result.Standard.setAsIdentityConversion();
b73bc9af60367 (John McCall              2012-04-04 02:40:27 +0000  5280)       Result.Standard.setFromType(ToType);
b73bc9af60367 (John McCall              2012-04-04 02:40:27 +0000  5281)       Result.Standard.setAllToTypes(ToType);
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5282)     }
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5283)     return Result;
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5284)   }
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5285) 
19d08672844ee (Larisse Voufo            2015-01-27 18:47:05 +0000  5286)   // C++14 [over.ics.list]p8:
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5287)   // C++11 [over.ics.list]p7:
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5288)   //   In all cases other than those enumerated above, no conversion is possible
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5289)   return Result;
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5290) }
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5291) 
8e1cf608dc587 (Douglas Gregor           2008-10-29 00:13:59 +0000  5292) /// TryCopyInitialization - Try to copy-initialize a value of type
8e1cf608dc587 (Douglas Gregor           2008-10-29 00:13:59 +0000  5293) /// ToType from the expression From. Return the implicit conversion
8e1cf608dc587 (Douglas Gregor           2008-10-29 00:13:59 +0000  5294) /// sequence required to pass this argument, which may be a bad
8e1cf608dc587 (Douglas Gregor           2008-10-29 00:13:59 +0000  5295) /// conversion sequence (meaning that the argument cannot be passed to
2fe9883a961df (Douglas Gregor           2008-11-03 19:09:14 +0000  5296) /// a parameter of this type). If @p SuppressUserConversions, then we
e81335c85ba47 (Douglas Gregor           2010-04-16 18:00:29 +0000  5297) /// do not permit any user-defined conversion sequences.
cb13cfc878200 (Douglas Gregor           2010-04-16 17:51:22 +0000  5298) static ImplicitConversionSequence
cb13cfc878200 (Douglas Gregor           2010-04-16 17:51:22 +0000  5299) TryCopyInitialization(Sema &S, Expr *From, QualType ToType,
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  5300)                       bool SuppressUserConversions,
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  5301)                       bool InOverloadResolution,
6073dcab38e4e (Douglas Gregor           2012-02-24 23:56:31 +0000  5302)                       bool AllowObjCWritebackConversion,
6073dcab38e4e (Douglas Gregor           2012-02-24 23:56:31 +0000  5303)                       bool AllowExplicit) {
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5304)   if (InitListExpr *FromInitList = dyn_cast<InitListExpr>(From))
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5305)     return TryListConversion(S, FromInitList, ToType, SuppressUserConversions,
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5306)                              InOverloadResolution,AllowObjCWritebackConversion);
b17be8dcfec4a (Sebastian Redl           2011-10-16 18:19:34 +0000  5307) 
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  5308)   if (ToType->isReferenceType())
cb13cfc878200 (Douglas Gregor           2010-04-16 17:51:22 +0000  5309)     return TryReferenceInit(S, From, ToType,
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  5310)                             /*FIXME:*/ From->getBeginLoc(),
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  5311)                             SuppressUserConversions, AllowExplicit);
38ae6ab6bc14d (Douglas Gregor           2010-04-13 16:31:36 +0000  5312) 
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  5313)   return TryImplicitConversion(S, From, ToType,
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  5314)                                SuppressUserConversions,
d28763cad06e6 (Richard Smith            2020-01-29 12:07:14 -0800  5315)                                AllowedExplicit::None,
582813596a100 (Douglas Gregor           2011-01-27 00:58:17 +0000  5316)                                InOverloadResolution,
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  5317)                                /*CStyle=*/false,
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  5318)                                AllowObjCWritebackConversion,
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  5319)                                /*AllowObjCConversionOnExplicit=*/false);
8e1cf608dc587 (Douglas Gregor           2008-10-29 00:13:59 +0000  5320) }
8e1cf608dc587 (Douglas Gregor           2008-10-29 00:13:59 +0000  5321) 
1b06812f466f1 (Anna Zaks                2011-07-28 19:46:48 +0000  5322) static bool TryCopyInitialization(const CanQualType FromQTy,
1b06812f466f1 (Anna Zaks                2011-07-28 19:46:48 +0000  5323)                                   const CanQualType ToQTy,
1b06812f466f1 (Anna Zaks                2011-07-28 19:46:48 +0000  5324)                                   Sema &S,
1b06812f466f1 (Anna Zaks                2011-07-28 19:46:48 +0000  5325)                                   SourceLocation Loc,
1b06812f466f1 (Anna Zaks                2011-07-28 19:46:48 +0000  5326)                                   ExprValueKind FromVK) {
1b06812f466f1 (Anna Zaks                2011-07-28 19:46:48 +0000  5327)   OpaqueValueExpr TmpExpr(Loc, FromQTy, FromVK);
1b06812f466f1 (Anna Zaks                2011-07-28 19:46:48 +0000  5328)   ImplicitConversionSequence ICS =
1b06812f466f1 (Anna Zaks                2011-07-28 19:46:48 +0000  5329)     TryCopyInitialization(S, &TmpExpr, ToQTy, true, true, false);
1b06812f466f1 (Anna Zaks                2011-07-28 19:46:48 +0000  5330) 
1b06812f466f1 (Anna Zaks                2011-07-28 19:46:48 +0000  5331)   return !ICS.isBad();
1b06812f466f1 (Anna Zaks                2011-07-28 19:46:48 +0000  5332) }
1b06812f466f1 (Anna Zaks                2011-07-28 19:46:48 +0000  5333) 
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  5334) /// TryObjectArgumentInitialization - Try to initialize the object
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  5335) /// parameter of the given member function (@c Method) from the
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  5336) /// expression @p From.
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  5337) static ImplicitConversionSequence
0f59cb38e7f31 (Richard Smith            2015-12-18 21:45:41 +0000  5338) TryObjectArgumentInitialization(Sema &S, SourceLocation Loc, QualType FromType,
0282432039ab9 (Douglas Gregor           2011-01-26 19:30:28 +0000  5339)                                 Expr::Classification FromClassification,
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  5340)                                 CXXMethodDecl *Method,
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  5341)                                 CXXRecordDecl *ActingContext) {
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  5342)   QualType ClassType = S.Context.getTypeDeclType(ActingContext);
931e0bd331953 (Sebastian Redl           2009-11-18 20:55:52 +0000  5343)   // [class.dtor]p2: A destructor can be invoked for a const, volatile or
931e0bd331953 (Sebastian Redl           2009-11-18 20:55:52 +0000  5344)   //                 const volatile object.
88559637641e9 (Marco Antognini          2019-07-22 09:39:13 +0000  5345)   Qualifiers Quals = Method->getMethodQualifiers();
9d2872db7495d (Mikael Nilsson           2018-12-13 10:15:27 +0000  5346)   if (isa<CXXDestructorDecl>(Method)) {
9d2872db7495d (Mikael Nilsson           2018-12-13 10:15:27 +0000  5347)     Quals.addConst();
9d2872db7495d (Mikael Nilsson           2018-12-13 10:15:27 +0000  5348)     Quals.addVolatile();
9d2872db7495d (Mikael Nilsson           2018-12-13 10:15:27 +0000  5349)   }
9d2872db7495d (Mikael Nilsson           2018-12-13 10:15:27 +0000  5350) 
9d2872db7495d (Mikael Nilsson           2018-12-13 10:15:27 +0000  5351)   QualType ImplicitParamType = S.Context.getQualifiedType(ClassType, Quals);
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  5352) 
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  5353)   // Set up the conversion sequence as a "bad" conversion, to allow us
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  5354)   // to exit early.
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  5355)   ImplicitConversionSequence ICS;
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  5356) 
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  5357)   // We need to have an object of class type.
0282432039ab9 (Douglas Gregor           2011-01-26 19:30:28 +0000  5358)   if (const PointerType *PT = FromType->getAs<PointerType>()) {
bfdea0f13684f (Anders Carlsson          2009-05-01 18:34:30 +0000  5359)     FromType = PT->getPointeeType();
bfdea0f13684f (Anders Carlsson          2009-05-01 18:34:30 +0000  5360) 
0282432039ab9 (Douglas Gregor           2011-01-26 19:30:28 +0000  5361)     // When we had a pointer, it's implicitly dereferenced, so we
0282432039ab9 (Douglas Gregor           2011-01-26 19:30:28 +0000  5362)     // better have an lvalue.
0282432039ab9 (Douglas Gregor           2011-01-26 19:30:28 +0000  5363)     assert(FromClassification.isLValue());
0282432039ab9 (Douglas Gregor           2011-01-26 19:30:28 +0000  5364)   }
0282432039ab9 (Douglas Gregor           2011-01-26 19:30:28 +0000  5365) 
bfdea0f13684f (Anders Carlsson          2009-05-01 18:34:30 +0000  5366)   assert(FromType->isRecordType());
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  5367) 
0282432039ab9 (Douglas Gregor           2011-01-26 19:30:28 +0000  5368)   // C++0x [over.match.funcs]p4:
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  5369)   //   For non-static member functions, the type of the implicit object
0282432039ab9 (Douglas Gregor           2011-01-26 19:30:28 +0000  5370)   //   parameter is
0282432039ab9 (Douglas Gregor           2011-01-26 19:30:28 +0000  5371)   //
7c2888689dfdd (NAKAMURA Takumi          2011-01-27 07:09:49 +0000  5372)   //     - "lvalue reference to cv X" for functions declared without a
7c2888689dfdd (NAKAMURA Takumi          2011-01-27 07:09:49 +0000  5373)   //        ref-qualifier or with the & ref-qualifier
7c2888689dfdd (NAKAMURA Takumi          2011-01-27 07:09:49 +0000  5374)   //     - "rvalue reference to cv X" for functions declared with the &&
0282432039ab9 (Douglas Gregor           2011-01-26 19:30:28 +0000  5375)   //        ref-qualifier
0282432039ab9 (Douglas Gregor           2011-01-26 19:30:28 +0000  5376)   //
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  5377)   // where X is the class of which the function is a member and cv is the
0282432039ab9 (Douglas Gregor           2011-01-26 19:30:28 +0000  5378)   // cv-qualification on the member function declaration.
0282432039ab9 (Douglas Gregor           2011-01-26 19:30:28 +0000  5379)   //
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  5380)   // However, when finding an implicit conversion sequence for the argument, we
122f88d481971 (Richard Smith            2016-12-06 23:52:28 +0000  5381)   // are not allowed to perform user-defined conversions
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  5382)   // (C++ [over.match.funcs]p5). We perform a simplified version of
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  5383)   // reference binding here, that allows class rvalues to bind to
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  5384)   // non-constant references.
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  5385) 
0282432039ab9 (Douglas Gregor           2011-01-26 19:30:28 +0000  5386)   // First check the qualifiers.
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  5387)   QualType FromTypeCanon = S.Context.getCanonicalType(FromType);
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  5388)   if (ImplicitParamType.getCVRQualifiers()
1b8fe5b716b8b (Douglas Gregor           2009-11-16 21:35:15 +0000  5389)                                     != FromTypeCanon.getLocalCVRQualifiers() &&
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000  5390)       !ImplicitParamType.isAtLeastAsQualifiedAs(FromTypeCanon)) {
65eb879d22cc9 (John McCall              2010-02-25 01:37:24 +0000  5391)     ICS.setBad(BadConversionSequence::bad_qualifiers,
03c66d3c57b51 (Richard Smith            2013-01-26 02:07:32 +0000  5392)                FromType, ImplicitParamType);
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  5393)     return ICS;
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000  5394)   }
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  5395) 
f2ace9d6005b4 (Michael Liao             2019-12-06 11:48:15 -0500  5396)   if (FromTypeCanon.hasAddressSpace()) {
5cffa45401149 (Anastasia Stulova        2019-01-21 16:01:38 +0000  5397)     Qualifiers QualsImplicitParamType = ImplicitParamType.getQualifiers();
5cffa45401149 (Anastasia Stulova        2019-01-21 16:01:38 +0000  5398)     Qualifiers QualsFromType = FromTypeCanon.getQualifiers();
5cffa45401149 (Anastasia Stulova        2019-01-21 16:01:38 +0000  5399)     if (!QualsImplicitParamType.isAddressSpaceSupersetOf(QualsFromType)) {
5cffa45401149 (Anastasia Stulova        2019-01-21 16:01:38 +0000  5400)       ICS.setBad(BadConversionSequence::bad_qualifiers,
5cffa45401149 (Anastasia Stulova        2019-01-21 16:01:38 +0000  5401)                  FromType, ImplicitParamType);
5cffa45401149 (Anastasia Stulova        2019-01-21 16:01:38 +0000  5402)       return ICS;
5cffa45401149 (Anastasia Stulova        2019-01-21 16:01:38 +0000  5403)     }
5cffa45401149 (Anastasia Stulova        2019-01-21 16:01:38 +0000  5404)   }
5cffa45401149 (Anastasia Stulova        2019-01-21 16:01:38 +0000  5405) 
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  5406)   // Check that we have either the same type or a derived type. It
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  5407)   // affects the conversion rank.
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  5408)   QualType ClassTypeCanon = S.Context.getCanonicalType(ClassType);
65eb879d22cc9 (John McCall              2010-02-25 01:37:24 +0000  5409)   ImplicitConversionKind SecondKind;
65eb879d22cc9 (John McCall              2010-02-25 01:37:24 +0000  5410)   if (ClassTypeCanon == FromTypeCanon.getLocalUnqualifiedType()) {
65eb879d22cc9 (John McCall              2010-02-25 01:37:24 +0000  5411)     SecondKind = ICK_Identity;
0f59cb38e7f31 (Richard Smith            2015-12-18 21:45:41 +0000  5412)   } else if (S.IsDerivedFrom(Loc, FromType, ClassType))
65eb879d22cc9 (John McCall              2010-02-25 01:37:24 +0000  5413)     SecondKind = ICK_Derived_To_Base;
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000  5414)   else {
65eb879d22cc9 (John McCall              2010-02-25 01:37:24 +0000  5415)     ICS.setBad(BadConversionSequence::unrelated_class,
65eb879d22cc9 (John McCall              2010-02-25 01:37:24 +0000  5416)                FromType, ImplicitParamType);
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  5417)     return ICS;
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000  5418)   }
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  5419) 
0282432039ab9 (Douglas Gregor           2011-01-26 19:30:28 +0000  5420)   // Check the ref-qualifier.
0282432039ab9 (Douglas Gregor           2011-01-26 19:30:28 +0000  5421)   switch (Method->getRefQualifier()) {
0282432039ab9 (Douglas Gregor           2011-01-26 19:30:28 +0000  5422)   case RQ_None:
0282432039ab9 (Douglas Gregor           2011-01-26 19:30:28 +0000  5423)     // Do nothing; we don't care about lvalueness or rvalueness.
0282432039ab9 (Douglas Gregor           2011-01-26 19:30:28 +0000  5424)     break;
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  5425) 
0282432039ab9 (Douglas Gregor           2011-01-26 19:30:28 +0000  5426)   case RQ_LValue:
9d2872db7495d (Mikael Nilsson           2018-12-13 10:15:27 +0000  5427)     if (!FromClassification.isLValue() && !Quals.hasOnlyConst()) {
0282432039ab9 (Douglas Gregor           2011-01-26 19:30:28 +0000  5428)       // non-const lvalue reference cannot bind to an rvalue
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  5429)       ICS.setBad(BadConversionSequence::lvalue_ref_to_rvalue, FromType,
0282432039ab9 (Douglas Gregor           2011-01-26 19:30:28 +0000  5430)                  ImplicitParamType);
0282432039ab9 (Douglas Gregor           2011-01-26 19:30:28 +0000  5431)       return ICS;
0282432039ab9 (Douglas Gregor           2011-01-26 19:30:28 +0000  5432)     }
0282432039ab9 (Douglas Gregor           2011-01-26 19:30:28 +0000  5433)     break;
0282432039ab9 (Douglas Gregor           2011-01-26 19:30:28 +0000  5434) 
0282432039ab9 (Douglas Gregor           2011-01-26 19:30:28 +0000  5435)   case RQ_RValue:
0282432039ab9 (Douglas Gregor           2011-01-26 19:30:28 +0000  5436)     if (!FromClassification.isRValue()) {
0282432039ab9 (Douglas Gregor           2011-01-26 19:30:28 +0000  5437)       // rvalue reference cannot bind to an lvalue
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  5438)       ICS.setBad(BadConversionSequence::rvalue_ref_to_lvalue, FromType,
0282432039ab9 (Douglas Gregor           2011-01-26 19:30:28 +0000  5439)                  ImplicitParamType);
0282432039ab9 (Douglas Gregor           2011-01-26 19:30:28 +0000  5440)       return ICS;
0282432039ab9 (Douglas Gregor           2011-01-26 19:30:28 +0000  5441)     }
0282432039ab9 (Douglas Gregor           2011-01-26 19:30:28 +0000  5442)     break;
0282432039ab9 (Douglas Gregor           2011-01-26 19:30:28 +0000  5443)   }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  5444) 
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  5445)   // Success. Mark this as a reference binding.
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000  5446)   ICS.setStandard();
65eb879d22cc9 (John McCall              2010-02-25 01:37:24 +0000  5447)   ICS.Standard.setAsIdentityConversion();
65eb879d22cc9 (John McCall              2010-02-25 01:37:24 +0000  5448)   ICS.Standard.Second = SecondKind;
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000  5449)   ICS.Standard.setFromType(FromType);
3edc4d5ec3fdc (Douglas Gregor           2010-01-27 03:51:04 +0000  5450)   ICS.Standard.setAllToTypes(ImplicitParamType);
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  5451)   ICS.Standard.ReferenceBinding = true;
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  5452)   ICS.Standard.DirectBinding = true;
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  5453)   ICS.Standard.IsLvalueReference = Method->getRefQualifier() != RQ_RValue;
e696ebbd70b3d (Douglas Gregor           2011-01-26 14:52:12 +0000  5454)   ICS.Standard.BindsToFunctionLvalue = false;
e1a47c176656a (Douglas Gregor           2011-01-26 19:41:18 +0000  5455)   ICS.Standard.BindsToRvalue = FromClassification.isRValue();
e1a47c176656a (Douglas Gregor           2011-01-26 19:41:18 +0000  5456)   ICS.Standard.BindsImplicitObjectArgumentWithoutRefQualifier
e1a47c176656a (Douglas Gregor           2011-01-26 19:41:18 +0000  5457)     = (Method->getRefQualifier() == RQ_None);
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  5458)   return ICS;
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  5459) }
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  5460) 
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  5461) /// PerformObjectArgumentInitialization - Perform initialization of
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  5462) /// the implicit object parameter for the given Method with the given
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  5463) /// expression.
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000  5464) ExprResult
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000  5465) Sema::PerformObjectArgumentInitialization(Expr *From,
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  5466)                                           NestedNameSpecifier *Qualifier,
16df1e59f2bb7 (John McCall              2010-03-30 21:47:33 +0000  5467)                                           NamedDecl *FoundDecl,
cc3f325fa69e7 (Douglas Gregor           2010-03-03 23:55:11 +0000  5468)                                           CXXMethodDecl *Method) {
bfdea0f13684f (Anders Carlsson          2009-05-01 18:34:30 +0000  5469)   QualType FromRecordType, DestType;
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  5470)   QualType ImplicitParamRecordType  =
ed3b68e0dc3c0 (Simon Pilgrim            2019-10-02 14:02:27 +0000  5471)     Method->getThisType()->castAs<PointerType>()->getPointeeType();
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  5472) 
0282432039ab9 (Douglas Gregor           2011-01-26 19:30:28 +0000  5473)   Expr::Classification FromClassification;
c23c7e6a51927 (Ted Kremenek             2009-07-29 21:53:49 +0000  5474)   if (const PointerType *PT = From->getType()->getAs<PointerType>()) {
bfdea0f13684f (Anders Carlsson          2009-05-01 18:34:30 +0000  5475)     FromRecordType = PT->getPointeeType();
5488ab4ddd47a (Brian Gesiak             2019-01-11 01:54:53 +0000  5476)     DestType = Method->getThisType();
0282432039ab9 (Douglas Gregor           2011-01-26 19:30:28 +0000  5477)     FromClassification = Expr::Classification::makeSimpleLValue();
bfdea0f13684f (Anders Carlsson          2009-05-01 18:34:30 +0000  5478)   } else {
bfdea0f13684f (Anders Carlsson          2009-05-01 18:34:30 +0000  5479)     FromRecordType = From->getType();
bfdea0f13684f (Anders Carlsson          2009-05-01 18:34:30 +0000  5480)     DestType = ImplicitParamRecordType;
0282432039ab9 (Douglas Gregor           2011-01-26 19:30:28 +0000  5481)     FromClassification = From->Classify(Context);
7ed5fb2d22942 (Richard Smith            2018-07-27 17:13:18 +0000  5482) 
7ed5fb2d22942 (Richard Smith            2018-07-27 17:13:18 +0000  5483)     // When performing member access on an rvalue, materialize a temporary.
7ed5fb2d22942 (Richard Smith            2018-07-27 17:13:18 +0000  5484)     if (From->isRValue()) {
7ed5fb2d22942 (Richard Smith            2018-07-27 17:13:18 +0000  5485)       From = CreateMaterializeTemporaryExpr(FromRecordType, From,
7ed5fb2d22942 (Richard Smith            2018-07-27 17:13:18 +0000  5486)                                             Method->getRefQualifier() !=
7ed5fb2d22942 (Richard Smith            2018-07-27 17:13:18 +0000  5487)                                                 RefQualifierKind::RQ_RValue);
7ed5fb2d22942 (Richard Smith            2018-07-27 17:13:18 +0000  5488)     }
bfdea0f13684f (Anders Carlsson          2009-05-01 18:34:30 +0000  5489)   }
bfdea0f13684f (Anders Carlsson          2009-05-01 18:34:30 +0000  5490) 
6e9f8f6374349 (John McCall              2009-12-03 04:06:58 +0000  5491)   // Note that we always use the true parent context when performing
6e9f8f6374349 (John McCall              2009-12-03 04:06:58 +0000  5492)   // the actual argument initialization.
b58e51c304112 (Nico Weber               2014-11-19 05:21:39 +0000  5493)   ImplicitConversionSequence ICS = TryObjectArgumentInitialization(
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  5494)       *this, From->getBeginLoc(), From->getType(), FromClassification, Method,
0f59cb38e7f31 (Richard Smith            2015-12-18 21:45:41 +0000  5495)       Method->getParent());
9813d3221d7d5 (Argyrios Kyrtzidis       2010-11-16 08:04:45 +0000  5496)   if (ICS.isBad()) {
bb93578108c52 (Jacob Bandes-Storch      2017-12-31 18:27:29 +0000  5497)     switch (ICS.Bad.Kind) {
bb93578108c52 (Jacob Bandes-Storch      2017-12-31 18:27:29 +0000  5498)     case BadConversionSequence::bad_qualifiers: {
9813d3221d7d5 (Argyrios Kyrtzidis       2010-11-16 08:04:45 +0000  5499)       Qualifiers FromQs = FromRecordType.getQualifiers();
9813d3221d7d5 (Argyrios Kyrtzidis       2010-11-16 08:04:45 +0000  5500)       Qualifiers ToQs = DestType.getQualifiers();
9813d3221d7d5 (Argyrios Kyrtzidis       2010-11-16 08:04:45 +0000  5501)       unsigned CVR = FromQs.getCVRQualifiers() & ~ToQs.getCVRQualifiers();
9813d3221d7d5 (Argyrios Kyrtzidis       2010-11-16 08:04:45 +0000  5502)       if (CVR) {
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  5503)         Diag(From->getBeginLoc(), diag::err_member_function_call_bad_cvr)
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  5504)             << Method->getDeclName() << FromRecordType << (CVR - 1)
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  5505)             << From->getSourceRange();
9813d3221d7d5 (Argyrios Kyrtzidis       2010-11-16 08:04:45 +0000  5506)         Diag(Method->getLocation(), diag::note_previous_decl)
9813d3221d7d5 (Argyrios Kyrtzidis       2010-11-16 08:04:45 +0000  5507)           << Method->getDeclName();
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000  5508)         return ExprError();
9813d3221d7d5 (Argyrios Kyrtzidis       2010-11-16 08:04:45 +0000  5509)       }
bb93578108c52 (Jacob Bandes-Storch      2017-12-31 18:27:29 +0000  5510)       break;
bb93578108c52 (Jacob Bandes-Storch      2017-12-31 18:27:29 +0000  5511)     }
bb93578108c52 (Jacob Bandes-Storch      2017-12-31 18:27:29 +0000  5512) 
bb93578108c52 (Jacob Bandes-Storch      2017-12-31 18:27:29 +0000  5513)     case BadConversionSequence::lvalue_ref_to_rvalue:
bb93578108c52 (Jacob Bandes-Storch      2017-12-31 18:27:29 +0000  5514)     case BadConversionSequence::rvalue_ref_to_lvalue: {
bb93578108c52 (Jacob Bandes-Storch      2017-12-31 18:27:29 +0000  5515)       bool IsRValueQualified =
bb93578108c52 (Jacob Bandes-Storch      2017-12-31 18:27:29 +0000  5516)         Method->getRefQualifier() == RefQualifierKind::RQ_RValue;
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  5517)       Diag(From->getBeginLoc(), diag::err_member_function_call_bad_ref)
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  5518)           << Method->getDeclName() << FromClassification.isRValue()
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  5519)           << IsRValueQualified;
bb93578108c52 (Jacob Bandes-Storch      2017-12-31 18:27:29 +0000  5520)       Diag(Method->getLocation(), diag::note_previous_decl)
bb93578108c52 (Jacob Bandes-Storch      2017-12-31 18:27:29 +0000  5521)         << Method->getDeclName();
bb93578108c52 (Jacob Bandes-Storch      2017-12-31 18:27:29 +0000  5522)       return ExprError();
bb93578108c52 (Jacob Bandes-Storch      2017-12-31 18:27:29 +0000  5523)     }
bb93578108c52 (Jacob Bandes-Storch      2017-12-31 18:27:29 +0000  5524) 
bb93578108c52 (Jacob Bandes-Storch      2017-12-31 18:27:29 +0000  5525)     case BadConversionSequence::no_conversion:
bb93578108c52 (Jacob Bandes-Storch      2017-12-31 18:27:29 +0000  5526)     case BadConversionSequence::unrelated_class:
bb93578108c52 (Jacob Bandes-Storch      2017-12-31 18:27:29 +0000  5527)       break;
9813d3221d7d5 (Argyrios Kyrtzidis       2010-11-16 08:04:45 +0000  5528)     }
9813d3221d7d5 (Argyrios Kyrtzidis       2010-11-16 08:04:45 +0000  5529) 
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  5530)     return Diag(From->getBeginLoc(), diag::err_member_function_call_bad_type)
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  5531)            << ImplicitParamRecordType << FromRecordType
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  5532)            << From->getSourceRange();
9813d3221d7d5 (Argyrios Kyrtzidis       2010-11-16 08:04:45 +0000  5533)   }
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  5534) 
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000  5535)   if (ICS.Standard.Second == ICK_Derived_To_Base) {
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000  5536)     ExprResult FromRes =
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000  5537)       PerformObjectMemberConversion(From, Qualifier, FoundDecl, Method);
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000  5538)     if (FromRes.isInvalid())
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000  5539)       return ExprError();
01a7598561561 (Nikola Smiljanic         2014-05-29 10:55:11 +0000  5540)     From = FromRes.get();
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000  5541)   }
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  5542) 
9d2872db7495d (Mikael Nilsson           2018-12-13 10:15:27 +0000  5543)   if (!Context.hasSameType(From->getType(), DestType)) {
26e095e84f0d0 (Anastasia Stulova        2019-05-02 16:10:50 +0000  5544)     CastKind CK;
82888b78d47ed (Sven van Haastregt       2019-11-04 13:12:17 +0000  5545)     QualType PteeTy = DestType->getPointeeType();
82888b78d47ed (Sven van Haastregt       2019-11-04 13:12:17 +0000  5546)     LangAS DestAS =
82888b78d47ed (Sven van Haastregt       2019-11-04 13:12:17 +0000  5547)         PteeTy.isNull() ? DestType.getAddressSpace() : PteeTy.getAddressSpace();
82888b78d47ed (Sven van Haastregt       2019-11-04 13:12:17 +0000  5548)     if (FromRecordType.getAddressSpace() != DestAS)
26e095e84f0d0 (Anastasia Stulova        2019-05-02 16:10:50 +0000  5549)       CK = CK_AddressSpaceConversion;
9d2872db7495d (Mikael Nilsson           2018-12-13 10:15:27 +0000  5550)     else
26e095e84f0d0 (Anastasia Stulova        2019-05-02 16:10:50 +0000  5551)       CK = CK_NoOp;
26e095e84f0d0 (Anastasia Stulova        2019-05-02 16:10:50 +0000  5552)     From = ImpCastExprToType(From, DestType, CK, From->getValueKind()).get();
9d2872db7495d (Mikael Nilsson           2018-12-13 10:15:27 +0000  5553)   }
03ff2596cb161 (Nikola Smiljanic         2014-05-29 14:05:12 +0000  5554)   return From;
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  5555) }
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  5556) 
5fb53972380f5 (Douglas Gregor           2009-01-14 15:45:31 +0000  5557) /// TryContextuallyConvertToBool - Attempt to contextually convert the
5fb53972380f5 (Douglas Gregor           2009-01-14 15:45:31 +0000  5558) /// expression From to bool (C++0x [conv]p3).
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  5559) static ImplicitConversionSequence
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  5560) TryContextuallyConvertToBool(Sema &S, Expr *From) {
9ce6dc9872be4 (Richard Smith            2020-02-11 06:09:18 -0800  5561)   // C++ [dcl.init]/17.8:
9ce6dc9872be4 (Richard Smith            2020-02-11 06:09:18 -0800  5562)   //   - Otherwise, if the initialization is direct-initialization, the source
9ce6dc9872be4 (Richard Smith            2020-02-11 06:09:18 -0800  5563)   //     type is std::nullptr_t, and the destination type is bool, the initial
9ce6dc9872be4 (Richard Smith            2020-02-11 06:09:18 -0800  5564)   //     value of the object being initialized is false.
9ce6dc9872be4 (Richard Smith            2020-02-11 06:09:18 -0800  5565)   if (From->getType()->isNullPtrType())
9ce6dc9872be4 (Richard Smith            2020-02-11 06:09:18 -0800  5566)     return ImplicitConversionSequence::getNullptrToBool(From->getType(),
9ce6dc9872be4 (Richard Smith            2020-02-11 06:09:18 -0800  5567)                                                         S.Context.BoolTy,
9ce6dc9872be4 (Richard Smith            2020-02-11 06:09:18 -0800  5568)                                                         From->isGLValue());
9ce6dc9872be4 (Richard Smith            2020-02-11 06:09:18 -0800  5569) 
9ce6dc9872be4 (Richard Smith            2020-02-11 06:09:18 -0800  5570)   // All other direct-initialization of bool is equivalent to an implicit
9ce6dc9872be4 (Richard Smith            2020-02-11 06:09:18 -0800  5571)   // conversion to bool in which explicit conversions are permitted.
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  5572)   return TryImplicitConversion(S, From, S.Context.BoolTy,
ef4c72135f8ec (Anders Carlsson          2009-08-27 17:24:15 +0000  5573)                                /*SuppressUserConversions=*/false,
d28763cad06e6 (Richard Smith            2020-01-29 12:07:14 -0800  5574)                                AllowedExplicit::Conversions,
582813596a100 (Douglas Gregor           2011-01-27 00:58:17 +0000  5575)                                /*InOverloadResolution=*/false,
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  5576)                                /*CStyle=*/false,
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  5577)                                /*AllowObjCWritebackConversion=*/false,
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  5578)                                /*AllowObjCConversionOnExplicit=*/false);
5fb53972380f5 (Douglas Gregor           2009-01-14 15:45:31 +0000  5579) }
5fb53972380f5 (Douglas Gregor           2009-01-14 15:45:31 +0000  5580) 
5fb53972380f5 (Douglas Gregor           2009-01-14 15:45:31 +0000  5581) /// PerformContextuallyConvertToBool - Perform a contextual conversion
5fb53972380f5 (Douglas Gregor           2009-01-14 15:45:31 +0000  5582) /// of the expression From to bool (C++0x [conv]p3).
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000  5583) ExprResult Sema::PerformContextuallyConvertToBool(Expr *From) {
526ab47a55734 (John McCall              2011-10-25 17:37:35 +0000  5584)   if (checkPlaceholderForOverload(*this, From))
526ab47a55734 (John McCall              2011-10-25 17:37:35 +0000  5585)     return ExprError();
526ab47a55734 (John McCall              2011-10-25 17:37:35 +0000  5586) 
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  5587)   ImplicitConversionSequence ICS = TryContextuallyConvertToBool(*this, From);
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000  5588)   if (!ICS.isBad())
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000  5589)     return PerformImplicitConversion(From, Context.BoolTy, ICS, AA_Converting);
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  5590) 
76197416ac15c (Fariborz Jahanian        2009-11-18 18:26:29 +0000  5591)   if (!DiagnoseMultipleUserDefinedConversion(From, Context.BoolTy))
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  5592)     return Diag(From->getBeginLoc(), diag::err_typecheck_bool_condition)
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  5593)            << From->getType() << From->getSourceRange();
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000  5594)   return ExprError();
5fb53972380f5 (Douglas Gregor           2009-01-14 15:45:31 +0000  5595) }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  5596) 
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5597) /// Check that the specified conversion is permitted in a converted constant
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5598) /// expression, according to C++11 [expr.const]p3. Return true if the conversion
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5599) /// is acceptable.
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5600) static bool CheckConvertedConstantConversions(Sema &S,
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5601)                                               StandardConversionSequence &SCS) {
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5602)   // Since we know that the target type is an integral or unscoped enumeration
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5603)   // type, most conversion kinds are impossible. All possible First and Third
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5604)   // conversions are fine.
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5605)   switch (SCS.Second) {
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5606)   case ICK_Identity:
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5607)   case ICK_Integral_Promotion:
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5608)   case ICK_Integral_Conversion: // Narrowing conversions are checked elsewhere.
89831421af27b (Egor Churaev             2016-12-23 14:55:49 +0000  5609)   case ICK_Zero_Queue_Conversion:
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5610)     return true;
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5611) 
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5612)   case ICK_Boolean_Conversion:
ca24ed473b9ce (Richard Smith            2012-09-13 22:00:12 +0000  5613)     // Conversion from an integral or unscoped enumeration type to bool is
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5614)     // classified as ICK_Boolean_Conversion, but it's also arguably an integral
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5615)     // conversion, so we allow it in a converted constant expression.
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5616)     //
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5617)     // FIXME: Per core issue 1407, we should not allow this, but that breaks
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5618)     // a lot of popular code. We should at least add a warning for this
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5619)     // (non-conforming) extension.
ca24ed473b9ce (Richard Smith            2012-09-13 22:00:12 +0000  5620)     return SCS.getFromType()->isIntegralOrUnscopedEnumerationType() &&
ca24ed473b9ce (Richard Smith            2012-09-13 22:00:12 +0000  5621)            SCS.getToType(2)->isBooleanType();
ca24ed473b9ce (Richard Smith            2012-09-13 22:00:12 +0000  5622) 
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5623)   case ICK_Pointer_Conversion:
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5624)   case ICK_Pointer_Member:
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5625)     // C++1z: null pointer conversions and null member pointer conversions are
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5626)     // only permitted if the source type is std::nullptr_t.
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5627)     return SCS.getFromType()->isNullPtrType();
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5628) 
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5629)   case ICK_Floating_Promotion:
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5630)   case ICK_Complex_Promotion:
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5631)   case ICK_Floating_Conversion:
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5632)   case ICK_Complex_Conversion:
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5633)   case ICK_Floating_Integral:
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5634)   case ICK_Compatible_Conversion:
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5635)   case ICK_Derived_To_Base:
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5636)   case ICK_Vector_Conversion:
feed5a7239d8e (Cullen Rhodes            2020-08-11 13:04:21 +0000  5637)   case ICK_SVE_Vector_Conversion:
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5638)   case ICK_Vector_Splat:
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5639)   case ICK_Complex_Real:
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5640)   case ICK_Block_Pointer_Conversion:
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5641)   case ICK_TransparentUnionConversion:
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5642)   case ICK_Writeback_Conversion:
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5643)   case ICK_Zero_Event_Conversion:
4546181e12c89 (George Burgess IV        2015-10-11 20:13:20 +0000  5644)   case ICK_C_Only_Conversion:
2099b54102e7d (George Burgess IV        2016-09-02 22:59:57 +0000  5645)   case ICK_Incompatible_Pointer_Conversion:
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5646)     return false;
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5647) 
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5648)   case ICK_Lvalue_To_Rvalue:
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5649)   case ICK_Array_To_Pointer:
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5650)   case ICK_Function_To_Pointer:
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5651)     llvm_unreachable("found a first conversion kind in Second");
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5652) 
b4a2d36c3f74e (Aaron Puchert            2020-08-29 18:13:56 +0200  5653)   case ICK_Function_Conversion:
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5654)   case ICK_Qualification:
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5655)     llvm_unreachable("found a third conversion kind in Second");
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5656) 
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5657)   case ICK_Num_Conversion_Kinds:
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5658)     break;
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5659)   }
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5660) 
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5661)   llvm_unreachable("unknown conversion kind");
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5662) }
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5663) 
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5664) /// CheckConvertedConstantExpression - Check that the expression From is a
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5665) /// converted constant expression of type T, perform the conversion and produce
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5666) /// the converted expression, per C++11 [expr.const]p3.
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5667) static ExprResult CheckConvertedConstantExpression(Sema &S, Expr *From,
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5668)                                                    QualType T, APValue &Value,
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5669)                                                    Sema::CCEKind CCE,
ba4768c966581 (Richard Smith            2020-09-20 23:16:08 -0700  5670)                                                    bool RequireInt,
8ba442bc2136c (Hans Wennborg            2021-01-20 15:25:33 +0100  5671)                                                    NamedDecl *Dest) {
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5672)   assert(S.getLangOpts().CPlusPlus11 &&
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5673)          "converted constant expression outside C++11");
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5674) 
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5675)   if (checkPlaceholderForOverload(S, From))
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5676)     return ExprError();
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5677) 
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5678)   // C++1z [expr.const]p3:
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5679)   //  A converted constant expression of type T is an expression,
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5680)   //  implicitly converted to type T, where the converted
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5681)   //  expression is a constant expression and the implicit conversion
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5682)   //  sequence contains only [... list of conversions ...].
4a00774e59c71 (Ismail Pazarbasi         2016-09-07 18:24:54 +0000  5683)   // C++1z [stmt.if]p2:
4a00774e59c71 (Ismail Pazarbasi         2016-09-07 18:24:54 +0000  5684)   //  If the if statement is of the form if constexpr, the value of the
4a00774e59c71 (Ismail Pazarbasi         2016-09-07 18:24:54 +0000  5685)   //  condition shall be a contextually converted constant expression of type
4a00774e59c71 (Ismail Pazarbasi         2016-09-07 18:24:54 +0000  5686)   //  bool.
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5687)   ImplicitConversionSequence ICS =
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000  5688)       CCE == Sema::CCEK_ConstexprIf || CCE == Sema::CCEK_ExplicitBool
4a00774e59c71 (Ismail Pazarbasi         2016-09-07 18:24:54 +0000  5689)           ? TryContextuallyConvertToBool(S, From)
4a00774e59c71 (Ismail Pazarbasi         2016-09-07 18:24:54 +0000  5690)           : TryCopyInitialization(S, From, T,
4a00774e59c71 (Ismail Pazarbasi         2016-09-07 18:24:54 +0000  5691)                                   /*SuppressUserConversions=*/false,
4a00774e59c71 (Ismail Pazarbasi         2016-09-07 18:24:54 +0000  5692)                                   /*InOverloadResolution=*/false,
49a3ad21d6034 (Rui Ueyama               2019-07-16 04:46:31 +0000  5693)                                   /*AllowObjCWritebackConversion=*/false,
4a00774e59c71 (Ismail Pazarbasi         2016-09-07 18:24:54 +0000  5694)                                   /*AllowExplicit=*/false);
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000  5695)   StandardConversionSequence *SCS = nullptr;
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5696)   switch (ICS.getKind()) {
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5697)   case ImplicitConversionSequence::StandardConversion:
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5698)     SCS = &ICS.Standard;
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5699)     break;
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5700)   case ImplicitConversionSequence::UserDefinedConversion:
ba4768c966581 (Richard Smith            2020-09-20 23:16:08 -0700  5701)     if (T->isRecordType())
ba4768c966581 (Richard Smith            2020-09-20 23:16:08 -0700  5702)       SCS = &ICS.UserDefined.Before;
ba4768c966581 (Richard Smith            2020-09-20 23:16:08 -0700  5703)     else
ba4768c966581 (Richard Smith            2020-09-20 23:16:08 -0700  5704)       SCS = &ICS.UserDefined.After;
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5705)     break;
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5706)   case ImplicitConversionSequence::AmbiguousConversion:
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5707)   case ImplicitConversionSequence::BadConversion:
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5708)     if (!S.DiagnoseMultipleUserDefinedConversion(From, T))
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  5709)       return S.Diag(From->getBeginLoc(),
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5710)                     diag::err_typecheck_converted_constant_expression)
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  5711)              << From->getType() << From->getSourceRange() << T;
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5712)     return ExprError();
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5713) 
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5714)   case ImplicitConversionSequence::EllipsisConversion:
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5715)     llvm_unreachable("ellipsis conversion in converted constant expression");
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5716)   }
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5717) 
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5718)   // Check that we would only use permitted conversions.
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5719)   if (!CheckConvertedConstantConversions(S, *SCS)) {
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  5720)     return S.Diag(From->getBeginLoc(),
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5721)                   diag::err_typecheck_converted_constant_expression_disallowed)
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  5722)            << From->getType() << From->getSourceRange() << T;
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5723)   }
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5724)   // [...] and where the reference binding (if any) binds directly.
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5725)   if (SCS->ReferenceBinding && !SCS->DirectBinding) {
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  5726)     return S.Diag(From->getBeginLoc(),
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5727)                   diag::err_typecheck_converted_constant_expression_indirect)
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  5728)            << From->getType() << From->getSourceRange() << T;
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5729)   }
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5730) 
ba4768c966581 (Richard Smith            2020-09-20 23:16:08 -0700  5731)   // Usually we can simply apply the ImplicitConversionSequence we formed
ba4768c966581 (Richard Smith            2020-09-20 23:16:08 -0700  5732)   // earlier, but that's not guaranteed to work when initializing an object of
ba4768c966581 (Richard Smith            2020-09-20 23:16:08 -0700  5733)   // class type.
ba4768c966581 (Richard Smith            2020-09-20 23:16:08 -0700  5734)   ExprResult Result;
ba4768c966581 (Richard Smith            2020-09-20 23:16:08 -0700  5735)   if (T->isRecordType()) {
ba4768c966581 (Richard Smith            2020-09-20 23:16:08 -0700  5736)     assert(CCE == Sema::CCEK_TemplateArg &&
ba4768c966581 (Richard Smith            2020-09-20 23:16:08 -0700  5737)            "unexpected class type converted constant expr");
ba4768c966581 (Richard Smith            2020-09-20 23:16:08 -0700  5738)     Result = S.PerformCopyInitialization(
ba4768c966581 (Richard Smith            2020-09-20 23:16:08 -0700  5739)         InitializedEntity::InitializeTemplateParameter(
ba4768c966581 (Richard Smith            2020-09-20 23:16:08 -0700  5740)             T, cast<NonTypeTemplateParmDecl>(Dest)),
ba4768c966581 (Richard Smith            2020-09-20 23:16:08 -0700  5741)         SourceLocation(), From);
ba4768c966581 (Richard Smith            2020-09-20 23:16:08 -0700  5742)   } else {
ba4768c966581 (Richard Smith            2020-09-20 23:16:08 -0700  5743)     Result = S.PerformImplicitConversion(From, T, ICS, Sema::AA_Converting);
ba4768c966581 (Richard Smith            2020-09-20 23:16:08 -0700  5744)   }
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5745)   if (Result.isInvalid())
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5746)     return Result;
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5747) 
40c3d6e335900 (Richard Smith            2019-09-19 22:00:16 +0000  5748)   // C++2a [intro.execution]p5:
40c3d6e335900 (Richard Smith            2019-09-19 22:00:16 +0000  5749)   //   A full-expression is [...] a constant-expression [...]
40c3d6e335900 (Richard Smith            2019-09-19 22:00:16 +0000  5750)   Result =
40c3d6e335900 (Richard Smith            2019-09-19 22:00:16 +0000  5751)       S.ActOnFinishFullExpr(Result.get(), From->getExprLoc(),
40c3d6e335900 (Richard Smith            2019-09-19 22:00:16 +0000  5752)                             /*DiscardedValue=*/false, /*IsConstexpr=*/true);
40c3d6e335900 (Richard Smith            2019-09-19 22:00:16 +0000  5753)   if (Result.isInvalid())
40c3d6e335900 (Richard Smith            2019-09-19 22:00:16 +0000  5754)     return Result;
40c3d6e335900 (Richard Smith            2019-09-19 22:00:16 +0000  5755) 
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5756)   // Check for a narrowing implicit conversion.
c1c1bed5d0828 (Richard Smith            2020-08-19 12:46:52 -0700  5757)   bool ReturnPreNarrowingValue = false;
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5758)   APValue PreNarrowingValue;
5614ca77153b2 (Richard Smith            2012-03-23 23:55:39 +0000  5759)   QualType PreNarrowingType;
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5760)   switch (SCS->getNarrowingKind(S.Context, Result.get(), PreNarrowingValue,
5614ca77153b2 (Richard Smith            2012-03-23 23:55:39 +0000  5761)                                 PreNarrowingType)) {
52e624f3ecbe1 (Richard Smith            2016-12-21 21:42:57 +0000  5762)   case NK_Dependent_Narrowing:
52e624f3ecbe1 (Richard Smith            2016-12-21 21:42:57 +0000  5763)     // Implicit conversion to a narrower type, but the expression is
52e624f3ecbe1 (Richard Smith            2016-12-21 21:42:57 +0000  5764)     // value-dependent so we can't tell whether it's actually narrowing.
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5765)   case NK_Variable_Narrowing:
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5766)     // Implicit conversion to a narrower type, and the value is not a constant
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5767)     // expression. We'll diagnose this in a moment.
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5768)   case NK_Not_Narrowing:
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5769)     break;
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5770) 
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5771)   case NK_Constant_Narrowing:
c1c1bed5d0828 (Richard Smith            2020-08-19 12:46:52 -0700  5772)     if (CCE == Sema::CCEK_ArrayBound &&
c1c1bed5d0828 (Richard Smith            2020-08-19 12:46:52 -0700  5773)         PreNarrowingType->isIntegralOrEnumerationType() &&
c1c1bed5d0828 (Richard Smith            2020-08-19 12:46:52 -0700  5774)         PreNarrowingValue.isInt()) {
c1c1bed5d0828 (Richard Smith            2020-08-19 12:46:52 -0700  5775)       // Don't diagnose array bound narrowing here; we produce more precise
c1c1bed5d0828 (Richard Smith            2020-08-19 12:46:52 -0700  5776)       // errors by allowing the un-narrowed value through.
c1c1bed5d0828 (Richard Smith            2020-08-19 12:46:52 -0700  5777)       ReturnPreNarrowingValue = true;
c1c1bed5d0828 (Richard Smith            2020-08-19 12:46:52 -0700  5778)       break;
c1c1bed5d0828 (Richard Smith            2020-08-19 12:46:52 -0700  5779)     }
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  5780)     S.Diag(From->getBeginLoc(), diag::ext_cce_narrowing)
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  5781)         << CCE << /*Constant*/ 1
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  5782)         << PreNarrowingValue.getAsString(S.Context, PreNarrowingType) << T;
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5783)     break;
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5784) 
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5785)   case NK_Type_Narrowing:
c1c1bed5d0828 (Richard Smith            2020-08-19 12:46:52 -0700  5786)     // FIXME: It would be better to diagnose that the expression is not a
c1c1bed5d0828 (Richard Smith            2020-08-19 12:46:52 -0700  5787)     // constant expression.
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  5788)     S.Diag(From->getBeginLoc(), diag::ext_cce_narrowing)
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  5789)         << CCE << /*Constant*/ 0 << From->getType() << T;
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5790)     break;
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5791)   }
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5792) 
52e624f3ecbe1 (Richard Smith            2016-12-21 21:42:57 +0000  5793)   if (Result.get()->isValueDependent()) {
52e624f3ecbe1 (Richard Smith            2016-12-21 21:42:57 +0000  5794)     Value = APValue();
52e624f3ecbe1 (Richard Smith            2016-12-21 21:42:57 +0000  5795)     return Result;
52e624f3ecbe1 (Richard Smith            2016-12-21 21:42:57 +0000  5796)   }
52e624f3ecbe1 (Richard Smith            2016-12-21 21:42:57 +0000  5797) 
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5798)   // Check the expression is a constant expression.
f857950d391d0 (Dmitri Gribenko          2013-01-12 19:30:44 +0000  5799)   SmallVector<PartialDiagnosticAt, 8> Notes;
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5800)   Expr::EvalResult Eval;
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5801)   Eval.Diag = &Notes;
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5802) 
7b3515880c22c (Richard Smith            2020-10-24 22:08:24 -0700  5803)   ConstantExprKind Kind;
7b3515880c22c (Richard Smith            2020-10-24 22:08:24 -0700  5804)   if (CCE == Sema::CCEK_TemplateArg && T->isRecordType())
7b3515880c22c (Richard Smith            2020-10-24 22:08:24 -0700  5805)     Kind = ConstantExprKind::ClassTemplateArgument;
7b3515880c22c (Richard Smith            2020-10-24 22:08:24 -0700  5806)   else if (CCE == Sema::CCEK_TemplateArg)
7b3515880c22c (Richard Smith            2020-10-24 22:08:24 -0700  5807)     Kind = ConstantExprKind::NonClassTemplateArgument;
7b3515880c22c (Richard Smith            2020-10-24 22:08:24 -0700  5808)   else
7b3515880c22c (Richard Smith            2020-10-24 22:08:24 -0700  5809)     Kind = ConstantExprKind::Normal;
7b3515880c22c (Richard Smith            2020-10-24 22:08:24 -0700  5810) 
7b3515880c22c (Richard Smith            2020-10-24 22:08:24 -0700  5811)   if (!Result.get()->EvaluateAsConstantExpr(Eval, S.Context, Kind) ||
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5812)       (RequireInt && !Eval.Val.isInt())) {
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5813)     // The expression can't be folded, so we can't keep it at this position in
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5814)     // the AST.
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5815)     Result = ExprError();
911e142f034a3 (Richard Smith            2012-01-30 22:27:01 +0000  5816)   } else {
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5817)     Value = Eval.Val;
911e142f034a3 (Richard Smith            2012-01-30 22:27:01 +0000  5818) 
911e142f034a3 (Richard Smith            2012-01-30 22:27:01 +0000  5819)     if (Notes.empty()) {
911e142f034a3 (Richard Smith            2012-01-30 22:27:01 +0000  5820)       // It's a constant expression.
8ba442bc2136c (Hans Wennborg            2021-01-20 15:25:33 +0100  5821)       Expr *E = ConstantExpr::Create(S.Context, Result.get(), Value);
c1c1bed5d0828 (Richard Smith            2020-08-19 12:46:52 -0700  5822)       if (ReturnPreNarrowingValue)
c1c1bed5d0828 (Richard Smith            2020-08-19 12:46:52 -0700  5823)         Value = std::move(PreNarrowingValue);
c1c1bed5d0828 (Richard Smith            2020-08-19 12:46:52 -0700  5824)       return E;
911e142f034a3 (Richard Smith            2012-01-30 22:27:01 +0000  5825)     }
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5826)   }
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5827) 
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5828)   // It's not a constant expression. Produce an appropriate diagnostic.
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5829)   if (Notes.size() == 1 &&
7b3515880c22c (Richard Smith            2020-10-24 22:08:24 -0700  5830)       Notes[0].second.getDiagID() == diag::note_invalid_subexpr_in_const_expr) {
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5831)     S.Diag(Notes[0].first, diag::err_expr_not_cce) << CCE;
7b3515880c22c (Richard Smith            2020-10-24 22:08:24 -0700  5832)   } else if (!Notes.empty() && Notes[0].second.getDiagID() ==
7b3515880c22c (Richard Smith            2020-10-24 22:08:24 -0700  5833)                                    diag::note_constexpr_invalid_template_arg) {
7b3515880c22c (Richard Smith            2020-10-24 22:08:24 -0700  5834)     Notes[0].second.setDiagID(diag::err_constexpr_invalid_template_arg);
7b3515880c22c (Richard Smith            2020-10-24 22:08:24 -0700  5835)     for (unsigned I = 0; I < Notes.size(); ++I)
7b3515880c22c (Richard Smith            2020-10-24 22:08:24 -0700  5836)       S.Diag(Notes[I].first, Notes[I].second);
7b3515880c22c (Richard Smith            2020-10-24 22:08:24 -0700  5837)   } else {
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  5838)     S.Diag(From->getBeginLoc(), diag::err_expr_not_cce)
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  5839)         << CCE << From->getSourceRange();
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5840)     for (unsigned I = 0; I < Notes.size(); ++I)
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5841)       S.Diag(Notes[I].first, Notes[I].second);
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5842)   }
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5843)   return ExprError();
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5844) }
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5845) 
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5846) ExprResult Sema::CheckConvertedConstantExpression(Expr *From, QualType T,
ba4768c966581 (Richard Smith            2020-09-20 23:16:08 -0700  5847)                                                   APValue &Value, CCEKind CCE,
8ba442bc2136c (Hans Wennborg            2021-01-20 15:25:33 +0100  5848)                                                   NamedDecl *Dest) {
ba4768c966581 (Richard Smith            2020-09-20 23:16:08 -0700  5849)   return ::CheckConvertedConstantExpression(*this, From, T, Value, CCE, false,
8ba442bc2136c (Hans Wennborg            2021-01-20 15:25:33 +0100  5850)                                             Dest);
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5851) }
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5852) 
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5853) ExprResult Sema::CheckConvertedConstantExpression(Expr *From, QualType T,
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5854)                                                   llvm::APSInt &Value,
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5855)                                                   CCEKind CCE) {
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5856)   assert(T->isIntegralOrEnumerationType() && "unexpected converted const type");
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5857) 
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5858)   APValue V;
ba4768c966581 (Richard Smith            2020-09-20 23:16:08 -0700  5859)   auto R = ::CheckConvertedConstantExpression(*this, From, T, V, CCE, true,
8ba442bc2136c (Hans Wennborg            2021-01-20 15:25:33 +0100  5860)                                               /*Dest=*/nullptr);
01bfa68fecaf5 (Richard Smith            2016-12-27 02:02:09 +0000  5861)   if (!R.isInvalid() && !R.get()->isValueDependent())
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5862)     Value = V.getInt();
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5863)   return R;
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5864) }
f8379a0fc3592 (Richard Smith            2012-01-18 23:55:52 +0000  5865) 
410cc893745ee (Richard Smith            2014-11-26 03:26:53 +0000  5866) 
fec112d50e801 (John McCall              2011-09-09 06:11:02 +0000  5867) /// dropPointerConversions - If the given standard conversion sequence
fec112d50e801 (John McCall              2011-09-09 06:11:02 +0000  5868) /// involves any pointer conversions, remove them.  This may change
fec112d50e801 (John McCall              2011-09-09 06:11:02 +0000  5869) /// the result type of the conversion sequence.
fec112d50e801 (John McCall              2011-09-09 06:11:02 +0000  5870) static void dropPointerConversion(StandardConversionSequence &SCS) {
fec112d50e801 (John McCall              2011-09-09 06:11:02 +0000  5871)   if (SCS.Second == ICK_Pointer_Conversion) {
fec112d50e801 (John McCall              2011-09-09 06:11:02 +0000  5872)     SCS.Second = ICK_Identity;
fec112d50e801 (John McCall              2011-09-09 06:11:02 +0000  5873)     SCS.Third = ICK_Identity;
fec112d50e801 (John McCall              2011-09-09 06:11:02 +0000  5874)     SCS.ToTypePtrs[2] = SCS.ToTypePtrs[1] = SCS.ToTypePtrs[0];
fec112d50e801 (John McCall              2011-09-09 06:11:02 +0000  5875)   }
fec112d50e801 (John McCall              2011-09-09 06:11:02 +0000  5876) }
fec112d50e801 (John McCall              2011-09-09 06:11:02 +0000  5877) 
fec112d50e801 (John McCall              2011-09-09 06:11:02 +0000  5878) /// TryContextuallyConvertToObjCPointer - Attempt to contextually
fec112d50e801 (John McCall              2011-09-09 06:11:02 +0000  5879) /// convert the expression From to an Objective-C pointer type.
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  5880) static ImplicitConversionSequence
fec112d50e801 (John McCall              2011-09-09 06:11:02 +0000  5881) TryContextuallyConvertToObjCPointer(Sema &S, Expr *From) {
fec112d50e801 (John McCall              2011-09-09 06:11:02 +0000  5882)   // Do an implicit conversion to 'id'.
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  5883)   QualType Ty = S.Context.getObjCIdType();
fec112d50e801 (John McCall              2011-09-09 06:11:02 +0000  5884)   ImplicitConversionSequence ICS
fec112d50e801 (John McCall              2011-09-09 06:11:02 +0000  5885)     = TryImplicitConversion(S, From, Ty,
fec112d50e801 (John McCall              2011-09-09 06:11:02 +0000  5886)                             // FIXME: Are these flags correct?
fec112d50e801 (John McCall              2011-09-09 06:11:02 +0000  5887)                             /*SuppressUserConversions=*/false,
d28763cad06e6 (Richard Smith            2020-01-29 12:07:14 -0800  5888)                             AllowedExplicit::Conversions,
fec112d50e801 (John McCall              2011-09-09 06:11:02 +0000  5889)                             /*InOverloadResolution=*/false,
fec112d50e801 (John McCall              2011-09-09 06:11:02 +0000  5890)                             /*CStyle=*/false,
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  5891)                             /*AllowObjCWritebackConversion=*/false,
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  5892)                             /*AllowObjCConversionOnExplicit=*/true);
fec112d50e801 (John McCall              2011-09-09 06:11:02 +0000  5893) 
fec112d50e801 (John McCall              2011-09-09 06:11:02 +0000  5894)   // Strip off any final conversions to 'id'.
fec112d50e801 (John McCall              2011-09-09 06:11:02 +0000  5895)   switch (ICS.getKind()) {
fec112d50e801 (John McCall              2011-09-09 06:11:02 +0000  5896)   case ImplicitConversionSequence::BadConversion:
fec112d50e801 (John McCall              2011-09-09 06:11:02 +0000  5897)   case ImplicitConversionSequence::AmbiguousConversion:
fec112d50e801 (John McCall              2011-09-09 06:11:02 +0000  5898)   case ImplicitConversionSequence::EllipsisConversion:
fec112d50e801 (John McCall              2011-09-09 06:11:02 +0000  5899)     break;
fec112d50e801 (John McCall              2011-09-09 06:11:02 +0000  5900) 
fec112d50e801 (John McCall              2011-09-09 06:11:02 +0000  5901)   case ImplicitConversionSequence::UserDefinedConversion:
fec112d50e801 (John McCall              2011-09-09 06:11:02 +0000  5902)     dropPointerConversion(ICS.UserDefined.After);
fec112d50e801 (John McCall              2011-09-09 06:11:02 +0000  5903)     break;
fec112d50e801 (John McCall              2011-09-09 06:11:02 +0000  5904) 
fec112d50e801 (John McCall              2011-09-09 06:11:02 +0000  5905)   case ImplicitConversionSequence::StandardConversion:
fec112d50e801 (John McCall              2011-09-09 06:11:02 +0000  5906)     dropPointerConversion(ICS.Standard);
fec112d50e801 (John McCall              2011-09-09 06:11:02 +0000  5907)     break;
fec112d50e801 (John McCall              2011-09-09 06:11:02 +0000  5908)   }
fec112d50e801 (John McCall              2011-09-09 06:11:02 +0000  5909) 
fec112d50e801 (John McCall              2011-09-09 06:11:02 +0000  5910)   return ICS;
cac49a8f8a11d (Fariborz Jahanian        2010-05-12 23:29:11 +0000  5911) }
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  5912) 
fec112d50e801 (John McCall              2011-09-09 06:11:02 +0000  5913) /// PerformContextuallyConvertToObjCPointer - Perform a contextual
fec112d50e801 (John McCall              2011-09-09 06:11:02 +0000  5914) /// conversion of the expression From to an Objective-C pointer type.
e15a370084f37 (Richard Smith            2016-10-06 23:12:58 +0000  5915) /// Returns a valid but null ExprResult if no conversion sequence exists.
fec112d50e801 (John McCall              2011-09-09 06:11:02 +0000  5916) ExprResult Sema::PerformContextuallyConvertToObjCPointer(Expr *From) {
526ab47a55734 (John McCall              2011-10-25 17:37:35 +0000  5917)   if (checkPlaceholderForOverload(*this, From))
526ab47a55734 (John McCall              2011-10-25 17:37:35 +0000  5918)     return ExprError();
526ab47a55734 (John McCall              2011-10-25 17:37:35 +0000  5919) 
8b07ec253d404 (John McCall              2010-05-15 11:32:37 +0000  5920)   QualType Ty = Context.getObjCIdType();
fec112d50e801 (John McCall              2011-09-09 06:11:02 +0000  5921)   ImplicitConversionSequence ICS =
fec112d50e801 (John McCall              2011-09-09 06:11:02 +0000  5922)     TryContextuallyConvertToObjCPointer(*this, From);
cac49a8f8a11d (Fariborz Jahanian        2010-05-12 23:29:11 +0000  5923)   if (!ICS.isBad())
cac49a8f8a11d (Fariborz Jahanian        2010-05-12 23:29:11 +0000  5924)     return PerformImplicitConversion(From, Ty, ICS, AA_Converting);
e15a370084f37 (Richard Smith            2016-10-06 23:12:58 +0000  5925)   return ExprResult();
cac49a8f8a11d (Fariborz Jahanian        2010-05-12 23:29:11 +0000  5926) }
5fb53972380f5 (Douglas Gregor           2009-01-14 15:45:31 +0000  5927) 
8dd3425077ba7 (Richard Smith            2012-02-04 07:07:42 +0000  5928) /// Determine whether the provided type is an integral type, or an enumeration
8dd3425077ba7 (Richard Smith            2012-02-04 07:07:42 +0000  5929) /// type of a permitted flavor.
ccc11811052db (Richard Smith            2013-05-21 19:05:48 +0000  5930) bool Sema::ICEConvertDiagnoser::match(QualType T) {
ccc11811052db (Richard Smith            2013-05-21 19:05:48 +0000  5931)   return AllowScopedEnumerations ? T->isIntegralOrEnumerationType()
ccc11811052db (Richard Smith            2013-05-21 19:05:48 +0000  5932)                                  : T->isIntegralOrUnscopedEnumerationType();
8dd3425077ba7 (Richard Smith            2012-02-04 07:07:42 +0000  5933) }
8dd3425077ba7 (Richard Smith            2012-02-04 07:07:42 +0000  5934) 
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5935) static ExprResult
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5936) diagnoseAmbiguousConversion(Sema &SemaRef, SourceLocation Loc, Expr *From,
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5937)                             Sema::ContextualImplicitConverter &Converter,
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5938)                             QualType T, UnresolvedSetImpl &ViableConversions) {
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5939) 
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5940)   if (Converter.Suppress)
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5941)     return ExprError();
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5942) 
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5943)   Converter.diagnoseAmbiguous(SemaRef, Loc, T) << From->getSourceRange();
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5944)   for (unsigned I = 0, N = ViableConversions.size(); I != N; ++I) {
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5945)     CXXConversionDecl *Conv =
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5946)         cast<CXXConversionDecl>(ViableConversions[I]->getUnderlyingDecl());
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5947)     QualType ConvTy = Conv->getConversionType().getNonReferenceType();
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5948)     Converter.noteAmbiguous(SemaRef, Conv, ConvTy);
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5949)   }
03ff2596cb161 (Nikola Smiljanic         2014-05-29 14:05:12 +0000  5950)   return From;
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5951) }
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5952) 
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5953) static bool
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5954) diagnoseNoViableConversion(Sema &SemaRef, SourceLocation Loc, Expr *&From,
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5955)                            Sema::ContextualImplicitConverter &Converter,
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5956)                            QualType T, bool HadMultipleCandidates,
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5957)                            UnresolvedSetImpl &ExplicitConversions) {
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5958)   if (ExplicitConversions.size() == 1 && !Converter.Suppress) {
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5959)     DeclAccessPair Found = ExplicitConversions[0];
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5960)     CXXConversionDecl *Conversion =
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5961)         cast<CXXConversionDecl>(Found->getUnderlyingDecl());
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5962) 
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5963)     // The user probably meant to invoke the given explicit
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5964)     // conversion; use it.
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5965)     QualType ConvTy = Conversion->getConversionType().getNonReferenceType();
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5966)     std::string TypeStr;
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5967)     ConvTy.getAsStringInternal(TypeStr, SemaRef.getPrintingPolicy());
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5968) 
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5969)     Converter.diagnoseExplicitConv(SemaRef, Loc, T, ConvTy)
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  5970)         << FixItHint::CreateInsertion(From->getBeginLoc(),
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5971)                                       "static_cast<" + TypeStr + ">(")
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5972)         << FixItHint::CreateInsertion(
1c301dcbc4e59 (Stephen Kelly            2018-08-09 21:09:38 +0000  5973)                SemaRef.getLocForEndOfToken(From->getEndLoc()), ")");
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5974)     Converter.noteExplicitConv(SemaRef, Conversion, ConvTy);
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5975) 
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5976)     // If we aren't in a SFINAE context, build a call to the
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5977)     // explicit conversion function.
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5978)     if (SemaRef.isSFINAEContext())
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5979)       return true;
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5980) 
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000  5981)     SemaRef.CheckMemberOperatorAccess(From->getExprLoc(), From, nullptr, Found);
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5982)     ExprResult Result = SemaRef.BuildCXXMemberCallExpr(From, Found, Conversion,
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5983)                                                        HadMultipleCandidates);
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5984)     if (Result.isInvalid())
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5985)       return true;
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5986)     // Record usage of conversion in an implicit cast.
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5987)     From = ImplicitCastExpr::Create(SemaRef.Context, Result.get()->getType(),
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000  5988)                                     CK_UserDefinedConversion, Result.get(),
f1cd6593da3ad (Serge Pavlov             2020-09-12 21:54:14 +0700  5989)                                     nullptr, Result.get()->getValueKind(),
f1cd6593da3ad (Serge Pavlov             2020-09-12 21:54:14 +0700  5990)                                     SemaRef.CurFPFeatureOverrides());
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5991)   }
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5992)   return false;
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5993) }
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5994) 
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5995) static bool recordConversion(Sema &SemaRef, SourceLocation Loc, Expr *&From,
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5996)                              Sema::ContextualImplicitConverter &Converter,
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5997)                              QualType T, bool HadMultipleCandidates,
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5998)                              DeclAccessPair &Found) {
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  5999)   CXXConversionDecl *Conversion =
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6000)       cast<CXXConversionDecl>(Found->getUnderlyingDecl());
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000  6001)   SemaRef.CheckMemberOperatorAccess(From->getExprLoc(), From, nullptr, Found);
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6002) 
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6003)   QualType ToType = Conversion->getConversionType().getNonReferenceType();
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6004)   if (!Converter.SuppressConversion) {
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6005)     if (SemaRef.isSFINAEContext())
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6006)       return true;
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6007) 
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6008)     Converter.diagnoseConversion(SemaRef, Loc, T, ToType)
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6009)         << From->getSourceRange();
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6010)   }
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6011) 
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6012)   ExprResult Result = SemaRef.BuildCXXMemberCallExpr(From, Found, Conversion,
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6013)                                                      HadMultipleCandidates);
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6014)   if (Result.isInvalid())
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6015)     return true;
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6016)   // Record usage of conversion in an implicit cast.
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6017)   From = ImplicitCastExpr::Create(SemaRef.Context, Result.get()->getType(),
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000  6018)                                   CK_UserDefinedConversion, Result.get(),
f1cd6593da3ad (Serge Pavlov             2020-09-12 21:54:14 +0700  6019)                                   nullptr, Result.get()->getValueKind(),
f1cd6593da3ad (Serge Pavlov             2020-09-12 21:54:14 +0700  6020)                                   SemaRef.CurFPFeatureOverrides());
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6021)   return false;
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6022) }
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6023) 
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6024) static ExprResult finishContextualImplicitConversion(
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6025)     Sema &SemaRef, SourceLocation Loc, Expr *From,
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6026)     Sema::ContextualImplicitConverter &Converter) {
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6027)   if (!Converter.match(From->getType()) && !Converter.Suppress)
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6028)     Converter.diagnoseNoMatch(SemaRef, Loc, From->getType())
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6029)         << From->getSourceRange();
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6030) 
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6031)   return SemaRef.DefaultLvalueConversion(From);
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6032) }
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6033) 
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6034) static void
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6035) collectViableConversionCandidates(Sema &SemaRef, Expr *From, QualType ToType,
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6036)                                   UnresolvedSetImpl &ViableConversions,
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6037)                                   OverloadCandidateSet &CandidateSet) {
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6038)   for (unsigned I = 0, N = ViableConversions.size(); I != N; ++I) {
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6039)     DeclAccessPair FoundDecl = ViableConversions[I];
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6040)     NamedDecl *D = FoundDecl.getDecl();
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6041)     CXXRecordDecl *ActingContext = cast<CXXRecordDecl>(D->getDeclContext());
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6042)     if (isa<UsingShadowDecl>(D))
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6043)       D = cast<UsingShadowDecl>(D)->getTargetDecl();
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6044) 
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6045)     CXXConversionDecl *Conv;
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6046)     FunctionTemplateDecl *ConvTemplate;
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6047)     if ((ConvTemplate = dyn_cast<FunctionTemplateDecl>(D)))
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6048)       Conv = cast<CXXConversionDecl>(ConvTemplate->getTemplatedDecl());
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6049)     else
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6050)       Conv = cast<CXXConversionDecl>(D);
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6051) 
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6052)     if (ConvTemplate)
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6053)       SemaRef.AddTemplateConversionCandidate(
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000  6054)           ConvTemplate, FoundDecl, ActingContext, From, ToType, CandidateSet,
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000  6055)           /*AllowObjCConversionOnExplicit=*/false, /*AllowExplicit*/ true);
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6056)     else
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6057)       SemaRef.AddConversionCandidate(Conv, FoundDecl, ActingContext, From,
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  6058)                                      ToType, CandidateSet,
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000  6059)                                      /*AllowObjCConversionOnExplicit=*/false,
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000  6060)                                      /*AllowExplicit*/ true);
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6061)   }
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6062) }
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6063) 
9fc8faf9e6197 (Adrian Prantl            2018-05-09 01:00:01 +0000  6064) /// Attempt to convert the given expression to a type which is accepted
ccc11811052db (Richard Smith            2013-05-21 19:05:48 +0000  6065) /// by the given converter.
f4ea725d38cc5 (Douglas Gregor           2010-06-29 23:17:37 +0000  6066) ///
ccc11811052db (Richard Smith            2013-05-21 19:05:48 +0000  6067) /// This routine will attempt to convert an expression of class type to a
ccc11811052db (Richard Smith            2013-05-21 19:05:48 +0000  6068) /// type accepted by the specified converter. In C++11 and before, the class
ccc11811052db (Richard Smith            2013-05-21 19:05:48 +0000  6069) /// must have a single non-explicit conversion function converting to a matching
ccc11811052db (Richard Smith            2013-05-21 19:05:48 +0000  6070) /// type. In C++1y, there can be multiple such conversion functions, but only
ccc11811052db (Richard Smith            2013-05-21 19:05:48 +0000  6071) /// one target type.
f4ea725d38cc5 (Douglas Gregor           2010-06-29 23:17:37 +0000  6072) ///
4799d03ce8411 (Douglas Gregor           2010-06-30 00:20:43 +0000  6073) /// \param Loc The source location of the construct that requires the
4799d03ce8411 (Douglas Gregor           2010-06-30 00:20:43 +0000  6074) /// conversion.
4799d03ce8411 (Douglas Gregor           2010-06-30 00:20:43 +0000  6075) ///
18348b6218e4c (James Dennett            2012-06-22 08:52:37 +0000  6076) /// \param From The expression we're converting from.
4799d03ce8411 (Douglas Gregor           2010-06-30 00:20:43 +0000  6077) ///
ccc11811052db (Richard Smith            2013-05-21 19:05:48 +0000  6078) /// \param Converter Used to control and diagnose the conversion process.
8dd3425077ba7 (Richard Smith            2012-02-04 07:07:42 +0000  6079) ///
4799d03ce8411 (Douglas Gregor           2010-06-30 00:20:43 +0000  6080) /// \returns The expression, converted to an integral or enumeration type if
4799d03ce8411 (Douglas Gregor           2010-06-30 00:20:43 +0000  6081) /// successful.
ccc11811052db (Richard Smith            2013-05-21 19:05:48 +0000  6082) ExprResult Sema::PerformContextualImplicitConversion(
ccc11811052db (Richard Smith            2013-05-21 19:05:48 +0000  6083)     SourceLocation Loc, Expr *From, ContextualImplicitConverter &Converter) {
f4ea725d38cc5 (Douglas Gregor           2010-06-29 23:17:37 +0000  6084)   // We can't perform any more checking for type-dependent expressions.
f4ea725d38cc5 (Douglas Gregor           2010-06-29 23:17:37 +0000  6085)   if (From->isTypeDependent())
03ff2596cb161 (Nikola Smiljanic         2014-05-29 14:05:12 +0000  6086)     return From;
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  6087) 
1da70394f68a5 (Eli Friedman             2012-01-26 00:26:18 +0000  6088)   // Process placeholders immediately.
1da70394f68a5 (Eli Friedman             2012-01-26 00:26:18 +0000  6089)   if (From->hasPlaceholderType()) {
1da70394f68a5 (Eli Friedman             2012-01-26 00:26:18 +0000  6090)     ExprResult result = CheckPlaceholderExpr(From);
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6091)     if (result.isInvalid())
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6092)       return result;
01a7598561561 (Nikola Smiljanic         2014-05-29 10:55:11 +0000  6093)     From = result.get();
1da70394f68a5 (Eli Friedman             2012-01-26 00:26:18 +0000  6094)   }
1da70394f68a5 (Eli Friedman             2012-01-26 00:26:18 +0000  6095) 
ccc11811052db (Richard Smith            2013-05-21 19:05:48 +0000  6096)   // If the expression already has a matching type, we're golden.
f4ea725d38cc5 (Douglas Gregor           2010-06-29 23:17:37 +0000  6097)   QualType T = From->getType();
ccc11811052db (Richard Smith            2013-05-21 19:05:48 +0000  6098)   if (Converter.match(T))
1da70394f68a5 (Eli Friedman             2012-01-26 00:26:18 +0000  6099)     return DefaultLvalueConversion(From);
f4ea725d38cc5 (Douglas Gregor           2010-06-29 23:17:37 +0000  6100) 
f4ea725d38cc5 (Douglas Gregor           2010-06-29 23:17:37 +0000  6101)   // FIXME: Check for missing '()' if T is a function type?
f4ea725d38cc5 (Douglas Gregor           2010-06-29 23:17:37 +0000  6102) 
ccc11811052db (Richard Smith            2013-05-21 19:05:48 +0000  6103)   // We can only perform contextual implicit conversions on objects of class
ccc11811052db (Richard Smith            2013-05-21 19:05:48 +0000  6104)   // type.
f4ea725d38cc5 (Douglas Gregor           2010-06-29 23:17:37 +0000  6105)   const RecordType *RecordTy = T->getAs<RecordType>();
bbafb8a745736 (David Blaikie            2012-03-11 07:00:24 +0000  6106)   if (!RecordTy || !getLangOpts().CPlusPlus) {
ccc11811052db (Richard Smith            2013-05-21 19:05:48 +0000  6107)     if (!Converter.Suppress)
ccc11811052db (Richard Smith            2013-05-21 19:05:48 +0000  6108)       Converter.diagnoseNoMatch(*this, Loc, T) << From->getSourceRange();
03ff2596cb161 (Nikola Smiljanic         2014-05-29 14:05:12 +0000  6109)     return From;
f4ea725d38cc5 (Douglas Gregor           2010-06-29 23:17:37 +0000  6110)   }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  6111) 
f4ea725d38cc5 (Douglas Gregor           2010-06-29 23:17:37 +0000  6112)   // We must have a complete class type.
a6c5abb754044 (Douglas Gregor           2012-05-04 16:48:41 +0000  6113)   struct TypeDiagnoserPartialDiag : TypeDiagnoser {
ccc11811052db (Richard Smith            2013-05-21 19:05:48 +0000  6114)     ContextualImplicitConverter &Converter;
e2b3744890f63 (Douglas Gregor           2012-05-04 22:38:52 +0000  6115)     Expr *From;
ccc11811052db (Richard Smith            2013-05-21 19:05:48 +0000  6116) 
ccc11811052db (Richard Smith            2013-05-21 19:05:48 +0000  6117)     TypeDiagnoserPartialDiag(ContextualImplicitConverter &Converter, Expr *From)
db0ac5572fcf7 (Richard Smith            2015-12-18 22:40:25 +0000  6118)         : Converter(Converter), From(From) {}
ccc11811052db (Richard Smith            2013-05-21 19:05:48 +0000  6119) 
e14c0f8e733e0 (Craig Topper             2014-03-12 04:55:44 +0000  6120)     void diagnose(Sema &S, SourceLocation Loc, QualType T) override {
ccc11811052db (Richard Smith            2013-05-21 19:05:48 +0000  6121)       Converter.diagnoseIncomplete(S, Loc, T) << From->getSourceRange();
7bfb2d026ec99 (Douglas Gregor           2012-05-04 16:32:21 +0000  6122)     }
ccc11811052db (Richard Smith            2013-05-21 19:05:48 +0000  6123)   } IncompleteDiagnoser(Converter, From);
7bfb2d026ec99 (Douglas Gregor           2012-05-04 16:32:21 +0000  6124) 
db0ac5572fcf7 (Richard Smith            2015-12-18 22:40:25 +0000  6125)   if (Converter.Suppress ? !isCompleteType(Loc, T)
db0ac5572fcf7 (Richard Smith            2015-12-18 22:40:25 +0000  6126)                          : RequireCompleteType(Loc, T, IncompleteDiagnoser))
03ff2596cb161 (Nikola Smiljanic         2014-05-29 14:05:12 +0000  6127)     return From;
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  6128) 
f4ea725d38cc5 (Douglas Gregor           2010-06-29 23:17:37 +0000  6129)   // Look for a conversion to an integral or enumeration type.
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6130)   UnresolvedSet<4>
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6131)       ViableConversions; // These are *potentially* viable in C++1y.
f4ea725d38cc5 (Douglas Gregor           2010-06-29 23:17:37 +0000  6132)   UnresolvedSet<4> ExplicitConversions;
b4ef66832dee0 (Benjamin Kramer          2015-02-06 17:25:10 +0000  6133)   const auto &Conversions =
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6134)       cast<CXXRecordDecl>(RecordTy->getDecl())->getVisibleConversionFunctions();
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6135) 
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6136)   bool HadMultipleCandidates =
b4ef66832dee0 (Benjamin Kramer          2015-02-06 17:25:10 +0000  6137)       (std::distance(Conversions.begin(), Conversions.end()) > 1);
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6138) 
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6139)   // To check that there is only one target type, in C++1y:
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6140)   QualType ToType;
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6141)   bool HasUniqueTargetType = true;
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6142) 
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6143)   // Collect explicit or viable (potentially in C++1y) conversions.
b4ef66832dee0 (Benjamin Kramer          2015-02-06 17:25:10 +0000  6144)   for (auto I = Conversions.begin(), E = Conversions.end(); I != E; ++I) {
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6145)     NamedDecl *D = (*I)->getUnderlyingDecl();
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6146)     CXXConversionDecl *Conversion;
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6147)     FunctionTemplateDecl *ConvTemplate = dyn_cast<FunctionTemplateDecl>(D);
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6148)     if (ConvTemplate) {
dd69ef38dba72 (Aaron Ballman            2014-08-19 15:55:55 +0000  6149)       if (getLangOpts().CPlusPlus14)
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6150)         Conversion = cast<CXXConversionDecl>(ConvTemplate->getTemplatedDecl());
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6151)       else
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6152)         continue; // C++11 does not consider conversion operator templates(?).
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6153)     } else
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6154)       Conversion = cast<CXXConversionDecl>(D);
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  6155) 
dd69ef38dba72 (Aaron Ballman            2014-08-19 15:55:55 +0000  6156)     assert((!ConvTemplate || getLangOpts().CPlusPlus14) &&
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6157)            "Conversion operator templates are considered potentially "
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6158)            "viable in C++1y");
635ed24e1dad8 (Abramo Bagnara           2011-10-05 07:56:41 +0000  6159) 
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6160)     QualType CurToType = Conversion->getConversionType().getNonReferenceType();
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6161)     if (Converter.match(CurToType) || ConvTemplate) {
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6162) 
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6163)       if (Conversion->isExplicit()) {
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6164)         // FIXME: For C++1y, do we need this restriction?
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6165)         // cf. diagnoseNoViableConversion()
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6166)         if (!ConvTemplate)
f4ea725d38cc5 (Douglas Gregor           2010-06-29 23:17:37 +0000  6167)           ExplicitConversions.addDecl(I.getDecl(), I.getAccess());
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6168)       } else {
dd69ef38dba72 (Aaron Ballman            2014-08-19 15:55:55 +0000  6169)         if (!ConvTemplate && getLangOpts().CPlusPlus14) {
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6170)           if (ToType.isNull())
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6171)             ToType = CurToType.getUnqualifiedType();
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6172)           else if (HasUniqueTargetType &&
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6173)                    (CurToType.getUnqualifiedType() != ToType))
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6174)             HasUniqueTargetType = false;
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6175)         }
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6176)         ViableConversions.addDecl(I.getDecl(), I.getAccess());
f4ea725d38cc5 (Douglas Gregor           2010-06-29 23:17:37 +0000  6177)       }
8dd3425077ba7 (Richard Smith            2012-02-04 07:07:42 +0000  6178)     }
f4ea725d38cc5 (Douglas Gregor           2010-06-29 23:17:37 +0000  6179)   }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  6180) 
dd69ef38dba72 (Aaron Ballman            2014-08-19 15:55:55 +0000  6181)   if (getLangOpts().CPlusPlus14) {
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6182)     // C++1y [conv]p6:
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6183)     // ... An expression e of class type E appearing in such a context
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6184)     // is said to be contextually implicitly converted to a specified
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6185)     // type T and is well-formed if and only if e can be implicitly
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6186)     // converted to a type T that is determined as follows: E is searched
67170bd71ace5 (Larisse Voufo            2013-06-10 08:25:58 +0000  6187)     // for conversion functions whose return type is cv T or reference to
67170bd71ace5 (Larisse Voufo            2013-06-10 08:25:58 +0000  6188)     // cv T such that T is allowed by the context. There shall be
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6189)     // exactly one such T.
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6190) 
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6191)     // If no unique T is found:
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6192)     if (ToType.isNull()) {
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6193)       if (diagnoseNoViableConversion(*this, Loc, From, Converter, T,
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6194)                                      HadMultipleCandidates,
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6195)                                      ExplicitConversions))
f4ea725d38cc5 (Douglas Gregor           2010-06-29 23:17:37 +0000  6196)         return ExprError();
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6197)       return finishContextualImplicitConversion(*this, Loc, From, Converter);
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6198)     }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  6199) 
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6200)     // If more than one unique Ts are found:
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6201)     if (!HasUniqueTargetType)
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6202)       return diagnoseAmbiguousConversion(*this, Loc, From, Converter, T,
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6203)                                          ViableConversions);
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6204) 
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6205)     // If one unique T is found:
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6206)     // First, build a candidate set from the previously recorded
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6207)     // potentially viable conversions.
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000  6208)     OverloadCandidateSet CandidateSet(Loc, OverloadCandidateSet::CSK_Normal);
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6209)     collectViableConversionCandidates(*this, From, ToType, ViableConversions,
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6210)                                       CandidateSet);
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6211) 
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6212)     // Then, perform overload resolution over the candidate set.
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6213)     OverloadCandidateSet::iterator Best;
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6214)     switch (CandidateSet.BestViableFunction(*this, Loc, Best)) {
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6215)     case OR_Success: {
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6216)       // Apply this conversion.
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6217)       DeclAccessPair Found =
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6218)           DeclAccessPair::make(Best->Function, Best->FoundDecl.getAccess());
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6219)       if (recordConversion(*this, Loc, From, Converter, T,
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6220)                            HadMultipleCandidates, Found))
668443efb1db5 (Douglas Gregor           2011-01-20 00:18:04 +0000  6221)         return ExprError();
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6222)       break;
f4ea725d38cc5 (Douglas Gregor           2010-06-29 23:17:37 +0000  6223)     }
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6224)     case OR_Ambiguous:
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6225)       return diagnoseAmbiguousConversion(*this, Loc, From, Converter, T,
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6226)                                          ViableConversions);
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6227)     case OR_No_Viable_Function:
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6228)       if (diagnoseNoViableConversion(*this, Loc, From, Converter, T,
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6229)                                      HadMultipleCandidates,
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6230)                                      ExplicitConversions))
4799d03ce8411 (Douglas Gregor           2010-06-30 00:20:43 +0000  6231)         return ExprError();
f3b3ccda590c1 (Adrian Prantl            2017-12-19 22:06:11 +0000  6232)       LLVM_FALLTHROUGH;
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6233)     case OR_Deleted:
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6234)       // We'll complain below about a non-integral condition type.
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6235)       break;
4799d03ce8411 (Douglas Gregor           2010-06-30 00:20:43 +0000  6236)     }
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6237)   } else {
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6238)     switch (ViableConversions.size()) {
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6239)     case 0: {
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6240)       if (diagnoseNoViableConversion(*this, Loc, From, Converter, T,
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6241)                                      HadMultipleCandidates,
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6242)                                      ExplicitConversions))
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6243)         return ExprError();
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  6244) 
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6245)       // We'll complain below about a non-integral condition type.
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6246)       break;
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6247)     }
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6248)     case 1: {
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6249)       // Apply this conversion.
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6250)       DeclAccessPair Found = ViableConversions[0];
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6251)       if (recordConversion(*this, Loc, From, Converter, T,
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6252)                            HadMultipleCandidates, Found))
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6253)         return ExprError();
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6254)       break;
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6255)     }
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6256)     default:
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6257)       return diagnoseAmbiguousConversion(*this, Loc, From, Converter, T,
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6258)                                          ViableConversions);
f4ea725d38cc5 (Douglas Gregor           2010-06-29 23:17:37 +0000  6259)     }
f4ea725d38cc5 (Douglas Gregor           2010-06-29 23:17:37 +0000  6260)   }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  6261) 
236bec24ec195 (Larisse Voufo            2013-06-10 06:50:24 +0000  6262)   return finishContextualImplicitConversion(*this, Loc, From, Converter);
f4ea725d38cc5 (Douglas Gregor           2010-06-29 23:17:37 +0000  6263) }
f4ea725d38cc5 (Douglas Gregor           2010-06-29 23:17:37 +0000  6264) 
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000  6265) /// IsAcceptableNonMemberOperatorCandidate - Determine whether Fn is
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000  6266) /// an acceptable non-member overloaded operator for a call whose
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000  6267) /// arguments have types T1 (and, if non-empty, T2). This routine
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000  6268) /// implements the check in C++ [over.match.oper]p3b2 concerning
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000  6269) /// enumeration types.
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000  6270) static bool IsAcceptableNonMemberOperatorCandidate(ASTContext &Context,
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000  6271)                                                    FunctionDecl *Fn,
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000  6272)                                                    ArrayRef<Expr *> Args) {
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000  6273)   QualType T1 = Args[0]->getType();
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000  6274)   QualType T2 = Args.size() > 1 ? Args[1]->getType() : QualType();
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000  6275) 
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000  6276)   if (T1->isDependentType() || (!T2.isNull() && T2->isDependentType()))
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000  6277)     return true;
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000  6278) 
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000  6279)   if (T1->isRecordType() || (!T2.isNull() && T2->isRecordType()))
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000  6280)     return true;
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000  6281) 
ab9dbc1d124cd (Simon Pilgrim            2020-01-14 14:15:51 +0000  6282)   const auto *Proto = Fn->getType()->castAs<FunctionProtoType>();
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000  6283)   if (Proto->getNumParams() < 1)
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000  6284)     return false;
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000  6285) 
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000  6286)   if (T1->isEnumeralType()) {
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000  6287)     QualType ArgType = Proto->getParamType(0).getNonReferenceType();
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000  6288)     if (Context.hasSameUnqualifiedType(T1, ArgType))
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000  6289)       return true;
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000  6290)   }
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000  6291) 
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000  6292)   if (Proto->getNumParams() < 2)
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000  6293)     return false;
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000  6294) 
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000  6295)   if (!T2.isNull() && T2->isEnumeralType()) {
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000  6296)     QualType ArgType = Proto->getParamType(1).getNonReferenceType();
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000  6297)     if (Context.hasSameUnqualifiedType(T2, ArgType))
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000  6298)       return true;
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000  6299)   }
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000  6300) 
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000  6301)   return false;
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000  6302) }
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000  6303) 
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  6304) /// AddOverloadCandidate - Adds the given function to the set of
2fe9883a961df (Douglas Gregor           2008-11-03 19:09:14 +0000  6305) /// candidate functions, using the given function call arguments.  If
2fe9883a961df (Douglas Gregor           2008-11-03 19:09:14 +0000  6306) /// @p SuppressUserConversions, then don't allow user-defined
2fe9883a961df (Douglas Gregor           2008-11-03 19:09:14 +0000  6307) /// conversions via constructors or conversion operators.
cabea40ea3c9b (Douglas Gregor           2009-09-22 15:41:20 +0000  6308) ///
2a4d13c5cf5e9 (James Dennett            2012-06-15 07:13:21 +0000  6309) /// \param PartialOverloading true if we are performing "partial" overloading
cabea40ea3c9b (Douglas Gregor           2009-09-22 15:41:20 +0000  6310) /// based on an incomplete set of function arguments. This feature is used by
cabea40ea3c9b (Douglas Gregor           2009-09-22 15:41:20 +0000  6311) /// code completion.
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000  6312) void Sema::AddOverloadCandidate(
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000  6313)     FunctionDecl *Function, DeclAccessPair FoundDecl, ArrayRef<Expr *> Args,
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000  6314)     OverloadCandidateSet &CandidateSet, bool SuppressUserConversions,
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000  6315)     bool PartialOverloading, bool AllowExplicit, bool AllowExplicitConversions,
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  6316)     ADLCallKind IsADLCandidate, ConversionSequenceList EarlyConversions,
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  6317)     OverloadCandidateParamOrder PO) {
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  6318)   const FunctionProtoType *Proto
9dd450bb78148 (John McCall              2009-09-21 23:43:11 +0000  6319)     = dyn_cast<FunctionProtoType>(Function->getType()->getAs<FunctionType>());
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  6320)   assert(Proto && "Functions without a prototype cannot be overloaded");
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  6321)   assert(!Function->getDescribedFunctionTemplate() &&
7c2888689dfdd (NAKAMURA Takumi          2011-01-27 07:09:49 +0000  6322)          "Use AddTemplateOverloadCandidate for function templates");
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  6323) 
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000  6324)   if (CXXMethodDecl *Method = dyn_cast<CXXMethodDecl>(Function)) {
1a99f441e64c8 (Sebastian Redl           2009-04-16 17:51:27 +0000  6325)     if (!isa<CXXConstructorDecl>(Method)) {
1a99f441e64c8 (Sebastian Redl           2009-04-16 17:51:27 +0000  6326)       // If we get here, it's because we're calling a member function
1a99f441e64c8 (Sebastian Redl           2009-04-16 17:51:27 +0000  6327)       // that is named without a member access expression (e.g.,
1a99f441e64c8 (Sebastian Redl           2009-04-16 17:51:27 +0000  6328)       // "this->f") that was either written explicitly or created
1a99f441e64c8 (Sebastian Redl           2009-04-16 17:51:27 +0000  6329)       // implicitly. This can happen with a qualified call to a member
6e9f8f6374349 (John McCall              2009-12-03 04:06:58 +0000  6330)       // function, e.g., X::f(). We use an empty type for the implied
6e9f8f6374349 (John McCall              2009-12-03 04:06:58 +0000  6331)       // object argument (C++ [over.call.func]p3), and the acting context
6e9f8f6374349 (John McCall              2009-12-03 04:06:58 +0000  6332)       // is irrelevant.
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  6333)       AddMethodCandidate(Method, FoundDecl, Method->getParent(), QualType(),
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6334)                          Expr::Classification::makeSimpleLValue(), Args,
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6335)                          CandidateSet, SuppressUserConversions,
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  6336)                          PartialOverloading, EarlyConversions, PO);
1a99f441e64c8 (Sebastian Redl           2009-04-16 17:51:27 +0000  6337)       return;
1a99f441e64c8 (Sebastian Redl           2009-04-16 17:51:27 +0000  6338)     }
1a99f441e64c8 (Sebastian Redl           2009-04-16 17:51:27 +0000  6339)     // We treat a constructor like a non-member function, since its object
1a99f441e64c8 (Sebastian Redl           2009-04-16 17:51:27 +0000  6340)     // argument doesn't participate in overload resolution.
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000  6341)   }
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000  6342) 
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  6343)   if (!CandidateSet.isNewCandidate(Function, PO))
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000  6344)     return;
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000  6345) 
8b86f2d4010e1 (Richard Smith            2013-11-04 01:48:18 +0000  6346)   // C++11 [class.copy]p11: [DR1402]
8b86f2d4010e1 (Richard Smith            2013-11-04 01:48:18 +0000  6347)   //   A defaulted move constructor that is defined as deleted is ignored by
8b86f2d4010e1 (Richard Smith            2013-11-04 01:48:18 +0000  6348)   //   overload resolution.
8b86f2d4010e1 (Richard Smith            2013-11-04 01:48:18 +0000  6349)   CXXConstructorDecl *Constructor = dyn_cast<CXXConstructorDecl>(Function);
8b86f2d4010e1 (Richard Smith            2013-11-04 01:48:18 +0000  6350)   if (Constructor && Constructor->isDefaulted() && Constructor->isDeleted() &&
8b86f2d4010e1 (Richard Smith            2013-11-04 01:48:18 +0000  6351)       Constructor->isMoveConstructor())
8b86f2d4010e1 (Richard Smith            2013-11-04 01:48:18 +0000  6352)     return;
8b86f2d4010e1 (Richard Smith            2013-11-04 01:48:18 +0000  6353) 
27381f3d93454 (Douglas Gregor           2009-11-23 12:27:39 +0000  6354)   // Overload resolution is always an unevaluated context.
d143a0c2de131 (Faisal Vali              2017-04-01 21:30:49 +0000  6355)   EnterExpressionEvaluationContext Unevaluated(
d143a0c2de131 (Faisal Vali              2017-04-01 21:30:49 +0000  6356)       *this, Sema::ExpressionEvaluationContext::Unevaluated);
27381f3d93454 (Douglas Gregor           2009-11-23 12:27:39 +0000  6357) 
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  6358)   // C++ [over.match.oper]p3:
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  6359)   //   if no operand has a class type, only those non-member functions in the
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  6360)   //   lookup set that have a first parameter of type T1 or "reference to
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  6361)   //   (possibly cv-qualified) T1", when T1 is an enumeration type, or (if there
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  6362)   //   is a right operand) a second parameter of type T2 or "reference to
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  6363)   //   (possibly cv-qualified) T2", when T2 is an enumeration type, are
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  6364)   //   candidate functions.
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  6365)   if (CandidateSet.getKind() == OverloadCandidateSet::CSK_Operator &&
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  6366)       !IsAcceptableNonMemberOperatorCandidate(Context, Function, Args))
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  6367)     return;
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  6368) 
578a1f8c6d275 (John McCall              2014-12-14 01:46:53 +0000  6369)   // Add this candidate
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  6370)   OverloadCandidate &Candidate =
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  6371)       CandidateSet.addCandidate(Args.size(), EarlyConversions);
578a1f8c6d275 (John McCall              2014-12-14 01:46:53 +0000  6372)   Candidate.FoundDecl = FoundDecl;
578a1f8c6d275 (John McCall              2014-12-14 01:46:53 +0000  6373)   Candidate.Function = Function;
578a1f8c6d275 (John McCall              2014-12-14 01:46:53 +0000  6374)   Candidate.Viable = true;
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  6375)   Candidate.RewriteKind =
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  6376)       CandidateSet.getRewriteInfo().getRewriteKind(Function, PO);
578a1f8c6d275 (John McCall              2014-12-14 01:46:53 +0000  6377)   Candidate.IsSurrogate = false;
5cdc2cda28ac8 (Eric Fiselier            2018-12-12 21:50:55 +0000  6378)   Candidate.IsADLCandidate = IsADLCandidate;
578a1f8c6d275 (John McCall              2014-12-14 01:46:53 +0000  6379)   Candidate.IgnoreObjectArgument = false;
578a1f8c6d275 (John McCall              2014-12-14 01:46:53 +0000  6380)   Candidate.ExplicitCallArguments = Args.size();
578a1f8c6d275 (John McCall              2014-12-14 01:46:53 +0000  6381) 
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  6382)   // Explicit functions are not actually candidates at all if we're not
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  6383)   // allowing them in this context, but keep them around so we can point
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  6384)   // to them in diagnostics.
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  6385)   if (!AllowExplicit && ExplicitSpecifier::getFromDecl(Function).isExplicit()) {
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  6386)     Candidate.Viable = false;
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  6387)     Candidate.FailureKind = ovl_fail_explicit;
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  6388)     return;
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  6389)   }
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  6390) 
3efe00206f0f4 (Erich Keane              2018-07-20 14:13:28 +0000  6391)   if (Function->isMultiVersion() && Function->hasAttr<TargetAttr>() &&
281d20b601c8a (Erich Keane              2018-01-08 21:34:17 +0000  6392)       !Function->getAttr<TargetAttr>()->isDefaultVersion()) {
281d20b601c8a (Erich Keane              2018-01-08 21:34:17 +0000  6393)     Candidate.Viable = false;
281d20b601c8a (Erich Keane              2018-01-08 21:34:17 +0000  6394)     Candidate.FailureKind = ovl_non_default_multiversion_function;
281d20b601c8a (Erich Keane              2018-01-08 21:34:17 +0000  6395)     return;
281d20b601c8a (Erich Keane              2018-01-08 21:34:17 +0000  6396)   }
281d20b601c8a (Erich Keane              2018-01-08 21:34:17 +0000  6397) 
8b86f2d4010e1 (Richard Smith            2013-11-04 01:48:18 +0000  6398)   if (Constructor) {
ffe14e37121c5 (Douglas Gregor           2009-11-14 01:20:54 +0000  6399)     // C++ [class.copy]p3:
ffe14e37121c5 (Douglas Gregor           2009-11-14 01:20:54 +0000  6400)     //   A member function template is never instantiated to perform the copy
ffe14e37121c5 (Douglas Gregor           2009-11-14 01:20:54 +0000  6401)     //   of a class object to an object of its class type.
ffe14e37121c5 (Douglas Gregor           2009-11-14 01:20:54 +0000  6402)     QualType ClassType = Context.getTypeDeclType(Constructor->getParent());
0f59cb38e7f31 (Richard Smith            2015-12-18 21:45:41 +0000  6403)     if (Args.size() == 1 && Constructor->isSpecializationCopyingObject() &&
901e717f9295e (Douglas Gregor           2010-02-21 18:30:38 +0000  6404)         (Context.hasSameUnqualifiedType(ClassType, Args[0]->getType()) ||
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  6405)          IsDerivedFrom(Args[0]->getBeginLoc(), Args[0]->getType(),
0f59cb38e7f31 (Richard Smith            2015-12-18 21:45:41 +0000  6406)                        ClassType))) {
578a1f8c6d275 (John McCall              2014-12-14 01:46:53 +0000  6407)       Candidate.Viable = false;
578a1f8c6d275 (John McCall              2014-12-14 01:46:53 +0000  6408)       Candidate.FailureKind = ovl_fail_illegal_constructor;
ffe14e37121c5 (Douglas Gregor           2009-11-14 01:20:54 +0000  6409)       return;
578a1f8c6d275 (John McCall              2014-12-14 01:46:53 +0000  6410)     }
836a3b416d222 (Richard Smith            2017-01-13 20:46:54 +0000  6411) 
836a3b416d222 (Richard Smith            2017-01-13 20:46:54 +0000  6412)     // C++ [over.match.funcs]p8: (proposed DR resolution)
836a3b416d222 (Richard Smith            2017-01-13 20:46:54 +0000  6413)     //   A constructor inherited from class type C that has a first parameter
836a3b416d222 (Richard Smith            2017-01-13 20:46:54 +0000  6414)     //   of type "reference to P" (including such a constructor instantiated
836a3b416d222 (Richard Smith            2017-01-13 20:46:54 +0000  6415)     //   from a template) is excluded from the set of candidate functions when
836a3b416d222 (Richard Smith            2017-01-13 20:46:54 +0000  6416)     //   constructing an object of type cv D if the argument list has exactly
836a3b416d222 (Richard Smith            2017-01-13 20:46:54 +0000  6417)     //   one argument and D is reference-related to P and P is reference-related
836a3b416d222 (Richard Smith            2017-01-13 20:46:54 +0000  6418)     //   to C.
836a3b416d222 (Richard Smith            2017-01-13 20:46:54 +0000  6419)     auto *Shadow = dyn_cast<ConstructorUsingShadowDecl>(FoundDecl.getDecl());
836a3b416d222 (Richard Smith            2017-01-13 20:46:54 +0000  6420)     if (Shadow && Args.size() == 1 && Constructor->getNumParams() >= 1 &&
836a3b416d222 (Richard Smith            2017-01-13 20:46:54 +0000  6421)         Constructor->getParamDecl(0)->getType()->isReferenceType()) {
836a3b416d222 (Richard Smith            2017-01-13 20:46:54 +0000  6422)       QualType P = Constructor->getParamDecl(0)->getType()->getPointeeType();
836a3b416d222 (Richard Smith            2017-01-13 20:46:54 +0000  6423)       QualType C = Context.getRecordType(Constructor->getParent());
836a3b416d222 (Richard Smith            2017-01-13 20:46:54 +0000  6424)       QualType D = Context.getRecordType(Shadow->getParent());
836a3b416d222 (Richard Smith            2017-01-13 20:46:54 +0000  6425)       SourceLocation Loc = Args.front()->getExprLoc();
836a3b416d222 (Richard Smith            2017-01-13 20:46:54 +0000  6426)       if ((Context.hasSameUnqualifiedType(P, C) || IsDerivedFrom(Loc, P, C)) &&
836a3b416d222 (Richard Smith            2017-01-13 20:46:54 +0000  6427)           (Context.hasSameUnqualifiedType(D, P) || IsDerivedFrom(Loc, D, P))) {
836a3b416d222 (Richard Smith            2017-01-13 20:46:54 +0000  6428)         Candidate.Viable = false;
836a3b416d222 (Richard Smith            2017-01-13 20:46:54 +0000  6429)         Candidate.FailureKind = ovl_fail_inhctor_slice;
836a3b416d222 (Richard Smith            2017-01-13 20:46:54 +0000  6430)         return;
836a3b416d222 (Richard Smith            2017-01-13 20:46:54 +0000  6431)       }
836a3b416d222 (Richard Smith            2017-01-13 20:46:54 +0000  6432)     }
c25ea86d43929 (Anastasia Stulova        2019-06-20 16:23:28 +0000  6433) 
c25ea86d43929 (Anastasia Stulova        2019-06-20 16:23:28 +0000  6434)     // Check that the constructor is capable of constructing an object in the
c25ea86d43929 (Anastasia Stulova        2019-06-20 16:23:28 +0000  6435)     // destination address space.
c25ea86d43929 (Anastasia Stulova        2019-06-20 16:23:28 +0000  6436)     if (!Qualifiers::isAddressSpaceSupersetOf(
c25ea86d43929 (Anastasia Stulova        2019-06-20 16:23:28 +0000  6437)             Constructor->getMethodQualifiers().getAddressSpace(),
c25ea86d43929 (Anastasia Stulova        2019-06-20 16:23:28 +0000  6438)             CandidateSet.getDestAS())) {
c25ea86d43929 (Anastasia Stulova        2019-06-20 16:23:28 +0000  6439)       Candidate.Viable = false;
c25ea86d43929 (Anastasia Stulova        2019-06-20 16:23:28 +0000  6440)       Candidate.FailureKind = ovl_fail_object_addrspace_mismatch;
c25ea86d43929 (Anastasia Stulova        2019-06-20 16:23:28 +0000  6441)     }
ffe14e37121c5 (Douglas Gregor           2009-11-14 01:20:54 +0000  6442)   }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  6443) 
b3fd5cfa81b83 (Alp Toker                2014-01-21 00:32:38 +0000  6444)   unsigned NumParams = Proto->getNumParams();
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  6445) 
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  6446)   // (C++ 13.3.2p2): A candidate function having fewer than m
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  6447)   // parameters is viable only if it has an ellipsis in its parameter
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  6448)   // list (8.3.5).
975a9f6ecea60 (Francisco Lopes da Silva 2015-01-21 16:24:11 +0000  6449)   if (TooManyArguments(NumParams, Args.size(), PartialOverloading) &&
2a920014d3b33 (Douglas Gregor           2009-09-23 14:56:09 +0000  6450)       !Proto->isVariadic()) {
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  6451)     Candidate.Viable = false;
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000  6452)     Candidate.FailureKind = ovl_fail_too_many_arguments;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  6453)     return;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  6454)   }
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  6455) 
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  6456)   // (C++ 13.3.2p2): A candidate function having more than m parameters
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  6457)   // is viable only if the (m+1)st parameter has a default argument
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  6458)   // (8.3.6). For the purposes of overload resolution, the
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  6459)   // parameter list is truncated on the right, so that there are
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  6460)   // exactly m parameters.
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  6461)   unsigned MinRequiredArgs = Function->getMinRequiredArguments();
b24b9aa298311 (Ahmed Charles            2012-02-25 11:00:22 +0000  6462)   if (Args.size() < MinRequiredArgs && !PartialOverloading) {
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  6463)     // Not enough arguments.
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  6464)     Candidate.Viable = false;
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000  6465)     Candidate.FailureKind = ovl_fail_too_few_arguments;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  6466)     return;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  6467)   }
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  6468) 
7277fe8aed6e1 (Peter Collingbourne      2011-10-02 23:49:40 +0000  6469)   // (CUDA B.1): Check for invalid calls between targets.
bbafb8a745736 (David Blaikie            2012-03-11 07:00:24 +0000  6470)   if (getLangOpts().CUDA)
7277fe8aed6e1 (Peter Collingbourne      2011-10-02 23:49:40 +0000  6471)     if (const FunctionDecl *Caller = dyn_cast<FunctionDecl>(CurContext))
9a220fca4a6f0 (Eli Bendersky            2014-09-29 20:38:29 +0000  6472)       // Skip the check for callers that are implicit members, because in this
9a220fca4a6f0 (Eli Bendersky            2014-09-29 20:38:29 +0000  6473)       // case we may not yet know what the member's target is; the target is
9a220fca4a6f0 (Eli Bendersky            2014-09-29 20:38:29 +0000  6474)       // inferred for the member automatically, based on the bases and fields of
9a220fca4a6f0 (Eli Bendersky            2014-09-29 20:38:29 +0000  6475)       // the class.
b008003aa3f0d (Justin Lebar             2016-08-10 01:09:11 +0000  6476)       if (!Caller->isImplicit() && !IsAllowedCUDACall(Caller, Function)) {
7277fe8aed6e1 (Peter Collingbourne      2011-10-02 23:49:40 +0000  6477)         Candidate.Viable = false;
7277fe8aed6e1 (Peter Collingbourne      2011-10-02 23:49:40 +0000  6478)         Candidate.FailureKind = ovl_fail_bad_target;
7277fe8aed6e1 (Peter Collingbourne      2011-10-02 23:49:40 +0000  6479)         return;
7277fe8aed6e1 (Peter Collingbourne      2011-10-02 23:49:40 +0000  6480)       }
7277fe8aed6e1 (Peter Collingbourne      2011-10-02 23:49:40 +0000  6481) 
713562f54858f (Saar Raz                 2020-01-25 22:54:27 +0200  6482)   if (Function->getTrailingRequiresClause()) {
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  6483)     ConstraintSatisfaction Satisfaction;
713562f54858f (Saar Raz                 2020-01-25 22:54:27 +0200  6484)     if (CheckFunctionConstraints(Function, Satisfaction) ||
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  6485)         !Satisfaction.IsSatisfied) {
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  6486)       Candidate.Viable = false;
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  6487)       Candidate.FailureKind = ovl_fail_constraints_not_satisfied;
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  6488)       return;
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  6489)     }
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  6490)   }
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  6491) 
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  6492)   // Determine the implicit conversion sequences for each of the
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  6493)   // arguments.
b24b9aa298311 (Ahmed Charles            2012-02-25 11:00:22 +0000  6494)   for (unsigned ArgIdx = 0; ArgIdx < Args.size(); ++ArgIdx) {
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  6495)     unsigned ConvIdx =
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  6496)         PO == OverloadCandidateParamOrder::Reversed ? 1 - ArgIdx : ArgIdx;
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  6497)     if (Candidate.Conversions[ConvIdx].isInitialized()) {
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  6498)       // We already formed a conversion sequence for this parameter during
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  6499)       // template argument deduction.
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  6500)     } else if (ArgIdx < NumParams) {
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  6501)       // (C++ 13.3.2p3): for F to be a viable function, there shall
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  6502)       // exist for each argument an implicit conversion sequence
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  6503)       // (13.3.3.1) that converts that argument to the corresponding
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  6504)       // parameter of F.
9cacbabd33eea (Alp Toker                2014-01-20 20:26:09 +0000  6505)       QualType ParamType = Proto->getParamType(ArgIdx);
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  6506)       Candidate.Conversions[ConvIdx] = TryCopyInitialization(
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000  6507)           *this, Args[ArgIdx], ParamType, SuppressUserConversions,
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000  6508)           /*InOverloadResolution=*/true,
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000  6509)           /*AllowObjCWritebackConversion=*/
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000  6510)           getLangOpts().ObjCAutoRefCount, AllowExplicitConversions);
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  6511)       if (Candidate.Conversions[ConvIdx].isBad()) {
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000  6512)         Candidate.Viable = false;
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000  6513)         Candidate.FailureKind = ovl_fail_bad_conversion;
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  6514)         return;
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  6515)       }
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  6516)     } else {
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  6517)       // (C++ 13.3.2p2): For the purposes of overload resolution, any
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  6518)       // argument for which there is no corresponding parameter is
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  6519)       // considered to ""match the ellipsis" (C+ 13.3.3.1.3).
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  6520)       Candidate.Conversions[ConvIdx].setEllipsis();
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  6521)     }
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  6522)   }
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  6523) 
0dfb43deb6d55 (Richard Smith            2020-05-28 15:02:18 -0700  6524)   if (EnableIfAttr *FailedAttr =
0dfb43deb6d55 (Richard Smith            2020-05-28 15:02:18 -0700  6525)           CheckEnableIf(Function, CandidateSet.getLocation(), Args)) {
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  6526)     Candidate.Viable = false;
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  6527)     Candidate.FailureKind = ovl_fail_enable_if;
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  6528)     Candidate.DeductionFailure.Data = FailedAttr;
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  6529)     return;
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  6530)   }
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  6531) }
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  6532) 
d2a3cd7261503 (Manman Ren               2016-04-07 19:30:20 +0000  6533) ObjCMethodDecl *
d2a3cd7261503 (Manman Ren               2016-04-07 19:30:20 +0000  6534) Sema::SelectBestMethod(Selector Sel, MultiExprArg Args, bool IsInstance,
d2a3cd7261503 (Manman Ren               2016-04-07 19:30:20 +0000  6535)                        SmallVectorImpl<ObjCMethodDecl *> &Methods) {
d2a3cd7261503 (Manman Ren               2016-04-07 19:30:20 +0000  6536)   if (Methods.size() <= 1)
0ded42451d8d4 (Fariborz Jahanian        2014-08-13 21:24:14 +0000  6537)     return nullptr;
d2a3cd7261503 (Manman Ren               2016-04-07 19:30:20 +0000  6538) 
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6539)   for (unsigned b = 0, e = Methods.size(); b < e; b++) {
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6540)     bool Match = true;
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6541)     ObjCMethodDecl *Method = Methods[b];
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6542)     unsigned NumNamedArgs = Sel.getNumArgs();
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6543)     // Method might have more arguments than selector indicates. This is due
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6544)     // to addition of c-style arguments in method.
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6545)     if (Method->param_size() > NumNamedArgs)
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6546)       NumNamedArgs = Method->param_size();
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6547)     if (Args.size() < NumNamedArgs)
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6548)       continue;
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  6549) 
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6550)     for (unsigned i = 0; i < NumNamedArgs; i++) {
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6551)       // We can't do any type-checking on a type-dependent argument.
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6552)       if (Args[i]->isTypeDependent()) {
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6553)         Match = false;
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6554)         break;
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6555)       }
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  6556) 
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6557)       ParmVarDecl *param = Method->parameters()[i];
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6558)       Expr *argExpr = Args[i];
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6559)       assert(argExpr && "SelectBestMethod(): missing expression");
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  6560) 
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6561)       // Strip the unbridged-cast placeholder expression off unless it's
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6562)       // a consumed argument.
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6563)       if (argExpr->hasPlaceholderType(BuiltinType::ARCUnbridgedCast) &&
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6564)           !param->hasAttr<CFConsumedAttr>())
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6565)         argExpr = stripARCUnbridgedCast(argExpr);
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  6566) 
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6567)       // If the parameter is __unknown_anytype, move on to the next method.
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6568)       if (param->getType() == Context.UnknownAnyTy) {
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6569)         Match = false;
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6570)         break;
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6571)       }
4546181e12c89 (George Burgess IV        2015-10-11 20:13:20 +0000  6572) 
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6573)       ImplicitConversionSequence ConversionState
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6574)         = TryCopyInitialization(*this, argExpr, param->getType(),
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6575)                                 /*SuppressUserConversions*/false,
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6576)                                 /*InOverloadResolution=*/true,
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6577)                                 /*AllowObjCWritebackConversion=*/
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6578)                                 getLangOpts().ObjCAutoRefCount,
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6579)                                 /*AllowExplicit*/false);
2099b54102e7d (George Burgess IV        2016-09-02 22:59:57 +0000  6580)       // This function looks for a reasonably-exact match, so we consider
2099b54102e7d (George Burgess IV        2016-09-02 22:59:57 +0000  6581)       // incompatible pointer conversions to be a failure here.
2099b54102e7d (George Burgess IV        2016-09-02 22:59:57 +0000  6582)       if (ConversionState.isBad() ||
2099b54102e7d (George Burgess IV        2016-09-02 22:59:57 +0000  6583)           (ConversionState.isStandard() &&
2099b54102e7d (George Burgess IV        2016-09-02 22:59:57 +0000  6584)            ConversionState.Standard.Second ==
2099b54102e7d (George Burgess IV        2016-09-02 22:59:57 +0000  6585)                ICK_Incompatible_Pointer_Conversion)) {
2099b54102e7d (George Burgess IV        2016-09-02 22:59:57 +0000  6586)         Match = false;
2099b54102e7d (George Burgess IV        2016-09-02 22:59:57 +0000  6587)         break;
2099b54102e7d (George Burgess IV        2016-09-02 22:59:57 +0000  6588)       }
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6589)     }
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6590)     // Promote additional arguments to variadic methods.
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6591)     if (Match && Method->isVariadic()) {
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6592)       for (unsigned i = NumNamedArgs, e = Args.size(); i < e; ++i) {
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6593)         if (Args[i]->isTypeDependent()) {
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6594)           Match = false;
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6595)           break;
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6596)         }
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6597)         ExprResult Arg = DefaultVariadicArgumentPromotion(Args[i], VariadicMethod,
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6598)                                                           nullptr);
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6599)         if (Arg.isInvalid()) {
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6600)           Match = false;
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6601)           break;
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6602)         }
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6603)       }
180d76b4089e7 (Fariborz Jahanian        2014-08-27 16:38:47 +0000  6604)     } else {
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6605)       // Check for extra arguments to non-variadic methods.
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6606)       if (Args.size() != NumNamedArgs)
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6607)         Match = false;
180d76b4089e7 (Fariborz Jahanian        2014-08-27 16:38:47 +0000  6608)       else if (Match && NumNamedArgs == 0 && Methods.size() > 1) {
180d76b4089e7 (Fariborz Jahanian        2014-08-27 16:38:47 +0000  6609)         // Special case when selectors have no argument. In this case, select
180d76b4089e7 (Fariborz Jahanian        2014-08-27 16:38:47 +0000  6610)         // one with the most general result type of 'id'.
180d76b4089e7 (Fariborz Jahanian        2014-08-27 16:38:47 +0000  6611)         for (unsigned b = 0, e = Methods.size(); b < e; b++) {
180d76b4089e7 (Fariborz Jahanian        2014-08-27 16:38:47 +0000  6612)           QualType ReturnT = Methods[b]->getReturnType();
180d76b4089e7 (Fariborz Jahanian        2014-08-27 16:38:47 +0000  6613)           if (ReturnT->isObjCIdType())
180d76b4089e7 (Fariborz Jahanian        2014-08-27 16:38:47 +0000  6614)             return Methods[b];
180d76b4089e7 (Fariborz Jahanian        2014-08-27 16:38:47 +0000  6615)         }
180d76b4089e7 (Fariborz Jahanian        2014-08-27 16:38:47 +0000  6616)       }
180d76b4089e7 (Fariborz Jahanian        2014-08-27 16:38:47 +0000  6617)     }
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6618) 
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6619)     if (Match)
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6620)       return Method;
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6621)   }
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6622)   return nullptr;
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6623) }
30ae8d44139ba (Fariborz Jahanian        2014-08-13 21:07:35 +0000  6624) 
0dfb43deb6d55 (Richard Smith            2020-05-28 15:02:18 -0700  6625) static bool convertArgsForAvailabilityChecks(
0dfb43deb6d55 (Richard Smith            2020-05-28 15:02:18 -0700  6626)     Sema &S, FunctionDecl *Function, Expr *ThisArg, SourceLocation CallLoc,
0dfb43deb6d55 (Richard Smith            2020-05-28 15:02:18 -0700  6627)     ArrayRef<Expr *> Args, Sema::SFINAETrap &Trap, bool MissingImplicitThis,
0dfb43deb6d55 (Richard Smith            2020-05-28 15:02:18 -0700  6628)     Expr *&ConvertedThis, SmallVectorImpl<Expr *> &ConvertedArgs) {
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6629)   if (ThisArg) {
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6630)     CXXMethodDecl *Method = cast<CXXMethodDecl>(Function);
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6631)     assert(!isa<CXXConstructorDecl>(Method) &&
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6632)            "Shouldn't have `this` for ctors!");
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6633)     assert(!Method->isStatic() && "Shouldn't have `this` for static methods!");
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6634)     ExprResult R = S.PerformObjectArgumentInitialization(
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6635)         ThisArg, /*Qualifier=*/nullptr, Method, Method);
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6636)     if (R.isInvalid())
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6637)       return false;
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6638)     ConvertedThis = R.get();
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6639)   } else {
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6640)     if (auto *MD = dyn_cast<CXXMethodDecl>(Function)) {
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6641)       (void)MD;
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6642)       assert((MissingImplicitThis || MD->isStatic() ||
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6643)               isa<CXXConstructorDecl>(MD)) &&
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6644)              "Expected `this` for non-ctor instance methods");
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6645)     }
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6646)     ConvertedThis = nullptr;
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6647)   }
e283c5529e3c0 (Nick Lewycky             2015-08-25 22:33:16 +0000  6648) 
458b3f3a114d5 (George Burgess IV        2016-08-12 04:19:35 +0000  6649)   // Ignore any variadic arguments. Converting them is pointless, since the
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6650)   // user can't refer to them in the function condition.
53b938da5a39c (George Burgess IV        2016-08-12 04:12:31 +0000  6651)   unsigned ArgSizeNoVarargs = std::min(Function->param_size(), Args.size());
53b938da5a39c (George Burgess IV        2016-08-12 04:12:31 +0000  6652) 
e283c5529e3c0 (Nick Lewycky             2015-08-25 22:33:16 +0000  6653)   // Convert the arguments.
53b938da5a39c (George Burgess IV        2016-08-12 04:12:31 +0000  6654)   for (unsigned I = 0; I != ArgSizeNoVarargs; ++I) {
e96abf79599d5 (George Burgess IV        2016-02-24 22:31:14 +0000  6655)     ExprResult R;
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6656)     R = S.PerformCopyInitialization(InitializedEntity::InitializeParameter(
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6657)                                         S.Context, Function->getParamDecl(I)),
e96abf79599d5 (George Burgess IV        2016-02-24 22:31:14 +0000  6658)                                     SourceLocation(), Args[I]);
e96abf79599d5 (George Burgess IV        2016-02-24 22:31:14 +0000  6659) 
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6660)     if (R.isInvalid())
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6661)       return false;
e96abf79599d5 (George Burgess IV        2016-02-24 22:31:14 +0000  6662) 
e96abf79599d5 (George Burgess IV        2016-02-24 22:31:14 +0000  6663)     ConvertedArgs.push_back(R.get());
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  6664)   }
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  6665) 
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6666)   if (Trap.hasErrorOccurred())
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6667)     return false;
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  6668) 
e283c5529e3c0 (Nick Lewycky             2015-08-25 22:33:16 +0000  6669)   // Push default arguments if needed.
e283c5529e3c0 (Nick Lewycky             2015-08-25 22:33:16 +0000  6670)   if (!Function->isVariadic() && Args.size() < Function->getNumParams()) {
e283c5529e3c0 (Nick Lewycky             2015-08-25 22:33:16 +0000  6671)     for (unsigned i = Args.size(), e = Function->getNumParams(); i != e; ++i) {
e283c5529e3c0 (Nick Lewycky             2015-08-25 22:33:16 +0000  6672)       ParmVarDecl *P = Function->getParamDecl(i);
b5f2c4e45b8d5 (Richard Smith            2020-06-02 10:42:36 -0700  6673)       if (!P->hasDefaultArg())
b5f2c4e45b8d5 (Richard Smith            2020-06-02 10:42:36 -0700  6674)         return false;
0dfb43deb6d55 (Richard Smith            2020-05-28 15:02:18 -0700  6675)       ExprResult R = S.BuildCXXDefaultArgExpr(CallLoc, Function, P);
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6676)       if (R.isInvalid())
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6677)         return false;
e283c5529e3c0 (Nick Lewycky             2015-08-25 22:33:16 +0000  6678)       ConvertedArgs.push_back(R.get());
e283c5529e3c0 (Nick Lewycky             2015-08-25 22:33:16 +0000  6679)     }
e283c5529e3c0 (Nick Lewycky             2015-08-25 22:33:16 +0000  6680) 
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6681)     if (Trap.hasErrorOccurred())
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6682)       return false;
e283c5529e3c0 (Nick Lewycky             2015-08-25 22:33:16 +0000  6683)   }
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6684)   return true;
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6685) }
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6686) 
0dfb43deb6d55 (Richard Smith            2020-05-28 15:02:18 -0700  6687) EnableIfAttr *Sema::CheckEnableIf(FunctionDecl *Function,
0dfb43deb6d55 (Richard Smith            2020-05-28 15:02:18 -0700  6688)                                   SourceLocation CallLoc,
0dfb43deb6d55 (Richard Smith            2020-05-28 15:02:18 -0700  6689)                                   ArrayRef<Expr *> Args,
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6690)                                   bool MissingImplicitThis) {
dc5ce72afada3 (Michael Kruse            2018-08-03 01:21:16 +0000  6691)   auto EnableIfAttrs = Function->specific_attrs<EnableIfAttr>();
dc5ce72afada3 (Michael Kruse            2018-08-03 01:21:16 +0000  6692)   if (EnableIfAttrs.begin() == EnableIfAttrs.end())
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6693)     return nullptr;
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6694) 
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6695)   SFINAETrap Trap(*this);
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6696)   SmallVector<Expr *, 16> ConvertedArgs;
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6697)   // FIXME: We should look into making enable_if late-parsed.
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6698)   Expr *DiscardedThis;
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6699)   if (!convertArgsForAvailabilityChecks(
0dfb43deb6d55 (Richard Smith            2020-05-28 15:02:18 -0700  6700)           *this, Function, /*ThisArg=*/nullptr, CallLoc, Args, Trap,
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6701)           /*MissingImplicitThis=*/true, DiscardedThis, ConvertedArgs))
dc5ce72afada3 (Michael Kruse            2018-08-03 01:21:16 +0000  6702)     return *EnableIfAttrs.begin();
e283c5529e3c0 (Nick Lewycky             2015-08-25 22:33:16 +0000  6703) 
2a6150d93290b (George Burgess IV        2015-10-16 01:17:38 +0000  6704)   for (auto *EIA : EnableIfAttrs) {
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  6705)     APValue Result;
e8f10cc0b9a9f (George Burgess IV        2016-05-11 01:38:27 +0000  6706)     // FIXME: This doesn't consider value-dependent cases, because doing so is
e8f10cc0b9a9f (George Burgess IV        2016-05-11 01:38:27 +0000  6707)     // very difficult. Ideally, we should handle them more gracefully.
04323c24a1ac9 (Dmitri Gribenko          2019-05-17 17:16:53 +0000  6708)     if (EIA->getCond()->isValueDependent() ||
04323c24a1ac9 (Dmitri Gribenko          2019-05-17 17:16:53 +0000  6709)         !EIA->getCond()->EvaluateWithSubstitution(
e8f10cc0b9a9f (George Burgess IV        2016-05-11 01:38:27 +0000  6710)             Result, Context, Function, llvm::makeArrayRef(ConvertedArgs)))
e8f10cc0b9a9f (George Burgess IV        2016-05-11 01:38:27 +0000  6711)       return EIA;
e8f10cc0b9a9f (George Burgess IV        2016-05-11 01:38:27 +0000  6712) 
e8f10cc0b9a9f (George Burgess IV        2016-05-11 01:38:27 +0000  6713)     if (!Result.isInt() || !Result.getInt().getBoolValue())
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  6714)       return EIA;
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  6715)   }
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000  6716)   return nullptr;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  6717) }
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  6718) 
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6719) template <typename CheckFn>
a7233bd801602 (Argyrios Kyrtzidis       2017-05-24 00:46:27 +0000  6720) static bool diagnoseDiagnoseIfAttrsWith(Sema &S, const NamedDecl *ND,
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6721)                                         bool ArgDependent, SourceLocation Loc,
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6722)                                         CheckFn &&IsSuccessful) {
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6723)   SmallVector<const DiagnoseIfAttr *, 8> Attrs;
a7233bd801602 (Argyrios Kyrtzidis       2017-05-24 00:46:27 +0000  6724)   for (const auto *DIA : ND->specific_attrs<DiagnoseIfAttr>()) {
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6725)     if (ArgDependent == DIA->getArgDependent())
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6726)       Attrs.push_back(DIA);
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6727)   }
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6728) 
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6729)   // Common case: No diagnose_if attributes, so we can quit early.
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6730)   if (Attrs.empty())
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6731)     return false;
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6732) 
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6733)   auto WarningBegin = std::stable_partition(
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6734)       Attrs.begin(), Attrs.end(),
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6735)       [](const DiagnoseIfAttr *DIA) { return DIA->isError(); });
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6736) 
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6737)   // Note that diagnose_if attributes are late-parsed, so they appear in the
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6738)   // correct order (unlike enable_if attributes).
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6739)   auto ErrAttr = llvm::find_if(llvm::make_range(Attrs.begin(), WarningBegin),
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6740)                                IsSuccessful);
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6741)   if (ErrAttr != WarningBegin) {
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6742)     const DiagnoseIfAttr *DIA = *ErrAttr;
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6743)     S.Diag(Loc, diag::err_diagnose_if_succeeded) << DIA->getMessage();
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6744)     S.Diag(DIA->getLocation(), diag::note_from_diagnose_if)
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6745)         << DIA->getParent() << DIA->getCond()->getSourceRange();
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6746)     return true;
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6747)   }
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6748) 
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6749)   for (const auto *DIA : llvm::make_range(WarningBegin, Attrs.end()))
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6750)     if (IsSuccessful(DIA)) {
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6751)       S.Diag(Loc, diag::warn_diagnose_if_succeeded) << DIA->getMessage();
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6752)       S.Diag(DIA->getLocation(), diag::note_from_diagnose_if)
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6753)           << DIA->getParent() << DIA->getCond()->getSourceRange();
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6754)     }
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6755) 
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6756)   return false;
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6757) }
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6758) 
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6759) bool Sema::diagnoseArgDependentDiagnoseIfAttrs(const FunctionDecl *Function,
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6760)                                                const Expr *ThisArg,
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6761)                                                ArrayRef<const Expr *> Args,
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6762)                                                SourceLocation Loc) {
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6763)   return diagnoseDiagnoseIfAttrsWith(
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6764)       *this, Function, /*ArgDependent=*/true, Loc,
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6765)       [&](const DiagnoseIfAttr *DIA) {
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6766)         APValue Result;
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6767)         // It's sane to use the same Args for any redecl of this function, since
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6768)         // EvaluateWithSubstitution only cares about the position of each
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6769)         // argument in the arg list, not the ParmVarDecl* it maps to.
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6770)         if (!DIA->getCond()->EvaluateWithSubstitution(
a7233bd801602 (Argyrios Kyrtzidis       2017-05-24 00:46:27 +0000  6771)                 Result, Context, cast<FunctionDecl>(DIA->getParent()), Args, ThisArg))
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6772)           return false;
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6773)         return Result.isInt() && Result.getInt().getBoolValue();
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6774)       });
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6775) }
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6776) 
a7233bd801602 (Argyrios Kyrtzidis       2017-05-24 00:46:27 +0000  6777) bool Sema::diagnoseArgIndependentDiagnoseIfAttrs(const NamedDecl *ND,
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6778)                                                  SourceLocation Loc) {
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6779)   return diagnoseDiagnoseIfAttrsWith(
a7233bd801602 (Argyrios Kyrtzidis       2017-05-24 00:46:27 +0000  6780)       *this, ND, /*ArgDependent=*/false, Loc,
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6781)       [&](const DiagnoseIfAttr *DIA) {
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6782)         bool Result;
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6783)         return DIA->getCond()->EvaluateAsBooleanCondition(Result, Context) &&
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6784)                Result;
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6785)       });
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6786) }
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6787) 
9fc8faf9e6197 (Adrian Prantl            2018-05-09 01:00:01 +0000  6788) /// Add all of the function declarations in the given function set to
ed4265c24e2b6 (Nick Lewycky             2013-09-22 10:06:01 +0000  6789) /// the overload candidate set.
4c4c1dfc2b768 (John McCall              2010-01-26 03:27:55 +0000  6790) void Sema::AddFunctionCandidates(const UnresolvedSetImpl &Fns,
f857950d391d0 (Dmitri Gribenko          2013-01-12 19:30:44 +0000  6791)                                  ArrayRef<Expr *> Args,
f83cfda02bd06 (Ivan Donchevskii         2018-06-21 08:34:50 +0000  6792)                                  OverloadCandidateSet &CandidateSet,
975a9f6ecea60 (Francisco Lopes da Silva 2015-01-21 16:24:11 +0000  6793)                                  TemplateArgumentListInfo *ExplicitTemplateArgs,
bcc22fc4e1b2c (Richard Smith            2012-03-09 08:00:36 +0000  6794)                                  bool SuppressUserConversions,
e3962aebca1e2 (Benjamin Kramer          2017-10-26 08:41:28 +0000  6795)                                  bool PartialOverloading,
e3962aebca1e2 (Benjamin Kramer          2017-10-26 08:41:28 +0000  6796)                                  bool FirstArgumentIsBase) {
4c4c1dfc2b768 (John McCall              2010-01-26 03:27:55 +0000  6797)   for (UnresolvedSetIterator F = Fns.begin(), E = Fns.end(); F != E; ++F) {
a0296f7987c0a (John McCall              2010-03-19 07:35:19 +0000  6798)     NamedDecl *D = F.getDecl()->getUnderlyingDecl();
f83cfda02bd06 (Ivan Donchevskii         2018-06-21 08:34:50 +0000  6799)     ArrayRef<Expr *> FunctionArgs = Args;
f83cfda02bd06 (Ivan Donchevskii         2018-06-21 08:34:50 +0000  6800) 
f83cfda02bd06 (Ivan Donchevskii         2018-06-21 08:34:50 +0000  6801)     FunctionTemplateDecl *FunTmpl = dyn_cast<FunctionTemplateDecl>(D);
f83cfda02bd06 (Ivan Donchevskii         2018-06-21 08:34:50 +0000  6802)     FunctionDecl *FD =
f83cfda02bd06 (Ivan Donchevskii         2018-06-21 08:34:50 +0000  6803)         FunTmpl ? FunTmpl->getTemplatedDecl() : cast<FunctionDecl>(D);
f83cfda02bd06 (Ivan Donchevskii         2018-06-21 08:34:50 +0000  6804) 
f83cfda02bd06 (Ivan Donchevskii         2018-06-21 08:34:50 +0000  6805)     if (isa<CXXMethodDecl>(FD) && !cast<CXXMethodDecl>(FD)->isStatic()) {
f83cfda02bd06 (Ivan Donchevskii         2018-06-21 08:34:50 +0000  6806)       QualType ObjectType;
f83cfda02bd06 (Ivan Donchevskii         2018-06-21 08:34:50 +0000  6807)       Expr::Classification ObjectClassification;
f83cfda02bd06 (Ivan Donchevskii         2018-06-21 08:34:50 +0000  6808)       if (Args.size() > 0) {
f1898cfa42a05 (Erik Verbruggen          2017-03-28 07:22:21 +0000  6809)         if (Expr *E = Args[0]) {
2a8c18d991188 (Alexander Kornienko      2018-04-06 15:14:32 +0000  6810)           // Use the explicit base to restrict the lookup:
f1898cfa42a05 (Erik Verbruggen          2017-03-28 07:22:21 +0000  6811)           ObjectType = E->getType();
143a9e0b1236d (Ilya Biryukov            2018-12-07 13:17:52 +0000  6812)           // Pointers in the object arguments are implicitly dereferenced, so we
143a9e0b1236d (Ilya Biryukov            2018-12-07 13:17:52 +0000  6813)           // always classify them as l-values.
143a9e0b1236d (Ilya Biryukov            2018-12-07 13:17:52 +0000  6814)           if (!ObjectType.isNull() && ObjectType->isPointerType())
143a9e0b1236d (Ilya Biryukov            2018-12-07 13:17:52 +0000  6815)             ObjectClassification = Expr::Classification::makeSimpleLValue();
143a9e0b1236d (Ilya Biryukov            2018-12-07 13:17:52 +0000  6816)           else
143a9e0b1236d (Ilya Biryukov            2018-12-07 13:17:52 +0000  6817)             ObjectClassification = E->Classify(Context);
f83cfda02bd06 (Ivan Donchevskii         2018-06-21 08:34:50 +0000  6818)         } // .. else there is an implicit base.
f83cfda02bd06 (Ivan Donchevskii         2018-06-21 08:34:50 +0000  6819)         FunctionArgs = Args.slice(1);
f83cfda02bd06 (Ivan Donchevskii         2018-06-21 08:34:50 +0000  6820)       }
f83cfda02bd06 (Ivan Donchevskii         2018-06-21 08:34:50 +0000  6821)       if (FunTmpl) {
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6822)         AddMethodTemplateCandidate(
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6823)             FunTmpl, F.getPair(),
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000  6824)             cast<CXXRecordDecl>(FunTmpl->getDeclContext()),
f1898cfa42a05 (Erik Verbruggen          2017-03-28 07:22:21 +0000  6825)             ExplicitTemplateArgs, ObjectType, ObjectClassification,
f83cfda02bd06 (Ivan Donchevskii         2018-06-21 08:34:50 +0000  6826)             FunctionArgs, CandidateSet, SuppressUserConversions,
f1898cfa42a05 (Erik Verbruggen          2017-03-28 07:22:21 +0000  6827)             PartialOverloading);
f1898cfa42a05 (Erik Verbruggen          2017-03-28 07:22:21 +0000  6828)       } else {
f83cfda02bd06 (Ivan Donchevskii         2018-06-21 08:34:50 +0000  6829)         AddMethodCandidate(cast<CXXMethodDecl>(FD), F.getPair(),
f83cfda02bd06 (Ivan Donchevskii         2018-06-21 08:34:50 +0000  6830)                            cast<CXXMethodDecl>(FD)->getParent(), ObjectType,
f83cfda02bd06 (Ivan Donchevskii         2018-06-21 08:34:50 +0000  6831)                            ObjectClassification, FunctionArgs, CandidateSet,
f83cfda02bd06 (Ivan Donchevskii         2018-06-21 08:34:50 +0000  6832)                            SuppressUserConversions, PartialOverloading);
f83cfda02bd06 (Ivan Donchevskii         2018-06-21 08:34:50 +0000  6833)       }
f83cfda02bd06 (Ivan Donchevskii         2018-06-21 08:34:50 +0000  6834)     } else {
f83cfda02bd06 (Ivan Donchevskii         2018-06-21 08:34:50 +0000  6835)       // This branch handles both standalone functions and static methods.
f83cfda02bd06 (Ivan Donchevskii         2018-06-21 08:34:50 +0000  6836) 
f83cfda02bd06 (Ivan Donchevskii         2018-06-21 08:34:50 +0000  6837)       // Slice the first argument (which is the base) when we access
f83cfda02bd06 (Ivan Donchevskii         2018-06-21 08:34:50 +0000  6838)       // static method as non-static.
f83cfda02bd06 (Ivan Donchevskii         2018-06-21 08:34:50 +0000  6839)       if (Args.size() > 0 &&
f83cfda02bd06 (Ivan Donchevskii         2018-06-21 08:34:50 +0000  6840)           (!Args[0] || (FirstArgumentIsBase && isa<CXXMethodDecl>(FD) &&
f83cfda02bd06 (Ivan Donchevskii         2018-06-21 08:34:50 +0000  6841)                         !isa<CXXConstructorDecl>(FD)))) {
f83cfda02bd06 (Ivan Donchevskii         2018-06-21 08:34:50 +0000  6842)         assert(cast<CXXMethodDecl>(FD)->isStatic());
f83cfda02bd06 (Ivan Donchevskii         2018-06-21 08:34:50 +0000  6843)         FunctionArgs = Args.slice(1);
f83cfda02bd06 (Ivan Donchevskii         2018-06-21 08:34:50 +0000  6844)       }
f83cfda02bd06 (Ivan Donchevskii         2018-06-21 08:34:50 +0000  6845)       if (FunTmpl) {
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  6846)         AddTemplateOverloadCandidate(FunTmpl, F.getPair(),
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  6847)                                      ExplicitTemplateArgs, FunctionArgs,
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  6848)                                      CandidateSet, SuppressUserConversions,
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  6849)                                      PartialOverloading);
f83cfda02bd06 (Ivan Donchevskii         2018-06-21 08:34:50 +0000  6850)       } else {
f83cfda02bd06 (Ivan Donchevskii         2018-06-21 08:34:50 +0000  6851)         AddOverloadCandidate(FD, F.getPair(), FunctionArgs, CandidateSet,
f83cfda02bd06 (Ivan Donchevskii         2018-06-21 08:34:50 +0000  6852)                              SuppressUserConversions, PartialOverloading);
f1898cfa42a05 (Erik Verbruggen          2017-03-28 07:22:21 +0000  6853)       }
5b0f2a2fbe3ac (Douglas Gregor           2009-09-28 04:47:19 +0000  6854)     }
15448f8d238c5 (Douglas Gregor           2009-06-27 21:05:07 +0000  6855)   }
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000  6856) }
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000  6857) 
f0f1cf087e704 (John McCall              2009-11-17 07:50:12 +0000  6858) /// AddMethodCandidate - Adds a named decl (which is some kind of
f0f1cf087e704 (John McCall              2009-11-17 07:50:12 +0000  6859) /// method) as a method candidate to the given overload set.
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  6860) void Sema::AddMethodCandidate(DeclAccessPair FoundDecl, QualType ObjectType,
0282432039ab9 (Douglas Gregor           2011-01-26 19:30:28 +0000  6861)                               Expr::Classification ObjectClassification,
51629dfce2e0c (Rafael Espindola         2013-04-29 19:29:25 +0000  6862)                               ArrayRef<Expr *> Args,
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  6863)                               OverloadCandidateSet &CandidateSet,
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  6864)                               bool SuppressUserConversions,
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  6865)                               OverloadCandidateParamOrder PO) {
a0296f7987c0a (John McCall              2010-03-19 07:35:19 +0000  6866)   NamedDecl *Decl = FoundDecl.getDecl();
6e9f8f6374349 (John McCall              2009-12-03 04:06:58 +0000  6867)   CXXRecordDecl *ActingContext = cast<CXXRecordDecl>(Decl->getDeclContext());
f0f1cf087e704 (John McCall              2009-11-17 07:50:12 +0000  6868) 
f0f1cf087e704 (John McCall              2009-11-17 07:50:12 +0000  6869)   if (isa<UsingShadowDecl>(Decl))
f0f1cf087e704 (John McCall              2009-11-17 07:50:12 +0000  6870)     Decl = cast<UsingShadowDecl>(Decl)->getTargetDecl();
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  6871) 
f0f1cf087e704 (John McCall              2009-11-17 07:50:12 +0000  6872)   if (FunctionTemplateDecl *TD = dyn_cast<FunctionTemplateDecl>(Decl)) {
f0f1cf087e704 (John McCall              2009-11-17 07:50:12 +0000  6873)     assert(isa<CXXMethodDecl>(TD->getTemplatedDecl()) &&
f0f1cf087e704 (John McCall              2009-11-17 07:50:12 +0000  6874)            "Expected a member function template");
a0296f7987c0a (John McCall              2010-03-19 07:35:19 +0000  6875)     AddMethodTemplateCandidate(TD, FoundDecl, ActingContext,
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6876)                                /*ExplicitArgs*/ nullptr, ObjectType,
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6877)                                ObjectClassification, Args, CandidateSet,
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  6878)                                SuppressUserConversions, false, PO);
f0f1cf087e704 (John McCall              2009-11-17 07:50:12 +0000  6879)   } else {
a0296f7987c0a (John McCall              2010-03-19 07:35:19 +0000  6880)     AddMethodCandidate(cast<CXXMethodDecl>(Decl), FoundDecl, ActingContext,
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6881)                        ObjectType, ObjectClassification, Args, CandidateSet,
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  6882)                        SuppressUserConversions, false, None, PO);
f0f1cf087e704 (John McCall              2009-11-17 07:50:12 +0000  6883)   }
f0f1cf087e704 (John McCall              2009-11-17 07:50:12 +0000  6884) }
f0f1cf087e704 (John McCall              2009-11-17 07:50:12 +0000  6885) 
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  6886) /// AddMethodCandidate - Adds the given C++ member function to the set
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  6887) /// of candidate functions, using the given function call arguments
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  6888) /// and the object argument (@c Object). For example, in a call
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  6889) /// @c o.f(a1,a2), @c Object will contain @c o and @c Args will contain
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  6890) /// both @c a1 and @c a2. If @p SuppressUserConversions, then don't
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  6891) /// allow user-defined conversions via constructors or conversion
f1e4669232de4 (Douglas Gregor           2010-04-16 17:33:27 +0000  6892) /// operators.
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  6893) void
a0296f7987c0a (John McCall              2010-03-19 07:35:19 +0000  6894) Sema::AddMethodCandidate(CXXMethodDecl *Method, DeclAccessPair FoundDecl,
b89836b6db6fa (John McCall              2010-01-26 01:37:31 +0000  6895)                          CXXRecordDecl *ActingContext, QualType ObjectType,
0282432039ab9 (Douglas Gregor           2011-01-26 19:30:28 +0000  6896)                          Expr::Classification ObjectClassification,
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  6897)                          ArrayRef<Expr *> Args,
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  6898)                          OverloadCandidateSet &CandidateSet,
975a9f6ecea60 (Francisco Lopes da Silva 2015-01-21 16:24:11 +0000  6899)                          bool SuppressUserConversions,
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  6900)                          bool PartialOverloading,
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  6901)                          ConversionSequenceList EarlyConversions,
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  6902)                          OverloadCandidateParamOrder PO) {
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  6903)   const FunctionProtoType *Proto
9dd450bb78148 (John McCall              2009-09-21 23:43:11 +0000  6904)     = dyn_cast<FunctionProtoType>(Method->getType()->getAs<FunctionType>());
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  6905)   assert(Proto && "Methods without a prototype cannot be overloaded");
1a99f441e64c8 (Sebastian Redl           2009-04-16 17:51:27 +0000  6906)   assert(!isa<CXXConstructorDecl>(Method) &&
1a99f441e64c8 (Sebastian Redl           2009-04-16 17:51:27 +0000  6907)          "Use AddOverloadCandidate for constructors");
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  6908) 
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  6909)   if (!CandidateSet.isNewCandidate(Method, PO))
5b0f2a2fbe3ac (Douglas Gregor           2009-09-28 04:47:19 +0000  6910)     return;
5b0f2a2fbe3ac (Douglas Gregor           2009-09-28 04:47:19 +0000  6911) 
8b86f2d4010e1 (Richard Smith            2013-11-04 01:48:18 +0000  6912)   // C++11 [class.copy]p23: [DR1402]
8b86f2d4010e1 (Richard Smith            2013-11-04 01:48:18 +0000  6913)   //   A defaulted move assignment operator that is defined as deleted is
8b86f2d4010e1 (Richard Smith            2013-11-04 01:48:18 +0000  6914)   //   ignored by overload resolution.
8b86f2d4010e1 (Richard Smith            2013-11-04 01:48:18 +0000  6915)   if (Method->isDefaulted() && Method->isDeleted() &&
8b86f2d4010e1 (Richard Smith            2013-11-04 01:48:18 +0000  6916)       Method->isMoveAssignmentOperator())
8b86f2d4010e1 (Richard Smith            2013-11-04 01:48:18 +0000  6917)     return;
8b86f2d4010e1 (Richard Smith            2013-11-04 01:48:18 +0000  6918) 
27381f3d93454 (Douglas Gregor           2009-11-23 12:27:39 +0000  6919)   // Overload resolution is always an unevaluated context.
d143a0c2de131 (Faisal Vali              2017-04-01 21:30:49 +0000  6920)   EnterExpressionEvaluationContext Unevaluated(
d143a0c2de131 (Faisal Vali              2017-04-01 21:30:49 +0000  6921)       *this, Sema::ExpressionEvaluationContext::Unevaluated);
27381f3d93454 (Douglas Gregor           2009-11-23 12:27:39 +0000  6922) 
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  6923)   // Add this candidate
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  6924)   OverloadCandidate &Candidate =
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  6925)       CandidateSet.addCandidate(Args.size() + 1, EarlyConversions);
a0296f7987c0a (John McCall              2010-03-19 07:35:19 +0000  6926)   Candidate.FoundDecl = FoundDecl;
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  6927)   Candidate.Function = Method;
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  6928)   Candidate.RewriteKind =
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  6929)       CandidateSet.getRewriteInfo().getRewriteKind(Method, PO);
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  6930)   Candidate.IsSurrogate = false;
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000  6931)   Candidate.IgnoreObjectArgument = false;
b24b9aa298311 (Ahmed Charles            2012-02-25 11:00:22 +0000  6932)   Candidate.ExplicitCallArguments = Args.size();
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  6933) 
b3fd5cfa81b83 (Alp Toker                2014-01-21 00:32:38 +0000  6934)   unsigned NumParams = Proto->getNumParams();
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  6935) 
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  6936)   // (C++ 13.3.2p2): A candidate function having fewer than m
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  6937)   // parameters is viable only if it has an ellipsis in its parameter
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  6938)   // list (8.3.5).
975a9f6ecea60 (Francisco Lopes da Silva 2015-01-21 16:24:11 +0000  6939)   if (TooManyArguments(NumParams, Args.size(), PartialOverloading) &&
975a9f6ecea60 (Francisco Lopes da Silva 2015-01-21 16:24:11 +0000  6940)       !Proto->isVariadic()) {
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  6941)     Candidate.Viable = false;
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000  6942)     Candidate.FailureKind = ovl_fail_too_many_arguments;
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  6943)     return;
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  6944)   }
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  6945) 
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  6946)   // (C++ 13.3.2p2): A candidate function having more than m parameters
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  6947)   // is viable only if the (m+1)st parameter has a default argument
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  6948)   // (8.3.6). For the purposes of overload resolution, the
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  6949)   // parameter list is truncated on the right, so that there are
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  6950)   // exactly m parameters.
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  6951)   unsigned MinRequiredArgs = Method->getMinRequiredArguments();
975a9f6ecea60 (Francisco Lopes da Silva 2015-01-21 16:24:11 +0000  6952)   if (Args.size() < MinRequiredArgs && !PartialOverloading) {
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  6953)     // Not enough arguments.
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  6954)     Candidate.Viable = false;
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000  6955)     Candidate.FailureKind = ovl_fail_too_few_arguments;
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  6956)     return;
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  6957)   }
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  6958) 
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  6959)   Candidate.Viable = true;
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  6960) 
6e9f8f6374349 (John McCall              2009-12-03 04:06:58 +0000  6961)   if (Method->isStatic() || ObjectType.isNull())
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000  6962)     // The implicit object argument is ignored.
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000  6963)     Candidate.IgnoreObjectArgument = true;
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000  6964)   else {
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  6965)     unsigned ConvIdx = PO == OverloadCandidateParamOrder::Reversed ? 1 : 0;
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000  6966)     // Determine the implicit conversion sequence for the object
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000  6967)     // parameter.
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  6968)     Candidate.Conversions[ConvIdx] = TryObjectArgumentInitialization(
0f59cb38e7f31 (Richard Smith            2015-12-18 21:45:41 +0000  6969)         *this, CandidateSet.getLocation(), ObjectType, ObjectClassification,
0f59cb38e7f31 (Richard Smith            2015-12-18 21:45:41 +0000  6970)         Method, ActingContext);
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  6971)     if (Candidate.Conversions[ConvIdx].isBad()) {
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000  6972)       Candidate.Viable = false;
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000  6973)       Candidate.FailureKind = ovl_fail_bad_conversion;
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000  6974)       return;
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000  6975)     }
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  6976)   }
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  6977) 
291a57e2c22b6 (Eli Bendersky            2014-09-25 23:59:08 +0000  6978)   // (CUDA B.1): Check for invalid calls between targets.
291a57e2c22b6 (Eli Bendersky            2014-09-25 23:59:08 +0000  6979)   if (getLangOpts().CUDA)
291a57e2c22b6 (Eli Bendersky            2014-09-25 23:59:08 +0000  6980)     if (const FunctionDecl *Caller = dyn_cast<FunctionDecl>(CurContext))
b008003aa3f0d (Justin Lebar             2016-08-10 01:09:11 +0000  6981)       if (!IsAllowedCUDACall(Caller, Method)) {
291a57e2c22b6 (Eli Bendersky            2014-09-25 23:59:08 +0000  6982)         Candidate.Viable = false;
291a57e2c22b6 (Eli Bendersky            2014-09-25 23:59:08 +0000  6983)         Candidate.FailureKind = ovl_fail_bad_target;
291a57e2c22b6 (Eli Bendersky            2014-09-25 23:59:08 +0000  6984)         return;
291a57e2c22b6 (Eli Bendersky            2014-09-25 23:59:08 +0000  6985)       }
291a57e2c22b6 (Eli Bendersky            2014-09-25 23:59:08 +0000  6986) 
713562f54858f (Saar Raz                 2020-01-25 22:54:27 +0200  6987)   if (Method->getTrailingRequiresClause()) {
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  6988)     ConstraintSatisfaction Satisfaction;
713562f54858f (Saar Raz                 2020-01-25 22:54:27 +0200  6989)     if (CheckFunctionConstraints(Method, Satisfaction) ||
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  6990)         !Satisfaction.IsSatisfied) {
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  6991)       Candidate.Viable = false;
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  6992)       Candidate.FailureKind = ovl_fail_constraints_not_satisfied;
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  6993)       return;
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  6994)     }
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  6995)   }
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  6996) 
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  6997)   // Determine the implicit conversion sequences for each of the
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  6998)   // arguments.
b24b9aa298311 (Ahmed Charles            2012-02-25 11:00:22 +0000  6999)   for (unsigned ArgIdx = 0; ArgIdx < Args.size(); ++ArgIdx) {
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7000)     unsigned ConvIdx =
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7001)         PO == OverloadCandidateParamOrder::Reversed ? 0 : (ArgIdx + 1);
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7002)     if (Candidate.Conversions[ConvIdx].isInitialized()) {
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7003)       // We already formed a conversion sequence for this parameter during
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7004)       // template argument deduction.
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7005)     } else if (ArgIdx < NumParams) {
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  7006)       // (C++ 13.3.2p3): for F to be a viable function, there shall
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  7007)       // exist for each argument an implicit conversion sequence
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  7008)       // (13.3.3.1) that converts that argument to the corresponding
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  7009)       // parameter of F.
9cacbabd33eea (Alp Toker                2014-01-20 20:26:09 +0000  7010)       QualType ParamType = Proto->getParamType(ArgIdx);
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7011)       Candidate.Conversions[ConvIdx]
cb13cfc878200 (Douglas Gregor           2010-04-16 17:51:22 +0000  7012)         = TryCopyInitialization(*this, Args[ArgIdx], ParamType,
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  7013)                                 SuppressUserConversions,
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  7014)                                 /*InOverloadResolution=*/true,
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  7015)                                 /*AllowObjCWritebackConversion=*/
bbafb8a745736 (David Blaikie            2012-03-11 07:00:24 +0000  7016)                                   getLangOpts().ObjCAutoRefCount);
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7017)       if (Candidate.Conversions[ConvIdx].isBad()) {
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  7018)         Candidate.Viable = false;
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000  7019)         Candidate.FailureKind = ovl_fail_bad_conversion;
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  7020)         return;
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  7021)       }
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  7022)     } else {
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  7023)       // (C++ 13.3.2p2): For the purposes of overload resolution, any
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  7024)       // argument for which there is no corresponding parameter is
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  7025)       // considered to "match the ellipsis" (C+ 13.3.3.1.3).
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7026)       Candidate.Conversions[ConvIdx].setEllipsis();
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  7027)     }
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  7028)   }
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  7029) 
0dfb43deb6d55 (Richard Smith            2020-05-28 15:02:18 -0700  7030)   if (EnableIfAttr *FailedAttr =
0dfb43deb6d55 (Richard Smith            2020-05-28 15:02:18 -0700  7031)           CheckEnableIf(Method, CandidateSet.getLocation(), Args, true)) {
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  7032)     Candidate.Viable = false;
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  7033)     Candidate.FailureKind = ovl_fail_enable_if;
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  7034)     Candidate.DeductionFailure.Data = FailedAttr;
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  7035)     return;
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  7036)   }
281d20b601c8a (Erich Keane              2018-01-08 21:34:17 +0000  7037) 
3efe00206f0f4 (Erich Keane              2018-07-20 14:13:28 +0000  7038)   if (Method->isMultiVersion() && Method->hasAttr<TargetAttr>() &&
281d20b601c8a (Erich Keane              2018-01-08 21:34:17 +0000  7039)       !Method->getAttr<TargetAttr>()->isDefaultVersion()) {
281d20b601c8a (Erich Keane              2018-01-08 21:34:17 +0000  7040)     Candidate.Viable = false;
281d20b601c8a (Erich Keane              2018-01-08 21:34:17 +0000  7041)     Candidate.FailureKind = ovl_non_default_multiversion_function;
281d20b601c8a (Erich Keane              2018-01-08 21:34:17 +0000  7042)   }
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  7043) }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  7044) 
9fc8faf9e6197 (Adrian Prantl            2018-05-09 01:00:01 +0000  7045) /// Add a C++ member function template as a candidate to the candidate
97628d6a4ce22 (Douglas Gregor           2009-08-21 00:16:32 +0000  7046) /// set, using template argument deduction to produce an appropriate member
97628d6a4ce22 (Douglas Gregor           2009-08-21 00:16:32 +0000  7047) /// function template specialization.
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7048) void Sema::AddMethodTemplateCandidate(
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7049)     FunctionTemplateDecl *MethodTmpl, DeclAccessPair FoundDecl,
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7050)     CXXRecordDecl *ActingContext,
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7051)     TemplateArgumentListInfo *ExplicitTemplateArgs, QualType ObjectType,
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7052)     Expr::Classification ObjectClassification, ArrayRef<Expr *> Args,
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7053)     OverloadCandidateSet &CandidateSet, bool SuppressUserConversions,
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7054)     bool PartialOverloading, OverloadCandidateParamOrder PO) {
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7055)   if (!CandidateSet.isNewCandidate(MethodTmpl, PO))
5b0f2a2fbe3ac (Douglas Gregor           2009-09-28 04:47:19 +0000  7056)     return;
5b0f2a2fbe3ac (Douglas Gregor           2009-09-28 04:47:19 +0000  7057) 
97628d6a4ce22 (Douglas Gregor           2009-08-21 00:16:32 +0000  7058)   // C++ [over.match.funcs]p7:
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  7059)   //   In each case where a candidate is a function template, candidate
97628d6a4ce22 (Douglas Gregor           2009-08-21 00:16:32 +0000  7060)   //   function template specializations are generated using template argument
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  7061)   //   deduction (14.8.3, 14.8.2). Those candidates are then handled as
97628d6a4ce22 (Douglas Gregor           2009-08-21 00:16:32 +0000  7062)   //   candidate functions in the usual way.113) A given name can refer to one
97628d6a4ce22 (Douglas Gregor           2009-08-21 00:16:32 +0000  7063)   //   or more function templates and also to a set of overloaded non-template
97628d6a4ce22 (Douglas Gregor           2009-08-21 00:16:32 +0000  7064)   //   functions. In such a case, the candidate functions generated from each
97628d6a4ce22 (Douglas Gregor           2009-08-21 00:16:32 +0000  7065)   //   function template are combined with the set of non-template candidate
97628d6a4ce22 (Douglas Gregor           2009-08-21 00:16:32 +0000  7066)   //   functions.
e6706e40bb692 (Craig Topper             2012-09-19 02:26:47 +0000  7067)   TemplateDeductionInfo Info(CandidateSet.getLocation());
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000  7068)   FunctionDecl *Specialization = nullptr;
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7069)   ConversionSequenceList Conversions;
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7070)   if (TemplateDeductionResult Result = DeduceTemplateArguments(
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7071)           MethodTmpl, ExplicitTemplateArgs, Args, Specialization, Info,
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7072)           PartialOverloading, [&](ArrayRef<QualType> ParamTypes) {
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7073)             return CheckNonDependentConversions(
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7074)                 MethodTmpl, ParamTypes, Args, CandidateSet, Conversions,
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7075)                 SuppressUserConversions, ActingContext, ObjectType,
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7076)                 ObjectClassification, PO);
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7077)           })) {
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7078)     OverloadCandidate &Candidate =
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7079)         CandidateSet.addCandidate(Conversions.size(), Conversions);
90cf2c98bbca9 (Douglas Gregor           2010-05-08 20:18:54 +0000  7080)     Candidate.FoundDecl = FoundDecl;
90cf2c98bbca9 (Douglas Gregor           2010-05-08 20:18:54 +0000  7081)     Candidate.Function = MethodTmpl->getTemplatedDecl();
90cf2c98bbca9 (Douglas Gregor           2010-05-08 20:18:54 +0000  7082)     Candidate.Viable = false;
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7083)     Candidate.RewriteKind =
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7084)       CandidateSet.getRewriteInfo().getRewriteKind(Candidate.Function, PO);
90cf2c98bbca9 (Douglas Gregor           2010-05-08 20:18:54 +0000  7085)     Candidate.IsSurrogate = false;
9d05e15c3a26c (Richard Smith            2017-01-10 20:52:50 +0000  7086)     Candidate.IgnoreObjectArgument =
9d05e15c3a26c (Richard Smith            2017-01-10 20:52:50 +0000  7087)         cast<CXXMethodDecl>(Candidate.Function)->isStatic() ||
9d05e15c3a26c (Richard Smith            2017-01-10 20:52:50 +0000  7088)         ObjectType.isNull();
b24b9aa298311 (Ahmed Charles            2012-02-25 11:00:22 +0000  7089)     Candidate.ExplicitCallArguments = Args.size();
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7090)     if (Result == TDK_NonDependentConversionFailure)
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7091)       Candidate.FailureKind = ovl_fail_bad_conversion;
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7092)     else {
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7093)       Candidate.FailureKind = ovl_fail_bad_deduction;
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7094)       Candidate.DeductionFailure = MakeDeductionFailureInfo(Context, Result,
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7095)                                                             Info);
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7096)     }
90cf2c98bbca9 (Douglas Gregor           2010-05-08 20:18:54 +0000  7097)     return;
90cf2c98bbca9 (Douglas Gregor           2010-05-08 20:18:54 +0000  7098)   }
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  7099) 
97628d6a4ce22 (Douglas Gregor           2009-08-21 00:16:32 +0000  7100)   // Add the function template specialization produced by template argument
97628d6a4ce22 (Douglas Gregor           2009-08-21 00:16:32 +0000  7101)   // deduction as a candidate.
97628d6a4ce22 (Douglas Gregor           2009-08-21 00:16:32 +0000  7102)   assert(Specialization && "Missing member function template specialization?");
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  7103)   assert(isa<CXXMethodDecl>(Specialization) &&
97628d6a4ce22 (Douglas Gregor           2009-08-21 00:16:32 +0000  7104)          "Specialization is not a member function?");
a0296f7987c0a (John McCall              2010-03-19 07:35:19 +0000  7105)   AddMethodCandidate(cast<CXXMethodDecl>(Specialization), FoundDecl,
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  7106)                      ActingContext, ObjectType, ObjectClassification, Args,
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  7107)                      CandidateSet, SuppressUserConversions, PartialOverloading,
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7108)                      Conversions, PO);
97628d6a4ce22 (Douglas Gregor           2009-08-21 00:16:32 +0000  7109) }
97628d6a4ce22 (Douglas Gregor           2009-08-21 00:16:32 +0000  7110) 
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  7111) /// Determine whether a given function template has a simple explicit specifier
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  7112) /// or a non-value-dependent explicit-specification that evaluates to true.
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  7113) static bool isNonDependentlyExplicit(FunctionTemplateDecl *FTD) {
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  7114)   return ExplicitSpecifier::getFromDecl(FTD->getTemplatedDecl()).isExplicit();
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  7115) }
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  7116) 
9fc8faf9e6197 (Adrian Prantl            2018-05-09 01:00:01 +0000  7117) /// Add a C++ function template specialization as a candidate
05155d8d7b215 (Douglas Gregor           2009-08-21 23:19:43 +0000  7118) /// in the candidate set, using template argument deduction to produce
05155d8d7b215 (Douglas Gregor           2009-08-21 23:19:43 +0000  7119) /// an appropriate function template specialization.
5cdc2cda28ac8 (Eric Fiselier            2018-12-12 21:50:55 +0000  7120) void Sema::AddTemplateOverloadCandidate(
5cdc2cda28ac8 (Eric Fiselier            2018-12-12 21:50:55 +0000  7121)     FunctionTemplateDecl *FunctionTemplate, DeclAccessPair FoundDecl,
5cdc2cda28ac8 (Eric Fiselier            2018-12-12 21:50:55 +0000  7122)     TemplateArgumentListInfo *ExplicitTemplateArgs, ArrayRef<Expr *> Args,
5cdc2cda28ac8 (Eric Fiselier            2018-12-12 21:50:55 +0000  7123)     OverloadCandidateSet &CandidateSet, bool SuppressUserConversions,
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7124)     bool PartialOverloading, bool AllowExplicit, ADLCallKind IsADLCandidate,
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7125)     OverloadCandidateParamOrder PO) {
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7126)   if (!CandidateSet.isNewCandidate(FunctionTemplate, PO))
5b0f2a2fbe3ac (Douglas Gregor           2009-09-28 04:47:19 +0000  7127)     return;
5b0f2a2fbe3ac (Douglas Gregor           2009-09-28 04:47:19 +0000  7128) 
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  7129)   // If the function template has a non-dependent explicit specification,
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  7130)   // exclude it now if appropriate; we are not permitted to perform deduction
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  7131)   // and substitution in this case.
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  7132)   if (!AllowExplicit && isNonDependentlyExplicit(FunctionTemplate)) {
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  7133)     OverloadCandidate &Candidate = CandidateSet.addCandidate();
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  7134)     Candidate.FoundDecl = FoundDecl;
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  7135)     Candidate.Function = FunctionTemplate->getTemplatedDecl();
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  7136)     Candidate.Viable = false;
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  7137)     Candidate.FailureKind = ovl_fail_explicit;
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  7138)     return;
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  7139)   }
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  7140) 
ad3f2fcf43eb7 (Douglas Gregor           2009-06-25 22:08:12 +0000  7141)   // C++ [over.match.funcs]p7:
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  7142)   //   In each case where a candidate is a function template, candidate
ad3f2fcf43eb7 (Douglas Gregor           2009-06-25 22:08:12 +0000  7143)   //   function template specializations are generated using template argument
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  7144)   //   deduction (14.8.3, 14.8.2). Those candidates are then handled as
ad3f2fcf43eb7 (Douglas Gregor           2009-06-25 22:08:12 +0000  7145)   //   candidate functions in the usual way.113) A given name can refer to one
ad3f2fcf43eb7 (Douglas Gregor           2009-06-25 22:08:12 +0000  7146)   //   or more function templates and also to a set of overloaded non-template
ad3f2fcf43eb7 (Douglas Gregor           2009-06-25 22:08:12 +0000  7147)   //   functions. In such a case, the candidate functions generated from each
ad3f2fcf43eb7 (Douglas Gregor           2009-06-25 22:08:12 +0000  7148)   //   function template are combined with the set of non-template candidate
ad3f2fcf43eb7 (Douglas Gregor           2009-06-25 22:08:12 +0000  7149)   //   functions.
e6706e40bb692 (Craig Topper             2012-09-19 02:26:47 +0000  7150)   TemplateDeductionInfo Info(CandidateSet.getLocation());
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000  7151)   FunctionDecl *Specialization = nullptr;
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7152)   ConversionSequenceList Conversions;
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7153)   if (TemplateDeductionResult Result = DeduceTemplateArguments(
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7154)           FunctionTemplate, ExplicitTemplateArgs, Args, Specialization, Info,
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7155)           PartialOverloading, [&](ArrayRef<QualType> ParamTypes) {
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7156)             return CheckNonDependentConversions(
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7157)                 FunctionTemplate, ParamTypes, Args, CandidateSet, Conversions,
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7158)                 SuppressUserConversions, nullptr, QualType(), {}, PO);
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7159)           })) {
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7160)     OverloadCandidate &Candidate =
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7161)         CandidateSet.addCandidate(Conversions.size(), Conversions);
a0296f7987c0a (John McCall              2010-03-19 07:35:19 +0000  7162)     Candidate.FoundDecl = FoundDecl;
d681c3959f85b (John McCall              2009-12-16 08:11:27 +0000  7163)     Candidate.Function = FunctionTemplate->getTemplatedDecl();
d681c3959f85b (John McCall              2009-12-16 08:11:27 +0000  7164)     Candidate.Viable = false;
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7165)     Candidate.RewriteKind =
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7166)       CandidateSet.getRewriteInfo().getRewriteKind(Candidate.Function, PO);
d681c3959f85b (John McCall              2009-12-16 08:11:27 +0000  7167)     Candidate.IsSurrogate = false;
5cdc2cda28ac8 (Eric Fiselier            2018-12-12 21:50:55 +0000  7168)     Candidate.IsADLCandidate = IsADLCandidate;
9d05e15c3a26c (Richard Smith            2017-01-10 20:52:50 +0000  7169)     // Ignore the object argument if there is one, since we don't have an object
9d05e15c3a26c (Richard Smith            2017-01-10 20:52:50 +0000  7170)     // type.
9d05e15c3a26c (Richard Smith            2017-01-10 20:52:50 +0000  7171)     Candidate.IgnoreObjectArgument =
9d05e15c3a26c (Richard Smith            2017-01-10 20:52:50 +0000  7172)         isa<CXXMethodDecl>(Candidate.Function) &&
9d05e15c3a26c (Richard Smith            2017-01-10 20:52:50 +0000  7173)         !isa<CXXConstructorDecl>(Candidate.Function);
b24b9aa298311 (Ahmed Charles            2012-02-25 11:00:22 +0000  7174)     Candidate.ExplicitCallArguments = Args.size();
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7175)     if (Result == TDK_NonDependentConversionFailure)
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7176)       Candidate.FailureKind = ovl_fail_bad_conversion;
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7177)     else {
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7178)       Candidate.FailureKind = ovl_fail_bad_deduction;
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7179)       Candidate.DeductionFailure = MakeDeductionFailureInfo(Context, Result,
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7180)                                                             Info);
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7181)     }
ad3f2fcf43eb7 (Douglas Gregor           2009-06-25 22:08:12 +0000  7182)     return;
ad3f2fcf43eb7 (Douglas Gregor           2009-06-25 22:08:12 +0000  7183)   }
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  7184) 
ad3f2fcf43eb7 (Douglas Gregor           2009-06-25 22:08:12 +0000  7185)   // Add the function template specialization produced by template argument
ad3f2fcf43eb7 (Douglas Gregor           2009-06-25 22:08:12 +0000  7186)   // deduction as a candidate.
ad3f2fcf43eb7 (Douglas Gregor           2009-06-25 22:08:12 +0000  7187)   assert(Specialization && "Missing function template specialization?");
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000  7188)   AddOverloadCandidate(
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000  7189)       Specialization, FoundDecl, Args, CandidateSet, SuppressUserConversions,
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000  7190)       PartialOverloading, AllowExplicit,
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7191)       /*AllowExplicitConversions*/ false, IsADLCandidate, Conversions, PO);
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7192) }
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7193) 
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7194) /// Check that implicit conversion sequences can be formed for each argument
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7195) /// whose corresponding parameter has a non-dependent type, per DR1391's
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7196) /// [temp.deduct.call]p10.
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7197) bool Sema::CheckNonDependentConversions(
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7198)     FunctionTemplateDecl *FunctionTemplate, ArrayRef<QualType> ParamTypes,
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7199)     ArrayRef<Expr *> Args, OverloadCandidateSet &CandidateSet,
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7200)     ConversionSequenceList &Conversions, bool SuppressUserConversions,
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7201)     CXXRecordDecl *ActingContext, QualType ObjectType,
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7202)     Expr::Classification ObjectClassification, OverloadCandidateParamOrder PO) {
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7203)   // FIXME: The cases in which we allow explicit conversions for constructor
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7204)   // arguments never consider calling a constructor template. It's not clear
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7205)   // that is correct.
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7206)   const bool AllowExplicit = false;
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7207) 
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7208)   auto *FD = FunctionTemplate->getTemplatedDecl();
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7209)   auto *Method = dyn_cast<CXXMethodDecl>(FD);
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7210)   bool HasThisConversion = Method && !isa<CXXConstructorDecl>(Method);
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7211)   unsigned ThisConversions = HasThisConversion ? 1 : 0;
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7212) 
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7213)   Conversions =
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7214)       CandidateSet.allocateConversionSequences(ThisConversions + Args.size());
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7215) 
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7216)   // Overload resolution is always an unevaluated context.
d143a0c2de131 (Faisal Vali              2017-04-01 21:30:49 +0000  7217)   EnterExpressionEvaluationContext Unevaluated(
d143a0c2de131 (Faisal Vali              2017-04-01 21:30:49 +0000  7218)       *this, Sema::ExpressionEvaluationContext::Unevaluated);
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7219) 
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7220)   // For a method call, check the 'this' conversion here too. DR1391 doesn't
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7221)   // require that, but this check should never result in a hard error, and
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7222)   // overload resolution is permitted to sidestep instantiations.
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7223)   if (HasThisConversion && !cast<CXXMethodDecl>(FD)->isStatic() &&
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7224)       !ObjectType.isNull()) {
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7225)     unsigned ConvIdx = PO == OverloadCandidateParamOrder::Reversed ? 1 : 0;
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7226)     Conversions[ConvIdx] = TryObjectArgumentInitialization(
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7227)         *this, CandidateSet.getLocation(), ObjectType, ObjectClassification,
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7228)         Method, ActingContext);
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7229)     if (Conversions[ConvIdx].isBad())
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7230)       return true;
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7231)   }
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7232) 
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7233)   for (unsigned I = 0, N = std::min(ParamTypes.size(), Args.size()); I != N;
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7234)        ++I) {
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7235)     QualType ParamType = ParamTypes[I];
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7236)     if (!ParamType->isDependentType()) {
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7237)       unsigned ConvIdx = PO == OverloadCandidateParamOrder::Reversed
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7238)                              ? 0
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7239)                              : (ThisConversions + I);
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7240)       Conversions[ConvIdx]
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7241)         = TryCopyInitialization(*this, Args[I], ParamType,
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7242)                                 SuppressUserConversions,
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7243)                                 /*InOverloadResolution=*/true,
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7244)                                 /*AllowObjCWritebackConversion=*/
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7245)                                   getLangOpts().ObjCAutoRefCount,
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7246)                                 AllowExplicit);
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7247)       if (Conversions[ConvIdx].isBad())
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7248)         return true;
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7249)     }
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7250)   }
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7251) 
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  7252)   return false;
ad3f2fcf43eb7 (Douglas Gregor           2009-06-25 22:08:12 +0000  7253) }
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  7254) 
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  7255) /// Determine whether this is an allowable conversion from the result
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  7256) /// of an explicit conversion operator to the expected type, per C++
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  7257) /// [over.match.conv]p1 and [over.match.ref]p1.
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  7258) ///
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  7259) /// \param ConvType The return type of the conversion function.
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  7260) ///
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  7261) /// \param ToType The type we are converting to.
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  7262) ///
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  7263) /// \param AllowObjCPointerConversion Allow a conversion from one
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  7264) /// Objective-C pointer to another.
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  7265) ///
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  7266) /// \returns true if the conversion is allowable, false otherwise.
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  7267) static bool isAllowableExplicitConversion(Sema &S,
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  7268)                                           QualType ConvType, QualType ToType,
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  7269)                                           bool AllowObjCPointerConversion) {
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  7270)   QualType ToNonRefType = ToType.getNonReferenceType();
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  7271) 
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  7272)   // Easy case: the types are the same.
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  7273)   if (S.Context.hasSameUnqualifiedType(ConvType, ToNonRefType))
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  7274)     return true;
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  7275) 
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  7276)   // Allow qualification conversions.
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  7277)   bool ObjCLifetimeConversion;
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  7278)   if (S.IsQualificationConversion(ConvType, ToNonRefType, /*CStyle*/false,
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  7279)                                   ObjCLifetimeConversion))
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  7280)     return true;
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  7281) 
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  7282)   // If we're not allowed to consider Objective-C pointer conversions,
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  7283)   // we're done.
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  7284)   if (!AllowObjCPointerConversion)
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  7285)     return false;
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  7286) 
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  7287)   // Is this an Objective-C pointer conversion?
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  7288)   bool IncompatibleObjC = false;
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  7289)   QualType ConvertedType;
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  7290)   return S.isObjCPointerConversion(ConvType, ToNonRefType, ConvertedType,
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  7291)                                    IncompatibleObjC);
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  7292) }
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  7293) 
a1f013e8edb82 (Douglas Gregor           2008-11-07 22:36:19 +0000  7294) /// AddConversionCandidate - Add a C++ conversion function as a
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  7295) /// candidate in the candidate set (C++ [over.match.conv],
a1f013e8edb82 (Douglas Gregor           2008-11-07 22:36:19 +0000  7296) /// C++ [over.match.copy]). From is the expression we're converting from,
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  7297) /// and ToType is the type that we're eventually trying to convert to
a1f013e8edb82 (Douglas Gregor           2008-11-07 22:36:19 +0000  7298) /// (which may or may not be the same type as the type that the
a1f013e8edb82 (Douglas Gregor           2008-11-07 22:36:19 +0000  7299) /// conversion function produces).
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000  7300) void Sema::AddConversionCandidate(
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000  7301)     CXXConversionDecl *Conversion, DeclAccessPair FoundDecl,
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000  7302)     CXXRecordDecl *ActingContext, Expr *From, QualType ToType,
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000  7303)     OverloadCandidateSet &CandidateSet, bool AllowObjCConversionOnExplicit,
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000  7304)     bool AllowExplicit, bool AllowResultConversion) {
05155d8d7b215 (Douglas Gregor           2009-08-21 23:19:43 +0000  7305)   assert(!Conversion->getDescribedFunctionTemplate() &&
05155d8d7b215 (Douglas Gregor           2009-08-21 23:19:43 +0000  7306)          "Conversion function templates use AddTemplateConversionCandidate");
5ab116553171e (Douglas Gregor           2010-04-17 22:01:05 +0000  7307)   QualType ConvType = Conversion->getConversionType().getNonReferenceType();
5b0f2a2fbe3ac (Douglas Gregor           2009-09-28 04:47:19 +0000  7308)   if (!CandidateSet.isNewCandidate(Conversion))
5b0f2a2fbe3ac (Douglas Gregor           2009-09-28 04:47:19 +0000  7309)     return;
5b0f2a2fbe3ac (Douglas Gregor           2009-09-28 04:47:19 +0000  7310) 
2a7d481faf546 (Richard Smith            2013-05-04 07:00:32 +0000  7311)   // If the conversion function has an undeduced return type, trigger its
2a7d481faf546 (Richard Smith            2013-05-04 07:00:32 +0000  7312)   // deduction now.
dd69ef38dba72 (Aaron Ballman            2014-08-19 15:55:55 +0000  7313)   if (getLangOpts().CPlusPlus14 && ConvType->isUndeducedType()) {
2a7d481faf546 (Richard Smith            2013-05-04 07:00:32 +0000  7314)     if (DeduceReturnType(Conversion, From->getExprLoc()))
2a7d481faf546 (Richard Smith            2013-05-04 07:00:32 +0000  7315)       return;
2a7d481faf546 (Richard Smith            2013-05-04 07:00:32 +0000  7316)     ConvType = Conversion->getConversionType().getNonReferenceType();
2a7d481faf546 (Richard Smith            2013-05-04 07:00:32 +0000  7317)   }
2a7d481faf546 (Richard Smith            2013-05-04 07:00:32 +0000  7318) 
67ef14fe486e1 (Richard Smith            2017-09-26 18:37:55 +0000  7319)   // If we don't allow any conversion of the result type, ignore conversion
67ef14fe486e1 (Richard Smith            2017-09-26 18:37:55 +0000  7320)   // functions that don't convert to exactly (possibly cv-qualified) T.
67ef14fe486e1 (Richard Smith            2017-09-26 18:37:55 +0000  7321)   if (!AllowResultConversion &&
67ef14fe486e1 (Richard Smith            2017-09-26 18:37:55 +0000  7322)       !Context.hasSameUnqualifiedType(Conversion->getConversionType(), ToType))
67ef14fe486e1 (Richard Smith            2017-09-26 18:37:55 +0000  7323)     return;
67ef14fe486e1 (Richard Smith            2017-09-26 18:37:55 +0000  7324) 
089c31637f86a (Richard Smith            2013-09-21 21:55:46 +0000  7325)   // Per C++ [over.match.conv]p1, [over.match.ref]p1, an explicit conversion
089c31637f86a (Richard Smith            2013-09-21 21:55:46 +0000  7326)   // operator is only a candidate if its return type is the target type or
089c31637f86a (Richard Smith            2013-09-21 21:55:46 +0000  7327)   // can be converted to the target type with a qualification conversion.
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  7328)   //
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  7329)   // FIXME: Include such functions in the candidate list and explain why we
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  7330)   // can't select them.
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  7331)   if (Conversion->isExplicit() &&
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  7332)       !isAllowableExplicitConversion(*this, ConvType, ToType,
4b60a1594d2c6 (Douglas Gregor           2013-11-07 22:34:54 +0000  7333)                                      AllowObjCConversionOnExplicit))
089c31637f86a (Richard Smith            2013-09-21 21:55:46 +0000  7334)     return;
089c31637f86a (Richard Smith            2013-09-21 21:55:46 +0000  7335) 
27381f3d93454 (Douglas Gregor           2009-11-23 12:27:39 +0000  7336)   // Overload resolution is always an unevaluated context.
d143a0c2de131 (Faisal Vali              2017-04-01 21:30:49 +0000  7337)   EnterExpressionEvaluationContext Unevaluated(
d143a0c2de131 (Faisal Vali              2017-04-01 21:30:49 +0000  7338)       *this, Sema::ExpressionEvaluationContext::Unevaluated);
27381f3d93454 (Douglas Gregor           2009-11-23 12:27:39 +0000  7339) 
a1f013e8edb82 (Douglas Gregor           2008-11-07 22:36:19 +0000  7340)   // Add this candidate
fb761ff54452f (Benjamin Kramer          2012-01-14 16:31:55 +0000  7341)   OverloadCandidate &Candidate = CandidateSet.addCandidate(1);
a0296f7987c0a (John McCall              2010-03-19 07:35:19 +0000  7342)   Candidate.FoundDecl = FoundDecl;
a1f013e8edb82 (Douglas Gregor           2008-11-07 22:36:19 +0000  7343)   Candidate.Function = Conversion;
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7344)   Candidate.IsSurrogate = false;
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000  7345)   Candidate.IgnoreObjectArgument = false;
a1f013e8edb82 (Douglas Gregor           2008-11-07 22:36:19 +0000  7346)   Candidate.FinalConversion.setAsIdentityConversion();
5ab116553171e (Douglas Gregor           2010-04-17 22:01:05 +0000  7347)   Candidate.FinalConversion.setFromType(ConvType);
3edc4d5ec3fdc (Douglas Gregor           2010-01-27 03:51:04 +0000  7348)   Candidate.FinalConversion.setAllToTypes(ToType);
a1f013e8edb82 (Douglas Gregor           2008-11-07 22:36:19 +0000  7349)   Candidate.Viable = true;
6edd977c6f368 (Douglas Gregor           2011-01-19 23:54:39 +0000  7350)   Candidate.ExplicitCallArguments = 1;
c9ed4681a8511 (Douglas Gregor           2010-08-19 15:57:50 +0000  7351) 
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  7352)   // Explicit functions are not actually candidates at all if we're not
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  7353)   // allowing them in this context, but keep them around so we can point
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  7354)   // to them in diagnostics.
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  7355)   if (!AllowExplicit && Conversion->isExplicit()) {
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  7356)     Candidate.Viable = false;
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  7357)     Candidate.FailureKind = ovl_fail_explicit;
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  7358)     return;
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  7359)   }
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  7360) 
6affc78f1b43b (Douglas Gregor           2010-08-19 15:37:02 +0000  7361)   // C++ [over.match.funcs]p4:
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  7362)   //   For conversion functions, the function is considered to be a member of
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  7363)   //   the class of the implicit implied object argument for the purpose of
6affc78f1b43b (Douglas Gregor           2010-08-19 15:37:02 +0000  7364)   //   defining the type of the implicit object parameter.
c9ed4681a8511 (Douglas Gregor           2010-08-19 15:57:50 +0000  7365)   //
c9ed4681a8511 (Douglas Gregor           2010-08-19 15:57:50 +0000  7366)   // Determine the implicit conversion sequence for the implicit
c9ed4681a8511 (Douglas Gregor           2010-08-19 15:57:50 +0000  7367)   // object parameter.
c9ed4681a8511 (Douglas Gregor           2010-08-19 15:57:50 +0000  7368)   QualType ImplicitParamType = From->getType();
c9ed4681a8511 (Douglas Gregor           2010-08-19 15:57:50 +0000  7369)   if (const PointerType *FromPtrType = ImplicitParamType->getAs<PointerType>())
c9ed4681a8511 (Douglas Gregor           2010-08-19 15:57:50 +0000  7370)     ImplicitParamType = FromPtrType->getPointeeType();
c9ed4681a8511 (Douglas Gregor           2010-08-19 15:57:50 +0000  7371)   CXXRecordDecl *ConversionContext
ed3b68e0dc3c0 (Simon Pilgrim            2019-10-02 14:02:27 +0000  7372)     = cast<CXXRecordDecl>(ImplicitParamType->castAs<RecordType>()->getDecl());
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  7373) 
0f59cb38e7f31 (Richard Smith            2015-12-18 21:45:41 +0000  7374)   Candidate.Conversions[0] = TryObjectArgumentInitialization(
0f59cb38e7f31 (Richard Smith            2015-12-18 21:45:41 +0000  7375)       *this, CandidateSet.getLocation(), From->getType(),
0f59cb38e7f31 (Richard Smith            2015-12-18 21:45:41 +0000  7376)       From->Classify(Context), Conversion, ConversionContext);
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  7377) 
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000  7378)   if (Candidate.Conversions[0].isBad()) {
a1f013e8edb82 (Douglas Gregor           2008-11-07 22:36:19 +0000  7379)     Candidate.Viable = false;
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000  7380)     Candidate.FailureKind = ovl_fail_bad_conversion;
a1f013e8edb82 (Douglas Gregor           2008-11-07 22:36:19 +0000  7381)     return;
a1f013e8edb82 (Douglas Gregor           2008-11-07 22:36:19 +0000  7382)   }
c9ed4681a8511 (Douglas Gregor           2010-08-19 15:57:50 +0000  7383) 
713562f54858f (Saar Raz                 2020-01-25 22:54:27 +0200  7384)   if (Conversion->getTrailingRequiresClause()) {
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  7385)     ConstraintSatisfaction Satisfaction;
713562f54858f (Saar Raz                 2020-01-25 22:54:27 +0200  7386)     if (CheckFunctionConstraints(Conversion, Satisfaction) ||
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  7387)         !Satisfaction.IsSatisfied) {
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  7388)       Candidate.Viable = false;
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  7389)       Candidate.FailureKind = ovl_fail_constraints_not_satisfied;
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  7390)       return;
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  7391)     }
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  7392)   }
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  7393) 
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  7394)   // We won't go through a user-defined type conversion function to convert a
996a6aa3f18c3 (Fariborz Jahanian        2009-10-19 19:18:20 +0000  7395)   // derived to base as such conversions are given Conversion Rank. They only
996a6aa3f18c3 (Fariborz Jahanian        2009-10-19 19:18:20 +0000  7396)   // go through a copy constructor. 13.3.3.1.2-p4 [over.ics.user]
996a6aa3f18c3 (Fariborz Jahanian        2009-10-19 19:18:20 +0000  7397)   QualType FromCanon
996a6aa3f18c3 (Fariborz Jahanian        2009-10-19 19:18:20 +0000  7398)     = Context.getCanonicalType(From->getType().getUnqualifiedType());
996a6aa3f18c3 (Fariborz Jahanian        2009-10-19 19:18:20 +0000  7399)   QualType ToCanon = Context.getCanonicalType(ToType).getUnqualifiedType();
0f59cb38e7f31 (Richard Smith            2015-12-18 21:45:41 +0000  7400)   if (FromCanon == ToCanon ||
0f59cb38e7f31 (Richard Smith            2015-12-18 21:45:41 +0000  7401)       IsDerivedFrom(CandidateSet.getLocation(), FromCanon, ToCanon)) {
996a6aa3f18c3 (Fariborz Jahanian        2009-10-19 19:18:20 +0000  7402)     Candidate.Viable = false;
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000  7403)     Candidate.FailureKind = ovl_fail_trivial_conversion;
996a6aa3f18c3 (Fariborz Jahanian        2009-10-19 19:18:20 +0000  7404)     return;
996a6aa3f18c3 (Fariborz Jahanian        2009-10-19 19:18:20 +0000  7405)   }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  7406) 
a1f013e8edb82 (Douglas Gregor           2008-11-07 22:36:19 +0000  7407)   // To determine what the conversion from the result of calling the
a1f013e8edb82 (Douglas Gregor           2008-11-07 22:36:19 +0000  7408)   // conversion function to the type we're eventually trying to
a1f013e8edb82 (Douglas Gregor           2008-11-07 22:36:19 +0000  7409)   // convert to (ToType), we need to synthesize a call to the
a1f013e8edb82 (Douglas Gregor           2008-11-07 22:36:19 +0000  7410)   // conversion function and attempt copy initialization from it. This
a1f013e8edb82 (Douglas Gregor           2008-11-07 22:36:19 +0000  7411)   // makes sure that we get the right semantics with respect to
a1f013e8edb82 (Douglas Gregor           2008-11-07 22:36:19 +0000  7412)   // lvalues/rvalues and the type. Fortunately, we can allocate this
a1f013e8edb82 (Douglas Gregor           2008-11-07 22:36:19 +0000  7413)   // call on the stack and we don't need its arguments to be
a1f013e8edb82 (Douglas Gregor           2008-11-07 22:36:19 +0000  7414)   // well-formed.
5fc4db75798c8 (Bruno Ricci              2018-12-21 14:10:18 +0000  7415)   DeclRefExpr ConversionRef(Context, Conversion, false, Conversion->getType(),
5fc4db75798c8 (Bruno Ricci              2018-12-21 14:10:18 +0000  7416)                             VK_LValue, From->getBeginLoc());
cf1421650953d (John McCall              2010-08-07 06:22:56 +0000  7417)   ImplicitCastExpr ConversionFn(ImplicitCastExpr::OnStack,
cf1421650953d (John McCall              2010-08-07 06:22:56 +0000  7418)                                 Context.getPointerType(Conversion->getType()),
f1cd6593da3ad (Serge Pavlov             2020-09-12 21:54:14 +0700  7419)                                 CK_FunctionToPointerDecay, &ConversionRef,
f1cd6593da3ad (Serge Pavlov             2020-09-12 21:54:14 +0700  7420)                                 VK_RValue, FPOptionsOverride());
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  7421) 
48d2464c3fd8b (Richard Smith            2011-07-13 22:53:21 +0000  7422)   QualType ConversionType = Conversion->getConversionType();
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000  7423)   if (!isCompleteType(From->getBeginLoc(), ConversionType)) {
72ebdabc5d60e (Douglas Gregor           2010-11-13 19:36:57 +0000  7424)     Candidate.Viable = false;
72ebdabc5d60e (Douglas Gregor           2010-11-13 19:36:57 +0000  7425)     Candidate.FailureKind = ovl_fail_bad_final_conversion;
72ebdabc5d60e (Douglas Gregor           2010-11-13 19:36:57 +0000  7426)     return;
72ebdabc5d60e (Douglas Gregor           2010-11-13 19:36:57 +0000  7427)   }
72ebdabc5d60e (Douglas Gregor           2010-11-13 19:36:57 +0000  7428) 
48d2464c3fd8b (Richard Smith            2011-07-13 22:53:21 +0000  7429)   ExprValueKind VK = Expr::getValueKindForType(ConversionType);
7decc9e4ea6c5 (John McCall              2010-11-18 06:31:45 +0000  7430) 
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  7431)   // Note that it is safe to allocate CallExpr on the stack here because
d7b4f40b18476 (Ted Kremenek             2009-02-09 20:51:47 +0000  7432)   // there are 0 arguments (i.e., nothing is allocated using ASTContext's
d7b4f40b18476 (Ted Kremenek             2009-02-09 20:51:47 +0000  7433)   // allocator).
48d2464c3fd8b (Richard Smith            2011-07-13 22:53:21 +0000  7434)   QualType CallResultType = ConversionType.getNonLValueExprType(Context);
c5885cffc5206 (Bruno Ricci              2018-12-21 15:20:32 +0000  7435) 
ac8686205b0b0 (JF Bastien               2019-07-29 23:12:48 +0000  7436)   alignas(CallExpr) char Buffer[sizeof(CallExpr) + sizeof(Stmt *)];
c5885cffc5206 (Bruno Ricci              2018-12-21 15:20:32 +0000  7437)   CallExpr *TheTemporaryCall = CallExpr::CreateTemporary(
ac8686205b0b0 (JF Bastien               2019-07-29 23:12:48 +0000  7438)       Buffer, &ConversionFn, CallResultType, VK, From->getBeginLoc());
c5885cffc5206 (Bruno Ricci              2018-12-21 15:20:32 +0000  7439) 
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  7440)   ImplicitConversionSequence ICS =
c5885cffc5206 (Bruno Ricci              2018-12-21 15:20:32 +0000  7441)       TryCopyInitialization(*this, TheTemporaryCall, ToType,
c5885cffc5206 (Bruno Ricci              2018-12-21 15:20:32 +0000  7442)                             /*SuppressUserConversions=*/true,
c5885cffc5206 (Bruno Ricci              2018-12-21 15:20:32 +0000  7443)                             /*InOverloadResolution=*/false,
c5885cffc5206 (Bruno Ricci              2018-12-21 15:20:32 +0000  7444)                             /*AllowObjCWritebackConversion=*/false);
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  7445) 
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000  7446)   switch (ICS.getKind()) {
a1f013e8edb82 (Douglas Gregor           2008-11-07 22:36:19 +0000  7447)   case ImplicitConversionSequence::StandardConversion:
a1f013e8edb82 (Douglas Gregor           2008-11-07 22:36:19 +0000  7448)     Candidate.FinalConversion = ICS.Standard;
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  7449) 
2c326bce387c8 (Douglas Gregor           2010-04-12 23:42:09 +0000  7450)     // C++ [over.ics.user]p3:
2c326bce387c8 (Douglas Gregor           2010-04-12 23:42:09 +0000  7451)     //   If the user-defined conversion is specified by a specialization of a
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  7452)     //   conversion function template, the second standard conversion sequence
2c326bce387c8 (Douglas Gregor           2010-04-12 23:42:09 +0000  7453)     //   shall have exact match rank.
2c326bce387c8 (Douglas Gregor           2010-04-12 23:42:09 +0000  7454)     if (Conversion->getPrimaryTemplate() &&
2c326bce387c8 (Douglas Gregor           2010-04-12 23:42:09 +0000  7455)         GetConversionRank(ICS.Standard.Second) != ICR_Exact_Match) {
2c326bce387c8 (Douglas Gregor           2010-04-12 23:42:09 +0000  7456)       Candidate.Viable = false;
2c326bce387c8 (Douglas Gregor           2010-04-12 23:42:09 +0000  7457)       Candidate.FailureKind = ovl_fail_final_conversion_not_exact;
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  7458)       return;
2c326bce387c8 (Douglas Gregor           2010-04-12 23:42:09 +0000  7459)     }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  7460) 
cba72b1f620fd (Douglas Gregor           2011-01-21 05:18:22 +0000  7461)     // C++0x [dcl.init.ref]p5:
cba72b1f620fd (Douglas Gregor           2011-01-21 05:18:22 +0000  7462)     //    In the second case, if the reference is an rvalue reference and
cba72b1f620fd (Douglas Gregor           2011-01-21 05:18:22 +0000  7463)     //    the second standard conversion sequence of the user-defined
cba72b1f620fd (Douglas Gregor           2011-01-21 05:18:22 +0000  7464)     //    conversion sequence includes an lvalue-to-rvalue conversion, the
cba72b1f620fd (Douglas Gregor           2011-01-21 05:18:22 +0000  7465)     //    program is ill-formed.
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  7466)     if (ToType->isRValueReferenceType() &&
cba72b1f620fd (Douglas Gregor           2011-01-21 05:18:22 +0000  7467)         ICS.Standard.First == ICK_Lvalue_To_Rvalue) {
cba72b1f620fd (Douglas Gregor           2011-01-21 05:18:22 +0000  7468)       Candidate.Viable = false;
cba72b1f620fd (Douglas Gregor           2011-01-21 05:18:22 +0000  7469)       Candidate.FailureKind = ovl_fail_bad_final_conversion;
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  7470)       return;
cba72b1f620fd (Douglas Gregor           2011-01-21 05:18:22 +0000  7471)     }
a1f013e8edb82 (Douglas Gregor           2008-11-07 22:36:19 +0000  7472)     break;
a1f013e8edb82 (Douglas Gregor           2008-11-07 22:36:19 +0000  7473) 
a1f013e8edb82 (Douglas Gregor           2008-11-07 22:36:19 +0000  7474)   case ImplicitConversionSequence::BadConversion:
a1f013e8edb82 (Douglas Gregor           2008-11-07 22:36:19 +0000  7475)     Candidate.Viable = false;
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000  7476)     Candidate.FailureKind = ovl_fail_bad_final_conversion;
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  7477)     return;
a1f013e8edb82 (Douglas Gregor           2008-11-07 22:36:19 +0000  7478) 
a1f013e8edb82 (Douglas Gregor           2008-11-07 22:36:19 +0000  7479)   default:
83d382b1cad13 (David Blaikie            2011-09-23 05:06:16 +0000  7480)     llvm_unreachable(
a1f013e8edb82 (Douglas Gregor           2008-11-07 22:36:19 +0000  7481)            "Can only end up with a standard conversion sequence or failure");
a1f013e8edb82 (Douglas Gregor           2008-11-07 22:36:19 +0000  7482)   }
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  7483) 
0dfb43deb6d55 (Richard Smith            2020-05-28 15:02:18 -0700  7484)   if (EnableIfAttr *FailedAttr =
0dfb43deb6d55 (Richard Smith            2020-05-28 15:02:18 -0700  7485)           CheckEnableIf(Conversion, CandidateSet.getLocation(), None)) {
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  7486)     Candidate.Viable = false;
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  7487)     Candidate.FailureKind = ovl_fail_enable_if;
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  7488)     Candidate.DeductionFailure.Data = FailedAttr;
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  7489)     return;
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  7490)   }
281d20b601c8a (Erich Keane              2018-01-08 21:34:17 +0000  7491) 
3efe00206f0f4 (Erich Keane              2018-07-20 14:13:28 +0000  7492)   if (Conversion->isMultiVersion() && Conversion->hasAttr<TargetAttr>() &&
281d20b601c8a (Erich Keane              2018-01-08 21:34:17 +0000  7493)       !Conversion->getAttr<TargetAttr>()->isDefaultVersion()) {
281d20b601c8a (Erich Keane              2018-01-08 21:34:17 +0000  7494)     Candidate.Viable = false;
281d20b601c8a (Erich Keane              2018-01-08 21:34:17 +0000  7495)     Candidate.FailureKind = ovl_non_default_multiversion_function;
281d20b601c8a (Erich Keane              2018-01-08 21:34:17 +0000  7496)   }
a1f013e8edb82 (Douglas Gregor           2008-11-07 22:36:19 +0000  7497) }
a1f013e8edb82 (Douglas Gregor           2008-11-07 22:36:19 +0000  7498) 
9fc8faf9e6197 (Adrian Prantl            2018-05-09 01:00:01 +0000  7499) /// Adds a conversion function template specialization
05155d8d7b215 (Douglas Gregor           2009-08-21 23:19:43 +0000  7500) /// candidate to the overload set, using template argument deduction
05155d8d7b215 (Douglas Gregor           2009-08-21 23:19:43 +0000  7501) /// to deduce the template arguments of the conversion function
05155d8d7b215 (Douglas Gregor           2009-08-21 23:19:43 +0000  7502) /// template from the type that we are converting to (C++
05155d8d7b215 (Douglas Gregor           2009-08-21 23:19:43 +0000  7503) /// [temp.deduct.conv]).
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000  7504) void Sema::AddTemplateConversionCandidate(
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000  7505)     FunctionTemplateDecl *FunctionTemplate, DeclAccessPair FoundDecl,
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000  7506)     CXXRecordDecl *ActingDC, Expr *From, QualType ToType,
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000  7507)     OverloadCandidateSet &CandidateSet, bool AllowObjCConversionOnExplicit,
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000  7508)     bool AllowExplicit, bool AllowResultConversion) {
05155d8d7b215 (Douglas Gregor           2009-08-21 23:19:43 +0000  7509)   assert(isa<CXXConversionDecl>(FunctionTemplate->getTemplatedDecl()) &&
05155d8d7b215 (Douglas Gregor           2009-08-21 23:19:43 +0000  7510)          "Only conversion function templates permitted here");
05155d8d7b215 (Douglas Gregor           2009-08-21 23:19:43 +0000  7511) 
5b0f2a2fbe3ac (Douglas Gregor           2009-09-28 04:47:19 +0000  7512)   if (!CandidateSet.isNewCandidate(FunctionTemplate))
5b0f2a2fbe3ac (Douglas Gregor           2009-09-28 04:47:19 +0000  7513)     return;
5b0f2a2fbe3ac (Douglas Gregor           2009-09-28 04:47:19 +0000  7514) 
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  7515)   // If the function template has a non-dependent explicit specification,
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  7516)   // exclude it now if appropriate; we are not permitted to perform deduction
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  7517)   // and substitution in this case.
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  7518)   if (!AllowExplicit && isNonDependentlyExplicit(FunctionTemplate)) {
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  7519)     OverloadCandidate &Candidate = CandidateSet.addCandidate();
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  7520)     Candidate.FoundDecl = FoundDecl;
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  7521)     Candidate.Function = FunctionTemplate->getTemplatedDecl();
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  7522)     Candidate.Viable = false;
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  7523)     Candidate.FailureKind = ovl_fail_explicit;
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  7524)     return;
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  7525)   }
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800  7526) 
e6706e40bb692 (Craig Topper             2012-09-19 02:26:47 +0000  7527)   TemplateDeductionInfo Info(CandidateSet.getLocation());
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000  7528)   CXXConversionDecl *Specialization = nullptr;
05155d8d7b215 (Douglas Gregor           2009-08-21 23:19:43 +0000  7529)   if (TemplateDeductionResult Result
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  7530)         = DeduceTemplateArguments(FunctionTemplate, ToType,
05155d8d7b215 (Douglas Gregor           2009-08-21 23:19:43 +0000  7531)                                   Specialization, Info)) {
fb761ff54452f (Benjamin Kramer          2012-01-14 16:31:55 +0000  7532)     OverloadCandidate &Candidate = CandidateSet.addCandidate();
90cf2c98bbca9 (Douglas Gregor           2010-05-08 20:18:54 +0000  7533)     Candidate.FoundDecl = FoundDecl;
90cf2c98bbca9 (Douglas Gregor           2010-05-08 20:18:54 +0000  7534)     Candidate.Function = FunctionTemplate->getTemplatedDecl();
90cf2c98bbca9 (Douglas Gregor           2010-05-08 20:18:54 +0000  7535)     Candidate.Viable = false;
90cf2c98bbca9 (Douglas Gregor           2010-05-08 20:18:54 +0000  7536)     Candidate.FailureKind = ovl_fail_bad_deduction;
90cf2c98bbca9 (Douglas Gregor           2010-05-08 20:18:54 +0000  7537)     Candidate.IsSurrogate = false;
90cf2c98bbca9 (Douglas Gregor           2010-05-08 20:18:54 +0000  7538)     Candidate.IgnoreObjectArgument = false;
6edd977c6f368 (Douglas Gregor           2011-01-19 23:54:39 +0000  7539)     Candidate.ExplicitCallArguments = 1;
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  7540)     Candidate.DeductionFailure = MakeDeductionFailureInfo(Context, Result,
90cf2c98bbca9 (Douglas Gregor           2010-05-08 20:18:54 +0000  7541)                                                           Info);
05155d8d7b215 (Douglas Gregor           2009-08-21 23:19:43 +0000  7542)     return;
05155d8d7b215 (Douglas Gregor           2009-08-21 23:19:43 +0000  7543)   }
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  7544) 
05155d8d7b215 (Douglas Gregor           2009-08-21 23:19:43 +0000  7545)   // Add the conversion function template specialization produced by
05155d8d7b215 (Douglas Gregor           2009-08-21 23:19:43 +0000  7546)   // template argument deduction as a candidate.
05155d8d7b215 (Douglas Gregor           2009-08-21 23:19:43 +0000  7547)   assert(Specialization && "Missing function template specialization?");
a0296f7987c0a (John McCall              2010-03-19 07:35:19 +0000  7548)   AddConversionCandidate(Specialization, FoundDecl, ActingDC, From, ToType,
67ef14fe486e1 (Richard Smith            2017-09-26 18:37:55 +0000  7549)                          CandidateSet, AllowObjCConversionOnExplicit,
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000  7550)                          AllowExplicit, AllowResultConversion);
05155d8d7b215 (Douglas Gregor           2009-08-21 23:19:43 +0000  7551) }
05155d8d7b215 (Douglas Gregor           2009-08-21 23:19:43 +0000  7552) 
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7553) /// AddSurrogateCandidate - Adds a "surrogate" candidate function that
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7554) /// converts the given @c Object to a function pointer via the
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7555) /// conversion function @c Conversion, and then attempts to call it
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7556) /// with the given arguments (C++ [over.call.object]p2-4). Proto is
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7557) /// the type of function that we'll eventually be calling.
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7558) void Sema::AddSurrogateCandidate(CXXConversionDecl *Conversion,
a0296f7987c0a (John McCall              2010-03-19 07:35:19 +0000  7559)                                  DeclAccessPair FoundDecl,
6e9f8f6374349 (John McCall              2009-12-03 04:06:58 +0000  7560)                                  CXXRecordDecl *ActingContext,
deaad8cc34239 (Douglas Gregor           2009-02-26 23:50:07 +0000  7561)                                  const FunctionProtoType *Proto,
0282432039ab9 (Douglas Gregor           2011-01-26 19:30:28 +0000  7562)                                  Expr *Object,
f857950d391d0 (Dmitri Gribenko          2013-01-12 19:30:44 +0000  7563)                                  ArrayRef<Expr *> Args,
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7564)                                  OverloadCandidateSet& CandidateSet) {
5b0f2a2fbe3ac (Douglas Gregor           2009-09-28 04:47:19 +0000  7565)   if (!CandidateSet.isNewCandidate(Conversion))
5b0f2a2fbe3ac (Douglas Gregor           2009-09-28 04:47:19 +0000  7566)     return;
5b0f2a2fbe3ac (Douglas Gregor           2009-09-28 04:47:19 +0000  7567) 
27381f3d93454 (Douglas Gregor           2009-11-23 12:27:39 +0000  7568)   // Overload resolution is always an unevaluated context.
d143a0c2de131 (Faisal Vali              2017-04-01 21:30:49 +0000  7569)   EnterExpressionEvaluationContext Unevaluated(
d143a0c2de131 (Faisal Vali              2017-04-01 21:30:49 +0000  7570)       *this, Sema::ExpressionEvaluationContext::Unevaluated);
27381f3d93454 (Douglas Gregor           2009-11-23 12:27:39 +0000  7571) 
b24b9aa298311 (Ahmed Charles            2012-02-25 11:00:22 +0000  7572)   OverloadCandidate &Candidate = CandidateSet.addCandidate(Args.size() + 1);
a0296f7987c0a (John McCall              2010-03-19 07:35:19 +0000  7573)   Candidate.FoundDecl = FoundDecl;
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000  7574)   Candidate.Function = nullptr;
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7575)   Candidate.Surrogate = Conversion;
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7576)   Candidate.Viable = true;
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7577)   Candidate.IsSurrogate = true;
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000  7578)   Candidate.IgnoreObjectArgument = false;
b24b9aa298311 (Ahmed Charles            2012-02-25 11:00:22 +0000  7579)   Candidate.ExplicitCallArguments = Args.size();
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7580) 
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7581)   // Determine the implicit conversion sequence for the implicit
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7582)   // object parameter.
0f59cb38e7f31 (Richard Smith            2015-12-18 21:45:41 +0000  7583)   ImplicitConversionSequence ObjectInit = TryObjectArgumentInitialization(
0f59cb38e7f31 (Richard Smith            2015-12-18 21:45:41 +0000  7584)       *this, CandidateSet.getLocation(), Object->getType(),
0f59cb38e7f31 (Richard Smith            2015-12-18 21:45:41 +0000  7585)       Object->Classify(Context), Conversion, ActingContext);
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000  7586)   if (ObjectInit.isBad()) {
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7587)     Candidate.Viable = false;
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000  7588)     Candidate.FailureKind = ovl_fail_bad_conversion;
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000  7589)     Candidate.Conversions[0] = ObjectInit;
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7590)     return;
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7591)   }
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7592) 
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7593)   // The first conversion is actually a user-defined conversion whose
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7594)   // first conversion is ObjectInit's standard conversion (which is
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7595)   // effectively a reference binding). Record it as such.
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000  7596)   Candidate.Conversions[0].setUserDefined();
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7597)   Candidate.Conversions[0].UserDefined.Before = ObjectInit.Standard;
5582451e914f4 (Fariborz Jahanian        2009-11-06 00:23:08 +0000  7598)   Candidate.Conversions[0].UserDefined.EllipsisConversion = false;
635ed24e1dad8 (Abramo Bagnara           2011-10-05 07:56:41 +0000  7599)   Candidate.Conversions[0].UserDefined.HadMultipleCandidates = false;
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7600)   Candidate.Conversions[0].UserDefined.ConversionFunction = Conversion;
30909031a7f76 (John McCall              2011-09-21 08:36:56 +0000  7601)   Candidate.Conversions[0].UserDefined.FoundConversionFunction = FoundDecl;
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  7602)   Candidate.Conversions[0].UserDefined.After
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7603)     = Candidate.Conversions[0].UserDefined.Before;
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7604)   Candidate.Conversions[0].UserDefined.After.setAsIdentityConversion();
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7605) 
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  7606)   // Find the
b3fd5cfa81b83 (Alp Toker                2014-01-21 00:32:38 +0000  7607)   unsigned NumParams = Proto->getNumParams();
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7608) 
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7609)   // (C++ 13.3.2p2): A candidate function having fewer than m
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7610)   // parameters is viable only if it has an ellipsis in its parameter
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7611)   // list (8.3.5).
b3fd5cfa81b83 (Alp Toker                2014-01-21 00:32:38 +0000  7612)   if (Args.size() > NumParams && !Proto->isVariadic()) {
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7613)     Candidate.Viable = false;
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000  7614)     Candidate.FailureKind = ovl_fail_too_many_arguments;
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7615)     return;
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7616)   }
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7617) 
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7618)   // Function types don't have any default arguments, so just check if
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7619)   // we have enough arguments.
b3fd5cfa81b83 (Alp Toker                2014-01-21 00:32:38 +0000  7620)   if (Args.size() < NumParams) {
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7621)     // Not enough arguments.
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7622)     Candidate.Viable = false;
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000  7623)     Candidate.FailureKind = ovl_fail_too_few_arguments;
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7624)     return;
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7625)   }
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7626) 
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7627)   // Determine the implicit conversion sequences for each of the
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7628)   // arguments.
e54c307bb4ed9 (Richard Smith            2013-05-05 15:51:06 +0000  7629)   for (unsigned ArgIdx = 0, N = Args.size(); ArgIdx != N; ++ArgIdx) {
b3fd5cfa81b83 (Alp Toker                2014-01-21 00:32:38 +0000  7630)     if (ArgIdx < NumParams) {
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7631)       // (C++ 13.3.2p3): for F to be a viable function, there shall
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7632)       // exist for each argument an implicit conversion sequence
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7633)       // (13.3.3.1) that converts that argument to the corresponding
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7634)       // parameter of F.
9cacbabd33eea (Alp Toker                2014-01-20 20:26:09 +0000  7635)       QualType ParamType = Proto->getParamType(ArgIdx);
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  7636)       Candidate.Conversions[ArgIdx + 1]
cb13cfc878200 (Douglas Gregor           2010-04-16 17:51:22 +0000  7637)         = TryCopyInitialization(*this, Args[ArgIdx], ParamType,
03068aa0777d7 (Anders Carlsson          2009-08-27 17:18:13 +0000  7638)                                 /*SuppressUserConversions=*/false,
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  7639)                                 /*InOverloadResolution=*/false,
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  7640)                                 /*AllowObjCWritebackConversion=*/
bbafb8a745736 (David Blaikie            2012-03-11 07:00:24 +0000  7641)                                   getLangOpts().ObjCAutoRefCount);
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000  7642)       if (Candidate.Conversions[ArgIdx + 1].isBad()) {
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7643)         Candidate.Viable = false;
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000  7644)         Candidate.FailureKind = ovl_fail_bad_conversion;
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  7645)         return;
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7646)       }
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7647)     } else {
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7648)       // (C++ 13.3.2p2): For the purposes of overload resolution, any
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7649)       // argument for which there is no corresponding parameter is
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7650)       // considered to ""match the ellipsis" (C+ 13.3.3.1.3).
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000  7651)       Candidate.Conversions[ArgIdx + 1].setEllipsis();
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7652)     }
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7653)   }
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  7654) 
0dfb43deb6d55 (Richard Smith            2020-05-28 15:02:18 -0700  7655)   if (EnableIfAttr *FailedAttr =
0dfb43deb6d55 (Richard Smith            2020-05-28 15:02:18 -0700  7656)           CheckEnableIf(Conversion, CandidateSet.getLocation(), None)) {
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  7657)     Candidate.Viable = false;
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  7658)     Candidate.FailureKind = ovl_fail_enable_if;
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  7659)     Candidate.DeductionFailure.Data = FailedAttr;
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  7660)     return;
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  7661)   }
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7662) }
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000  7663) 
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7664) /// Add all of the non-member operator function declarations in the given
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7665) /// function set to the overload candidate set.
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7666) void Sema::AddNonMemberOperatorCandidates(
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7667)     const UnresolvedSetImpl &Fns, ArrayRef<Expr *> Args,
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7668)     OverloadCandidateSet &CandidateSet,
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7669)     TemplateArgumentListInfo *ExplicitTemplateArgs) {
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7670)   for (UnresolvedSetIterator F = Fns.begin(), E = Fns.end(); F != E; ++F) {
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7671)     NamedDecl *D = F.getDecl()->getUnderlyingDecl();
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7672)     ArrayRef<Expr *> FunctionArgs = Args;
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7673) 
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7674)     FunctionTemplateDecl *FunTmpl = dyn_cast<FunctionTemplateDecl>(D);
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7675)     FunctionDecl *FD =
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7676)         FunTmpl ? FunTmpl->getTemplatedDecl() : cast<FunctionDecl>(D);
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7677) 
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7678)     // Don't consider rewritten functions if we're not rewriting.
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7679)     if (!CandidateSet.getRewriteInfo().isAcceptableCandidate(FD))
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7680)       continue;
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7681) 
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7682)     assert(!isa<CXXMethodDecl>(FD) &&
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7683)            "unqualified operator lookup found a member function");
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7684) 
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7685)     if (FunTmpl) {
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7686)       AddTemplateOverloadCandidate(FunTmpl, F.getPair(), ExplicitTemplateArgs,
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7687)                                    FunctionArgs, CandidateSet);
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7688)       if (CandidateSet.getRewriteInfo().shouldAddReversed(Context, FD))
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7689)         AddTemplateOverloadCandidate(
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7690)             FunTmpl, F.getPair(), ExplicitTemplateArgs,
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7691)             {FunctionArgs[1], FunctionArgs[0]}, CandidateSet, false, false,
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7692)             true, ADLCallKind::NotADL, OverloadCandidateParamOrder::Reversed);
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7693)     } else {
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7694)       if (ExplicitTemplateArgs)
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7695)         continue;
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7696)       AddOverloadCandidate(FD, F.getPair(), FunctionArgs, CandidateSet);
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7697)       if (CandidateSet.getRewriteInfo().shouldAddReversed(Context, FD))
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7698)         AddOverloadCandidate(FD, F.getPair(),
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7699)                              {FunctionArgs[1], FunctionArgs[0]}, CandidateSet,
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7700)                              false, false, true, false, ADLCallKind::NotADL,
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7701)                              None, OverloadCandidateParamOrder::Reversed);
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7702)     }
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7703)   }
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7704) }
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7705) 
9fc8faf9e6197 (Adrian Prantl            2018-05-09 01:00:01 +0000  7706) /// Add overload candidates for overloaded operators that are
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000  7707) /// member functions.
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000  7708) ///
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000  7709) /// Add the overloaded operator candidates that are member functions
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000  7710) /// for the operator Op that was used in an operator expression such
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000  7711) /// as "x Op y". , Args/NumArgs provides the operator arguments, and
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000  7712) /// CandidateSet will store the added overload candidates. (C++
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000  7713) /// [over.match.oper]).
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000  7714) void Sema::AddMemberOperatorCandidates(OverloadedOperatorKind Op,
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000  7715)                                        SourceLocation OpLoc,
e54c307bb4ed9 (Richard Smith            2013-05-05 15:51:06 +0000  7716)                                        ArrayRef<Expr *> Args,
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7717)                                        OverloadCandidateSet &CandidateSet,
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7718)                                        OverloadCandidateParamOrder PO) {
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  7719)   DeclarationName OpName = Context.DeclarationNames.getCXXOperatorName(Op);
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  7720) 
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  7721)   // C++ [over.match.oper]p3:
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  7722)   //   For a unary operator @ with an operand of a type whose
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  7723)   //   cv-unqualified version is T1, and for a binary operator @ with
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  7724)   //   a left operand of a type whose cv-unqualified version is T1 and
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  7725)   //   a right operand of a type whose cv-unqualified version is T2,
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  7726)   //   three sets of candidate functions, designated member
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  7727)   //   candidates, non-member candidates and built-in candidates, are
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  7728)   //   constructed as follows:
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  7729)   QualType T1 = Args[0]->getType();
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  7730) 
0feaf0c7e3e13 (Richard Smith            2013-04-20 12:41:22 +0000  7731)   //     -- If T1 is a complete class type or a class currently being
0feaf0c7e3e13 (Richard Smith            2013-04-20 12:41:22 +0000  7732)   //        defined, the set of member candidates is the result of the
0feaf0c7e3e13 (Richard Smith            2013-04-20 12:41:22 +0000  7733)   //        qualified lookup of T1::operator@ (13.3.1.1.1); otherwise,
0feaf0c7e3e13 (Richard Smith            2013-04-20 12:41:22 +0000  7734)   //        the set of member candidates is empty.
c23c7e6a51927 (Ted Kremenek             2009-07-29 21:53:49 +0000  7735)   if (const RecordType *T1Rec = T1->getAs<RecordType>()) {
0feaf0c7e3e13 (Richard Smith            2013-04-20 12:41:22 +0000  7736)     // Complete the type if it can be completed.
db0ac5572fcf7 (Richard Smith            2015-12-18 22:40:25 +0000  7737)     if (!isCompleteType(OpLoc, T1) && !T1Rec->isBeingDefined())
82b8d4e6fd79e (Richard Smith            2015-12-18 22:19:11 +0000  7738)       return;
0feaf0c7e3e13 (Richard Smith            2013-04-20 12:41:22 +0000  7739)     // If the type is neither complete nor being defined, bail out now.
0feaf0c7e3e13 (Richard Smith            2013-04-20 12:41:22 +0000  7740)     if (!T1Rec->getDecl()->getDefinition())
6a1f965853df1 (Douglas Gregor           2009-08-27 23:35:55 +0000  7741)       return;
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  7742) 
27b18f8144b7c (John McCall              2009-11-17 02:14:36 +0000  7743)     LookupResult Operators(*this, OpName, OpLoc, LookupOrdinaryName);
27b18f8144b7c (John McCall              2009-11-17 02:14:36 +0000  7744)     LookupQualifiedName(Operators, T1Rec->getDecl());
27b18f8144b7c (John McCall              2009-11-17 02:14:36 +0000  7745)     Operators.suppressDiagnostics();
27b18f8144b7c (John McCall              2009-11-17 02:14:36 +0000  7746) 
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  7747)     for (LookupResult::iterator Oper = Operators.begin(),
6a1f965853df1 (Douglas Gregor           2009-08-27 23:35:55 +0000  7748)                              OperEnd = Operators.end();
6a1f965853df1 (Douglas Gregor           2009-08-27 23:35:55 +0000  7749)          Oper != OperEnd;
f0f1cf087e704 (John McCall              2009-11-17 07:50:12 +0000  7750)          ++Oper)
a0296f7987c0a (John McCall              2010-03-19 07:35:19 +0000  7751)       AddMethodCandidate(Oper.getPair(), Args[0]->getType(),
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000  7752)                          Args[0]->Classify(Context), Args.slice(1),
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  7753)                          CandidateSet, /*SuppressUserConversion=*/false, PO);
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  7754)   }
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  7755) }
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  7756) 
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  7757) /// AddBuiltinCandidate - Add a candidate for a built-in
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  7758) /// operator. ResultTy and ParamTys are the result and parameter types
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  7759) /// of the built-in candidate, respectively. Args and NumArgs are the
c5e61070f6d1b (Douglas Gregor           2009-01-13 00:52:54 +0000  7760) /// arguments being passed to the candidate. IsAssignmentOperator
c5e61070f6d1b (Douglas Gregor           2009-01-13 00:52:54 +0000  7761) /// should be true when this built-in candidate is an assignment
5fb53972380f5 (Douglas Gregor           2009-01-14 15:45:31 +0000  7762) /// operator. NumContextualBoolArguments is the number of arguments
5fb53972380f5 (Douglas Gregor           2009-01-14 15:45:31 +0000  7763) /// (at the beginning of the argument list) that will be contextually
5fb53972380f5 (Douglas Gregor           2009-01-14 15:45:31 +0000  7764) /// converted to bool.
c07c389a94bb4 (George Burgess IV        2017-06-08 18:19:25 +0000  7765) void Sema::AddBuiltinCandidate(QualType *ParamTys, ArrayRef<Expr *> Args,
c5e61070f6d1b (Douglas Gregor           2009-01-13 00:52:54 +0000  7766)                                OverloadCandidateSet& CandidateSet,
5fb53972380f5 (Douglas Gregor           2009-01-14 15:45:31 +0000  7767)                                bool IsAssignmentOperator,
5fb53972380f5 (Douglas Gregor           2009-01-14 15:45:31 +0000  7768)                                unsigned NumContextualBoolArguments) {
27381f3d93454 (Douglas Gregor           2009-11-23 12:27:39 +0000  7769)   // Overload resolution is always an unevaluated context.
d143a0c2de131 (Faisal Vali              2017-04-01 21:30:49 +0000  7770)   EnterExpressionEvaluationContext Unevaluated(
d143a0c2de131 (Faisal Vali              2017-04-01 21:30:49 +0000  7771)       *this, Sema::ExpressionEvaluationContext::Unevaluated);
27381f3d93454 (Douglas Gregor           2009-11-23 12:27:39 +0000  7772) 
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  7773)   // Add this candidate
e54c307bb4ed9 (Richard Smith            2013-05-05 15:51:06 +0000  7774)   OverloadCandidate &Candidate = CandidateSet.addCandidate(Args.size());
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000  7775)   Candidate.FoundDecl = DeclAccessPair::make(nullptr, AS_none);
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000  7776)   Candidate.Function = nullptr;
1d248c53ab1c5 (Douglas Gregor           2008-12-12 02:00:36 +0000  7777)   Candidate.IsSurrogate = false;
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000  7778)   Candidate.IgnoreObjectArgument = false;
5f6ab9a8bf307 (George Burgess IV        2017-06-08 20:55:21 +0000  7779)   std::copy(ParamTys, ParamTys + Args.size(), Candidate.BuiltinParamTypes);
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  7780) 
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  7781)   // Determine the implicit conversion sequences for each of the
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  7782)   // arguments.
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  7783)   Candidate.Viable = true;
e54c307bb4ed9 (Richard Smith            2013-05-05 15:51:06 +0000  7784)   Candidate.ExplicitCallArguments = Args.size();
e54c307bb4ed9 (Richard Smith            2013-05-05 15:51:06 +0000  7785)   for (unsigned ArgIdx = 0, N = Args.size(); ArgIdx != N; ++ArgIdx) {
c5e61070f6d1b (Douglas Gregor           2009-01-13 00:52:54 +0000  7786)     // C++ [over.match.oper]p4:
c5e61070f6d1b (Douglas Gregor           2009-01-13 00:52:54 +0000  7787)     //   For the built-in assignment operators, conversions of the
c5e61070f6d1b (Douglas Gregor           2009-01-13 00:52:54 +0000  7788)     //   left operand are restricted as follows:
c5e61070f6d1b (Douglas Gregor           2009-01-13 00:52:54 +0000  7789)     //     -- no temporaries are introduced to hold the left operand, and
c5e61070f6d1b (Douglas Gregor           2009-01-13 00:52:54 +0000  7790)     //     -- no user-defined conversions are applied to the left
c5e61070f6d1b (Douglas Gregor           2009-01-13 00:52:54 +0000  7791)     //        operand to achieve a type match with the left-most
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  7792)     //        parameter of a built-in candidate.
c5e61070f6d1b (Douglas Gregor           2009-01-13 00:52:54 +0000  7793)     //
c5e61070f6d1b (Douglas Gregor           2009-01-13 00:52:54 +0000  7794)     // We block these conversions by turning off user-defined
c5e61070f6d1b (Douglas Gregor           2009-01-13 00:52:54 +0000  7795)     // conversions, since that is the only way that initialization of
c5e61070f6d1b (Douglas Gregor           2009-01-13 00:52:54 +0000  7796)     // a reference to a non-class type can occur from something that
c5e61070f6d1b (Douglas Gregor           2009-01-13 00:52:54 +0000  7797)     // is not of the same type.
5fb53972380f5 (Douglas Gregor           2009-01-14 15:45:31 +0000  7798)     if (ArgIdx < NumContextualBoolArguments) {
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  7799)       assert(ParamTys[ArgIdx] == Context.BoolTy &&
5fb53972380f5 (Douglas Gregor           2009-01-14 15:45:31 +0000  7800)              "Contextual conversion to bool requires bool type");
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  7801)       Candidate.Conversions[ArgIdx]
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  7802)         = TryContextuallyConvertToBool(*this, Args[ArgIdx]);
5fb53972380f5 (Douglas Gregor           2009-01-14 15:45:31 +0000  7803)     } else {
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  7804)       Candidate.Conversions[ArgIdx]
cb13cfc878200 (Douglas Gregor           2010-04-16 17:51:22 +0000  7805)         = TryCopyInitialization(*this, Args[ArgIdx], ParamTys[ArgIdx],
03068aa0777d7 (Anders Carlsson          2009-08-27 17:18:13 +0000  7806)                                 ArgIdx == 0 && IsAssignmentOperator,
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  7807)                                 /*InOverloadResolution=*/false,
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000  7808)                                 /*AllowObjCWritebackConversion=*/
bbafb8a745736 (David Blaikie            2012-03-11 07:00:24 +0000  7809)                                   getLangOpts().ObjCAutoRefCount);
5fb53972380f5 (Douglas Gregor           2009-01-14 15:45:31 +0000  7810)     }
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000  7811)     if (Candidate.Conversions[ArgIdx].isBad()) {
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  7812)       Candidate.Viable = false;
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000  7813)       Candidate.FailureKind = ovl_fail_bad_conversion;
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  7814)       break;
436424cfa5855 (Douglas Gregor           2008-11-18 23:14:02 +0000  7815)     }
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  7816)   }
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  7817) }
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  7818) 
cd7b03342d936 (Craig Topper             2013-07-01 06:29:40 +0000  7819) namespace {
cd7b03342d936 (Craig Topper             2013-07-01 06:29:40 +0000  7820) 
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  7821) /// BuiltinCandidateTypeSet - A set of types that will be used for the
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  7822) /// candidate operator functions for built-in operators (C++
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  7823) /// [over.built]). The types are separated into pointer types and
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  7824) /// enumeration types.
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  7825) class BuiltinCandidateTypeSet  {
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  7826)   /// TypeSet - A set of types.
95853077c3f3f (Richard Smith            2016-03-25 00:08:53 +0000  7827)   typedef llvm::SetVector<QualType, SmallVector<QualType, 8>,
95853077c3f3f (Richard Smith            2016-03-25 00:08:53 +0000  7828)                           llvm::SmallPtrSet<QualType, 8>> TypeSet;
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  7829) 
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  7830)   /// PointerTypes - The set of pointer types that will be used in the
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  7831)   /// built-in candidates.
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  7832)   TypeSet PointerTypes;
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  7833) 
8ce189f9cefc4 (Sebastian Redl           2009-04-19 21:53:20 +0000  7834)   /// MemberPointerTypes - The set of member pointer types that will be
8ce189f9cefc4 (Sebastian Redl           2009-04-19 21:53:20 +0000  7835)   /// used in the built-in candidates.
8ce189f9cefc4 (Sebastian Redl           2009-04-19 21:53:20 +0000  7836)   TypeSet MemberPointerTypes;
8ce189f9cefc4 (Sebastian Redl           2009-04-19 21:53:20 +0000  7837) 
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  7838)   /// EnumerationTypes - The set of enumeration types that will be
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  7839)   /// used in the built-in candidates.
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  7840)   TypeSet EnumerationTypes;
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  7841) 
9fc8faf9e6197 (Adrian Prantl            2018-05-09 01:00:01 +0000  7842)   /// The set of vector types that will be used in the built-in
cbfbca14d0a2b (Douglas Gregor           2010-05-19 03:21:00 +0000  7843)   /// candidates.
cbfbca14d0a2b (Douglas Gregor           2010-05-19 03:21:00 +0000  7844)   TypeSet VectorTypes;
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  7845) 
6f6e91d193373 (Florian Hahn             2020-05-29 20:42:22 +0100  7846)   /// The set of matrix types that will be used in the built-in
6f6e91d193373 (Florian Hahn             2020-05-29 20:42:22 +0100  7847)   /// candidates.
6f6e91d193373 (Florian Hahn             2020-05-29 20:42:22 +0100  7848)   TypeSet MatrixTypes;
6f6e91d193373 (Florian Hahn             2020-05-29 20:42:22 +0100  7849) 
9fc8faf9e6197 (Adrian Prantl            2018-05-09 01:00:01 +0000  7850)   /// A flag indicating non-record types are viable candidates
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  7851)   bool HasNonRecordTypes;
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  7852) 
9fc8faf9e6197 (Adrian Prantl            2018-05-09 01:00:01 +0000  7853)   /// A flag indicating whether either arithmetic or enumeration types
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  7854)   /// were present in the candidate set.
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  7855)   bool HasArithmeticOrEnumeralTypes;
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  7856) 
9fc8faf9e6197 (Adrian Prantl            2018-05-09 01:00:01 +0000  7857)   /// A flag indicating whether the nullptr type was present in the
80af31397acee (Douglas Gregor           2011-05-21 23:15:46 +0000  7858)   /// candidate set.
80af31397acee (Douglas Gregor           2011-05-21 23:15:46 +0000  7859)   bool HasNullPtrType;
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  7860) 
8a2e601917708 (Douglas Gregor           2009-08-24 15:23:48 +0000  7861)   /// Sema - The semantic analysis instance where we are building the
8a2e601917708 (Douglas Gregor           2009-08-24 15:23:48 +0000  7862)   /// candidate type set.
8a2e601917708 (Douglas Gregor           2009-08-24 15:23:48 +0000  7863)   Sema &SemaRef;
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  7864) 
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  7865)   /// Context - The AST context in which we will build the type sets.
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  7866)   ASTContext &Context;
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  7867) 
b06ec054fc550 (Fariborz Jahanian        2009-10-16 22:08:05 +0000  7868)   bool AddPointerWithMoreQualifiedTypeVariants(QualType Ty,
b06ec054fc550 (Fariborz Jahanian        2009-10-16 22:08:05 +0000  7869)                                                const Qualifiers &VisibleQuals);
8ce189f9cefc4 (Sebastian Redl           2009-04-19 21:53:20 +0000  7870)   bool AddMemberPointerWithMoreQualifiedTypeVariants(QualType Ty);
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  7871) 
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  7872) public:
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  7873)   /// iterator - Iterates through the types that are part of the set.
a59a3e2d10626 (Chris Lattner            2009-03-29 00:04:01 +0000  7874)   typedef TypeSet::iterator iterator;
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  7875) 
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  7876)   BuiltinCandidateTypeSet(Sema &SemaRef)
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  7877)     : HasNonRecordTypes(false),
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  7878)       HasArithmeticOrEnumeralTypes(false),
80af31397acee (Douglas Gregor           2011-05-21 23:15:46 +0000  7879)       HasNullPtrType(false),
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  7880)       SemaRef(SemaRef),
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  7881)       Context(SemaRef.Context) { }
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  7882) 
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  7883)   void AddTypesConvertedFrom(QualType Ty,
c02cfe2a55e13 (Douglas Gregor           2009-10-21 23:19:44 +0000  7884)                              SourceLocation Loc,
c02cfe2a55e13 (Douglas Gregor           2009-10-21 23:19:44 +0000  7885)                              bool AllowUserConversions,
3b937fa298ce6 (Fariborz Jahanian        2009-10-15 17:14:05 +0000  7886)                              bool AllowExplicitConversions,
3b937fa298ce6 (Fariborz Jahanian        2009-10-15 17:14:05 +0000  7887)                              const Qualifiers &VisibleTypeConversionsQuals);
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  7888) 
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  7889)   llvm::iterator_range<iterator> pointer_types() { return PointerTypes; }
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  7890)   llvm::iterator_range<iterator> member_pointer_types() {
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  7891)     return MemberPointerTypes;
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  7892)   }
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  7893)   llvm::iterator_range<iterator> enumeration_types() {
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  7894)     return EnumerationTypes;
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  7895)   }
714e84be4615d (Florian Hahn             2020-06-04 20:15:21 +0100  7896)   llvm::iterator_range<iterator> vector_types() { return VectorTypes; }
6f6e91d193373 (Florian Hahn             2020-05-29 20:42:22 +0100  7897)   llvm::iterator_range<iterator> matrix_types() { return MatrixTypes; }
6f6e91d193373 (Florian Hahn             2020-05-29 20:42:22 +0100  7898) 
6f6e91d193373 (Florian Hahn             2020-05-29 20:42:22 +0100  7899)   bool containsMatrixType(QualType Ty) const { return MatrixTypes.count(Ty); }
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  7900)   bool hasNonRecordTypes() { return HasNonRecordTypes; }
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  7901)   bool hasArithmeticOrEnumeralTypes() { return HasArithmeticOrEnumeralTypes; }
80af31397acee (Douglas Gregor           2011-05-21 23:15:46 +0000  7902)   bool hasNullPtrType() const { return HasNullPtrType; }
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  7903) };
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  7904) 
cd7b03342d936 (Craig Topper             2013-07-01 06:29:40 +0000  7905) } // end anonymous namespace
cd7b03342d936 (Craig Topper             2013-07-01 06:29:40 +0000  7906) 
8ce189f9cefc4 (Sebastian Redl           2009-04-19 21:53:20 +0000  7907) /// AddPointerWithMoreQualifiedTypeVariants - Add the pointer type @p Ty to
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  7908) /// the set of pointer types along with any more-qualified variants of
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  7909) /// that type. For example, if @p Ty is "int const *", this routine
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  7910) /// will add "int const *", "int const volatile *", "int const
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  7911) /// restrict *", and "int const volatile restrict *" to the set of
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  7912) /// pointer types. Returns true if the add of @p Ty itself succeeded,
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  7913) /// false otherwise.
8ccfcb51ee020 (John McCall              2009-09-24 19:53:00 +0000  7914) ///
8ccfcb51ee020 (John McCall              2009-09-24 19:53:00 +0000  7915) /// FIXME: what to do about extended qualifiers?
8ce189f9cefc4 (Sebastian Redl           2009-04-19 21:53:20 +0000  7916) bool
c02cfe2a55e13 (Douglas Gregor           2009-10-21 23:19:44 +0000  7917) BuiltinCandidateTypeSet::AddPointerWithMoreQualifiedTypeVariants(QualType Ty,
c02cfe2a55e13 (Douglas Gregor           2009-10-21 23:19:44 +0000  7918)                                              const Qualifiers &VisibleQuals) {
8ccfcb51ee020 (John McCall              2009-09-24 19:53:00 +0000  7919) 
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  7920)   // Insert this type.
95853077c3f3f (Richard Smith            2016-03-25 00:08:53 +0000  7921)   if (!PointerTypes.insert(Ty))
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  7922)     return false;
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  7923) 
e4151b590ef4b (Fariborz Jahanian        2010-08-21 00:10:36 +0000  7924)   QualType PointeeTy;
8ccfcb51ee020 (John McCall              2009-09-24 19:53:00 +0000  7925)   const PointerType *PointerTy = Ty->getAs<PointerType>();
f2afc804c32bc (Fariborz Jahanian        2010-08-21 17:11:09 +0000  7926)   bool buildObjCPtr = false;
e4151b590ef4b (Fariborz Jahanian        2010-08-21 00:10:36 +0000  7927)   if (!PointerTy) {
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  7928)     const ObjCObjectPointerType *PTy = Ty->castAs<ObjCObjectPointerType>();
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  7929)     PointeeTy = PTy->getPointeeType();
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  7930)     buildObjCPtr = true;
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  7931)   } else {
e4151b590ef4b (Fariborz Jahanian        2010-08-21 00:10:36 +0000  7932)     PointeeTy = PointerTy->getPointeeType();
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  7933)   }
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  7934) 
4990a6347a3a8 (Sebastian Redl           2009-11-18 20:39:26 +0000  7935)   // Don't add qualified variants of arrays. For one, they're not allowed
4990a6347a3a8 (Sebastian Redl           2009-11-18 20:39:26 +0000  7936)   // (the qualifier would sink to the element type), and for another, the
4990a6347a3a8 (Sebastian Redl           2009-11-18 20:39:26 +0000  7937)   // only overload situation where it matters is subscript or pointer +- int,
4990a6347a3a8 (Sebastian Redl           2009-11-18 20:39:26 +0000  7938)   // and those shouldn't have qualifier variants anyway.
4990a6347a3a8 (Sebastian Redl           2009-11-18 20:39:26 +0000  7939)   if (PointeeTy->isArrayType())
4990a6347a3a8 (Sebastian Redl           2009-11-18 20:39:26 +0000  7940)     return true;
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  7941) 
8ccfcb51ee020 (John McCall              2009-09-24 19:53:00 +0000  7942)   unsigned BaseCVR = PointeeTy.getCVRQualifiers();
b06ec054fc550 (Fariborz Jahanian        2009-10-16 22:08:05 +0000  7943)   bool hasVolatile = VisibleQuals.hasVolatile();
b06ec054fc550 (Fariborz Jahanian        2009-10-16 22:08:05 +0000  7944)   bool hasRestrict = VisibleQuals.hasRestrict();
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  7945) 
8ccfcb51ee020 (John McCall              2009-09-24 19:53:00 +0000  7946)   // Iterate through all strict supersets of BaseCVR.
8ccfcb51ee020 (John McCall              2009-09-24 19:53:00 +0000  7947)   for (unsigned CVR = BaseCVR+1; CVR <= Qualifiers::CVRMask; ++CVR) {
8ccfcb51ee020 (John McCall              2009-09-24 19:53:00 +0000  7948)     if ((CVR | BaseCVR) != CVR) continue;
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  7949)     // Skip over volatile if no volatile found anywhere in the types.
b06ec054fc550 (Fariborz Jahanian        2009-10-16 22:08:05 +0000  7950)     if ((CVR & Qualifiers::Volatile) && !hasVolatile) continue;
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  7951) 
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  7952)     // Skip over restrict if no restrict found anywhere in the types, or if
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  7953)     // the type cannot be restrict-qualified.
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  7954)     if ((CVR & Qualifiers::Restrict) &&
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  7955)         (!hasRestrict ||
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  7956)          (!(PointeeTy->isAnyPointerType() || PointeeTy->isReferenceType()))))
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  7957)       continue;
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  7958) 
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  7959)     // Build qualified pointee type.
8ccfcb51ee020 (John McCall              2009-09-24 19:53:00 +0000  7960)     QualType QPointeeTy = Context.getCVRQualifiedType(PointeeTy, CVR);
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  7961) 
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  7962)     // Build qualified pointer type.
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  7963)     QualType QPointerTy;
f2afc804c32bc (Fariborz Jahanian        2010-08-21 17:11:09 +0000  7964)     if (!buildObjCPtr)
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  7965)       QPointerTy = Context.getPointerType(QPointeeTy);
f2afc804c32bc (Fariborz Jahanian        2010-08-21 17:11:09 +0000  7966)     else
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  7967)       QPointerTy = Context.getObjCObjectPointerType(QPointeeTy);
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  7968) 
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  7969)     // Insert qualified pointer type.
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  7970)     PointerTypes.insert(QPointerTy);
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  7971)   }
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  7972) 
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  7973)   return true;
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  7974) }
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  7975) 
8ce189f9cefc4 (Sebastian Redl           2009-04-19 21:53:20 +0000  7976) /// AddMemberPointerWithMoreQualifiedTypeVariants - Add the pointer type @p Ty
8ce189f9cefc4 (Sebastian Redl           2009-04-19 21:53:20 +0000  7977) /// to the set of pointer types along with any more-qualified variants of
8ce189f9cefc4 (Sebastian Redl           2009-04-19 21:53:20 +0000  7978) /// that type. For example, if @p Ty is "int const *", this routine
8ce189f9cefc4 (Sebastian Redl           2009-04-19 21:53:20 +0000  7979) /// will add "int const *", "int const volatile *", "int const
8ce189f9cefc4 (Sebastian Redl           2009-04-19 21:53:20 +0000  7980) /// restrict *", and "int const volatile restrict *" to the set of
8ce189f9cefc4 (Sebastian Redl           2009-04-19 21:53:20 +0000  7981) /// pointer types. Returns true if the add of @p Ty itself succeeded,
8ce189f9cefc4 (Sebastian Redl           2009-04-19 21:53:20 +0000  7982) /// false otherwise.
8ccfcb51ee020 (John McCall              2009-09-24 19:53:00 +0000  7983) ///
8ccfcb51ee020 (John McCall              2009-09-24 19:53:00 +0000  7984) /// FIXME: what to do about extended qualifiers?
8ce189f9cefc4 (Sebastian Redl           2009-04-19 21:53:20 +0000  7985) bool
8ce189f9cefc4 (Sebastian Redl           2009-04-19 21:53:20 +0000  7986) BuiltinCandidateTypeSet::AddMemberPointerWithMoreQualifiedTypeVariants(
8ce189f9cefc4 (Sebastian Redl           2009-04-19 21:53:20 +0000  7987)     QualType Ty) {
8ce189f9cefc4 (Sebastian Redl           2009-04-19 21:53:20 +0000  7988)   // Insert this type.
95853077c3f3f (Richard Smith            2016-03-25 00:08:53 +0000  7989)   if (!MemberPointerTypes.insert(Ty))
8ce189f9cefc4 (Sebastian Redl           2009-04-19 21:53:20 +0000  7990)     return false;
8ce189f9cefc4 (Sebastian Redl           2009-04-19 21:53:20 +0000  7991) 
8ccfcb51ee020 (John McCall              2009-09-24 19:53:00 +0000  7992)   const MemberPointerType *PointerTy = Ty->getAs<MemberPointerType>();
8ccfcb51ee020 (John McCall              2009-09-24 19:53:00 +0000  7993)   assert(PointerTy && "type was not a member pointer type!");
8ccfcb51ee020 (John McCall              2009-09-24 19:53:00 +0000  7994) 
8ccfcb51ee020 (John McCall              2009-09-24 19:53:00 +0000  7995)   QualType PointeeTy = PointerTy->getPointeeType();
4990a6347a3a8 (Sebastian Redl           2009-11-18 20:39:26 +0000  7996)   // Don't add qualified variants of arrays. For one, they're not allowed
4990a6347a3a8 (Sebastian Redl           2009-11-18 20:39:26 +0000  7997)   // (the qualifier would sink to the element type), and for another, the
4990a6347a3a8 (Sebastian Redl           2009-11-18 20:39:26 +0000  7998)   // only overload situation where it matters is subscript or pointer +- int,
4990a6347a3a8 (Sebastian Redl           2009-11-18 20:39:26 +0000  7999)   // and those shouldn't have qualifier variants anyway.
4990a6347a3a8 (Sebastian Redl           2009-11-18 20:39:26 +0000  8000)   if (PointeeTy->isArrayType())
4990a6347a3a8 (Sebastian Redl           2009-11-18 20:39:26 +0000  8001)     return true;
8ccfcb51ee020 (John McCall              2009-09-24 19:53:00 +0000  8002)   const Type *ClassTy = PointerTy->getClass();
8ce189f9cefc4 (Sebastian Redl           2009-04-19 21:53:20 +0000  8003) 
8ccfcb51ee020 (John McCall              2009-09-24 19:53:00 +0000  8004)   // Iterate through all strict supersets of the pointee type's CVR
8ccfcb51ee020 (John McCall              2009-09-24 19:53:00 +0000  8005)   // qualifiers.
8ccfcb51ee020 (John McCall              2009-09-24 19:53:00 +0000  8006)   unsigned BaseCVR = PointeeTy.getCVRQualifiers();
8ccfcb51ee020 (John McCall              2009-09-24 19:53:00 +0000  8007)   for (unsigned CVR = BaseCVR+1; CVR <= Qualifiers::CVRMask; ++CVR) {
8ccfcb51ee020 (John McCall              2009-09-24 19:53:00 +0000  8008)     if ((CVR | BaseCVR) != CVR) continue;
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  8009) 
8ccfcb51ee020 (John McCall              2009-09-24 19:53:00 +0000  8010)     QualType QPointeeTy = Context.getCVRQualifiedType(PointeeTy, CVR);
8e543b3d46932 (Chandler Carruth         2010-12-12 08:17:55 +0000  8011)     MemberPointerTypes.insert(
8e543b3d46932 (Chandler Carruth         2010-12-12 08:17:55 +0000  8012)       Context.getMemberPointerType(QPointeeTy, ClassTy));
8ce189f9cefc4 (Sebastian Redl           2009-04-19 21:53:20 +0000  8013)   }
8ce189f9cefc4 (Sebastian Redl           2009-04-19 21:53:20 +0000  8014) 
8ce189f9cefc4 (Sebastian Redl           2009-04-19 21:53:20 +0000  8015)   return true;
8ce189f9cefc4 (Sebastian Redl           2009-04-19 21:53:20 +0000  8016) }
8ce189f9cefc4 (Sebastian Redl           2009-04-19 21:53:20 +0000  8017) 
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8018) /// AddTypesConvertedFrom - Add each of the types to which the type @p
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8019) /// Ty can be implicit converted to the given set of @p Types. We're
8ce189f9cefc4 (Sebastian Redl           2009-04-19 21:53:20 +0000  8020) /// primarily interested in pointer types and enumeration types. We also
8ce189f9cefc4 (Sebastian Redl           2009-04-19 21:53:20 +0000  8021) /// take member pointer types, for the conditional operator.
5fb53972380f5 (Douglas Gregor           2009-01-14 15:45:31 +0000  8022) /// AllowUserConversions is true if we should look at the conversion
5fb53972380f5 (Douglas Gregor           2009-01-14 15:45:31 +0000  8023) /// functions of a class type, and AllowExplicitConversions if we
5fb53972380f5 (Douglas Gregor           2009-01-14 15:45:31 +0000  8024) /// should also include the explicit conversion functions of a class
5fb53972380f5 (Douglas Gregor           2009-01-14 15:45:31 +0000  8025) /// type.
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  8026) void
5fb53972380f5 (Douglas Gregor           2009-01-14 15:45:31 +0000  8027) BuiltinCandidateTypeSet::AddTypesConvertedFrom(QualType Ty,
c02cfe2a55e13 (Douglas Gregor           2009-10-21 23:19:44 +0000  8028)                                                SourceLocation Loc,
5fb53972380f5 (Douglas Gregor           2009-01-14 15:45:31 +0000  8029)                                                bool AllowUserConversions,
3b937fa298ce6 (Fariborz Jahanian        2009-10-15 17:14:05 +0000  8030)                                                bool AllowExplicitConversions,
3b937fa298ce6 (Fariborz Jahanian        2009-10-15 17:14:05 +0000  8031)                                                const Qualifiers &VisibleQuals) {
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8032)   // Only deal with canonical types.
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8033)   Ty = Context.getCanonicalType(Ty);
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8034) 
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8035)   // Look through reference types; they aren't part of the type of an
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8036)   // expression for the purposes of conversions.
c23c7e6a51927 (Ted Kremenek             2009-07-29 21:53:49 +0000  8037)   if (const ReferenceType *RefTy = Ty->getAs<ReferenceType>())
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8038)     Ty = RefTy->getPointeeType();
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8039) 
33ddac05bba47 (John McCall              2011-01-19 10:06:00 +0000  8040)   // If we're dealing with an array type, decay to the pointer.
33ddac05bba47 (John McCall              2011-01-19 10:06:00 +0000  8041)   if (Ty->isArrayType())
33ddac05bba47 (John McCall              2011-01-19 10:06:00 +0000  8042)     Ty = SemaRef.Context.getArrayDecayedType(Ty);
33ddac05bba47 (John McCall              2011-01-19 10:06:00 +0000  8043) 
33ddac05bba47 (John McCall              2011-01-19 10:06:00 +0000  8044)   // Otherwise, we don't care about qualifiers on the type.
1b8fe5b716b8b (Douglas Gregor           2009-11-16 21:35:15 +0000  8045)   Ty = Ty.getLocalUnqualifiedType();
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8046) 
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  8047)   // Flag if we ever add a non-record type.
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  8048)   const RecordType *TyRec = Ty->getAs<RecordType>();
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  8049)   HasNonRecordTypes = HasNonRecordTypes || !TyRec;
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  8050) 
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  8051)   // Flag if we encounter an arithmetic type.
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  8052)   HasArithmeticOrEnumeralTypes =
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  8053)     HasArithmeticOrEnumeralTypes || Ty->isArithmeticType();
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  8054) 
e4151b590ef4b (Fariborz Jahanian        2010-08-21 00:10:36 +0000  8055)   if (Ty->isObjCIdType() || Ty->isObjCClassType())
e4151b590ef4b (Fariborz Jahanian        2010-08-21 00:10:36 +0000  8056)     PointerTypes.insert(Ty);
e4151b590ef4b (Fariborz Jahanian        2010-08-21 00:10:36 +0000  8057)   else if (Ty->getAs<PointerType>() || Ty->getAs<ObjCObjectPointerType>()) {
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8058)     // Insert our type, and its more-qualified variants, into the set
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8059)     // of types.
b06ec054fc550 (Fariborz Jahanian        2009-10-16 22:08:05 +0000  8060)     if (!AddPointerWithMoreQualifiedTypeVariants(Ty, VisibleQuals))
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8061)       return;
8ce189f9cefc4 (Sebastian Redl           2009-04-19 21:53:20 +0000  8062)   } else if (Ty->isMemberPointerType()) {
8ce189f9cefc4 (Sebastian Redl           2009-04-19 21:53:20 +0000  8063)     // Member pointers are far easier, since the pointee can't be converted.
8ce189f9cefc4 (Sebastian Redl           2009-04-19 21:53:20 +0000  8064)     if (!AddMemberPointerWithMoreQualifiedTypeVariants(Ty))
8ce189f9cefc4 (Sebastian Redl           2009-04-19 21:53:20 +0000  8065)       return;
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8066)   } else if (Ty->isEnumeralType()) {
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  8067)     HasArithmeticOrEnumeralTypes = true;
a59a3e2d10626 (Chris Lattner            2009-03-29 00:04:01 +0000  8068)     EnumerationTypes.insert(Ty);
cbfbca14d0a2b (Douglas Gregor           2010-05-19 03:21:00 +0000  8069)   } else if (Ty->isVectorType()) {
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  8070)     // We treat vector types as arithmetic types in many contexts as an
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  8071)     // extension.
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  8072)     HasArithmeticOrEnumeralTypes = true;
cbfbca14d0a2b (Douglas Gregor           2010-05-19 03:21:00 +0000  8073)     VectorTypes.insert(Ty);
6f6e91d193373 (Florian Hahn             2020-05-29 20:42:22 +0100  8074)   } else if (Ty->isMatrixType()) {
6f6e91d193373 (Florian Hahn             2020-05-29 20:42:22 +0100  8075)     // Similar to vector types, we treat vector types as arithmetic types in
6f6e91d193373 (Florian Hahn             2020-05-29 20:42:22 +0100  8076)     // many contexts as an extension.
6f6e91d193373 (Florian Hahn             2020-05-29 20:42:22 +0100  8077)     HasArithmeticOrEnumeralTypes = true;
6f6e91d193373 (Florian Hahn             2020-05-29 20:42:22 +0100  8078)     MatrixTypes.insert(Ty);
80af31397acee (Douglas Gregor           2011-05-21 23:15:46 +0000  8079)   } else if (Ty->isNullPtrType()) {
80af31397acee (Douglas Gregor           2011-05-21 23:15:46 +0000  8080)     HasNullPtrType = true;
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  8081)   } else if (AllowUserConversions && TyRec) {
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  8082)     // No conversion functions in incomplete types.
db0ac5572fcf7 (Richard Smith            2015-12-18 22:40:25 +0000  8083)     if (!SemaRef.isCompleteType(Loc, Ty))
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  8084)       return;
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  8085) 
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  8086)     CXXRecordDecl *ClassDecl = cast<CXXRecordDecl>(TyRec->getDecl());
b4ef66832dee0 (Benjamin Kramer          2015-02-06 17:25:10 +0000  8087)     for (NamedDecl *D : ClassDecl->getVisibleConversionFunctions()) {
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  8088)       if (isa<UsingShadowDecl>(D))
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  8089)         D = cast<UsingShadowDecl>(D)->getTargetDecl();
05155d8d7b215 (Douglas Gregor           2009-08-21 23:19:43 +0000  8090) 
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  8091)       // Skip conversion function templates; they don't tell us anything
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  8092)       // about which builtin types we can convert to.
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  8093)       if (isa<FunctionTemplateDecl>(D))
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  8094)         continue;
05155d8d7b215 (Douglas Gregor           2009-08-21 23:19:43 +0000  8095) 
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  8096)       CXXConversionDecl *Conv = cast<CXXConversionDecl>(D);
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  8097)       if (AllowExplicitConversions || !Conv->isExplicit()) {
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  8098)         AddTypesConvertedFrom(Conv->getConversionType(), Loc, false, false,
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  8099)                               VisibleQuals);
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8100)       }
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8101)     }
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8102)   }
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8103) }
27e5c212ee42b (Anastasia Stulova        2019-03-07 16:43:41 +0000  8104) /// Helper function for adjusting address spaces for the pointer or reference
27e5c212ee42b (Anastasia Stulova        2019-03-07 16:43:41 +0000  8105) /// operands of builtin operators depending on the argument.
27e5c212ee42b (Anastasia Stulova        2019-03-07 16:43:41 +0000  8106) static QualType AdjustAddressSpaceForBuiltinOperandType(Sema &S, QualType T,
27e5c212ee42b (Anastasia Stulova        2019-03-07 16:43:41 +0000  8107)                                                         Expr *Arg) {
27e5c212ee42b (Anastasia Stulova        2019-03-07 16:43:41 +0000  8108)   return S.Context.getAddrSpaceQualType(T, Arg->getType().getAddressSpace());
27e5c212ee42b (Anastasia Stulova        2019-03-07 16:43:41 +0000  8109) }
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8110) 
9fc8faf9e6197 (Adrian Prantl            2018-05-09 01:00:01 +0000  8111) /// Helper function for AddBuiltinOperatorCandidates() that adds
84605aeac90e0 (Douglas Gregor           2009-08-24 13:43:27 +0000  8112) /// the volatile- and non-volatile-qualified assignment operators for the
84605aeac90e0 (Douglas Gregor           2009-08-24 13:43:27 +0000  8113) /// given type to the candidate set.
84605aeac90e0 (Douglas Gregor           2009-08-24 13:43:27 +0000  8114) static void AddBuiltinAssignmentOperatorCandidates(Sema &S,
84605aeac90e0 (Douglas Gregor           2009-08-24 13:43:27 +0000  8115)                                                    QualType T,
e54c307bb4ed9 (Richard Smith            2013-05-05 15:51:06 +0000  8116)                                                    ArrayRef<Expr *> Args,
84605aeac90e0 (Douglas Gregor           2009-08-24 13:43:27 +0000  8117)                                     OverloadCandidateSet &CandidateSet) {
84605aeac90e0 (Douglas Gregor           2009-08-24 13:43:27 +0000  8118)   QualType ParamTypes[2];
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  8119) 
84605aeac90e0 (Douglas Gregor           2009-08-24 13:43:27 +0000  8120)   // T& operator=(T&, T)
27e5c212ee42b (Anastasia Stulova        2019-03-07 16:43:41 +0000  8121)   ParamTypes[0] = S.Context.getLValueReferenceType(
27e5c212ee42b (Anastasia Stulova        2019-03-07 16:43:41 +0000  8122)       AdjustAddressSpaceForBuiltinOperandType(S, T, Args[0]));
84605aeac90e0 (Douglas Gregor           2009-08-24 13:43:27 +0000  8123)   ParamTypes[1] = T;
c07c389a94bb4 (George Burgess IV        2017-06-08 18:19:25 +0000  8124)   S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet,
84605aeac90e0 (Douglas Gregor           2009-08-24 13:43:27 +0000  8125)                         /*IsAssignmentOperator=*/true);
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  8126) 
84605aeac90e0 (Douglas Gregor           2009-08-24 13:43:27 +0000  8127)   if (!S.Context.getCanonicalType(T).isVolatileQualified()) {
84605aeac90e0 (Douglas Gregor           2009-08-24 13:43:27 +0000  8128)     // volatile T& operator=(volatile T&, T)
27e5c212ee42b (Anastasia Stulova        2019-03-07 16:43:41 +0000  8129)     ParamTypes[0] = S.Context.getLValueReferenceType(
27e5c212ee42b (Anastasia Stulova        2019-03-07 16:43:41 +0000  8130)         AdjustAddressSpaceForBuiltinOperandType(S, S.Context.getVolatileType(T),
27e5c212ee42b (Anastasia Stulova        2019-03-07 16:43:41 +0000  8131)                                                 Args[0]));
84605aeac90e0 (Douglas Gregor           2009-08-24 13:43:27 +0000  8132)     ParamTypes[1] = T;
c07c389a94bb4 (George Burgess IV        2017-06-08 18:19:25 +0000  8133)     S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet,
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  8134)                           /*IsAssignmentOperator=*/true);
84605aeac90e0 (Douglas Gregor           2009-08-24 13:43:27 +0000  8135)   }
84605aeac90e0 (Douglas Gregor           2009-08-24 13:43:27 +0000  8136) }
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  8137) 
1054faed320dd (Sebastian Redl           2009-10-25 17:03:50 +0000  8138) /// CollectVRQualifiers - This routine returns Volatile/Restrict qualifiers,
1054faed320dd (Sebastian Redl           2009-10-25 17:03:50 +0000  8139) /// if any, found in visible type conversion functions found in ArgExpr's type.
3b937fa298ce6 (Fariborz Jahanian        2009-10-15 17:14:05 +0000  8140) static  Qualifiers CollectVRQualifiers(ASTContext &Context, Expr* ArgExpr) {
3b937fa298ce6 (Fariborz Jahanian        2009-10-15 17:14:05 +0000  8141)     Qualifiers VRQuals;
3b937fa298ce6 (Fariborz Jahanian        2009-10-15 17:14:05 +0000  8142)     const RecordType *TyRec;
3b937fa298ce6 (Fariborz Jahanian        2009-10-15 17:14:05 +0000  8143)     if (const MemberPointerType *RHSMPType =
3b937fa298ce6 (Fariborz Jahanian        2009-10-15 17:14:05 +0000  8144)         ArgExpr->getType()->getAs<MemberPointerType>())
d0ace024965bb (Douglas Gregor           2010-04-25 00:55:24 +0000  8145)       TyRec = RHSMPType->getClass()->getAs<RecordType>();
3b937fa298ce6 (Fariborz Jahanian        2009-10-15 17:14:05 +0000  8146)     else
3b937fa298ce6 (Fariborz Jahanian        2009-10-15 17:14:05 +0000  8147)       TyRec = ArgExpr->getType()->getAs<RecordType>();
3b937fa298ce6 (Fariborz Jahanian        2009-10-15 17:14:05 +0000  8148)     if (!TyRec) {
b06ec054fc550 (Fariborz Jahanian        2009-10-16 22:08:05 +0000  8149)       // Just to be safe, assume the worst case.
3b937fa298ce6 (Fariborz Jahanian        2009-10-15 17:14:05 +0000  8150)       VRQuals.addVolatile();
3b937fa298ce6 (Fariborz Jahanian        2009-10-15 17:14:05 +0000  8151)       VRQuals.addRestrict();
3b937fa298ce6 (Fariborz Jahanian        2009-10-15 17:14:05 +0000  8152)       return VRQuals;
3b937fa298ce6 (Fariborz Jahanian        2009-10-15 17:14:05 +0000  8153)     }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  8154) 
3b937fa298ce6 (Fariborz Jahanian        2009-10-15 17:14:05 +0000  8155)     CXXRecordDecl *ClassDecl = cast<CXXRecordDecl>(TyRec->getDecl());
67da35c832e66 (John McCall              2010-02-04 22:26:26 +0000  8156)     if (!ClassDecl->hasDefinition())
67da35c832e66 (John McCall              2010-02-04 22:26:26 +0000  8157)       return VRQuals;
67da35c832e66 (John McCall              2010-02-04 22:26:26 +0000  8158) 
b4ef66832dee0 (Benjamin Kramer          2015-02-06 17:25:10 +0000  8159)     for (NamedDecl *D : ClassDecl->getVisibleConversionFunctions()) {
da4458e98f54c (John McCall              2010-03-31 01:36:47 +0000  8160)       if (isa<UsingShadowDecl>(D))
da4458e98f54c (John McCall              2010-03-31 01:36:47 +0000  8161)         D = cast<UsingShadowDecl>(D)->getTargetDecl();
da4458e98f54c (John McCall              2010-03-31 01:36:47 +0000  8162)       if (CXXConversionDecl *Conv = dyn_cast<CXXConversionDecl>(D)) {
3b937fa298ce6 (Fariborz Jahanian        2009-10-15 17:14:05 +0000  8163)         QualType CanTy = Context.getCanonicalType(Conv->getConversionType());
3b937fa298ce6 (Fariborz Jahanian        2009-10-15 17:14:05 +0000  8164)         if (const ReferenceType *ResTypeRef = CanTy->getAs<ReferenceType>())
3b937fa298ce6 (Fariborz Jahanian        2009-10-15 17:14:05 +0000  8165)           CanTy = ResTypeRef->getPointeeType();
3b937fa298ce6 (Fariborz Jahanian        2009-10-15 17:14:05 +0000  8166)         // Need to go down the pointer/mempointer chain and add qualifiers
3b937fa298ce6 (Fariborz Jahanian        2009-10-15 17:14:05 +0000  8167)         // as see them.
3b937fa298ce6 (Fariborz Jahanian        2009-10-15 17:14:05 +0000  8168)         bool done = false;
3b937fa298ce6 (Fariborz Jahanian        2009-10-15 17:14:05 +0000  8169)         while (!done) {
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  8170)           if (CanTy.isRestrictQualified())
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  8171)             VRQuals.addRestrict();
3b937fa298ce6 (Fariborz Jahanian        2009-10-15 17:14:05 +0000  8172)           if (const PointerType *ResTypePtr = CanTy->getAs<PointerType>())
3b937fa298ce6 (Fariborz Jahanian        2009-10-15 17:14:05 +0000  8173)             CanTy = ResTypePtr->getPointeeType();
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  8174)           else if (const MemberPointerType *ResTypeMPtr =
3b937fa298ce6 (Fariborz Jahanian        2009-10-15 17:14:05 +0000  8175)                 CanTy->getAs<MemberPointerType>())
3b937fa298ce6 (Fariborz Jahanian        2009-10-15 17:14:05 +0000  8176)             CanTy = ResTypeMPtr->getPointeeType();
3b937fa298ce6 (Fariborz Jahanian        2009-10-15 17:14:05 +0000  8177)           else
3b937fa298ce6 (Fariborz Jahanian        2009-10-15 17:14:05 +0000  8178)             done = true;
3b937fa298ce6 (Fariborz Jahanian        2009-10-15 17:14:05 +0000  8179)           if (CanTy.isVolatileQualified())
3b937fa298ce6 (Fariborz Jahanian        2009-10-15 17:14:05 +0000  8180)             VRQuals.addVolatile();
3b937fa298ce6 (Fariborz Jahanian        2009-10-15 17:14:05 +0000  8181)           if (VRQuals.hasRestrict() && VRQuals.hasVolatile())
3b937fa298ce6 (Fariborz Jahanian        2009-10-15 17:14:05 +0000  8182)             return VRQuals;
3b937fa298ce6 (Fariborz Jahanian        2009-10-15 17:14:05 +0000  8183)         }
3b937fa298ce6 (Fariborz Jahanian        2009-10-15 17:14:05 +0000  8184)       }
3b937fa298ce6 (Fariborz Jahanian        2009-10-15 17:14:05 +0000  8185)     }
3b937fa298ce6 (Fariborz Jahanian        2009-10-15 17:14:05 +0000  8186)     return VRQuals;
3b937fa298ce6 (Fariborz Jahanian        2009-10-15 17:14:05 +0000  8187) }
528729872ed9c (John McCall              2010-11-13 05:51:15 +0000  8188) 
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8189) namespace {
528729872ed9c (John McCall              2010-11-13 05:51:15 +0000  8190) 
9fc8faf9e6197 (Adrian Prantl            2018-05-09 01:00:01 +0000  8191) /// Helper class to manage the addition of builtin operator overload
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8192) /// candidates. It provides shared state and utility methods used throughout
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8193) /// the process, as well as a helper method to add each group of builtin
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8194) /// operator overloads from the standard to a candidate set.
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8195) class BuiltinOperatorOverloadBuilder {
c6586e52a9640 (Chandler Carruth         2010-12-12 10:35:00 +0000  8196)   // Common instance state available to all overload candidate addition methods.
c6586e52a9640 (Chandler Carruth         2010-12-12 10:35:00 +0000  8197)   Sema &S;
e54c307bb4ed9 (Richard Smith            2013-05-05 15:51:06 +0000  8198)   ArrayRef<Expr *> Args;
c6586e52a9640 (Chandler Carruth         2010-12-12 10:35:00 +0000  8199)   Qualifiers VisibleTypeConversionsQuals;
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  8200)   bool HasArithmeticOrEnumeralCandidateType;
0e62c1cc0b47c (Chris Lattner            2011-07-23 10:55:15 +0000  8201)   SmallVectorImpl<BuiltinCandidateTypeSet> &CandidateTypes;
c6586e52a9640 (Chandler Carruth         2010-12-12 10:35:00 +0000  8202)   OverloadCandidateSet &CandidateSet;
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8203) 
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8204)   static constexpr int ArithmeticTypesCap = 24;
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8205)   SmallVector<CanQualType, ArithmeticTypesCap> ArithmeticTypes;
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8206) 
f64918d092c07 (Nico Weber               2019-08-21 15:49:21 +0000  8207)   // Define some indices used to iterate over the arithmetic types in
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8208)   // ArithmeticTypes.  The "promoted arithmetic types" are the arithmetic
528729872ed9c (John McCall              2010-11-13 05:51:15 +0000  8209)   // types are that preserved by promotion (C++ [over.built]p2).
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8210)   unsigned FirstIntegralType,
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8211)            LastIntegralType;
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8212)   unsigned FirstPromotedIntegralType,
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8213)            LastPromotedIntegralType;
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8214)   unsigned FirstPromotedArithmeticType,
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8215)            LastPromotedArithmeticType;
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8216)   unsigned NumArithmeticTypes;
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8217) 
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8218)   void InitArithmeticTypes() {
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8219)     // Start of promoted types.
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8220)     FirstPromotedArithmeticType = 0;
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8221)     ArithmeticTypes.push_back(S.Context.FloatTy);
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8222)     ArithmeticTypes.push_back(S.Context.DoubleTy);
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8223)     ArithmeticTypes.push_back(S.Context.LongDoubleTy);
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8224)     if (S.Context.getTargetInfo().hasFloat128Type())
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8225)       ArithmeticTypes.push_back(S.Context.Float128Ty);
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8226) 
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8227)     // Start of integral types.
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8228)     FirstIntegralType = ArithmeticTypes.size();
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8229)     FirstPromotedIntegralType = ArithmeticTypes.size();
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8230)     ArithmeticTypes.push_back(S.Context.IntTy);
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8231)     ArithmeticTypes.push_back(S.Context.LongTy);
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8232)     ArithmeticTypes.push_back(S.Context.LongLongTy);
f8d5b49c786f5 (Jennifer Yu              2020-12-04 14:54:12 -0800  8233)     if (S.Context.getTargetInfo().hasInt128Type() ||
f8d5b49c786f5 (Jennifer Yu              2020-12-04 14:54:12 -0800  8234)         (S.Context.getAuxTargetInfo() &&
f8d5b49c786f5 (Jennifer Yu              2020-12-04 14:54:12 -0800  8235)          S.Context.getAuxTargetInfo()->hasInt128Type()))
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8236)       ArithmeticTypes.push_back(S.Context.Int128Ty);
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8237)     ArithmeticTypes.push_back(S.Context.UnsignedIntTy);
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8238)     ArithmeticTypes.push_back(S.Context.UnsignedLongTy);
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8239)     ArithmeticTypes.push_back(S.Context.UnsignedLongLongTy);
f8d5b49c786f5 (Jennifer Yu              2020-12-04 14:54:12 -0800  8240)     if (S.Context.getTargetInfo().hasInt128Type() ||
f8d5b49c786f5 (Jennifer Yu              2020-12-04 14:54:12 -0800  8241)         (S.Context.getAuxTargetInfo() &&
f8d5b49c786f5 (Jennifer Yu              2020-12-04 14:54:12 -0800  8242)          S.Context.getAuxTargetInfo()->hasInt128Type()))
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8243)       ArithmeticTypes.push_back(S.Context.UnsignedInt128Ty);
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8244)     LastPromotedIntegralType = ArithmeticTypes.size();
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8245)     LastPromotedArithmeticType = ArithmeticTypes.size();
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8246)     // End of promoted types.
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8247) 
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8248)     ArithmeticTypes.push_back(S.Context.BoolTy);
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8249)     ArithmeticTypes.push_back(S.Context.CharTy);
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8250)     ArithmeticTypes.push_back(S.Context.WCharTy);
3a8244df6fb88 (Richard Smith            2018-05-01 05:02:45 +0000  8251)     if (S.Context.getLangOpts().Char8)
3a8244df6fb88 (Richard Smith            2018-05-01 05:02:45 +0000  8252)       ArithmeticTypes.push_back(S.Context.Char8Ty);
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8253)     ArithmeticTypes.push_back(S.Context.Char16Ty);
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8254)     ArithmeticTypes.push_back(S.Context.Char32Ty);
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8255)     ArithmeticTypes.push_back(S.Context.SignedCharTy);
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8256)     ArithmeticTypes.push_back(S.Context.ShortTy);
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8257)     ArithmeticTypes.push_back(S.Context.UnsignedCharTy);
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8258)     ArithmeticTypes.push_back(S.Context.UnsignedShortTy);
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8259)     LastIntegralType = ArithmeticTypes.size();
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8260)     NumArithmeticTypes = ArithmeticTypes.size();
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8261)     // End of integral types.
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8262)     // FIXME: What about complex? What about half?
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8263) 
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8264)     assert(ArithmeticTypes.size() <= ArithmeticTypesCap &&
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8265)            "Enough inline storage for all arithmetic types.");
c6586e52a9640 (Chandler Carruth         2010-12-12 10:35:00 +0000  8266)   }
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8267) 
9fc8faf9e6197 (Adrian Prantl            2018-05-09 01:00:01 +0000  8268)   /// Helper method to factor out the common pattern of adding overloads
5659c0c480d4b (Chandler Carruth         2010-12-12 09:22:45 +0000  8269)   /// for '++' and '--' builtin operators.
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8270)   void addPlusPlusMinusMinusStyleOverloads(QualType CandidateTy,
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  8271)                                            bool HasVolatile,
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  8272)                                            bool HasRestrict) {
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8273)     QualType ParamTypes[2] = {
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8274)       S.Context.getLValueReferenceType(CandidateTy),
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8275)       S.Context.IntTy
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8276)     };
d08452f60a273 (Douglas Gregor           2008-11-19 15:42:04 +0000  8277) 
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8278)     // Non-volatile version.
c07c389a94bb4 (George Burgess IV        2017-06-08 18:19:25 +0000  8279)     S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8280) 
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8281)     // Use a heuristic to reduce number of builtin candidates in the set:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8282)     // add volatile version only if there are conversions to a volatile type.
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8283)     if (HasVolatile) {
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8284)       ParamTypes[0] =
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8285)         S.Context.getLValueReferenceType(
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8286)           S.Context.getVolatileType(CandidateTy));
c07c389a94bb4 (George Burgess IV        2017-06-08 18:19:25 +0000  8287)       S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8288)     }
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  8289) 
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  8290)     // Add restrict version only if there are conversions to a restrict type
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  8291)     // and our candidate type is a non-restrict-qualified pointer.
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  8292)     if (HasRestrict && CandidateTy->isAnyPointerType() &&
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  8293)         !CandidateTy.isRestrictQualified()) {
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  8294)       ParamTypes[0]
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  8295)         = S.Context.getLValueReferenceType(
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  8296)             S.Context.getCVRQualifiedType(CandidateTy, Qualifiers::Restrict));
c07c389a94bb4 (George Burgess IV        2017-06-08 18:19:25 +0000  8297)       S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet);
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  8298) 
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  8299)       if (HasVolatile) {
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  8300)         ParamTypes[0]
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  8301)           = S.Context.getLValueReferenceType(
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  8302)               S.Context.getCVRQualifiedType(CandidateTy,
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  8303)                                             (Qualifiers::Volatile |
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  8304)                                              Qualifiers::Restrict)));
c07c389a94bb4 (George Burgess IV        2017-06-08 18:19:25 +0000  8305)         S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet);
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  8306)       }
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  8307)     }
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  8308) 
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8309)   }
d08452f60a273 (Douglas Gregor           2008-11-19 15:42:04 +0000  8310) 
6f6e91d193373 (Florian Hahn             2020-05-29 20:42:22 +0100  8311)   /// Helper to add an overload candidate for a binary builtin with types \p L
6f6e91d193373 (Florian Hahn             2020-05-29 20:42:22 +0100  8312)   /// and \p R.
6f6e91d193373 (Florian Hahn             2020-05-29 20:42:22 +0100  8313)   void AddCandidate(QualType L, QualType R) {
6f6e91d193373 (Florian Hahn             2020-05-29 20:42:22 +0100  8314)     QualType LandR[2] = {L, R};
6f6e91d193373 (Florian Hahn             2020-05-29 20:42:22 +0100  8315)     S.AddBuiltinCandidate(LandR, Args, CandidateSet);
6f6e91d193373 (Florian Hahn             2020-05-29 20:42:22 +0100  8316)   }
6f6e91d193373 (Florian Hahn             2020-05-29 20:42:22 +0100  8317) 
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8318) public:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8319)   BuiltinOperatorOverloadBuilder(
e54c307bb4ed9 (Richard Smith            2013-05-05 15:51:06 +0000  8320)     Sema &S, ArrayRef<Expr *> Args,
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8321)     Qualifiers VisibleTypeConversionsQuals,
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  8322)     bool HasArithmeticOrEnumeralCandidateType,
0e62c1cc0b47c (Chris Lattner            2011-07-23 10:55:15 +0000  8323)     SmallVectorImpl<BuiltinCandidateTypeSet> &CandidateTypes,
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8324)     OverloadCandidateSet &CandidateSet)
e54c307bb4ed9 (Richard Smith            2013-05-05 15:51:06 +0000  8325)     : S(S), Args(Args),
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8326)       VisibleTypeConversionsQuals(VisibleTypeConversionsQuals),
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  8327)       HasArithmeticOrEnumeralCandidateType(
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  8328)         HasArithmeticOrEnumeralCandidateType),
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8329)       CandidateTypes(CandidateTypes),
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8330)       CandidateSet(CandidateSet) {
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8331) 
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8332)     InitArithmeticTypes();
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8333)   }
d08452f60a273 (Douglas Gregor           2008-11-19 15:42:04 +0000  8334) 
536d2e30721e2 (Jan Korous               2018-04-18 13:38:39 +0000  8335)   // Increment is deprecated for bool since C++17.
536d2e30721e2 (Jan Korous               2018-04-18 13:38:39 +0000  8336)   //
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8337)   // C++ [over.built]p3:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8338)   //
536d2e30721e2 (Jan Korous               2018-04-18 13:38:39 +0000  8339)   //   For every pair (T, VQ), where T is an arithmetic type other
536d2e30721e2 (Jan Korous               2018-04-18 13:38:39 +0000  8340)   //   than bool, and VQ is either volatile or empty, there exist
536d2e30721e2 (Jan Korous               2018-04-18 13:38:39 +0000  8341)   //   candidate operator functions of the form
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8342)   //
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8343)   //       VQ T&      operator++(VQ T&);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8344)   //       T          operator++(VQ T&, int);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8345)   //
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8346)   // C++ [over.built]p4:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8347)   //
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8348)   //   For every pair (T, VQ), where T is an arithmetic type other
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8349)   //   than bool, and VQ is either volatile or empty, there exist
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8350)   //   candidate operator functions of the form
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8351)   //
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8352)   //       VQ T&      operator--(VQ T&);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8353)   //       T          operator--(VQ T&, int);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8354)   void addPlusPlusMinusMinusArithmeticOverloads(OverloadedOperatorKind Op) {
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  8355)     if (!HasArithmeticOrEnumeralCandidateType)
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  8356)       return;
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  8357) 
d74ebe22db891 (Jan Korous               2018-04-11 13:36:29 +0000  8358)     for (unsigned Arith = 0; Arith < NumArithmeticTypes; ++Arith) {
d74ebe22db891 (Jan Korous               2018-04-11 13:36:29 +0000  8359)       const auto TypeOfT = ArithmeticTypes[Arith];
536d2e30721e2 (Jan Korous               2018-04-18 13:38:39 +0000  8360)       if (TypeOfT == S.Context.BoolTy) {
536d2e30721e2 (Jan Korous               2018-04-18 13:38:39 +0000  8361)         if (Op == OO_MinusMinus)
536d2e30721e2 (Jan Korous               2018-04-18 13:38:39 +0000  8362)           continue;
536d2e30721e2 (Jan Korous               2018-04-18 13:38:39 +0000  8363)         if (Op == OO_PlusPlus && S.getLangOpts().CPlusPlus17)
536d2e30721e2 (Jan Korous               2018-04-18 13:38:39 +0000  8364)           continue;
536d2e30721e2 (Jan Korous               2018-04-18 13:38:39 +0000  8365)       }
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8366)       addPlusPlusMinusMinusStyleOverloads(
d74ebe22db891 (Jan Korous               2018-04-11 13:36:29 +0000  8367)         TypeOfT,
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  8368)         VisibleTypeConversionsQuals.hasVolatile(),
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  8369)         VisibleTypeConversionsQuals.hasRestrict());
d08452f60a273 (Douglas Gregor           2008-11-19 15:42:04 +0000  8370)     }
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8371)   }
d08452f60a273 (Douglas Gregor           2008-11-19 15:42:04 +0000  8372) 
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8373)   // C++ [over.built]p5:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8374)   //
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8375)   //   For every pair (T, VQ), where T is a cv-qualified or
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8376)   //   cv-unqualified object type, and VQ is either volatile or
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8377)   //   empty, there exist candidate operator functions of the form
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8378)   //
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8379)   //       T*VQ&      operator++(T*VQ&);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8380)   //       T*VQ&      operator--(T*VQ&);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8381)   //       T*         operator++(T*VQ&, int);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8382)   //       T*         operator--(T*VQ&, int);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8383)   void addPlusPlusMinusMinusPointerOverloads() {
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8384)     for (QualType PtrTy : CandidateTypes[0].pointer_types()) {
d08452f60a273 (Douglas Gregor           2008-11-19 15:42:04 +0000  8385)       // Skip pointer types that aren't pointers to object types.
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8386)       if (!PtrTy->getPointeeType()->isObjectType())
d08452f60a273 (Douglas Gregor           2008-11-19 15:42:04 +0000  8387)         continue;
d08452f60a273 (Douglas Gregor           2008-11-19 15:42:04 +0000  8388) 
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8389)       addPlusPlusMinusMinusStyleOverloads(
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8390)           PtrTy,
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8391)           (!PtrTy.isVolatileQualified() &&
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8392)            VisibleTypeConversionsQuals.hasVolatile()),
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8393)           (!PtrTy.isRestrictQualified() &&
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8394)            VisibleTypeConversionsQuals.hasRestrict()));
d08452f60a273 (Douglas Gregor           2008-11-19 15:42:04 +0000  8395)     }
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8396)   }
d08452f60a273 (Douglas Gregor           2008-11-19 15:42:04 +0000  8397) 
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8398)   // C++ [over.built]p6:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8399)   //   For every cv-qualified or cv-unqualified object type T, there
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8400)   //   exist candidate operator functions of the form
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8401)   //
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8402)   //       T&         operator*(T*);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8403)   //
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8404)   // C++ [over.built]p7:
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  8405)   //   For every function type T that does not have cv-qualifiers or a
0282432039ab9 (Douglas Gregor           2011-01-26 19:30:28 +0000  8406)   //   ref-qualifier, there exist candidate operator functions of the form
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8407)   //       T&         operator*(T*);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8408)   void addUnaryStarPointerOverloads() {
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8409)     for (QualType ParamTy : CandidateTypes[0].pointer_types()) {
421ad5e1e67bb (Argyrios Kyrtzidis       2010-08-23 07:12:16 +0000  8410)       QualType PointeeTy = ParamTy->getPointeeType();
66990031e2951 (Douglas Gregor           2011-01-05 00:13:17 +0000  8411)       if (!PointeeTy->isObjectType() && !PointeeTy->isFunctionType())
66990031e2951 (Douglas Gregor           2011-01-05 00:13:17 +0000  8412)         continue;
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  8413) 
0282432039ab9 (Douglas Gregor           2011-01-26 19:30:28 +0000  8414)       if (const FunctionProtoType *Proto =PointeeTy->getAs<FunctionProtoType>())
c61eaa5920161 (Anastasia Stulova        2019-01-28 11:37:49 +0000  8415)         if (Proto->getMethodQuals() || Proto->getRefQualifier())
0282432039ab9 (Douglas Gregor           2011-01-26 19:30:28 +0000  8416)           continue;
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  8417) 
c07c389a94bb4 (George Burgess IV        2017-06-08 18:19:25 +0000  8418)       S.AddBuiltinCandidate(&ParamTy, Args, CandidateSet);
d08452f60a273 (Douglas Gregor           2008-11-19 15:42:04 +0000  8419)     }
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8420)   }
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  8421) 
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8422)   // C++ [over.built]p9:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8423)   //  For every promoted arithmetic type T, there exist candidate
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8424)   //  operator functions of the form
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8425)   //
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8426)   //       T         operator+(T);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8427)   //       T         operator-(T);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8428)   void addUnaryPlusOrMinusArithmeticOverloads() {
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  8429)     if (!HasArithmeticOrEnumeralCandidateType)
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  8430)       return;
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  8431) 
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  8432)     for (unsigned Arith = FirstPromotedArithmeticType;
d08452f60a273 (Douglas Gregor           2008-11-19 15:42:04 +0000  8433)          Arith < LastPromotedArithmeticType; ++Arith) {
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8434)       QualType ArithTy = ArithmeticTypes[Arith];
c07c389a94bb4 (George Burgess IV        2017-06-08 18:19:25 +0000  8435)       S.AddBuiltinCandidate(&ArithTy, Args, CandidateSet);
d08452f60a273 (Douglas Gregor           2008-11-19 15:42:04 +0000  8436)     }
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8437) 
cbfbca14d0a2b (Douglas Gregor           2010-05-19 03:21:00 +0000  8438)     // Extension: We also add these operators for vector types.
714e84be4615d (Florian Hahn             2020-06-04 20:15:21 +0100  8439)     for (QualType VecTy : CandidateTypes[0].vector_types())
c07c389a94bb4 (George Burgess IV        2017-06-08 18:19:25 +0000  8440)       S.AddBuiltinCandidate(&VecTy, Args, CandidateSet);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8441)   }
d08452f60a273 (Douglas Gregor           2008-11-19 15:42:04 +0000  8442) 
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8443)   // C++ [over.built]p8:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8444)   //   For every type T, there exist candidate operator functions of
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8445)   //   the form
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8446)   //
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8447)   //       T*         operator+(T*);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8448)   void addUnaryPlusPointerOverloads() {
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8449)     for (QualType ParamTy : CandidateTypes[0].pointer_types())
c07c389a94bb4 (George Burgess IV        2017-06-08 18:19:25 +0000  8450)       S.AddBuiltinCandidate(&ParamTy, Args, CandidateSet);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8451)   }
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8452) 
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8453)   // C++ [over.built]p10:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8454)   //   For every promoted integral type T, there exist candidate
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8455)   //   operator functions of the form
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8456)   //
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8457)   //        T         operator~(T);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8458)   void addUnaryTildePromotedIntegralOverloads() {
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  8459)     if (!HasArithmeticOrEnumeralCandidateType)
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  8460)       return;
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  8461) 
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  8462)     for (unsigned Int = FirstPromotedIntegralType;
d08452f60a273 (Douglas Gregor           2008-11-19 15:42:04 +0000  8463)          Int < LastPromotedIntegralType; ++Int) {
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8464)       QualType IntTy = ArithmeticTypes[Int];
c07c389a94bb4 (George Burgess IV        2017-06-08 18:19:25 +0000  8465)       S.AddBuiltinCandidate(&IntTy, Args, CandidateSet);
d08452f60a273 (Douglas Gregor           2008-11-19 15:42:04 +0000  8466)     }
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8467) 
cbfbca14d0a2b (Douglas Gregor           2010-05-19 03:21:00 +0000  8468)     // Extension: We also add this operator for vector types.
714e84be4615d (Florian Hahn             2020-06-04 20:15:21 +0100  8469)     for (QualType VecTy : CandidateTypes[0].vector_types())
c07c389a94bb4 (George Burgess IV        2017-06-08 18:19:25 +0000  8470)       S.AddBuiltinCandidate(&VecTy, Args, CandidateSet);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8471)   }
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8472) 
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8473)   // C++ [over.match.oper]p16:
5e9746f520e6b (Richard Smith            2016-10-21 22:00:42 +0000  8474)   //   For every pointer to member type T or type std::nullptr_t, there
5e9746f520e6b (Richard Smith            2016-10-21 22:00:42 +0000  8475)   //   exist candidate operator functions of the form
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8476)   //
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8477)   //        bool operator==(T,T);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8478)   //        bool operator!=(T,T);
5e9746f520e6b (Richard Smith            2016-10-21 22:00:42 +0000  8479)   void addEqualEqualOrNotEqualMemberPointerOrNullptrOverloads() {
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8480)     /// Set of (canonical) types that we've already handled.
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8481)     llvm::SmallPtrSet<QualType, 8> AddedTypes;
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8482) 
e54c307bb4ed9 (Richard Smith            2013-05-05 15:51:06 +0000  8483)     for (unsigned ArgIdx = 0, N = Args.size(); ArgIdx != N; ++ArgIdx) {
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8484)       for (QualType MemPtrTy : CandidateTypes[ArgIdx].member_pointer_types()) {
b37c9af75dae4 (Douglas Gregor           2010-11-03 17:00:07 +0000  8485)         // Don't add the same builtin candidate twice.
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8486)         if (!AddedTypes.insert(S.Context.getCanonicalType(MemPtrTy)).second)
b37c9af75dae4 (Douglas Gregor           2010-11-03 17:00:07 +0000  8487)           continue;
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8488) 
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8489)         QualType ParamTypes[2] = {MemPtrTy, MemPtrTy};
c07c389a94bb4 (George Burgess IV        2017-06-08 18:19:25 +0000  8490)         S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet);
b37c9af75dae4 (Douglas Gregor           2010-11-03 17:00:07 +0000  8491)       }
5e9746f520e6b (Richard Smith            2016-10-21 22:00:42 +0000  8492) 
5e9746f520e6b (Richard Smith            2016-10-21 22:00:42 +0000  8493)       if (CandidateTypes[ArgIdx].hasNullPtrType()) {
5e9746f520e6b (Richard Smith            2016-10-21 22:00:42 +0000  8494)         CanQualType NullPtrTy = S.Context.getCanonicalType(S.Context.NullPtrTy);
5e9746f520e6b (Richard Smith            2016-10-21 22:00:42 +0000  8495)         if (AddedTypes.insert(NullPtrTy).second) {
5e9746f520e6b (Richard Smith            2016-10-21 22:00:42 +0000  8496)           QualType ParamTypes[2] = { NullPtrTy, NullPtrTy };
c07c389a94bb4 (George Burgess IV        2017-06-08 18:19:25 +0000  8497)           S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet);
5e9746f520e6b (Richard Smith            2016-10-21 22:00:42 +0000  8498)         }
5e9746f520e6b (Richard Smith            2016-10-21 22:00:42 +0000  8499)       }
84605aeac90e0 (Douglas Gregor           2009-08-24 13:43:27 +0000  8500)     }
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8501)   }
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8502) 
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8503)   // C++ [over.built]p15:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8504)   //
5e9746f520e6b (Richard Smith            2016-10-21 22:00:42 +0000  8505)   //   For every T, where T is an enumeration type or a pointer type,
5e9746f520e6b (Richard Smith            2016-10-21 22:00:42 +0000  8506)   //   there exist candidate operator functions of the form
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8507)   //
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8508)   //        bool       operator<(T, T);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8509)   //        bool       operator>(T, T);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8510)   //        bool       operator<=(T, T);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8511)   //        bool       operator>=(T, T);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8512)   //        bool       operator==(T, T);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8513)   //        bool       operator!=(T, T);
0683c0e68d31d (Eric Fiselier            2018-05-07 21:07:10 +0000  8514)   //           R       operator<=>(T, T)
0683c0e68d31d (Eric Fiselier            2018-05-07 21:07:10 +0000  8515)   void addGenericBinaryPointerOrEnumeralOverloads() {
14f082b69d730 (Eli Friedman             2012-09-18 21:52:24 +0000  8516)     // C++ [over.match.oper]p3:
14f082b69d730 (Eli Friedman             2012-09-18 21:52:24 +0000  8517)     //   [...]the built-in candidates include all of the candidate operator
14f082b69d730 (Eli Friedman             2012-09-18 21:52:24 +0000  8518)     //   functions defined in 13.6 that, compared to the given operator, [...]
14f082b69d730 (Eli Friedman             2012-09-18 21:52:24 +0000  8519)     //   do not have the same parameter-type-list as any non-template non-member
14f082b69d730 (Eli Friedman             2012-09-18 21:52:24 +0000  8520)     //   candidate.
c02db8cfb3dad (Chandler Carruth         2010-12-12 09:14:11 +0000  8521)     //
14f082b69d730 (Eli Friedman             2012-09-18 21:52:24 +0000  8522)     // Note that in practice, this only affects enumeration types because there
14f082b69d730 (Eli Friedman             2012-09-18 21:52:24 +0000  8523)     // aren't any built-in candidates of record type, and a user-defined operator
14f082b69d730 (Eli Friedman             2012-09-18 21:52:24 +0000  8524)     // must have an operand of record or enumeration type. Also, the only other
14f082b69d730 (Eli Friedman             2012-09-18 21:52:24 +0000  8525)     // overloaded operator with enumeration arguments, operator=,
c02db8cfb3dad (Chandler Carruth         2010-12-12 09:14:11 +0000  8526)     // cannot be overloaded for enumeration types, so this is the only place
c02db8cfb3dad (Chandler Carruth         2010-12-12 09:14:11 +0000  8527)     // where we must suppress candidates like this.
c02db8cfb3dad (Chandler Carruth         2010-12-12 09:14:11 +0000  8528)     llvm::DenseSet<std::pair<CanQualType, CanQualType> >
c02db8cfb3dad (Chandler Carruth         2010-12-12 09:14:11 +0000  8529)       UserDefinedBinaryOperators;
c02db8cfb3dad (Chandler Carruth         2010-12-12 09:14:11 +0000  8530) 
e54c307bb4ed9 (Richard Smith            2013-05-05 15:51:06 +0000  8531)     for (unsigned ArgIdx = 0, N = Args.size(); ArgIdx != N; ++ArgIdx) {
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8532)       if (!CandidateTypes[ArgIdx].enumeration_types().empty()) {
c02db8cfb3dad (Chandler Carruth         2010-12-12 09:14:11 +0000  8533)         for (OverloadCandidateSet::iterator C = CandidateSet.begin(),
c02db8cfb3dad (Chandler Carruth         2010-12-12 09:14:11 +0000  8534)                                          CEnd = CandidateSet.end();
c02db8cfb3dad (Chandler Carruth         2010-12-12 09:14:11 +0000  8535)              C != CEnd; ++C) {
c02db8cfb3dad (Chandler Carruth         2010-12-12 09:14:11 +0000  8536)           if (!C->Viable || !C->Function || C->Function->getNumParams() != 2)
c02db8cfb3dad (Chandler Carruth         2010-12-12 09:14:11 +0000  8537)             continue;
c02db8cfb3dad (Chandler Carruth         2010-12-12 09:14:11 +0000  8538) 
14f082b69d730 (Eli Friedman             2012-09-18 21:52:24 +0000  8539)           if (C->Function->isFunctionTemplateSpecialization())
14f082b69d730 (Eli Friedman             2012-09-18 21:52:24 +0000  8540)             continue;
14f082b69d730 (Eli Friedman             2012-09-18 21:52:24 +0000  8541) 
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  8542)           // We interpret "same parameter-type-list" as applying to the
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  8543)           // "synthesized candidate, with the order of the two parameters
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  8544)           // reversed", not to the original function.
fcea7fbdba1bd (Richard Smith            2020-02-10 06:05:59 -0800  8545)           bool Reversed = C->isReversed();
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  8546)           QualType FirstParamType = C->Function->getParamDecl(Reversed ? 1 : 0)
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  8547)                                         ->getType()
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  8548)                                         .getUnqualifiedType();
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  8549)           QualType SecondParamType = C->Function->getParamDecl(Reversed ? 0 : 1)
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  8550)                                          ->getType()
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  8551)                                          .getUnqualifiedType();
c02db8cfb3dad (Chandler Carruth         2010-12-12 09:14:11 +0000  8552) 
c02db8cfb3dad (Chandler Carruth         2010-12-12 09:14:11 +0000  8553)           // Skip if either parameter isn't of enumeral type.
c02db8cfb3dad (Chandler Carruth         2010-12-12 09:14:11 +0000  8554)           if (!FirstParamType->isEnumeralType() ||
c02db8cfb3dad (Chandler Carruth         2010-12-12 09:14:11 +0000  8555)               !SecondParamType->isEnumeralType())
c02db8cfb3dad (Chandler Carruth         2010-12-12 09:14:11 +0000  8556)             continue;
c02db8cfb3dad (Chandler Carruth         2010-12-12 09:14:11 +0000  8557) 
c02db8cfb3dad (Chandler Carruth         2010-12-12 09:14:11 +0000  8558)           // Add this operator to the set of known user-defined operators.
c02db8cfb3dad (Chandler Carruth         2010-12-12 09:14:11 +0000  8559)           UserDefinedBinaryOperators.insert(
c02db8cfb3dad (Chandler Carruth         2010-12-12 09:14:11 +0000  8560)             std::make_pair(S.Context.getCanonicalType(FirstParamType),
c02db8cfb3dad (Chandler Carruth         2010-12-12 09:14:11 +0000  8561)                            S.Context.getCanonicalType(SecondParamType)));
c02db8cfb3dad (Chandler Carruth         2010-12-12 09:14:11 +0000  8562)         }
c02db8cfb3dad (Chandler Carruth         2010-12-12 09:14:11 +0000  8563)       }
c02db8cfb3dad (Chandler Carruth         2010-12-12 09:14:11 +0000  8564)     }
c02db8cfb3dad (Chandler Carruth         2010-12-12 09:14:11 +0000  8565) 
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8566)     /// Set of (canonical) types that we've already handled.
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8567)     llvm::SmallPtrSet<QualType, 8> AddedTypes;
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  8568) 
e54c307bb4ed9 (Richard Smith            2013-05-05 15:51:06 +0000  8569)     for (unsigned ArgIdx = 0, N = Args.size(); ArgIdx != N; ++ArgIdx) {
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8570)       for (QualType PtrTy : CandidateTypes[ArgIdx].pointer_types()) {
b37c9af75dae4 (Douglas Gregor           2010-11-03 17:00:07 +0000  8571)         // Don't add the same builtin candidate twice.
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8572)         if (!AddedTypes.insert(S.Context.getCanonicalType(PtrTy)).second)
b37c9af75dae4 (Douglas Gregor           2010-11-03 17:00:07 +0000  8573)           continue;
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8574) 
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8575)         QualType ParamTypes[2] = {PtrTy, PtrTy};
c07c389a94bb4 (George Burgess IV        2017-06-08 18:19:25 +0000  8576)         S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet);
b37c9af75dae4 (Douglas Gregor           2010-11-03 17:00:07 +0000  8577)       }
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8578)       for (QualType EnumTy : CandidateTypes[ArgIdx].enumeration_types()) {
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8579)         CanQualType CanonType = S.Context.getCanonicalType(EnumTy);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8580) 
c02db8cfb3dad (Chandler Carruth         2010-12-12 09:14:11 +0000  8581)         // Don't add the same builtin candidate twice, or if a user defined
c02db8cfb3dad (Chandler Carruth         2010-12-12 09:14:11 +0000  8582)         // candidate exists.
82e95a3c79d67 (David Blaikie            2014-11-19 07:49:47 +0000  8583)         if (!AddedTypes.insert(CanonType).second ||
c02db8cfb3dad (Chandler Carruth         2010-12-12 09:14:11 +0000  8584)             UserDefinedBinaryOperators.count(std::make_pair(CanonType,
c02db8cfb3dad (Chandler Carruth         2010-12-12 09:14:11 +0000  8585)                                                             CanonType)))
b37c9af75dae4 (Douglas Gregor           2010-11-03 17:00:07 +0000  8586)           continue;
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8587)         QualType ParamTypes[2] = {EnumTy, EnumTy};
c07c389a94bb4 (George Burgess IV        2017-06-08 18:19:25 +0000  8588)         S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet);
b37c9af75dae4 (Douglas Gregor           2010-11-03 17:00:07 +0000  8589)       }
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8590)     }
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8591)   }
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8592) 
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8593)   // C++ [over.built]p13:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8594)   //
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8595)   //   For every cv-qualified or cv-unqualified object type T
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8596)   //   there exist candidate operator functions of the form
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8597)   //
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8598)   //      T*         operator+(T*, ptrdiff_t);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8599)   //      T&         operator[](T*, ptrdiff_t);    [BELOW]
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8600)   //      T*         operator-(T*, ptrdiff_t);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8601)   //      T*         operator+(ptrdiff_t, T*);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8602)   //      T&         operator[](ptrdiff_t, T*);    [BELOW]
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8603)   //
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8604)   // C++ [over.built]p14:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8605)   //
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8606)   //   For every T, where T is a pointer to object type, there
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8607)   //   exist candidate operator functions of the form
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8608)   //
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8609)   //      ptrdiff_t  operator-(T, T);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8610)   void addBinaryPlusOrMinusPointerOverloads(OverloadedOperatorKind Op) {
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8611)     /// Set of (canonical) types that we've already handled.
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8612)     llvm::SmallPtrSet<QualType, 8> AddedTypes;
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8613) 
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8614)     for (int Arg = 0; Arg < 2; ++Arg) {
9207a52bc525f (Eric Christopher         2015-08-21 16:24:01 +0000  8615)       QualType AsymmetricParamTypes[2] = {
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8616)         S.Context.getPointerDiffType(),
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8617)         S.Context.getPointerDiffType(),
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8618)       };
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8619)       for (QualType PtrTy : CandidateTypes[Arg].pointer_types()) {
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8620)         QualType PointeeTy = PtrTy->getPointeeType();
66990031e2951 (Douglas Gregor           2011-01-05 00:13:17 +0000  8621)         if (!PointeeTy->isObjectType())
66990031e2951 (Douglas Gregor           2011-01-05 00:13:17 +0000  8622)           continue;
66990031e2951 (Douglas Gregor           2011-01-05 00:13:17 +0000  8623) 
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8624)         AsymmetricParamTypes[Arg] = PtrTy;
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8625)         if (Arg == 0 || Op == OO_Plus) {
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8626)           // operator+(T*, ptrdiff_t) or operator-(T*, ptrdiff_t)
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8627)           // T* operator+(ptrdiff_t, T*);
c07c389a94bb4 (George Burgess IV        2017-06-08 18:19:25 +0000  8628)           S.AddBuiltinCandidate(AsymmetricParamTypes, Args, CandidateSet);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8629)         }
b37c9af75dae4 (Douglas Gregor           2010-11-03 17:00:07 +0000  8630)         if (Op == OO_Minus) {
b37c9af75dae4 (Douglas Gregor           2010-11-03 17:00:07 +0000  8631)           // ptrdiff_t operator-(T, T);
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8632)           if (!AddedTypes.insert(S.Context.getCanonicalType(PtrTy)).second)
b37c9af75dae4 (Douglas Gregor           2010-11-03 17:00:07 +0000  8633)             continue;
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8634) 
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8635)           QualType ParamTypes[2] = {PtrTy, PtrTy};
c07c389a94bb4 (George Burgess IV        2017-06-08 18:19:25 +0000  8636)           S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet);
b37c9af75dae4 (Douglas Gregor           2010-11-03 17:00:07 +0000  8637)         }
b37c9af75dae4 (Douglas Gregor           2010-11-03 17:00:07 +0000  8638)       }
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8639)     }
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8640)   }
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8641) 
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8642)   // C++ [over.built]p12:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8643)   //
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8644)   //   For every pair of promoted arithmetic types L and R, there
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8645)   //   exist candidate operator functions of the form
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8646)   //
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8647)   //        LR         operator*(L, R);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8648)   //        LR         operator/(L, R);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8649)   //        LR         operator+(L, R);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8650)   //        LR         operator-(L, R);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8651)   //        bool       operator<(L, R);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8652)   //        bool       operator>(L, R);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8653)   //        bool       operator<=(L, R);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8654)   //        bool       operator>=(L, R);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8655)   //        bool       operator==(L, R);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8656)   //        bool       operator!=(L, R);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8657)   //
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8658)   //   where LR is the result of the usual arithmetic conversions
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8659)   //   between types L and R.
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8660)   //
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8661)   // C++ [over.built]p24:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8662)   //
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8663)   //   For every pair of promoted arithmetic types L and R, there exist
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8664)   //   candidate operator functions of the form
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8665)   //
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8666)   //        LR       operator?(bool, L, R);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8667)   //
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8668)   //   where LR is the result of the usual arithmetic conversions
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8669)   //   between types L and R.
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8670)   // Our candidates ignore the first parameter.
c07c389a94bb4 (George Burgess IV        2017-06-08 18:19:25 +0000  8671)   void addGenericBinaryArithmeticOverloads() {
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  8672)     if (!HasArithmeticOrEnumeralCandidateType)
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  8673)       return;
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  8674) 
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  8675)     for (unsigned Left = FirstPromotedArithmeticType;
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8676)          Left < LastPromotedArithmeticType; ++Left) {
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  8677)       for (unsigned Right = FirstPromotedArithmeticType;
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8678)            Right < LastPromotedArithmeticType; ++Right) {
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8679)         QualType LandR[2] = { ArithmeticTypes[Left],
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8680)                               ArithmeticTypes[Right] };
c07c389a94bb4 (George Burgess IV        2017-06-08 18:19:25 +0000  8681)         S.AddBuiltinCandidate(LandR, Args, CandidateSet);
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8682)       }
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8683)     }
cbfbca14d0a2b (Douglas Gregor           2010-05-19 03:21:00 +0000  8684) 
cbfbca14d0a2b (Douglas Gregor           2010-05-19 03:21:00 +0000  8685)     // Extension: Add the binary operators ==, !=, <, <=, >=, >, *, /, and the
cbfbca14d0a2b (Douglas Gregor           2010-05-19 03:21:00 +0000  8686)     // conditional operator for vector types.
714e84be4615d (Florian Hahn             2020-06-04 20:15:21 +0100  8687)     for (QualType Vec1Ty : CandidateTypes[0].vector_types())
714e84be4615d (Florian Hahn             2020-06-04 20:15:21 +0100  8688)       for (QualType Vec2Ty : CandidateTypes[1].vector_types()) {
714e84be4615d (Florian Hahn             2020-06-04 20:15:21 +0100  8689)         QualType LandR[2] = {Vec1Ty, Vec2Ty};
c07c389a94bb4 (George Burgess IV        2017-06-08 18:19:25 +0000  8690)         S.AddBuiltinCandidate(LandR, Args, CandidateSet);
cbfbca14d0a2b (Douglas Gregor           2010-05-19 03:21:00 +0000  8691)       }
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8692)   }
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8693) 
6f6e91d193373 (Florian Hahn             2020-05-29 20:42:22 +0100  8694)   /// Add binary operator overloads for each candidate matrix type M1, M2:
6f6e91d193373 (Florian Hahn             2020-05-29 20:42:22 +0100  8695)   ///  * (M1, M1) -> M1
6f6e91d193373 (Florian Hahn             2020-05-29 20:42:22 +0100  8696)   ///  * (M1, M1.getElementType()) -> M1
6f6e91d193373 (Florian Hahn             2020-05-29 20:42:22 +0100  8697)   ///  * (M2.getElementType(), M2) -> M2
6f6e91d193373 (Florian Hahn             2020-05-29 20:42:22 +0100  8698)   ///  * (M2, M2) -> M2 // Only if M2 is not part of CandidateTypes[0].
6f6e91d193373 (Florian Hahn             2020-05-29 20:42:22 +0100  8699)   void addMatrixBinaryArithmeticOverloads() {
6f6e91d193373 (Florian Hahn             2020-05-29 20:42:22 +0100  8700)     if (!HasArithmeticOrEnumeralCandidateType)
6f6e91d193373 (Florian Hahn             2020-05-29 20:42:22 +0100  8701)       return;
6f6e91d193373 (Florian Hahn             2020-05-29 20:42:22 +0100  8702) 
6f6e91d193373 (Florian Hahn             2020-05-29 20:42:22 +0100  8703)     for (QualType M1 : CandidateTypes[0].matrix_types()) {
6f6e91d193373 (Florian Hahn             2020-05-29 20:42:22 +0100  8704)       AddCandidate(M1, cast<MatrixType>(M1)->getElementType());
6f6e91d193373 (Florian Hahn             2020-05-29 20:42:22 +0100  8705)       AddCandidate(M1, M1);
6f6e91d193373 (Florian Hahn             2020-05-29 20:42:22 +0100  8706)     }
6f6e91d193373 (Florian Hahn             2020-05-29 20:42:22 +0100  8707) 
6f6e91d193373 (Florian Hahn             2020-05-29 20:42:22 +0100  8708)     for (QualType M2 : CandidateTypes[1].matrix_types()) {
6f6e91d193373 (Florian Hahn             2020-05-29 20:42:22 +0100  8709)       AddCandidate(cast<MatrixType>(M2)->getElementType(), M2);
6f6e91d193373 (Florian Hahn             2020-05-29 20:42:22 +0100  8710)       if (!CandidateTypes[0].containsMatrixType(M2))
6f6e91d193373 (Florian Hahn             2020-05-29 20:42:22 +0100  8711)         AddCandidate(M2, M2);
6f6e91d193373 (Florian Hahn             2020-05-29 20:42:22 +0100  8712)     }
6f6e91d193373 (Florian Hahn             2020-05-29 20:42:22 +0100  8713)   }
6f6e91d193373 (Florian Hahn             2020-05-29 20:42:22 +0100  8714) 
0683c0e68d31d (Eric Fiselier            2018-05-07 21:07:10 +0000  8715)   // C++2a [over.built]p14:
0683c0e68d31d (Eric Fiselier            2018-05-07 21:07:10 +0000  8716)   //
0683c0e68d31d (Eric Fiselier            2018-05-07 21:07:10 +0000  8717)   //   For every integral type T there exists a candidate operator function
0683c0e68d31d (Eric Fiselier            2018-05-07 21:07:10 +0000  8718)   //   of the form
0683c0e68d31d (Eric Fiselier            2018-05-07 21:07:10 +0000  8719)   //
0683c0e68d31d (Eric Fiselier            2018-05-07 21:07:10 +0000  8720)   //        std::strong_ordering operator<=>(T, T)
0683c0e68d31d (Eric Fiselier            2018-05-07 21:07:10 +0000  8721)   //
0683c0e68d31d (Eric Fiselier            2018-05-07 21:07:10 +0000  8722)   // C++2a [over.built]p15:
0683c0e68d31d (Eric Fiselier            2018-05-07 21:07:10 +0000  8723)   //
0683c0e68d31d (Eric Fiselier            2018-05-07 21:07:10 +0000  8724)   //   For every pair of floating-point types L and R, there exists a candidate
0683c0e68d31d (Eric Fiselier            2018-05-07 21:07:10 +0000  8725)   //   operator function of the form
0683c0e68d31d (Eric Fiselier            2018-05-07 21:07:10 +0000  8726)   //
0683c0e68d31d (Eric Fiselier            2018-05-07 21:07:10 +0000  8727)   //       std::partial_ordering operator<=>(L, R);
0683c0e68d31d (Eric Fiselier            2018-05-07 21:07:10 +0000  8728)   //
0683c0e68d31d (Eric Fiselier            2018-05-07 21:07:10 +0000  8729)   // FIXME: The current specification for integral types doesn't play nice with
0683c0e68d31d (Eric Fiselier            2018-05-07 21:07:10 +0000  8730)   // the direction of p0946r0, which allows mixed integral and unscoped-enum
0683c0e68d31d (Eric Fiselier            2018-05-07 21:07:10 +0000  8731)   // comparisons. Under the current spec this can lead to ambiguity during
0683c0e68d31d (Eric Fiselier            2018-05-07 21:07:10 +0000  8732)   // overload resolution. For example:
0683c0e68d31d (Eric Fiselier            2018-05-07 21:07:10 +0000  8733)   //
0683c0e68d31d (Eric Fiselier            2018-05-07 21:07:10 +0000  8734)   //   enum A : int {a};
0683c0e68d31d (Eric Fiselier            2018-05-07 21:07:10 +0000  8735)   //   auto x = (a <=> (long)42);
0683c0e68d31d (Eric Fiselier            2018-05-07 21:07:10 +0000  8736)   //
0683c0e68d31d (Eric Fiselier            2018-05-07 21:07:10 +0000  8737)   //   error: call is ambiguous for arguments 'A' and 'long'.
0683c0e68d31d (Eric Fiselier            2018-05-07 21:07:10 +0000  8738)   //   note: candidate operator<=>(int, int)
0683c0e68d31d (Eric Fiselier            2018-05-07 21:07:10 +0000  8739)   //   note: candidate operator<=>(long, long)
0683c0e68d31d (Eric Fiselier            2018-05-07 21:07:10 +0000  8740)   //
0683c0e68d31d (Eric Fiselier            2018-05-07 21:07:10 +0000  8741)   // To avoid this error, this function deviates from the specification and adds
0683c0e68d31d (Eric Fiselier            2018-05-07 21:07:10 +0000  8742)   // the mixed overloads `operator<=>(L, R)` where L and R are promoted
0683c0e68d31d (Eric Fiselier            2018-05-07 21:07:10 +0000  8743)   // arithmetic types (the same as the generic relational overloads).
0683c0e68d31d (Eric Fiselier            2018-05-07 21:07:10 +0000  8744)   //
0683c0e68d31d (Eric Fiselier            2018-05-07 21:07:10 +0000  8745)   // For now this function acts as a placeholder.
0683c0e68d31d (Eric Fiselier            2018-05-07 21:07:10 +0000  8746)   void addThreeWayArithmeticOverloads() {
0683c0e68d31d (Eric Fiselier            2018-05-07 21:07:10 +0000  8747)     addGenericBinaryArithmeticOverloads();
0683c0e68d31d (Eric Fiselier            2018-05-07 21:07:10 +0000  8748)   }
0683c0e68d31d (Eric Fiselier            2018-05-07 21:07:10 +0000  8749) 
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8750)   // C++ [over.built]p17:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8751)   //
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8752)   //   For every pair of promoted integral types L and R, there
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8753)   //   exist candidate operator functions of the form
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8754)   //
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8755)   //      LR         operator%(L, R);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8756)   //      LR         operator&(L, R);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8757)   //      LR         operator^(L, R);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8758)   //      LR         operator|(L, R);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8759)   //      L          operator<<(L, R);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8760)   //      L          operator>>(L, R);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8761)   //
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8762)   //   where LR is the result of the usual arithmetic conversions
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8763)   //   between types L and R.
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8764)   void addBinaryBitwiseArithmeticOverloads(OverloadedOperatorKind Op) {
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  8765)     if (!HasArithmeticOrEnumeralCandidateType)
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  8766)       return;
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  8767) 
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  8768)     for (unsigned Left = FirstPromotedIntegralType;
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8769)          Left < LastPromotedIntegralType; ++Left) {
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  8770)       for (unsigned Right = FirstPromotedIntegralType;
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8771)            Right < LastPromotedIntegralType; ++Right) {
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8772)         QualType LandR[2] = { ArithmeticTypes[Left],
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8773)                               ArithmeticTypes[Right] };
c07c389a94bb4 (George Burgess IV        2017-06-08 18:19:25 +0000  8774)         S.AddBuiltinCandidate(LandR, Args, CandidateSet);
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8775)       }
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8776)     }
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8777)   }
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8778) 
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8779)   // C++ [over.built]p20:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8780)   //
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8781)   //   For every pair (T, VQ), where T is an enumeration or
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8782)   //   pointer to member type and VQ is either volatile or
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8783)   //   empty, there exist candidate operator functions of the form
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8784)   //
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8785)   //        VQ T&      operator=(VQ T&, T);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8786)   void addAssignmentMemberPointerOrEnumeralOverloads() {
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8787)     /// Set of (canonical) types that we've already handled.
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8788)     llvm::SmallPtrSet<QualType, 8> AddedTypes;
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8789) 
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8790)     for (unsigned ArgIdx = 0; ArgIdx < 2; ++ArgIdx) {
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8791)       for (QualType EnumTy : CandidateTypes[ArgIdx].enumeration_types()) {
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8792)         if (!AddedTypes.insert(S.Context.getCanonicalType(EnumTy)).second)
b37c9af75dae4 (Douglas Gregor           2010-11-03 17:00:07 +0000  8793)           continue;
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8794) 
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8795)         AddBuiltinAssignmentOperatorCandidates(S, EnumTy, Args, CandidateSet);
b37c9af75dae4 (Douglas Gregor           2010-11-03 17:00:07 +0000  8796)       }
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8797) 
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8798)       for (QualType MemPtrTy : CandidateTypes[ArgIdx].member_pointer_types()) {
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8799)         if (!AddedTypes.insert(S.Context.getCanonicalType(MemPtrTy)).second)
b37c9af75dae4 (Douglas Gregor           2010-11-03 17:00:07 +0000  8800)           continue;
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8801) 
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8802)         AddBuiltinAssignmentOperatorCandidates(S, MemPtrTy, Args, CandidateSet);
b37c9af75dae4 (Douglas Gregor           2010-11-03 17:00:07 +0000  8803)       }
b37c9af75dae4 (Douglas Gregor           2010-11-03 17:00:07 +0000  8804)     }
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8805)   }
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8806) 
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8807)   // C++ [over.built]p19:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8808)   //
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8809)   //   For every pair (T, VQ), where T is any type and VQ is either
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8810)   //   volatile or empty, there exist candidate operator functions
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8811)   //   of the form
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8812)   //
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8813)   //        T*VQ&      operator=(T*VQ&, T*);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8814)   //
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8815)   // C++ [over.built]p21:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8816)   //
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8817)   //   For every pair (T, VQ), where T is a cv-qualified or
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8818)   //   cv-unqualified object type and VQ is either volatile or
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8819)   //   empty, there exist candidate operator functions of the form
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8820)   //
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8821)   //        T*VQ&      operator+=(T*VQ&, ptrdiff_t);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8822)   //        T*VQ&      operator-=(T*VQ&, ptrdiff_t);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8823)   void addAssignmentPointerOverloads(bool isEqualOp) {
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8824)     /// Set of (canonical) types that we've already handled.
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8825)     llvm::SmallPtrSet<QualType, 8> AddedTypes;
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8826) 
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8827)     for (QualType PtrTy : CandidateTypes[0].pointer_types()) {
b37c9af75dae4 (Douglas Gregor           2010-11-03 17:00:07 +0000  8828)       // If this is operator=, keep track of the builtin candidates we added.
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8829)       if (isEqualOp)
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8830)         AddedTypes.insert(S.Context.getCanonicalType(PtrTy));
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8831)       else if (!PtrTy->getPointeeType()->isObjectType())
66990031e2951 (Douglas Gregor           2011-01-05 00:13:17 +0000  8832)         continue;
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8833) 
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8834)       // non-volatile version
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8835)       QualType ParamTypes[2] = {
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8836)           S.Context.getLValueReferenceType(PtrTy),
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8837)           isEqualOp ? PtrTy : S.Context.getPointerDiffType(),
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8838)       };
c07c389a94bb4 (George Burgess IV        2017-06-08 18:19:25 +0000  8839)       S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet,
49a3ad21d6034 (Rui Ueyama               2019-07-16 04:46:31 +0000  8840)                             /*IsAssignmentOperator=*/ isEqualOp);
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8841) 
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8842)       bool NeedVolatile = !PtrTy.isVolatileQualified() &&
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  8843)                           VisibleTypeConversionsQuals.hasVolatile();
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  8844)       if (NeedVolatile) {
d08452f60a273 (Douglas Gregor           2008-11-19 15:42:04 +0000  8845)         // volatile version
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8846)         ParamTypes[0] =
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8847)             S.Context.getLValueReferenceType(S.Context.getVolatileType(PtrTy));
c07c389a94bb4 (George Burgess IV        2017-06-08 18:19:25 +0000  8848)         S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet,
49a3ad21d6034 (Rui Ueyama               2019-07-16 04:46:31 +0000  8849)                               /*IsAssignmentOperator=*/isEqualOp);
d08452f60a273 (Douglas Gregor           2008-11-19 15:42:04 +0000  8850)       }
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  8851) 
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8852)       if (!PtrTy.isRestrictQualified() &&
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  8853)           VisibleTypeConversionsQuals.hasRestrict()) {
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  8854)         // restrict version
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8855)         ParamTypes[0] =
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8856)             S.Context.getLValueReferenceType(S.Context.getRestrictType(PtrTy));
c07c389a94bb4 (George Burgess IV        2017-06-08 18:19:25 +0000  8857)         S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet,
49a3ad21d6034 (Rui Ueyama               2019-07-16 04:46:31 +0000  8858)                               /*IsAssignmentOperator=*/isEqualOp);
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  8859) 
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  8860)         if (NeedVolatile) {
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  8861)           // volatile restrict version
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8862)           ParamTypes[0] =
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8863)               S.Context.getLValueReferenceType(S.Context.getCVRQualifiedType(
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8864)                   PtrTy, (Qualifiers::Volatile | Qualifiers::Restrict)));
c07c389a94bb4 (George Burgess IV        2017-06-08 18:19:25 +0000  8865)           S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet,
49a3ad21d6034 (Rui Ueyama               2019-07-16 04:46:31 +0000  8866)                                 /*IsAssignmentOperator=*/isEqualOp);
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  8867)         }
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  8868)       }
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8869)     }
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8870) 
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8871)     if (isEqualOp) {
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8872)       for (QualType PtrTy : CandidateTypes[1].pointer_types()) {
b37c9af75dae4 (Douglas Gregor           2010-11-03 17:00:07 +0000  8873)         // Make sure we don't add the same candidate twice.
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8874)         if (!AddedTypes.insert(S.Context.getCanonicalType(PtrTy)).second)
b37c9af75dae4 (Douglas Gregor           2010-11-03 17:00:07 +0000  8875)           continue;
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8876) 
8e543b3d46932 (Chandler Carruth         2010-12-12 08:17:55 +0000  8877)         QualType ParamTypes[2] = {
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8878)             S.Context.getLValueReferenceType(PtrTy),
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8879)             PtrTy,
8e543b3d46932 (Chandler Carruth         2010-12-12 08:17:55 +0000  8880)         };
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8881) 
b37c9af75dae4 (Douglas Gregor           2010-11-03 17:00:07 +0000  8882)         // non-volatile version
c07c389a94bb4 (George Burgess IV        2017-06-08 18:19:25 +0000  8883)         S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet,
49a3ad21d6034 (Rui Ueyama               2019-07-16 04:46:31 +0000  8884)                               /*IsAssignmentOperator=*/true);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8885) 
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8886)         bool NeedVolatile = !PtrTy.isVolatileQualified() &&
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8887)                             VisibleTypeConversionsQuals.hasVolatile();
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  8888)         if (NeedVolatile) {
b37c9af75dae4 (Douglas Gregor           2010-11-03 17:00:07 +0000  8889)           // volatile version
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8890)           ParamTypes[0] = S.Context.getLValueReferenceType(
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8891)               S.Context.getVolatileType(PtrTy));
c07c389a94bb4 (George Burgess IV        2017-06-08 18:19:25 +0000  8892)           S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet,
49a3ad21d6034 (Rui Ueyama               2019-07-16 04:46:31 +0000  8893)                                 /*IsAssignmentOperator=*/true);
b37c9af75dae4 (Douglas Gregor           2010-11-03 17:00:07 +0000  8894)         }
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  8895) 
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8896)         if (!PtrTy.isRestrictQualified() &&
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  8897)             VisibleTypeConversionsQuals.hasRestrict()) {
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  8898)           // restrict version
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8899)           ParamTypes[0] = S.Context.getLValueReferenceType(
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8900)               S.Context.getRestrictType(PtrTy));
c07c389a94bb4 (George Burgess IV        2017-06-08 18:19:25 +0000  8901)           S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet,
49a3ad21d6034 (Rui Ueyama               2019-07-16 04:46:31 +0000  8902)                                 /*IsAssignmentOperator=*/true);
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000  8903) 
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  8904)           if (NeedVolatile) {
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  8905)             // volatile restrict version
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8906)             ParamTypes[0] =
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8907)                 S.Context.getLValueReferenceType(S.Context.getCVRQualifiedType(
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  8908)                     PtrTy, (Qualifiers::Volatile | Qualifiers::Restrict)));
c07c389a94bb4 (George Burgess IV        2017-06-08 18:19:25 +0000  8909)             S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet,
49a3ad21d6034 (Rui Ueyama               2019-07-16 04:46:31 +0000  8910)                                   /*IsAssignmentOperator=*/true);
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  8911)           }
5bee25884b9b7 (Douglas Gregor           2012-06-04 00:15:09 +0000  8912)         }
b37c9af75dae4 (Douglas Gregor           2010-11-03 17:00:07 +0000  8913)       }
b37c9af75dae4 (Douglas Gregor           2010-11-03 17:00:07 +0000  8914)     }
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8915)   }
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8916) 
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8917)   // C++ [over.built]p18:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8918)   //
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8919)   //   For every triple (L, VQ, R), where L is an arithmetic type,
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8920)   //   VQ is either volatile or empty, and R is a promoted
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8921)   //   arithmetic type, there exist candidate operator functions of
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8922)   //   the form
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8923)   //
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8924)   //        VQ L&      operator=(VQ L&, R);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8925)   //        VQ L&      operator*=(VQ L&, R);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8926)   //        VQ L&      operator/=(VQ L&, R);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8927)   //        VQ L&      operator+=(VQ L&, R);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8928)   //        VQ L&      operator-=(VQ L&, R);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8929)   void addAssignmentArithmeticOverloads(bool isEqualOp) {
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  8930)     if (!HasArithmeticOrEnumeralCandidateType)
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  8931)       return;
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  8932) 
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8933)     for (unsigned Left = 0; Left < NumArithmeticTypes; ++Left) {
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  8934)       for (unsigned Right = FirstPromotedArithmeticType;
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8935)            Right < LastPromotedArithmeticType; ++Right) {
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8936)         QualType ParamTypes[2];
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8937)         ParamTypes[1] = ArithmeticTypes[Right];
4ce581e5a9f90 (Anastasia Stulova        2019-03-19 16:50:21 +0000  8938)         auto LeftBaseTy = AdjustAddressSpaceForBuiltinOperandType(
4ce581e5a9f90 (Anastasia Stulova        2019-03-19 16:50:21 +0000  8939)             S, ArithmeticTypes[Left], Args[0]);
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8940)         // Add this built-in operator as a candidate (VQ is empty).
4ce581e5a9f90 (Anastasia Stulova        2019-03-19 16:50:21 +0000  8941)         ParamTypes[0] = S.Context.getLValueReferenceType(LeftBaseTy);
c07c389a94bb4 (George Burgess IV        2017-06-08 18:19:25 +0000  8942)         S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet,
49a3ad21d6034 (Rui Ueyama               2019-07-16 04:46:31 +0000  8943)                               /*IsAssignmentOperator=*/isEqualOp);
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8944) 
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8945)         // Add this built-in operator as a candidate (VQ is 'volatile').
b9e8c42ee6aea (Fariborz Jahanian        2009-10-19 21:30:45 +0000  8946)         if (VisibleTypeConversionsQuals.hasVolatile()) {
4ce581e5a9f90 (Anastasia Stulova        2019-03-19 16:50:21 +0000  8947)           ParamTypes[0] = S.Context.getVolatileType(LeftBaseTy);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8948)           ParamTypes[0] = S.Context.getLValueReferenceType(ParamTypes[0]);
c07c389a94bb4 (George Burgess IV        2017-06-08 18:19:25 +0000  8949)           S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet,
49a3ad21d6034 (Rui Ueyama               2019-07-16 04:46:31 +0000  8950)                                 /*IsAssignmentOperator=*/isEqualOp);
b9e8c42ee6aea (Fariborz Jahanian        2009-10-19 21:30:45 +0000  8951)         }
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8952)       }
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8953)     }
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8954) 
cbfbca14d0a2b (Douglas Gregor           2010-05-19 03:21:00 +0000  8955)     // Extension: Add the binary operators =, +=, -=, *=, /= for vector types.
714e84be4615d (Florian Hahn             2020-06-04 20:15:21 +0100  8956)     for (QualType Vec1Ty : CandidateTypes[0].vector_types())
714e84be4615d (Florian Hahn             2020-06-04 20:15:21 +0100  8957)       for (QualType Vec2Ty : CandidateTypes[0].vector_types()) {
cbfbca14d0a2b (Douglas Gregor           2010-05-19 03:21:00 +0000  8958)         QualType ParamTypes[2];
714e84be4615d (Florian Hahn             2020-06-04 20:15:21 +0100  8959)         ParamTypes[1] = Vec2Ty;
cbfbca14d0a2b (Douglas Gregor           2010-05-19 03:21:00 +0000  8960)         // Add this built-in operator as a candidate (VQ is empty).
714e84be4615d (Florian Hahn             2020-06-04 20:15:21 +0100  8961)         ParamTypes[0] = S.Context.getLValueReferenceType(Vec1Ty);
c07c389a94bb4 (George Burgess IV        2017-06-08 18:19:25 +0000  8962)         S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet,
49a3ad21d6034 (Rui Ueyama               2019-07-16 04:46:31 +0000  8963)                               /*IsAssignmentOperator=*/isEqualOp);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8964) 
cbfbca14d0a2b (Douglas Gregor           2010-05-19 03:21:00 +0000  8965)         // Add this built-in operator as a candidate (VQ is 'volatile').
cbfbca14d0a2b (Douglas Gregor           2010-05-19 03:21:00 +0000  8966)         if (VisibleTypeConversionsQuals.hasVolatile()) {
714e84be4615d (Florian Hahn             2020-06-04 20:15:21 +0100  8967)           ParamTypes[0] = S.Context.getVolatileType(Vec1Ty);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8968)           ParamTypes[0] = S.Context.getLValueReferenceType(ParamTypes[0]);
c07c389a94bb4 (George Burgess IV        2017-06-08 18:19:25 +0000  8969)           S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet,
49a3ad21d6034 (Rui Ueyama               2019-07-16 04:46:31 +0000  8970)                                 /*IsAssignmentOperator=*/isEqualOp);
cbfbca14d0a2b (Douglas Gregor           2010-05-19 03:21:00 +0000  8971)         }
cbfbca14d0a2b (Douglas Gregor           2010-05-19 03:21:00 +0000  8972)       }
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8973)   }
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8974) 
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8975)   // C++ [over.built]p22:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8976)   //
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8977)   //   For every triple (L, VQ, R), where L is an integral type, VQ
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8978)   //   is either volatile or empty, and R is a promoted integral
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8979)   //   type, there exist candidate operator functions of the form
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8980)   //
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8981)   //        VQ L&       operator%=(VQ L&, R);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8982)   //        VQ L&       operator<<=(VQ L&, R);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8983)   //        VQ L&       operator>>=(VQ L&, R);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8984)   //        VQ L&       operator&=(VQ L&, R);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8985)   //        VQ L&       operator^=(VQ L&, R);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8986)   //        VQ L&       operator|=(VQ L&, R);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  8987)   void addAssignmentIntegralOverloads() {
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  8988)     if (!HasArithmeticOrEnumeralCandidateType)
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  8989)       return;
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  8990) 
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8991)     for (unsigned Left = FirstIntegralType; Left < LastIntegralType; ++Left) {
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  8992)       for (unsigned Right = FirstPromotedIntegralType;
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8993)            Right < LastPromotedIntegralType; ++Right) {
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8994)         QualType ParamTypes[2];
8237141be1d45 (Hans Wennborg            2017-11-15 17:11:53 +0000  8995)         ParamTypes[1] = ArithmeticTypes[Right];
4ce581e5a9f90 (Anastasia Stulova        2019-03-19 16:50:21 +0000  8996)         auto LeftBaseTy = AdjustAddressSpaceForBuiltinOperandType(
4ce581e5a9f90 (Anastasia Stulova        2019-03-19 16:50:21 +0000  8997)             S, ArithmeticTypes[Left], Args[0]);
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  8998)         // Add this built-in operator as a candidate (VQ is empty).
4ce581e5a9f90 (Anastasia Stulova        2019-03-19 16:50:21 +0000  8999)         ParamTypes[0] = S.Context.getLValueReferenceType(LeftBaseTy);
c07c389a94bb4 (George Burgess IV        2017-06-08 18:19:25 +0000  9000)         S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet);
a4a9334a5013a (Fariborz Jahanian        2009-10-20 00:04:40 +0000  9001)         if (VisibleTypeConversionsQuals.hasVolatile()) {
a4a9334a5013a (Fariborz Jahanian        2009-10-20 00:04:40 +0000  9002)           // Add this built-in operator as a candidate (VQ is 'volatile').
4ce581e5a9f90 (Anastasia Stulova        2019-03-19 16:50:21 +0000  9003)           ParamTypes[0] = LeftBaseTy;
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9004)           ParamTypes[0] = S.Context.getVolatileType(ParamTypes[0]);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9005)           ParamTypes[0] = S.Context.getLValueReferenceType(ParamTypes[0]);
c07c389a94bb4 (George Burgess IV        2017-06-08 18:19:25 +0000  9006)           S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet);
a4a9334a5013a (Fariborz Jahanian        2009-10-20 00:04:40 +0000  9007)         }
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  9008)       }
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  9009)     }
d08452f60a273 (Douglas Gregor           2008-11-19 15:42:04 +0000  9010)   }
d08452f60a273 (Douglas Gregor           2008-11-19 15:42:04 +0000  9011) 
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9012)   // C++ [over.operator]p23:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9013)   //
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9014)   //   There also exist candidate operator functions of the form
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9015)   //
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9016)   //        bool        operator!(bool);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9017)   //        bool        operator&&(bool, bool);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9018)   //        bool        operator||(bool, bool);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9019)   void addExclaimOverload() {
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9020)     QualType ParamTy = S.Context.BoolTy;
c07c389a94bb4 (George Burgess IV        2017-06-08 18:19:25 +0000  9021)     S.AddBuiltinCandidate(&ParamTy, Args, CandidateSet,
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9022)                           /*IsAssignmentOperator=*/false,
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9023)                           /*NumContextualBoolArguments=*/1);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9024)   }
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9025)   void addAmpAmpOrPipePipeOverload() {
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9026)     QualType ParamTypes[2] = { S.Context.BoolTy, S.Context.BoolTy };
c07c389a94bb4 (George Burgess IV        2017-06-08 18:19:25 +0000  9027)     S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet,
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9028)                           /*IsAssignmentOperator=*/false,
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9029)                           /*NumContextualBoolArguments=*/2);
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  9030)   }
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  9031) 
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9032)   // C++ [over.built]p13:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9033)   //
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9034)   //   For every cv-qualified or cv-unqualified object type T there
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9035)   //   exist candidate operator functions of the form
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9036)   //
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9037)   //        T*         operator+(T*, ptrdiff_t);     [ABOVE]
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9038)   //        T&         operator[](T*, ptrdiff_t);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9039)   //        T*         operator-(T*, ptrdiff_t);     [ABOVE]
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9040)   //        T*         operator+(ptrdiff_t, T*);     [ABOVE]
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9041)   //        T&         operator[](ptrdiff_t, T*);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9042)   void addSubscriptOverloads() {
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  9043)     for (QualType PtrTy : CandidateTypes[0].pointer_types()) {
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  9044)       QualType ParamTypes[2] = {PtrTy, S.Context.getPointerDiffType()};
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  9045)       QualType PointeeType = PtrTy->getPointeeType();
66990031e2951 (Douglas Gregor           2011-01-05 00:13:17 +0000  9046)       if (!PointeeType->isObjectType())
66990031e2951 (Douglas Gregor           2011-01-05 00:13:17 +0000  9047)         continue;
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  9048) 
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  9049)       // T& operator[](T*, ptrdiff_t)
c07c389a94bb4 (George Burgess IV        2017-06-08 18:19:25 +0000  9050)       S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet);
b37c9af75dae4 (Douglas Gregor           2010-11-03 17:00:07 +0000  9051)     }
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9052) 
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  9053)     for (QualType PtrTy : CandidateTypes[1].pointer_types()) {
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  9054)       QualType ParamTypes[2] = {S.Context.getPointerDiffType(), PtrTy};
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  9055)       QualType PointeeType = PtrTy->getPointeeType();
66990031e2951 (Douglas Gregor           2011-01-05 00:13:17 +0000  9056)       if (!PointeeType->isObjectType())
66990031e2951 (Douglas Gregor           2011-01-05 00:13:17 +0000  9057)         continue;
66990031e2951 (Douglas Gregor           2011-01-05 00:13:17 +0000  9058) 
b37c9af75dae4 (Douglas Gregor           2010-11-03 17:00:07 +0000  9059)       // T& operator[](ptrdiff_t, T*)
c07c389a94bb4 (George Burgess IV        2017-06-08 18:19:25 +0000  9060)       S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet);
b37c9af75dae4 (Douglas Gregor           2010-11-03 17:00:07 +0000  9061)     }
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9062)   }
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  9063) 
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9064)   // C++ [over.built]p11:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9065)   //    For every quintuple (C1, C2, T, CV1, CV2), where C2 is a class type,
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9066)   //    C1 is the same type as C2 or is a derived class of C2, T is an object
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9067)   //    type or a function type, and CV1 and CV2 are cv-qualifier-seqs,
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9068)   //    there exist candidate operator functions of the form
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9069)   //
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9070)   //      CV12 T& operator->*(CV1 C1*, CV2 T C2::*);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9071)   //
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9072)   //    where CV12 is the union of CV1 and CV2.
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9073)   void addArrowStarOverloads() {
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  9074)     for (QualType PtrTy : CandidateTypes[0].pointer_types()) {
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  9075)       QualType C1Ty = PtrTy;
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9076)       QualType C1;
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9077)       QualifierCollector Q1;
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9078)       C1 = QualType(Q1.strip(C1Ty->getPointeeType()), 0);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9079)       if (!isa<RecordType>(C1))
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9080)         continue;
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9081)       // heuristic to reduce number of builtin candidates in the set.
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9082)       // Add volatile/restrict version only if there are conversions to a
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9083)       // volatile/restrict type.
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9084)       if (!VisibleTypeConversionsQuals.hasVolatile() && Q1.hasVolatile())
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9085)         continue;
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9086)       if (!VisibleTypeConversionsQuals.hasRestrict() && Q1.hasRestrict())
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9087)         continue;
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  9088)       for (QualType MemPtrTy : CandidateTypes[1].member_pointer_types()) {
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  9089)         const MemberPointerType *mptr = cast<MemberPointerType>(MemPtrTy);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9090)         QualType C2 = QualType(mptr->getClass(), 0);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9091)         C2 = C2.getUnqualifiedType();
0f59cb38e7f31 (Richard Smith            2015-12-18 21:45:41 +0000  9092)         if (C1 != C2 && !S.IsDerivedFrom(CandidateSet.getLocation(), C1, C2))
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9093)           break;
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  9094)         QualType ParamTypes[2] = {PtrTy, MemPtrTy};
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9095)         // build CV12 T&
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9096)         QualType T = mptr->getPointeeType();
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9097)         if (!VisibleTypeConversionsQuals.hasVolatile() &&
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9098)             T.isVolatileQualified())
421ad5e1e67bb (Argyrios Kyrtzidis       2010-08-23 07:12:16 +0000  9099)           continue;
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9100)         if (!VisibleTypeConversionsQuals.hasRestrict() &&
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9101)             T.isRestrictQualified())
421ad5e1e67bb (Argyrios Kyrtzidis       2010-08-23 07:12:16 +0000  9102)           continue;
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9103)         T = Q1.apply(S.Context, T);
c07c389a94bb4 (George Burgess IV        2017-06-08 18:19:25 +0000  9104)         S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet);
34d93dcddde71 (Fariborz Jahanian        2009-10-06 23:08:05 +0000  9105)       }
34d93dcddde71 (Fariborz Jahanian        2009-10-06 23:08:05 +0000  9106)     }
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9107)   }
1a99f441e64c8 (Sebastian Redl           2009-04-16 17:51:27 +0000  9108) 
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9109)   // Note that we don't consider the first argument, since it has been
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9110)   // contextually converted to bool long ago. The candidates below are
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9111)   // therefore added as binary.
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9112)   //
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9113)   // C++ [over.built]p25:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9114)   //   For every type T, where T is a pointer, pointer-to-member, or scoped
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9115)   //   enumeration type, there exist candidate operator functions of the form
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9116)   //
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9117)   //        T        operator?(bool, T, T);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9118)   //
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9119)   void addConditionalOperatorOverloads() {
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9120)     /// Set of (canonical) types that we've already handled.
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9121)     llvm::SmallPtrSet<QualType, 8> AddedTypes;
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9122) 
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9123)     for (unsigned ArgIdx = 0; ArgIdx < 2; ++ArgIdx) {
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  9124)       for (QualType PtrTy : CandidateTypes[ArgIdx].pointer_types()) {
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  9125)         if (!AddedTypes.insert(S.Context.getCanonicalType(PtrTy)).second)
b37c9af75dae4 (Douglas Gregor           2010-11-03 17:00:07 +0000  9126)           continue;
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9127) 
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  9128)         QualType ParamTypes[2] = {PtrTy, PtrTy};
c07c389a94bb4 (George Burgess IV        2017-06-08 18:19:25 +0000  9129)         S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet);
b37c9af75dae4 (Douglas Gregor           2010-11-03 17:00:07 +0000  9130)       }
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9131) 
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  9132)       for (QualType MemPtrTy : CandidateTypes[ArgIdx].member_pointer_types()) {
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  9133)         if (!AddedTypes.insert(S.Context.getCanonicalType(MemPtrTy)).second)
b37c9af75dae4 (Douglas Gregor           2010-11-03 17:00:07 +0000  9134)           continue;
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9135) 
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  9136)         QualType ParamTypes[2] = {MemPtrTy, MemPtrTy};
c07c389a94bb4 (George Burgess IV        2017-06-08 18:19:25 +0000  9137)         S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet);
b37c9af75dae4 (Douglas Gregor           2010-11-03 17:00:07 +0000  9138)       }
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9139) 
2bf7fdb723fc5 (Richard Smith            2013-01-02 11:42:31 +0000  9140)       if (S.getLangOpts().CPlusPlus11) {
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  9141)         for (QualType EnumTy : CandidateTypes[ArgIdx].enumeration_types()) {
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  9142)           if (!EnumTy->castAs<EnumType>()->getDecl()->isScoped())
b37c9af75dae4 (Douglas Gregor           2010-11-03 17:00:07 +0000  9143)             continue;
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9144) 
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  9145)           if (!AddedTypes.insert(S.Context.getCanonicalType(EnumTy)).second)
b37c9af75dae4 (Douglas Gregor           2010-11-03 17:00:07 +0000  9146)             continue;
b37c9af75dae4 (Douglas Gregor           2010-11-03 17:00:07 +0000  9147) 
fd14a2753368b (Richard Sandiford        2020-12-07 18:34:53 +0000  9148)           QualType ParamTypes[2] = {EnumTy, EnumTy};
c07c389a94bb4 (George Burgess IV        2017-06-08 18:19:25 +0000  9149)           S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet);
b37c9af75dae4 (Douglas Gregor           2010-11-03 17:00:07 +0000  9150)         }
b37c9af75dae4 (Douglas Gregor           2010-11-03 17:00:07 +0000  9151)       }
8a8e0313bfb01 (Douglas Gregor           2010-10-15 00:50:56 +0000  9152)     }
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9153)   }
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9154) };
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9155) 
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9156) } // end anonymous namespace
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9157) 
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9158) /// AddBuiltinOperatorCandidates - Add the appropriate built-in
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9159) /// operator overloads to the candidate set (C++ [over.built]), based
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9160) /// on the operator @p Op and the arguments given. For example, if the
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9161) /// operator is a binary '+', this routine might add "int
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9162) /// operator+(int, int)" to cover integer addition.
16e94b91ef4d5 (Robert Wilhelm           2013-08-09 18:02:13 +0000  9163) void Sema::AddBuiltinOperatorCandidates(OverloadedOperatorKind Op,
16e94b91ef4d5 (Robert Wilhelm           2013-08-09 18:02:13 +0000  9164)                                         SourceLocation OpLoc,
16e94b91ef4d5 (Robert Wilhelm           2013-08-09 18:02:13 +0000  9165)                                         ArrayRef<Expr *> Args,
16e94b91ef4d5 (Robert Wilhelm           2013-08-09 18:02:13 +0000  9166)                                         OverloadCandidateSet &CandidateSet) {
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9167)   // Find all of the types that the arguments can convert to, but only
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9168)   // if the operator we're looking at has built-in operator candidates
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  9169)   // that make use of these types. Also record whether we encounter non-record
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  9170)   // candidate types or either arithmetic or enumeral candidate types.
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9171)   Qualifiers VisibleTypeConversionsQuals;
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9172)   VisibleTypeConversionsQuals.addConst();
e54c307bb4ed9 (Richard Smith            2013-05-05 15:51:06 +0000  9173)   for (unsigned ArgIdx = 0, N = Args.size(); ArgIdx != N; ++ArgIdx)
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9174)     VisibleTypeConversionsQuals += CollectVRQualifiers(Context, Args[ArgIdx]);
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  9175) 
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  9176)   bool HasNonRecordCandidateType = false;
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  9177)   bool HasArithmeticOrEnumeralCandidateType = false;
0e62c1cc0b47c (Chris Lattner            2011-07-23 10:55:15 +0000  9178)   SmallVector<BuiltinCandidateTypeSet, 2> CandidateTypes;
e54c307bb4ed9 (Richard Smith            2013-05-05 15:51:06 +0000  9179)   for (unsigned ArgIdx = 0, N = Args.size(); ArgIdx != N; ++ArgIdx) {
57dddd4840bac (Benjamin Kramer          2015-02-17 21:55:18 +0000  9180)     CandidateTypes.emplace_back(*this);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9181)     CandidateTypes[ArgIdx].AddTypesConvertedFrom(Args[ArgIdx]->getType(),
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9182)                                                  OpLoc,
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9183)                                                  true,
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9184)                                                  (Op == OO_Exclaim ||
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9185)                                                   Op == OO_AmpAmp ||
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9186)                                                   Op == OO_PipePipe),
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9187)                                                  VisibleTypeConversionsQuals);
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  9188)     HasNonRecordCandidateType = HasNonRecordCandidateType ||
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  9189)         CandidateTypes[ArgIdx].hasNonRecordTypes();
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  9190)     HasArithmeticOrEnumeralCandidateType =
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  9191)         HasArithmeticOrEnumeralCandidateType ||
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  9192)         CandidateTypes[ArgIdx].hasArithmeticOrEnumeralTypes();
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9193)   }
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9194) 
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  9195)   // Exit early when no non-record types have been added to the candidate set
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  9196)   // for any of the arguments to the operator.
877d4ebba49cc (Douglas Gregor           2011-10-10 14:05:31 +0000  9197)   //
877d4ebba49cc (Douglas Gregor           2011-10-10 14:05:31 +0000  9198)   // We can't exit early for !, ||, or &&, since there we have always have
877d4ebba49cc (Douglas Gregor           2011-10-10 14:05:31 +0000  9199)   // 'bool' overloads.
e54c307bb4ed9 (Richard Smith            2013-05-05 15:51:06 +0000  9200)   if (!HasNonRecordCandidateType &&
877d4ebba49cc (Douglas Gregor           2011-10-10 14:05:31 +0000  9201)       !(Op == OO_Exclaim || Op == OO_AmpAmp || Op == OO_PipePipe))
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  9202)     return;
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  9203) 
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9204)   // Setup an object to manage the common state for building overloads.
e54c307bb4ed9 (Richard Smith            2013-05-05 15:51:06 +0000  9205)   BuiltinOperatorOverloadBuilder OpBuilder(*this, Args,
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9206)                                            VisibleTypeConversionsQuals,
00a383363859a (Chandler Carruth         2010-12-13 01:44:01 +0000  9207)                                            HasArithmeticOrEnumeralCandidateType,
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9208)                                            CandidateTypes, CandidateSet);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9209) 
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9210)   // Dispatch over the operation to add in only those overloads which apply.
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9211)   switch (Op) {
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9212)   case OO_None:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9213)   case NUM_OVERLOADED_OPERATORS:
83d382b1cad13 (David Blaikie            2011-09-23 05:06:16 +0000  9214)     llvm_unreachable("Expected an overloaded operator");
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9215) 
5184de0aff61b (Chandler Carruth         2010-12-12 08:51:33 +0000  9216)   case OO_New:
5184de0aff61b (Chandler Carruth         2010-12-12 08:51:33 +0000  9217)   case OO_Delete:
5184de0aff61b (Chandler Carruth         2010-12-12 08:51:33 +0000  9218)   case OO_Array_New:
5184de0aff61b (Chandler Carruth         2010-12-12 08:51:33 +0000  9219)   case OO_Array_Delete:
5184de0aff61b (Chandler Carruth         2010-12-12 08:51:33 +0000  9220)   case OO_Call:
83d382b1cad13 (David Blaikie            2011-09-23 05:06:16 +0000  9221)     llvm_unreachable(
83d382b1cad13 (David Blaikie            2011-09-23 05:06:16 +0000  9222)                     "Special operators don't use AddBuiltinOperatorCandidates");
5184de0aff61b (Chandler Carruth         2010-12-12 08:51:33 +0000  9223) 
5184de0aff61b (Chandler Carruth         2010-12-12 08:51:33 +0000  9224)   case OO_Comma:
5184de0aff61b (Chandler Carruth         2010-12-12 08:51:33 +0000  9225)   case OO_Arrow:
9f690bd80bb67 (Richard Smith            2015-10-27 06:02:45 +0000  9226)   case OO_Coawait:
5184de0aff61b (Chandler Carruth         2010-12-12 08:51:33 +0000  9227)     // C++ [over.match.oper]p3:
9f690bd80bb67 (Richard Smith            2015-10-27 06:02:45 +0000  9228)     //   -- For the operator ',', the unary operator '&', the
9f690bd80bb67 (Richard Smith            2015-10-27 06:02:45 +0000  9229)     //      operator '->', or the operator 'co_await', the
9f690bd80bb67 (Richard Smith            2015-10-27 06:02:45 +0000  9230)     //      built-in candidates set is empty.
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9231)     break;
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9232) 
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9233)   case OO_Plus: // '+' is either unary or binary
e54c307bb4ed9 (Richard Smith            2013-05-05 15:51:06 +0000  9234)     if (Args.size() == 1)
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9235)       OpBuilder.addUnaryPlusPointerOverloads();
f3b3ccda590c1 (Adrian Prantl            2017-12-19 22:06:11 +0000  9236)     LLVM_FALLTHROUGH;
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9237) 
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9238)   case OO_Minus: // '-' is either unary or binary
e54c307bb4ed9 (Richard Smith            2013-05-05 15:51:06 +0000  9239)     if (Args.size() == 1) {
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9240)       OpBuilder.addUnaryPlusOrMinusArithmeticOverloads();
f9802446a58e5 (Chandler Carruth         2010-12-12 08:39:38 +0000  9241)     } else {
f9802446a58e5 (Chandler Carruth         2010-12-12 08:39:38 +0000  9242)       OpBuilder.addBinaryPlusOrMinusPointerOverloads(Op);
c07c389a94bb4 (George Burgess IV        2017-06-08 18:19:25 +0000  9243)       OpBuilder.addGenericBinaryArithmeticOverloads();
6f6e91d193373 (Florian Hahn             2020-05-29 20:42:22 +0100  9244)       OpBuilder.addMatrixBinaryArithmeticOverloads();
f9802446a58e5 (Chandler Carruth         2010-12-12 08:39:38 +0000  9245)     }
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9246)     break;
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9247) 
5184de0aff61b (Chandler Carruth         2010-12-12 08:51:33 +0000  9248)   case OO_Star: // '*' is either unary or binary
e54c307bb4ed9 (Richard Smith            2013-05-05 15:51:06 +0000  9249)     if (Args.size() == 1)
5184de0aff61b (Chandler Carruth         2010-12-12 08:51:33 +0000  9250)       OpBuilder.addUnaryStarPointerOverloads();
4affc444b499b (Florian Hahn             2020-06-07 11:11:27 +0100  9251)     else {
c07c389a94bb4 (George Burgess IV        2017-06-08 18:19:25 +0000  9252)       OpBuilder.addGenericBinaryArithmeticOverloads();
4affc444b499b (Florian Hahn             2020-06-07 11:11:27 +0100  9253)       OpBuilder.addMatrixBinaryArithmeticOverloads();
4affc444b499b (Florian Hahn             2020-06-07 11:11:27 +0100  9254)     }
5184de0aff61b (Chandler Carruth         2010-12-12 08:51:33 +0000  9255)     break;
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9256) 
5184de0aff61b (Chandler Carruth         2010-12-12 08:51:33 +0000  9257)   case OO_Slash:
c07c389a94bb4 (George Burgess IV        2017-06-08 18:19:25 +0000  9258)     OpBuilder.addGenericBinaryArithmeticOverloads();
9de23cdb45e56 (Chandler Carruth         2010-12-12 08:45:02 +0000  9259)     break;
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9260) 
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9261)   case OO_PlusPlus:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9262)   case OO_MinusMinus:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9263)     OpBuilder.addPlusPlusMinusMinusArithmeticOverloads(Op);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9264)     OpBuilder.addPlusPlusMinusMinusPointerOverloads();
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9265)     break;
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9266) 
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9267)   case OO_EqualEqual:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9268)   case OO_ExclaimEqual:
5e9746f520e6b (Richard Smith            2016-10-21 22:00:42 +0000  9269)     OpBuilder.addEqualEqualOrNotEqualMemberPointerOrNullptrOverloads();
f3b3ccda590c1 (Adrian Prantl            2017-12-19 22:06:11 +0000  9270)     LLVM_FALLTHROUGH;
9de23cdb45e56 (Chandler Carruth         2010-12-12 08:45:02 +0000  9271) 
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9272)   case OO_Less:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9273)   case OO_Greater:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9274)   case OO_LessEqual:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9275)   case OO_GreaterEqual:
0683c0e68d31d (Eric Fiselier            2018-05-07 21:07:10 +0000  9276)     OpBuilder.addGenericBinaryPointerOrEnumeralOverloads();
c07c389a94bb4 (George Burgess IV        2017-06-08 18:19:25 +0000  9277)     OpBuilder.addGenericBinaryArithmeticOverloads();
0375e954468f1 (Chandler Carruth         2010-12-12 08:32:28 +0000  9278)     break;
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9279) 
d30b23d6a54b3 (Richard Smith            2017-12-01 02:13:10 +0000  9280)   case OO_Spaceship:
0683c0e68d31d (Eric Fiselier            2018-05-07 21:07:10 +0000  9281)     OpBuilder.addGenericBinaryPointerOrEnumeralOverloads();
0683c0e68d31d (Eric Fiselier            2018-05-07 21:07:10 +0000  9282)     OpBuilder.addThreeWayArithmeticOverloads();
0683c0e68d31d (Eric Fiselier            2018-05-07 21:07:10 +0000  9283)     break;
d30b23d6a54b3 (Richard Smith            2017-12-01 02:13:10 +0000  9284) 
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9285)   case OO_Percent:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9286)   case OO_Caret:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9287)   case OO_Pipe:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9288)   case OO_LessLess:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9289)   case OO_GreaterGreater:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9290)     OpBuilder.addBinaryBitwiseArithmeticOverloads(Op);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9291)     break;
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9292) 
5184de0aff61b (Chandler Carruth         2010-12-12 08:51:33 +0000  9293)   case OO_Amp: // '&' is either unary or binary
e54c307bb4ed9 (Richard Smith            2013-05-05 15:51:06 +0000  9294)     if (Args.size() == 1)
5184de0aff61b (Chandler Carruth         2010-12-12 08:51:33 +0000  9295)       // C++ [over.match.oper]p3:
5184de0aff61b (Chandler Carruth         2010-12-12 08:51:33 +0000  9296)       //   -- For the operator ',', the unary operator '&', or the
5184de0aff61b (Chandler Carruth         2010-12-12 08:51:33 +0000  9297)       //      operator '->', the built-in candidates set is empty.
5184de0aff61b (Chandler Carruth         2010-12-12 08:51:33 +0000  9298)       break;
5184de0aff61b (Chandler Carruth         2010-12-12 08:51:33 +0000  9299) 
5184de0aff61b (Chandler Carruth         2010-12-12 08:51:33 +0000  9300)     OpBuilder.addBinaryBitwiseArithmeticOverloads(Op);
5184de0aff61b (Chandler Carruth         2010-12-12 08:51:33 +0000  9301)     break;
5184de0aff61b (Chandler Carruth         2010-12-12 08:51:33 +0000  9302) 
5184de0aff61b (Chandler Carruth         2010-12-12 08:51:33 +0000  9303)   case OO_Tilde:
5184de0aff61b (Chandler Carruth         2010-12-12 08:51:33 +0000  9304)     OpBuilder.addUnaryTildePromotedIntegralOverloads();
5184de0aff61b (Chandler Carruth         2010-12-12 08:51:33 +0000  9305)     break;
5184de0aff61b (Chandler Carruth         2010-12-12 08:51:33 +0000  9306) 
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9307)   case OO_Equal:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9308)     OpBuilder.addAssignmentMemberPointerOrEnumeralOverloads();
f3b3ccda590c1 (Adrian Prantl            2017-12-19 22:06:11 +0000  9309)     LLVM_FALLTHROUGH;
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9310) 
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9311)   case OO_PlusEqual:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9312)   case OO_MinusEqual:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9313)     OpBuilder.addAssignmentPointerOverloads(Op == OO_Equal);
f3b3ccda590c1 (Adrian Prantl            2017-12-19 22:06:11 +0000  9314)     LLVM_FALLTHROUGH;
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9315) 
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9316)   case OO_StarEqual:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9317)   case OO_SlashEqual:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9318)     OpBuilder.addAssignmentArithmeticOverloads(Op == OO_Equal);
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9319)     break;
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9320) 
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9321)   case OO_PercentEqual:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9322)   case OO_LessLessEqual:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9323)   case OO_GreaterGreaterEqual:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9324)   case OO_AmpEqual:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9325)   case OO_CaretEqual:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9326)   case OO_PipeEqual:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9327)     OpBuilder.addAssignmentIntegralOverloads();
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9328)     break;
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9329) 
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9330)   case OO_Exclaim:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9331)     OpBuilder.addExclaimOverload();
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9332)     break;
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9333) 
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9334)   case OO_AmpAmp:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9335)   case OO_PipePipe:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9336)     OpBuilder.addAmpAmpOrPipePipeOverload();
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9337)     break;
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9338) 
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9339)   case OO_Subscript:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9340)     OpBuilder.addSubscriptOverloads();
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9341)     break;
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9342) 
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9343)   case OO_ArrowStar:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9344)     OpBuilder.addArrowStarOverloads();
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9345)     break;
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9346) 
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9347)   case OO_Conditional:
85c2d09a5a43a (Chandler Carruth         2010-12-12 08:11:30 +0000  9348)     OpBuilder.addConditionalOperatorOverloads();
c07c389a94bb4 (George Burgess IV        2017-06-08 18:19:25 +0000  9349)     OpBuilder.addGenericBinaryArithmeticOverloads();
f9802446a58e5 (Chandler Carruth         2010-12-12 08:39:38 +0000  9350)     break;
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  9351)   }
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  9352) }
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000  9353) 
9fc8faf9e6197 (Adrian Prantl            2018-05-09 01:00:01 +0000  9354) /// Add function candidates found via argument-dependent lookup
e254f90d94e32 (Douglas Gregor           2009-02-04 00:32:51 +0000  9355) /// to the set of overloading candidates.
e254f90d94e32 (Douglas Gregor           2009-02-04 00:32:51 +0000  9356) ///
e254f90d94e32 (Douglas Gregor           2009-02-04 00:32:51 +0000  9357) /// This routine performs argument-dependent name lookup based on the
e254f90d94e32 (Douglas Gregor           2009-02-04 00:32:51 +0000  9358) /// given function name (which may also be an operator name) and adds
e254f90d94e32 (Douglas Gregor           2009-02-04 00:32:51 +0000  9359) /// all of the overload candidates found by ADL to the overload
e254f90d94e32 (Douglas Gregor           2009-02-04 00:32:51 +0000  9360) /// candidate set (C++ [basic.lookup.argdep]).
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  9361) void
e254f90d94e32 (Douglas Gregor           2009-02-04 00:32:51 +0000  9362) Sema::AddArgumentDependentLookupCandidates(DeclarationName Name,
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000  9363)                                            SourceLocation Loc,
f857950d391d0 (Dmitri Gribenko          2013-01-12 19:30:44 +0000  9364)                                            ArrayRef<Expr *> Args,
739b107af8003 (Douglas Gregor           2011-03-03 02:41:12 +0000  9365)                                  TemplateArgumentListInfo *ExplicitTemplateArgs,
cabea40ea3c9b (Douglas Gregor           2009-09-22 15:41:20 +0000  9366)                                            OverloadCandidateSet& CandidateSet,
b6626748c2e50 (Richard Smith            2012-10-18 17:56:02 +0000  9367)                                            bool PartialOverloading) {
8fe6808de0d1b (John McCall              2010-01-26 07:16:45 +0000  9368)   ADLResult Fns;
d2b7ef6ecea96 (Douglas Gregor           2009-03-13 00:33:25 +0000  9369) 
91f61fc921e4a (John McCall              2010-01-26 06:04:06 +0000  9370)   // FIXME: This approach for uniquing ADL results (and removing
91f61fc921e4a (John McCall              2010-01-26 06:04:06 +0000  9371)   // redundant candidates from the set) relies on pointer-equality,
91f61fc921e4a (John McCall              2010-01-26 06:04:06 +0000  9372)   // which means we need to key off the canonical decl.  However,
91f61fc921e4a (John McCall              2010-01-26 06:04:06 +0000  9373)   // always going back to the canonical decl might not get us the
91f61fc921e4a (John McCall              2010-01-26 06:04:06 +0000  9374)   // right set of default arguments.  What default arguments are
91f61fc921e4a (John McCall              2010-01-26 06:04:06 +0000  9375)   // we supposed to consider on ADL candidates, anyway?
91f61fc921e4a (John McCall              2010-01-26 06:04:06 +0000  9376) 
cabea40ea3c9b (Douglas Gregor           2009-09-22 15:41:20 +0000  9377)   // FIXME: Pass in the explicit template arguments?
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000  9378)   ArgumentDependentLookup(Name, Loc, Args, Fns);
d2b7ef6ecea96 (Douglas Gregor           2009-03-13 00:33:25 +0000  9379) 
d2b7ef6ecea96 (Douglas Gregor           2009-03-13 00:33:25 +0000  9380)   // Erase all of the candidates we already knew about.
d2b7ef6ecea96 (Douglas Gregor           2009-03-13 00:33:25 +0000  9381)   for (OverloadCandidateSet::iterator Cand = CandidateSet.begin(),
d2b7ef6ecea96 (Douglas Gregor           2009-03-13 00:33:25 +0000  9382)                                    CandEnd = CandidateSet.end();
d2b7ef6ecea96 (Douglas Gregor           2009-03-13 00:33:25 +0000  9383)        Cand != CandEnd; ++Cand)
15448f8d238c5 (Douglas Gregor           2009-06-27 21:05:07 +0000  9384)     if (Cand->Function) {
8fe6808de0d1b (John McCall              2010-01-26 07:16:45 +0000  9385)       Fns.erase(Cand->Function);
15448f8d238c5 (Douglas Gregor           2009-06-27 21:05:07 +0000  9386)       if (FunctionTemplateDecl *FunTmpl = Cand->Function->getPrimaryTemplate())
8fe6808de0d1b (John McCall              2010-01-26 07:16:45 +0000  9387)         Fns.erase(FunTmpl);
15448f8d238c5 (Douglas Gregor           2009-06-27 21:05:07 +0000  9388)     }
d2b7ef6ecea96 (Douglas Gregor           2009-03-13 00:33:25 +0000  9389) 
d2b7ef6ecea96 (Douglas Gregor           2009-03-13 00:33:25 +0000  9390)   // For each of the ADL candidates we found, add it to the overload
d2b7ef6ecea96 (Douglas Gregor           2009-03-13 00:33:25 +0000  9391)   // set.
8fe6808de0d1b (John McCall              2010-01-26 07:16:45 +0000  9392)   for (ADLResult::iterator I = Fns.begin(), E = Fns.end(); I != E; ++I) {
a0296f7987c0a (John McCall              2010-03-19 07:35:19 +0000  9393)     DeclAccessPair FoundDecl = DeclAccessPair::make(*I, AS_none);
5cdc2cda28ac8 (Eric Fiselier            2018-12-12 21:50:55 +0000  9394) 
4c4c1dfc2b768 (John McCall              2010-01-26 03:27:55 +0000  9395)     if (FunctionDecl *FD = dyn_cast<FunctionDecl>(*I)) {
6b51f28e82646 (John McCall              2009-11-23 01:53:49 +0000  9396)       if (ExplicitTemplateArgs)
cabea40ea3c9b (Douglas Gregor           2009-09-22 15:41:20 +0000  9397)         continue;
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000  9398) 
1db66e705f4db (Richard Smith            2020-01-30 18:40:53 -0800  9399)       AddOverloadCandidate(
1db66e705f4db (Richard Smith            2020-01-30 18:40:53 -0800  9400)           FD, FoundDecl, Args, CandidateSet, /*SuppressUserConversions=*/false,
1db66e705f4db (Richard Smith            2020-01-30 18:40:53 -0800  9401)           PartialOverloading, /*AllowExplicit=*/true,
1db66e705f4db (Richard Smith            2020-01-30 18:40:53 -0800  9402)           /*AllowExplicitConversions=*/false, ADLCallKind::UsesADL);
1db66e705f4db (Richard Smith            2020-01-30 18:40:53 -0800  9403)       if (CandidateSet.getRewriteInfo().shouldAddReversed(Context, FD)) {
1db66e705f4db (Richard Smith            2020-01-30 18:40:53 -0800  9404)         AddOverloadCandidate(
1db66e705f4db (Richard Smith            2020-01-30 18:40:53 -0800  9405)             FD, FoundDecl, {Args[1], Args[0]}, CandidateSet,
1db66e705f4db (Richard Smith            2020-01-30 18:40:53 -0800  9406)             /*SuppressUserConversions=*/false, PartialOverloading,
1db66e705f4db (Richard Smith            2020-01-30 18:40:53 -0800  9407)             /*AllowExplicit=*/true, /*AllowExplicitConversions=*/false,
1db66e705f4db (Richard Smith            2020-01-30 18:40:53 -0800  9408)             ADLCallKind::UsesADL, None, OverloadCandidateParamOrder::Reversed);
1db66e705f4db (Richard Smith            2020-01-30 18:40:53 -0800  9409)       }
743ae6045d413 (Eric Fiselier            2018-12-11 16:53:25 +0000  9410)     } else {
1db66e705f4db (Richard Smith            2020-01-30 18:40:53 -0800  9411)       auto *FTD = cast<FunctionTemplateDecl>(*I);
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000  9412)       AddTemplateOverloadCandidate(
1db66e705f4db (Richard Smith            2020-01-30 18:40:53 -0800  9413)           FTD, FoundDecl, ExplicitTemplateArgs, Args, CandidateSet,
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000  9414)           /*SuppressUserConversions=*/false, PartialOverloading,
1db66e705f4db (Richard Smith            2020-01-30 18:40:53 -0800  9415)           /*AllowExplicit=*/true, ADLCallKind::UsesADL);
1db66e705f4db (Richard Smith            2020-01-30 18:40:53 -0800  9416)       if (CandidateSet.getRewriteInfo().shouldAddReversed(
1db66e705f4db (Richard Smith            2020-01-30 18:40:53 -0800  9417)               Context, FTD->getTemplatedDecl())) {
1db66e705f4db (Richard Smith            2020-01-30 18:40:53 -0800  9418)         AddTemplateOverloadCandidate(
1db66e705f4db (Richard Smith            2020-01-30 18:40:53 -0800  9419)             FTD, FoundDecl, ExplicitTemplateArgs, {Args[1], Args[0]},
1db66e705f4db (Richard Smith            2020-01-30 18:40:53 -0800  9420)             CandidateSet, /*SuppressUserConversions=*/false, PartialOverloading,
1db66e705f4db (Richard Smith            2020-01-30 18:40:53 -0800  9421)             /*AllowExplicit=*/true, ADLCallKind::UsesADL,
1db66e705f4db (Richard Smith            2020-01-30 18:40:53 -0800  9422)             OverloadCandidateParamOrder::Reversed);
1db66e705f4db (Richard Smith            2020-01-30 18:40:53 -0800  9423)       }
743ae6045d413 (Eric Fiselier            2018-12-11 16:53:25 +0000  9424)     }
15448f8d238c5 (Douglas Gregor           2009-06-27 21:05:07 +0000  9425)   }
e254f90d94e32 (Douglas Gregor           2009-02-04 00:32:51 +0000  9426) }
e254f90d94e32 (Douglas Gregor           2009-02-04 00:32:51 +0000  9427) 
3dc16691339e0 (George Burgess IV        2016-05-10 01:59:34 +0000  9428) namespace {
3dc16691339e0 (George Burgess IV        2016-05-10 01:59:34 +0000  9429) enum class Comparison { Equal, Better, Worse };
3dc16691339e0 (George Burgess IV        2016-05-10 01:59:34 +0000  9430) }
3dc16691339e0 (George Burgess IV        2016-05-10 01:59:34 +0000  9431) 
3dc16691339e0 (George Burgess IV        2016-05-10 01:59:34 +0000  9432) /// Compares the enable_if attributes of two FunctionDecls, for the purposes of
3dc16691339e0 (George Burgess IV        2016-05-10 01:59:34 +0000  9433) /// overload resolution.
3dc16691339e0 (George Burgess IV        2016-05-10 01:59:34 +0000  9434) ///
3dc16691339e0 (George Burgess IV        2016-05-10 01:59:34 +0000  9435) /// Cand1's set of enable_if attributes are said to be "better" than Cand2's iff
3dc16691339e0 (George Burgess IV        2016-05-10 01:59:34 +0000  9436) /// Cand1's first N enable_if attributes have precisely the same conditions as
3dc16691339e0 (George Burgess IV        2016-05-10 01:59:34 +0000  9437) /// Cand2's first N enable_if attributes (where N = the number of enable_if
3dc16691339e0 (George Burgess IV        2016-05-10 01:59:34 +0000  9438) /// attributes on Cand2), and Cand1 has more than N enable_if attributes.
3dc16691339e0 (George Burgess IV        2016-05-10 01:59:34 +0000  9439) ///
3dc16691339e0 (George Burgess IV        2016-05-10 01:59:34 +0000  9440) /// Note that you can have a pair of candidates such that Cand1's enable_if
3dc16691339e0 (George Burgess IV        2016-05-10 01:59:34 +0000  9441) /// attributes are worse than Cand2's, and Cand2's enable_if attributes are
3dc16691339e0 (George Burgess IV        2016-05-10 01:59:34 +0000  9442) /// worse than Cand1's.
3dc16691339e0 (George Burgess IV        2016-05-10 01:59:34 +0000  9443) static Comparison compareEnableIfAttrs(const Sema &S, const FunctionDecl *Cand1,
3dc16691339e0 (George Burgess IV        2016-05-10 01:59:34 +0000  9444)                                        const FunctionDecl *Cand2) {
3dc16691339e0 (George Burgess IV        2016-05-10 01:59:34 +0000  9445)   // Common case: One (or both) decls don't have enable_if attrs.
3dc16691339e0 (George Burgess IV        2016-05-10 01:59:34 +0000  9446)   bool Cand1Attr = Cand1->hasAttr<EnableIfAttr>();
3dc16691339e0 (George Burgess IV        2016-05-10 01:59:34 +0000  9447)   bool Cand2Attr = Cand2->hasAttr<EnableIfAttr>();
3dc16691339e0 (George Burgess IV        2016-05-10 01:59:34 +0000  9448)   if (!Cand1Attr || !Cand2Attr) {
3dc16691339e0 (George Burgess IV        2016-05-10 01:59:34 +0000  9449)     if (Cand1Attr == Cand2Attr)
3dc16691339e0 (George Burgess IV        2016-05-10 01:59:34 +0000  9450)       return Comparison::Equal;
3dc16691339e0 (George Burgess IV        2016-05-10 01:59:34 +0000  9451)     return Cand1Attr ? Comparison::Better : Comparison::Worse;
3dc16691339e0 (George Burgess IV        2016-05-10 01:59:34 +0000  9452)   }
2a6150d93290b (George Burgess IV        2015-10-16 01:17:38 +0000  9453) 
dc5ce72afada3 (Michael Kruse            2018-08-03 01:21:16 +0000  9454)   auto Cand1Attrs = Cand1->specific_attrs<EnableIfAttr>();
dc5ce72afada3 (Michael Kruse            2018-08-03 01:21:16 +0000  9455)   auto Cand2Attrs = Cand2->specific_attrs<EnableIfAttr>();
2a6150d93290b (George Burgess IV        2015-10-16 01:17:38 +0000  9456) 
2a6150d93290b (George Burgess IV        2015-10-16 01:17:38 +0000  9457)   llvm::FoldingSetNodeID Cand1ID, Cand2ID;
157a355f3b3e7 (Michael Kruse            2018-12-10 15:16:37 +0000  9458)   for (auto Pair : zip_longest(Cand1Attrs, Cand2Attrs)) {
157a355f3b3e7 (Michael Kruse            2018-12-10 15:16:37 +0000  9459)     Optional<EnableIfAttr *> Cand1A = std::get<0>(Pair);
157a355f3b3e7 (Michael Kruse            2018-12-10 15:16:37 +0000  9460)     Optional<EnableIfAttr *> Cand2A = std::get<1>(Pair);
2a6150d93290b (George Burgess IV        2015-10-16 01:17:38 +0000  9461) 
dc5ce72afada3 (Michael Kruse            2018-08-03 01:21:16 +0000  9462)     // It's impossible for Cand1 to be better than (or equal to) Cand2 if Cand1
157a355f3b3e7 (Michael Kruse            2018-12-10 15:16:37 +0000  9463)     // has fewer enable_if attributes than Cand2, and vice versa.
157a355f3b3e7 (Michael Kruse            2018-12-10 15:16:37 +0000  9464)     if (!Cand1A)
dc5ce72afada3 (Michael Kruse            2018-08-03 01:21:16 +0000  9465)       return Comparison::Worse;
157a355f3b3e7 (Michael Kruse            2018-12-10 15:16:37 +0000  9466)     if (!Cand2A)
157a355f3b3e7 (Michael Kruse            2018-12-10 15:16:37 +0000  9467)       return Comparison::Better;
157a355f3b3e7 (Michael Kruse            2018-12-10 15:16:37 +0000  9468) 
157a355f3b3e7 (Michael Kruse            2018-12-10 15:16:37 +0000  9469)     Cand1ID.clear();
157a355f3b3e7 (Michael Kruse            2018-12-10 15:16:37 +0000  9470)     Cand2ID.clear();
dc5ce72afada3 (Michael Kruse            2018-08-03 01:21:16 +0000  9471) 
157a355f3b3e7 (Michael Kruse            2018-12-10 15:16:37 +0000  9472)     (*Cand1A)->getCond()->Profile(Cand1ID, S.getASTContext(), true);
157a355f3b3e7 (Michael Kruse            2018-12-10 15:16:37 +0000  9473)     (*Cand2A)->getCond()->Profile(Cand2ID, S.getASTContext(), true);
2a6150d93290b (George Burgess IV        2015-10-16 01:17:38 +0000  9474)     if (Cand1ID != Cand2ID)
3dc16691339e0 (George Burgess IV        2016-05-10 01:59:34 +0000  9475)       return Comparison::Worse;
2a6150d93290b (George Burgess IV        2015-10-16 01:17:38 +0000  9476)   }
2a6150d93290b (George Burgess IV        2015-10-16 01:17:38 +0000  9477) 
157a355f3b3e7 (Michael Kruse            2018-12-10 15:16:37 +0000  9478)   return Comparison::Equal;
2a6150d93290b (George Burgess IV        2015-10-16 01:17:38 +0000  9479) }
2a6150d93290b (George Burgess IV        2015-10-16 01:17:38 +0000  9480) 
b3d10920e1344 (Fangrui Song             2020-06-10 22:32:43 -0700  9481) static Comparison
b3d10920e1344 (Fangrui Song             2020-06-10 22:32:43 -0700  9482) isBetterMultiversionCandidate(const OverloadCandidate &Cand1,
b3d10920e1344 (Fangrui Song             2020-06-10 22:32:43 -0700  9483)                               const OverloadCandidate &Cand2) {
3efe00206f0f4 (Erich Keane              2018-07-20 14:13:28 +0000  9484)   if (!Cand1.Function || !Cand1.Function->isMultiVersion() || !Cand2.Function ||
3efe00206f0f4 (Erich Keane              2018-07-20 14:13:28 +0000  9485)       !Cand2.Function->isMultiVersion())
b3d10920e1344 (Fangrui Song             2020-06-10 22:32:43 -0700  9486)     return Comparison::Equal;
3efe00206f0f4 (Erich Keane              2018-07-20 14:13:28 +0000  9487) 
b3d10920e1344 (Fangrui Song             2020-06-10 22:32:43 -0700  9488)   // If both are invalid, they are equal. If one of them is invalid, the other
b3d10920e1344 (Fangrui Song             2020-06-10 22:32:43 -0700  9489)   // is better.
b3d10920e1344 (Fangrui Song             2020-06-10 22:32:43 -0700  9490)   if (Cand1.Function->isInvalidDecl()) {
b3d10920e1344 (Fangrui Song             2020-06-10 22:32:43 -0700  9491)     if (Cand2.Function->isInvalidDecl())
b3d10920e1344 (Fangrui Song             2020-06-10 22:32:43 -0700  9492)       return Comparison::Equal;
b3d10920e1344 (Fangrui Song             2020-06-10 22:32:43 -0700  9493)     return Comparison::Worse;
b3d10920e1344 (Fangrui Song             2020-06-10 22:32:43 -0700  9494)   }
b3d10920e1344 (Fangrui Song             2020-06-10 22:32:43 -0700  9495)   if (Cand2.Function->isInvalidDecl())
b3d10920e1344 (Fangrui Song             2020-06-10 22:32:43 -0700  9496)     return Comparison::Better;
414ff52d09f7a (Erich Keane              2019-01-04 15:24:06 +0000  9497) 
3efe00206f0f4 (Erich Keane              2018-07-20 14:13:28 +0000  9498)   // If this is a cpu_dispatch/cpu_specific multiversion situation, prefer
3efe00206f0f4 (Erich Keane              2018-07-20 14:13:28 +0000  9499)   // cpu_dispatch, else arbitrarily based on the identifiers.
3efe00206f0f4 (Erich Keane              2018-07-20 14:13:28 +0000  9500)   bool Cand1CPUDisp = Cand1.Function->hasAttr<CPUDispatchAttr>();
3efe00206f0f4 (Erich Keane              2018-07-20 14:13:28 +0000  9501)   bool Cand2CPUDisp = Cand2.Function->hasAttr<CPUDispatchAttr>();
3efe00206f0f4 (Erich Keane              2018-07-20 14:13:28 +0000  9502)   const auto *Cand1CPUSpec = Cand1.Function->getAttr<CPUSpecificAttr>();
3efe00206f0f4 (Erich Keane              2018-07-20 14:13:28 +0000  9503)   const auto *Cand2CPUSpec = Cand2.Function->getAttr<CPUSpecificAttr>();
3efe00206f0f4 (Erich Keane              2018-07-20 14:13:28 +0000  9504) 
3efe00206f0f4 (Erich Keane              2018-07-20 14:13:28 +0000  9505)   if (!Cand1CPUDisp && !Cand2CPUDisp && !Cand1CPUSpec && !Cand2CPUSpec)
b3d10920e1344 (Fangrui Song             2020-06-10 22:32:43 -0700  9506)     return Comparison::Equal;
3efe00206f0f4 (Erich Keane              2018-07-20 14:13:28 +0000  9507) 
3efe00206f0f4 (Erich Keane              2018-07-20 14:13:28 +0000  9508)   if (Cand1CPUDisp && !Cand2CPUDisp)
b3d10920e1344 (Fangrui Song             2020-06-10 22:32:43 -0700  9509)     return Comparison::Better;
3efe00206f0f4 (Erich Keane              2018-07-20 14:13:28 +0000  9510)   if (Cand2CPUDisp && !Cand1CPUDisp)
b3d10920e1344 (Fangrui Song             2020-06-10 22:32:43 -0700  9511)     return Comparison::Worse;
3efe00206f0f4 (Erich Keane              2018-07-20 14:13:28 +0000  9512) 
3efe00206f0f4 (Erich Keane              2018-07-20 14:13:28 +0000  9513)   if (Cand1CPUSpec && Cand2CPUSpec) {
3efe00206f0f4 (Erich Keane              2018-07-20 14:13:28 +0000  9514)     if (Cand1CPUSpec->cpus_size() != Cand2CPUSpec->cpus_size())
b3d10920e1344 (Fangrui Song             2020-06-10 22:32:43 -0700  9515)       return Cand1CPUSpec->cpus_size() < Cand2CPUSpec->cpus_size()
b3d10920e1344 (Fangrui Song             2020-06-10 22:32:43 -0700  9516)                  ? Comparison::Better
b3d10920e1344 (Fangrui Song             2020-06-10 22:32:43 -0700  9517)                  : Comparison::Worse;
3efe00206f0f4 (Erich Keane              2018-07-20 14:13:28 +0000  9518) 
3efe00206f0f4 (Erich Keane              2018-07-20 14:13:28 +0000  9519)     std::pair<CPUSpecificAttr::cpus_iterator, CPUSpecificAttr::cpus_iterator>
3efe00206f0f4 (Erich Keane              2018-07-20 14:13:28 +0000  9520)         FirstDiff = std::mismatch(
3efe00206f0f4 (Erich Keane              2018-07-20 14:13:28 +0000  9521)             Cand1CPUSpec->cpus_begin(), Cand1CPUSpec->cpus_end(),
3efe00206f0f4 (Erich Keane              2018-07-20 14:13:28 +0000  9522)             Cand2CPUSpec->cpus_begin(),
3efe00206f0f4 (Erich Keane              2018-07-20 14:13:28 +0000  9523)             [](const IdentifierInfo *LHS, const IdentifierInfo *RHS) {
3efe00206f0f4 (Erich Keane              2018-07-20 14:13:28 +0000  9524)               return LHS->getName() == RHS->getName();
3efe00206f0f4 (Erich Keane              2018-07-20 14:13:28 +0000  9525)             });
3efe00206f0f4 (Erich Keane              2018-07-20 14:13:28 +0000  9526) 
3efe00206f0f4 (Erich Keane              2018-07-20 14:13:28 +0000  9527)     assert(FirstDiff.first != Cand1CPUSpec->cpus_end() &&
3efe00206f0f4 (Erich Keane              2018-07-20 14:13:28 +0000  9528)            "Two different cpu-specific versions should not have the same "
3efe00206f0f4 (Erich Keane              2018-07-20 14:13:28 +0000  9529)            "identifier list, otherwise they'd be the same decl!");
b3d10920e1344 (Fangrui Song             2020-06-10 22:32:43 -0700  9530)     return (*FirstDiff.first)->getName() < (*FirstDiff.second)->getName()
b3d10920e1344 (Fangrui Song             2020-06-10 22:32:43 -0700  9531)                ? Comparison::Better
b3d10920e1344 (Fangrui Song             2020-06-10 22:32:43 -0700  9532)                : Comparison::Worse;
3efe00206f0f4 (Erich Keane              2018-07-20 14:13:28 +0000  9533)   }
3efe00206f0f4 (Erich Keane              2018-07-20 14:13:28 +0000  9534)   llvm_unreachable("No way to get here unless both had cpu_dispatch");
3efe00206f0f4 (Erich Keane              2018-07-20 14:13:28 +0000  9535) }
3efe00206f0f4 (Erich Keane              2018-07-20 14:13:28 +0000  9536) 
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9537) /// Compute the type of the implicit object parameter for the given function,
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9538) /// if any. Returns None if there is no implicit object parameter, and a null
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9539) /// QualType if there is a 'matches anything' implicit object parameter.
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9540) static Optional<QualType> getImplicitObjectParamType(ASTContext &Context,
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9541)                                                      const FunctionDecl *F) {
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9542)   if (!isa<CXXMethodDecl>(F) || isa<CXXConstructorDecl>(F))
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9543)     return llvm::None;
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9544) 
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9545)   auto *M = cast<CXXMethodDecl>(F);
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9546)   // Static member functions' object parameters match all types.
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9547)   if (M->isStatic())
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9548)     return QualType();
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9549) 
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9550)   QualType T = M->getThisObjectType();
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9551)   if (M->getRefQualifier() == RQ_RValue)
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9552)     return Context.getRValueReferenceType(T);
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9553)   return Context.getLValueReferenceType(T);
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9554) }
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9555) 
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9556) static bool haveSameParameterTypes(ASTContext &Context, const FunctionDecl *F1,
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9557)                                    const FunctionDecl *F2, unsigned NumParams) {
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9558)   if (declaresSameEntity(F1, F2))
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9559)     return true;
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9560) 
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9561)   auto NextParam = [&](const FunctionDecl *F, unsigned &I, bool First) {
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9562)     if (First) {
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9563)       if (Optional<QualType> T = getImplicitObjectParamType(Context, F))
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9564)         return *T;
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9565)     }
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9566)     assert(I < F->getNumParams());
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9567)     return F->getParamDecl(I++)->getType();
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9568)   };
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9569) 
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9570)   unsigned I1 = 0, I2 = 0;
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9571)   for (unsigned I = 0; I != NumParams; ++I) {
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9572)     QualType T1 = NextParam(F1, I1, I == 0);
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9573)     QualType T2 = NextParam(F2, I2, I == 0);
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9574)     if (!T1.isNull() && !T1.isNull() && !Context.hasSameUnqualifiedType(T1, T2))
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9575)       return false;
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9576)   }
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9577)   return true;
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9578) }
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9579) 
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  9580) /// isBetterOverloadCandidate - Determines whether the first overload
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  9581) /// candidate is a better candidate than the second (C++ 13.3.3p1).
67ef14fe486e1 (Richard Smith            2017-09-26 18:37:55 +0000  9582) bool clang::isBetterOverloadCandidate(
67ef14fe486e1 (Richard Smith            2017-09-26 18:37:55 +0000  9583)     Sema &S, const OverloadCandidate &Cand1, const OverloadCandidate &Cand2,
67ef14fe486e1 (Richard Smith            2017-09-26 18:37:55 +0000  9584)     SourceLocation Loc, OverloadCandidateSet::CandidateSetKind Kind) {
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  9585)   // Define viable functions to be better candidates than non-viable
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  9586)   // functions.
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  9587)   if (!Cand2.Viable)
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  9588)     return Cand1.Viable;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  9589)   else if (!Cand1.Viable)
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  9590)     return false;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  9591) 
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9592)   // [CUDA] A function with 'never' preference is marked not viable, therefore
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9593)   // is never shown up here. The worst preference shown up here is 'wrong side',
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9594)   // e.g. an H function called by a HD function in device compilation. This is
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9595)   // valid AST as long as the HD function is not emitted, e.g. it is an inline
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9596)   // function which is called only by an H function. A deferred diagnostic will
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9597)   // be triggered if it is emitted. However a wrong-sided function is still
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9598)   // a viable candidate here.
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9599)   //
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9600)   // If Cand1 can be emitted and Cand2 cannot be emitted in the current
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9601)   // context, Cand1 is better than Cand2. If Cand1 can not be emitted and Cand2
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9602)   // can be emitted, Cand1 is not better than Cand2. This rule should have
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9603)   // precedence over other rules.
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9604)   //
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9605)   // If both Cand1 and Cand2 can be emitted, or neither can be emitted, then
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9606)   // other rules should be used to determine which is better. This is because
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9607)   // host/device based overloading resolution is mostly for determining
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9608)   // viability of a function. If two functions are both viable, other factors
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9609)   // should take precedence in preference, e.g. the standard-defined preferences
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9610)   // like argument conversion ranks or enable_if partial-ordering. The
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9611)   // preference for pass-object-size parameters is probably most similar to a
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9612)   // type-based-overloading decision and so should take priority.
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9613)   //
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9614)   // If other rules cannot determine which is better, CUDA preference will be
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9615)   // used again to determine which is better.
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9616)   //
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9617)   // TODO: Currently IdentifyCUDAPreference does not return correct values
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9618)   // for functions called in global variable initializers due to missing
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9619)   // correct context about device/host. Therefore we can only enforce this
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9620)   // rule when there is a caller. We should enforce this rule for functions
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9621)   // in global variable initializers once proper context is added.
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9622)   //
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9623)   // TODO: We can only enable the hostness based overloading resolution when
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9624)   // -fgpu-exclude-wrong-side-overloads is on since this requires deferring
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9625)   // overloading resolution diagnostics.
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9626)   if (S.getLangOpts().CUDA && Cand1.Function && Cand2.Function &&
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9627)       S.getLangOpts().GPUExcludeWrongSideOverloads) {
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9628)     if (FunctionDecl *Caller = dyn_cast<FunctionDecl>(S.CurContext)) {
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9629)       bool IsCallerImplicitHD = Sema::isCUDAImplicitHostDeviceFunction(Caller);
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9630)       bool IsCand1ImplicitHD =
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9631)           Sema::isCUDAImplicitHostDeviceFunction(Cand1.Function);
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9632)       bool IsCand2ImplicitHD =
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9633)           Sema::isCUDAImplicitHostDeviceFunction(Cand2.Function);
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9634)       auto P1 = S.IdentifyCUDAPreference(Caller, Cand1.Function);
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9635)       auto P2 = S.IdentifyCUDAPreference(Caller, Cand2.Function);
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9636)       assert(P1 != Sema::CFP_Never && P2 != Sema::CFP_Never);
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9637)       // The implicit HD function may be a function in a system header which
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9638)       // is forced by pragma. In device compilation, if we prefer HD candidates
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9639)       // over wrong-sided candidates, overloading resolution may change, which
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9640)       // may result in non-deferrable diagnostics. As a workaround, we let
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9641)       // implicit HD candidates take equal preference as wrong-sided candidates.
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9642)       // This will preserve the overloading resolution.
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9643)       // TODO: We still need special handling of implicit HD functions since
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9644)       // they may incur other diagnostics to be deferred. We should make all
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9645)       // host/device related diagnostics deferrable and remove special handling
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9646)       // of implicit HD functions.
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9647)       auto EmitThreshold =
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9648)           (S.getLangOpts().CUDAIsDevice && IsCallerImplicitHD &&
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9649)            (IsCand1ImplicitHD || IsCand2ImplicitHD))
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9650)               ? Sema::CFP_Never
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9651)               : Sema::CFP_WrongSide;
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9652)       auto Cand1Emittable = P1 > EmitThreshold;
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9653)       auto Cand2Emittable = P2 > EmitThreshold;
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9654)       if (Cand1Emittable && !Cand2Emittable)
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9655)         return true;
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9656)       if (!Cand1Emittable && Cand2Emittable)
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9657)         return false;
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9658)     }
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9659)   }
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9660) 
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000  9661)   // C++ [over.match.best]p1:
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000  9662)   //
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000  9663)   //   -- if F is a static member function, ICS1(F) is defined such
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000  9664)   //      that ICS1(F) is neither better nor worse than ICS1(G) for
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000  9665)   //      any function G, and, symmetrically, ICS1(G) is neither
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000  9666)   //      better nor worse than ICS1(F).
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000  9667)   unsigned StartArg = 0;
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000  9668)   if (Cand1.IgnoreObjectArgument || Cand2.IgnoreObjectArgument)
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000  9669)     StartArg = 1;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  9670) 
fbad5b2f1b7df (George Burgess IV        2016-09-07 20:03:19 +0000  9671)   auto IsIllFormedConversion = [&](const ImplicitConversionSequence &ICS) {
fbad5b2f1b7df (George Burgess IV        2016-09-07 20:03:19 +0000  9672)     // We don't allow incompatible pointer conversions in C++.
fbad5b2f1b7df (George Burgess IV        2016-09-07 20:03:19 +0000  9673)     if (!S.getLangOpts().CPlusPlus)
fbad5b2f1b7df (George Burgess IV        2016-09-07 20:03:19 +0000  9674)       return ICS.isStandard() &&
fbad5b2f1b7df (George Burgess IV        2016-09-07 20:03:19 +0000  9675)              ICS.Standard.Second == ICK_Incompatible_Pointer_Conversion;
fbad5b2f1b7df (George Burgess IV        2016-09-07 20:03:19 +0000  9676) 
fbad5b2f1b7df (George Burgess IV        2016-09-07 20:03:19 +0000  9677)     // The only ill-formed conversion we allow in C++ is the string literal to
fbad5b2f1b7df (George Burgess IV        2016-09-07 20:03:19 +0000  9678)     // char* conversion, which is only considered ill-formed after C++11.
fbad5b2f1b7df (George Burgess IV        2016-09-07 20:03:19 +0000  9679)     return S.getLangOpts().CPlusPlus11 && !S.getLangOpts().WritableStrings &&
fbad5b2f1b7df (George Burgess IV        2016-09-07 20:03:19 +0000  9680)            hasDeprecatedStringLiteralToCharPtrConversion(ICS);
fbad5b2f1b7df (George Burgess IV        2016-09-07 20:03:19 +0000  9681)   };
fbad5b2f1b7df (George Burgess IV        2016-09-07 20:03:19 +0000  9682) 
fbad5b2f1b7df (George Burgess IV        2016-09-07 20:03:19 +0000  9683)   // Define functions that don't require ill-formed conversions for a given
fbad5b2f1b7df (George Burgess IV        2016-09-07 20:03:19 +0000  9684)   // argument to be better candidates than functions that do.
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  9685)   unsigned NumArgs = Cand1.Conversions.size();
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000  9686)   assert(Cand2.Conversions.size() == NumArgs && "Overload candidate mismatch");
fbad5b2f1b7df (George Burgess IV        2016-09-07 20:03:19 +0000  9687)   bool HasBetterConversion = false;
fbad5b2f1b7df (George Burgess IV        2016-09-07 20:03:19 +0000  9688)   for (unsigned ArgIdx = StartArg; ArgIdx < NumArgs; ++ArgIdx) {
fbad5b2f1b7df (George Burgess IV        2016-09-07 20:03:19 +0000  9689)     bool Cand1Bad = IsIllFormedConversion(Cand1.Conversions[ArgIdx]);
fbad5b2f1b7df (George Burgess IV        2016-09-07 20:03:19 +0000  9690)     bool Cand2Bad = IsIllFormedConversion(Cand2.Conversions[ArgIdx]);
fbad5b2f1b7df (George Burgess IV        2016-09-07 20:03:19 +0000  9691)     if (Cand1Bad != Cand2Bad) {
fbad5b2f1b7df (George Burgess IV        2016-09-07 20:03:19 +0000  9692)       if (Cand1Bad)
fbad5b2f1b7df (George Burgess IV        2016-09-07 20:03:19 +0000  9693)         return false;
fbad5b2f1b7df (George Burgess IV        2016-09-07 20:03:19 +0000  9694)       HasBetterConversion = true;
fbad5b2f1b7df (George Burgess IV        2016-09-07 20:03:19 +0000  9695)     }
fbad5b2f1b7df (George Burgess IV        2016-09-07 20:03:19 +0000  9696)   }
fbad5b2f1b7df (George Burgess IV        2016-09-07 20:03:19 +0000  9697) 
fbad5b2f1b7df (George Burgess IV        2016-09-07 20:03:19 +0000  9698)   if (HasBetterConversion)
fbad5b2f1b7df (George Burgess IV        2016-09-07 20:03:19 +0000  9699)     return true;
fbad5b2f1b7df (George Burgess IV        2016-09-07 20:03:19 +0000  9700) 
d3cb356d14680 (Douglas Gregor           2009-07-07 23:38:56 +0000  9701)   // C++ [over.match.best]p1:
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  9702)   //   A viable function F1 is defined to be a better function than another
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  9703)   //   viable function F2 if for all arguments i, ICSi(F1) is not a worse
d3cb356d14680 (Douglas Gregor           2009-07-07 23:38:56 +0000  9704)   //   conversion sequence than ICSi(F2), and then...
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  9705)   bool HasWorseConversion = false;
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000  9706)   for (unsigned ArgIdx = StartArg; ArgIdx < NumArgs; ++ArgIdx) {
0f59cb38e7f31 (Richard Smith            2015-12-18 21:45:41 +0000  9707)     switch (CompareImplicitConversionSequences(S, Loc,
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  9708)                                                Cand1.Conversions[ArgIdx],
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  9709)                                                Cand2.Conversions[ArgIdx])) {
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  9710)     case ImplicitConversionSequence::Better:
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  9711)       // Cand1 has a better conversion sequence.
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  9712)       HasBetterConversion = true;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  9713)       break;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  9714) 
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  9715)     case ImplicitConversionSequence::Worse:
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9716)       if (Cand1.Function && Cand2.Function &&
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9717)           Cand1.isReversed() != Cand2.isReversed() &&
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9718)           haveSameParameterTypes(S.Context, Cand1.Function, Cand2.Function,
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9719)                                  NumArgs)) {
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  9720)         // Work around large-scale breakage caused by considering reversed
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  9721)         // forms of operator== in C++20:
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  9722)         //
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9723)         // When comparing a function against a reversed function with the same
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9724)         // parameter types, if we have a better conversion for one argument and
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9725)         // a worse conversion for the other, the implicit conversion sequences
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9726)         // are treated as being equally good.
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  9727)         //
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9728)         // This prevents a comparison function from being considered ambiguous
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9729)         // with a reversed form that is written in the same way.
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  9730)         //
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  9731)         // We diagnose this as an extension from CreateOverloadedBinOp.
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  9732)         HasWorseConversion = true;
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  9733)         break;
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  9734)       }
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  9735) 
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  9736)       // Cand1 can't be better than Cand2.
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  9737)       return false;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  9738) 
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  9739)     case ImplicitConversionSequence::Indistinguishable:
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  9740)       // Do nothing.
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  9741)       break;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  9742)     }
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  9743)   }
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  9744) 
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  9745)   //    -- for some argument j, ICSj(F1) is a better conversion sequence than
d3cb356d14680 (Douglas Gregor           2009-07-07 23:38:56 +0000  9746)   //       ICSj(F2), or, if not that,
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700  9747)   if (HasBetterConversion && !HasWorseConversion)
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  9748)     return true;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  9749) 
a1f013e8edb82 (Douglas Gregor           2008-11-07 22:36:19 +0000  9750)   //   -- the context is an initialization by user-defined conversion
a1f013e8edb82 (Douglas Gregor           2008-11-07 22:36:19 +0000  9751)   //      (see 8.5, 13.3.1.5) and the standard conversion sequence
a1f013e8edb82 (Douglas Gregor           2008-11-07 22:36:19 +0000  9752)   //      from the return type of F1 to the destination type (i.e.,
a1f013e8edb82 (Douglas Gregor           2008-11-07 22:36:19 +0000  9753)   //      the type of the entity being initialized) is a better
a1f013e8edb82 (Douglas Gregor           2008-11-07 22:36:19 +0000  9754)   //      conversion sequence than the standard conversion sequence
a1f013e8edb82 (Douglas Gregor           2008-11-07 22:36:19 +0000  9755)   //      from the return type of F2 to the destination type.
67ef14fe486e1 (Richard Smith            2017-09-26 18:37:55 +0000  9756)   if (Kind == OverloadCandidateSet::CSK_InitByUserDefinedConversion &&
67ef14fe486e1 (Richard Smith            2017-09-26 18:37:55 +0000  9757)       Cand1.Function && Cand2.Function &&
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000  9758)       isa<CXXConversionDecl>(Cand1.Function) &&
a1f013e8edb82 (Douglas Gregor           2008-11-07 22:36:19 +0000  9759)       isa<CXXConversionDecl>(Cand2.Function)) {
2837aa2932710 (Douglas Gregor           2012-02-22 17:32:19 +0000  9760)     // First check whether we prefer one of the conversion functions over the
2837aa2932710 (Douglas Gregor           2012-02-22 17:32:19 +0000  9761)     // other. This only distinguishes the results in non-standard, extension
2837aa2932710 (Douglas Gregor           2012-02-22 17:32:19 +0000  9762)     // cases such as the conversion from a lambda closure type to a function
2837aa2932710 (Douglas Gregor           2012-02-22 17:32:19 +0000  9763)     // pointer or block.
ec2748a8ad627 (Richard Smith            2014-05-17 04:36:39 +0000  9764)     ImplicitConversionSequence::CompareKind Result =
ec2748a8ad627 (Richard Smith            2014-05-17 04:36:39 +0000  9765)         compareConversionFunctions(S, Cand1.Function, Cand2.Function);
ec2748a8ad627 (Richard Smith            2014-05-17 04:36:39 +0000  9766)     if (Result == ImplicitConversionSequence::Indistinguishable)
0f59cb38e7f31 (Richard Smith            2015-12-18 21:45:41 +0000  9767)       Result = CompareStandardConversionSequences(S, Loc,
ec2748a8ad627 (Richard Smith            2014-05-17 04:36:39 +0000  9768)                                                   Cand1.FinalConversion,
ec2748a8ad627 (Richard Smith            2014-05-17 04:36:39 +0000  9769)                                                   Cand2.FinalConversion);
a1f013e8edb82 (Douglas Gregor           2008-11-07 22:36:19 +0000  9770) 
ec2748a8ad627 (Richard Smith            2014-05-17 04:36:39 +0000  9771)     if (Result != ImplicitConversionSequence::Indistinguishable)
ec2748a8ad627 (Richard Smith            2014-05-17 04:36:39 +0000  9772)       return Result == ImplicitConversionSequence::Better;
6fdeaabda9f7d (Richard Smith            2014-05-17 01:58:45 +0000  9773) 
6fdeaabda9f7d (Richard Smith            2014-05-17 01:58:45 +0000  9774)     // FIXME: Compare kind of reference binding if conversion functions
6fdeaabda9f7d (Richard Smith            2014-05-17 01:58:45 +0000  9775)     // convert to a reference type used in direct reference binding, per
6fdeaabda9f7d (Richard Smith            2014-05-17 01:58:45 +0000  9776)     // C++14 [over.match.best]p1 section 2 bullet 3.
6fdeaabda9f7d (Richard Smith            2014-05-17 01:58:45 +0000  9777)   }
6fdeaabda9f7d (Richard Smith            2014-05-17 01:58:45 +0000  9778) 
5173136a96854 (Richard Smith            2017-11-01 01:37:11 +0000  9779)   // FIXME: Work around a defect in the C++17 guaranteed copy elision wording,
5173136a96854 (Richard Smith            2017-11-01 01:37:11 +0000  9780)   // as combined with the resolution to CWG issue 243.
5173136a96854 (Richard Smith            2017-11-01 01:37:11 +0000  9781)   //
5173136a96854 (Richard Smith            2017-11-01 01:37:11 +0000  9782)   // When the context is initialization by constructor ([over.match.ctor] or
5173136a96854 (Richard Smith            2017-11-01 01:37:11 +0000  9783)   // either phase of [over.match.list]), a constructor is preferred over
5173136a96854 (Richard Smith            2017-11-01 01:37:11 +0000  9784)   // a conversion function.
5173136a96854 (Richard Smith            2017-11-01 01:37:11 +0000  9785)   if (Kind == OverloadCandidateSet::CSK_InitByConstructor && NumArgs == 1 &&
5173136a96854 (Richard Smith            2017-11-01 01:37:11 +0000  9786)       Cand1.Function && Cand2.Function &&
5173136a96854 (Richard Smith            2017-11-01 01:37:11 +0000  9787)       isa<CXXConstructorDecl>(Cand1.Function) !=
5173136a96854 (Richard Smith            2017-11-01 01:37:11 +0000  9788)           isa<CXXConstructorDecl>(Cand2.Function))
5173136a96854 (Richard Smith            2017-11-01 01:37:11 +0000  9789)     return isa<CXXConstructorDecl>(Cand1.Function);
5173136a96854 (Richard Smith            2017-11-01 01:37:11 +0000  9790) 
6fdeaabda9f7d (Richard Smith            2014-05-17 01:58:45 +0000  9791)   //    -- F1 is a non-template function and F2 is a function template
6fdeaabda9f7d (Richard Smith            2014-05-17 01:58:45 +0000  9792)   //       specialization, or, if not that,
6fdeaabda9f7d (Richard Smith            2014-05-17 01:58:45 +0000  9793)   bool Cand1IsSpecialization = Cand1.Function &&
6fdeaabda9f7d (Richard Smith            2014-05-17 01:58:45 +0000  9794)                                Cand1.Function->getPrimaryTemplate();
6fdeaabda9f7d (Richard Smith            2014-05-17 01:58:45 +0000  9795)   bool Cand2IsSpecialization = Cand2.Function &&
6fdeaabda9f7d (Richard Smith            2014-05-17 01:58:45 +0000  9796)                                Cand2.Function->getPrimaryTemplate();
6fdeaabda9f7d (Richard Smith            2014-05-17 01:58:45 +0000  9797)   if (Cand1IsSpecialization != Cand2IsSpecialization)
6fdeaabda9f7d (Richard Smith            2014-05-17 01:58:45 +0000  9798)     return Cand2IsSpecialization;
6fdeaabda9f7d (Richard Smith            2014-05-17 01:58:45 +0000  9799) 
6fdeaabda9f7d (Richard Smith            2014-05-17 01:58:45 +0000  9800)   //   -- F1 and F2 are function template specializations, and the function
6fdeaabda9f7d (Richard Smith            2014-05-17 01:58:45 +0000  9801)   //      template for F1 is more specialized than the template for F2
6fdeaabda9f7d (Richard Smith            2014-05-17 01:58:45 +0000  9802)   //      according to the partial ordering rules described in 14.5.5.2, or,
6fdeaabda9f7d (Richard Smith            2014-05-17 01:58:45 +0000  9803)   //      if not that,
6fdeaabda9f7d (Richard Smith            2014-05-17 01:58:45 +0000  9804)   if (Cand1IsSpecialization && Cand2IsSpecialization) {
fcea7fbdba1bd (Richard Smith            2020-02-10 06:05:59 -0800  9805)     if (FunctionTemplateDecl *BetterTemplate = S.getMoreSpecializedTemplate(
fcea7fbdba1bd (Richard Smith            2020-02-10 06:05:59 -0800  9806)             Cand1.Function->getPrimaryTemplate(),
fcea7fbdba1bd (Richard Smith            2020-02-10 06:05:59 -0800  9807)             Cand2.Function->getPrimaryTemplate(), Loc,
fcea7fbdba1bd (Richard Smith            2020-02-10 06:05:59 -0800  9808)             isa<CXXConversionDecl>(Cand1.Function) ? TPOC_Conversion
fcea7fbdba1bd (Richard Smith            2020-02-10 06:05:59 -0800  9809)                                                    : TPOC_Call,
fcea7fbdba1bd (Richard Smith            2020-02-10 06:05:59 -0800  9810)             Cand1.ExplicitCallArguments, Cand2.ExplicitCallArguments,
fcea7fbdba1bd (Richard Smith            2020-02-10 06:05:59 -0800  9811)             Cand1.isReversed() ^ Cand2.isReversed()))
6fdeaabda9f7d (Richard Smith            2014-05-17 01:58:45 +0000  9812)       return BetterTemplate == Cand1.Function->getPrimaryTemplate();
a1f013e8edb82 (Douglas Gregor           2008-11-07 22:36:19 +0000  9813)   }
a1f013e8edb82 (Douglas Gregor           2008-11-07 22:36:19 +0000  9814) 
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  9815)   //   - F1 and F2 are non-template functions with the same
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  9816)   //      parameter-type-lists, and F1 is more constrained than F2 [...],
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  9817)   if (Cand1.Function && Cand2.Function && !Cand1IsSpecialization &&
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  9818)       !Cand2IsSpecialization && Cand1.Function->hasPrototype() &&
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  9819)       Cand2.Function->hasPrototype()) {
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  9820)     auto *PT1 = cast<FunctionProtoType>(Cand1.Function->getFunctionType());
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  9821)     auto *PT2 = cast<FunctionProtoType>(Cand2.Function->getFunctionType());
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  9822)     if (PT1->getNumParams() == PT2->getNumParams() &&
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  9823)         PT1->isVariadic() == PT2->isVariadic() &&
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  9824)         S.FunctionParamTypesAreEqual(PT1, PT2)) {
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  9825)       Expr *RC1 = Cand1.Function->getTrailingRequiresClause();
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  9826)       Expr *RC2 = Cand2.Function->getTrailingRequiresClause();
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  9827)       if (RC1 && RC2) {
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  9828)         bool AtLeastAsConstrained1, AtLeastAsConstrained2;
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  9829)         if (S.IsAtLeastAsConstrained(Cand1.Function, {RC1}, Cand2.Function,
cfacf9ae20b8c (Richard Smith            2020-02-04 12:20:34 -0800  9830)                                      {RC2}, AtLeastAsConstrained1) ||
cfacf9ae20b8c (Richard Smith            2020-02-04 12:20:34 -0800  9831)             S.IsAtLeastAsConstrained(Cand2.Function, {RC2}, Cand1.Function,
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  9832)                                      {RC1}, AtLeastAsConstrained2))
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  9833)           return false;
cfacf9ae20b8c (Richard Smith            2020-02-04 12:20:34 -0800  9834)         if (AtLeastAsConstrained1 != AtLeastAsConstrained2)
cfacf9ae20b8c (Richard Smith            2020-02-04 12:20:34 -0800  9835)           return AtLeastAsConstrained1;
cfacf9ae20b8c (Richard Smith            2020-02-04 12:20:34 -0800  9836)       } else if (RC1 || RC2) {
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  9837)         return RC1 != nullptr;
cfacf9ae20b8c (Richard Smith            2020-02-04 12:20:34 -0800  9838)       }
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  9839)     }
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  9840)   }
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200  9841) 
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  9842)   //   -- F1 is a constructor for a class D, F2 is a constructor for a base
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  9843)   //      class B of D, and for all arguments the corresponding parameters of
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  9844)   //      F1 and F2 have the same type.
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  9845)   // FIXME: Implement the "all parameters have the same type" check.
5179eb78210a2 (Richard Smith            2016-06-28 19:03:57 +0000  9846)   bool Cand1IsInherited =
5179eb78210a2 (Richard Smith            2016-06-28 19:03:57 +0000  9847)       dyn_cast_or_null<ConstructorUsingShadowDecl>(Cand1.FoundDecl.getDecl());
5179eb78210a2 (Richard Smith            2016-06-28 19:03:57 +0000  9848)   bool Cand2IsInherited =
5179eb78210a2 (Richard Smith            2016-06-28 19:03:57 +0000  9849)       dyn_cast_or_null<ConstructorUsingShadowDecl>(Cand2.FoundDecl.getDecl());
5179eb78210a2 (Richard Smith            2016-06-28 19:03:57 +0000  9850)   if (Cand1IsInherited != Cand2IsInherited)
5179eb78210a2 (Richard Smith            2016-06-28 19:03:57 +0000  9851)     return Cand2IsInherited;
5179eb78210a2 (Richard Smith            2016-06-28 19:03:57 +0000  9852)   else if (Cand1IsInherited) {
5179eb78210a2 (Richard Smith            2016-06-28 19:03:57 +0000  9853)     assert(Cand2IsInherited);
5179eb78210a2 (Richard Smith            2016-06-28 19:03:57 +0000  9854)     auto *Cand1Class = cast<CXXRecordDecl>(Cand1.Function->getDeclContext());
5179eb78210a2 (Richard Smith            2016-06-28 19:03:57 +0000  9855)     auto *Cand2Class = cast<CXXRecordDecl>(Cand2.Function->getDeclContext());
5179eb78210a2 (Richard Smith            2016-06-28 19:03:57 +0000  9856)     if (Cand1Class->isDerivedFrom(Cand2Class))
5179eb78210a2 (Richard Smith            2016-06-28 19:03:57 +0000  9857)       return true;
5179eb78210a2 (Richard Smith            2016-06-28 19:03:57 +0000  9858)     if (Cand2Class->isDerivedFrom(Cand1Class))
5179eb78210a2 (Richard Smith            2016-06-28 19:03:57 +0000  9859)       return false;
5179eb78210a2 (Richard Smith            2016-06-28 19:03:57 +0000  9860)     // Inherited from sibling base classes: still ambiguous.
5179eb78210a2 (Richard Smith            2016-06-28 19:03:57 +0000  9861)   }
5179eb78210a2 (Richard Smith            2016-06-28 19:03:57 +0000  9862) 
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  9863)   //   -- F2 is a rewritten candidate (12.4.1.2) and F1 is not
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  9864)   //   -- F1 and F2 are rewritten candidates, and F2 is a synthesized candidate
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  9865)   //      with reversed order of parameters and F1 is not
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  9866)   //
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  9867)   // We rank reversed + different operator as worse than just reversed, but
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  9868)   // that comparison can never happen, because we only consider reversing for
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  9869)   // the maximally-rewritten operator (== or <=>).
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  9870)   if (Cand1.RewriteKind != Cand2.RewriteKind)
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  9871)     return Cand1.RewriteKind < Cand2.RewriteKind;
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000  9872) 
81b756e6a3e49 (Faisal Vali              2017-10-22 14:45:08 +0000  9873)   // Check C++17 tie-breakers for deduction guides.
81b756e6a3e49 (Faisal Vali              2017-10-22 14:45:08 +0000  9874)   {
81b756e6a3e49 (Faisal Vali              2017-10-22 14:45:08 +0000  9875)     auto *Guide1 = dyn_cast_or_null<CXXDeductionGuideDecl>(Cand1.Function);
81b756e6a3e49 (Faisal Vali              2017-10-22 14:45:08 +0000  9876)     auto *Guide2 = dyn_cast_or_null<CXXDeductionGuideDecl>(Cand2.Function);
81b756e6a3e49 (Faisal Vali              2017-10-22 14:45:08 +0000  9877)     if (Guide1 && Guide2) {
81b756e6a3e49 (Faisal Vali              2017-10-22 14:45:08 +0000  9878)       //  -- F1 is generated from a deduction-guide and F2 is not
81b756e6a3e49 (Faisal Vali              2017-10-22 14:45:08 +0000  9879)       if (Guide1->isImplicit() != Guide2->isImplicit())
81b756e6a3e49 (Faisal Vali              2017-10-22 14:45:08 +0000  9880)         return Guide2->isImplicit();
81b756e6a3e49 (Faisal Vali              2017-10-22 14:45:08 +0000  9881) 
81b756e6a3e49 (Faisal Vali              2017-10-22 14:45:08 +0000  9882)       //  -- F1 is the copy deduction candidate(16.3.1.8) and F2 is not
81b756e6a3e49 (Faisal Vali              2017-10-22 14:45:08 +0000  9883)       if (Guide1->isCopyDeductionCandidate())
81b756e6a3e49 (Faisal Vali              2017-10-22 14:45:08 +0000  9884)         return true;
81b756e6a3e49 (Faisal Vali              2017-10-22 14:45:08 +0000  9885)     }
81b756e6a3e49 (Faisal Vali              2017-10-22 14:45:08 +0000  9886)   }
67ef14fe486e1 (Richard Smith            2017-09-26 18:37:55 +0000  9887) 
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  9888)   // Check for enable_if value-based overload resolution.
3dc16691339e0 (George Burgess IV        2016-05-10 01:59:34 +0000  9889)   if (Cand1.Function && Cand2.Function) {
3dc16691339e0 (George Burgess IV        2016-05-10 01:59:34 +0000  9890)     Comparison Cmp = compareEnableIfAttrs(S, Cand1.Function, Cand2.Function);
3dc16691339e0 (George Burgess IV        2016-05-10 01:59:34 +0000  9891)     if (Cmp != Comparison::Equal)
3dc16691339e0 (George Burgess IV        2016-05-10 01:59:34 +0000  9892)       return Cmp == Comparison::Better;
3dc16691339e0 (George Burgess IV        2016-05-10 01:59:34 +0000  9893)   }
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000  9894) 
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000  9895)   bool HasPS1 = Cand1.Function != nullptr &&
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000  9896)                 functionHasPassObjectSizeParams(Cand1.Function);
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000  9897)   bool HasPS2 = Cand2.Function != nullptr &&
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000  9898)                 functionHasPassObjectSizeParams(Cand2.Function);
3efe00206f0f4 (Erich Keane              2018-07-20 14:13:28 +0000  9899)   if (HasPS1 != HasPS2 && HasPS1)
3efe00206f0f4 (Erich Keane              2018-07-20 14:13:28 +0000  9900)     return true;
3efe00206f0f4 (Erich Keane              2018-07-20 14:13:28 +0000  9901) 
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9902)   auto MV = isBetterMultiversionCandidate(Cand1, Cand2);
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9903)   if (MV == Comparison::Better)
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9904)     return true;
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9905)   if (MV == Comparison::Worse)
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9906)     return false;
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9907) 
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9908)   // If other rules cannot determine which is better, CUDA preference is used
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9909)   // to determine which is better.
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9910)   if (S.getLangOpts().CUDA && Cand1.Function && Cand2.Function) {
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9911)     FunctionDecl *Caller = dyn_cast<FunctionDecl>(S.CurContext);
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9912)     return S.IdentifyCUDAPreference(Caller, Cand1.Function) >
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9913)            S.IdentifyCUDAPreference(Caller, Cand2.Function);
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9914)   }
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9915) 
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500  9916)   return false;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  9917) }
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000  9918) 
2dbe4043e8f54 (Richard Smith            2015-11-04 19:26:32 +0000  9919) /// Determine whether two declarations are "equivalent" for the purposes of
26210db67f218 (Richard Smith            2015-11-13 03:52:13 +0000  9920) /// name lookup and overload resolution. This applies when the same internal/no
26210db67f218 (Richard Smith            2015-11-13 03:52:13 +0000  9921) /// linkage entity is defined by two modules (probably by textually including
2dbe4043e8f54 (Richard Smith            2015-11-04 19:26:32 +0000  9922) /// the same header). In such a case, we don't consider the declarations to
2dbe4043e8f54 (Richard Smith            2015-11-04 19:26:32 +0000  9923) /// declare the same entity, but we also don't want lookups with both
2dbe4043e8f54 (Richard Smith            2015-11-04 19:26:32 +0000  9924) /// declarations visible to be ambiguous in some cases (this happens when using
2dbe4043e8f54 (Richard Smith            2015-11-04 19:26:32 +0000  9925) /// a modularized libstdc++).
2dbe4043e8f54 (Richard Smith            2015-11-04 19:26:32 +0000  9926) bool Sema::isEquivalentInternalLinkageDeclaration(const NamedDecl *A,
2dbe4043e8f54 (Richard Smith            2015-11-04 19:26:32 +0000  9927)                                                   const NamedDecl *B) {
26210db67f218 (Richard Smith            2015-11-13 03:52:13 +0000  9928)   auto *VA = dyn_cast_or_null<ValueDecl>(A);
26210db67f218 (Richard Smith            2015-11-13 03:52:13 +0000  9929)   auto *VB = dyn_cast_or_null<ValueDecl>(B);
26210db67f218 (Richard Smith            2015-11-13 03:52:13 +0000  9930)   if (!VA || !VB)
26210db67f218 (Richard Smith            2015-11-13 03:52:13 +0000  9931)     return false;
26210db67f218 (Richard Smith            2015-11-13 03:52:13 +0000  9932) 
26210db67f218 (Richard Smith            2015-11-13 03:52:13 +0000  9933)   // The declarations must be declaring the same name as an internal linkage
26210db67f218 (Richard Smith            2015-11-13 03:52:13 +0000  9934)   // entity in different modules.
26210db67f218 (Richard Smith            2015-11-13 03:52:13 +0000  9935)   if (!VA->getDeclContext()->getRedeclContext()->Equals(
26210db67f218 (Richard Smith            2015-11-13 03:52:13 +0000  9936)           VB->getDeclContext()->getRedeclContext()) ||
7af67259cdd66 (Simon Pilgrim            2020-01-13 14:28:49 +0000  9937)       getOwningModule(VA) == getOwningModule(VB) ||
26210db67f218 (Richard Smith            2015-11-13 03:52:13 +0000  9938)       VA->isExternallyVisible() || VB->isExternallyVisible())
26210db67f218 (Richard Smith            2015-11-13 03:52:13 +0000  9939)     return false;
26210db67f218 (Richard Smith            2015-11-13 03:52:13 +0000  9940) 
26210db67f218 (Richard Smith            2015-11-13 03:52:13 +0000  9941)   // Check that the declarations appear to be equivalent.
26210db67f218 (Richard Smith            2015-11-13 03:52:13 +0000  9942)   //
26210db67f218 (Richard Smith            2015-11-13 03:52:13 +0000  9943)   // FIXME: Checking the type isn't really enough to resolve the ambiguity.
26210db67f218 (Richard Smith            2015-11-13 03:52:13 +0000  9944)   // For constants and functions, we should check the initializer or body is
26210db67f218 (Richard Smith            2015-11-13 03:52:13 +0000  9945)   // the same. For non-constant variables, we shouldn't allow it at all.
26210db67f218 (Richard Smith            2015-11-13 03:52:13 +0000  9946)   if (Context.hasSameType(VA->getType(), VB->getType()))
26210db67f218 (Richard Smith            2015-11-13 03:52:13 +0000  9947)     return true;
26210db67f218 (Richard Smith            2015-11-13 03:52:13 +0000  9948) 
26210db67f218 (Richard Smith            2015-11-13 03:52:13 +0000  9949)   // Enum constants within unnamed enumerations will have different types, but
26210db67f218 (Richard Smith            2015-11-13 03:52:13 +0000  9950)   // may still be similar enough to be interchangeable for our purposes.
26210db67f218 (Richard Smith            2015-11-13 03:52:13 +0000  9951)   if (auto *EA = dyn_cast<EnumConstantDecl>(VA)) {
26210db67f218 (Richard Smith            2015-11-13 03:52:13 +0000  9952)     if (auto *EB = dyn_cast<EnumConstantDecl>(VB)) {
26210db67f218 (Richard Smith            2015-11-13 03:52:13 +0000  9953)       // Only handle anonymous enums. If the enumerations were named and
26210db67f218 (Richard Smith            2015-11-13 03:52:13 +0000  9954)       // equivalent, they would have been merged to the same type.
26210db67f218 (Richard Smith            2015-11-13 03:52:13 +0000  9955)       auto *EnumA = cast<EnumDecl>(EA->getDeclContext());
26210db67f218 (Richard Smith            2015-11-13 03:52:13 +0000  9956)       auto *EnumB = cast<EnumDecl>(EB->getDeclContext());
26210db67f218 (Richard Smith            2015-11-13 03:52:13 +0000  9957)       if (EnumA->hasNameForLinkage() || EnumB->hasNameForLinkage() ||
26210db67f218 (Richard Smith            2015-11-13 03:52:13 +0000  9958)           !Context.hasSameType(EnumA->getIntegerType(),
26210db67f218 (Richard Smith            2015-11-13 03:52:13 +0000  9959)                                EnumB->getIntegerType()))
26210db67f218 (Richard Smith            2015-11-13 03:52:13 +0000  9960)         return false;
26210db67f218 (Richard Smith            2015-11-13 03:52:13 +0000  9961)       // Allow this only if the value is the same for both enumerators.
26210db67f218 (Richard Smith            2015-11-13 03:52:13 +0000  9962)       return llvm::APSInt::isSameValue(EA->getInitVal(), EB->getInitVal());
26210db67f218 (Richard Smith            2015-11-13 03:52:13 +0000  9963)     }
26210db67f218 (Richard Smith            2015-11-13 03:52:13 +0000  9964)   }
26210db67f218 (Richard Smith            2015-11-13 03:52:13 +0000  9965) 
26210db67f218 (Richard Smith            2015-11-13 03:52:13 +0000  9966)   // Nothing else is sufficiently similar.
26210db67f218 (Richard Smith            2015-11-13 03:52:13 +0000  9967)   return false;
2dbe4043e8f54 (Richard Smith            2015-11-04 19:26:32 +0000  9968) }
2dbe4043e8f54 (Richard Smith            2015-11-04 19:26:32 +0000  9969) 
2dbe4043e8f54 (Richard Smith            2015-11-04 19:26:32 +0000  9970) void Sema::diagnoseEquivalentInternalLinkageDeclarations(
2dbe4043e8f54 (Richard Smith            2015-11-04 19:26:32 +0000  9971)     SourceLocation Loc, const NamedDecl *D, ArrayRef<const NamedDecl *> Equiv) {
feb0b4ec0a448 (Simon Pilgrim            2021-01-26 15:51:49 +0000  9972)   assert(D && "Unknown declaration");
2dbe4043e8f54 (Richard Smith            2015-11-04 19:26:32 +0000  9973)   Diag(Loc, diag::ext_equivalent_internal_linkage_decl_in_modules) << D;
2dbe4043e8f54 (Richard Smith            2015-11-04 19:26:32 +0000  9974) 
7af67259cdd66 (Simon Pilgrim            2020-01-13 14:28:49 +0000  9975)   Module *M = getOwningModule(D);
2dbe4043e8f54 (Richard Smith            2015-11-04 19:26:32 +0000  9976)   Diag(D->getLocation(), diag::note_equivalent_internal_linkage_decl)
2dbe4043e8f54 (Richard Smith            2015-11-04 19:26:32 +0000  9977)       << !M << (M ? M->getFullModuleName() : "");
2dbe4043e8f54 (Richard Smith            2015-11-04 19:26:32 +0000  9978) 
2dbe4043e8f54 (Richard Smith            2015-11-04 19:26:32 +0000  9979)   for (auto *E : Equiv) {
7af67259cdd66 (Simon Pilgrim            2020-01-13 14:28:49 +0000  9980)     Module *M = getOwningModule(E);
2dbe4043e8f54 (Richard Smith            2015-11-04 19:26:32 +0000  9981)     Diag(E->getLocation(), diag::note_equivalent_internal_linkage_decl)
2dbe4043e8f54 (Richard Smith            2015-11-04 19:26:32 +0000  9982)         << !M << (M ? M->getFullModuleName() : "");
2dbe4043e8f54 (Richard Smith            2015-11-04 19:26:32 +0000  9983)   }
896c66ecc64e9 (Richard Smith            2015-10-21 07:13:52 +0000  9984) }
896c66ecc64e9 (Richard Smith            2015-10-21 07:13:52 +0000  9985) 
9fc8faf9e6197 (Adrian Prantl            2018-05-09 01:00:01 +0000  9986) /// Computes the best viable function (C++ 13.3.3)
c9c02ed8f499f (Douglas Gregor           2009-06-19 23:52:42 +0000  9987) /// within an overload candidate set.
c9c02ed8f499f (Douglas Gregor           2009-06-19 23:52:42 +0000  9988) ///
ffad8b75e53ff (James Dennett            2012-06-22 08:10:18 +0000  9989) /// \param Loc The location of the function name (or operator symbol) for
c9c02ed8f499f (Douglas Gregor           2009-06-19 23:52:42 +0000  9990) /// which overload resolution occurs.
c9c02ed8f499f (Douglas Gregor           2009-06-19 23:52:42 +0000  9991) ///
ffad8b75e53ff (James Dennett            2012-06-22 08:10:18 +0000  9992) /// \param Best If overload resolution was successful or found a deleted
ffad8b75e53ff (James Dennett            2012-06-22 08:10:18 +0000  9993) /// function, \p Best points to the candidate function found.
c9c02ed8f499f (Douglas Gregor           2009-06-19 23:52:42 +0000  9994) ///
c9c02ed8f499f (Douglas Gregor           2009-06-19 23:52:42 +0000  9995) /// \returns The result of overload resolution.
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  9996) OverloadingResult
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000  9997) OverloadCandidateSet::BestViableFunction(Sema &S, SourceLocation Loc,
67ef14fe486e1 (Richard Smith            2017-09-26 18:37:55 +0000  9998)                                          iterator &Best) {
186091094ae7c (Artem Belevich           2016-02-12 18:29:18 +0000  9999)   llvm::SmallVector<OverloadCandidate *, 16> Candidates;
186091094ae7c (Artem Belevich           2016-02-12 18:29:18 +0000 10000)   std::transform(begin(), end(), std::back_inserter(Candidates),
186091094ae7c (Artem Belevich           2016-02-12 18:29:18 +0000 10001)                  [](OverloadCandidate &Cand) { return &Cand; });
186091094ae7c (Artem Belevich           2016-02-12 18:29:18 +0000 10002) 
dfc0d9475556c (Fangrui Song             2020-06-10 17:40:04 -0700 10003)   // [CUDA] HD->H or HD->D calls are technically not allowed by CUDA but
dfc0d9475556c (Fangrui Song             2020-06-10 17:40:04 -0700 10004)   // are accepted by both clang and NVCC. However, during a particular
dfc0d9475556c (Fangrui Song             2020-06-10 17:40:04 -0700 10005)   // compilation mode only one call variant is viable. We need to
dfc0d9475556c (Fangrui Song             2020-06-10 17:40:04 -0700 10006)   // exclude non-viable overload candidates from consideration based
dfc0d9475556c (Fangrui Song             2020-06-10 17:40:04 -0700 10007)   // only on their host/device attributes. Specifically, if one
dfc0d9475556c (Fangrui Song             2020-06-10 17:40:04 -0700 10008)   // candidate call is WrongSide and the other is SameSide, we ignore
dfc0d9475556c (Fangrui Song             2020-06-10 17:40:04 -0700 10009)   // the WrongSide candidate.
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500 10010)   // We only need to remove wrong-sided candidates here if
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500 10011)   // -fgpu-exclude-wrong-side-overloads is off. When
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500 10012)   // -fgpu-exclude-wrong-side-overloads is on, all candidates are compared
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500 10013)   // uniformly in isBetterOverloadCandidate.
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500 10014)   if (S.getLangOpts().CUDA && !S.getLangOpts().GPUExcludeWrongSideOverloads) {
dfc0d9475556c (Fangrui Song             2020-06-10 17:40:04 -0700 10015)     const FunctionDecl *Caller = dyn_cast<FunctionDecl>(S.CurContext);
dfc0d9475556c (Fangrui Song             2020-06-10 17:40:04 -0700 10016)     bool ContainsSameSideCandidate =
dfc0d9475556c (Fangrui Song             2020-06-10 17:40:04 -0700 10017)         llvm::any_of(Candidates, [&](OverloadCandidate *Cand) {
dfc0d9475556c (Fangrui Song             2020-06-10 17:40:04 -0700 10018)           // Check viable function only.
dfc0d9475556c (Fangrui Song             2020-06-10 17:40:04 -0700 10019)           return Cand->Viable && Cand->Function &&
dfc0d9475556c (Fangrui Song             2020-06-10 17:40:04 -0700 10020)                  S.IdentifyCUDAPreference(Caller, Cand->Function) ==
dfc0d9475556c (Fangrui Song             2020-06-10 17:40:04 -0700 10021)                      Sema::CFP_SameSide;
dfc0d9475556c (Fangrui Song             2020-06-10 17:40:04 -0700 10022)         });
dfc0d9475556c (Fangrui Song             2020-06-10 17:40:04 -0700 10023)     if (ContainsSameSideCandidate) {
dfc0d9475556c (Fangrui Song             2020-06-10 17:40:04 -0700 10024)       auto IsWrongSideCandidate = [&](OverloadCandidate *Cand) {
dfc0d9475556c (Fangrui Song             2020-06-10 17:40:04 -0700 10025)         // Check viable function only to avoid unnecessary data copying/moving.
dfc0d9475556c (Fangrui Song             2020-06-10 17:40:04 -0700 10026)         return Cand->Viable && Cand->Function &&
dfc0d9475556c (Fangrui Song             2020-06-10 17:40:04 -0700 10027)                S.IdentifyCUDAPreference(Caller, Cand->Function) ==
dfc0d9475556c (Fangrui Song             2020-06-10 17:40:04 -0700 10028)                    Sema::CFP_WrongSide;
dfc0d9475556c (Fangrui Song             2020-06-10 17:40:04 -0700 10029)       };
dfc0d9475556c (Fangrui Song             2020-06-10 17:40:04 -0700 10030)       llvm::erase_if(Candidates, IsWrongSideCandidate);
dfc0d9475556c (Fangrui Song             2020-06-10 17:40:04 -0700 10031)     }
dfc0d9475556c (Fangrui Song             2020-06-10 17:40:04 -0700 10032)   }
dfc0d9475556c (Fangrui Song             2020-06-10 17:40:04 -0700 10033) 
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000 10034)   // Find the best viable function.
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000 10035)   Best = end();
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 10036)   for (auto *Cand : Candidates) {
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 10037)     Cand->Best = false;
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000 10038)     if (Cand->Viable)
67ef14fe486e1 (Richard Smith            2017-09-26 18:37:55 +0000 10039)       if (Best == end() ||
67ef14fe486e1 (Richard Smith            2017-09-26 18:37:55 +0000 10040)           isBetterOverloadCandidate(S, *Cand, *Best, Loc, Kind))
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000 10041)         Best = Cand;
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 10042)   }
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000 10043) 
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000 10044)   // If we didn't find any viable functions, abort.
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000 10045)   if (Best == end())
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000 10046)     return OR_No_Viable_Function;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000 10047) 
2dbe4043e8f54 (Richard Smith            2015-11-04 19:26:32 +0000 10048)   llvm::SmallVector<const NamedDecl *, 4> EquivalentCands;
896c66ecc64e9 (Richard Smith            2015-10-21 07:13:52 +0000 10049) 
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 10050)   llvm::SmallVector<OverloadCandidate*, 4> PendingBest;
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 10051)   PendingBest.push_back(&*Best);
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 10052)   Best->Best = true;
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 10053) 
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000 10054)   // Make sure that this function is better than every other viable
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000 10055)   // function. If not, we have an ambiguity.
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 10056)   while (!PendingBest.empty()) {
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 10057)     auto *Curr = PendingBest.pop_back_val();
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 10058)     for (auto *Cand : Candidates) {
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 10059)       if (Cand->Viable && !Cand->Best &&
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 10060)           !isBetterOverloadCandidate(S, *Curr, *Cand, Loc, Kind)) {
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 10061)         PendingBest.push_back(Cand);
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 10062)         Cand->Best = true;
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 10063) 
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 10064)         if (S.isEquivalentInternalLinkageDeclaration(Cand->Function,
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 10065)                                                      Curr->Function))
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 10066)           EquivalentCands.push_back(Cand->Function);
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 10067)         else
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 10068)           Best = end();
896c66ecc64e9 (Richard Smith            2015-10-21 07:13:52 +0000 10069)       }
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000 10070)     }
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000 10071)   }
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000 10072) 
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 10073)   // If we found more than one best candidate, this is ambiguous.
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 10074)   if (Best == end())
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 10075)     return OR_Ambiguous;
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 10076) 
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000 10077)   // Best is the best viable function.
13ee62f7d7eed (Erik Pilkington          2019-03-20 19:26:33 +0000 10078)   if (Best->Function && Best->Function->isDeleted())
171c45ab0c19b (Douglas Gregor           2009-02-18 21:56:37 +0000 10079)     return OR_Deleted;
171c45ab0c19b (Douglas Gregor           2009-02-18 21:56:37 +0000 10080) 
2dbe4043e8f54 (Richard Smith            2015-11-04 19:26:32 +0000 10081)   if (!EquivalentCands.empty())
2dbe4043e8f54 (Richard Smith            2015-11-04 19:26:32 +0000 10082)     S.diagnoseEquivalentInternalLinkageDeclarations(Loc, Best->Function,
2dbe4043e8f54 (Richard Smith            2015-11-04 19:26:32 +0000 10083)                                                     EquivalentCands);
896c66ecc64e9 (Richard Smith            2015-10-21 07:13:52 +0000 10084) 
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000 10085)   return OR_Success;
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000 10086) }
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000 10087) 
53262c96d9a90 (John McCall              2010-01-12 02:15:36 +0000 10088) namespace {
fd0b2f8fe486f (John McCall              2010-01-06 09:43:14 +0000 10089) 
53262c96d9a90 (John McCall              2010-01-12 02:15:36 +0000 10090) enum OverloadCandidateKind {
53262c96d9a90 (John McCall              2010-01-12 02:15:36 +0000 10091)   oc_function,
53262c96d9a90 (John McCall              2010-01-12 02:15:36 +0000 10092)   oc_method,
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 10093)   oc_reversed_binary_operator,
53262c96d9a90 (John McCall              2010-01-12 02:15:36 +0000 10094)   oc_constructor,
53262c96d9a90 (John McCall              2010-01-12 02:15:36 +0000 10095)   oc_implicit_default_constructor,
53262c96d9a90 (John McCall              2010-01-12 02:15:36 +0000 10096)   oc_implicit_copy_constructor,
119c10ef231ee (Alexis Hunt              2011-05-25 23:16:36 +0000 10097)   oc_implicit_move_constructor,
0890502f44a1f (Sebastian Redl           2011-02-05 19:23:19 +0000 10098)   oc_implicit_copy_assignment,
119c10ef231ee (Alexis Hunt              2011-05-25 23:16:36 +0000 10099)   oc_implicit_move_assignment,
bc24014b9765a (Richard Smith            2019-12-10 16:45:02 -0800 10100)   oc_implicit_equality_comparison,
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10101)   oc_inherited_constructor
53262c96d9a90 (John McCall              2010-01-12 02:15:36 +0000 10102) };
fd0b2f8fe486f (John McCall              2010-01-06 09:43:14 +0000 10103) 
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10104) enum OverloadCandidateSelect {
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10105)   ocs_non_template,
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10106)   ocs_template,
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10107)   ocs_described_template,
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10108) };
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10109) 
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10110) static std::pair<OverloadCandidateKind, OverloadCandidateSelect>
d66d37cbd96f3 (George Burgess IV        2016-10-28 21:42:06 +0000 10111) ClassifyOverloadCandidate(Sema &S, NamedDecl *Found, FunctionDecl *Fn,
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 10112)                           OverloadCandidateRewriteKind CRK,
d66d37cbd96f3 (George Burgess IV        2016-10-28 21:42:06 +0000 10113)                           std::string &Description) {
e1ac8d1742209 (John McCall              2010-01-13 00:25:19 +0000 10114) 
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10115)   bool isTemplate = Fn->isTemplateDecl() || Found->isTemplateDecl();
e1ac8d1742209 (John McCall              2010-01-13 00:25:19 +0000 10116)   if (FunctionTemplateDecl *FunTmpl = Fn->getPrimaryTemplate()) {
e1ac8d1742209 (John McCall              2010-01-13 00:25:19 +0000 10117)     isTemplate = true;
e1ac8d1742209 (John McCall              2010-01-13 00:25:19 +0000 10118)     Description = S.getTemplateArgumentBindingsText(
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10119)         FunTmpl->getTemplateParameters(), *Fn->getTemplateSpecializationArgs());
e1ac8d1742209 (John McCall              2010-01-13 00:25:19 +0000 10120)   }
fd0b2f8fe486f (John McCall              2010-01-06 09:43:14 +0000 10121) 
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10122)   OverloadCandidateSelect Select = [&]() {
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10123)     if (!Description.empty())
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10124)       return ocs_described_template;
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10125)     return isTemplate ? ocs_template : ocs_non_template;
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10126)   }();
0890502f44a1f (Sebastian Redl           2011-02-05 19:23:19 +0000 10127) 
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10128)   OverloadCandidateKind Kind = [&]() {
bc24014b9765a (Richard Smith            2019-12-10 16:45:02 -0800 10129)     if (Fn->isImplicit() && Fn->getOverloadedOperator() == OO_EqualEqual)
bc24014b9765a (Richard Smith            2019-12-10 16:45:02 -0800 10130)       return oc_implicit_equality_comparison;
bc24014b9765a (Richard Smith            2019-12-10 16:45:02 -0800 10131) 
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 10132)     if (CRK & CRK_Reversed)
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 10133)       return oc_reversed_binary_operator;
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 10134) 
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10135)     if (CXXConstructorDecl *Ctor = dyn_cast<CXXConstructorDecl>(Fn)) {
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10136)       if (!Ctor->isImplicit()) {
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10137)         if (isa<ConstructorUsingShadowDecl>(Found))
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10138)           return oc_inherited_constructor;
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10139)         else
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10140)           return oc_constructor;
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10141)       }
119c10ef231ee (Alexis Hunt              2011-05-25 23:16:36 +0000 10142) 
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10143)       if (Ctor->isDefaultConstructor())
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10144)         return oc_implicit_default_constructor;
119c10ef231ee (Alexis Hunt              2011-05-25 23:16:36 +0000 10145) 
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10146)       if (Ctor->isMoveConstructor())
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10147)         return oc_implicit_move_constructor;
fd0b2f8fe486f (John McCall              2010-01-06 09:43:14 +0000 10148) 
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10149)       assert(Ctor->isCopyConstructor() &&
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10150)              "unexpected sort of implicit constructor");
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10151)       return oc_implicit_copy_constructor;
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10152)     }
fd0b2f8fe486f (John McCall              2010-01-06 09:43:14 +0000 10153) 
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10154)     if (CXXMethodDecl *Meth = dyn_cast<CXXMethodDecl>(Fn)) {
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10155)       // This actually gets spelled 'candidate function' for now, but
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10156)       // it doesn't hurt to split it out.
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10157)       if (!Meth->isImplicit())
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10158)         return oc_method;
119c10ef231ee (Alexis Hunt              2011-05-25 23:16:36 +0000 10159) 
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10160)       if (Meth->isMoveAssignmentOperator())
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10161)         return oc_implicit_move_assignment;
12695101ec453 (Douglas Gregor           2012-02-10 08:36:38 +0000 10162) 
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10163)       if (Meth->isCopyAssignmentOperator())
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10164)         return oc_implicit_copy_assignment;
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10165) 
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10166)       assert(isa<CXXConversionDecl>(Meth) && "expected conversion");
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10167)       return oc_method;
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10168)     }
53262c96d9a90 (John McCall              2010-01-12 02:15:36 +0000 10169) 
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10170)     return oc_function;
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10171)   }();
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10172) 
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10173)   return std::make_pair(Kind, Select);
53262c96d9a90 (John McCall              2010-01-12 02:15:36 +0000 10174) }
53262c96d9a90 (John McCall              2010-01-12 02:15:36 +0000 10175) 
5179eb78210a2 (Richard Smith            2016-06-28 19:03:57 +0000 10176) void MaybeEmitInheritedConstructorNote(Sema &S, Decl *FoundDecl) {
5179eb78210a2 (Richard Smith            2016-06-28 19:03:57 +0000 10177)   // FIXME: It'd be nice to only emit a note once per using-decl per overload
5179eb78210a2 (Richard Smith            2016-06-28 19:03:57 +0000 10178)   // set.
5179eb78210a2 (Richard Smith            2016-06-28 19:03:57 +0000 10179)   if (auto *Shadow = dyn_cast<ConstructorUsingShadowDecl>(FoundDecl))
5179eb78210a2 (Richard Smith            2016-06-28 19:03:57 +0000 10180)     S.Diag(FoundDecl->getLocation(),
5179eb78210a2 (Richard Smith            2016-06-28 19:03:57 +0000 10181)            diag::note_ovl_candidate_inherited_constructor)
5179eb78210a2 (Richard Smith            2016-06-28 19:03:57 +0000 10182)       << Shadow->getNominatedBaseClass();
0890502f44a1f (Sebastian Redl           2011-02-05 19:23:19 +0000 10183) }
0890502f44a1f (Sebastian Redl           2011-02-05 19:23:19 +0000 10184) 
53262c96d9a90 (John McCall              2010-01-12 02:15:36 +0000 10185) } // end anonymous namespace
53262c96d9a90 (John McCall              2010-01-12 02:15:36 +0000 10186) 
5f21c718007fd (George Burgess IV        2015-10-12 19:57:04 +0000 10187) static bool isFunctionAlwaysEnabled(const ASTContext &Ctx,
5f21c718007fd (George Burgess IV        2015-10-12 19:57:04 +0000 10188)                                     const FunctionDecl *FD) {
5f21c718007fd (George Burgess IV        2015-10-12 19:57:04 +0000 10189)   for (auto *EnableIf : FD->specific_attrs<EnableIfAttr>()) {
5f21c718007fd (George Burgess IV        2015-10-12 19:57:04 +0000 10190)     bool AlwaysTrue;
04323c24a1ac9 (Dmitri Gribenko          2019-05-17 17:16:53 +0000 10191)     if (EnableIf->getCond()->isValueDependent() ||
04323c24a1ac9 (Dmitri Gribenko          2019-05-17 17:16:53 +0000 10192)         !EnableIf->getCond()->EvaluateAsBooleanCondition(AlwaysTrue, Ctx))
5f21c718007fd (George Burgess IV        2015-10-12 19:57:04 +0000 10193)       return false;
5f21c718007fd (George Burgess IV        2015-10-12 19:57:04 +0000 10194)     if (!AlwaysTrue)
5f21c718007fd (George Burgess IV        2015-10-12 19:57:04 +0000 10195)       return false;
5f21c718007fd (George Burgess IV        2015-10-12 19:57:04 +0000 10196)   }
5f21c718007fd (George Burgess IV        2015-10-12 19:57:04 +0000 10197)   return true;
5f21c718007fd (George Burgess IV        2015-10-12 19:57:04 +0000 10198) }
5f21c718007fd (George Burgess IV        2015-10-12 19:57:04 +0000 10199) 
9fc8faf9e6197 (Adrian Prantl            2018-05-09 01:00:01 +0000 10200) /// Returns true if we can take the address of the function.
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10201) ///
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10202) /// \param Complain - If true, we'll emit a diagnostic
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10203) /// \param InOverloadResolution - For the purposes of emitting a diagnostic, are
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10204) ///   we in overload resolution?
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10205) /// \param Loc - The location of the statement we're complaining about. Ignored
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10206) ///   if we're not complaining, or if we're in overload resolution.
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10207) static bool checkAddressOfFunctionIsAvailable(Sema &S, const FunctionDecl *FD,
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10208)                                               bool Complain,
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10209)                                               bool InOverloadResolution,
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10210)                                               SourceLocation Loc) {
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10211)   if (!isFunctionAlwaysEnabled(S.Context, FD)) {
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10212)     if (Complain) {
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10213)       if (InOverloadResolution)
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000 10214)         S.Diag(FD->getBeginLoc(),
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10215)                diag::note_addrof_ovl_candidate_disabled_by_enable_if_attr);
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10216)       else
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10217)         S.Diag(Loc, diag::err_addrof_function_disabled_by_enable_if_attr) << FD;
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10218)     }
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10219)     return false;
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10220)   }
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10221) 
713562f54858f (Saar Raz                 2020-01-25 22:54:27 +0200 10222)   if (FD->getTrailingRequiresClause()) {
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10223)     ConstraintSatisfaction Satisfaction;
713562f54858f (Saar Raz                 2020-01-25 22:54:27 +0200 10224)     if (S.CheckFunctionConstraints(FD, Satisfaction, Loc))
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10225)       return false;
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10226)     if (!Satisfaction.IsSatisfied) {
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10227)       if (Complain) {
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10228)         if (InOverloadResolution)
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10229)           S.Diag(FD->getBeginLoc(),
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10230)                  diag::note_ovl_candidate_unsatisfied_constraints);
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10231)         else
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10232)           S.Diag(Loc, diag::err_addrof_function_constraints_not_satisfied)
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10233)               << FD;
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10234)         S.DiagnoseUnsatisfiedConstraint(Satisfaction);
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10235)       }
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10236)       return false;
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10237)     }
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10238)   }
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10239) 
21081364f84dc (George Burgess IV        2016-07-24 23:12:40 +0000 10240)   auto I = llvm::find_if(FD->parameters(), [](const ParmVarDecl *P) {
21081364f84dc (George Burgess IV        2016-07-24 23:12:40 +0000 10241)     return P->hasAttr<PassObjectSizeAttr>();
21081364f84dc (George Burgess IV        2016-07-24 23:12:40 +0000 10242)   });
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10243)   if (I == FD->param_end())
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10244)     return true;
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10245) 
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10246)   if (Complain) {
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10247)     // Add one to ParamNo because it's user-facing
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10248)     unsigned ParamNo = std::distance(FD->param_begin(), I) + 1;
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10249)     if (InOverloadResolution)
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10250)       S.Diag(FD->getLocation(),
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10251)              diag::note_ovl_candidate_has_pass_object_size_params)
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10252)           << ParamNo;
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10253)     else
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10254)       S.Diag(Loc, diag::err_address_of_function_with_pass_object_size_params)
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10255)           << FD << ParamNo;
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10256)   }
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10257)   return false;
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10258) }
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10259) 
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10260) static bool checkAddressOfCandidateIsAvailable(Sema &S,
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10261)                                                const FunctionDecl *FD) {
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10262)   return checkAddressOfFunctionIsAvailable(S, FD, /*Complain=*/true,
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10263)                                            /*InOverloadResolution=*/true,
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10264)                                            /*Loc=*/SourceLocation());
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10265) }
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10266) 
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10267) bool Sema::checkAddressOfFunctionIsAvailable(const FunctionDecl *Function,
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10268)                                              bool Complain,
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10269)                                              SourceLocation Loc) {
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10270)   return ::checkAddressOfFunctionIsAvailable(*this, Function, Complain,
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10271)                                              /*InOverloadResolution=*/false,
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10272)                                              Loc);
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10273) }
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10274) 
6976fef05b7e5 (Erich Keane              2020-11-16 15:26:22 -0800 10275) // Don't print candidates other than the one that matches the calling
6976fef05b7e5 (Erich Keane              2020-11-16 15:26:22 -0800 10276) // convention of the call operator, since that is guaranteed to exist.
6976fef05b7e5 (Erich Keane              2020-11-16 15:26:22 -0800 10277) static bool shouldSkipNotingLambdaConversionDecl(FunctionDecl *Fn) {
6976fef05b7e5 (Erich Keane              2020-11-16 15:26:22 -0800 10278)   const auto *ConvD = dyn_cast<CXXConversionDecl>(Fn);
6976fef05b7e5 (Erich Keane              2020-11-16 15:26:22 -0800 10279) 
6976fef05b7e5 (Erich Keane              2020-11-16 15:26:22 -0800 10280)   if (!ConvD)
6976fef05b7e5 (Erich Keane              2020-11-16 15:26:22 -0800 10281)     return false;
6976fef05b7e5 (Erich Keane              2020-11-16 15:26:22 -0800 10282)   const auto *RD = cast<CXXRecordDecl>(Fn->getParent());
6976fef05b7e5 (Erich Keane              2020-11-16 15:26:22 -0800 10283)   if (!RD->isLambda())
6976fef05b7e5 (Erich Keane              2020-11-16 15:26:22 -0800 10284)     return false;
6976fef05b7e5 (Erich Keane              2020-11-16 15:26:22 -0800 10285) 
6976fef05b7e5 (Erich Keane              2020-11-16 15:26:22 -0800 10286)   CXXMethodDecl *CallOp = RD->getLambdaCallOperator();
6976fef05b7e5 (Erich Keane              2020-11-16 15:26:22 -0800 10287)   CallingConv CallOpCC =
2901dc7575873 (Simon Pilgrim            2021-04-06 12:04:01 +0100 10288)       CallOp->getType()->castAs<FunctionType>()->getCallConv();
2901dc7575873 (Simon Pilgrim            2021-04-06 12:04:01 +0100 10289)   QualType ConvRTy = ConvD->getType()->castAs<FunctionType>()->getReturnType();
6976fef05b7e5 (Erich Keane              2020-11-16 15:26:22 -0800 10290)   CallingConv ConvToCC =
2901dc7575873 (Simon Pilgrim            2021-04-06 12:04:01 +0100 10291)       ConvRTy->getPointeeType()->castAs<FunctionType>()->getCallConv();
6976fef05b7e5 (Erich Keane              2020-11-16 15:26:22 -0800 10292) 
6976fef05b7e5 (Erich Keane              2020-11-16 15:26:22 -0800 10293)   return ConvToCC != CallOpCC;
6976fef05b7e5 (Erich Keane              2020-11-16 15:26:22 -0800 10294) }
6976fef05b7e5 (Erich Keane              2020-11-16 15:26:22 -0800 10295) 
53262c96d9a90 (John McCall              2010-01-12 02:15:36 +0000 10296) // Notes the location of an overload candidate.
c2bebe9acab26 (Richard Smith            2016-05-11 20:37:46 +0000 10297) void Sema::NoteOverloadCandidate(NamedDecl *Found, FunctionDecl *Fn,
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 10298)                                  OverloadCandidateRewriteKind RewriteKind,
c2bebe9acab26 (Richard Smith            2016-05-11 20:37:46 +0000 10299)                                  QualType DestType, bool TakingAddress) {
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10300)   if (TakingAddress && !checkAddressOfCandidateIsAvailable(*this, Fn))
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10301)     return;
3efe00206f0f4 (Erich Keane              2018-07-20 14:13:28 +0000 10302)   if (Fn->isMultiVersion() && Fn->hasAttr<TargetAttr>() &&
3efe00206f0f4 (Erich Keane              2018-07-20 14:13:28 +0000 10303)       !Fn->getAttr<TargetAttr>()->isDefaultVersion())
281d20b601c8a (Erich Keane              2018-01-08 21:34:17 +0000 10304)     return;
6976fef05b7e5 (Erich Keane              2020-11-16 15:26:22 -0800 10305)   if (shouldSkipNotingLambdaConversionDecl(Fn))
6976fef05b7e5 (Erich Keane              2020-11-16 15:26:22 -0800 10306)     return;
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10307) 
e1ac8d1742209 (John McCall              2010-01-13 00:25:19 +0000 10308)   std::string FnDesc;
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10309)   std::pair<OverloadCandidateKind, OverloadCandidateSelect> KSPair =
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 10310)       ClassifyOverloadCandidate(*this, Found, Fn, RewriteKind, FnDesc);
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000 10311)   PartialDiagnostic PD = PDiag(diag::note_ovl_candidate)
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10312)                          << (unsigned)KSPair.first << (unsigned)KSPair.second
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10313)                          << Fn << FnDesc;
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10314) 
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10315)   HandleFunctionTypeMismatch(PD, Fn->getType(), DestType);
caff247882fce (Richard Trieu            2011-11-23 22:32:32 +0000 10316)   Diag(Fn->getLocation(), PD);
5179eb78210a2 (Richard Smith            2016-06-28 19:03:57 +0000 10317)   MaybeEmitInheritedConstructorNote(*this, Found);
fd0b2f8fe486f (John McCall              2010-01-06 09:43:14 +0000 10318) }
fd0b2f8fe486f (John McCall              2010-01-06 09:43:14 +0000 10319) 
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10320) static void
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10321) MaybeDiagnoseAmbiguousConstraints(Sema &S, ArrayRef<OverloadCandidate> Cands) {
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10322)   // Perhaps the ambiguity was caused by two atomic constraints that are
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10323)   // 'identical' but not equivalent:
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10324)   //
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10325)   // void foo() requires (sizeof(T) > 4) { } // #1
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10326)   // void foo() requires (sizeof(T) > 4) && T::value { } // #2
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10327)   //
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10328)   // The 'sizeof(T) > 4' constraints are seemingly equivalent and should cause
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10329)   // #2 to subsume #1, but these constraint are not considered equivalent
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10330)   // according to the subsumption rules because they are not the same
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10331)   // source-level construct. This behavior is quite confusing and we should try
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10332)   // to help the user figure out what happened.
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10333) 
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10334)   SmallVector<const Expr *, 3> FirstAC, SecondAC;
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10335)   FunctionDecl *FirstCand = nullptr, *SecondCand = nullptr;
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10336)   for (auto I = Cands.begin(), E = Cands.end(); I != E; ++I) {
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10337)     if (!I->Function)
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10338)       continue;
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10339)     SmallVector<const Expr *, 3> AC;
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10340)     if (auto *Template = I->Function->getPrimaryTemplate())
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10341)       Template->getAssociatedConstraints(AC);
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10342)     else
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10343)       I->Function->getAssociatedConstraints(AC);
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10344)     if (AC.empty())
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10345)       continue;
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10346)     if (FirstCand == nullptr) {
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10347)       FirstCand = I->Function;
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10348)       FirstAC = AC;
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10349)     } else if (SecondCand == nullptr) {
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10350)       SecondCand = I->Function;
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10351)       SecondAC = AC;
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10352)     } else {
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10353)       // We have more than one pair of constrained functions - this check is
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10354)       // expensive and we'd rather not try to diagnose it.
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10355)       return;
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10356)     }
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10357)   }
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10358)   if (!SecondCand)
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10359)     return;
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10360)   // The diagnostic can only happen if there are associated constraints on
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10361)   // both sides (there needs to be some identical atomic constraint).
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10362)   if (S.MaybeEmitAmbiguousAtomicConstraintsDiagnostic(FirstCand, FirstAC,
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10363)                                                       SecondCand, SecondAC))
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10364)     // Just show the user one diagnostic, they'll probably figure it out
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10365)     // from here.
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10366)     return;
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10367) }
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 10368) 
ed4265c24e2b6 (Nick Lewycky             2013-09-22 10:06:01 +0000 10369) // Notes the location of all overload candidates designated through
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 10370) // OverloadedExpr
5f21c718007fd (George Burgess IV        2015-10-12 19:57:04 +0000 10371) void Sema::NoteAllOverloadCandidates(Expr *OverloadedExpr, QualType DestType,
5f21c718007fd (George Burgess IV        2015-10-12 19:57:04 +0000 10372)                                      bool TakingAddress) {
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 10373)   assert(OverloadedExpr->getType() == Context.OverloadTy);
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 10374) 
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 10375)   OverloadExpr::FindResult Ovl = OverloadExpr::find(OverloadedExpr);
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 10376)   OverloadExpr *OvlExpr = Ovl.Expression;
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 10377) 
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 10378)   for (UnresolvedSetIterator I = OvlExpr->decls_begin(),
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000 10379)                             IEnd = OvlExpr->decls_end();
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 10380)        I != IEnd; ++I) {
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000 10381)     if (FunctionTemplateDecl *FunTmpl =
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 10382)                 dyn_cast<FunctionTemplateDecl>((*I)->getUnderlyingDecl()) ) {
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 10383)       NoteOverloadCandidate(*I, FunTmpl->getTemplatedDecl(), CRK_None, DestType,
5f21c718007fd (George Burgess IV        2015-10-12 19:57:04 +0000 10384)                             TakingAddress);
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000 10385)     } else if (FunctionDecl *Fun
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 10386)                       = dyn_cast<FunctionDecl>((*I)->getUnderlyingDecl()) ) {
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 10387)       NoteOverloadCandidate(*I, Fun, CRK_None, DestType, TakingAddress);
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 10388)     }
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 10389)   }
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 10390) }
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 10391) 
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000 10392) /// Diagnoses an ambiguous conversion.  The partial diagnostic is the
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000 10393) /// "lead" diagnostic; it will be given two arguments, the source and
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000 10394) /// target types of the conversion.
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000 10395) void ImplicitConversionSequence::DiagnoseAmbiguousConversion(
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000 10396)                                  Sema &S,
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000 10397)                                  SourceLocation CaretLoc,
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000 10398)                                  const PartialDiagnostic &PDiag) const {
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000 10399)   S.Diag(CaretLoc, PDiag)
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000 10400)     << Ambiguous.getFromType() << Ambiguous.getToType();
641bd89d6b5e7 (Matt Beaumont-Gay        2012-11-08 20:50:02 +0000 10401)   unsigned CandsShown = 0;
641bd89d6b5e7 (Matt Beaumont-Gay        2012-11-08 20:50:02 +0000 10402)   AmbiguousConversionSequence::const_iterator I, E;
641bd89d6b5e7 (Matt Beaumont-Gay        2012-11-08 20:50:02 +0000 10403)   for (I = Ambiguous.begin(), E = Ambiguous.end(); I != E; ++I) {
c90dac27e94ec (Justin Lebar             2021-01-30 19:00:24 -0800 10404)     if (CandsShown >= S.Diags.getNumOverloadCandidatesToShow())
641bd89d6b5e7 (Matt Beaumont-Gay        2012-11-08 20:50:02 +0000 10405)       break;
641bd89d6b5e7 (Matt Beaumont-Gay        2012-11-08 20:50:02 +0000 10406)     ++CandsShown;
c2bebe9acab26 (Richard Smith            2016-05-11 20:37:46 +0000 10407)     S.NoteOverloadCandidate(I->first, I->second);
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000 10408)   }
c90dac27e94ec (Justin Lebar             2021-01-30 19:00:24 -0800 10409)   S.Diags.overloadCandidatesShown(CandsShown);
641bd89d6b5e7 (Matt Beaumont-Gay        2012-11-08 20:50:02 +0000 10410)   if (I != E)
641bd89d6b5e7 (Matt Beaumont-Gay        2012-11-08 20:50:02 +0000 10411)     S.Diag(SourceLocation(), diag::note_ovl_too_many_candidates) << int(E - I);
12f97bc48ad40 (John McCall              2010-01-08 04:41:39 +0000 10412) }
12f97bc48ad40 (John McCall              2010-01-08 04:41:39 +0000 10413) 
17c00b43288dc (Richard Smith            2014-11-12 01:24:00 +0000 10414) static void DiagnoseBadConversion(Sema &S, OverloadCandidate *Cand,
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10415)                                   unsigned I, bool TakingCandidateAddress) {
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000 10416)   const ImplicitConversionSequence &Conv = Cand->Conversions[I];
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000 10417)   assert(Conv.isBad());
e1ac8d1742209 (John McCall              2010-01-13 00:25:19 +0000 10418)   assert(Cand->Function && "for now, candidate must be a function");
e1ac8d1742209 (John McCall              2010-01-13 00:25:19 +0000 10419)   FunctionDecl *Fn = Cand->Function;
e1ac8d1742209 (John McCall              2010-01-13 00:25:19 +0000 10420) 
e1ac8d1742209 (John McCall              2010-01-13 00:25:19 +0000 10421)   // There's a conversion slot for the object argument if this is a
e1ac8d1742209 (John McCall              2010-01-13 00:25:19 +0000 10422)   // non-constructor method.  Note that 'I' corresponds the
e1ac8d1742209 (John McCall              2010-01-13 00:25:19 +0000 10423)   // conversion-slot index.
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000 10424)   bool isObjectArgument = false;
e1ac8d1742209 (John McCall              2010-01-13 00:25:19 +0000 10425)   if (isa<CXXMethodDecl>(Fn) && !isa<CXXConstructorDecl>(Fn)) {
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000 10426)     if (I == 0)
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000 10427)       isObjectArgument = true;
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000 10428)     else
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000 10429)       I--;
e1ac8d1742209 (John McCall              2010-01-13 00:25:19 +0000 10430)   }
e1ac8d1742209 (John McCall              2010-01-13 00:25:19 +0000 10431) 
e1ac8d1742209 (John McCall              2010-01-13 00:25:19 +0000 10432)   std::string FnDesc;
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10433)   std::pair<OverloadCandidateKind, OverloadCandidateSelect> FnKindPair =
56b5eab12970e (Richard Smith            2019-11-09 05:52:18 -0800 10434)       ClassifyOverloadCandidate(S, Cand->FoundDecl, Fn, Cand->getRewriteKind(),
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 10435)                                 FnDesc);
e1ac8d1742209 (John McCall              2010-01-13 00:25:19 +0000 10436) 
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000 10437)   Expr *FromExpr = Conv.Bad.FromExpr;
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000 10438)   QualType FromTy = Conv.Bad.getFromType();
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000 10439)   QualType ToTy = Conv.Bad.getToType();
e1ac8d1742209 (John McCall              2010-01-13 00:25:19 +0000 10440) 
fb7ad0f57a0cb (John McCall              2010-02-02 02:42:52 +0000 10441)   if (FromTy == S.Context.OverloadTy) {
65eb879d22cc9 (John McCall              2010-02-25 01:37:24 +0000 10442)     assert(FromExpr && "overload set argument came from implicit argument?");
fb7ad0f57a0cb (John McCall              2010-02-02 02:42:52 +0000 10443)     Expr *E = FromExpr->IgnoreParens();
fb7ad0f57a0cb (John McCall              2010-02-02 02:42:52 +0000 10444)     if (isa<UnaryOperator>(E))
fb7ad0f57a0cb (John McCall              2010-02-02 02:42:52 +0000 10445)       E = cast<UnaryOperator>(E)->getSubExpr()->IgnoreParens();
1acbbb5a4c6e6 (John McCall              2010-02-02 06:20:04 +0000 10446)     DeclarationName Name = cast<OverloadExpr>(E)->getName();
fb7ad0f57a0cb (John McCall              2010-02-02 02:42:52 +0000 10447) 
fb7ad0f57a0cb (John McCall              2010-02-02 02:42:52 +0000 10448)     S.Diag(Fn->getLocation(), diag::note_ovl_candidate_bad_overload)
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10449)         << (unsigned)FnKindPair.first << (unsigned)FnKindPair.second << FnDesc
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10450)         << (FromExpr ? FromExpr->getSourceRange() : SourceRange()) << ToTy
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10451)         << Name << I + 1;
5179eb78210a2 (Richard Smith            2016-06-28 19:03:57 +0000 10452)     MaybeEmitInheritedConstructorNote(S, Cand->FoundDecl);
fb7ad0f57a0cb (John McCall              2010-02-02 02:42:52 +0000 10453)     return;
fb7ad0f57a0cb (John McCall              2010-02-02 02:42:52 +0000 10454)   }
fb7ad0f57a0cb (John McCall              2010-02-02 02:42:52 +0000 10455) 
6d174646dd1a8 (John McCall              2010-01-23 08:10:49 +0000 10456)   // Do some hand-waving analysis to see if the non-viability is due
6d174646dd1a8 (John McCall              2010-01-23 08:10:49 +0000 10457)   // to a qualifier mismatch.
47000997193cf (John McCall              2010-01-14 03:28:57 +0000 10458)   CanQualType CFromTy = S.Context.getCanonicalType(FromTy);
47000997193cf (John McCall              2010-01-14 03:28:57 +0000 10459)   CanQualType CToTy = S.Context.getCanonicalType(ToTy);
47000997193cf (John McCall              2010-01-14 03:28:57 +0000 10460)   if (CanQual<ReferenceType> RT = CToTy->getAs<ReferenceType>())
47000997193cf (John McCall              2010-01-14 03:28:57 +0000 10461)     CToTy = RT->getPointeeType();
47000997193cf (John McCall              2010-01-14 03:28:57 +0000 10462)   else {
47000997193cf (John McCall              2010-01-14 03:28:57 +0000 10463)     // TODO: detect and diagnose the full richness of const mismatches.
47000997193cf (John McCall              2010-01-14 03:28:57 +0000 10464)     if (CanQual<PointerType> FromPT = CFromTy->getAs<PointerType>())
cc3949d99af2b (Richard Trieu            2016-02-18 22:34:54 +0000 10465)       if (CanQual<PointerType> ToPT = CToTy->getAs<PointerType>()) {
cc3949d99af2b (Richard Trieu            2016-02-18 22:34:54 +0000 10466)         CFromTy = FromPT->getPointeeType();
cc3949d99af2b (Richard Trieu            2016-02-18 22:34:54 +0000 10467)         CToTy = ToPT->getPointeeType();
cc3949d99af2b (Richard Trieu            2016-02-18 22:34:54 +0000 10468)       }
47000997193cf (John McCall              2010-01-14 03:28:57 +0000 10469)   }
47000997193cf (John McCall              2010-01-14 03:28:57 +0000 10470) 
47000997193cf (John McCall              2010-01-14 03:28:57 +0000 10471)   if (CToTy.getUnqualifiedType() == CFromTy.getUnqualifiedType() &&
47000997193cf (John McCall              2010-01-14 03:28:57 +0000 10472)       !CToTy.isAtLeastAsQualifiedAs(CFromTy)) {
47000997193cf (John McCall              2010-01-14 03:28:57 +0000 10473)     Qualifiers FromQs = CFromTy.getQualifiers();
47000997193cf (John McCall              2010-01-14 03:28:57 +0000 10474)     Qualifiers ToQs = CToTy.getQualifiers();
47000997193cf (John McCall              2010-01-14 03:28:57 +0000 10475) 
47000997193cf (John McCall              2010-01-14 03:28:57 +0000 10476)     if (FromQs.getAddressSpace() != ToQs.getAddressSpace()) {
ed8dadb37c7e1 (Anastasia Stulova        2019-12-13 12:30:59 +0000 10477)       if (isObjectArgument)
ed8dadb37c7e1 (Anastasia Stulova        2019-12-13 12:30:59 +0000 10478)         S.Diag(Fn->getLocation(), diag::note_ovl_candidate_bad_addrspace_this)
ed8dadb37c7e1 (Anastasia Stulova        2019-12-13 12:30:59 +0000 10479)             << (unsigned)FnKindPair.first << (unsigned)FnKindPair.second
ed8dadb37c7e1 (Anastasia Stulova        2019-12-13 12:30:59 +0000 10480)             << FnDesc << (FromExpr ? FromExpr->getSourceRange() : SourceRange())
ed8dadb37c7e1 (Anastasia Stulova        2019-12-13 12:30:59 +0000 10481)             << FromQs.getAddressSpace() << ToQs.getAddressSpace();
ed8dadb37c7e1 (Anastasia Stulova        2019-12-13 12:30:59 +0000 10482)       else
ed8dadb37c7e1 (Anastasia Stulova        2019-12-13 12:30:59 +0000 10483)         S.Diag(Fn->getLocation(), diag::note_ovl_candidate_bad_addrspace)
ed8dadb37c7e1 (Anastasia Stulova        2019-12-13 12:30:59 +0000 10484)             << (unsigned)FnKindPair.first << (unsigned)FnKindPair.second
ed8dadb37c7e1 (Anastasia Stulova        2019-12-13 12:30:59 +0000 10485)             << FnDesc << (FromExpr ? FromExpr->getSourceRange() : SourceRange())
ed8dadb37c7e1 (Anastasia Stulova        2019-12-13 12:30:59 +0000 10486)             << FromQs.getAddressSpace() << ToQs.getAddressSpace()
ed8dadb37c7e1 (Anastasia Stulova        2019-12-13 12:30:59 +0000 10487)             << ToTy->isReferenceType() << I + 1;
5179eb78210a2 (Richard Smith            2016-06-28 19:03:57 +0000 10488)       MaybeEmitInheritedConstructorNote(S, Cand->FoundDecl);
47000997193cf (John McCall              2010-01-14 03:28:57 +0000 10489)       return;
47000997193cf (John McCall              2010-01-14 03:28:57 +0000 10490)     }
47000997193cf (John McCall              2010-01-14 03:28:57 +0000 10491) 
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000 10492)     if (FromQs.getObjCLifetime() != ToQs.getObjCLifetime()) {
cff00d9c127c7 (Argyrios Kyrtzidis       2011-06-24 00:08:59 +0000 10493)       S.Diag(Fn->getLocation(), diag::note_ovl_candidate_bad_ownership)
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10494)           << (unsigned)FnKindPair.first << (unsigned)FnKindPair.second << FnDesc
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10495)           << (FromExpr ? FromExpr->getSourceRange() : SourceRange()) << FromTy
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10496)           << FromQs.getObjCLifetime() << ToQs.getObjCLifetime()
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10497)           << (unsigned)isObjectArgument << I + 1;
5179eb78210a2 (Richard Smith            2016-06-28 19:03:57 +0000 10498)       MaybeEmitInheritedConstructorNote(S, Cand->FoundDecl);
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000 10499)       return;
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000 10500)     }
31168b077c368 (John McCall              2011-06-15 23:02:42 +0000 10501) 
aec25847606fd (Douglas Gregor           2011-04-26 23:16:46 +0000 10502)     if (FromQs.getObjCGCAttr() != ToQs.getObjCGCAttr()) {
aec25847606fd (Douglas Gregor           2011-04-26 23:16:46 +0000 10503)       S.Diag(Fn->getLocation(), diag::note_ovl_candidate_bad_gc)
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10504)           << (unsigned)FnKindPair.first << (unsigned)FnKindPair.second << FnDesc
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10505)           << (FromExpr ? FromExpr->getSourceRange() : SourceRange()) << FromTy
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10506)           << FromQs.getObjCGCAttr() << ToQs.getObjCGCAttr()
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10507)           << (unsigned)isObjectArgument << I + 1;
5179eb78210a2 (Richard Smith            2016-06-28 19:03:57 +0000 10508)       MaybeEmitInheritedConstructorNote(S, Cand->FoundDecl);
aec25847606fd (Douglas Gregor           2011-04-26 23:16:46 +0000 10509)       return;
aec25847606fd (Douglas Gregor           2011-04-26 23:16:46 +0000 10510)     }
aec25847606fd (Douglas Gregor           2011-04-26 23:16:46 +0000 10511) 
45d413260e82b (Andrey Bokhanko          2016-05-11 18:38:21 +0000 10512)     if (FromQs.hasUnaligned() != ToQs.hasUnaligned()) {
45d413260e82b (Andrey Bokhanko          2016-05-11 18:38:21 +0000 10513)       S.Diag(Fn->getLocation(), diag::note_ovl_candidate_bad_unaligned)
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10514)           << (unsigned)FnKindPair.first << (unsigned)FnKindPair.second << FnDesc
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10515)           << (FromExpr ? FromExpr->getSourceRange() : SourceRange()) << FromTy
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10516)           << FromQs.hasUnaligned() << I + 1;
5179eb78210a2 (Richard Smith            2016-06-28 19:03:57 +0000 10517)       MaybeEmitInheritedConstructorNote(S, Cand->FoundDecl);
45d413260e82b (Andrey Bokhanko          2016-05-11 18:38:21 +0000 10518)       return;
45d413260e82b (Andrey Bokhanko          2016-05-11 18:38:21 +0000 10519)     }
45d413260e82b (Andrey Bokhanko          2016-05-11 18:38:21 +0000 10520) 
47000997193cf (John McCall              2010-01-14 03:28:57 +0000 10521)     unsigned CVR = FromQs.getCVRQualifiers() & ~ToQs.getCVRQualifiers();
6f84779674a97 (Aaron Puchert            2020-11-15 16:11:23 +0100 10522)     assert(CVR && "expected qualifiers mismatch");
47000997193cf (John McCall              2010-01-14 03:28:57 +0000 10523) 
47000997193cf (John McCall              2010-01-14 03:28:57 +0000 10524)     if (isObjectArgument) {
47000997193cf (John McCall              2010-01-14 03:28:57 +0000 10525)       S.Diag(Fn->getLocation(), diag::note_ovl_candidate_bad_cvr_this)
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10526)           << (unsigned)FnKindPair.first << (unsigned)FnKindPair.second << FnDesc
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10527)           << (FromExpr ? FromExpr->getSourceRange() : SourceRange()) << FromTy
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10528)           << (CVR - 1);
47000997193cf (John McCall              2010-01-14 03:28:57 +0000 10529)     } else {
47000997193cf (John McCall              2010-01-14 03:28:57 +0000 10530)       S.Diag(Fn->getLocation(), diag::note_ovl_candidate_bad_cvr)
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10531)           << (unsigned)FnKindPair.first << (unsigned)FnKindPair.second << FnDesc
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10532)           << (FromExpr ? FromExpr->getSourceRange() : SourceRange()) << FromTy
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10533)           << (CVR - 1) << I + 1;
47000997193cf (John McCall              2010-01-14 03:28:57 +0000 10534)     }
5179eb78210a2 (Richard Smith            2016-06-28 19:03:57 +0000 10535)     MaybeEmitInheritedConstructorNote(S, Cand->FoundDecl);
47000997193cf (John McCall              2010-01-14 03:28:57 +0000 10536)     return;
47000997193cf (John McCall              2010-01-14 03:28:57 +0000 10537)   }
47000997193cf (John McCall              2010-01-14 03:28:57 +0000 10538) 
6f84779674a97 (Aaron Puchert            2020-11-15 16:11:23 +0100 10539)   if (Conv.Bad.Kind == BadConversionSequence::lvalue_ref_to_rvalue ||
6f84779674a97 (Aaron Puchert            2020-11-15 16:11:23 +0100 10540)       Conv.Bad.Kind == BadConversionSequence::rvalue_ref_to_lvalue) {
6f84779674a97 (Aaron Puchert            2020-11-15 16:11:23 +0100 10541)     S.Diag(Fn->getLocation(), diag::note_ovl_candidate_bad_value_category)
6f84779674a97 (Aaron Puchert            2020-11-15 16:11:23 +0100 10542)         << (unsigned)FnKindPair.first << (unsigned)FnKindPair.second << FnDesc
6f84779674a97 (Aaron Puchert            2020-11-15 16:11:23 +0100 10543)         << (unsigned)isObjectArgument << I + 1
6f84779674a97 (Aaron Puchert            2020-11-15 16:11:23 +0100 10544)         << (Conv.Bad.Kind == BadConversionSequence::rvalue_ref_to_lvalue)
6f84779674a97 (Aaron Puchert            2020-11-15 16:11:23 +0100 10545)         << (FromExpr ? FromExpr->getSourceRange() : SourceRange());
6f84779674a97 (Aaron Puchert            2020-11-15 16:11:23 +0100 10546)     MaybeEmitInheritedConstructorNote(S, Cand->FoundDecl);
6f84779674a97 (Aaron Puchert            2020-11-15 16:11:23 +0100 10547)     return;
6f84779674a97 (Aaron Puchert            2020-11-15 16:11:23 +0100 10548)   }
6f84779674a97 (Aaron Puchert            2020-11-15 16:11:23 +0100 10549) 
a72462cdf43be (Sebastian Redl           2011-09-24 17:48:32 +0000 10550)   // Special diagnostic for failure to convert an initializer list, since
a72462cdf43be (Sebastian Redl           2011-09-24 17:48:32 +0000 10551)   // telling the user that it has type void is not useful.
a72462cdf43be (Sebastian Redl           2011-09-24 17:48:32 +0000 10552)   if (FromExpr && isa<InitListExpr>(FromExpr)) {
a72462cdf43be (Sebastian Redl           2011-09-24 17:48:32 +0000 10553)     S.Diag(Fn->getLocation(), diag::note_ovl_candidate_bad_list_argument)
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10554)         << (unsigned)FnKindPair.first << (unsigned)FnKindPair.second << FnDesc
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10555)         << (FromExpr ? FromExpr->getSourceRange() : SourceRange()) << FromTy
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10556)         << ToTy << (unsigned)isObjectArgument << I + 1;
5179eb78210a2 (Richard Smith            2016-06-28 19:03:57 +0000 10557)     MaybeEmitInheritedConstructorNote(S, Cand->FoundDecl);
a72462cdf43be (Sebastian Redl           2011-09-24 17:48:32 +0000 10558)     return;
a72462cdf43be (Sebastian Redl           2011-09-24 17:48:32 +0000 10559)   }
a72462cdf43be (Sebastian Redl           2011-09-24 17:48:32 +0000 10560) 
6d174646dd1a8 (John McCall              2010-01-23 08:10:49 +0000 10561)   // Diagnose references or pointers to incomplete types differently,
6d174646dd1a8 (John McCall              2010-01-23 08:10:49 +0000 10562)   // since it's far from impossible that the incompleteness triggered
6d174646dd1a8 (John McCall              2010-01-23 08:10:49 +0000 10563)   // the failure.
6d174646dd1a8 (John McCall              2010-01-23 08:10:49 +0000 10564)   QualType TempFromTy = FromTy.getNonReferenceType();
6d174646dd1a8 (John McCall              2010-01-23 08:10:49 +0000 10565)   if (const PointerType *PTy = TempFromTy->getAs<PointerType>())
6d174646dd1a8 (John McCall              2010-01-23 08:10:49 +0000 10566)     TempFromTy = PTy->getPointeeType();
6d174646dd1a8 (John McCall              2010-01-23 08:10:49 +0000 10567)   if (TempFromTy->isIncompleteType()) {
ac92893a93618 (David Blaikie            2016-03-04 22:29:11 +0000 10568)     // Emit the generic diagnostic and, optionally, add the hints to it.
6d174646dd1a8 (John McCall              2010-01-23 08:10:49 +0000 10569)     S.Diag(Fn->getLocation(), diag::note_ovl_candidate_bad_conv_incomplete)
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10570)         << (unsigned)FnKindPair.first << (unsigned)FnKindPair.second << FnDesc
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10571)         << (FromExpr ? FromExpr->getSourceRange() : SourceRange()) << FromTy
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10572)         << ToTy << (unsigned)isObjectArgument << I + 1
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10573)         << (unsigned)(Cand->Fix.Kind);
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000 10574) 
5179eb78210a2 (Richard Smith            2016-06-28 19:03:57 +0000 10575)     MaybeEmitInheritedConstructorNote(S, Cand->FoundDecl);
6d174646dd1a8 (John McCall              2010-01-23 08:10:49 +0000 10576)     return;
6d174646dd1a8 (John McCall              2010-01-23 08:10:49 +0000 10577)   }
6d174646dd1a8 (John McCall              2010-01-23 08:10:49 +0000 10578) 
56f2e34a6a081 (Douglas Gregor           2010-06-30 23:01:39 +0000 10579)   // Diagnose base -> derived pointer conversions.
fb0c0d37b7f2d (Douglas Gregor           2010-07-01 02:14:45 +0000 10580)   unsigned BaseToDerivedConversion = 0;
56f2e34a6a081 (Douglas Gregor           2010-06-30 23:01:39 +0000 10581)   if (const PointerType *FromPtrTy = FromTy->getAs<PointerType>()) {
56f2e34a6a081 (Douglas Gregor           2010-06-30 23:01:39 +0000 10582)     if (const PointerType *ToPtrTy = ToTy->getAs<PointerType>()) {
56f2e34a6a081 (Douglas Gregor           2010-06-30 23:01:39 +0000 10583)       if (ToPtrTy->getPointeeType().isAtLeastAsQualifiedAs(
56f2e34a6a081 (Douglas Gregor           2010-06-30 23:01:39 +0000 10584)                                                FromPtrTy->getPointeeType()) &&
56f2e34a6a081 (Douglas Gregor           2010-06-30 23:01:39 +0000 10585)           !FromPtrTy->getPointeeType()->isIncompleteType() &&
56f2e34a6a081 (Douglas Gregor           2010-06-30 23:01:39 +0000 10586)           !ToPtrTy->getPointeeType()->isIncompleteType() &&
0f59cb38e7f31 (Richard Smith            2015-12-18 21:45:41 +0000 10587)           S.IsDerivedFrom(SourceLocation(), ToPtrTy->getPointeeType(),
56f2e34a6a081 (Douglas Gregor           2010-06-30 23:01:39 +0000 10588)                           FromPtrTy->getPointeeType()))
fb0c0d37b7f2d (Douglas Gregor           2010-07-01 02:14:45 +0000 10589)         BaseToDerivedConversion = 1;
56f2e34a6a081 (Douglas Gregor           2010-06-30 23:01:39 +0000 10590)     }
56f2e34a6a081 (Douglas Gregor           2010-06-30 23:01:39 +0000 10591)   } else if (const ObjCObjectPointerType *FromPtrTy
56f2e34a6a081 (Douglas Gregor           2010-06-30 23:01:39 +0000 10592)                                     = FromTy->getAs<ObjCObjectPointerType>()) {
56f2e34a6a081 (Douglas Gregor           2010-06-30 23:01:39 +0000 10593)     if (const ObjCObjectPointerType *ToPtrTy
56f2e34a6a081 (Douglas Gregor           2010-06-30 23:01:39 +0000 10594)                                         = ToTy->getAs<ObjCObjectPointerType>())
56f2e34a6a081 (Douglas Gregor           2010-06-30 23:01:39 +0000 10595)       if (const ObjCInterfaceDecl *FromIface = FromPtrTy->getInterfaceDecl())
56f2e34a6a081 (Douglas Gregor           2010-06-30 23:01:39 +0000 10596)         if (const ObjCInterfaceDecl *ToIface = ToPtrTy->getInterfaceDecl())
56f2e34a6a081 (Douglas Gregor           2010-06-30 23:01:39 +0000 10597)           if (ToPtrTy->getPointeeType().isAtLeastAsQualifiedAs(
56f2e34a6a081 (Douglas Gregor           2010-06-30 23:01:39 +0000 10598)                                                 FromPtrTy->getPointeeType()) &&
56f2e34a6a081 (Douglas Gregor           2010-06-30 23:01:39 +0000 10599)               FromIface->isSuperClassOf(ToIface))
fb0c0d37b7f2d (Douglas Gregor           2010-07-01 02:14:45 +0000 10600)             BaseToDerivedConversion = 2;
fb0c0d37b7f2d (Douglas Gregor           2010-07-01 02:14:45 +0000 10601)   } else if (const ReferenceType *ToRefTy = ToTy->getAs<ReferenceType>()) {
9ea8f7e6c53fa (Kaelyn Uhrain            2012-06-19 00:37:47 +0000 10602)     if (ToRefTy->getPointeeType().isAtLeastAsQualifiedAs(FromTy) &&
9ea8f7e6c53fa (Kaelyn Uhrain            2012-06-19 00:37:47 +0000 10603)         !FromTy->isIncompleteType() &&
9ea8f7e6c53fa (Kaelyn Uhrain            2012-06-19 00:37:47 +0000 10604)         !ToRefTy->getPointeeType()->isIncompleteType() &&
0f59cb38e7f31 (Richard Smith            2015-12-18 21:45:41 +0000 10605)         S.IsDerivedFrom(SourceLocation(), ToRefTy->getPointeeType(), FromTy)) {
9ea8f7e6c53fa (Kaelyn Uhrain            2012-06-19 00:37:47 +0000 10606)       BaseToDerivedConversion = 3;
fb0c0d37b7f2d (Douglas Gregor           2010-07-01 02:14:45 +0000 10607)     }
9ea8f7e6c53fa (Kaelyn Uhrain            2012-06-19 00:37:47 +0000 10608)   }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 10609) 
fb0c0d37b7f2d (Douglas Gregor           2010-07-01 02:14:45 +0000 10610)   if (BaseToDerivedConversion) {
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10611)     S.Diag(Fn->getLocation(), diag::note_ovl_candidate_bad_base_to_derived_conv)
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10612)         << (unsigned)FnKindPair.first << (unsigned)FnKindPair.second << FnDesc
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10613)         << (FromExpr ? FromExpr->getSourceRange() : SourceRange())
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10614)         << (BaseToDerivedConversion - 1) << FromTy << ToTy << I + 1;
5179eb78210a2 (Richard Smith            2016-06-28 19:03:57 +0000 10615)     MaybeEmitInheritedConstructorNote(S, Cand->FoundDecl);
56f2e34a6a081 (Douglas Gregor           2010-06-30 23:01:39 +0000 10616)     return;
56f2e34a6a081 (Douglas Gregor           2010-06-30 23:01:39 +0000 10617)   }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 10618) 
a644f9cb73a1b (Fariborz Jahanian        2011-07-20 17:14:09 +0000 10619)   if (isa<ObjCObjectPointerType>(CFromTy) &&
a644f9cb73a1b (Fariborz Jahanian        2011-07-20 17:14:09 +0000 10620)       isa<PointerType>(CToTy)) {
a644f9cb73a1b (Fariborz Jahanian        2011-07-20 17:14:09 +0000 10621)       Qualifiers FromQs = CFromTy.getQualifiers();
a644f9cb73a1b (Fariborz Jahanian        2011-07-20 17:14:09 +0000 10622)       Qualifiers ToQs = CToTy.getQualifiers();
a644f9cb73a1b (Fariborz Jahanian        2011-07-20 17:14:09 +0000 10623)       if (FromQs.getObjCLifetime() != ToQs.getObjCLifetime()) {
a644f9cb73a1b (Fariborz Jahanian        2011-07-20 17:14:09 +0000 10624)         S.Diag(Fn->getLocation(), diag::note_ovl_candidate_bad_arc_conv)
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10625)             << (unsigned)FnKindPair.first << (unsigned)FnKindPair.second
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10626)             << FnDesc << (FromExpr ? FromExpr->getSourceRange() : SourceRange())
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10627)             << FromTy << ToTy << (unsigned)isObjectArgument << I + 1;
5179eb78210a2 (Richard Smith            2016-06-28 19:03:57 +0000 10628)         MaybeEmitInheritedConstructorNote(S, Cand->FoundDecl);
a644f9cb73a1b (Fariborz Jahanian        2011-07-20 17:14:09 +0000 10629)         return;
a644f9cb73a1b (Fariborz Jahanian        2011-07-20 17:14:09 +0000 10630)       }
a644f9cb73a1b (Fariborz Jahanian        2011-07-20 17:14:09 +0000 10631)   }
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10632) 
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10633)   if (TakingCandidateAddress &&
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10634)       !checkAddressOfCandidateIsAvailable(S, Cand->Function))
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10635)     return;
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10636) 
df92ddf8466bf (Anna Zaks                2011-07-19 19:49:12 +0000 10637)   // Emit the generic diagnostic and, optionally, add the hints to it.
df92ddf8466bf (Anna Zaks                2011-07-19 19:49:12 +0000 10638)   PartialDiagnostic FDiag = S.PDiag(diag::note_ovl_candidate_bad_conv);
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10639)   FDiag << (unsigned)FnKindPair.first << (unsigned)FnKindPair.second << FnDesc
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10640)         << (FromExpr ? FromExpr->getSourceRange() : SourceRange()) << FromTy
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10641)         << ToTy << (unsigned)isObjectArgument << I + 1
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10642)         << (unsigned)(Cand->Fix.Kind);
df92ddf8466bf (Anna Zaks                2011-07-19 19:49:12 +0000 10643) 
df92ddf8466bf (Anna Zaks                2011-07-19 19:49:12 +0000 10644)   // If we can fix the conversion, suggest the FixIts.
490afa6b9d1b3 (Benjamin Kramer          2012-01-14 21:05:10 +0000 10645)   for (std::vector<FixItHint>::iterator HI = Cand->Fix.Hints.begin(),
490afa6b9d1b3 (Benjamin Kramer          2012-01-14 21:05:10 +0000 10646)        HE = Cand->Fix.Hints.end(); HI != HE; ++HI)
df92ddf8466bf (Anna Zaks                2011-07-19 19:49:12 +0000 10647)     FDiag << *HI;
df92ddf8466bf (Anna Zaks                2011-07-19 19:49:12 +0000 10648)   S.Diag(Fn->getLocation(), FDiag);
df92ddf8466bf (Anna Zaks                2011-07-19 19:49:12 +0000 10649) 
5179eb78210a2 (Richard Smith            2016-06-28 19:03:57 +0000 10650)   MaybeEmitInheritedConstructorNote(S, Cand->FoundDecl);
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000 10651) }
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000 10652) 
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10653) /// Additional arity mismatch diagnosis specific to a function overload
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10654) /// candidates. This is not covered by the more general DiagnoseArityMismatch()
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10655) /// over a candidate in any candidate set.
17c00b43288dc (Richard Smith            2014-11-12 01:24:00 +0000 10656) static bool CheckArityMismatch(Sema &S, OverloadCandidate *Cand,
17c00b43288dc (Richard Smith            2014-11-12 01:24:00 +0000 10657)                                unsigned NumArgs) {
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000 10658)   FunctionDecl *Fn = Cand->Function;
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000 10659)   unsigned MinParams = Fn->getMinRequiredArguments();
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 10660) 
1d33f8d8a0d7e (Douglas Gregor           2011-05-05 00:13:13 +0000 10661)   // With invalid overloaded operators, it's possible that we think we
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10662)   // have an arity mismatch when in fact it looks like we have the
1d33f8d8a0d7e (Douglas Gregor           2011-05-05 00:13:13 +0000 10663)   // right number of arguments, because only overloaded operators have
1d33f8d8a0d7e (Douglas Gregor           2011-05-05 00:13:13 +0000 10664)   // the weird behavior of overloading member and non-member functions.
1d33f8d8a0d7e (Douglas Gregor           2011-05-05 00:13:13 +0000 10665)   // Just don't report anything.
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000 10666)   if (Fn->isInvalidDecl() &&
1d33f8d8a0d7e (Douglas Gregor           2011-05-05 00:13:13 +0000 10667)       Fn->getDeclName().getNameKind() == DeclarationName::CXXOperatorName)
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10668)     return true;
8d33da6d58f34 (Larisse Voufo            2013-07-19 22:34:32 +0000 10669) 
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10670)   if (NumArgs < MinParams) {
47c0845e0b388 (Larisse Voufo            2013-07-19 22:53:23 +0000 10671)     assert((Cand->FailureKind == ovl_fail_too_few_arguments) ||
47c0845e0b388 (Larisse Voufo            2013-07-19 22:53:23 +0000 10672)            (Cand->FailureKind == ovl_fail_bad_deduction &&
47c0845e0b388 (Larisse Voufo            2013-07-19 22:53:23 +0000 10673)             Cand->DeductionFailure.Result == Sema::TDK_TooFewArguments));
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10674)   } else {
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10675)     assert((Cand->FailureKind == ovl_fail_too_many_arguments) ||
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10676)            (Cand->FailureKind == ovl_fail_bad_deduction &&
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10677)             Cand->DeductionFailure.Result == Sema::TDK_TooManyArguments));
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10678)   }
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10679) 
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10680)   return false;
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10681) }
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10682) 
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10683) /// General arity mismatch diagnosis over a candidate in a candidate set.
c2bebe9acab26 (Richard Smith            2016-05-11 20:37:46 +0000 10684) static void DiagnoseArityMismatch(Sema &S, NamedDecl *Found, Decl *D,
c2bebe9acab26 (Richard Smith            2016-05-11 20:37:46 +0000 10685)                                   unsigned NumFormalArgs) {
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10686)   assert(isa<FunctionDecl>(D) &&
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10687)       "The templated declaration should at least be a function"
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10688)       " when diagnosing bad template argument deduction due to too many"
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10689)       " or too few arguments");
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000 10690) 
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10691)   FunctionDecl *Fn = cast<FunctionDecl>(D);
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000 10692) 
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10693)   // TODO: treat calls to a missing default constructor as a special case
ab9dbc1d124cd (Simon Pilgrim            2020-01-14 14:15:51 +0000 10694)   const auto *FnTy = Fn->getType()->castAs<FunctionProtoType>();
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10695)   unsigned MinParams = Fn->getMinRequiredArguments();
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10696) 
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10697)   // at least / at most / exactly
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10698)   unsigned mode, modeCount;
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10699)   if (NumFormalArgs < MinParams) {
9cacbabd33eea (Alp Toker                2014-01-20 20:26:09 +0000 10700)     if (MinParams != FnTy->getNumParams() || FnTy->isVariadic() ||
9cacbabd33eea (Alp Toker                2014-01-20 20:26:09 +0000 10701)         FnTy->isTemplateVariadic())
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000 10702)       mode = 0; // "at least"
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000 10703)     else
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000 10704)       mode = 2; // "exactly"
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000 10705)     modeCount = MinParams;
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000 10706)   } else {
9cacbabd33eea (Alp Toker                2014-01-20 20:26:09 +0000 10707)     if (MinParams != FnTy->getNumParams())
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000 10708)       mode = 1; // "at most"
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000 10709)     else
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000 10710)       mode = 2; // "exactly"
9cacbabd33eea (Alp Toker                2014-01-20 20:26:09 +0000 10711)     modeCount = FnTy->getNumParams();
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000 10712)   }
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000 10713) 
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000 10714)   std::string Description;
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10715)   std::pair<OverloadCandidateKind, OverloadCandidateSelect> FnKindPair =
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 10716)       ClassifyOverloadCandidate(S, Found, Fn, CRK_None, Description);
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000 10717) 
10ff50d7d8d61 (Richard Smith            2012-05-11 05:16:41 +0000 10718)   if (modeCount == 1 && Fn->getParamDecl(0)->getDeclName())
10ff50d7d8d61 (Richard Smith            2012-05-11 05:16:41 +0000 10719)     S.Diag(Fn->getLocation(), diag::note_ovl_candidate_arity_one)
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10720)         << (unsigned)FnKindPair.first << (unsigned)FnKindPair.second
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10721)         << Description << mode << Fn->getParamDecl(0) << NumFormalArgs;
10ff50d7d8d61 (Richard Smith            2012-05-11 05:16:41 +0000 10722)   else
10ff50d7d8d61 (Richard Smith            2012-05-11 05:16:41 +0000 10723)     S.Diag(Fn->getLocation(), diag::note_ovl_candidate_arity)
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10724)         << (unsigned)FnKindPair.first << (unsigned)FnKindPair.second
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10725)         << Description << mode << modeCount << NumFormalArgs;
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 10726) 
5179eb78210a2 (Richard Smith            2016-06-28 19:03:57 +0000 10727)   MaybeEmitInheritedConstructorNote(S, Found);
e1ac8d1742209 (John McCall              2010-01-13 00:25:19 +0000 10728) }
e1ac8d1742209 (John McCall              2010-01-13 00:25:19 +0000 10729) 
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10730) /// Arity mismatch diagnosis specific to a function overload candidate.
17c00b43288dc (Richard Smith            2014-11-12 01:24:00 +0000 10731) static void DiagnoseArityMismatch(Sema &S, OverloadCandidate *Cand,
17c00b43288dc (Richard Smith            2014-11-12 01:24:00 +0000 10732)                                   unsigned NumFormalArgs) {
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10733)   if (!CheckArityMismatch(S, Cand, NumFormalArgs))
c2bebe9acab26 (Richard Smith            2016-05-11 20:37:46 +0000 10734)     DiagnoseArityMismatch(S, Cand->FoundDecl, Cand->Function, NumFormalArgs);
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10735) }
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10736) 
17c00b43288dc (Richard Smith            2014-11-12 01:24:00 +0000 10737) static TemplateDecl *getDescribedTemplate(Decl *Templated) {
7dcc97e7ac0a7 (Serge Pavlov             2016-04-19 06:19:52 +0000 10738)   if (TemplateDecl *TD = Templated->getDescribedTemplate())
7dcc97e7ac0a7 (Serge Pavlov             2016-04-19 06:19:52 +0000 10739)     return TD;
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10740)   llvm_unreachable("Unsupported: Getting the described template declaration"
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10741)                    " for bad deduction diagnosis");
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10742) }
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10743) 
8b9ed55bfbea0 (John McCall              2010-02-01 18:53:26 +0000 10744) /// Diagnose a failed template-argument deduction.
c2bebe9acab26 (Richard Smith            2016-05-11 20:37:46 +0000 10745) static void DiagnoseBadDeduction(Sema &S, NamedDecl *Found, Decl *Templated,
17c00b43288dc (Richard Smith            2014-11-12 01:24:00 +0000 10746)                                  DeductionFailureInfo &DeductionFailure,
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10747)                                  unsigned NumArgs,
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10748)                                  bool TakingCandidateAddress) {
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10749)   TemplateParameter Param = DeductionFailure.getTemplateParameter();
1d72edd7c55a8 (Douglas Gregor           2010-05-08 19:15:54 +0000 10750)   NamedDecl *ParamD;
1d72edd7c55a8 (Douglas Gregor           2010-05-08 19:15:54 +0000 10751)   (ParamD = Param.dyn_cast<TemplateTypeParmDecl*>()) ||
1d72edd7c55a8 (Douglas Gregor           2010-05-08 19:15:54 +0000 10752)   (ParamD = Param.dyn_cast<NonTypeTemplateParmDecl*>()) ||
1d72edd7c55a8 (Douglas Gregor           2010-05-08 19:15:54 +0000 10753)   (ParamD = Param.dyn_cast<TemplateTemplateParmDecl*>());
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10754)   switch (DeductionFailure.Result) {
8b9ed55bfbea0 (John McCall              2010-02-01 18:53:26 +0000 10755)   case Sema::TDK_Success:
8b9ed55bfbea0 (John McCall              2010-02-01 18:53:26 +0000 10756)     llvm_unreachable("TDK_success while diagnosing bad deduction");
8b9ed55bfbea0 (John McCall              2010-02-01 18:53:26 +0000 10757) 
8b9ed55bfbea0 (John McCall              2010-02-01 18:53:26 +0000 10758)   case Sema::TDK_Incomplete: {
8b9ed55bfbea0 (John McCall              2010-02-01 18:53:26 +0000 10759)     assert(ParamD && "no parameter found for incomplete deduction result");
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10760)     S.Diag(Templated->getLocation(),
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10761)            diag::note_ovl_candidate_incomplete_deduction)
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10762)         << ParamD->getDeclName();
5179eb78210a2 (Richard Smith            2016-06-28 19:03:57 +0000 10763)     MaybeEmitInheritedConstructorNote(S, Found);
8b9ed55bfbea0 (John McCall              2010-02-01 18:53:26 +0000 10764)     return;
8b9ed55bfbea0 (John McCall              2010-02-01 18:53:26 +0000 10765)   }
8b9ed55bfbea0 (John McCall              2010-02-01 18:53:26 +0000 10766) 
4a8f3518cb144 (Richard Smith            2018-07-19 19:00:37 +0000 10767)   case Sema::TDK_IncompletePack: {
4a8f3518cb144 (Richard Smith            2018-07-19 19:00:37 +0000 10768)     assert(ParamD && "no parameter found for incomplete deduction result");
4a8f3518cb144 (Richard Smith            2018-07-19 19:00:37 +0000 10769)     S.Diag(Templated->getLocation(),
4a8f3518cb144 (Richard Smith            2018-07-19 19:00:37 +0000 10770)            diag::note_ovl_candidate_incomplete_deduction_pack)
4a8f3518cb144 (Richard Smith            2018-07-19 19:00:37 +0000 10771)         << ParamD->getDeclName()
4a8f3518cb144 (Richard Smith            2018-07-19 19:00:37 +0000 10772)         << (DeductionFailure.getFirstArg()->pack_size() + 1)
4a8f3518cb144 (Richard Smith            2018-07-19 19:00:37 +0000 10773)         << *DeductionFailure.getFirstArg();
4a8f3518cb144 (Richard Smith            2018-07-19 19:00:37 +0000 10774)     MaybeEmitInheritedConstructorNote(S, Found);
4a8f3518cb144 (Richard Smith            2018-07-19 19:00:37 +0000 10775)     return;
4a8f3518cb144 (Richard Smith            2018-07-19 19:00:37 +0000 10776)   }
4a8f3518cb144 (Richard Smith            2018-07-19 19:00:37 +0000 10777) 
42d7d19710d09 (John McCall              2010-08-05 09:05:08 +0000 10778)   case Sema::TDK_Underqualified: {
42d7d19710d09 (John McCall              2010-08-05 09:05:08 +0000 10779)     assert(ParamD && "no parameter found for bad qualifiers deduction result");
42d7d19710d09 (John McCall              2010-08-05 09:05:08 +0000 10780)     TemplateTypeParmDecl *TParam = cast<TemplateTypeParmDecl>(ParamD);
42d7d19710d09 (John McCall              2010-08-05 09:05:08 +0000 10781) 
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10782)     QualType Param = DeductionFailure.getFirstArg()->getAsType();
42d7d19710d09 (John McCall              2010-08-05 09:05:08 +0000 10783) 
42d7d19710d09 (John McCall              2010-08-05 09:05:08 +0000 10784)     // Param will have been canonicalized, but it should just be a
42d7d19710d09 (John McCall              2010-08-05 09:05:08 +0000 10785)     // qualified version of ParamD, so move the qualifiers to that.
717d9b0e2f2a8 (John McCall              2010-12-10 11:01:00 +0000 10786)     QualifierCollector Qs;
42d7d19710d09 (John McCall              2010-08-05 09:05:08 +0000 10787)     Qs.strip(Param);
717d9b0e2f2a8 (John McCall              2010-12-10 11:01:00 +0000 10788)     QualType NonCanonParam = Qs.apply(S.Context, TParam->getTypeForDecl());
42d7d19710d09 (John McCall              2010-08-05 09:05:08 +0000 10789)     assert(S.Context.hasSameType(Param, NonCanonParam));
42d7d19710d09 (John McCall              2010-08-05 09:05:08 +0000 10790) 
42d7d19710d09 (John McCall              2010-08-05 09:05:08 +0000 10791)     // Arg has also been canonicalized, but there's nothing we can do
42d7d19710d09 (John McCall              2010-08-05 09:05:08 +0000 10792)     // about that.  It also doesn't matter as much, because it won't
42d7d19710d09 (John McCall              2010-08-05 09:05:08 +0000 10793)     // have any template parameters in it (because deduction isn't
42d7d19710d09 (John McCall              2010-08-05 09:05:08 +0000 10794)     // done on dependent types).
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10795)     QualType Arg = DeductionFailure.getSecondArg()->getAsType();
42d7d19710d09 (John McCall              2010-08-05 09:05:08 +0000 10796) 
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10797)     S.Diag(Templated->getLocation(), diag::note_ovl_candidate_underqualified)
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10798)         << ParamD->getDeclName() << Arg << NonCanonParam;
5179eb78210a2 (Richard Smith            2016-06-28 19:03:57 +0000 10799)     MaybeEmitInheritedConstructorNote(S, Found);
42d7d19710d09 (John McCall              2010-08-05 09:05:08 +0000 10800)     return;
42d7d19710d09 (John McCall              2010-08-05 09:05:08 +0000 10801)   }
42d7d19710d09 (John McCall              2010-08-05 09:05:08 +0000 10802) 
42d7d19710d09 (John McCall              2010-08-05 09:05:08 +0000 10803)   case Sema::TDK_Inconsistent: {
8e543b3d46932 (Chandler Carruth         2010-12-12 08:17:55 +0000 10804)     assert(ParamD && "no parameter found for inconsistent deduction result");
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000 10805)     int which = 0;
1d72edd7c55a8 (Douglas Gregor           2010-05-08 19:15:54 +0000 10806)     if (isa<TemplateTypeParmDecl>(ParamD))
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000 10807)       which = 0;
593d6a168f457 (Richard Smith            2016-12-23 01:30:39 +0000 10808)     else if (isa<NonTypeTemplateParmDecl>(ParamD)) {
593d6a168f457 (Richard Smith            2016-12-23 01:30:39 +0000 10809)       // Deduction might have failed because we deduced arguments of two
593d6a168f457 (Richard Smith            2016-12-23 01:30:39 +0000 10810)       // different types for a non-type template parameter.
593d6a168f457 (Richard Smith            2016-12-23 01:30:39 +0000 10811)       // FIXME: Use a different TDK value for this.
593d6a168f457 (Richard Smith            2016-12-23 01:30:39 +0000 10812)       QualType T1 =
593d6a168f457 (Richard Smith            2016-12-23 01:30:39 +0000 10813)           DeductionFailure.getFirstArg()->getNonTypeTemplateArgumentType();
593d6a168f457 (Richard Smith            2016-12-23 01:30:39 +0000 10814)       QualType T2 =
593d6a168f457 (Richard Smith            2016-12-23 01:30:39 +0000 10815)           DeductionFailure.getSecondArg()->getNonTypeTemplateArgumentType();
e54d9525ad594 (Richard Smith            2018-10-09 18:49:22 +0000 10816)       if (!T1.isNull() && !T2.isNull() && !S.Context.hasSameType(T1, T2)) {
593d6a168f457 (Richard Smith            2016-12-23 01:30:39 +0000 10817)         S.Diag(Templated->getLocation(),
593d6a168f457 (Richard Smith            2016-12-23 01:30:39 +0000 10818)                diag::note_ovl_candidate_inconsistent_deduction_types)
593d6a168f457 (Richard Smith            2016-12-23 01:30:39 +0000 10819)           << ParamD->getDeclName() << *DeductionFailure.getFirstArg() << T1
593d6a168f457 (Richard Smith            2016-12-23 01:30:39 +0000 10820)           << *DeductionFailure.getSecondArg() << T2;
593d6a168f457 (Richard Smith            2016-12-23 01:30:39 +0000 10821)         MaybeEmitInheritedConstructorNote(S, Found);
593d6a168f457 (Richard Smith            2016-12-23 01:30:39 +0000 10822)         return;
593d6a168f457 (Richard Smith            2016-12-23 01:30:39 +0000 10823)       }
593d6a168f457 (Richard Smith            2016-12-23 01:30:39 +0000 10824) 
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000 10825)       which = 1;
593d6a168f457 (Richard Smith            2016-12-23 01:30:39 +0000 10826)     } else {
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000 10827)       which = 2;
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000 10828)     }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 10829) 
907cefe721437 (Richard Smith            2020-01-06 17:16:29 -0800 10830)     // Tweak the diagnostic if the problem is that we deduced packs of
907cefe721437 (Richard Smith            2020-01-06 17:16:29 -0800 10831)     // different arities. We'll print the actual packs anyway in case that
907cefe721437 (Richard Smith            2020-01-06 17:16:29 -0800 10832)     // includes additional useful information.
907cefe721437 (Richard Smith            2020-01-06 17:16:29 -0800 10833)     if (DeductionFailure.getFirstArg()->getKind() == TemplateArgument::Pack &&
907cefe721437 (Richard Smith            2020-01-06 17:16:29 -0800 10834)         DeductionFailure.getSecondArg()->getKind() == TemplateArgument::Pack &&
907cefe721437 (Richard Smith            2020-01-06 17:16:29 -0800 10835)         DeductionFailure.getFirstArg()->pack_size() !=
907cefe721437 (Richard Smith            2020-01-06 17:16:29 -0800 10836)             DeductionFailure.getSecondArg()->pack_size()) {
907cefe721437 (Richard Smith            2020-01-06 17:16:29 -0800 10837)       which = 3;
907cefe721437 (Richard Smith            2020-01-06 17:16:29 -0800 10838)     }
907cefe721437 (Richard Smith            2020-01-06 17:16:29 -0800 10839) 
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10840)     S.Diag(Templated->getLocation(),
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10841)            diag::note_ovl_candidate_inconsistent_deduction)
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10842)         << which << ParamD->getDeclName() << *DeductionFailure.getFirstArg()
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10843)         << *DeductionFailure.getSecondArg();
5179eb78210a2 (Richard Smith            2016-06-28 19:03:57 +0000 10844)     MaybeEmitInheritedConstructorNote(S, Found);
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000 10845)     return;
3626a5cac2edf (Douglas Gregor           2010-05-08 17:41:32 +0000 10846)   }
02eb4835ce7da (Douglas Gregor           2010-05-08 18:13:28 +0000 10847) 
1d72edd7c55a8 (Douglas Gregor           2010-05-08 19:15:54 +0000 10848)   case Sema::TDK_InvalidExplicitArguments:
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 10849)     assert(ParamD && "no parameter found for invalid explicit arguments");
1d72edd7c55a8 (Douglas Gregor           2010-05-08 19:15:54 +0000 10850)     if (ParamD->getDeclName())
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10851)       S.Diag(Templated->getLocation(),
1d72edd7c55a8 (Douglas Gregor           2010-05-08 19:15:54 +0000 10852)              diag::note_ovl_candidate_explicit_arg_mismatch_named)
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10853)           << ParamD->getDeclName();
1d72edd7c55a8 (Douglas Gregor           2010-05-08 19:15:54 +0000 10854)     else {
1d72edd7c55a8 (Douglas Gregor           2010-05-08 19:15:54 +0000 10855)       int index = 0;
1d72edd7c55a8 (Douglas Gregor           2010-05-08 19:15:54 +0000 10856)       if (TemplateTypeParmDecl *TTP = dyn_cast<TemplateTypeParmDecl>(ParamD))
1d72edd7c55a8 (Douglas Gregor           2010-05-08 19:15:54 +0000 10857)         index = TTP->getIndex();
1d72edd7c55a8 (Douglas Gregor           2010-05-08 19:15:54 +0000 10858)       else if (NonTypeTemplateParmDecl *NTTP
1d72edd7c55a8 (Douglas Gregor           2010-05-08 19:15:54 +0000 10859)                                   = dyn_cast<NonTypeTemplateParmDecl>(ParamD))
1d72edd7c55a8 (Douglas Gregor           2010-05-08 19:15:54 +0000 10860)         index = NTTP->getIndex();
1d72edd7c55a8 (Douglas Gregor           2010-05-08 19:15:54 +0000 10861)       else
1d72edd7c55a8 (Douglas Gregor           2010-05-08 19:15:54 +0000 10862)         index = cast<TemplateTemplateParmDecl>(ParamD)->getIndex();
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10863)       S.Diag(Templated->getLocation(),
1d72edd7c55a8 (Douglas Gregor           2010-05-08 19:15:54 +0000 10864)              diag::note_ovl_candidate_explicit_arg_mismatch_unnamed)
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10865)           << (index + 1);
1d72edd7c55a8 (Douglas Gregor           2010-05-08 19:15:54 +0000 10866)     }
5179eb78210a2 (Richard Smith            2016-06-28 19:03:57 +0000 10867)     MaybeEmitInheritedConstructorNote(S, Found);
1d72edd7c55a8 (Douglas Gregor           2010-05-08 19:15:54 +0000 10868)     return;
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 10869) 
fdf80e86a5284 (Saar Raz                 2019-12-06 01:30:21 +0200 10870)   case Sema::TDK_ConstraintsNotSatisfied: {
fdf80e86a5284 (Saar Raz                 2019-12-06 01:30:21 +0200 10871)     // Format the template argument list into the argument string.
fdf80e86a5284 (Saar Raz                 2019-12-06 01:30:21 +0200 10872)     SmallString<128> TemplateArgString;
fdf80e86a5284 (Saar Raz                 2019-12-06 01:30:21 +0200 10873)     TemplateArgumentList *Args = DeductionFailure.getTemplateArgumentList();
fdf80e86a5284 (Saar Raz                 2019-12-06 01:30:21 +0200 10874)     TemplateArgString = " ";
fdf80e86a5284 (Saar Raz                 2019-12-06 01:30:21 +0200 10875)     TemplateArgString += S.getTemplateArgumentBindingsText(
fdf80e86a5284 (Saar Raz                 2019-12-06 01:30:21 +0200 10876)         getDescribedTemplate(Templated)->getTemplateParameters(), *Args);
907cefe721437 (Richard Smith            2020-01-06 17:16:29 -0800 10877)     if (TemplateArgString.size() == 1)
907cefe721437 (Richard Smith            2020-01-06 17:16:29 -0800 10878)       TemplateArgString.clear();
fdf80e86a5284 (Saar Raz                 2019-12-06 01:30:21 +0200 10879)     S.Diag(Templated->getLocation(),
fdf80e86a5284 (Saar Raz                 2019-12-06 01:30:21 +0200 10880)            diag::note_ovl_candidate_unsatisfied_constraints)
fdf80e86a5284 (Saar Raz                 2019-12-06 01:30:21 +0200 10881)         << TemplateArgString;
fdf80e86a5284 (Saar Raz                 2019-12-06 01:30:21 +0200 10882) 
fdf80e86a5284 (Saar Raz                 2019-12-06 01:30:21 +0200 10883)     S.DiagnoseUnsatisfiedConstraint(
fdf80e86a5284 (Saar Raz                 2019-12-06 01:30:21 +0200 10884)         static_cast<CNSInfo*>(DeductionFailure.Data)->Satisfaction);
fdf80e86a5284 (Saar Raz                 2019-12-06 01:30:21 +0200 10885)     return;
fdf80e86a5284 (Saar Raz                 2019-12-06 01:30:21 +0200 10886)   }
02eb4835ce7da (Douglas Gregor           2010-05-08 18:13:28 +0000 10887)   case Sema::TDK_TooManyArguments:
02eb4835ce7da (Douglas Gregor           2010-05-08 18:13:28 +0000 10888)   case Sema::TDK_TooFewArguments:
c2bebe9acab26 (Richard Smith            2016-05-11 20:37:46 +0000 10889)     DiagnoseArityMismatch(S, Found, Templated, NumArgs);
02eb4835ce7da (Douglas Gregor           2010-05-08 18:13:28 +0000 10890)     return;
d09efd43d3f84 (Douglas Gregor           2010-05-08 20:07:26 +0000 10891) 
d09efd43d3f84 (Douglas Gregor           2010-05-08 20:07:26 +0000 10892)   case Sema::TDK_InstantiationDepth:
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10893)     S.Diag(Templated->getLocation(),
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10894)            diag::note_ovl_candidate_instantiation_depth);
5179eb78210a2 (Richard Smith            2016-06-28 19:03:57 +0000 10895)     MaybeEmitInheritedConstructorNote(S, Found);
d09efd43d3f84 (Douglas Gregor           2010-05-08 20:07:26 +0000 10896)     return;
d09efd43d3f84 (Douglas Gregor           2010-05-08 20:07:26 +0000 10897) 
d09efd43d3f84 (Douglas Gregor           2010-05-08 20:07:26 +0000 10898)   case Sema::TDK_SubstitutionFailure: {
9ca6461f5a9ac (Richard Smith            2012-05-07 09:03:25 +0000 10899)     // Format the template argument list into the argument string.
f857950d391d0 (Dmitri Gribenko          2013-01-12 19:30:44 +0000 10900)     SmallString<128> TemplateArgString;
9ca6461f5a9ac (Richard Smith            2012-05-07 09:03:25 +0000 10901)     if (TemplateArgumentList *Args =
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10902)             DeductionFailure.getTemplateArgumentList()) {
9ca6461f5a9ac (Richard Smith            2012-05-07 09:03:25 +0000 10903)       TemplateArgString = " ";
9ca6461f5a9ac (Richard Smith            2012-05-07 09:03:25 +0000 10904)       TemplateArgString += S.getTemplateArgumentBindingsText(
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10905)           getDescribedTemplate(Templated)->getTemplateParameters(), *Args);
907cefe721437 (Richard Smith            2020-01-06 17:16:29 -0800 10906)       if (TemplateArgString.size() == 1)
907cefe721437 (Richard Smith            2020-01-06 17:16:29 -0800 10907)         TemplateArgString.clear();
9ca6461f5a9ac (Richard Smith            2012-05-07 09:03:25 +0000 10908)     }
9ca6461f5a9ac (Richard Smith            2012-05-07 09:03:25 +0000 10909) 
6f8d2c6c9c345 (Richard Smith            2012-05-09 05:17:00 +0000 10910)     // If this candidate was disabled by enable_if, say so.
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10911)     PartialDiagnosticAt *PDiag = DeductionFailure.getSFINAEDiagnostic();
6f8d2c6c9c345 (Richard Smith            2012-05-09 05:17:00 +0000 10912)     if (PDiag && PDiag->second.getDiagID() ==
6f8d2c6c9c345 (Richard Smith            2012-05-09 05:17:00 +0000 10913)           diag::err_typename_nested_not_found_enable_if) {
6f8d2c6c9c345 (Richard Smith            2012-05-09 05:17:00 +0000 10914)       // FIXME: Use the source range of the condition, and the fully-qualified
6f8d2c6c9c345 (Richard Smith            2012-05-09 05:17:00 +0000 10915)       //        name of the enable_if template. These are both present in PDiag.
6f8d2c6c9c345 (Richard Smith            2012-05-09 05:17:00 +0000 10916)       S.Diag(PDiag->first, diag::note_ovl_candidate_disabled_by_enable_if)
6f8d2c6c9c345 (Richard Smith            2012-05-09 05:17:00 +0000 10917)         << "'enable_if'" << TemplateArgString;
6f8d2c6c9c345 (Richard Smith            2012-05-09 05:17:00 +0000 10918)       return;
6f8d2c6c9c345 (Richard Smith            2012-05-09 05:17:00 +0000 10919)     }
6f8d2c6c9c345 (Richard Smith            2012-05-09 05:17:00 +0000 10920) 
00fa10b43f25d (Douglas Gregor           2017-07-05 20:20:14 +0000 10921)     // We found a specific requirement that disabled the enable_if.
00fa10b43f25d (Douglas Gregor           2017-07-05 20:20:14 +0000 10922)     if (PDiag && PDiag->second.getDiagID() ==
00fa10b43f25d (Douglas Gregor           2017-07-05 20:20:14 +0000 10923)         diag::err_typename_nested_not_found_requirement) {
00fa10b43f25d (Douglas Gregor           2017-07-05 20:20:14 +0000 10924)       S.Diag(Templated->getLocation(),
00fa10b43f25d (Douglas Gregor           2017-07-05 20:20:14 +0000 10925)              diag::note_ovl_candidate_disabled_by_requirement)
00fa10b43f25d (Douglas Gregor           2017-07-05 20:20:14 +0000 10926)         << PDiag->second.getStringArg(0) << TemplateArgString;
00fa10b43f25d (Douglas Gregor           2017-07-05 20:20:14 +0000 10927)       return;
00fa10b43f25d (Douglas Gregor           2017-07-05 20:20:14 +0000 10928)     }
00fa10b43f25d (Douglas Gregor           2017-07-05 20:20:14 +0000 10929) 
9ca6461f5a9ac (Richard Smith            2012-05-07 09:03:25 +0000 10930)     // Format the SFINAE diagnostic into the argument string.
9ca6461f5a9ac (Richard Smith            2012-05-07 09:03:25 +0000 10931)     // FIXME: Add a general mechanism to include a PartialDiagnostic *'s
9ca6461f5a9ac (Richard Smith            2012-05-07 09:03:25 +0000 10932)     //        formatted message in another diagnostic.
f857950d391d0 (Dmitri Gribenko          2013-01-12 19:30:44 +0000 10933)     SmallString<128> SFINAEArgString;
9ca6461f5a9ac (Richard Smith            2012-05-07 09:03:25 +0000 10934)     SourceRange R;
6f8d2c6c9c345 (Richard Smith            2012-05-09 05:17:00 +0000 10935)     if (PDiag) {
9ca6461f5a9ac (Richard Smith            2012-05-07 09:03:25 +0000 10936)       SFINAEArgString = ": ";
9ca6461f5a9ac (Richard Smith            2012-05-07 09:03:25 +0000 10937)       R = SourceRange(PDiag->first, PDiag->first);
9ca6461f5a9ac (Richard Smith            2012-05-07 09:03:25 +0000 10938)       PDiag->second.EmitToString(S.getDiagnostics(), SFINAEArgString);
9ca6461f5a9ac (Richard Smith            2012-05-07 09:03:25 +0000 10939)     }
9ca6461f5a9ac (Richard Smith            2012-05-07 09:03:25 +0000 10940) 
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10941)     S.Diag(Templated->getLocation(),
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10942)            diag::note_ovl_candidate_substitution_failure)
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10943)         << TemplateArgString << SFINAEArgString << R;
5179eb78210a2 (Richard Smith            2016-06-28 19:03:57 +0000 10944)     MaybeEmitInheritedConstructorNote(S, Found);
d09efd43d3f84 (Douglas Gregor           2010-05-08 20:07:26 +0000 10945)     return;
d09efd43d3f84 (Douglas Gregor           2010-05-08 20:07:26 +0000 10946)   }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 10947) 
c92d206ce4419 (Richard Smith            2017-01-05 23:02:44 +0000 10948)   case Sema::TDK_DeducedMismatch:
c92d206ce4419 (Richard Smith            2017-01-05 23:02:44 +0000 10949)   case Sema::TDK_DeducedMismatchNested: {
9b534547250a3 (Richard Smith            2015-12-31 02:02:54 +0000 10950)     // Format the template argument list into the argument string.
9b534547250a3 (Richard Smith            2015-12-31 02:02:54 +0000 10951)     SmallString<128> TemplateArgString;
9b534547250a3 (Richard Smith            2015-12-31 02:02:54 +0000 10952)     if (TemplateArgumentList *Args =
9b534547250a3 (Richard Smith            2015-12-31 02:02:54 +0000 10953)             DeductionFailure.getTemplateArgumentList()) {
9b534547250a3 (Richard Smith            2015-12-31 02:02:54 +0000 10954)       TemplateArgString = " ";
9b534547250a3 (Richard Smith            2015-12-31 02:02:54 +0000 10955)       TemplateArgString += S.getTemplateArgumentBindingsText(
9b534547250a3 (Richard Smith            2015-12-31 02:02:54 +0000 10956)           getDescribedTemplate(Templated)->getTemplateParameters(), *Args);
907cefe721437 (Richard Smith            2020-01-06 17:16:29 -0800 10957)       if (TemplateArgString.size() == 1)
907cefe721437 (Richard Smith            2020-01-06 17:16:29 -0800 10958)         TemplateArgString.clear();
9b534547250a3 (Richard Smith            2015-12-31 02:02:54 +0000 10959)     }
9b534547250a3 (Richard Smith            2015-12-31 02:02:54 +0000 10960) 
9b534547250a3 (Richard Smith            2015-12-31 02:02:54 +0000 10961)     S.Diag(Templated->getLocation(), diag::note_ovl_candidate_deduced_mismatch)
9b534547250a3 (Richard Smith            2015-12-31 02:02:54 +0000 10962)         << (*DeductionFailure.getCallArgIndex() + 1)
9b534547250a3 (Richard Smith            2015-12-31 02:02:54 +0000 10963)         << *DeductionFailure.getFirstArg() << *DeductionFailure.getSecondArg()
c92d206ce4419 (Richard Smith            2017-01-05 23:02:44 +0000 10964)         << TemplateArgString
c92d206ce4419 (Richard Smith            2017-01-05 23:02:44 +0000 10965)         << (DeductionFailure.Result == Sema::TDK_DeducedMismatchNested);
9b534547250a3 (Richard Smith            2015-12-31 02:02:54 +0000 10966)     break;
9b534547250a3 (Richard Smith            2015-12-31 02:02:54 +0000 10967)   }
9b534547250a3 (Richard Smith            2015-12-31 02:02:54 +0000 10968) 
e373235c7cf8e (Richard Trieu            2013-04-08 21:11:40 +0000 10969)   case Sema::TDK_NonDeducedMismatch: {
44ecdbdc6134c (Richard Smith            2013-01-31 05:19:49 +0000 10970)     // FIXME: Provide a source location to indicate what we couldn't match.
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10971)     TemplateArgument FirstTA = *DeductionFailure.getFirstArg();
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10972)     TemplateArgument SecondTA = *DeductionFailure.getSecondArg();
e373235c7cf8e (Richard Trieu            2013-04-08 21:11:40 +0000 10973)     if (FirstTA.getKind() == TemplateArgument::Template &&
e373235c7cf8e (Richard Trieu            2013-04-08 21:11:40 +0000 10974)         SecondTA.getKind() == TemplateArgument::Template) {
e373235c7cf8e (Richard Trieu            2013-04-08 21:11:40 +0000 10975)       TemplateName FirstTN = FirstTA.getAsTemplate();
e373235c7cf8e (Richard Trieu            2013-04-08 21:11:40 +0000 10976)       TemplateName SecondTN = SecondTA.getAsTemplate();
e373235c7cf8e (Richard Trieu            2013-04-08 21:11:40 +0000 10977)       if (FirstTN.getKind() == TemplateName::Template &&
e373235c7cf8e (Richard Trieu            2013-04-08 21:11:40 +0000 10978)           SecondTN.getKind() == TemplateName::Template) {
e373235c7cf8e (Richard Trieu            2013-04-08 21:11:40 +0000 10979)         if (FirstTN.getAsTemplateDecl()->getName() ==
e373235c7cf8e (Richard Trieu            2013-04-08 21:11:40 +0000 10980)             SecondTN.getAsTemplateDecl()->getName()) {
e373235c7cf8e (Richard Trieu            2013-04-08 21:11:40 +0000 10981)           // FIXME: This fixes a bad diagnostic where both templates are named
e373235c7cf8e (Richard Trieu            2013-04-08 21:11:40 +0000 10982)           // the same.  This particular case is a bit difficult since:
e373235c7cf8e (Richard Trieu            2013-04-08 21:11:40 +0000 10983)           // 1) It is passed as a string to the diagnostic printer.
e373235c7cf8e (Richard Trieu            2013-04-08 21:11:40 +0000 10984)           // 2) The diagnostic printer only attempts to find a better
e373235c7cf8e (Richard Trieu            2013-04-08 21:11:40 +0000 10985)           //    name for types, not decls.
e373235c7cf8e (Richard Trieu            2013-04-08 21:11:40 +0000 10986)           // Ideally, this should folded into the diagnostic printer.
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 10987)           S.Diag(Templated->getLocation(),
e373235c7cf8e (Richard Trieu            2013-04-08 21:11:40 +0000 10988)                  diag::note_ovl_candidate_non_deduced_mismatch_qualified)
e373235c7cf8e (Richard Trieu            2013-04-08 21:11:40 +0000 10989)               << FirstTN.getAsTemplateDecl() << SecondTN.getAsTemplateDecl();
e373235c7cf8e (Richard Trieu            2013-04-08 21:11:40 +0000 10990)           return;
e373235c7cf8e (Richard Trieu            2013-04-08 21:11:40 +0000 10991)         }
e373235c7cf8e (Richard Trieu            2013-04-08 21:11:40 +0000 10992)       }
e373235c7cf8e (Richard Trieu            2013-04-08 21:11:40 +0000 10993)     }
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10994) 
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10995)     if (TakingCandidateAddress && isa<FunctionDecl>(Templated) &&
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10996)         !checkAddressOfCandidateIsAvailable(S, cast<FunctionDecl>(Templated)))
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10997)       return;
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 10998) 
2b391ab7086b8 (Faisal Vali              2013-09-26 19:54:12 +0000 10999)     // FIXME: For generic lambda parameters, check if the function is a lambda
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000 11000)     // call operator, and if so, emit a prettier and more informative
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000 11001)     // diagnostic that mentions 'auto' and lambda in addition to
2b391ab7086b8 (Faisal Vali              2013-09-26 19:54:12 +0000 11002)     // (or instead of?) the canonical template type parameters.
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11003)     S.Diag(Templated->getLocation(),
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11004)            diag::note_ovl_candidate_non_deduced_mismatch)
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11005)         << FirstTA << SecondTA;
44ecdbdc6134c (Richard Smith            2013-01-31 05:19:49 +0000 11006)     return;
e373235c7cf8e (Richard Trieu            2013-04-08 21:11:40 +0000 11007)   }
8b9ed55bfbea0 (John McCall              2010-02-01 18:53:26 +0000 11008)   // TODO: diagnose these individually, then kill off
8b9ed55bfbea0 (John McCall              2010-02-01 18:53:26 +0000 11009)   // note_ovl_candidate_bad_deduction, which is uselessly vague.
44ecdbdc6134c (Richard Smith            2013-01-31 05:19:49 +0000 11010)   case Sema::TDK_MiscellaneousDeductionFailure:
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11011)     S.Diag(Templated->getLocation(), diag::note_ovl_candidate_bad_deduction);
5179eb78210a2 (Richard Smith            2016-06-28 19:03:57 +0000 11012)     MaybeEmitInheritedConstructorNote(S, Found);
8b9ed55bfbea0 (John McCall              2010-02-01 18:53:26 +0000 11013)     return;
13e9b4d76851d (Artem Belevich           2016-12-07 19:27:16 +0000 11014)   case Sema::TDK_CUDATargetMismatch:
13e9b4d76851d (Artem Belevich           2016-12-07 19:27:16 +0000 11015)     S.Diag(Templated->getLocation(),
13e9b4d76851d (Artem Belevich           2016-12-07 19:27:16 +0000 11016)            diag::note_cuda_ovl_candidate_target_mismatch);
13e9b4d76851d (Artem Belevich           2016-12-07 19:27:16 +0000 11017)     return;
8b9ed55bfbea0 (John McCall              2010-02-01 18:53:26 +0000 11018)   }
8b9ed55bfbea0 (John McCall              2010-02-01 18:53:26 +0000 11019) }
8b9ed55bfbea0 (John McCall              2010-02-01 18:53:26 +0000 11020) 
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11021) /// Diagnose a failed template-argument deduction, for function calls.
17c00b43288dc (Richard Smith            2014-11-12 01:24:00 +0000 11022) static void DiagnoseBadDeduction(Sema &S, OverloadCandidate *Cand,
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 11023)                                  unsigned NumArgs,
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 11024)                                  bool TakingCandidateAddress) {
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11025)   unsigned TDK = Cand->DeductionFailure.Result;
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11026)   if (TDK == Sema::TDK_TooFewArguments || TDK == Sema::TDK_TooManyArguments) {
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11027)     if (CheckArityMismatch(S, Cand, NumArgs))
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11028)       return;
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11029)   }
c2bebe9acab26 (Richard Smith            2016-05-11 20:37:46 +0000 11030)   DiagnoseBadDeduction(S, Cand->FoundDecl, Cand->Function, // pattern
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 11031)                        Cand->DeductionFailure, NumArgs, TakingCandidateAddress);
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11032) }
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11033) 
7277fe8aed6e1 (Peter Collingbourne      2011-10-02 23:49:40 +0000 11034) /// CUDA: diagnose an invalid call across targets.
17c00b43288dc (Richard Smith            2014-11-12 01:24:00 +0000 11035) static void DiagnoseBadTarget(Sema &S, OverloadCandidate *Cand) {
7277fe8aed6e1 (Peter Collingbourne      2011-10-02 23:49:40 +0000 11036)   FunctionDecl *Caller = cast<FunctionDecl>(S.CurContext);
7277fe8aed6e1 (Peter Collingbourne      2011-10-02 23:49:40 +0000 11037)   FunctionDecl *Callee = Cand->Function;
7277fe8aed6e1 (Peter Collingbourne      2011-10-02 23:49:40 +0000 11038) 
7277fe8aed6e1 (Peter Collingbourne      2011-10-02 23:49:40 +0000 11039)   Sema::CUDAFunctionTarget CallerTarget = S.IdentifyCUDATarget(Caller),
7277fe8aed6e1 (Peter Collingbourne      2011-10-02 23:49:40 +0000 11040)                            CalleeTarget = S.IdentifyCUDATarget(Callee);
7277fe8aed6e1 (Peter Collingbourne      2011-10-02 23:49:40 +0000 11041) 
7277fe8aed6e1 (Peter Collingbourne      2011-10-02 23:49:40 +0000 11042)   std::string FnDesc;
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 11043)   std::pair<OverloadCandidateKind, OverloadCandidateSelect> FnKindPair =
56b5eab12970e (Richard Smith            2019-11-09 05:52:18 -0800 11044)       ClassifyOverloadCandidate(S, Cand->FoundDecl, Callee,
56b5eab12970e (Richard Smith            2019-11-09 05:52:18 -0800 11045)                                 Cand->getRewriteKind(), FnDesc);
7277fe8aed6e1 (Peter Collingbourne      2011-10-02 23:49:40 +0000 11046) 
7277fe8aed6e1 (Peter Collingbourne      2011-10-02 23:49:40 +0000 11047)   S.Diag(Callee->getLocation(), diag::note_ovl_candidate_bad_target)
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 11048)       << (unsigned)FnKindPair.first << (unsigned)ocs_non_template
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 11049)       << FnDesc /* Ignored */
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 11050)       << CalleeTarget << CallerTarget;
9a220fca4a6f0 (Eli Bendersky            2014-09-29 20:38:29 +0000 11051) 
9a220fca4a6f0 (Eli Bendersky            2014-09-29 20:38:29 +0000 11052)   // This could be an implicit constructor for which we could not infer the
9a220fca4a6f0 (Eli Bendersky            2014-09-29 20:38:29 +0000 11053)   // target due to a collsion. Diagnose that case.
9a220fca4a6f0 (Eli Bendersky            2014-09-29 20:38:29 +0000 11054)   CXXMethodDecl *Meth = dyn_cast<CXXMethodDecl>(Callee);
9a220fca4a6f0 (Eli Bendersky            2014-09-29 20:38:29 +0000 11055)   if (Meth != nullptr && Meth->isImplicit()) {
9a220fca4a6f0 (Eli Bendersky            2014-09-29 20:38:29 +0000 11056)     CXXRecordDecl *ParentClass = Meth->getParent();
9a220fca4a6f0 (Eli Bendersky            2014-09-29 20:38:29 +0000 11057)     Sema::CXXSpecialMember CSM;
9a220fca4a6f0 (Eli Bendersky            2014-09-29 20:38:29 +0000 11058) 
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 11059)     switch (FnKindPair.first) {
9a220fca4a6f0 (Eli Bendersky            2014-09-29 20:38:29 +0000 11060)     default:
9a220fca4a6f0 (Eli Bendersky            2014-09-29 20:38:29 +0000 11061)       return;
9a220fca4a6f0 (Eli Bendersky            2014-09-29 20:38:29 +0000 11062)     case oc_implicit_default_constructor:
9a220fca4a6f0 (Eli Bendersky            2014-09-29 20:38:29 +0000 11063)       CSM = Sema::CXXDefaultConstructor;
9a220fca4a6f0 (Eli Bendersky            2014-09-29 20:38:29 +0000 11064)       break;
9a220fca4a6f0 (Eli Bendersky            2014-09-29 20:38:29 +0000 11065)     case oc_implicit_copy_constructor:
9a220fca4a6f0 (Eli Bendersky            2014-09-29 20:38:29 +0000 11066)       CSM = Sema::CXXCopyConstructor;
9a220fca4a6f0 (Eli Bendersky            2014-09-29 20:38:29 +0000 11067)       break;
9a220fca4a6f0 (Eli Bendersky            2014-09-29 20:38:29 +0000 11068)     case oc_implicit_move_constructor:
9a220fca4a6f0 (Eli Bendersky            2014-09-29 20:38:29 +0000 11069)       CSM = Sema::CXXMoveConstructor;
9a220fca4a6f0 (Eli Bendersky            2014-09-29 20:38:29 +0000 11070)       break;
9a220fca4a6f0 (Eli Bendersky            2014-09-29 20:38:29 +0000 11071)     case oc_implicit_copy_assignment:
9a220fca4a6f0 (Eli Bendersky            2014-09-29 20:38:29 +0000 11072)       CSM = Sema::CXXCopyAssignment;
9a220fca4a6f0 (Eli Bendersky            2014-09-29 20:38:29 +0000 11073)       break;
9a220fca4a6f0 (Eli Bendersky            2014-09-29 20:38:29 +0000 11074)     case oc_implicit_move_assignment:
9a220fca4a6f0 (Eli Bendersky            2014-09-29 20:38:29 +0000 11075)       CSM = Sema::CXXMoveAssignment;
9a220fca4a6f0 (Eli Bendersky            2014-09-29 20:38:29 +0000 11076)       break;
9a220fca4a6f0 (Eli Bendersky            2014-09-29 20:38:29 +0000 11077)     };
9a220fca4a6f0 (Eli Bendersky            2014-09-29 20:38:29 +0000 11078) 
9a220fca4a6f0 (Eli Bendersky            2014-09-29 20:38:29 +0000 11079)     bool ConstRHS = false;
9a220fca4a6f0 (Eli Bendersky            2014-09-29 20:38:29 +0000 11080)     if (Meth->getNumParams()) {
9a220fca4a6f0 (Eli Bendersky            2014-09-29 20:38:29 +0000 11081)       if (const ReferenceType *RT =
9a220fca4a6f0 (Eli Bendersky            2014-09-29 20:38:29 +0000 11082)               Meth->getParamDecl(0)->getType()->getAs<ReferenceType>()) {
9a220fca4a6f0 (Eli Bendersky            2014-09-29 20:38:29 +0000 11083)         ConstRHS = RT->getPointeeType().isConstQualified();
9a220fca4a6f0 (Eli Bendersky            2014-09-29 20:38:29 +0000 11084)       }
9a220fca4a6f0 (Eli Bendersky            2014-09-29 20:38:29 +0000 11085)     }
9a220fca4a6f0 (Eli Bendersky            2014-09-29 20:38:29 +0000 11086) 
9a220fca4a6f0 (Eli Bendersky            2014-09-29 20:38:29 +0000 11087)     S.inferCUDATargetForImplicitSpecialMember(ParentClass, CSM, Meth,
9a220fca4a6f0 (Eli Bendersky            2014-09-29 20:38:29 +0000 11088)                                               /* ConstRHS */ ConstRHS,
9a220fca4a6f0 (Eli Bendersky            2014-09-29 20:38:29 +0000 11089)                                               /* Diagnose */ true);
9a220fca4a6f0 (Eli Bendersky            2014-09-29 20:38:29 +0000 11090)   }
7277fe8aed6e1 (Peter Collingbourne      2011-10-02 23:49:40 +0000 11091) }
7277fe8aed6e1 (Peter Collingbourne      2011-10-02 23:49:40 +0000 11092) 
17c00b43288dc (Richard Smith            2014-11-12 01:24:00 +0000 11093) static void DiagnoseFailedEnableIfAttr(Sema &S, OverloadCandidate *Cand) {
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000 11094)   FunctionDecl *Callee = Cand->Function;
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000 11095)   EnableIfAttr *Attr = static_cast<EnableIfAttr*>(Cand->DeductionFailure.Data);
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000 11096) 
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000 11097)   S.Diag(Callee->getLocation(),
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000 11098)          diag::note_ovl_candidate_disabled_by_function_cond_attr)
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000 11099)       << Attr->getCond()->getSourceRange() << Attr->getMessage();
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000 11100) }
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000 11101) 
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000 11102) static void DiagnoseFailedExplicitSpec(Sema &S, OverloadCandidate *Cand) {
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11103)   ExplicitSpecifier ES = ExplicitSpecifier::getFromDecl(Cand->Function);
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11104)   assert(ES.isExplicit() && "not an explicit candidate");
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11105) 
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11106)   unsigned Kind;
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000 11107)   switch (Cand->Function->getDeclKind()) {
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000 11108)   case Decl::Kind::CXXConstructor:
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11109)     Kind = 0;
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000 11110)     break;
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000 11111)   case Decl::Kind::CXXConversion:
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11112)     Kind = 1;
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000 11113)     break;
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000 11114)   case Decl::Kind::CXXDeductionGuide:
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11115)     Kind = Cand->Function->isImplicit() ? 0 : 2;
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000 11116)     break;
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000 11117)   default:
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000 11118)     llvm_unreachable("invalid Decl");
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000 11119)   }
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11120) 
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11121)   // Note the location of the first (in-class) declaration; a redeclaration
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11122)   // (particularly an out-of-class definition) will typically lack the
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11123)   // 'explicit' specifier.
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11124)   // FIXME: This is probably a good thing to do for all 'candidate' notes.
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11125)   FunctionDecl *First = Cand->Function->getFirstDecl();
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11126)   if (FunctionDecl *Pattern = First->getTemplateInstantiationPattern())
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11127)     First = Pattern->getFirstDecl();
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11128) 
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11129)   S.Diag(First->getLocation(),
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11130)          diag::note_ovl_candidate_explicit)
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11131)       << Kind << (ES.getExpr() ? 1 : 0)
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11132)       << (ES.getExpr() ? ES.getExpr()->getSourceRange() : SourceRange());
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000 11133) }
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000 11134) 
8b9ed55bfbea0 (John McCall              2010-02-01 18:53:26 +0000 11135) /// Generates a 'note' diagnostic for an overload candidate.  We've
8b9ed55bfbea0 (John McCall              2010-02-01 18:53:26 +0000 11136) /// already generated a primary error at the call site.
8b9ed55bfbea0 (John McCall              2010-02-01 18:53:26 +0000 11137) ///
8b9ed55bfbea0 (John McCall              2010-02-01 18:53:26 +0000 11138) /// It really does need to be a single diagnostic with its caret
8b9ed55bfbea0 (John McCall              2010-02-01 18:53:26 +0000 11139) /// pointed at the candidate declaration.  Yes, this creates some
8b9ed55bfbea0 (John McCall              2010-02-01 18:53:26 +0000 11140) /// major challenges of technical writing.  Yes, this makes pointing
8b9ed55bfbea0 (John McCall              2010-02-01 18:53:26 +0000 11141) /// out problems with specific arguments quite awkward.  It's still
8b9ed55bfbea0 (John McCall              2010-02-01 18:53:26 +0000 11142) /// better than generating twenty screens of text for every failed
8b9ed55bfbea0 (John McCall              2010-02-01 18:53:26 +0000 11143) /// overload.
8b9ed55bfbea0 (John McCall              2010-02-01 18:53:26 +0000 11144) ///
8b9ed55bfbea0 (John McCall              2010-02-01 18:53:26 +0000 11145) /// It would be great to be able to express per-candidate problems
8b9ed55bfbea0 (John McCall              2010-02-01 18:53:26 +0000 11146) /// more richly for those diagnostic clients that cared, but we'd
8b9ed55bfbea0 (John McCall              2010-02-01 18:53:26 +0000 11147) /// still have to be just as careful with the default diagnostics.
c25ea86d43929 (Anastasia Stulova        2019-06-20 16:23:28 +0000 11148) /// \param CtorDestAS Addr space of object being constructed (for ctor
c25ea86d43929 (Anastasia Stulova        2019-06-20 16:23:28 +0000 11149) /// candidates only).
17c00b43288dc (Richard Smith            2014-11-12 01:24:00 +0000 11150) static void NoteFunctionCandidate(Sema &S, OverloadCandidate *Cand,
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 11151)                                   unsigned NumArgs,
c25ea86d43929 (Anastasia Stulova        2019-06-20 16:23:28 +0000 11152)                                   bool TakingCandidateAddress,
c25ea86d43929 (Anastasia Stulova        2019-06-20 16:23:28 +0000 11153)                                   LangAS CtorDestAS = LangAS::Default) {
53262c96d9a90 (John McCall              2010-01-12 02:15:36 +0000 11154)   FunctionDecl *Fn = Cand->Function;
6976fef05b7e5 (Erich Keane              2020-11-16 15:26:22 -0800 11155)   if (shouldSkipNotingLambdaConversionDecl(Fn))
6976fef05b7e5 (Erich Keane              2020-11-16 15:26:22 -0800 11156)     return;
53262c96d9a90 (John McCall              2010-01-12 02:15:36 +0000 11157) 
12f97bc48ad40 (John McCall              2010-01-08 04:41:39 +0000 11158)   // Note deleted candidates, but only if they're viable.
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000 11159)   if (Cand->Viable) {
13ee62f7d7eed (Erik Pilkington          2019-03-20 19:26:33 +0000 11160)     if (Fn->isDeleted()) {
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000 11161)       std::string FnDesc;
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 11162)       std::pair<OverloadCandidateKind, OverloadCandidateSelect> FnKindPair =
56b5eab12970e (Richard Smith            2019-11-09 05:52:18 -0800 11163)           ClassifyOverloadCandidate(S, Cand->FoundDecl, Fn,
56b5eab12970e (Richard Smith            2019-11-09 05:52:18 -0800 11164)                                     Cand->getRewriteKind(), FnDesc);
12f97bc48ad40 (John McCall              2010-01-08 04:41:39 +0000 11165) 
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000 11166)       S.Diag(Fn->getLocation(), diag::note_ovl_candidate_deleted)
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 11167)           << (unsigned)FnKindPair.first << (unsigned)FnKindPair.second << FnDesc
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 11168)           << (Fn->isDeleted() ? (Fn->isDeletedAsWritten() ? 1 : 2) : 0);
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000 11169)       MaybeEmitInheritedConstructorNote(S, Cand->FoundDecl);
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000 11170)       return;
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000 11171)     }
e1ac8d1742209 (John McCall              2010-01-13 00:25:19 +0000 11172) 
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000 11173)     // We don't really have anything else to say about viable candidates.
56b5eab12970e (Richard Smith            2019-11-09 05:52:18 -0800 11174)     S.NoteOverloadCandidate(Cand->FoundDecl, Fn, Cand->getRewriteKind());
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11175)     return;
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11176)   }
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11177) 
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000 11178)   switch (Cand->FailureKind) {
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000 11179)   case ovl_fail_too_many_arguments:
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000 11180)   case ovl_fail_too_few_arguments:
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000 11181)     return DiagnoseArityMismatch(S, Cand, NumArgs);
e1ac8d1742209 (John McCall              2010-01-13 00:25:19 +0000 11182) 
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000 11183)   case ovl_fail_bad_deduction:
c2bebe9acab26 (Richard Smith            2016-05-11 20:37:46 +0000 11184)     return DiagnoseBadDeduction(S, Cand, NumArgs,
c2bebe9acab26 (Richard Smith            2016-05-11 20:37:46 +0000 11185)                                 TakingCandidateAddress);
8b9ed55bfbea0 (John McCall              2010-02-01 18:53:26 +0000 11186) 
578a1f8c6d275 (John McCall              2014-12-14 01:46:53 +0000 11187)   case ovl_fail_illegal_constructor: {
578a1f8c6d275 (John McCall              2014-12-14 01:46:53 +0000 11188)     S.Diag(Fn->getLocation(), diag::note_ovl_candidate_illegal_constructor)
578a1f8c6d275 (John McCall              2014-12-14 01:46:53 +0000 11189)       << (Fn->getPrimaryTemplate() ? 1 : 0);
5179eb78210a2 (Richard Smith            2016-06-28 19:03:57 +0000 11190)     MaybeEmitInheritedConstructorNote(S, Cand->FoundDecl);
578a1f8c6d275 (John McCall              2014-12-14 01:46:53 +0000 11191)     return;
578a1f8c6d275 (John McCall              2014-12-14 01:46:53 +0000 11192)   }
578a1f8c6d275 (John McCall              2014-12-14 01:46:53 +0000 11193) 
c25ea86d43929 (Anastasia Stulova        2019-06-20 16:23:28 +0000 11194)   case ovl_fail_object_addrspace_mismatch: {
c25ea86d43929 (Anastasia Stulova        2019-06-20 16:23:28 +0000 11195)     Qualifiers QualsForPrinting;
c25ea86d43929 (Anastasia Stulova        2019-06-20 16:23:28 +0000 11196)     QualsForPrinting.setAddressSpace(CtorDestAS);
c25ea86d43929 (Anastasia Stulova        2019-06-20 16:23:28 +0000 11197)     S.Diag(Fn->getLocation(),
c25ea86d43929 (Anastasia Stulova        2019-06-20 16:23:28 +0000 11198)            diag::note_ovl_candidate_illegal_constructor_adrspace_mismatch)
c25ea86d43929 (Anastasia Stulova        2019-06-20 16:23:28 +0000 11199)         << QualsForPrinting;
c25ea86d43929 (Anastasia Stulova        2019-06-20 16:23:28 +0000 11200)     MaybeEmitInheritedConstructorNote(S, Cand->FoundDecl);
c25ea86d43929 (Anastasia Stulova        2019-06-20 16:23:28 +0000 11201)     return;
c25ea86d43929 (Anastasia Stulova        2019-06-20 16:23:28 +0000 11202)   }
c25ea86d43929 (Anastasia Stulova        2019-06-20 16:23:28 +0000 11203) 
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11204)   case ovl_fail_trivial_conversion:
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11205)   case ovl_fail_bad_final_conversion:
2c326bce387c8 (Douglas Gregor           2010-04-12 23:42:09 +0000 11206)   case ovl_fail_final_conversion_not_exact:
56b5eab12970e (Richard Smith            2019-11-09 05:52:18 -0800 11207)     return S.NoteOverloadCandidate(Cand->FoundDecl, Fn, Cand->getRewriteKind());
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000 11208) 
65eb879d22cc9 (John McCall              2010-02-25 01:37:24 +0000 11209)   case ovl_fail_bad_conversion: {
65eb879d22cc9 (John McCall              2010-02-25 01:37:24 +0000 11210)     unsigned I = (Cand->IgnoreObjectArgument ? 1 : 0);
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000 11211)     for (unsigned N = Cand->Conversions.size(); I != N; ++I)
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000 11212)       if (Cand->Conversions[I].isBad())
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 11213)         return DiagnoseBadConversion(S, Cand, I, TakingCandidateAddress);
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 11214) 
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000 11215)     // FIXME: this currently happens when we're called from SemaInit
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000 11216)     // when user-conversion overload fails.  Figure out how to handle
6a61b5203dc68 (John McCall              2010-01-13 09:16:55 +0000 11217)     // those conditions and diagnose them well.
56b5eab12970e (Richard Smith            2019-11-09 05:52:18 -0800 11218)     return S.NoteOverloadCandidate(Cand->FoundDecl, Fn, Cand->getRewriteKind());
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11219)   }
7277fe8aed6e1 (Peter Collingbourne      2011-10-02 23:49:40 +0000 11220) 
7277fe8aed6e1 (Peter Collingbourne      2011-10-02 23:49:40 +0000 11221)   case ovl_fail_bad_target:
7277fe8aed6e1 (Peter Collingbourne      2011-10-02 23:49:40 +0000 11222)     return DiagnoseBadTarget(S, Cand);
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000 11223) 
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000 11224)   case ovl_fail_enable_if:
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000 11225)     return DiagnoseFailedEnableIfAttr(S, Cand);
7204ed97dd930 (George Burgess IV        2016-01-07 02:26:57 +0000 11226) 
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11227)   case ovl_fail_explicit:
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000 11228)     return DiagnoseFailedExplicitSpec(S, Cand);
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000 11229) 
f9c59b71220ce (Richard Smith            2017-01-08 21:45:44 +0000 11230)   case ovl_fail_inhctor_slice:
836a3b416d222 (Richard Smith            2017-01-13 20:46:54 +0000 11231)     // It's generally not interesting to note copy/move constructors here.
836a3b416d222 (Richard Smith            2017-01-13 20:46:54 +0000 11232)     if (cast<CXXConstructorDecl>(Fn)->isCopyOrMoveConstructor())
836a3b416d222 (Richard Smith            2017-01-13 20:46:54 +0000 11233)       return;
f9c59b71220ce (Richard Smith            2017-01-08 21:45:44 +0000 11234)     S.Diag(Fn->getLocation(),
836a3b416d222 (Richard Smith            2017-01-13 20:46:54 +0000 11235)            diag::note_ovl_candidate_inherited_constructor_slice)
836a3b416d222 (Richard Smith            2017-01-13 20:46:54 +0000 11236)       << (Fn->getPrimaryTemplate() ? 1 : 0)
836a3b416d222 (Richard Smith            2017-01-13 20:46:54 +0000 11237)       << Fn->getParamDecl(0)->getType()->isRValueReferenceType();
f9c59b71220ce (Richard Smith            2017-01-08 21:45:44 +0000 11238)     MaybeEmitInheritedConstructorNote(S, Cand->FoundDecl);
f9c59b71220ce (Richard Smith            2017-01-08 21:45:44 +0000 11239)     return;
f9c59b71220ce (Richard Smith            2017-01-08 21:45:44 +0000 11240) 
7204ed97dd930 (George Burgess IV        2016-01-07 02:26:57 +0000 11241)   case ovl_fail_addr_not_available: {
7204ed97dd930 (George Burgess IV        2016-01-07 02:26:57 +0000 11242)     bool Available = checkAddressOfCandidateIsAvailable(S, Cand->Function);
7204ed97dd930 (George Burgess IV        2016-01-07 02:26:57 +0000 11243)     (void)Available;
7204ed97dd930 (George Burgess IV        2016-01-07 02:26:57 +0000 11244)     assert(!Available);
7204ed97dd930 (George Burgess IV        2016-01-07 02:26:57 +0000 11245)     break;
7204ed97dd930 (George Burgess IV        2016-01-07 02:26:57 +0000 11246)   }
281d20b601c8a (Erich Keane              2018-01-08 21:34:17 +0000 11247)   case ovl_non_default_multiversion_function:
281d20b601c8a (Erich Keane              2018-01-08 21:34:17 +0000 11248)     // Do nothing, these should simply be ignored.
281d20b601c8a (Erich Keane              2018-01-08 21:34:17 +0000 11249)     break;
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 11250) 
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 11251)   case ovl_fail_constraints_not_satisfied: {
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 11252)     std::string FnDesc;
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 11253)     std::pair<OverloadCandidateKind, OverloadCandidateSelect> FnKindPair =
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 11254)         ClassifyOverloadCandidate(S, Cand->FoundDecl, Fn,
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 11255)                                   Cand->getRewriteKind(), FnDesc);
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 11256) 
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 11257)     S.Diag(Fn->getLocation(),
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 11258)            diag::note_ovl_candidate_constraints_not_satisfied)
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 11259)         << (unsigned)FnKindPair.first << (unsigned)ocs_non_template
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 11260)         << FnDesc /* Ignored */;
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 11261)     ConstraintSatisfaction Satisfaction;
713562f54858f (Saar Raz                 2020-01-25 22:54:27 +0200 11262)     if (S.CheckFunctionConstraints(Fn, Satisfaction))
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 11263)       break;
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 11264)     S.DiagnoseUnsatisfiedConstraint(Satisfaction);
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 11265)   }
65eb879d22cc9 (John McCall              2010-02-25 01:37:24 +0000 11266)   }
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11267) }
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11268) 
17c00b43288dc (Richard Smith            2014-11-12 01:24:00 +0000 11269) static void NoteSurrogateCandidate(Sema &S, OverloadCandidate *Cand) {
6976fef05b7e5 (Erich Keane              2020-11-16 15:26:22 -0800 11270)   if (shouldSkipNotingLambdaConversionDecl(Cand->Surrogate))
6976fef05b7e5 (Erich Keane              2020-11-16 15:26:22 -0800 11271)     return;
6976fef05b7e5 (Erich Keane              2020-11-16 15:26:22 -0800 11272) 
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11273)   // Desugar the type of the surrogate down to a function type,
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11274)   // retaining as many typedefs as possible while still showing
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11275)   // the function type (and, therefore, its parameter types).
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11276)   QualType FnType = Cand->Surrogate->getConversionType();
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11277)   bool isLValueReference = false;
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11278)   bool isRValueReference = false;
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11279)   bool isPointer = false;
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11280)   if (const LValueReferenceType *FnTypeRef =
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11281)         FnType->getAs<LValueReferenceType>()) {
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11282)     FnType = FnTypeRef->getPointeeType();
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11283)     isLValueReference = true;
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11284)   } else if (const RValueReferenceType *FnTypeRef =
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11285)                FnType->getAs<RValueReferenceType>()) {
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11286)     FnType = FnTypeRef->getPointeeType();
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11287)     isRValueReference = true;
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11288)   }
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11289)   if (const PointerType *FnTypePtr = FnType->getAs<PointerType>()) {
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11290)     FnType = FnTypePtr->getPointeeType();
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11291)     isPointer = true;
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11292)   }
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11293)   // Desugar down to a function type.
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11294)   FnType = QualType(FnType->getAs<FunctionType>(), 0);
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11295)   // Reconstruct the pointer/reference as appropriate.
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11296)   if (isPointer) FnType = S.Context.getPointerType(FnType);
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11297)   if (isRValueReference) FnType = S.Context.getRValueReferenceType(FnType);
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11298)   if (isLValueReference) FnType = S.Context.getLValueReferenceType(FnType);
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11299) 
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11300)   S.Diag(Cand->Surrogate->getLocation(), diag::note_ovl_surrogate_cand)
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11301)     << FnType;
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11302) }
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11303) 
17c00b43288dc (Richard Smith            2014-11-12 01:24:00 +0000 11304) static void NoteBuiltinOperatorCandidate(Sema &S, StringRef Opc,
17c00b43288dc (Richard Smith            2014-11-12 01:24:00 +0000 11305)                                          SourceLocation OpLoc,
17c00b43288dc (Richard Smith            2014-11-12 01:24:00 +0000 11306)                                          OverloadCandidate *Cand) {
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000 11307)   assert(Cand->Conversions.size() <= 2 && "builtin operator is not binary");
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11308)   std::string TypeStr("operator");
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11309)   TypeStr += Opc;
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11310)   TypeStr += "(";
5f6ab9a8bf307 (George Burgess IV        2017-06-08 20:55:21 +0000 11311)   TypeStr += Cand->BuiltinParamTypes[0].getAsString();
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000 11312)   if (Cand->Conversions.size() == 1) {
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11313)     TypeStr += ")";
783fc95f3eedf (Sven van Haastregt       2019-09-09 14:39:20 +0000 11314)     S.Diag(OpLoc, diag::note_ovl_builtin_candidate) << TypeStr;
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11315)   } else {
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11316)     TypeStr += ", ";
5f6ab9a8bf307 (George Burgess IV        2017-06-08 20:55:21 +0000 11317)     TypeStr += Cand->BuiltinParamTypes[1].getAsString();
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11318)     TypeStr += ")";
783fc95f3eedf (Sven van Haastregt       2019-09-09 14:39:20 +0000 11319)     S.Diag(OpLoc, diag::note_ovl_builtin_candidate) << TypeStr;
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11320)   }
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11321) }
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11322) 
17c00b43288dc (Richard Smith            2014-11-12 01:24:00 +0000 11323) static void NoteAmbiguousUserConversions(Sema &S, SourceLocation OpLoc,
17c00b43288dc (Richard Smith            2014-11-12 01:24:00 +0000 11324)                                          OverloadCandidate *Cand) {
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000 11325)   for (const ImplicitConversionSequence &ICS : Cand->Conversions) {
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000 11326)     if (ICS.isBad()) break; // all meaningless after first invalid
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000 11327)     if (!ICS.isAmbiguous()) continue;
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000 11328) 
c2bebe9acab26 (Richard Smith            2016-05-11 20:37:46 +0000 11329)     ICS.DiagnoseAmbiguousConversion(
c2bebe9acab26 (Richard Smith            2016-05-11 20:37:46 +0000 11330)         S, OpLoc, S.PDiag(diag::note_ambiguous_type_conversion));
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11331)   }
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11332) }
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11333) 
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11334) static SourceLocation GetLocationForCandidate(const OverloadCandidate *Cand) {
3712d9e391523 (John McCall              2010-01-15 23:32:50 +0000 11335)   if (Cand->Function)
3712d9e391523 (John McCall              2010-01-15 23:32:50 +0000 11336)     return Cand->Function->getLocation();
982adb518c34b (John McCall              2010-01-16 03:50:16 +0000 11337)   if (Cand->IsSurrogate)
3712d9e391523 (John McCall              2010-01-15 23:32:50 +0000 11338)     return Cand->Surrogate->getLocation();
3712d9e391523 (John McCall              2010-01-15 23:32:50 +0000 11339)   return SourceLocation();
3712d9e391523 (John McCall              2010-01-15 23:32:50 +0000 11340) }
3712d9e391523 (John McCall              2010-01-15 23:32:50 +0000 11341) 
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11342) static unsigned RankDeductionFailure(const DeductionFailureInfo &DFI) {
73fddfe1b0d51 (Chandler Carruth         2011-09-10 00:51:24 +0000 11343)   switch ((Sema::TemplateDeductionResult)DFI.Result) {
45e9370a24f15 (Kaelyn Uhrain            2011-09-09 21:58:49 +0000 11344)   case Sema::TDK_Success:
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000 11345)   case Sema::TDK_NonDependentConversionFailure:
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000 11346)     llvm_unreachable("non-deduction failure while diagnosing bad deduction");
8a8051f2cdfcc (Benjamin Kramer          2011-09-10 21:52:04 +0000 11347) 
c5c01a60c2e3f (Douglas Gregor           2012-09-13 21:01:57 +0000 11348)   case Sema::TDK_Invalid:
45e9370a24f15 (Kaelyn Uhrain            2011-09-09 21:58:49 +0000 11349)   case Sema::TDK_Incomplete:
4a8f3518cb144 (Richard Smith            2018-07-19 19:00:37 +0000 11350)   case Sema::TDK_IncompletePack:
45e9370a24f15 (Kaelyn Uhrain            2011-09-09 21:58:49 +0000 11351)     return 1;
45e9370a24f15 (Kaelyn Uhrain            2011-09-09 21:58:49 +0000 11352) 
45e9370a24f15 (Kaelyn Uhrain            2011-09-09 21:58:49 +0000 11353)   case Sema::TDK_Underqualified:
45e9370a24f15 (Kaelyn Uhrain            2011-09-09 21:58:49 +0000 11354)   case Sema::TDK_Inconsistent:
45e9370a24f15 (Kaelyn Uhrain            2011-09-09 21:58:49 +0000 11355)     return 2;
45e9370a24f15 (Kaelyn Uhrain            2011-09-09 21:58:49 +0000 11356) 
45e9370a24f15 (Kaelyn Uhrain            2011-09-09 21:58:49 +0000 11357)   case Sema::TDK_SubstitutionFailure:
9b534547250a3 (Richard Smith            2015-12-31 02:02:54 +0000 11358)   case Sema::TDK_DeducedMismatch:
fdf80e86a5284 (Saar Raz                 2019-12-06 01:30:21 +0200 11359)   case Sema::TDK_ConstraintsNotSatisfied:
c92d206ce4419 (Richard Smith            2017-01-05 23:02:44 +0000 11360)   case Sema::TDK_DeducedMismatchNested:
45e9370a24f15 (Kaelyn Uhrain            2011-09-09 21:58:49 +0000 11361)   case Sema::TDK_NonDeducedMismatch:
44ecdbdc6134c (Richard Smith            2013-01-31 05:19:49 +0000 11362)   case Sema::TDK_MiscellaneousDeductionFailure:
13e9b4d76851d (Artem Belevich           2016-12-07 19:27:16 +0000 11363)   case Sema::TDK_CUDATargetMismatch:
45e9370a24f15 (Kaelyn Uhrain            2011-09-09 21:58:49 +0000 11364)     return 3;
45e9370a24f15 (Kaelyn Uhrain            2011-09-09 21:58:49 +0000 11365) 
45e9370a24f15 (Kaelyn Uhrain            2011-09-09 21:58:49 +0000 11366)   case Sema::TDK_InstantiationDepth:
45e9370a24f15 (Kaelyn Uhrain            2011-09-09 21:58:49 +0000 11367)     return 4;
45e9370a24f15 (Kaelyn Uhrain            2011-09-09 21:58:49 +0000 11368) 
45e9370a24f15 (Kaelyn Uhrain            2011-09-09 21:58:49 +0000 11369)   case Sema::TDK_InvalidExplicitArguments:
45e9370a24f15 (Kaelyn Uhrain            2011-09-09 21:58:49 +0000 11370)     return 5;
45e9370a24f15 (Kaelyn Uhrain            2011-09-09 21:58:49 +0000 11371) 
45e9370a24f15 (Kaelyn Uhrain            2011-09-09 21:58:49 +0000 11372)   case Sema::TDK_TooManyArguments:
45e9370a24f15 (Kaelyn Uhrain            2011-09-09 21:58:49 +0000 11373)   case Sema::TDK_TooFewArguments:
45e9370a24f15 (Kaelyn Uhrain            2011-09-09 21:58:49 +0000 11374)     return 6;
45e9370a24f15 (Kaelyn Uhrain            2011-09-09 21:58:49 +0000 11375)   }
8a8051f2cdfcc (Benjamin Kramer          2011-09-10 21:52:04 +0000 11376)   llvm_unreachable("Unhandled deduction result");
45e9370a24f15 (Kaelyn Uhrain            2011-09-09 21:58:49 +0000 11377) }
45e9370a24f15 (Kaelyn Uhrain            2011-09-09 21:58:49 +0000 11378) 
17c00b43288dc (Richard Smith            2014-11-12 01:24:00 +0000 11379) namespace {
ad2587a394059 (John McCall              2010-01-12 00:48:53 +0000 11380) struct CompareOverloadCandidatesForDisplay {
ad2587a394059 (John McCall              2010-01-12 00:48:53 +0000 11381)   Sema &S;
0f59cb38e7f31 (Richard Smith            2015-12-18 21:45:41 +0000 11382)   SourceLocation Loc;
b96b3be8996bb (Kaelyn Takata            2014-05-01 21:15:24 +0000 11383)   size_t NumArgs;
67ef14fe486e1 (Richard Smith            2017-09-26 18:37:55 +0000 11384)   OverloadCandidateSet::CandidateSetKind CSK;
b96b3be8996bb (Kaelyn Takata            2014-05-01 21:15:24 +0000 11385) 
67ef14fe486e1 (Richard Smith            2017-09-26 18:37:55 +0000 11386)   CompareOverloadCandidatesForDisplay(
67ef14fe486e1 (Richard Smith            2017-09-26 18:37:55 +0000 11387)       Sema &S, SourceLocation Loc, size_t NArgs,
67ef14fe486e1 (Richard Smith            2017-09-26 18:37:55 +0000 11388)       OverloadCandidateSet::CandidateSetKind CSK)
fd54435b95922 (Richard Smith            2017-09-26 21:33:43 +0000 11389)       : S(S), NumArgs(NArgs), CSK(CSK) {}
12f97bc48ad40 (John McCall              2010-01-08 04:41:39 +0000 11390) 
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11391)   OverloadFailureKind EffectiveFailureKind(const OverloadCandidate *C) const {
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11392)     // If there are too many or too few arguments, that's the high-order bit we
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11393)     // want to sort by, even if the immediate failure kind was something else.
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11394)     if (C->FailureKind == ovl_fail_too_many_arguments ||
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11395)         C->FailureKind == ovl_fail_too_few_arguments)
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11396)       return static_cast<OverloadFailureKind>(C->FailureKind);
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11397) 
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11398)     if (C->Function) {
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11399)       if (NumArgs > C->Function->getNumParams() && !C->Function->isVariadic())
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11400)         return ovl_fail_too_many_arguments;
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11401)       if (NumArgs < C->Function->getMinRequiredArguments())
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11402)         return ovl_fail_too_few_arguments;
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11403)     }
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11404) 
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11405)     return static_cast<OverloadFailureKind>(C->FailureKind);
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11406)   }
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11407) 
12f97bc48ad40 (John McCall              2010-01-08 04:41:39 +0000 11408)   bool operator()(const OverloadCandidate *L,
12f97bc48ad40 (John McCall              2010-01-08 04:41:39 +0000 11409)                   const OverloadCandidate *R) {
982adb518c34b (John McCall              2010-01-16 03:50:16 +0000 11410)     // Fast-path this check.
982adb518c34b (John McCall              2010-01-16 03:50:16 +0000 11411)     if (L == R) return false;
982adb518c34b (John McCall              2010-01-16 03:50:16 +0000 11412) 
12f97bc48ad40 (John McCall              2010-01-08 04:41:39 +0000 11413)     // Order first by viability.
ad2587a394059 (John McCall              2010-01-12 00:48:53 +0000 11414)     if (L->Viable) {
ad2587a394059 (John McCall              2010-01-12 00:48:53 +0000 11415)       if (!R->Viable) return true;
ad2587a394059 (John McCall              2010-01-12 00:48:53 +0000 11416) 
ad2587a394059 (John McCall              2010-01-12 00:48:53 +0000 11417)       // TODO: introduce a tri-valued comparison for overload
ad2587a394059 (John McCall              2010-01-12 00:48:53 +0000 11418)       // candidates.  Would be more worthwhile if we had a sort
ad2587a394059 (John McCall              2010-01-12 00:48:53 +0000 11419)       // that could exploit it.
67ef14fe486e1 (Richard Smith            2017-09-26 18:37:55 +0000 11420)       if (isBetterOverloadCandidate(S, *L, *R, SourceLocation(), CSK))
67ef14fe486e1 (Richard Smith            2017-09-26 18:37:55 +0000 11421)         return true;
67ef14fe486e1 (Richard Smith            2017-09-26 18:37:55 +0000 11422)       if (isBetterOverloadCandidate(S, *R, *L, SourceLocation(), CSK))
67ef14fe486e1 (Richard Smith            2017-09-26 18:37:55 +0000 11423)         return false;
ad2587a394059 (John McCall              2010-01-12 00:48:53 +0000 11424)     } else if (R->Viable)
ad2587a394059 (John McCall              2010-01-12 00:48:53 +0000 11425)       return false;
12f97bc48ad40 (John McCall              2010-01-08 04:41:39 +0000 11426) 
3712d9e391523 (John McCall              2010-01-15 23:32:50 +0000 11427)     assert(L->Viable == R->Viable);
3712d9e391523 (John McCall              2010-01-15 23:32:50 +0000 11428) 
3712d9e391523 (John McCall              2010-01-15 23:32:50 +0000 11429)     // Criteria by which we can sort non-viable candidates:
3712d9e391523 (John McCall              2010-01-15 23:32:50 +0000 11430)     if (!L->Viable) {
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11431)       OverloadFailureKind LFailureKind = EffectiveFailureKind(L);
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11432)       OverloadFailureKind RFailureKind = EffectiveFailureKind(R);
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11433) 
3712d9e391523 (John McCall              2010-01-15 23:32:50 +0000 11434)       // 1. Arity mismatches come after other candidates.
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11435)       if (LFailureKind == ovl_fail_too_many_arguments ||
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11436)           LFailureKind == ovl_fail_too_few_arguments) {
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11437)         if (RFailureKind == ovl_fail_too_many_arguments ||
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11438)             RFailureKind == ovl_fail_too_few_arguments) {
50c4ffcca78e0 (Kaelyn Takata            2014-05-07 00:43:38 +0000 11439)           int LDist = std::abs((int)L->getNumParams() - (int)NumArgs);
50c4ffcca78e0 (Kaelyn Takata            2014-05-07 00:43:38 +0000 11440)           int RDist = std::abs((int)R->getNumParams() - (int)NumArgs);
50c4ffcca78e0 (Kaelyn Takata            2014-05-07 00:43:38 +0000 11441)           if (LDist == RDist) {
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11442)             if (LFailureKind == RFailureKind)
50c4ffcca78e0 (Kaelyn Takata            2014-05-07 00:43:38 +0000 11443)               // Sort non-surrogates before surrogates.
50c4ffcca78e0 (Kaelyn Takata            2014-05-07 00:43:38 +0000 11444)               return !L->IsSurrogate && R->IsSurrogate;
50c4ffcca78e0 (Kaelyn Takata            2014-05-07 00:43:38 +0000 11445)             // Sort candidates requiring fewer parameters than there were
50c4ffcca78e0 (Kaelyn Takata            2014-05-07 00:43:38 +0000 11446)             // arguments given after candidates requiring more parameters
50c4ffcca78e0 (Kaelyn Takata            2014-05-07 00:43:38 +0000 11447)             // than there were arguments given.
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11448)             return LFailureKind == ovl_fail_too_many_arguments;
50c4ffcca78e0 (Kaelyn Takata            2014-05-07 00:43:38 +0000 11449)           }
b96b3be8996bb (Kaelyn Takata            2014-05-01 21:15:24 +0000 11450)           return LDist < RDist;
b96b3be8996bb (Kaelyn Takata            2014-05-01 21:15:24 +0000 11451)         }
3712d9e391523 (John McCall              2010-01-15 23:32:50 +0000 11452)         return false;
b96b3be8996bb (Kaelyn Takata            2014-05-01 21:15:24 +0000 11453)       }
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11454)       if (RFailureKind == ovl_fail_too_many_arguments ||
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11455)           RFailureKind == ovl_fail_too_few_arguments)
3712d9e391523 (John McCall              2010-01-15 23:32:50 +0000 11456)         return true;
3712d9e391523 (John McCall              2010-01-15 23:32:50 +0000 11457) 
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11458)       // 2. Bad conversions come first and are ordered by the number
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11459)       // of bad conversions and quality of good conversions.
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11460)       if (LFailureKind == ovl_fail_bad_conversion) {
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11461)         if (RFailureKind != ovl_fail_bad_conversion)
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11462)           return true;
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11463) 
df92ddf8466bf (Anna Zaks                2011-07-19 19:49:12 +0000 11464)         // The conversion that can be fixed with a smaller number of changes,
df92ddf8466bf (Anna Zaks                2011-07-19 19:49:12 +0000 11465)         // comes first.
df92ddf8466bf (Anna Zaks                2011-07-19 19:49:12 +0000 11466)         unsigned numLFixes = L->Fix.NumConversionsFixed;
df92ddf8466bf (Anna Zaks                2011-07-19 19:49:12 +0000 11467)         unsigned numRFixes = R->Fix.NumConversionsFixed;
df92ddf8466bf (Anna Zaks                2011-07-19 19:49:12 +0000 11468)         numLFixes = (numLFixes == 0) ? UINT_MAX : numLFixes;
df92ddf8466bf (Anna Zaks                2011-07-19 19:49:12 +0000 11469)         numRFixes = (numRFixes == 0) ? UINT_MAX : numRFixes;
9ccf84e35dcf4 (Anna Zaks                2011-07-21 00:34:39 +0000 11470)         if (numLFixes != numRFixes) {
7a3cbb299772b (David Blaikie            2015-03-09 02:02:07 +0000 11471)           return numLFixes < numRFixes;
9ccf84e35dcf4 (Anna Zaks                2011-07-21 00:34:39 +0000 11472)         }
df92ddf8466bf (Anna Zaks                2011-07-19 19:49:12 +0000 11473) 
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11474)         // If there's any ordering between the defined conversions...
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11475)         // FIXME: this might not be transitive.
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000 11476)         assert(L->Conversions.size() == R->Conversions.size());
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11477) 
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11478)         int leftBetter = 0;
21b57fa4e5f1b (John McCall              2010-02-25 10:46:05 +0000 11479)         unsigned I = (L->IgnoreObjectArgument || R->IgnoreObjectArgument);
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000 11480)         for (unsigned E = L->Conversions.size(); I != E; ++I) {
0f59cb38e7f31 (Richard Smith            2015-12-18 21:45:41 +0000 11481)           switch (CompareImplicitConversionSequences(S, Loc,
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000 11482)                                                      L->Conversions[I],
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000 11483)                                                      R->Conversions[I])) {
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11484)           case ImplicitConversionSequence::Better:
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11485)             leftBetter++;
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11486)             break;
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11487) 
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11488)           case ImplicitConversionSequence::Worse:
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11489)             leftBetter--;
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11490)             break;
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11491) 
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11492)           case ImplicitConversionSequence::Indistinguishable:
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11493)             break;
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11494)           }
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11495)         }
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11496)         if (leftBetter > 0) return true;
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11497)         if (leftBetter < 0) return false;
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11498) 
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11499)       } else if (RFailureKind == ovl_fail_bad_conversion)
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11500)         return false;
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11501) 
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11502)       if (LFailureKind == ovl_fail_bad_deduction) {
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11503)         if (RFailureKind != ovl_fail_bad_deduction)
45e9370a24f15 (Kaelyn Uhrain            2011-09-09 21:58:49 +0000 11504)           return true;
45e9370a24f15 (Kaelyn Uhrain            2011-09-09 21:58:49 +0000 11505) 
45e9370a24f15 (Kaelyn Uhrain            2011-09-09 21:58:49 +0000 11506)         if (L->DeductionFailure.Result != R->DeductionFailure.Result)
45e9370a24f15 (Kaelyn Uhrain            2011-09-09 21:58:49 +0000 11507)           return RankDeductionFailure(L->DeductionFailure)
1e7a0c6a1d4f5 (Eli Friedman             2011-10-14 23:10:30 +0000 11508)                < RankDeductionFailure(R->DeductionFailure);
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11509)       } else if (RFailureKind == ovl_fail_bad_deduction)
e2c600cf4342a (Eli Friedman             2011-10-14 21:52:24 +0000 11510)         return false;
45e9370a24f15 (Kaelyn Uhrain            2011-09-09 21:58:49 +0000 11511) 
3712d9e391523 (John McCall              2010-01-15 23:32:50 +0000 11512)       // TODO: others?
3712d9e391523 (John McCall              2010-01-15 23:32:50 +0000 11513)     }
3712d9e391523 (John McCall              2010-01-15 23:32:50 +0000 11514) 
3712d9e391523 (John McCall              2010-01-15 23:32:50 +0000 11515)     // Sort everything else by location.
3712d9e391523 (John McCall              2010-01-15 23:32:50 +0000 11516)     SourceLocation LLoc = GetLocationForCandidate(L);
3712d9e391523 (John McCall              2010-01-15 23:32:50 +0000 11517)     SourceLocation RLoc = GetLocationForCandidate(R);
3712d9e391523 (John McCall              2010-01-15 23:32:50 +0000 11518) 
3712d9e391523 (John McCall              2010-01-15 23:32:50 +0000 11519)     // Put candidates without locations (e.g. builtins) at the end.
3712d9e391523 (John McCall              2010-01-15 23:32:50 +0000 11520)     if (LLoc.isInvalid()) return false;
3712d9e391523 (John McCall              2010-01-15 23:32:50 +0000 11521)     if (RLoc.isInvalid()) return true;
3712d9e391523 (John McCall              2010-01-15 23:32:50 +0000 11522) 
3712d9e391523 (John McCall              2010-01-15 23:32:50 +0000 11523)     return S.SourceMgr.isBeforeInTranslationUnit(LLoc, RLoc);
12f97bc48ad40 (John McCall              2010-01-08 04:41:39 +0000 11524)   }
12f97bc48ad40 (John McCall              2010-01-08 04:41:39 +0000 11525) };
ab9db51042d1b (Alexander Kornienko      2015-06-22 23:07:51 +0000 11526) }
12f97bc48ad40 (John McCall              2010-01-08 04:41:39 +0000 11527) 
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11528) /// CompleteNonViableCandidate - Normally, overload resolution only
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000 11529) /// computes up to the first bad conversion. Produces the FixIt set if
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000 11530) /// possible.
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 11531) static void
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 11532) CompleteNonViableCandidate(Sema &S, OverloadCandidate *Cand,
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 11533)                            ArrayRef<Expr *> Args,
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 11534)                            OverloadCandidateSet::CandidateSetKind CSK) {
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11535)   assert(!Cand->Viable);
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11536) 
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11537)   // Don't do anything on failures other than bad conversion.
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11538)   if (Cand->FailureKind != ovl_fail_bad_conversion)
25195541349b1 (Richard Smith            2020-01-09 12:27:48 -0800 11539)     return;
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11540) 
df92ddf8466bf (Anna Zaks                2011-07-19 19:49:12 +0000 11541)   // We only want the FixIts if all the arguments can be corrected.
df92ddf8466bf (Anna Zaks                2011-07-19 19:49:12 +0000 11542)   bool Unfixable = false;
1b06812f466f1 (Anna Zaks                2011-07-28 19:46:48 +0000 11543)   // Use a implicit copy initialization to check conversion fixes.
1b06812f466f1 (Anna Zaks                2011-07-28 19:46:48 +0000 11544)   Cand->Fix.setConversionChecker(TryCopyInitialization);
df92ddf8466bf (Anna Zaks                2011-07-19 19:49:12 +0000 11545) 
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000 11546)   // Attempt to fix the bad conversion.
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000 11547)   unsigned ConvCount = Cand->Conversions.size();
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000 11548)   for (unsigned ConvIdx = (Cand->IgnoreObjectArgument ? 1 : 0); /**/;
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000 11549)        ++ConvIdx) {
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11550)     assert(ConvIdx != ConvCount && "no bad conversion in candidate");
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000 11551)     if (Cand->Conversions[ConvIdx].isInitialized() &&
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000 11552)         Cand->Conversions[ConvIdx].isBad()) {
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000 11553)       Unfixable = !Cand->TryToFixBadConversion(ConvIdx, S);
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11554)       break;
df92ddf8466bf (Anna Zaks                2011-07-19 19:49:12 +0000 11555)     }
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11556)   }
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11557) 
adc7a704d2a38 (Douglas Gregor           2010-04-16 17:45:54 +0000 11558)   // FIXME: this should probably be preserved from the overload
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11559)   // operation somehow.
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11560)   bool SuppressUserConversions = false;
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11561) 
14ead30ab8bcd (Richard Smith            2017-01-10 20:19:21 +0000 11562)   unsigned ConvIdx = 0;
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 11563)   unsigned ArgIdx = 0;
14ead30ab8bcd (Richard Smith            2017-01-10 20:19:21 +0000 11564)   ArrayRef<QualType> ParamTypes;
fcea7fbdba1bd (Richard Smith            2020-02-10 06:05:59 -0800 11565)   bool Reversed = Cand->isReversed();
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11566) 
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11567)   if (Cand->IsSurrogate) {
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11568)     QualType ConvType
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11569)       = Cand->Surrogate->getConversionType().getNonReferenceType();
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11570)     if (const PointerType *ConvPtrType = ConvType->getAs<PointerType>())
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11571)       ConvType = ConvPtrType->getPointeeType();
ed3b68e0dc3c0 (Simon Pilgrim            2019-10-02 14:02:27 +0000 11572)     ParamTypes = ConvType->castAs<FunctionProtoType>()->getParamTypes();
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 11573)     // Conversion 0 is 'this', which doesn't have a corresponding parameter.
14ead30ab8bcd (Richard Smith            2017-01-10 20:19:21 +0000 11574)     ConvIdx = 1;
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11575)   } else if (Cand->Function) {
14ead30ab8bcd (Richard Smith            2017-01-10 20:19:21 +0000 11576)     ParamTypes =
ed3b68e0dc3c0 (Simon Pilgrim            2019-10-02 14:02:27 +0000 11577)         Cand->Function->getType()->castAs<FunctionProtoType>()->getParamTypes();
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11578)     if (isa<CXXMethodDecl>(Cand->Function) &&
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 11579)         !isa<CXXConstructorDecl>(Cand->Function) && !Reversed) {
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 11580)       // Conversion 0 is 'this', which doesn't have a corresponding parameter.
14ead30ab8bcd (Richard Smith            2017-01-10 20:19:21 +0000 11581)       ConvIdx = 1;
52590319a2257 (Richard Smith            2019-10-29 13:06:34 -0700 11582)       if (CSK == OverloadCandidateSet::CSK_Operator &&
52590319a2257 (Richard Smith            2019-10-29 13:06:34 -0700 11583)           Cand->Function->getDeclName().getCXXOverloadedOperator() != OO_Call)
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 11584)         // Argument 0 is 'this', which doesn't have a corresponding parameter.
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 11585)         ArgIdx = 1;
14ead30ab8bcd (Richard Smith            2017-01-10 20:19:21 +0000 11586)     }
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11587)   } else {
14ead30ab8bcd (Richard Smith            2017-01-10 20:19:21 +0000 11588)     // Builtin operator.
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11589)     assert(ConvCount <= 3);
5f6ab9a8bf307 (George Burgess IV        2017-06-08 20:55:21 +0000 11590)     ParamTypes = Cand->BuiltinParamTypes;
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11591)   }
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11592) 
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11593)   // Fill in the rest of the conversions.
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 11594)   for (unsigned ParamIdx = Reversed ? ParamTypes.size() - 1 : 0;
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 11595)        ConvIdx != ConvCount;
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 11596)        ++ConvIdx, ++ArgIdx, ParamIdx += (Reversed ? -1 : 1)) {
52590319a2257 (Richard Smith            2019-10-29 13:06:34 -0700 11597)     assert(ArgIdx < Args.size() && "no argument for this arg conversion");
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000 11598)     if (Cand->Conversions[ConvIdx].isInitialized()) {
14ead30ab8bcd (Richard Smith            2017-01-10 20:19:21 +0000 11599)       // We've already checked this conversion.
52590319a2257 (Richard Smith            2019-10-29 13:06:34 -0700 11600)     } else if (ParamIdx < ParamTypes.size()) {
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 11601)       if (ParamTypes[ParamIdx]->isDependentType())
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000 11602)         Cand->Conversions[ConvIdx].setAsIdentityConversion(
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000 11603)             Args[ArgIdx]->getType());
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000 11604)       else {
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000 11605)         Cand->Conversions[ConvIdx] =
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 11606)             TryCopyInitialization(S, Args[ArgIdx], ParamTypes[ParamIdx],
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000 11607)                                   SuppressUserConversions,
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000 11608)                                   /*InOverloadResolution=*/true,
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000 11609)                                   /*AllowObjCWritebackConversion=*/
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000 11610)                                   S.getLangOpts().ObjCAutoRefCount);
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000 11611)         // Store the FixIt in the candidate if it exists.
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000 11612)         if (!Unfixable && Cand->Conversions[ConvIdx].isBad())
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000 11613)           Unfixable = !Cand->TryToFixBadConversion(ConvIdx, S);
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000 11614)       }
6eedfe77c15fa (Richard Smith            2017-01-09 08:01:21 +0000 11615)     } else
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11616)       Cand->Conversions[ConvIdx].setEllipsis();
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11617)   }
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11618) }
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11619) 
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 11620) SmallVector<OverloadCandidate *, 32> OverloadCandidateSet::CompleteCandidates(
b2f0f05742130 (Richard Smith            2016-10-10 18:54:32 +0000 11621)     Sema &S, OverloadCandidateDisplayKind OCD, ArrayRef<Expr *> Args,
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 11622)     SourceLocation OpLoc,
b2f0f05742130 (Richard Smith            2016-10-10 18:54:32 +0000 11623)     llvm::function_ref<bool(OverloadCandidate &)> Filter) {
12f97bc48ad40 (John McCall              2010-01-08 04:41:39 +0000 11624)   // Sort the candidates by viability and position.  Sorting directly would
12f97bc48ad40 (John McCall              2010-01-08 04:41:39 +0000 11625)   // be prohibitive, so we make a set of pointers and sort those.
0e62c1cc0b47c (Chris Lattner            2011-07-23 10:55:15 +0000 11626)   SmallVector<OverloadCandidate*, 32> Cands;
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000 11627)   if (OCD == OCD_AllCandidates) Cands.reserve(size());
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000 11628)   for (iterator Cand = begin(), LastCand = end(); Cand != LastCand; ++Cand) {
b2f0f05742130 (Richard Smith            2016-10-10 18:54:32 +0000 11629)     if (!Filter(*Cand))
b2f0f05742130 (Richard Smith            2016-10-10 18:54:32 +0000 11630)       continue;
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 11631)     switch (OCD) {
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 11632)     case OCD_AllCandidates:
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 11633)       if (!Cand->Viable) {
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 11634)         if (!Cand->Function && !Cand->IsSurrogate) {
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 11635)           // This a non-viable builtin candidate.  We do not, in general,
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 11636)           // want to list every possible builtin candidate.
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 11637)           continue;
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 11638)         }
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 11639)         CompleteNonViableCandidate(S, Cand, Args, Kind);
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 11640)       }
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 11641)       break;
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 11642) 
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 11643)     case OCD_ViableCandidates:
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 11644)       if (!Cand->Viable)
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 11645)         continue;
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 11646)       break;
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 11647) 
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 11648)     case OCD_AmbiguousCandidates:
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 11649)       if (!Cand->Best)
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 11650)         continue;
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 11651)       break;
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11652)     }
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 11653) 
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 11654)     Cands.push_back(Cand);
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11655)   }
fe796ddd5a76f (John McCall              2010-01-23 05:17:32 +0000 11656) 
899d13926df4b (Fangrui Song             2019-04-24 14:43:05 +0000 11657)   llvm::stable_sort(
899d13926df4b (Fangrui Song             2019-04-24 14:43:05 +0000 11658)       Cands, CompareOverloadCandidatesForDisplay(S, OpLoc, Args.size(), Kind));
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 11659) 
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 11660)   return Cands;
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 11661) }
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 11662) 
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500 11663) bool OverloadCandidateSet::shouldDeferDiags(Sema &S, ArrayRef<Expr *> Args,
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500 11664)                                             SourceLocation OpLoc) {
52bcd691cb199 (Yaxun (Sam) Liu          2020-09-23 18:00:23 -0400 11665)   bool DeferHint = false;
52bcd691cb199 (Yaxun (Sam) Liu          2020-09-23 18:00:23 -0400 11666)   if (S.getLangOpts().CUDA && S.getLangOpts().GPUDeferDiag) {
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500 11667)     // Defer diagnostic for CUDA/HIP if there are wrong-sided candidates or
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500 11668)     // host device candidates.
52bcd691cb199 (Yaxun (Sam) Liu          2020-09-23 18:00:23 -0400 11669)     auto WrongSidedCands =
52bcd691cb199 (Yaxun (Sam) Liu          2020-09-23 18:00:23 -0400 11670)         CompleteCandidates(S, OCD_AllCandidates, Args, OpLoc, [](auto &Cand) {
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500 11671)           return (Cand.Viable == false &&
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500 11672)                   Cand.FailureKind == ovl_fail_bad_target) ||
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500 11673)                  (Cand.Function->template hasAttr<CUDAHostAttr>() &&
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500 11674)                   Cand.Function->template hasAttr<CUDADeviceAttr>());
52bcd691cb199 (Yaxun (Sam) Liu          2020-09-23 18:00:23 -0400 11675)         });
c90dac27e94ec (Justin Lebar             2021-01-30 19:00:24 -0800 11676)     DeferHint = !WrongSidedCands.empty();
52bcd691cb199 (Yaxun (Sam) Liu          2020-09-23 18:00:23 -0400 11677)   }
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500 11678)   return DeferHint;
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500 11679) }
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500 11680) 
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500 11681) /// When overload resolution fails, prints diagnostic messages containing the
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500 11682) /// candidates in the candidate set.
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500 11683) void OverloadCandidateSet::NoteCandidates(
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500 11684)     PartialDiagnosticAt PD, Sema &S, OverloadCandidateDisplayKind OCD,
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500 11685)     ArrayRef<Expr *> Args, StringRef Opc, SourceLocation OpLoc,
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500 11686)     llvm::function_ref<bool(OverloadCandidate &)> Filter) {
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500 11687) 
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 11688)   auto Cands = CompleteCandidates(S, OCD, Args, OpLoc, Filter);
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 11689) 
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500 11690)   S.Diag(PD.first, PD.second, shouldDeferDiags(S, Args, OpLoc));
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 11691) 
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 11692)   NoteCandidates(S, Args, Cands, Opc, OpLoc);
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 11693) 
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 11694)   if (OCD == OCD_AmbiguousCandidates)
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 11695)     MaybeDiagnoseAmbiguousConstraints(S, {begin(), end()});
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 11696) }
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 11697) 
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 11698) void OverloadCandidateSet::NoteCandidates(Sema &S, ArrayRef<Expr *> Args,
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 11699)                                           ArrayRef<OverloadCandidate *> Cands,
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 11700)                                           StringRef Opc, SourceLocation OpLoc) {
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000 11701)   bool ReportedAmbiguousConversions = false;
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11702) 
7959178eb00e3 (Douglas Gregor           2012-10-23 23:11:23 +0000 11703)   const OverloadsShown ShowOverloads = S.Diags.getShowOverloads();
2b99c6fc4f3e0 (Jeffrey Yasskin          2010-06-11 05:57:47 +0000 11704)   unsigned CandsShown = 0;
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 11705)   auto I = Cands.begin(), E = Cands.end();
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 11706)   for (; I != E; ++I) {
12f97bc48ad40 (John McCall              2010-01-08 04:41:39 +0000 11707)     OverloadCandidate *Cand = *I;
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11708) 
c90dac27e94ec (Justin Lebar             2021-01-30 19:00:24 -0800 11709)     if (CandsShown >= S.Diags.getNumOverloadCandidatesToShow() &&
c90dac27e94ec (Justin Lebar             2021-01-30 19:00:24 -0800 11710)         ShowOverloads == Ovl_Best) {
2b99c6fc4f3e0 (Jeffrey Yasskin          2010-06-11 05:57:47 +0000 11711)       break;
2b99c6fc4f3e0 (Jeffrey Yasskin          2010-06-11 05:57:47 +0000 11712)     }
2b99c6fc4f3e0 (Jeffrey Yasskin          2010-06-11 05:57:47 +0000 11713)     ++CandsShown;
2b99c6fc4f3e0 (Jeffrey Yasskin          2010-06-11 05:57:47 +0000 11714) 
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11715)     if (Cand->Function)
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 11716)       NoteFunctionCandidate(S, Cand, Args.size(),
c25ea86d43929 (Anastasia Stulova        2019-06-20 16:23:28 +0000 11717)                             /*TakingCandidateAddress=*/false, DestAS);
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11718)     else if (Cand->IsSurrogate)
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000 11719)       NoteSurrogateCandidate(S, Cand);
2b99c6fc4f3e0 (Jeffrey Yasskin          2010-06-11 05:57:47 +0000 11720)     else {
2b99c6fc4f3e0 (Jeffrey Yasskin          2010-06-11 05:57:47 +0000 11721)       assert(Cand->Viable &&
2b99c6fc4f3e0 (Jeffrey Yasskin          2010-06-11 05:57:47 +0000 11722)              "Non-viable built-in candidates are not added to Cands.");
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000 11723)       // Generally we only see ambiguities including viable builtin
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000 11724)       // operators if overload resolution got screwed up by an
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000 11725)       // ambiguous user-defined conversion.
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000 11726)       //
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000 11727)       // FIXME: It's quite possible for different conversions to see
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000 11728)       // different ambiguities, though.
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000 11729)       if (!ReportedAmbiguousConversions) {
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000 11730)         NoteAmbiguousUserConversions(S, OpLoc, Cand);
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000 11731)         ReportedAmbiguousConversions = true;
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000 11732)       }
d3224162336e1 (John McCall              2010-01-08 00:58:21 +0000 11733) 
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000 11734)       // If this is a viable builtin, print it.
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000 11735)       NoteBuiltinOperatorCandidate(S, Opc, OpLoc, Cand);
a11693bc37b1b (Douglas Gregor           2008-11-12 17:17:38 +0000 11736)     }
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000 11737)   }
2b99c6fc4f3e0 (Jeffrey Yasskin          2010-06-11 05:57:47 +0000 11738) 
c90dac27e94ec (Justin Lebar             2021-01-30 19:00:24 -0800 11739)   // Inform S.Diags that we've shown an overload set with N elements.  This may
c90dac27e94ec (Justin Lebar             2021-01-30 19:00:24 -0800 11740)   // inform the future value of S.Diags.getNumOverloadCandidatesToShow().
c90dac27e94ec (Justin Lebar             2021-01-30 19:00:24 -0800 11741)   S.Diags.overloadCandidatesShown(CandsShown);
c90dac27e94ec (Justin Lebar             2021-01-30 19:00:24 -0800 11742) 
2b99c6fc4f3e0 (Jeffrey Yasskin          2010-06-11 05:57:47 +0000 11743)   if (I != E)
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500 11744)     S.Diag(OpLoc, diag::note_ovl_too_many_candidates,
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500 11745)            shouldDeferDiags(S, Args, OpLoc))
acb6f80d96b74 (Yaxun (Sam) Liu          2020-11-25 10:33:18 -0500 11746)         << int(E - I);
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000 11747) }
5251f1b28324a (Douglas Gregor           2008-10-21 16:13:35 +0000 11748) 
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11749) static SourceLocation
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11750) GetLocationForCandidate(const TemplateSpecCandidate *Cand) {
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11751)   return Cand->Specialization ? Cand->Specialization->getLocation()
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11752)                               : SourceLocation();
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11753) }
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11754) 
17c00b43288dc (Richard Smith            2014-11-12 01:24:00 +0000 11755) namespace {
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11756) struct CompareTemplateSpecCandidatesForDisplay {
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11757)   Sema &S;
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11758)   CompareTemplateSpecCandidatesForDisplay(Sema &S) : S(S) {}
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11759) 
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11760)   bool operator()(const TemplateSpecCandidate *L,
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11761)                   const TemplateSpecCandidate *R) {
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11762)     // Fast-path this check.
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11763)     if (L == R)
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11764)       return false;
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11765) 
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11766)     // Assuming that both candidates are not matches...
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11767) 
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11768)     // Sort by the ranking of deduction failures.
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11769)     if (L->DeductionFailure.Result != R->DeductionFailure.Result)
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11770)       return RankDeductionFailure(L->DeductionFailure) <
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11771)              RankDeductionFailure(R->DeductionFailure);
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11772) 
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11773)     // Sort everything else by location.
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11774)     SourceLocation LLoc = GetLocationForCandidate(L);
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11775)     SourceLocation RLoc = GetLocationForCandidate(R);
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11776) 
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11777)     // Put candidates without locations (e.g. builtins) at the end.
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11778)     if (LLoc.isInvalid())
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11779)       return false;
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11780)     if (RLoc.isInvalid())
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11781)       return true;
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11782) 
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11783)     return S.SourceMgr.isBeforeInTranslationUnit(LLoc, RLoc);
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11784)   }
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11785) };
ab9db51042d1b (Alexander Kornienko      2015-06-22 23:07:51 +0000 11786) }
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11787) 
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11788) /// Diagnose a template argument deduction failure.
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11789) /// We are treating these failures as overload failures due to bad
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11790) /// deductions.
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 11791) void TemplateSpecCandidate::NoteDeductionFailure(Sema &S,
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 11792)                                                  bool ForTakingAddress) {
c2bebe9acab26 (Richard Smith            2016-05-11 20:37:46 +0000 11793)   DiagnoseBadDeduction(S, FoundDecl, Specialization, // pattern
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 11794)                        DeductionFailure, /*NumArgs=*/0, ForTakingAddress);
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11795) }
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11796) 
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11797) void TemplateSpecCandidateSet::destroyCandidates() {
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11798)   for (iterator i = begin(), e = end(); i != e; ++i) {
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11799)     i->DeductionFailure.Destroy();
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11800)   }
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11801) }
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11802) 
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11803) void TemplateSpecCandidateSet::clear() {
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11804)   destroyCandidates();
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11805)   Candidates.clear();
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11806) }
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11807) 
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11808) /// NoteCandidates - When no template specialization match is found, prints
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11809) /// diagnostic messages containing the non-matching specializations that form
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11810) /// the candidate set.
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11811) /// This is analoguous to OverloadCandidateSet::NoteCandidates() with
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11812) /// OCD == OCD_AllCandidates and Cand->Viable == false.
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11813) void TemplateSpecCandidateSet::NoteCandidates(Sema &S, SourceLocation Loc) {
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11814)   // Sort the candidates by position (assuming no candidate is a match).
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11815)   // Sorting directly would be prohibitive, so we make a set of pointers
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11816)   // and sort those.
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11817)   SmallVector<TemplateSpecCandidate *, 32> Cands;
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11818)   Cands.reserve(size());
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11819)   for (iterator Cand = begin(), LastCand = end(); Cand != LastCand; ++Cand) {
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11820)     if (Cand->Specialization)
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11821)       Cands.push_back(Cand);
d473363876d4b (Alp Toker                2013-12-05 04:47:09 +0000 11822)     // Otherwise, this is a non-matching builtin candidate.  We do not,
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11823)     // in general, want to list every possible builtin candidate.
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11824)   }
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11825) 
55fab260ca1c4 (Fangrui Song             2018-09-26 22:16:28 +0000 11826)   llvm::sort(Cands, CompareTemplateSpecCandidatesForDisplay(S));
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11827) 
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11828)   // FIXME: Perhaps rename OverloadsShown and getShowOverloads()
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11829)   // for generalization purposes (?).
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11830)   const OverloadsShown ShowOverloads = S.Diags.getShowOverloads();
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11831) 
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11832)   SmallVectorImpl<TemplateSpecCandidate *>::iterator I, E;
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11833)   unsigned CandsShown = 0;
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11834)   for (I = Cands.begin(), E = Cands.end(); I != E; ++I) {
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11835)     TemplateSpecCandidate *Cand = *I;
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11836) 
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11837)     // Set an arbitrary limit on the number of candidates we'll spam
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11838)     // the user with.  FIXME: This limit should depend on details of the
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11839)     // candidate list.
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11840)     if (CandsShown >= 4 && ShowOverloads == Ovl_Best)
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11841)       break;
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11842)     ++CandsShown;
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11843) 
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11844)     assert(Cand->Specialization &&
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11845)            "Non-matching built-in candidates are not added to Cands.");
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 11846)     Cand->NoteDeductionFailure(S, ForTakingAddress);
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11847)   }
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11848) 
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11849)   if (I != E)
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11850)     S.Diag(Loc, diag::note_ovl_too_many_candidates) << int(E - I);
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11851) }
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11852) 
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 11853) // [PossiblyAFunctionType]  -->   [Return]
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 11854) // NonFunctionType --> NonFunctionType
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 11855) // R (A) --> R(A)
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 11856) // R (*)(A) --> R (A)
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 11857) // R (&)(A) --> R (A)
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 11858) // R (S::*)(A) --> R (A)
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 11859) QualType Sema::ExtractUnqualifiedFunctionType(QualType PossiblyAFunctionType) {
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 11860)   QualType Ret = PossiblyAFunctionType;
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000 11861)   if (const PointerType *ToTypePtr =
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 11862)     PossiblyAFunctionType->getAs<PointerType>())
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 11863)     Ret = ToTypePtr->getPointeeType();
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000 11864)   else if (const ReferenceType *ToTypeRef =
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 11865)     PossiblyAFunctionType->getAs<ReferenceType>())
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 11866)     Ret = ToTypeRef->getPointeeType();
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 11867)   else if (const MemberPointerType *MemTypePtr =
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000 11868)     PossiblyAFunctionType->getAs<MemberPointerType>())
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000 11869)     Ret = MemTypePtr->getPointeeType();
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000 11870)   Ret =
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 11871)     Context.getCanonicalType(Ret).getUnqualifiedType();
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 11872)   return Ret;
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 11873) }
064fdb2fe844a (Douglas Gregor           2010-04-14 23:11:21 +0000 11874) 
9095e5bf7e4fc (Richard Smith            2016-11-01 01:31:23 +0000 11875) static bool completeFunctionType(Sema &S, FunctionDecl *FD, SourceLocation Loc,
9095e5bf7e4fc (Richard Smith            2016-11-01 01:31:23 +0000 11876)                                  bool Complain = true) {
9095e5bf7e4fc (Richard Smith            2016-11-01 01:31:23 +0000 11877)   if (S.getLangOpts().CPlusPlus14 && FD->getReturnType()->isUndeducedType() &&
9095e5bf7e4fc (Richard Smith            2016-11-01 01:31:23 +0000 11878)       S.DeduceReturnType(FD, Loc, Complain))
9095e5bf7e4fc (Richard Smith            2016-11-01 01:31:23 +0000 11879)     return true;
9095e5bf7e4fc (Richard Smith            2016-11-01 01:31:23 +0000 11880) 
9095e5bf7e4fc (Richard Smith            2016-11-01 01:31:23 +0000 11881)   auto *FPT = FD->getType()->castAs<FunctionProtoType>();
c351fba69e24c (Aaron Ballman            2017-12-04 20:27:34 +0000 11882)   if (S.getLangOpts().CPlusPlus17 &&
9095e5bf7e4fc (Richard Smith            2016-11-01 01:31:23 +0000 11883)       isUnresolvedExceptionSpec(FPT->getExceptionSpecType()) &&
9095e5bf7e4fc (Richard Smith            2016-11-01 01:31:23 +0000 11884)       !S.ResolveExceptionSpec(Loc, FPT))
9095e5bf7e4fc (Richard Smith            2016-11-01 01:31:23 +0000 11885)     return true;
9095e5bf7e4fc (Richard Smith            2016-11-01 01:31:23 +0000 11886) 
9095e5bf7e4fc (Richard Smith            2016-11-01 01:31:23 +0000 11887)   return false;
9095e5bf7e4fc (Richard Smith            2016-11-01 01:31:23 +0000 11888) }
9095e5bf7e4fc (Richard Smith            2016-11-01 01:31:23 +0000 11889) 
17c00b43288dc (Richard Smith            2014-11-12 01:24:00 +0000 11890) namespace {
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 11891) // A helper class to help with address of function resolution
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 11892) // - allows us to avoid passing around all those ugly parameters
17c00b43288dc (Richard Smith            2014-11-12 01:24:00 +0000 11893) class AddressOfFunctionResolver {
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 11894)   Sema& S;
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 11895)   Expr* SourceExpr;
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000 11896)   const QualType& TargetType;
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000 11897)   QualType TargetFunctionType; // Extracted function type from target type
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000 11898) 
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 11899)   bool Complain;
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 11900)   //DeclAccessPair& ResultFunctionAccessPair;
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 11901)   ASTContext& Context;
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 11902) 
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 11903)   bool TargetTypeIsNonStaticMemberFunction;
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 11904)   bool FoundNonTemplateFunction;
a4f7c7a600c3e (David Majnemer           2013-08-01 06:13:59 +0000 11905)   bool StaticMemberFunctionFromBoundPointer;
5f2ef457bfb1d (George Burgess IV        2015-10-12 18:40:58 +0000 11906)   bool HasComplained;
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 11907) 
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000 11908)   OverloadExpr::FindResult OvlExprInfo;
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 11909)   OverloadExpr *OvlExpr;
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 11910)   TemplateArgumentListInfo OvlExplicitTemplateArgs;
0e62c1cc0b47c (Chris Lattner            2011-07-23 10:55:15 +0000 11911)   SmallVector<std::pair<DeclAccessPair, FunctionDecl*>, 4> Matches;
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11912)   TemplateSpecCandidateSet FailedCandidates;
24d189484b443 (John McCall              2010-08-24 22:52:39 +0000 11913) 
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 11914) public:
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11915)   AddressOfFunctionResolver(Sema &S, Expr *SourceExpr,
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11916)                             const QualType &TargetType, bool Complain)
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11917)       : S(S), SourceExpr(SourceExpr), TargetType(TargetType),
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11918)         Complain(Complain), Context(S.getASTContext()),
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11919)         TargetTypeIsNonStaticMemberFunction(
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11920)             !!TargetType->getAs<MemberPointerType>()),
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11921)         FoundNonTemplateFunction(false),
a4f7c7a600c3e (David Majnemer           2013-08-01 06:13:59 +0000 11922)         StaticMemberFunctionFromBoundPointer(false),
5f2ef457bfb1d (George Burgess IV        2015-10-12 18:40:58 +0000 11923)         HasComplained(false),
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11924)         OvlExprInfo(OverloadExpr::find(SourceExpr)),
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 11925)         OvlExpr(OvlExprInfo.Expression),
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 11926)         FailedCandidates(OvlExpr->getNameLoc(), /*ForTakingAddress=*/true) {
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 11927)     ExtractUnqualifiedFunctionTypeFromTargetType();
a4f7c7a600c3e (David Majnemer           2013-08-01 06:13:59 +0000 11928) 
a4f7c7a600c3e (David Majnemer           2013-08-01 06:13:59 +0000 11929)     if (TargetFunctionType->isFunctionType()) {
a4f7c7a600c3e (David Majnemer           2013-08-01 06:13:59 +0000 11930)       if (UnresolvedMemberExpr *UME = dyn_cast<UnresolvedMemberExpr>(OvlExpr))
a4f7c7a600c3e (David Majnemer           2013-08-01 06:13:59 +0000 11931)         if (!UME->isImplicitAccess() &&
a4f7c7a600c3e (David Majnemer           2013-08-01 06:13:59 +0000 11932)             !S.ResolveSingleFunctionTemplateSpecialization(UME))
a4f7c7a600c3e (David Majnemer           2013-08-01 06:13:59 +0000 11933)           StaticMemberFunctionFromBoundPointer = true;
a4f7c7a600c3e (David Majnemer           2013-08-01 06:13:59 +0000 11934)     } else if (OvlExpr->hasExplicitTemplateArgs()) {
a4f7c7a600c3e (David Majnemer           2013-08-01 06:13:59 +0000 11935)       DeclAccessPair dap;
a4f7c7a600c3e (David Majnemer           2013-08-01 06:13:59 +0000 11936)       if (FunctionDecl *Fn = S.ResolveSingleFunctionTemplateSpecialization(
a4f7c7a600c3e (David Majnemer           2013-08-01 06:13:59 +0000 11937)               OvlExpr, false, &dap)) {
a4f7c7a600c3e (David Majnemer           2013-08-01 06:13:59 +0000 11938)         if (CXXMethodDecl *Method = dyn_cast<CXXMethodDecl>(Fn))
a4f7c7a600c3e (David Majnemer           2013-08-01 06:13:59 +0000 11939)           if (!Method->isStatic()) {
a4f7c7a600c3e (David Majnemer           2013-08-01 06:13:59 +0000 11940)             // If the target type is a non-function type and the function found
a4f7c7a600c3e (David Majnemer           2013-08-01 06:13:59 +0000 11941)             // is a non-static member function, pretend as if that was the
a4f7c7a600c3e (David Majnemer           2013-08-01 06:13:59 +0000 11942)             // target, it's the only possible type to end up with.
a4f7c7a600c3e (David Majnemer           2013-08-01 06:13:59 +0000 11943)             TargetTypeIsNonStaticMemberFunction = true;
a4f7c7a600c3e (David Majnemer           2013-08-01 06:13:59 +0000 11944) 
a4f7c7a600c3e (David Majnemer           2013-08-01 06:13:59 +0000 11945)             // And skip adding the function if its not in the proper form.
a4f7c7a600c3e (David Majnemer           2013-08-01 06:13:59 +0000 11946)             // We'll diagnose this due to an empty set of functions.
a4f7c7a600c3e (David Majnemer           2013-08-01 06:13:59 +0000 11947)             if (!OvlExprInfo.HasFormOfMemberPointer)
a4f7c7a600c3e (David Majnemer           2013-08-01 06:13:59 +0000 11948)               return;
ffce245700488 (Chandler Carruth         2011-03-29 08:08:18 +0000 11949)           }
ffce245700488 (Chandler Carruth         2011-03-29 08:08:18 +0000 11950) 
a4f7c7a600c3e (David Majnemer           2013-08-01 06:13:59 +0000 11951)         Matches.push_back(std::make_pair(dap, Fn));
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 11952)       }
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 11953)       return;
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 11954)     }
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000 11955) 
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 11956)     if (OvlExpr->hasExplicitTemplateArgs())
04ec5bfad8ff4 (James Y Knight           2015-12-24 02:59:37 +0000 11957)       OvlExpr->copyTemplateArgumentsInto(OvlExplicitTemplateArgs);
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 11958) 
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 11959)     if (FindAllFunctionsThatMatchTargetTypeExactly()) {
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 11960)       // C++ [over.over]p4:
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 11961)       //   If more than one function is selected, [...]
2a6150d93290b (George Burgess IV        2015-10-16 01:17:38 +0000 11962)       if (Matches.size() > 1 && !eliminiateSuboptimalOverloadCandidates()) {
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 11963)         if (FoundNonTemplateFunction)
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 11964)           EliminateAllTemplateMatches();
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 11965)         else
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 11966)           EliminateAllExceptMostSpecializedTemplate();
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 11967)       }
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 11968)     }
94a55e8169a1e (Artem Belevich           2015-09-22 17:22:59 +0000 11969) 
25c4a81e79b08 (Justin Lebar             2016-03-29 16:24:16 +0000 11970)     if (S.getLangOpts().CUDA && Matches.size() > 1)
94a55e8169a1e (Artem Belevich           2015-09-22 17:22:59 +0000 11971)       EliminateSuboptimalCudaMatches();
24d189484b443 (John McCall              2010-08-24 22:52:39 +0000 11972)   }
5f2ef457bfb1d (George Burgess IV        2015-10-12 18:40:58 +0000 11973) 
5f2ef457bfb1d (George Burgess IV        2015-10-12 18:40:58 +0000 11974)   bool hasComplained() const { return HasComplained; }
5f2ef457bfb1d (George Burgess IV        2015-10-12 18:40:58 +0000 11975) 
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 11976) private:
6da4c20f7daa6 (George Burgess IV        2016-03-23 02:33:58 +0000 11977)   bool candidateHasExactlyCorrectType(const FunctionDecl *FD) {
6da4c20f7daa6 (George Burgess IV        2016-03-23 02:33:58 +0000 11978)     QualType Discard;
6da4c20f7daa6 (George Burgess IV        2016-03-23 02:33:58 +0000 11979)     return Context.hasSameUnqualifiedType(TargetFunctionType, FD->getType()) ||
3c4f8d2e96c4b (Richard Smith            2016-10-16 17:54:23 +0000 11980)            S.IsFunctionConversion(FD->getType(), TargetFunctionType, Discard);
6da4c20f7daa6 (George Burgess IV        2016-03-23 02:33:58 +0000 11981)   }
6da4c20f7daa6 (George Burgess IV        2016-03-23 02:33:58 +0000 11982) 
6da4c20f7daa6 (George Burgess IV        2016-03-23 02:33:58 +0000 11983)   /// \return true if A is considered a better overload candidate for the
6da4c20f7daa6 (George Burgess IV        2016-03-23 02:33:58 +0000 11984)   /// desired type than B.
2a6150d93290b (George Burgess IV        2015-10-16 01:17:38 +0000 11985)   bool isBetterCandidate(const FunctionDecl *A, const FunctionDecl *B) {
6da4c20f7daa6 (George Burgess IV        2016-03-23 02:33:58 +0000 11986)     // If A doesn't have exactly the correct type, we don't want to classify it
6da4c20f7daa6 (George Burgess IV        2016-03-23 02:33:58 +0000 11987)     // as "better" than anything else. This way, the user is required to
6da4c20f7daa6 (George Burgess IV        2016-03-23 02:33:58 +0000 11988)     // disambiguate for us if there are multiple candidates and no exact match.
6da4c20f7daa6 (George Burgess IV        2016-03-23 02:33:58 +0000 11989)     return candidateHasExactlyCorrectType(A) &&
6da4c20f7daa6 (George Burgess IV        2016-03-23 02:33:58 +0000 11990)            (!candidateHasExactlyCorrectType(B) ||
3dc16691339e0 (George Burgess IV        2016-05-10 01:59:34 +0000 11991)             compareEnableIfAttrs(S, A, B) == Comparison::Better);
2a6150d93290b (George Burgess IV        2015-10-16 01:17:38 +0000 11992)   }
2a6150d93290b (George Burgess IV        2015-10-16 01:17:38 +0000 11993) 
6da4c20f7daa6 (George Burgess IV        2016-03-23 02:33:58 +0000 11994)   /// \return true if we were able to eliminate all but one overload candidate,
6da4c20f7daa6 (George Burgess IV        2016-03-23 02:33:58 +0000 11995)   /// false otherwise.
2a6150d93290b (George Burgess IV        2015-10-16 01:17:38 +0000 11996)   bool eliminiateSuboptimalOverloadCandidates() {
2a6150d93290b (George Burgess IV        2015-10-16 01:17:38 +0000 11997)     // Same algorithm as overload resolution -- one pass to pick the "best",
2a6150d93290b (George Burgess IV        2015-10-16 01:17:38 +0000 11998)     // another pass to be sure that nothing is better than the best.
2a6150d93290b (George Burgess IV        2015-10-16 01:17:38 +0000 11999)     auto Best = Matches.begin();
2a6150d93290b (George Burgess IV        2015-10-16 01:17:38 +0000 12000)     for (auto I = Matches.begin()+1, E = Matches.end(); I != E; ++I)
2a6150d93290b (George Burgess IV        2015-10-16 01:17:38 +0000 12001)       if (isBetterCandidate(I->second, Best->second))
2a6150d93290b (George Burgess IV        2015-10-16 01:17:38 +0000 12002)         Best = I;
2a6150d93290b (George Burgess IV        2015-10-16 01:17:38 +0000 12003) 
2a6150d93290b (George Burgess IV        2015-10-16 01:17:38 +0000 12004)     const FunctionDecl *BestFn = Best->second;
2a6150d93290b (George Burgess IV        2015-10-16 01:17:38 +0000 12005)     auto IsBestOrInferiorToBest = [this, BestFn](
2a6150d93290b (George Burgess IV        2015-10-16 01:17:38 +0000 12006)         const std::pair<DeclAccessPair, FunctionDecl *> &Pair) {
2a6150d93290b (George Burgess IV        2015-10-16 01:17:38 +0000 12007)       return BestFn == Pair.second || isBetterCandidate(BestFn, Pair.second);
2a6150d93290b (George Burgess IV        2015-10-16 01:17:38 +0000 12008)     };
2a6150d93290b (George Burgess IV        2015-10-16 01:17:38 +0000 12009) 
2a6150d93290b (George Burgess IV        2015-10-16 01:17:38 +0000 12010)     // Note: We explicitly leave Matches unmodified if there isn't a clear best
2a6150d93290b (George Burgess IV        2015-10-16 01:17:38 +0000 12011)     // option, so we can potentially give the user a better error
3117b17bc57c1 (Fangrui Song             2018-10-20 17:53:42 +0000 12012)     if (!llvm::all_of(Matches, IsBestOrInferiorToBest))
2a6150d93290b (George Burgess IV        2015-10-16 01:17:38 +0000 12013)       return false;
2a6150d93290b (George Burgess IV        2015-10-16 01:17:38 +0000 12014)     Matches[0] = *Best;
2a6150d93290b (George Burgess IV        2015-10-16 01:17:38 +0000 12015)     Matches.resize(1);
2a6150d93290b (George Burgess IV        2015-10-16 01:17:38 +0000 12016)     return true;
2a6150d93290b (George Burgess IV        2015-10-16 01:17:38 +0000 12017)   }
2a6150d93290b (George Burgess IV        2015-10-16 01:17:38 +0000 12018) 
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12019)   bool isTargetTypeAFunction() const {
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12020)     return TargetFunctionType->isFunctionType();
24d189484b443 (John McCall              2010-08-24 22:52:39 +0000 12021)   }
24d189484b443 (John McCall              2010-08-24 22:52:39 +0000 12022) 
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12023)   // [ToType]     [Return]
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000 12024) 
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12025)   // R (*)(A) --> R (A), IsNonStaticMemberFunction = false
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12026)   // R (&)(A) --> R (A), IsNonStaticMemberFunction = false
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12027)   // R (S::*)(A) --> R (A), IsNonStaticMemberFunction = true
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12028)   void inline ExtractUnqualifiedFunctionTypeFromTargetType() {
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12029)     TargetFunctionType = S.ExtractUnqualifiedFunctionType(TargetType);
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12030)   }
d14a86427f9cd (John McCall              2009-11-21 08:51:07 +0000 12031) 
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12032)   // return true if any matching specializations were found
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000 12033)   bool AddMatchingTemplateFunction(FunctionTemplateDecl* FunctionTemplate,
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12034)                                    const DeclAccessPair& CurAccessFunPair) {
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12035)     if (CXXMethodDecl *Method
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12036)               = dyn_cast<CXXMethodDecl>(FunctionTemplate->getTemplatedDecl())) {
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12037)       // Skip non-static function templates when converting to pointer, and
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12038)       // static when converting to member pointer.
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12039)       if (Method->isStatic() == TargetTypeIsNonStaticMemberFunction)
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12040)         return false;
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000 12041)     }
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12042)     else if (TargetTypeIsNonStaticMemberFunction)
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12043)       return false;
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000 12044) 
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12045)     // C++ [over.over]p2:
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12046)     //   If the name is a function template, template argument deduction is
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12047)     //   done (14.8.2.2), and if the argument deduction succeeds, the
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12048)     //   resulting template argument list is used to generate a single
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12049)     //   function template specialization, which is added to the set of
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12050)     //   overloaded functions considered.
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000 12051)     FunctionDecl *Specialization = nullptr;
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 12052)     TemplateDeductionInfo Info(FailedCandidates.getLocation());
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12053)     if (Sema::TemplateDeductionResult Result
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000 12054)           = S.DeduceTemplateArguments(FunctionTemplate,
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12055)                                       &OvlExplicitTemplateArgs,
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000 12056)                                       TargetFunctionType, Specialization,
baa4783d310c7 (Richard Smith            2016-12-01 02:11:49 +0000 12057)                                       Info, /*IsAddressOfFunction*/true)) {
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 12058)       // Make a note of the failed deduction for diagnostics.
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 12059)       FailedCandidates.addCandidate()
c2bebe9acab26 (Richard Smith            2016-05-11 20:37:46 +0000 12060)           .set(CurAccessFunPair, FunctionTemplate->getTemplatedDecl(),
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 12061)                MakeDeductionFailureInfo(Context, Result, Info));
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12062)       return false;
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000 12063)     }
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000 12064) 
19a41f161b87b (Douglas Gregor           2013-04-17 08:45:07 +0000 12065)     // Template argument deduction ensures that we have an exact match or
19a41f161b87b (Douglas Gregor           2013-04-17 08:45:07 +0000 12066)     // compatible pointer-to-function arguments that would be adjusted by ICS.
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12067)     // This function template specicalization works.
19a41f161b87b (Douglas Gregor           2013-04-17 08:45:07 +0000 12068)     assert(S.isSameOrCompatibleFunctionType(
19a41f161b87b (Douglas Gregor           2013-04-17 08:45:07 +0000 12069)               Context.getCanonicalType(Specialization->getType()),
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 12070)               Context.getCanonicalType(TargetFunctionType)));
5f21c718007fd (George Burgess IV        2015-10-12 19:57:04 +0000 12071) 
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 12072)     if (!S.checkAddressOfFunctionIsAvailable(Specialization))
5f21c718007fd (George Burgess IV        2015-10-12 19:57:04 +0000 12073)       return false;
5f21c718007fd (George Burgess IV        2015-10-12 19:57:04 +0000 12074) 
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12075)     Matches.push_back(std::make_pair(CurAccessFunPair, Specialization));
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12076)     return true;
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12077)   }
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000 12078) 
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000 12079)   bool AddMatchingNonTemplateFunction(NamedDecl* Fn,
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12080)                                       const DeclAccessPair& CurAccessFunPair) {
c25c6ee3dbf28 (Chandler Carruth         2009-12-29 06:17:27 +0000 12081)     if (CXXMethodDecl *Method = dyn_cast<CXXMethodDecl>(Fn)) {
18f8ff62a3adb (Sebastian Redl           2009-02-04 21:23:32 +0000 12082)       // Skip non-static functions when converting to pointer, and static
18f8ff62a3adb (Sebastian Redl           2009-02-04 21:23:32 +0000 12083)       // when converting to member pointer.
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12084)       if (Method->isStatic() == TargetTypeIsNonStaticMemberFunction)
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12085)         return false;
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000 12086)     }
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12087)     else if (TargetTypeIsNonStaticMemberFunction)
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12088)       return false;
cd695e500de7e (Douglas Gregor           2008-11-10 20:40:00 +0000 12089) 
c25c6ee3dbf28 (Chandler Carruth         2009-12-29 06:17:27 +0000 12090)     if (FunctionDecl *FunDecl = dyn_cast<FunctionDecl>(Fn)) {
bbafb8a745736 (David Blaikie            2012-03-11 07:00:24 +0000 12091)       if (S.getLangOpts().CUDA)
7277fe8aed6e1 (Peter Collingbourne      2011-10-02 23:49:40 +0000 12092)         if (FunctionDecl *Caller = dyn_cast<FunctionDecl>(S.CurContext))
b008003aa3f0d (Justin Lebar             2016-08-10 01:09:11 +0000 12093)           if (!Caller->isImplicit() && !S.IsAllowedCUDACall(Caller, FunDecl))
7277fe8aed6e1 (Peter Collingbourne      2011-10-02 23:49:40 +0000 12094)             return false;
281d20b601c8a (Erich Keane              2018-01-08 21:34:17 +0000 12095)       if (FunDecl->isMultiVersion()) {
281d20b601c8a (Erich Keane              2018-01-08 21:34:17 +0000 12096)         const auto *TA = FunDecl->getAttr<TargetAttr>();
3efe00206f0f4 (Erich Keane              2018-07-20 14:13:28 +0000 12097)         if (TA && !TA->isDefaultVersion())
281d20b601c8a (Erich Keane              2018-01-08 21:34:17 +0000 12098)           return false;
281d20b601c8a (Erich Keane              2018-01-08 21:34:17 +0000 12099)       }
7277fe8aed6e1 (Peter Collingbourne      2011-10-02 23:49:40 +0000 12100) 
2a7d481faf546 (Richard Smith            2013-05-04 07:00:32 +0000 12101)       // If any candidate has a placeholder return type, trigger its deduction
2a7d481faf546 (Richard Smith            2013-05-04 07:00:32 +0000 12102)       // now.
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000 12103)       if (completeFunctionType(S, FunDecl, SourceExpr->getBeginLoc(),
9095e5bf7e4fc (Richard Smith            2016-11-01 01:31:23 +0000 12104)                                Complain)) {
5f2ef457bfb1d (George Burgess IV        2015-10-12 18:40:58 +0000 12105)         HasComplained |= Complain;
2a7d481faf546 (Richard Smith            2013-05-04 07:00:32 +0000 12106)         return false;
5f2ef457bfb1d (George Burgess IV        2015-10-12 18:40:58 +0000 12107)       }
2a7d481faf546 (Richard Smith            2013-05-04 07:00:32 +0000 12108) 
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 12109)       if (!S.checkAddressOfFunctionIsAvailable(FunDecl))
5f21c718007fd (George Burgess IV        2015-10-12 19:57:04 +0000 12110)         return false;
5f21c718007fd (George Burgess IV        2015-10-12 19:57:04 +0000 12111) 
6da4c20f7daa6 (George Burgess IV        2016-03-23 02:33:58 +0000 12112)       // If we're in C, we need to support types that aren't exactly identical.
6da4c20f7daa6 (George Burgess IV        2016-03-23 02:33:58 +0000 12113)       if (!S.getLangOpts().CPlusPlus ||
6da4c20f7daa6 (George Burgess IV        2016-03-23 02:33:58 +0000 12114)           candidateHasExactlyCorrectType(FunDecl)) {
5f21c718007fd (George Burgess IV        2015-10-12 19:57:04 +0000 12115)         Matches.push_back(std::make_pair(
5f21c718007fd (George Burgess IV        2015-10-12 19:57:04 +0000 12116)             CurAccessFunPair, cast<FunctionDecl>(FunDecl->getCanonicalDecl())));
b257e4fff8a94 (Douglas Gregor           2009-07-08 23:33:52 +0000 12117)         FoundNonTemplateFunction = true;
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12118)         return true;
b257e4fff8a94 (Douglas Gregor           2009-07-08 23:33:52 +0000 12119)       }
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000 12120)     }
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000 12121) 
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12122)     return false;
cd695e500de7e (Douglas Gregor           2008-11-10 20:40:00 +0000 12123)   }
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000 12124) 
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12125)   bool FindAllFunctionsThatMatchTargetTypeExactly() {
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12126)     bool Ret = false;
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000 12127) 
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12128)     // If the overload expression doesn't have the form of a pointer to
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12129)     // member, don't try to convert it to a pointer-to-member type.
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12130)     if (IsInvalidFormOfPointerToMemberFunction())
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12131)       return false;
cd695e500de7e (Douglas Gregor           2008-11-10 20:40:00 +0000 12132) 
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12133)     for (UnresolvedSetIterator I = OvlExpr->decls_begin(),
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000 12134)                                E = OvlExpr->decls_end();
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12135)          I != E; ++I) {
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12136)       // Look through any using declarations to find the underlying function.
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12137)       NamedDecl *Fn = (*I)->getUnderlyingDecl();
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12138) 
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12139)       // C++ [over.over]p3:
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12140)       //   Non-member functions and static member functions match
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12141)       //   targets of type "pointer-to-function" or "reference-to-function."
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12142)       //   Nonstatic member functions match targets of
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12143)       //   type "pointer-to-member-function."
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12144)       // Note that according to DR 247, the containing class does not matter.
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12145)       if (FunctionTemplateDecl *FunctionTemplate
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12146)                                         = dyn_cast<FunctionTemplateDecl>(Fn)) {
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12147)         if (AddMatchingTemplateFunction(FunctionTemplate, I.getPair()))
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12148)           Ret = true;
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12149)       }
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12150)       // If we have explicit template arguments supplied, skip non-templates.
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12151)       else if (!OvlExpr->hasExplicitTemplateArgs() &&
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12152)                AddMatchingNonTemplateFunction(Fn, I.getPair()))
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12153)         Ret = true;
5bb5e4ad9d8ed (Douglas Gregor           2010-10-12 23:32:35 +0000 12154)     }
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12155)     assert(Ret || Matches.empty());
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12156)     return Ret;
df4b80e7c0caf (Sebastian Redl           2009-10-17 21:12:09 +0000 12157)   }
b257e4fff8a94 (Douglas Gregor           2009-07-08 23:33:52 +0000 12158) 
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12159)   void EliminateAllExceptMostSpecializedTemplate() {
05155d8d7b215 (Douglas Gregor           2009-08-21 23:19:43 +0000 12160)     //   [...] and any given function template specialization F1 is
05155d8d7b215 (Douglas Gregor           2009-08-21 23:19:43 +0000 12161)     //   eliminated if the set contains a second function template
05155d8d7b215 (Douglas Gregor           2009-08-21 23:19:43 +0000 12162)     //   specialization whose function template is more specialized
05155d8d7b215 (Douglas Gregor           2009-08-21 23:19:43 +0000 12163)     //   than the function template of F1 according to the partial
05155d8d7b215 (Douglas Gregor           2009-08-21 23:19:43 +0000 12164)     //   ordering rules of 14.5.5.2.
05155d8d7b215 (Douglas Gregor           2009-08-21 23:19:43 +0000 12165) 
05155d8d7b215 (Douglas Gregor           2009-08-21 23:19:43 +0000 12166)     // The algorithm specified above is quadratic. We instead use a
05155d8d7b215 (Douglas Gregor           2009-08-21 23:19:43 +0000 12167)     // two-pass algorithm (similar to the one used to identify the
05155d8d7b215 (Douglas Gregor           2009-08-21 23:19:43 +0000 12168)     // best viable function in an overload set) that identifies the
05155d8d7b215 (Douglas Gregor           2009-08-21 23:19:43 +0000 12169)     // best function template (if it exists).
a0296f7987c0a (John McCall              2010-03-19 07:35:19 +0000 12170) 
a0296f7987c0a (John McCall              2010-03-19 07:35:19 +0000 12171)     UnresolvedSet<4> MatchesCopy; // TODO: avoid!
a0296f7987c0a (John McCall              2010-03-19 07:35:19 +0000 12172)     for (unsigned I = 0, E = Matches.size(); I != E; ++I)
a0296f7987c0a (John McCall              2010-03-19 07:35:19 +0000 12173)       MatchesCopy.addDecl(Matches[I].second, Matches[I].first.getAccess());
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 12174) 
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 12175)     // TODO: It looks like FailedCandidates does not serve much purpose
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 12176)     // here, since the no_viable diagnostic has index 0.
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 12177)     UnresolvedSetIterator Result = S.getMostSpecialized(
35e1da259fcfb (Richard Smith            2013-09-10 22:59:25 +0000 12178)         MatchesCopy.begin(), MatchesCopy.end(), FailedCandidates,
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000 12179)         SourceExpr->getBeginLoc(), S.PDiag(),
5179eb78210a2 (Richard Smith            2016-06-28 19:03:57 +0000 12180)         S.PDiag(diag::err_addr_ovl_ambiguous)
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 12181)             << Matches[0].second->getDeclName(),
5179eb78210a2 (Richard Smith            2016-06-28 19:03:57 +0000 12182)         S.PDiag(diag::note_ovl_candidate)
92e523bf55087 (Eric Fiselier            2018-05-30 01:00:41 +0000 12183)             << (unsigned)oc_function << (unsigned)ocs_described_template,
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 12184)         Complain, TargetFunctionType);
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12185) 
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12186)     if (Result != MatchesCopy.end()) {
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12187)       // Make it the first and only element
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12188)       Matches[0].first = Matches[Result - MatchesCopy.begin()].first;
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12189)       Matches[0].second = cast<FunctionDecl>(*Result);
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12190)       Matches.resize(1);
5f2ef457bfb1d (George Burgess IV        2015-10-12 18:40:58 +0000 12191)     } else
5f2ef457bfb1d (George Burgess IV        2015-10-12 18:40:58 +0000 12192)       HasComplained |= Complain;
b257e4fff8a94 (Douglas Gregor           2009-07-08 23:33:52 +0000 12193)   }
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000 12194) 
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12195)   void EliminateAllTemplateMatches() {
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12196)     //   [...] any function template specializations in the set are
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12197)     //   eliminated if the set also contains a non-template function, [...]
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12198)     for (unsigned I = 0, N = Matches.size(); I != N; ) {
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000 12199)       if (Matches[I].second->getPrimaryTemplate() == nullptr)
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12200)         ++I;
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12201)       else {
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12202)         Matches[I] = Matches[--N];
94a55e8169a1e (Artem Belevich           2015-09-22 17:22:59 +0000 12203)         Matches.resize(N);
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12204)       }
58cc69d4c1516 (John McCall              2010-01-27 01:50:18 +0000 12205)     }
58cc69d4c1516 (John McCall              2010-01-27 01:50:18 +0000 12206)   }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 12207) 
94a55e8169a1e (Artem Belevich           2015-09-22 17:22:59 +0000 12208)   void EliminateSuboptimalCudaMatches() {
94a55e8169a1e (Artem Belevich           2015-09-22 17:22:59 +0000 12209)     S.EraseUnwantedCUDAMatches(dyn_cast<FunctionDecl>(S.CurContext), Matches);
94a55e8169a1e (Artem Belevich           2015-09-22 17:22:59 +0000 12210)   }
94a55e8169a1e (Artem Belevich           2015-09-22 17:22:59 +0000 12211) 
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12212) public:
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12213)   void ComplainNoMatchesFound() const {
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12214)     assert(Matches.empty());
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000 12215)     S.Diag(OvlExpr->getBeginLoc(), diag::err_addr_ovl_no_viable)
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12216)         << OvlExpr->getName() << TargetFunctionType
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12217)         << OvlExpr->getSourceRange();
0d905476f8316 (Richard Smith            2013-08-14 00:00:44 +0000 12218)     if (FailedCandidates.empty())
5f21c718007fd (George Burgess IV        2015-10-12 19:57:04 +0000 12219)       S.NoteAllOverloadCandidates(OvlExpr, TargetFunctionType,
5f21c718007fd (George Burgess IV        2015-10-12 19:57:04 +0000 12220)                                   /*TakingAddress=*/true);
0d905476f8316 (Richard Smith            2013-08-14 00:00:44 +0000 12221)     else {
0d905476f8316 (Richard Smith            2013-08-14 00:00:44 +0000 12222)       // We have some deduction failure messages. Use them to diagnose
0d905476f8316 (Richard Smith            2013-08-14 00:00:44 +0000 12223)       // the function templates, and diagnose the non-template candidates
0d905476f8316 (Richard Smith            2013-08-14 00:00:44 +0000 12224)       // normally.
0d905476f8316 (Richard Smith            2013-08-14 00:00:44 +0000 12225)       for (UnresolvedSetIterator I = OvlExpr->decls_begin(),
0d905476f8316 (Richard Smith            2013-08-14 00:00:44 +0000 12226)                                  IEnd = OvlExpr->decls_end();
0d905476f8316 (Richard Smith            2013-08-14 00:00:44 +0000 12227)            I != IEnd; ++I)
0d905476f8316 (Richard Smith            2013-08-14 00:00:44 +0000 12228)         if (FunctionDecl *Fun =
0d905476f8316 (Richard Smith            2013-08-14 00:00:44 +0000 12229)                 dyn_cast<FunctionDecl>((*I)->getUnderlyingDecl()))
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 12230)           if (!functionHasPassObjectSizeParams(Fun))
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 12231)             S.NoteOverloadCandidate(*I, Fun, CRK_None, TargetFunctionType,
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 12232)                                     /*TakingAddress=*/true);
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000 12233)       FailedCandidates.NoteCandidates(S, OvlExpr->getBeginLoc());
0d905476f8316 (Richard Smith            2013-08-14 00:00:44 +0000 12234)     }
0d905476f8316 (Richard Smith            2013-08-14 00:00:44 +0000 12235)   }
0d905476f8316 (Richard Smith            2013-08-14 00:00:44 +0000 12236) 
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12237)   bool IsInvalidFormOfPointerToMemberFunction() const {
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12238)     return TargetTypeIsNonStaticMemberFunction &&
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12239)       !OvlExprInfo.HasFormOfMemberPointer;
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12240)   }
a4f7c7a600c3e (David Majnemer           2013-08-01 06:13:59 +0000 12241) 
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12242)   void ComplainIsInvalidFormOfPointerToMemberFunction() const {
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12243)       // TODO: Should we condition this on whether any functions might
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12244)       // have matched, or is it more appropriate to do that in callers?
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12245)       // TODO: a fixit wouldn't hurt.
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12246)       S.Diag(OvlExpr->getNameLoc(), diag::err_addr_ovl_no_qualifier)
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12247)         << TargetType << OvlExpr->getSourceRange();
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12248)   }
a4f7c7a600c3e (David Majnemer           2013-08-01 06:13:59 +0000 12249) 
a4f7c7a600c3e (David Majnemer           2013-08-01 06:13:59 +0000 12250)   bool IsStaticMemberFunctionFromBoundPointer() const {
a4f7c7a600c3e (David Majnemer           2013-08-01 06:13:59 +0000 12251)     return StaticMemberFunctionFromBoundPointer;
a4f7c7a600c3e (David Majnemer           2013-08-01 06:13:59 +0000 12252)   }
a4f7c7a600c3e (David Majnemer           2013-08-01 06:13:59 +0000 12253) 
a4f7c7a600c3e (David Majnemer           2013-08-01 06:13:59 +0000 12254)   void ComplainIsStaticMemberFunctionFromBoundPointer() const {
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000 12255)     S.Diag(OvlExpr->getBeginLoc(),
a4f7c7a600c3e (David Majnemer           2013-08-01 06:13:59 +0000 12256)            diag::err_invalid_form_pointer_member_function)
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000 12257)         << OvlExpr->getSourceRange();
a4f7c7a600c3e (David Majnemer           2013-08-01 06:13:59 +0000 12258)   }
a4f7c7a600c3e (David Majnemer           2013-08-01 06:13:59 +0000 12259) 
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12260)   void ComplainOfInvalidConversion() const {
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000 12261)     S.Diag(OvlExpr->getBeginLoc(), diag::err_addr_ovl_not_func_ptrref)
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000 12262)         << OvlExpr->getName() << TargetType;
df4b80e7c0caf (Sebastian Redl           2009-10-17 21:12:09 +0000 12263)   }
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000 12264) 
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12265)   void ComplainMultipleMatchesFound() const {
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12266)     assert(Matches.size() > 1);
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000 12267)     S.Diag(OvlExpr->getBeginLoc(), diag::err_addr_ovl_ambiguous)
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000 12268)         << OvlExpr->getName() << OvlExpr->getSourceRange();
5f21c718007fd (George Burgess IV        2015-10-12 19:57:04 +0000 12269)     S.NoteAllOverloadCandidates(OvlExpr, TargetFunctionType,
5f21c718007fd (George Burgess IV        2015-10-12 19:57:04 +0000 12270)                                 /*TakingAddress=*/true);
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12271)   }
5001caa1b6320 (Abramo Bagnara           2011-11-19 11:44:21 +0000 12272) 
5001caa1b6320 (Abramo Bagnara           2011-11-19 11:44:21 +0000 12273)   bool hadMultipleCandidates() const { return (OvlExpr->getNumDecls() > 1); }
5001caa1b6320 (Abramo Bagnara           2011-11-19 11:44:21 +0000 12274) 
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12275)   int getNumMatches() const { return Matches.size(); }
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000 12276) 
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12277)   FunctionDecl* getMatchingFunctionDecl() const {
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000 12278)     if (Matches.size() != 1) return nullptr;
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12279)     return Matches[0].second;
e81f58e180117 (Douglas Gregor           2010-11-08 03:40:48 +0000 12280)   }
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000 12281) 
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12282)   const DeclAccessPair* getMatchingFunctionAccessPair() const {
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000 12283)     if (Matches.size() != 1) return nullptr;
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12284)     return &Matches[0].first;
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12285)   }
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12286) };
ab9db51042d1b (Alexander Kornienko      2015-06-22 23:07:51 +0000 12287) }
17c00b43288dc (Richard Smith            2014-11-12 01:24:00 +0000 12288) 
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12289) /// ResolveAddressOfOverloadedFunction - Try to resolve the address of
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12290) /// an overloaded function (C++ [over.over]), where @p From is an
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12291) /// expression with overloaded function type and @p ToType is the type
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12292) /// we're trying to resolve to. For example:
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12293) ///
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12294) /// @code
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12295) /// int f(double);
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12296) /// int f(int);
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12297) ///
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12298) /// int (*pfd)(double) = f; // selects f(double)
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12299) /// @endcode
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12300) ///
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12301) /// This routine returns the resulting FunctionDecl if it could be
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12302) /// resolved, and NULL otherwise. When @p Complain is true, this
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12303) /// routine will emit diagnostics if there is an error.
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12304) FunctionDecl *
5001caa1b6320 (Abramo Bagnara           2011-11-19 11:44:21 +0000 12305) Sema::ResolveAddressOfOverloadedFunction(Expr *AddressOfExpr,
5001caa1b6320 (Abramo Bagnara           2011-11-19 11:44:21 +0000 12306)                                          QualType TargetType,
5001caa1b6320 (Abramo Bagnara           2011-11-19 11:44:21 +0000 12307)                                          bool Complain,
5001caa1b6320 (Abramo Bagnara           2011-11-19 11:44:21 +0000 12308)                                          DeclAccessPair &FoundResult,
5001caa1b6320 (Abramo Bagnara           2011-11-19 11:44:21 +0000 12309)                                          bool *pHadMultipleCandidates) {
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12310)   assert(AddressOfExpr->getType() == Context.OverloadTy);
5001caa1b6320 (Abramo Bagnara           2011-11-19 11:44:21 +0000 12311) 
5001caa1b6320 (Abramo Bagnara           2011-11-19 11:44:21 +0000 12312)   AddressOfFunctionResolver Resolver(*this, AddressOfExpr, TargetType,
5001caa1b6320 (Abramo Bagnara           2011-11-19 11:44:21 +0000 12313)                                      Complain);
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12314)   int NumMatches = Resolver.getNumMatches();
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000 12315)   FunctionDecl *Fn = nullptr;
5f2ef457bfb1d (George Burgess IV        2015-10-12 18:40:58 +0000 12316)   bool ShouldComplain = Complain && !Resolver.hasComplained();
5f2ef457bfb1d (George Burgess IV        2015-10-12 18:40:58 +0000 12317)   if (NumMatches == 0 && ShouldComplain) {
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12318)     if (Resolver.IsInvalidFormOfPointerToMemberFunction())
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12319)       Resolver.ComplainIsInvalidFormOfPointerToMemberFunction();
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12320)     else
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12321)       Resolver.ComplainNoMatchesFound();
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12322)   }
5f2ef457bfb1d (George Burgess IV        2015-10-12 18:40:58 +0000 12323)   else if (NumMatches > 1 && ShouldComplain)
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12324)     Resolver.ComplainMultipleMatchesFound();
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12325)   else if (NumMatches == 1) {
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12326)     Fn = Resolver.getMatchingFunctionDecl();
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12327)     assert(Fn);
9095e5bf7e4fc (Richard Smith            2016-11-01 01:31:23 +0000 12328)     if (auto *FPT = Fn->getType()->getAs<FunctionProtoType>())
9095e5bf7e4fc (Richard Smith            2016-11-01 01:31:23 +0000 12329)       ResolveExceptionSpec(AddressOfExpr->getExprLoc(), FPT);
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12330)     FoundResult = *Resolver.getMatchingFunctionAccessPair();
a4f7c7a600c3e (David Majnemer           2013-08-01 06:13:59 +0000 12331)     if (Complain) {
a4f7c7a600c3e (David Majnemer           2013-08-01 06:13:59 +0000 12332)       if (Resolver.IsStaticMemberFunctionFromBoundPointer())
a4f7c7a600c3e (David Majnemer           2013-08-01 06:13:59 +0000 12333)         Resolver.ComplainIsStaticMemberFunctionFromBoundPointer();
a4f7c7a600c3e (David Majnemer           2013-08-01 06:13:59 +0000 12334)       else
a4f7c7a600c3e (David Majnemer           2013-08-01 06:13:59 +0000 12335)         CheckAddressOfMemberAccess(AddressOfExpr, FoundResult);
a4f7c7a600c3e (David Majnemer           2013-08-01 06:13:59 +0000 12336)     }
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12337)   }
5001caa1b6320 (Abramo Bagnara           2011-11-19 11:44:21 +0000 12338) 
5001caa1b6320 (Abramo Bagnara           2011-11-19 11:44:21 +0000 12339)   if (pHadMultipleCandidates)
5001caa1b6320 (Abramo Bagnara           2011-11-19 11:44:21 +0000 12340)     *pHadMultipleCandidates = Resolver.hadMultipleCandidates();
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12341)   return Fn;
cd695e500de7e (Douglas Gregor           2008-11-10 20:40:00 +0000 12342) }
cd695e500de7e (Douglas Gregor           2008-11-10 20:40:00 +0000 12343) 
9fc8faf9e6197 (Adrian Prantl            2018-05-09 01:00:01 +0000 12344) /// Given an expression that refers to an overloaded function, try to
3cde9bf9d5734 (George Burgess IV        2016-03-19 21:36:10 +0000 12345) /// resolve that function to a single function that can have its address taken.
3cde9bf9d5734 (George Burgess IV        2016-03-19 21:36:10 +0000 12346) /// This will modify `Pair` iff it returns non-null.
3cde9bf9d5734 (George Burgess IV        2016-03-19 21:36:10 +0000 12347) ///
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12348) /// This routine can only succeed if from all of the candidates in the overload
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12349) /// set for SrcExpr that can have their addresses taken, there is one candidate
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12350) /// that is more constrained than the rest.
3cde9bf9d5734 (George Burgess IV        2016-03-19 21:36:10 +0000 12351) FunctionDecl *
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12352) Sema::resolveAddressOfSingleOverloadCandidate(Expr *E, DeclAccessPair &Pair) {
3cde9bf9d5734 (George Burgess IV        2016-03-19 21:36:10 +0000 12353)   OverloadExpr::FindResult R = OverloadExpr::find(E);
3cde9bf9d5734 (George Burgess IV        2016-03-19 21:36:10 +0000 12354)   OverloadExpr *Ovl = R.Expression;
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12355)   bool IsResultAmbiguous = false;
3cde9bf9d5734 (George Burgess IV        2016-03-19 21:36:10 +0000 12356)   FunctionDecl *Result = nullptr;
3cde9bf9d5734 (George Burgess IV        2016-03-19 21:36:10 +0000 12357)   DeclAccessPair DAP;
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12358)   SmallVector<FunctionDecl *, 2> AmbiguousDecls;
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12359) 
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12360)   auto CheckMoreConstrained =
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12361)       [&] (FunctionDecl *FD1, FunctionDecl *FD2) -> Optional<bool> {
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12362)         SmallVector<const Expr *, 1> AC1, AC2;
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12363)         FD1->getAssociatedConstraints(AC1);
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12364)         FD2->getAssociatedConstraints(AC2);
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12365)         bool AtLeastAsConstrained1, AtLeastAsConstrained2;
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12366)         if (IsAtLeastAsConstrained(FD1, AC1, FD2, AC2, AtLeastAsConstrained1))
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12367)           return None;
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12368)         if (IsAtLeastAsConstrained(FD2, AC2, FD1, AC1, AtLeastAsConstrained2))
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12369)           return None;
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12370)         if (AtLeastAsConstrained1 == AtLeastAsConstrained2)
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12371)           return None;
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12372)         return AtLeastAsConstrained1;
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12373)       };
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12374) 
3cde9bf9d5734 (George Burgess IV        2016-03-19 21:36:10 +0000 12375)   // Don't use the AddressOfResolver because we're specifically looking for
3cde9bf9d5734 (George Burgess IV        2016-03-19 21:36:10 +0000 12376)   // cases where we have one overload candidate that lacks
3cde9bf9d5734 (George Burgess IV        2016-03-19 21:36:10 +0000 12377)   // enable_if/pass_object_size/...
3cde9bf9d5734 (George Burgess IV        2016-03-19 21:36:10 +0000 12378)   for (auto I = Ovl->decls_begin(), E = Ovl->decls_end(); I != E; ++I) {
3cde9bf9d5734 (George Burgess IV        2016-03-19 21:36:10 +0000 12379)     auto *FD = dyn_cast<FunctionDecl>(I->getUnderlyingDecl());
3cde9bf9d5734 (George Burgess IV        2016-03-19 21:36:10 +0000 12380)     if (!FD)
3cde9bf9d5734 (George Burgess IV        2016-03-19 21:36:10 +0000 12381)       return nullptr;
3cde9bf9d5734 (George Burgess IV        2016-03-19 21:36:10 +0000 12382) 
3cde9bf9d5734 (George Burgess IV        2016-03-19 21:36:10 +0000 12383)     if (!checkAddressOfFunctionIsAvailable(FD))
3cde9bf9d5734 (George Burgess IV        2016-03-19 21:36:10 +0000 12384)       continue;
3cde9bf9d5734 (George Burgess IV        2016-03-19 21:36:10 +0000 12385) 
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12386)     // We have more than one result - see if it is more constrained than the
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12387)     // previous one.
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12388)     if (Result) {
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12389)       Optional<bool> MoreConstrainedThanPrevious = CheckMoreConstrained(FD,
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12390)                                                                         Result);
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12391)       if (!MoreConstrainedThanPrevious) {
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12392)         IsResultAmbiguous = true;
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12393)         AmbiguousDecls.push_back(FD);
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12394)         continue;
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12395)       }
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12396)       if (!*MoreConstrainedThanPrevious)
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12397)         continue;
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12398)       // FD is more constrained - replace Result with it.
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12399)     }
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12400)     IsResultAmbiguous = false;
3cde9bf9d5734 (George Burgess IV        2016-03-19 21:36:10 +0000 12401)     DAP = I.getPair();
3cde9bf9d5734 (George Burgess IV        2016-03-19 21:36:10 +0000 12402)     Result = FD;
3cde9bf9d5734 (George Burgess IV        2016-03-19 21:36:10 +0000 12403)   }
3cde9bf9d5734 (George Burgess IV        2016-03-19 21:36:10 +0000 12404) 
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12405)   if (IsResultAmbiguous)
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12406)     return nullptr;
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12407) 
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12408)   if (Result) {
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12409)     SmallVector<const Expr *, 1> ResultAC;
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12410)     // We skipped over some ambiguous declarations which might be ambiguous with
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12411)     // the selected result.
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12412)     for (FunctionDecl *Skipped : AmbiguousDecls)
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12413)       if (!CheckMoreConstrained(Skipped, Result).hasValue())
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12414)         return nullptr;
3cde9bf9d5734 (George Burgess IV        2016-03-19 21:36:10 +0000 12415)     Pair = DAP;
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12416)   }
3cde9bf9d5734 (George Burgess IV        2016-03-19 21:36:10 +0000 12417)   return Result;
3cde9bf9d5734 (George Burgess IV        2016-03-19 21:36:10 +0000 12418) }
3cde9bf9d5734 (George Burgess IV        2016-03-19 21:36:10 +0000 12419) 
9fc8faf9e6197 (Adrian Prantl            2018-05-09 01:00:01 +0000 12420) /// Given an overloaded function, tries to turn it into a non-overloaded
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12421) /// function reference using resolveAddressOfSingleOverloadCandidate. This
beca4a3338ab3 (George Burgess IV        2016-06-08 00:34:22 +0000 12422) /// will perform access checks, diagnose the use of the resultant decl, and, if
1dbfa856b1172 (George Burgess IV        2017-05-09 04:06:24 +0000 12423) /// requested, potentially perform a function-to-pointer decay.
beca4a3338ab3 (George Burgess IV        2016-06-08 00:34:22 +0000 12424) ///
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12425) /// Returns false if resolveAddressOfSingleOverloadCandidate fails.
beca4a3338ab3 (George Burgess IV        2016-06-08 00:34:22 +0000 12426) /// Otherwise, returns true. This may emit diagnostics and return true.
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12427) bool Sema::resolveAndFixAddressOfSingleOverloadCandidate(
1dbfa856b1172 (George Burgess IV        2017-05-09 04:06:24 +0000 12428)     ExprResult &SrcExpr, bool DoFunctionPointerConverion) {
beca4a3338ab3 (George Burgess IV        2016-06-08 00:34:22 +0000 12429)   Expr *E = SrcExpr.get();
beca4a3338ab3 (George Burgess IV        2016-06-08 00:34:22 +0000 12430)   assert(E->getType() == Context.OverloadTy && "SrcExpr must be an overload");
beca4a3338ab3 (George Burgess IV        2016-06-08 00:34:22 +0000 12431) 
beca4a3338ab3 (George Burgess IV        2016-06-08 00:34:22 +0000 12432)   DeclAccessPair DAP;
b65b1f322bd88 (Saar Raz                 2020-01-09 15:07:51 +0200 12433)   FunctionDecl *Found = resolveAddressOfSingleOverloadCandidate(E, DAP);
3efe00206f0f4 (Erich Keane              2018-07-20 14:13:28 +0000 12434)   if (!Found || Found->isCPUDispatchMultiVersion() ||
3efe00206f0f4 (Erich Keane              2018-07-20 14:13:28 +0000 12435)       Found->isCPUSpecificMultiVersion())
beca4a3338ab3 (George Burgess IV        2016-06-08 00:34:22 +0000 12436)     return false;
beca4a3338ab3 (George Burgess IV        2016-06-08 00:34:22 +0000 12437) 
beca4a3338ab3 (George Burgess IV        2016-06-08 00:34:22 +0000 12438)   // Emitting multiple diagnostics for a function that is both inaccessible and
beca4a3338ab3 (George Burgess IV        2016-06-08 00:34:22 +0000 12439)   // unavailable is consistent with our behavior elsewhere. So, always check
beca4a3338ab3 (George Burgess IV        2016-06-08 00:34:22 +0000 12440)   // for both.
beca4a3338ab3 (George Burgess IV        2016-06-08 00:34:22 +0000 12441)   DiagnoseUseOfDecl(Found, E->getExprLoc());
beca4a3338ab3 (George Burgess IV        2016-06-08 00:34:22 +0000 12442)   CheckAddressOfMemberAccess(E, DAP);
beca4a3338ab3 (George Burgess IV        2016-06-08 00:34:22 +0000 12443)   Expr *Fixed = FixOverloadedFunctionReference(E, DAP, Found);
1dbfa856b1172 (George Burgess IV        2017-05-09 04:06:24 +0000 12444)   if (DoFunctionPointerConverion && Fixed->getType()->isFunctionType())
beca4a3338ab3 (George Burgess IV        2016-06-08 00:34:22 +0000 12445)     SrcExpr = DefaultFunctionArrayConversion(Fixed, /*Diagnose=*/false);
beca4a3338ab3 (George Burgess IV        2016-06-08 00:34:22 +0000 12446)   else
beca4a3338ab3 (George Burgess IV        2016-06-08 00:34:22 +0000 12447)     SrcExpr = Fixed;
beca4a3338ab3 (George Burgess IV        2016-06-08 00:34:22 +0000 12448)   return true;
beca4a3338ab3 (George Burgess IV        2016-06-08 00:34:22 +0000 12449) }
beca4a3338ab3 (George Burgess IV        2016-06-08 00:34:22 +0000 12450) 
9fc8faf9e6197 (Adrian Prantl            2018-05-09 01:00:01 +0000 12451) /// Given an expression that refers to an overloaded function, try to
8364e6b56856e (Douglas Gregor           2009-12-21 23:17:24 +0000 12452) /// resolve that overloaded function expression down to a single function.
8364e6b56856e (Douglas Gregor           2009-12-21 23:17:24 +0000 12453) ///
8364e6b56856e (Douglas Gregor           2009-12-21 23:17:24 +0000 12454) /// This routine can only resolve template-ids that refer to a single function
8364e6b56856e (Douglas Gregor           2009-12-21 23:17:24 +0000 12455) /// template, where that template-id refers to a single template whose template
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 12456) /// arguments are either provided by the template-id or have defaults,
8364e6b56856e (Douglas Gregor           2009-12-21 23:17:24 +0000 12457) /// as described in C++0x [temp.arg.explicit]p3.
67b47ac0a76bd (Alp Toker                2013-10-20 18:48:56 +0000 12458) ///
67b47ac0a76bd (Alp Toker                2013-10-20 18:48:56 +0000 12459) /// If no template-ids are found, no diagnostics are emitted and NULL is
67b47ac0a76bd (Alp Toker                2013-10-20 18:48:56 +0000 12460) /// returned.
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 12461) FunctionDecl *
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000 12462) Sema::ResolveSingleFunctionTemplateSpecialization(OverloadExpr *ovl,
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 12463)                                                   bool Complain,
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 12464)                                                   DeclAccessPair *FoundResult) {
8364e6b56856e (Douglas Gregor           2009-12-21 23:17:24 +0000 12465)   // C++ [over.over]p1:
8364e6b56856e (Douglas Gregor           2009-12-21 23:17:24 +0000 12466)   //   [...] [Note: any redundant set of parentheses surrounding the
8364e6b56856e (Douglas Gregor           2009-12-21 23:17:24 +0000 12467)   //   overloaded function name is ignored (5.1). ]
8364e6b56856e (Douglas Gregor           2009-12-21 23:17:24 +0000 12468)   // C++ [over.over]p1:
8364e6b56856e (Douglas Gregor           2009-12-21 23:17:24 +0000 12469)   //   [...] The overloaded function name can be preceded by the &
8364e6b56856e (Douglas Gregor           2009-12-21 23:17:24 +0000 12470)   //   operator.
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 12471) 
8364e6b56856e (Douglas Gregor           2009-12-21 23:17:24 +0000 12472)   // If we didn't actually find any template-ids, we're done.
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 12473)   if (!ovl->hasExplicitTemplateArgs())
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000 12474)     return nullptr;
1acbbb5a4c6e6 (John McCall              2010-02-02 06:20:04 +0000 12475) 
1acbbb5a4c6e6 (John McCall              2010-02-02 06:20:04 +0000 12476)   TemplateArgumentListInfo ExplicitTemplateArgs;
04ec5bfad8ff4 (James Y Knight           2015-12-24 02:59:37 +0000 12477)   ovl->copyTemplateArgumentsInto(ExplicitTemplateArgs);
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 12478)   TemplateSpecCandidateSet FailedCandidates(ovl->getNameLoc());
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 12479) 
8364e6b56856e (Douglas Gregor           2009-12-21 23:17:24 +0000 12480)   // Look through all of the overloaded functions, searching for one
8364e6b56856e (Douglas Gregor           2009-12-21 23:17:24 +0000 12481)   // whose type matches exactly.
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000 12482)   FunctionDecl *Matched = nullptr;
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 12483)   for (UnresolvedSetIterator I = ovl->decls_begin(),
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 12484)          E = ovl->decls_end(); I != E; ++I) {
8364e6b56856e (Douglas Gregor           2009-12-21 23:17:24 +0000 12485)     // C++0x [temp.arg.explicit]p3:
8364e6b56856e (Douglas Gregor           2009-12-21 23:17:24 +0000 12486)     //   [...] In contexts where deduction is done and fails, or in contexts
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 12487)     //   where deduction is not done, if a template argument list is
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 12488)     //   specified and it, along with any default template arguments,
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 12489)     //   identifies a single function template specialization, then the
8364e6b56856e (Douglas Gregor           2009-12-21 23:17:24 +0000 12490)     //   template-id is an lvalue for the function template specialization.
eebe72199e186 (Douglas Gregor           2010-07-14 23:20:53 +0000 12491)     FunctionTemplateDecl *FunctionTemplate
eebe72199e186 (Douglas Gregor           2010-07-14 23:20:53 +0000 12492)       = cast<FunctionTemplateDecl>((*I)->getUnderlyingDecl());
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 12493) 
8364e6b56856e (Douglas Gregor           2009-12-21 23:17:24 +0000 12494)     // C++ [over.over]p2:
8364e6b56856e (Douglas Gregor           2009-12-21 23:17:24 +0000 12495)     //   If the name is a function template, template argument deduction is
8364e6b56856e (Douglas Gregor           2009-12-21 23:17:24 +0000 12496)     //   done (14.8.2.2), and if the argument deduction succeeds, the
8364e6b56856e (Douglas Gregor           2009-12-21 23:17:24 +0000 12497)     //   resulting template argument list is used to generate a single
8364e6b56856e (Douglas Gregor           2009-12-21 23:17:24 +0000 12498)     //   function template specialization, which is added to the set of
8364e6b56856e (Douglas Gregor           2009-12-21 23:17:24 +0000 12499)     //   overloaded functions considered.
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000 12500)     FunctionDecl *Specialization = nullptr;
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 12501)     TemplateDeductionInfo Info(FailedCandidates.getLocation());
8364e6b56856e (Douglas Gregor           2009-12-21 23:17:24 +0000 12502)     if (TemplateDeductionResult Result
8364e6b56856e (Douglas Gregor           2009-12-21 23:17:24 +0000 12503)           = DeduceTemplateArguments(FunctionTemplate, &ExplicitTemplateArgs,
19a41f161b87b (Douglas Gregor           2013-04-17 08:45:07 +0000 12504)                                     Specialization, Info,
baa4783d310c7 (Richard Smith            2016-12-01 02:11:49 +0000 12505)                                     /*IsAddressOfFunction*/true)) {
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 12506)       // Make a note of the failed deduction for diagnostics.
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 12507)       // TODO: Actually use the failed-deduction info?
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 12508)       FailedCandidates.addCandidate()
c2bebe9acab26 (Richard Smith            2016-05-11 20:37:46 +0000 12509)           .set(I.getPair(), FunctionTemplate->getTemplatedDecl(),
98b20f1278e09 (Larisse Voufo            2013-07-19 23:00:19 +0000 12510)                MakeDeductionFailureInfo(Context, Result, Info));
8364e6b56856e (Douglas Gregor           2009-12-21 23:17:24 +0000 12511)       continue;
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 12512)     }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 12513) 
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 12514)     assert(Specialization && "no specialization and no error?");
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 12515) 
8364e6b56856e (Douglas Gregor           2009-12-21 23:17:24 +0000 12516)     // Multiple matches; we can't resolve to a single declaration.
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12517)     if (Matched) {
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12518)       if (Complain) {
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 12519)         Diag(ovl->getExprLoc(), diag::err_addr_ovl_ambiguous)
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 12520)           << ovl->getName();
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 12521)         NoteAllOverloadCandidates(ovl);
b491ed36b4ef9 (Douglas Gregor           2011-02-19 21:32:49 +0000 12522)       }
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000 12523)       return nullptr;
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 12524)     }
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000 12525) 
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 12526)     Matched = Specialization;
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000 12527)     if (FoundResult) *FoundResult = I.getPair();
8364e6b56856e (Douglas Gregor           2009-12-21 23:17:24 +0000 12528)   }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 12529) 
9095e5bf7e4fc (Richard Smith            2016-11-01 01:31:23 +0000 12530)   if (Matched &&
9095e5bf7e4fc (Richard Smith            2016-11-01 01:31:23 +0000 12531)       completeFunctionType(*this, Matched, ovl->getExprLoc(), Complain))
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000 12532)     return nullptr;
2a7d481faf546 (Richard Smith            2013-05-04 07:00:32 +0000 12533) 
8364e6b56856e (Douglas Gregor           2009-12-21 23:17:24 +0000 12534)   return Matched;
8364e6b56856e (Douglas Gregor           2009-12-21 23:17:24 +0000 12535) }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 12536) 
50a2c2c19de5e (John McCall              2011-10-11 23:14:30 +0000 12537) // Resolve and fix an overloaded expression that can be resolved
50a2c2c19de5e (John McCall              2011-10-11 23:14:30 +0000 12538) // because it identifies a single function template specialization.
50a2c2c19de5e (John McCall              2011-10-11 23:14:30 +0000 12539) //
1beec45a618b4 (Douglas Gregor           2011-03-12 01:48:56 +0000 12540) // Last three arguments should only be supplied if Complain = true
50a2c2c19de5e (John McCall              2011-10-11 23:14:30 +0000 12541) //
50a2c2c19de5e (John McCall              2011-10-11 23:14:30 +0000 12542) // Return true if it was logically possible to so resolve the
50a2c2c19de5e (John McCall              2011-10-11 23:14:30 +0000 12543) // expression, regardless of whether or not it succeeded.  Always
50a2c2c19de5e (John McCall              2011-10-11 23:14:30 +0000 12544) // returns true if 'complain' is set.
50a2c2c19de5e (John McCall              2011-10-11 23:14:30 +0000 12545) bool Sema::ResolveAndFixSingleFunctionTemplateSpecialization(
50a2c2c19de5e (John McCall              2011-10-11 23:14:30 +0000 12546)                       ExprResult &SrcExpr, bool doFunctionPointerConverion,
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000 12547)                       bool complain, SourceRange OpRangeForComplaining,
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000 12548)                                            QualType DestTypeForComplaining,
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 12549)                                             unsigned DiagIDForComplaining) {
50a2c2c19de5e (John McCall              2011-10-11 23:14:30 +0000 12550)   assert(SrcExpr.get()->getType() == Context.OverloadTy);
1beec45a618b4 (Douglas Gregor           2011-03-12 01:48:56 +0000 12551) 
50a2c2c19de5e (John McCall              2011-10-11 23:14:30 +0000 12552)   OverloadExpr::FindResult ovl = OverloadExpr::find(SrcExpr.get());
1beec45a618b4 (Douglas Gregor           2011-03-12 01:48:56 +0000 12553) 
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 12554)   DeclAccessPair found;
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 12555)   ExprResult SingleFunctionExpression;
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 12556)   if (FunctionDecl *fn = ResolveSingleFunctionTemplateSpecialization(
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 12557)                            ovl.Expression, /*complain*/ false, &found)) {
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000 12558)     if (DiagnoseUseOfDecl(fn, SrcExpr.get()->getBeginLoc())) {
50a2c2c19de5e (John McCall              2011-10-11 23:14:30 +0000 12559)       SrcExpr = ExprError();
50a2c2c19de5e (John McCall              2011-10-11 23:14:30 +0000 12560)       return true;
50a2c2c19de5e (John McCall              2011-10-11 23:14:30 +0000 12561)     }
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 12562) 
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 12563)     // It is only correct to resolve to an instance method if we're
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 12564)     // resolving a form that's permitted to be a pointer to member.
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 12565)     // Otherwise we'll end up making a bound member expression, which
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 12566)     // is illegal in all the contexts we resolve like this.
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 12567)     if (!ovl.HasFormOfMemberPointer &&
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 12568)         isa<CXXMethodDecl>(fn) &&
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 12569)         cast<CXXMethodDecl>(fn)->isInstance()) {
50a2c2c19de5e (John McCall              2011-10-11 23:14:30 +0000 12570)       if (!complain) return false;
50a2c2c19de5e (John McCall              2011-10-11 23:14:30 +0000 12571) 
50a2c2c19de5e (John McCall              2011-10-11 23:14:30 +0000 12572)       Diag(ovl.Expression->getExprLoc(),
50a2c2c19de5e (John McCall              2011-10-11 23:14:30 +0000 12573)            diag::err_bound_member_function)
50a2c2c19de5e (John McCall              2011-10-11 23:14:30 +0000 12574)         << 0 << ovl.Expression->getSourceRange();
50a2c2c19de5e (John McCall              2011-10-11 23:14:30 +0000 12575) 
50a2c2c19de5e (John McCall              2011-10-11 23:14:30 +0000 12576)       // TODO: I believe we only end up here if there's a mix of
50a2c2c19de5e (John McCall              2011-10-11 23:14:30 +0000 12577)       // static and non-static candidates (otherwise the expression
50a2c2c19de5e (John McCall              2011-10-11 23:14:30 +0000 12578)       // would have 'bound member' type, not 'overload' type).
50a2c2c19de5e (John McCall              2011-10-11 23:14:30 +0000 12579)       // Ideally we would note which candidate was chosen and why
50a2c2c19de5e (John McCall              2011-10-11 23:14:30 +0000 12580)       // the static candidates were rejected.
50a2c2c19de5e (John McCall              2011-10-11 23:14:30 +0000 12581)       SrcExpr = ExprError();
50a2c2c19de5e (John McCall              2011-10-11 23:14:30 +0000 12582)       return true;
1beec45a618b4 (Douglas Gregor           2011-03-12 01:48:56 +0000 12583)     }
89f3cd5c15212 (Douglas Gregor           2011-03-16 19:16:25 +0000 12584) 
a5202660fb2f2 (Sylvestre Ledru          2012-07-31 06:56:50 +0000 12585)     // Fix the expression to refer to 'fn'.
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 12586)     SingleFunctionExpression =
03ff2596cb161 (Nikola Smiljanic         2014-05-29 14:05:12 +0000 12587)         FixOverloadedFunctionReference(SrcExpr.get(), found, fn);
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 12588) 
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 12589)     // If desired, do function-to-pointer decay.
50a2c2c19de5e (John McCall              2011-10-11 23:14:30 +0000 12590)     if (doFunctionPointerConverion) {
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 12591)       SingleFunctionExpression =
01a7598561561 (Nikola Smiljanic         2014-05-29 10:55:11 +0000 12592)         DefaultFunctionArrayLvalueConversion(SingleFunctionExpression.get());
50a2c2c19de5e (John McCall              2011-10-11 23:14:30 +0000 12593)       if (SingleFunctionExpression.isInvalid()) {
50a2c2c19de5e (John McCall              2011-10-11 23:14:30 +0000 12594)         SrcExpr = ExprError();
50a2c2c19de5e (John McCall              2011-10-11 23:14:30 +0000 12595)         return true;
50a2c2c19de5e (John McCall              2011-10-11 23:14:30 +0000 12596)       }
50a2c2c19de5e (John McCall              2011-10-11 23:14:30 +0000 12597)     }
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 12598)   }
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 12599) 
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 12600)   if (!SingleFunctionExpression.isUsable()) {
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 12601)     if (complain) {
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 12602)       Diag(OpRangeForComplaining.getBegin(), DiagIDForComplaining)
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 12603)         << ovl.Expression->getName()
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 12604)         << DestTypeForComplaining
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000 12605)         << OpRangeForComplaining
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 12606)         << ovl.Expression->getQualifierLoc().getSourceRange();
50a2c2c19de5e (John McCall              2011-10-11 23:14:30 +0000 12607)       NoteAllOverloadCandidates(SrcExpr.get());
50a2c2c19de5e (John McCall              2011-10-11 23:14:30 +0000 12608) 
50a2c2c19de5e (John McCall              2011-10-11 23:14:30 +0000 12609)       SrcExpr = ExprError();
50a2c2c19de5e (John McCall              2011-10-11 23:14:30 +0000 12610)       return true;
50a2c2c19de5e (John McCall              2011-10-11 23:14:30 +0000 12611)     }
50a2c2c19de5e (John McCall              2011-10-11 23:14:30 +0000 12612) 
50a2c2c19de5e (John McCall              2011-10-11 23:14:30 +0000 12613)     return false;
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 12614)   }
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 12615) 
50a2c2c19de5e (John McCall              2011-10-11 23:14:30 +0000 12616)   SrcExpr = SingleFunctionExpression;
50a2c2c19de5e (John McCall              2011-10-11 23:14:30 +0000 12617)   return true;
1beec45a618b4 (Douglas Gregor           2011-03-12 01:48:56 +0000 12618) }
1beec45a618b4 (Douglas Gregor           2011-03-12 01:48:56 +0000 12619) 
9fc8faf9e6197 (Adrian Prantl            2018-05-09 01:00:01 +0000 12620) /// Add a single candidate to the overload set.
cabea40ea3c9b (Douglas Gregor           2009-09-22 15:41:20 +0000 12621) static void AddOverloadedCallCandidate(Sema &S,
a0296f7987c0a (John McCall              2010-03-19 07:35:19 +0000 12622)                                        DeclAccessPair FoundDecl,
739b107af8003 (Douglas Gregor           2011-03-03 02:41:12 +0000 12623)                                  TemplateArgumentListInfo *ExplicitTemplateArgs,
f857950d391d0 (Dmitri Gribenko          2013-01-12 19:30:44 +0000 12624)                                        ArrayRef<Expr *> Args,
cabea40ea3c9b (Douglas Gregor           2009-09-22 15:41:20 +0000 12625)                                        OverloadCandidateSet &CandidateSet,
95ce4f67a3369 (Richard Smith            2011-06-26 22:19:54 +0000 12626)                                        bool PartialOverloading,
95ce4f67a3369 (Richard Smith            2011-06-26 22:19:54 +0000 12627)                                        bool KnownValid) {
a0296f7987c0a (John McCall              2010-03-19 07:35:19 +0000 12628)   NamedDecl *Callee = FoundDecl.getDecl();
d14a86427f9cd (John McCall              2009-11-21 08:51:07 +0000 12629)   if (isa<UsingShadowDecl>(Callee))
d14a86427f9cd (John McCall              2009-11-21 08:51:07 +0000 12630)     Callee = cast<UsingShadowDecl>(Callee)->getTargetDecl();
d14a86427f9cd (John McCall              2009-11-21 08:51:07 +0000 12631) 
cabea40ea3c9b (Douglas Gregor           2009-09-22 15:41:20 +0000 12632)   if (FunctionDecl *Func = dyn_cast<FunctionDecl>(Callee)) {
95ce4f67a3369 (Richard Smith            2011-06-26 22:19:54 +0000 12633)     if (ExplicitTemplateArgs) {
95ce4f67a3369 (Richard Smith            2011-06-26 22:19:54 +0000 12634)       assert(!KnownValid && "Explicit template arguments?");
95ce4f67a3369 (Richard Smith            2011-06-26 22:19:54 +0000 12635)       return;
95ce4f67a3369 (Richard Smith            2011-06-26 22:19:54 +0000 12636)     }
370296302d037 (Bruno Cardoso Lopes      2017-04-26 20:13:45 +0000 12637)     // Prevent ill-formed function decls to be added as overload candidates.
370296302d037 (Bruno Cardoso Lopes      2017-04-26 20:13:45 +0000 12638)     if (!dyn_cast<FunctionProtoType>(Func->getType()->getAs<FunctionType>()))
370296302d037 (Bruno Cardoso Lopes      2017-04-26 20:13:45 +0000 12639)       return;
370296302d037 (Bruno Cardoso Lopes      2017-04-26 20:13:45 +0000 12640) 
975a9f6ecea60 (Francisco Lopes da Silva 2015-01-21 16:24:11 +0000 12641)     S.AddOverloadCandidate(Func, FoundDecl, Args, CandidateSet,
49a3ad21d6034 (Rui Ueyama               2019-07-16 04:46:31 +0000 12642)                            /*SuppressUserConversions=*/false,
b24b9aa298311 (Ahmed Charles            2012-02-25 11:00:22 +0000 12643)                            PartialOverloading);
cabea40ea3c9b (Douglas Gregor           2009-09-22 15:41:20 +0000 12644)     return;
d14a86427f9cd (John McCall              2009-11-21 08:51:07 +0000 12645)   }
d14a86427f9cd (John McCall              2009-11-21 08:51:07 +0000 12646) 
d14a86427f9cd (John McCall              2009-11-21 08:51:07 +0000 12647)   if (FunctionTemplateDecl *FuncTemplate
d14a86427f9cd (John McCall              2009-11-21 08:51:07 +0000 12648)       = dyn_cast<FunctionTemplateDecl>(Callee)) {
a0296f7987c0a (John McCall              2010-03-19 07:35:19 +0000 12649)     S.AddTemplateOverloadCandidate(FuncTemplate, FoundDecl,
975a9f6ecea60 (Francisco Lopes da Silva 2015-01-21 16:24:11 +0000 12650)                                    ExplicitTemplateArgs, Args, CandidateSet,
49a3ad21d6034 (Rui Ueyama               2019-07-16 04:46:31 +0000 12651)                                    /*SuppressUserConversions=*/false,
975a9f6ecea60 (Francisco Lopes da Silva 2015-01-21 16:24:11 +0000 12652)                                    PartialOverloading);
d14a86427f9cd (John McCall              2009-11-21 08:51:07 +0000 12653)     return;
d14a86427f9cd (John McCall              2009-11-21 08:51:07 +0000 12654)   }
d14a86427f9cd (John McCall              2009-11-21 08:51:07 +0000 12655) 
95ce4f67a3369 (Richard Smith            2011-06-26 22:19:54 +0000 12656)   assert(!KnownValid && "unhandled case in overloaded call candidate");
cabea40ea3c9b (Douglas Gregor           2009-09-22 15:41:20 +0000 12657) }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 12658) 
9fc8faf9e6197 (Adrian Prantl            2018-05-09 01:00:01 +0000 12659) /// Add the overload candidates named by callee and/or found by argument
cabea40ea3c9b (Douglas Gregor           2009-09-22 15:41:20 +0000 12660) /// dependent lookup to the given overload set.
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 12661) void Sema::AddOverloadedCallCandidates(UnresolvedLookupExpr *ULE,
f857950d391d0 (Dmitri Gribenko          2013-01-12 19:30:44 +0000 12662)                                        ArrayRef<Expr *> Args,
cabea40ea3c9b (Douglas Gregor           2009-09-22 15:41:20 +0000 12663)                                        OverloadCandidateSet &CandidateSet,
cabea40ea3c9b (Douglas Gregor           2009-09-22 15:41:20 +0000 12664)                                        bool PartialOverloading) {
d14a86427f9cd (John McCall              2009-11-21 08:51:07 +0000 12665) 
d14a86427f9cd (John McCall              2009-11-21 08:51:07 +0000 12666) #ifndef NDEBUG
d14a86427f9cd (John McCall              2009-11-21 08:51:07 +0000 12667)   // Verify that ArgumentDependentLookup is consistent with the rules
d14a86427f9cd (John McCall              2009-11-21 08:51:07 +0000 12668)   // in C++0x [basic.lookup.argdep]p3:
b8a9a41dd6ea0 (Douglas Gregor           2009-02-04 15:01:18 +0000 12669)   //
b8a9a41dd6ea0 (Douglas Gregor           2009-02-04 15:01:18 +0000 12670)   //   Let X be the lookup set produced by unqualified lookup (3.4.1)
b8a9a41dd6ea0 (Douglas Gregor           2009-02-04 15:01:18 +0000 12671)   //   and let Y be the lookup set produced by argument dependent
b8a9a41dd6ea0 (Douglas Gregor           2009-02-04 15:01:18 +0000 12672)   //   lookup (defined as follows). If X contains
b8a9a41dd6ea0 (Douglas Gregor           2009-02-04 15:01:18 +0000 12673)   //
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000 12674)   //     -- a declaration of a class member, or
b8a9a41dd6ea0 (Douglas Gregor           2009-02-04 15:01:18 +0000 12675)   //
b8a9a41dd6ea0 (Douglas Gregor           2009-02-04 15:01:18 +0000 12676)   //     -- a block-scope function declaration that is not a
d14a86427f9cd (John McCall              2009-11-21 08:51:07 +0000 12677)   //        using-declaration, or
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000 12678)   //
b8a9a41dd6ea0 (Douglas Gregor           2009-02-04 15:01:18 +0000 12679)   //     -- a declaration that is neither a function or a function
b8a9a41dd6ea0 (Douglas Gregor           2009-02-04 15:01:18 +0000 12680)   //        template
b8a9a41dd6ea0 (Douglas Gregor           2009-02-04 15:01:18 +0000 12681)   //
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000 12682)   //   then Y is empty.
d14a86427f9cd (John McCall              2009-11-21 08:51:07 +0000 12683) 
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 12684)   if (ULE->requiresADL()) {
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 12685)     for (UnresolvedLookupExpr::decls_iterator I = ULE->decls_begin(),
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 12686)            E = ULE->decls_end(); I != E; ++I) {
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 12687)       assert(!(*I)->getDeclContext()->isRecord());
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 12688)       assert(isa<UsingShadowDecl>(*I) ||
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 12689)              !(*I)->getDeclContext()->isFunctionOrMethod());
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 12690)       assert((*I)->getUnderlyingDecl()->isFunctionOrFunctionTemplate());
d14a86427f9cd (John McCall              2009-11-21 08:51:07 +0000 12691)     }
d14a86427f9cd (John McCall              2009-11-21 08:51:07 +0000 12692)   }
d14a86427f9cd (John McCall              2009-11-21 08:51:07 +0000 12693) #endif
d14a86427f9cd (John McCall              2009-11-21 08:51:07 +0000 12694) 
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 12695)   // It would be nice to avoid this copy.
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 12696)   TemplateArgumentListInfo TABuffer;
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000 12697)   TemplateArgumentListInfo *ExplicitTemplateArgs = nullptr;
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 12698)   if (ULE->hasExplicitTemplateArgs()) {
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 12699)     ULE->copyTemplateArgumentsInto(TABuffer);
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 12700)     ExplicitTemplateArgs = &TABuffer;
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 12701)   }
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 12702) 
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 12703)   for (UnresolvedLookupExpr::decls_iterator I = ULE->decls_begin(),
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 12704)          E = ULE->decls_end(); I != E; ++I)
b24b9aa298311 (Ahmed Charles            2012-02-25 11:00:22 +0000 12705)     AddOverloadedCallCandidate(*this, I.getPair(), ExplicitTemplateArgs, Args,
b24b9aa298311 (Ahmed Charles            2012-02-25 11:00:22 +0000 12706)                                CandidateSet, PartialOverloading,
b24b9aa298311 (Ahmed Charles            2012-02-25 11:00:22 +0000 12707)                                /*KnownValid*/ true);
d14a86427f9cd (John McCall              2009-11-21 08:51:07 +0000 12708) 
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 12709)   if (ULE->requiresADL())
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000 12710)     AddArgumentDependentLookupCandidates(ULE->getName(), ULE->getExprLoc(),
b24b9aa298311 (Ahmed Charles            2012-02-25 11:00:22 +0000 12711)                                          Args, ExplicitTemplateArgs,
b6626748c2e50 (Richard Smith            2012-10-18 17:56:02 +0000 12712)                                          CandidateSet, PartialOverloading);
cabea40ea3c9b (Douglas Gregor           2009-09-22 15:41:20 +0000 12713) }
d681c3959f85b (John McCall              2009-12-16 08:11:27 +0000 12714) 
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12715) /// Add the call candidates from the given set of lookup results to the given
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12716) /// overload set. Non-function lookup results are ignored.
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12717) void Sema::AddOverloadedCallCandidates(
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12718)     LookupResult &R, TemplateArgumentListInfo *ExplicitTemplateArgs,
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12719)     ArrayRef<Expr *> Args, OverloadCandidateSet &CandidateSet) {
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12720)   for (LookupResult::iterator I = R.begin(), E = R.end(); I != E; ++I)
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12721)     AddOverloadedCallCandidate(*this, I.getPair(), ExplicitTemplateArgs, Args,
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12722)                                CandidateSet, false, /*KnownValid*/ false);
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12723) }
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12724) 
0603bbb53c53c (Richard Smith            2013-06-12 22:56:54 +0000 12725) /// Determine whether a declaration with the specified name could be moved into
0603bbb53c53c (Richard Smith            2013-06-12 22:56:54 +0000 12726) /// a different namespace.
0603bbb53c53c (Richard Smith            2013-06-12 22:56:54 +0000 12727) static bool canBeDeclaredInNamespace(const DeclarationName &Name) {
0603bbb53c53c (Richard Smith            2013-06-12 22:56:54 +0000 12728)   switch (Name.getCXXOverloadedOperator()) {
0603bbb53c53c (Richard Smith            2013-06-12 22:56:54 +0000 12729)   case OO_New: case OO_Array_New:
0603bbb53c53c (Richard Smith            2013-06-12 22:56:54 +0000 12730)   case OO_Delete: case OO_Array_Delete:
0603bbb53c53c (Richard Smith            2013-06-12 22:56:54 +0000 12731)     return false;
0603bbb53c53c (Richard Smith            2013-06-12 22:56:54 +0000 12732) 
0603bbb53c53c (Richard Smith            2013-06-12 22:56:54 +0000 12733)   default:
0603bbb53c53c (Richard Smith            2013-06-12 22:56:54 +0000 12734)     return true;
0603bbb53c53c (Richard Smith            2013-06-12 22:56:54 +0000 12735)   }
0603bbb53c53c (Richard Smith            2013-06-12 22:56:54 +0000 12736) }
0603bbb53c53c (Richard Smith            2013-06-12 22:56:54 +0000 12737) 
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12738) /// Attempt to recover from an ill-formed use of a non-dependent name in a
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12739) /// template, where the non-dependent name was declared after the template
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12740) /// was defined. This is common in code written for a compilers which do not
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12741) /// correctly implement two-stage name lookup.
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12742) ///
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12743) /// Returns true if a viable candidate was found and a diagnostic was issued.
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12744) static bool DiagnoseTwoPhaseLookup(
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12745)     Sema &SemaRef, SourceLocation FnLoc, const CXXScopeSpec &SS,
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12746)     LookupResult &R, OverloadCandidateSet::CandidateSetKind CSK,
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12747)     TemplateArgumentListInfo *ExplicitTemplateArgs, ArrayRef<Expr *> Args,
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12748)     CXXRecordDecl **FoundInClass = nullptr) {
51ec0cf4aa94f (Richard Smith            2017-02-21 01:17:38 +0000 12749)   if (!SemaRef.inTemplateInstantiation() || !SS.isEmpty())
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12750)     return false;
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12751) 
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12752)   for (DeclContext *DC = SemaRef.CurContext; DC; DC = DC->getParent()) {
fcd5e7a1602cd (Nick Lewycky             2012-03-14 20:41:00 +0000 12753)     if (DC->isTransparentContext())
fcd5e7a1602cd (Nick Lewycky             2012-03-14 20:41:00 +0000 12754)       continue;
fcd5e7a1602cd (Nick Lewycky             2012-03-14 20:41:00 +0000 12755) 
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12756)     SemaRef.LookupQualifiedName(R, DC);
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12757) 
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12758)     if (!R.empty()) {
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12759)       R.suppressDiagnostics();
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12760) 
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000 12761)       OverloadCandidateSet Candidates(FnLoc, CSK);
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12762)       SemaRef.AddOverloadedCallCandidates(R, ExplicitTemplateArgs, Args,
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12763)                                           Candidates);
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12764) 
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12765)       OverloadCandidateSet::iterator Best;
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12766)       OverloadingResult OR =
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12767)           Candidates.BestViableFunction(SemaRef, FnLoc, Best);
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12768) 
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12769)       if (auto *RD = dyn_cast<CXXRecordDecl>(DC)) {
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12770)         // We either found non-function declarations or a best viable function
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12771)         // at class scope. A class-scope lookup result disables ADL. Don't
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12772)         // look past this, but let the caller know that we found something that
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12773)         // either is, or might be, usable in this class.
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12774)         if (FoundInClass) {
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12775)           *FoundInClass = RD;
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12776)           if (OR == OR_Success) {
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12777)             R.clear();
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12778)             R.addDecl(Best->FoundDecl.getDecl(), Best->FoundDecl.getAccess());
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12779)             R.resolveKind();
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12780)           }
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12781)         }
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12782)         return false;
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12783)       }
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12784) 
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12785)       if (OR != OR_Success) {
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12786)         // There wasn't a unique best function or function template.
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12787)         return false;
95ce4f67a3369 (Richard Smith            2011-06-26 22:19:54 +0000 12788)       }
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12789) 
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12790)       // Find the namespaces where ADL would have looked, and suggest
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12791)       // declaring the function there instead.
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12792)       Sema::AssociatedNamespaceSet AssociatedNamespaces;
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12793)       Sema::AssociatedClassSet AssociatedClasses;
7d8b041999de9 (John McCall              2012-08-24 20:38:34 +0000 12794)       SemaRef.FindAssociatedClassesAndNamespaces(FnLoc, Args,
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12795)                                                  AssociatedNamespaces,
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12796)                                                  AssociatedClasses);
d50f1690986f0 (Chandler Carruth         2011-06-05 23:36:55 +0000 12797)       Sema::AssociatedNamespaceSet SuggestedNamespaces;
0603bbb53c53c (Richard Smith            2013-06-12 22:56:54 +0000 12798)       if (canBeDeclaredInNamespace(R.getLookupName())) {
0603bbb53c53c (Richard Smith            2013-06-12 22:56:54 +0000 12799)         DeclContext *Std = SemaRef.getStdNamespace();
0603bbb53c53c (Richard Smith            2013-06-12 22:56:54 +0000 12800)         for (Sema::AssociatedNamespaceSet::iterator
0603bbb53c53c (Richard Smith            2013-06-12 22:56:54 +0000 12801)                it = AssociatedNamespaces.begin(),
0603bbb53c53c (Richard Smith            2013-06-12 22:56:54 +0000 12802)                end = AssociatedNamespaces.end(); it != end; ++it) {
0603bbb53c53c (Richard Smith            2013-06-12 22:56:54 +0000 12803)           // Never suggest declaring a function within namespace 'std'.
0603bbb53c53c (Richard Smith            2013-06-12 22:56:54 +0000 12804)           if (Std && Std->Encloses(*it))
0603bbb53c53c (Richard Smith            2013-06-12 22:56:54 +0000 12805)             continue;
21bae43fab8fa (Richard Smith            2012-12-22 02:46:14 +0000 12806) 
0603bbb53c53c (Richard Smith            2013-06-12 22:56:54 +0000 12807)           // Never suggest declaring a function within a namespace with a
0603bbb53c53c (Richard Smith            2013-06-12 22:56:54 +0000 12808)           // reserved name, like __gnu_cxx.
0603bbb53c53c (Richard Smith            2013-06-12 22:56:54 +0000 12809)           NamespaceDecl *NS = dyn_cast<NamespaceDecl>(*it);
0603bbb53c53c (Richard Smith            2013-06-12 22:56:54 +0000 12810)           if (NS &&
0603bbb53c53c (Richard Smith            2013-06-12 22:56:54 +0000 12811)               NS->getQualifiedNameAsString().find("__") != std::string::npos)
0603bbb53c53c (Richard Smith            2013-06-12 22:56:54 +0000 12812)             continue;
0603bbb53c53c (Richard Smith            2013-06-12 22:56:54 +0000 12813) 
0603bbb53c53c (Richard Smith            2013-06-12 22:56:54 +0000 12814)           SuggestedNamespaces.insert(*it);
0603bbb53c53c (Richard Smith            2013-06-12 22:56:54 +0000 12815)         }
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12816)       }
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12817) 
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12818)       SemaRef.Diag(R.getNameLoc(), diag::err_not_found_by_two_phase_lookup)
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12819)         << R.getLookupName();
d50f1690986f0 (Chandler Carruth         2011-06-05 23:36:55 +0000 12820)       if (SuggestedNamespaces.empty()) {
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12821)         SemaRef.Diag(Best->Function->getLocation(),
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12822)                      diag::note_not_found_by_two_phase_lookup)
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12823)           << R.getLookupName() << 0;
d50f1690986f0 (Chandler Carruth         2011-06-05 23:36:55 +0000 12824)       } else if (SuggestedNamespaces.size() == 1) {
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12825)         SemaRef.Diag(Best->Function->getLocation(),
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12826)                      diag::note_not_found_by_two_phase_lookup)
d50f1690986f0 (Chandler Carruth         2011-06-05 23:36:55 +0000 12827)           << R.getLookupName() << 1 << *SuggestedNamespaces.begin();
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12828)       } else {
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12829)         // FIXME: It would be useful to list the associated namespaces here,
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12830)         // but the diagnostics infrastructure doesn't provide a way to produce
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12831)         // a localized representation of a list of items.
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12832)         SemaRef.Diag(Best->Function->getLocation(),
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12833)                      diag::note_not_found_by_two_phase_lookup)
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12834)           << R.getLookupName() << 2;
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12835)       }
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12836) 
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12837)       // Try to recover by calling this function.
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12838)       return true;
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12839)     }
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12840) 
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12841)     R.clear();
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12842)   }
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12843) 
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12844)   return false;
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12845) }
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12846) 
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12847) /// Attempt to recover from ill-formed use of a non-dependent operator in a
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12848) /// template, where the non-dependent operator was declared after the template
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12849) /// was defined.
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12850) ///
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12851) /// Returns true if a viable candidate was found and a diagnostic was issued.
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12852) static bool
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12853) DiagnoseTwoPhaseOperatorLookup(Sema &SemaRef, OverloadedOperatorKind Op,
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12854)                                SourceLocation OpLoc,
f857950d391d0 (Dmitri Gribenko          2013-01-12 19:30:44 +0000 12855)                                ArrayRef<Expr *> Args) {
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12856)   DeclarationName OpName =
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12857)     SemaRef.Context.DeclarationNames.getCXXOperatorName(Op);
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12858)   LookupResult R(SemaRef, OpName, OpLoc, Sema::LookupOperatorName);
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12859)   return DiagnoseTwoPhaseLookup(SemaRef, OpLoc, CXXScopeSpec(), R,
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000 12860)                                 OverloadCandidateSet::CSK_Operator,
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000 12861)                                 /*ExplicitTemplateArgs=*/nullptr, Args);
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12862) }
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12863) 
8edb17d7538bf (Kaelyn Uhrain            2012-01-25 18:37:44 +0000 12864) namespace {
88d67f341279d (Richard Smith            2012-09-25 04:46:05 +0000 12865) class BuildRecoveryCallExprRAII {
88d67f341279d (Richard Smith            2012-09-25 04:46:05 +0000 12866)   Sema &SemaRef;
88d67f341279d (Richard Smith            2012-09-25 04:46:05 +0000 12867) public:
88d67f341279d (Richard Smith            2012-09-25 04:46:05 +0000 12868)   BuildRecoveryCallExprRAII(Sema &S) : SemaRef(S) {
88d67f341279d (Richard Smith            2012-09-25 04:46:05 +0000 12869)     assert(SemaRef.IsBuildingRecoveryCallExpr == false);
88d67f341279d (Richard Smith            2012-09-25 04:46:05 +0000 12870)     SemaRef.IsBuildingRecoveryCallExpr = true;
88d67f341279d (Richard Smith            2012-09-25 04:46:05 +0000 12871)   }
88d67f341279d (Richard Smith            2012-09-25 04:46:05 +0000 12872) 
88d67f341279d (Richard Smith            2012-09-25 04:46:05 +0000 12873)   ~BuildRecoveryCallExprRAII() {
88d67f341279d (Richard Smith            2012-09-25 04:46:05 +0000 12874)     SemaRef.IsBuildingRecoveryCallExpr = false;
88d67f341279d (Richard Smith            2012-09-25 04:46:05 +0000 12875)   }
88d67f341279d (Richard Smith            2012-09-25 04:46:05 +0000 12876) };
88d67f341279d (Richard Smith            2012-09-25 04:46:05 +0000 12877) 
ab9db51042d1b (Alexander Kornienko      2015-06-22 23:07:51 +0000 12878) }
8edb17d7538bf (Kaelyn Uhrain            2012-01-25 18:37:44 +0000 12879) 
d681c3959f85b (John McCall              2009-12-16 08:11:27 +0000 12880) /// Attempts to recover from a call where no functions were found.
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12881) ///
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12882) /// This function will do one of three things:
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12883) ///  * Diagnose, recover, and return a recovery expression.
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12884) ///  * Diagnose, fail to recover, and return ExprError().
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12885) ///  * Do not diagnose, do not recover, and return ExprResult(). The caller is
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12886) ///    expected to diagnose as appropriate.
dadc575b1e878 (John McCall              2010-08-24 06:29:42 +0000 12887) static ExprResult
2fb18b746fdb2 (Douglas Gregor           2010-04-14 20:27:54 +0000 12888) BuildRecoveryCallExpr(Sema &SemaRef, Scope *S, Expr *Fn,
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 12889)                       UnresolvedLookupExpr *ULE,
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 12890)                       SourceLocation LParenLoc,
e3d2ecbe86eee (Craig Topper             2014-06-28 23:22:33 +0000 12891)                       MutableArrayRef<Expr *> Args,
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 12892)                       SourceLocation RParenLoc,
9afaf793b36dc (Kaelyn Uhrain            2012-01-25 21:11:35 +0000 12893)                       bool EmptyLookup, bool AllowTypoCorrection) {
88d67f341279d (Richard Smith            2012-09-25 04:46:05 +0000 12894)   // Do not try to recover if it is already building a recovery call.
88d67f341279d (Richard Smith            2012-09-25 04:46:05 +0000 12895)   // This stops infinite loops for template instantiations like
88d67f341279d (Richard Smith            2012-09-25 04:46:05 +0000 12896)   //
88d67f341279d (Richard Smith            2012-09-25 04:46:05 +0000 12897)   // template <typename T> auto foo(T t) -> decltype(foo(t)) {}
88d67f341279d (Richard Smith            2012-09-25 04:46:05 +0000 12898)   // template <typename T> auto foo(T t) -> decltype(foo(&t)) {}
88d67f341279d (Richard Smith            2012-09-25 04:46:05 +0000 12899)   if (SemaRef.IsBuildingRecoveryCallExpr)
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12900)     return ExprResult();
88d67f341279d (Richard Smith            2012-09-25 04:46:05 +0000 12901)   BuildRecoveryCallExprRAII RCE(SemaRef);
d681c3959f85b (John McCall              2009-12-16 08:11:27 +0000 12902) 
d681c3959f85b (John McCall              2009-12-16 08:11:27 +0000 12903)   CXXScopeSpec SS;
0da1d43e1600a (Douglas Gregor           2011-02-28 20:01:57 +0000 12904)   SS.Adopt(ULE->getQualifierLoc());
7945c981b974f (Abramo Bagnara           2012-01-27 09:46:47 +0000 12905)   SourceLocation TemplateKWLoc = ULE->getTemplateKeywordLoc();
d681c3959f85b (John McCall              2009-12-16 08:11:27 +0000 12906) 
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 12907)   TemplateArgumentListInfo TABuffer;
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000 12908)   TemplateArgumentListInfo *ExplicitTemplateArgs = nullptr;
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 12909)   if (ULE->hasExplicitTemplateArgs()) {
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 12910)     ULE->copyTemplateArgumentsInto(TABuffer);
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 12911)     ExplicitTemplateArgs = &TABuffer;
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 12912)   }
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 12913) 
d681c3959f85b (John McCall              2009-12-16 08:11:27 +0000 12914)   LookupResult R(SemaRef, ULE->getName(), ULE->getNameLoc(),
d681c3959f85b (John McCall              2009-12-16 08:11:27 +0000 12915)                  Sema::LookupOrdinaryName);
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12916)   CXXRecordDecl *FoundInClass = nullptr;
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12917)   if (DiagnoseTwoPhaseLookup(SemaRef, Fn->getExprLoc(), SS, R,
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12918)                              OverloadCandidateSet::CSK_Normal,
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12919)                              ExplicitTemplateArgs, Args, &FoundInClass)) {
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12920)     // OK, diagnosed a two-phase lookup issue.
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12921)   } else if (EmptyLookup) {
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12922)     // Try to recover from an empty lookup with typo correction.
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12923)     R.clear();
70ad396bc49a9 (Bruno Ricci              2019-03-25 17:08:51 +0000 12924)     NoTypoCorrectionCCC NoTypoValidator{};
70ad396bc49a9 (Bruno Ricci              2019-03-25 17:08:51 +0000 12925)     FunctionCallFilterCCC FunctionCallValidator(SemaRef, Args.size(),
70ad396bc49a9 (Bruno Ricci              2019-03-25 17:08:51 +0000 12926)                                                 ExplicitTemplateArgs != nullptr,
70ad396bc49a9 (Bruno Ricci              2019-03-25 17:08:51 +0000 12927)                                                 dyn_cast<MemberExpr>(Fn));
70ad396bc49a9 (Bruno Ricci              2019-03-25 17:08:51 +0000 12928)     CorrectionCandidateCallback &Validator =
70ad396bc49a9 (Bruno Ricci              2019-03-25 17:08:51 +0000 12929)         AllowTypoCorrection
70ad396bc49a9 (Bruno Ricci              2019-03-25 17:08:51 +0000 12930)             ? static_cast<CorrectionCandidateCallback &>(FunctionCallValidator)
70ad396bc49a9 (Bruno Ricci              2019-03-25 17:08:51 +0000 12931)             : static_cast<CorrectionCandidateCallback &>(NoTypoValidator);
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12932)     if (SemaRef.DiagnoseEmptyLookup(S, SS, R, Validator, ExplicitTemplateArgs,
70ad396bc49a9 (Bruno Ricci              2019-03-25 17:08:51 +0000 12933)                                     Args))
70ad396bc49a9 (Bruno Ricci              2019-03-25 17:08:51 +0000 12934)       return ExprError();
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12935)   } else if (FoundInClass && SemaRef.getLangOpts().MSVCCompat) {
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12936)     // We found a usable declaration of the name in a dependent base of some
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12937)     // enclosing class.
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12938)     // FIXME: We should also explain why the candidates found by name lookup
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12939)     // were not viable.
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12940)     if (SemaRef.DiagnoseDependentMemberLookup(R))
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12941)       return ExprError();
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12942)   } else {
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12943)     // We had viable candidates and couldn't recover; let the caller diagnose
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12944)     // this.
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12945)     return ExprResult();
70ad396bc49a9 (Bruno Ricci              2019-03-25 17:08:51 +0000 12946)   }
d681c3959f85b (John McCall              2009-12-16 08:11:27 +0000 12947) 
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12948)   // If we get here, we should have issued a diagnostic and formed a recovery
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 12949)   // lookup result.
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 12950)   assert(!R.empty() && "lookup results empty despite recovery");
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 12951) 
151c4568581f1 (Richard Smith            2016-12-20 21:35:28 +0000 12952)   // If recovery created an ambiguity, just bail out.
151c4568581f1 (Richard Smith            2016-12-20 21:35:28 +0000 12953)   if (R.isAmbiguous()) {
151c4568581f1 (Richard Smith            2016-12-20 21:35:28 +0000 12954)     R.suppressDiagnostics();
151c4568581f1 (Richard Smith            2016-12-20 21:35:28 +0000 12955)     return ExprError();
151c4568581f1 (Richard Smith            2016-12-20 21:35:28 +0000 12956)   }
151c4568581f1 (Richard Smith            2016-12-20 21:35:28 +0000 12957) 
d972d4c749048 (Haojian Wu               2021-01-22 12:15:05 +0100 12958)   // Build an implicit member call if appropriate.  Just drop the
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 12959)   // casts and such from the call, we don't really care.
faf5fb4b78c79 (John McCall              2010-08-26 23:41:50 +0000 12960)   ExprResult NewFn = ExprError();
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 12961)   if ((*R.begin())->isCXXClassMember())
6924dcdf6f737 (Aaron Ballman            2015-09-01 14:49:24 +0000 12962)     NewFn = SemaRef.BuildPossibleImplicitMemberExpr(SS, TemplateKWLoc, R,
6924dcdf6f737 (Aaron Ballman            2015-09-01 14:49:24 +0000 12963)                                                     ExplicitTemplateArgs, S);
65f7c3dba22f0 (Abramo Bagnara           2012-02-06 14:31:00 +0000 12964)   else if (ExplicitTemplateArgs || TemplateKWLoc.isValid())
7945c981b974f (Abramo Bagnara           2012-01-27 09:46:47 +0000 12965)     NewFn = SemaRef.BuildTemplateIdExpr(SS, TemplateKWLoc, R, false,
65f7c3dba22f0 (Abramo Bagnara           2012-02-06 14:31:00 +0000 12966)                                         ExplicitTemplateArgs);
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 12967)   else
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 12968)     NewFn = SemaRef.BuildDeclarationNameExpr(SS, R, false);
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 12969) 
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 12970)   if (NewFn.isInvalid())
faf5fb4b78c79 (John McCall              2010-08-26 23:41:50 +0000 12971)     return ExprError();
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 12972) 
d972d4c749048 (Haojian Wu               2021-01-22 12:15:05 +0100 12973)   // This shouldn't cause an infinite loop because we're giving it
d972d4c749048 (Haojian Wu               2021-01-22 12:15:05 +0100 12974)   // an expression with viable lookup results, which should never
d972d4c749048 (Haojian Wu               2021-01-22 12:15:05 +0100 12975)   // end up here.
d972d4c749048 (Haojian Wu               2021-01-22 12:15:05 +0100 12976)   return SemaRef.BuildCallExpr(/*Scope*/ nullptr, NewFn.get(), LParenLoc,
d972d4c749048 (Haojian Wu               2021-01-22 12:15:05 +0100 12977)                                MultiExprArg(Args.data(), Args.size()),
d972d4c749048 (Haojian Wu               2021-01-22 12:15:05 +0100 12978)                                RParenLoc);
d681c3959f85b (John McCall              2009-12-16 08:11:27 +0000 12979) }
4038cf4b57da3 (Douglas Gregor           2010-06-08 17:35:15 +0000 12980) 
9fc8faf9e6197 (Adrian Prantl            2018-05-09 01:00:01 +0000 12981) /// Constructs and populates an OverloadedCandidateSet from
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 12982) /// the given function.
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 12983) /// \returns true when an the ExprResult output parameter has been set.
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 12984) bool Sema::buildOverloadedCallSet(Scope *S, Expr *Fn,
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 12985)                                   UnresolvedLookupExpr *ULE,
9c785c217b3f9 (Dmitri Gribenko          2013-05-09 21:02:07 +0000 12986)                                   MultiExprArg Args,
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 12987)                                   SourceLocation RParenLoc,
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 12988)                                   OverloadCandidateSet *CandidateSet,
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 12989)                                   ExprResult *Result) {
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 12990) #ifndef NDEBUG
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 12991)   if (ULE->requiresADL()) {
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 12992)     // To do ADL, we must have found an unqualified name.
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 12993)     assert(!ULE->getQualifier() && "qualified name with ADL");
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 12994) 
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 12995)     // We don't perform ADL for implicit declarations of builtins.
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 12996)     // Verify that this was correctly set up.
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 12997)     FunctionDecl *F;
b23c5e8c3df85 (Richard Smith            2019-05-09 03:31:27 +0000 12998)     if (ULE->decls_begin() != ULE->decls_end() &&
b23c5e8c3df85 (Richard Smith            2019-05-09 03:31:27 +0000 12999)         ULE->decls_begin() + 1 == ULE->decls_end() &&
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 13000)         (F = dyn_cast<FunctionDecl>(*ULE->decls_begin())) &&
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 13001)         F->getBuiltinID() && F->isImplicit())
83d382b1cad13 (David Blaikie            2011-09-23 05:06:16 +0000 13002)       llvm_unreachable("performing ADL for builtin");
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 13003) 
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 13004)     // We don't perform ADL in C.
bbafb8a745736 (David Blaikie            2012-03-11 07:00:24 +0000 13005)     assert(getLangOpts().CPlusPlus && "ADL enabled in C");
b6626748c2e50 (Richard Smith            2012-10-18 17:56:02 +0000 13006)   }
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 13007) #endif
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 13008) 
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000 13009)   UnbridgedCastsSet UnbridgedCasts;
9c785c217b3f9 (Dmitri Gribenko          2013-05-09 21:02:07 +0000 13010)   if (checkArgPlaceholdersForOverload(*this, Args, UnbridgedCasts)) {
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 13011)     *Result = ExprError();
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 13012)     return true;
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 13013)   }
e254f90d94e32 (Douglas Gregor           2009-02-04 00:32:51 +0000 13014) 
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 13015)   // Add the functions denoted by the callee to the set of candidate
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 13016)   // functions, including those from argument-dependent lookup.
9c785c217b3f9 (Dmitri Gribenko          2013-05-09 21:02:07 +0000 13017)   AddOverloadedCallCandidates(ULE, Args, *CandidateSet);
d681c3959f85b (John McCall              2009-12-16 08:11:27 +0000 13018) 
b274738725f2e (Hans Wennborg            2015-06-12 21:23:23 +0000 13019)   if (getLangOpts().MSVCCompat &&
b274738725f2e (Hans Wennborg            2015-06-12 21:23:23 +0000 13020)       CurContext->isDependentContext() && !isSFINAEContext() &&
64937c6f97fc4 (Hans Wennborg            2015-06-11 21:21:57 +0000 13021)       (isa<FunctionDecl>(CurContext) || isa<CXXRecordDecl>(CurContext))) {
64937c6f97fc4 (Hans Wennborg            2015-06-11 21:21:57 +0000 13022) 
64937c6f97fc4 (Hans Wennborg            2015-06-11 21:21:57 +0000 13023)     OverloadCandidateSet::iterator Best;
64937c6f97fc4 (Hans Wennborg            2015-06-11 21:21:57 +0000 13024)     if (CandidateSet->empty() ||
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000 13025)         CandidateSet->BestViableFunction(*this, Fn->getBeginLoc(), Best) ==
64937c6f97fc4 (Hans Wennborg            2015-06-11 21:21:57 +0000 13026)             OR_No_Viable_Function) {
c5885cffc5206 (Bruno Ricci              2018-12-21 15:20:32 +0000 13027)       // In Microsoft mode, if we are inside a template class member function
c5885cffc5206 (Bruno Ricci              2018-12-21 15:20:32 +0000 13028)       // then create a type dependent CallExpr. The goal is to postpone name
c5885cffc5206 (Bruno Ricci              2018-12-21 15:20:32 +0000 13029)       // lookup to instantiation time to be able to search into type dependent
c5885cffc5206 (Bruno Ricci              2018-12-21 15:20:32 +0000 13030)       // base classes.
70e7aa4a4ed36 (Serge Pavlov             2020-07-24 12:04:19 +0700 13031)       CallExpr *CE =
70e7aa4a4ed36 (Serge Pavlov             2020-07-24 12:04:19 +0700 13032)           CallExpr::Create(Context, Fn, Args, Context.DependentTy, VK_RValue,
70e7aa4a4ed36 (Serge Pavlov             2020-07-24 12:04:19 +0700 13033)                            RParenLoc, CurFPFeatureOverrides());
b4f02d89e5d8d (Sam McCall               2020-03-18 23:38:08 +0100 13034)       CE->markDependentForPostponedNameLookup();
03ff2596cb161 (Nikola Smiljanic         2014-05-29 14:05:12 +0000 13035)       *Result = CE;
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 13036)       return true;
b49c46c25cdc6 (Sebastian Redl           2011-09-24 17:48:00 +0000 13037)     }
bcf6471010a1c (Francois Pichet          2011-09-07 00:14:57 +0000 13038)   }
d681c3959f85b (John McCall              2009-12-16 08:11:27 +0000 13039) 
64937c6f97fc4 (Hans Wennborg            2015-06-11 21:21:57 +0000 13040)   if (CandidateSet->empty())
64937c6f97fc4 (Hans Wennborg            2015-06-11 21:21:57 +0000 13041)     return false;
64937c6f97fc4 (Hans Wennborg            2015-06-11 21:21:57 +0000 13042) 
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000 13043)   UnbridgedCasts.restore();
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 13044)   return false;
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 13045) }
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000 13046) 
8222107aa9249 (Haojian Wu               2020-05-08 16:13:17 +0200 13047) // Guess at what the return type for an unresolvable overload should be.
8222107aa9249 (Haojian Wu               2020-05-08 16:13:17 +0200 13048) static QualType chooseRecoveryType(OverloadCandidateSet &CS,
8222107aa9249 (Haojian Wu               2020-05-08 16:13:17 +0200 13049)                                    OverloadCandidateSet::iterator *Best) {
8222107aa9249 (Haojian Wu               2020-05-08 16:13:17 +0200 13050)   llvm::Optional<QualType> Result;
8222107aa9249 (Haojian Wu               2020-05-08 16:13:17 +0200 13051)   // Adjust Type after seeing a candidate.
8222107aa9249 (Haojian Wu               2020-05-08 16:13:17 +0200 13052)   auto ConsiderCandidate = [&](const OverloadCandidate &Candidate) {
8222107aa9249 (Haojian Wu               2020-05-08 16:13:17 +0200 13053)     if (!Candidate.Function)
8222107aa9249 (Haojian Wu               2020-05-08 16:13:17 +0200 13054)       return;
031738a561184 (Haojian Wu               2020-08-11 13:49:11 +0200 13055)     if (Candidate.Function->isInvalidDecl())
031738a561184 (Haojian Wu               2020-08-11 13:49:11 +0200 13056)       return;
96a5cfff208d8 (Haojian Wu               2020-07-08 13:53:47 +0200 13057)     QualType T = Candidate.Function->getReturnType();
8222107aa9249 (Haojian Wu               2020-05-08 16:13:17 +0200 13058)     if (T.isNull())
8222107aa9249 (Haojian Wu               2020-05-08 16:13:17 +0200 13059)       return;
8222107aa9249 (Haojian Wu               2020-05-08 16:13:17 +0200 13060)     if (!Result)
8222107aa9249 (Haojian Wu               2020-05-08 16:13:17 +0200 13061)       Result = T;
8222107aa9249 (Haojian Wu               2020-05-08 16:13:17 +0200 13062)     else if (Result != T)
8222107aa9249 (Haojian Wu               2020-05-08 16:13:17 +0200 13063)       Result = QualType();
8222107aa9249 (Haojian Wu               2020-05-08 16:13:17 +0200 13064)   };
8222107aa9249 (Haojian Wu               2020-05-08 16:13:17 +0200 13065) 
8222107aa9249 (Haojian Wu               2020-05-08 16:13:17 +0200 13066)   // Look for an unambiguous type from a progressively larger subset.
8222107aa9249 (Haojian Wu               2020-05-08 16:13:17 +0200 13067)   // e.g. if types disagree, but all *viable* overloads return int, choose int.
8222107aa9249 (Haojian Wu               2020-05-08 16:13:17 +0200 13068)   //
8222107aa9249 (Haojian Wu               2020-05-08 16:13:17 +0200 13069)   // First, consider only the best candidate.
8222107aa9249 (Haojian Wu               2020-05-08 16:13:17 +0200 13070)   if (Best && *Best != CS.end())
8222107aa9249 (Haojian Wu               2020-05-08 16:13:17 +0200 13071)     ConsiderCandidate(**Best);
8222107aa9249 (Haojian Wu               2020-05-08 16:13:17 +0200 13072)   // Next, consider only viable candidates.
8222107aa9249 (Haojian Wu               2020-05-08 16:13:17 +0200 13073)   if (!Result)
8222107aa9249 (Haojian Wu               2020-05-08 16:13:17 +0200 13074)     for (const auto &C : CS)
8222107aa9249 (Haojian Wu               2020-05-08 16:13:17 +0200 13075)       if (C.Viable)
8222107aa9249 (Haojian Wu               2020-05-08 16:13:17 +0200 13076)         ConsiderCandidate(C);
8222107aa9249 (Haojian Wu               2020-05-08 16:13:17 +0200 13077)   // Finally, consider all candidates.
8222107aa9249 (Haojian Wu               2020-05-08 16:13:17 +0200 13078)   if (!Result)
8222107aa9249 (Haojian Wu               2020-05-08 16:13:17 +0200 13079)     for (const auto &C : CS)
8222107aa9249 (Haojian Wu               2020-05-08 16:13:17 +0200 13080)       ConsiderCandidate(C);
8222107aa9249 (Haojian Wu               2020-05-08 16:13:17 +0200 13081) 
7f05fe1aeeb00 (Haojian Wu               2020-10-05 12:52:03 +0200 13082)   if (!Result)
7f05fe1aeeb00 (Haojian Wu               2020-10-05 12:52:03 +0200 13083)     return QualType();
7f05fe1aeeb00 (Haojian Wu               2020-10-05 12:52:03 +0200 13084)   auto Value = Result.getValue();
7f05fe1aeeb00 (Haojian Wu               2020-10-05 12:52:03 +0200 13085)   if (Value.isNull() || Value->isUndeducedType())
7f05fe1aeeb00 (Haojian Wu               2020-10-05 12:52:03 +0200 13086)     return QualType();
7f05fe1aeeb00 (Haojian Wu               2020-10-05 12:52:03 +0200 13087)   return Value;
8222107aa9249 (Haojian Wu               2020-05-08 16:13:17 +0200 13088) }
8222107aa9249 (Haojian Wu               2020-05-08 16:13:17 +0200 13089) 
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 13090) /// FinishOverloadedCallExpr - given an OverloadCandidateSet, builds and returns
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 13091) /// the completed call expression. If overload resolution fails, emits
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 13092) /// diagnostics and returns ExprError()
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 13093) static ExprResult FinishOverloadedCallExpr(Sema &SemaRef, Scope *S, Expr *Fn,
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 13094)                                            UnresolvedLookupExpr *ULE,
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 13095)                                            SourceLocation LParenLoc,
9c785c217b3f9 (Dmitri Gribenko          2013-05-09 21:02:07 +0000 13096)                                            MultiExprArg Args,
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 13097)                                            SourceLocation RParenLoc,
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 13098)                                            Expr *ExecConfig,
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 13099)                                            OverloadCandidateSet *CandidateSet,
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 13100)                                            OverloadCandidateSet::iterator *Best,
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 13101)                                            OverloadingResult OverloadResult,
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 13102)                                            bool AllowTypoCorrection) {
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 13103)   switch (OverloadResult) {
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 13104)   case OR_Success: {
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 13105)     FunctionDecl *FDecl = (*Best)->Function;
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 13106)     SemaRef.CheckUnresolvedLookupAccess(ULE, (*Best)->FoundDecl);
22262abd78af0 (Richard Smith            2013-05-04 06:44:46 +0000 13107)     if (SemaRef.DiagnoseUseOfDecl(FDecl, ULE->getNameLoc()))
22262abd78af0 (Richard Smith            2013-05-04 06:44:46 +0000 13108)       return ExprError();
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 13109)     Fn = SemaRef.FixOverloadedFunctionReference(Fn, (*Best)->FoundDecl, FDecl);
9c785c217b3f9 (Dmitri Gribenko          2013-05-09 21:02:07 +0000 13110)     return SemaRef.BuildResolvedCallExpr(Fn, FDecl, LParenLoc, Args, RParenLoc,
5cdc2cda28ac8 (Eric Fiselier            2018-12-12 21:50:55 +0000 13111)                                          ExecConfig, /*IsExecConfig=*/false,
5cdc2cda28ac8 (Eric Fiselier            2018-12-12 21:50:55 +0000 13112)                                          (*Best)->IsADLCandidate);
5750077300414 (John McCall              2009-12-16 12:17:52 +0000 13113)   }
99dcbff1542f3 (Douglas Gregor           2008-11-26 05:54:23 +0000 13114) 
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 13115)   case OR_No_Viable_Function: {
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 13116)     // Try to recover by looking for viable functions which the user might
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 13117)     // have meant to call.
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 13118)     ExprResult Recovery = BuildRecoveryCallExpr(SemaRef, S, Fn, ULE, LParenLoc,
9c785c217b3f9 (Dmitri Gribenko          2013-05-09 21:02:07 +0000 13119)                                                 Args, RParenLoc,
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 13120)                                                 CandidateSet->empty(),
9afaf793b36dc (Kaelyn Uhrain            2012-01-25 21:11:35 +0000 13121)                                                 AllowTypoCorrection);
c4fb7720ceb30 (Richard Smith            2020-12-02 17:46:28 -0800 13122)     if (Recovery.isInvalid() || Recovery.isUsable())
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 13123)       return Recovery;
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 13124) 
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 13125)     // If the user passes in a function that we can't take the address of, we
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 13126)     // generally end up emitting really bad error messages. Here, we attempt to
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 13127)     // emit better ones.
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 13128)     for (const Expr *Arg : Args) {
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 13129)       if (!Arg->getType()->isFunctionType())
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 13130)         continue;
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 13131)       if (auto *DRE = dyn_cast<DeclRefExpr>(Arg->IgnoreParenImpCasts())) {
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 13132)         auto *FD = dyn_cast<FunctionDecl>(DRE->getDecl());
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 13133)         if (FD &&
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 13134)             !SemaRef.checkAddressOfFunctionIsAvailable(FD, /*Complain=*/true,
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 13135)                                                        Arg->getExprLoc()))
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 13136)           return ExprError();
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 13137)       }
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 13138)     }
3e3bb95b6951c (George Burgess IV        2015-12-02 21:58:08 +0000 13139) 
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 13140)     CandidateSet->NoteCandidates(
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 13141)         PartialDiagnosticAt(
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 13142)             Fn->getBeginLoc(),
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 13143)             SemaRef.PDiag(diag::err_ovl_no_viable_function_in_call)
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 13144)                 << ULE->getName() << Fn->getSourceRange()),
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 13145)         SemaRef, OCD_AllCandidates, Args);
99dcbff1542f3 (Douglas Gregor           2008-11-26 05:54:23 +0000 13146)     break;
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 13147)   }
99dcbff1542f3 (Douglas Gregor           2008-11-26 05:54:23 +0000 13148) 
99dcbff1542f3 (Douglas Gregor           2008-11-26 05:54:23 +0000 13149)   case OR_Ambiguous:
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 13150)     CandidateSet->NoteCandidates(
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 13151)         PartialDiagnosticAt(Fn->getBeginLoc(),
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 13152)                             SemaRef.PDiag(diag::err_ovl_ambiguous_call)
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 13153)                                 << ULE->getName() << Fn->getSourceRange()),
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 13154)         SemaRef, OCD_AmbiguousCandidates, Args);
99dcbff1542f3 (Douglas Gregor           2008-11-26 05:54:23 +0000 13155)     break;
171c45ab0c19b (Douglas Gregor           2009-02-18 21:56:37 +0000 13156) 
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 13157)   case OR_Deleted: {
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 13158)     CandidateSet->NoteCandidates(
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 13159)         PartialDiagnosticAt(Fn->getBeginLoc(),
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 13160)                             SemaRef.PDiag(diag::err_ovl_deleted_call)
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 13161)                                 << ULE->getName() << Fn->getSourceRange()),
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 13162)         SemaRef, OCD_AllCandidates, Args);
3eaa22af57876 (Argyrios Kyrtzidis       2011-11-04 15:58:13 +0000 13163) 
2a8c18d991188 (Alexander Kornienko      2018-04-06 15:14:32 +0000 13164)     // We emitted an error for the unavailable/deleted function call but keep
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 13165)     // the call in the AST.
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 13166)     FunctionDecl *FDecl = (*Best)->Function;
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 13167)     Fn = SemaRef.FixOverloadedFunctionReference(Fn, (*Best)->FoundDecl, FDecl);
9c785c217b3f9 (Dmitri Gribenko          2013-05-09 21:02:07 +0000 13168)     return SemaRef.BuildResolvedCallExpr(Fn, FDecl, LParenLoc, Args, RParenLoc,
5cdc2cda28ac8 (Eric Fiselier            2018-12-12 21:50:55 +0000 13169)                                          ExecConfig, /*IsExecConfig=*/false,
5cdc2cda28ac8 (Eric Fiselier            2018-12-12 21:50:55 +0000 13170)                                          (*Best)->IsADLCandidate);
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 13171)   }
99dcbff1542f3 (Douglas Gregor           2008-11-26 05:54:23 +0000 13172)   }
99dcbff1542f3 (Douglas Gregor           2008-11-26 05:54:23 +0000 13173) 
8222107aa9249 (Haojian Wu               2020-05-08 16:13:17 +0200 13174)   // Overload resolution failed, try to recover.
8222107aa9249 (Haojian Wu               2020-05-08 16:13:17 +0200 13175)   SmallVector<Expr *, 8> SubExprs = {Fn};
8222107aa9249 (Haojian Wu               2020-05-08 16:13:17 +0200 13176)   SubExprs.append(Args.begin(), Args.end());
8222107aa9249 (Haojian Wu               2020-05-08 16:13:17 +0200 13177)   return SemaRef.CreateRecoveryExpr(Fn->getBeginLoc(), RParenLoc, SubExprs,
8222107aa9249 (Haojian Wu               2020-05-08 16:13:17 +0200 13178)                                     chooseRecoveryType(*CandidateSet, Best));
99dcbff1542f3 (Douglas Gregor           2008-11-26 05:54:23 +0000 13179) }
99dcbff1542f3 (Douglas Gregor           2008-11-26 05:54:23 +0000 13180) 
7204ed97dd930 (George Burgess IV        2016-01-07 02:26:57 +0000 13181) static void markUnaddressableCandidatesUnviable(Sema &S,
7204ed97dd930 (George Burgess IV        2016-01-07 02:26:57 +0000 13182)                                                 OverloadCandidateSet &CS) {
7204ed97dd930 (George Burgess IV        2016-01-07 02:26:57 +0000 13183)   for (auto I = CS.begin(), E = CS.end(); I != E; ++I) {
7204ed97dd930 (George Burgess IV        2016-01-07 02:26:57 +0000 13184)     if (I->Viable &&
7204ed97dd930 (George Burgess IV        2016-01-07 02:26:57 +0000 13185)         !S.checkAddressOfFunctionIsAvailable(I->Function, /*Complain=*/false)) {
7204ed97dd930 (George Burgess IV        2016-01-07 02:26:57 +0000 13186)       I->Viable = false;
7204ed97dd930 (George Burgess IV        2016-01-07 02:26:57 +0000 13187)       I->FailureKind = ovl_fail_addr_not_available;
7204ed97dd930 (George Burgess IV        2016-01-07 02:26:57 +0000 13188)     }
7204ed97dd930 (George Burgess IV        2016-01-07 02:26:57 +0000 13189)   }
7204ed97dd930 (George Burgess IV        2016-01-07 02:26:57 +0000 13190) }
7204ed97dd930 (George Burgess IV        2016-01-07 02:26:57 +0000 13191) 
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 13192) /// BuildOverloadedCallExpr - Given the call expression that calls Fn
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 13193) /// (which eventually refers to the declaration Func) and the call
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 13194) /// arguments Args/NumArgs, attempt to resolve the function call down
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 13195) /// to a specific function. If overload resolution succeeds, returns
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 13196) /// the call expression produced by overload resolution.
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 13197) /// Otherwise, emits diagnostics and returns ExprError.
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 13198) ExprResult Sema::BuildOverloadedCallExpr(Scope *S, Expr *Fn,
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 13199)                                          UnresolvedLookupExpr *ULE,
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 13200)                                          SourceLocation LParenLoc,
9c785c217b3f9 (Dmitri Gribenko          2013-05-09 21:02:07 +0000 13201)                                          MultiExprArg Args,
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 13202)                                          SourceLocation RParenLoc,
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 13203)                                          Expr *ExecConfig,
7204ed97dd930 (George Burgess IV        2016-01-07 02:26:57 +0000 13204)                                          bool AllowTypoCorrection,
7204ed97dd930 (George Burgess IV        2016-01-07 02:26:57 +0000 13205)                                          bool CalleesAddressIsTaken) {
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000 13206)   OverloadCandidateSet CandidateSet(Fn->getExprLoc(),
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000 13207)                                     OverloadCandidateSet::CSK_Normal);
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 13208)   ExprResult result;
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 13209) 
9c785c217b3f9 (Dmitri Gribenko          2013-05-09 21:02:07 +0000 13210)   if (buildOverloadedCallSet(S, Fn, ULE, Args, LParenLoc, &CandidateSet,
9c785c217b3f9 (Dmitri Gribenko          2013-05-09 21:02:07 +0000 13211)                              &result))
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 13212)     return result;
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 13213) 
7204ed97dd930 (George Burgess IV        2016-01-07 02:26:57 +0000 13214)   // If the user handed us something like `(&Foo)(Bar)`, we need to ensure that
7204ed97dd930 (George Burgess IV        2016-01-07 02:26:57 +0000 13215)   // functions that aren't addressible are considered unviable.
7204ed97dd930 (George Burgess IV        2016-01-07 02:26:57 +0000 13216)   if (CalleesAddressIsTaken)
7204ed97dd930 (George Burgess IV        2016-01-07 02:26:57 +0000 13217)     markUnaddressableCandidatesUnviable(*this, CandidateSet);
7204ed97dd930 (George Burgess IV        2016-01-07 02:26:57 +0000 13218) 
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 13219)   OverloadCandidateSet::iterator Best;
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 13220)   OverloadingResult OverloadResult =
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000 13221)       CandidateSet.BestViableFunction(*this, Fn->getBeginLoc(), Best);
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 13222) 
b23c5e8c3df85 (Richard Smith            2019-05-09 03:31:27 +0000 13223)   return FinishOverloadedCallExpr(*this, S, Fn, ULE, LParenLoc, Args, RParenLoc,
b23c5e8c3df85 (Richard Smith            2019-05-09 03:31:27 +0000 13224)                                   ExecConfig, &CandidateSet, &Best,
b23c5e8c3df85 (Richard Smith            2019-05-09 03:31:27 +0000 13225)                                   OverloadResult, AllowTypoCorrection);
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 13226) }
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 13227) 
4c4c1dfc2b768 (John McCall              2010-01-26 03:27:55 +0000 13228) static bool IsOverloaded(const UnresolvedSetImpl &Functions) {
283b901cf3542 (John McCall              2009-11-22 00:44:51 +0000 13229)   return Functions.size() > 1 ||
ed5a18fc0399d (Richard Smith            2020-08-06 15:57:35 -0700 13230)          (Functions.size() == 1 &&
ed5a18fc0399d (Richard Smith            2020-08-06 15:57:35 -0700 13231)           isa<FunctionTemplateDecl>((*Functions.begin())->getUnderlyingDecl()));
ed5a18fc0399d (Richard Smith            2020-08-06 15:57:35 -0700 13232) }
ed5a18fc0399d (Richard Smith            2020-08-06 15:57:35 -0700 13233) 
ed5a18fc0399d (Richard Smith            2020-08-06 15:57:35 -0700 13234) ExprResult Sema::CreateUnresolvedLookupExpr(CXXRecordDecl *NamingClass,
ed5a18fc0399d (Richard Smith            2020-08-06 15:57:35 -0700 13235)                                             NestedNameSpecifierLoc NNSLoc,
ed5a18fc0399d (Richard Smith            2020-08-06 15:57:35 -0700 13236)                                             DeclarationNameInfo DNI,
ed5a18fc0399d (Richard Smith            2020-08-06 15:57:35 -0700 13237)                                             const UnresolvedSetImpl &Fns,
ed5a18fc0399d (Richard Smith            2020-08-06 15:57:35 -0700 13238)                                             bool PerformADL) {
ed5a18fc0399d (Richard Smith            2020-08-06 15:57:35 -0700 13239)   return UnresolvedLookupExpr::Create(Context, NamingClass, NNSLoc, DNI,
ed5a18fc0399d (Richard Smith            2020-08-06 15:57:35 -0700 13240)                                       PerformADL, IsOverloaded(Fns),
ed5a18fc0399d (Richard Smith            2020-08-06 15:57:35 -0700 13241)                                       Fns.begin(), Fns.end());
283b901cf3542 (John McCall              2009-11-22 00:44:51 +0000 13242) }
283b901cf3542 (John McCall              2009-11-22 00:44:51 +0000 13243) 
9fc8faf9e6197 (Adrian Prantl            2018-05-09 01:00:01 +0000 13244) /// Create a unary operation that may resolve to an overloaded
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13245) /// operator.
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13246) ///
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13247) /// \param OpLoc The location of the operator itself (e.g., '*').
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13248) ///
a92ffb011eef7 (Craig Topper             2015-12-10 08:51:49 +0000 13249) /// \param Opc The UnaryOperatorKind that describes this operator.
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13250) ///
18348b6218e4c (James Dennett            2012-06-22 08:52:37 +0000 13251) /// \param Fns The set of non-member functions that will be
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13252) /// considered by overload resolution. The caller needs to build this
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13253) /// set based on the context using, e.g.,
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13254) /// LookupOverloadedOperatorName() and ArgumentDependentLookup(). This
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13255) /// set should not contain any member functions; those will be added
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13256) /// by CreateOverloadedUnaryOp().
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13257) ///
91738ffda3fa5 (James Dennett            2012-06-22 10:32:46 +0000 13258) /// \param Input The input argument.
dadc575b1e878 (John McCall              2010-08-24 06:29:42 +0000 13259) ExprResult
a92ffb011eef7 (Craig Topper             2015-12-10 08:51:49 +0000 13260) Sema::CreateOverloadedUnaryOp(SourceLocation OpLoc, UnaryOperatorKind Opc,
4c4c1dfc2b768 (John McCall              2010-01-26 03:27:55 +0000 13261)                               const UnresolvedSetImpl &Fns,
91fc7d89d0d5a (Richard Smith            2017-10-05 19:35:51 +0000 13262)                               Expr *Input, bool PerformADL) {
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13263)   OverloadedOperatorKind Op = UnaryOperator::getOverloadedOperator(Opc);
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13264)   assert(Op != OO_None && "Invalid opcode for overloaded unary operator");
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13265)   DeclarationName OpName = Context.DeclarationNames.getCXXOperatorName(Op);
d6d2f18905433 (Abramo Bagnara           2010-08-11 22:01:17 +0000 13266)   // TODO: provide better source location info.
d6d2f18905433 (Abramo Bagnara           2010-08-11 22:01:17 +0000 13267)   DeclarationNameInfo OpNameInfo(OpName, OpLoc);
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13268) 
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000 13269)   if (checkPlaceholderForOverload(*this, Input))
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000 13270)     return ExprError();
e26a872b02740 (John McCall              2010-12-04 08:14:53 +0000 13271) 
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000 13272)   Expr *Args[2] = { Input, nullptr };
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13273)   unsigned NumArgs = 1;
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000 13274) 
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13275)   // For post-increment and post-decrement, add the implicit '0' as
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13276)   // the second argument, so that we know this is a post-increment or
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13277)   // post-decrement.
e302792b6155b (John McCall              2010-08-25 11:45:40 +0000 13278)   if (Opc == UO_PostInc || Opc == UO_PostDec) {
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13279)     llvm::APSInt Zero(Context.getTypeSize(Context.IntTy), false);
43b205796f4ab (Argyrios Kyrtzidis       2010-08-28 09:06:06 +0000 13280)     Args[1] = IntegerLiteral::Create(Context, Zero, Context.IntTy,
43b205796f4ab (Argyrios Kyrtzidis       2010-08-28 09:06:06 +0000 13281)                                      SourceLocation());
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13282)     NumArgs = 2;
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13283)   }
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13284) 
e54c307bb4ed9 (Richard Smith            2013-05-05 15:51:06 +0000 13285)   ArrayRef<Expr *> ArgsArray(Args, NumArgs);
e54c307bb4ed9 (Richard Smith            2013-05-05 15:51:06 +0000 13286) 
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13287)   if (Input->isTypeDependent()) {
630dec57a2af3 (Douglas Gregor           2010-06-17 15:46:20 +0000 13288)     if (Fns.empty())
f5360d4bb3376 (Melanie Blower           2020-05-01 10:32:06 -0700 13289)       return UnaryOperator::Create(Context, Input, Opc, Context.DependentTy,
f5360d4bb3376 (Melanie Blower           2020-05-01 10:32:06 -0700 13290)                                    VK_RValue, OK_Ordinary, OpLoc, false,
f4aaed3bf16b3 (Melanie Blower           2020-06-26 09:23:45 -0700 13291)                                    CurFPFeatureOverrides());
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 13292) 
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000 13293)     CXXRecordDecl *NamingClass = nullptr; // lookup ignores member operators
ed5a18fc0399d (Richard Smith            2020-08-06 15:57:35 -0700 13294)     ExprResult Fn = CreateUnresolvedLookupExpr(
ed5a18fc0399d (Richard Smith            2020-08-06 15:57:35 -0700 13295)         NamingClass, NestedNameSpecifierLoc(), OpNameInfo, Fns);
ed5a18fc0399d (Richard Smith            2020-08-06 15:57:35 -0700 13296)     if (Fn.isInvalid())
ed5a18fc0399d (Richard Smith            2020-08-06 15:57:35 -0700 13297)       return ExprError();
ed5a18fc0399d (Richard Smith            2020-08-06 15:57:35 -0700 13298)     return CXXOperatorCallExpr::Create(Context, Op, Fn.get(), ArgsArray,
c5885cffc5206 (Bruno Ricci              2018-12-21 15:20:32 +0000 13299)                                        Context.DependentTy, VK_RValue, OpLoc,
f4aaed3bf16b3 (Melanie Blower           2020-06-26 09:23:45 -0700 13300)                                        CurFPFeatureOverrides());
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13301)   }
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13302) 
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13303)   // Build an empty overload set.
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000 13304)   OverloadCandidateSet CandidateSet(OpLoc, OverloadCandidateSet::CSK_Operator);
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13305) 
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13306)   // Add the candidates from the given function set.
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13307)   AddNonMemberOperatorCandidates(Fns, ArgsArray, CandidateSet);
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13308) 
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13309)   // Add operator candidates that are member functions.
e54c307bb4ed9 (Richard Smith            2013-05-05 15:51:06 +0000 13310)   AddMemberOperatorCandidates(Op, OpLoc, ArgsArray, CandidateSet);
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13311) 
4c4c1dfc2b768 (John McCall              2010-01-26 03:27:55 +0000 13312)   // Add candidates from ADL.
91fc7d89d0d5a (Richard Smith            2017-10-05 19:35:51 +0000 13313)   if (PerformADL) {
91fc7d89d0d5a (Richard Smith            2017-10-05 19:35:51 +0000 13314)     AddArgumentDependentLookupCandidates(OpName, OpLoc, ArgsArray,
91fc7d89d0d5a (Richard Smith            2017-10-05 19:35:51 +0000 13315)                                          /*ExplicitTemplateArgs*/nullptr,
91fc7d89d0d5a (Richard Smith            2017-10-05 19:35:51 +0000 13316)                                          CandidateSet);
91fc7d89d0d5a (Richard Smith            2017-10-05 19:35:51 +0000 13317)   }
4c4c1dfc2b768 (John McCall              2010-01-26 03:27:55 +0000 13318) 
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13319)   // Add builtin operator candidates.
e54c307bb4ed9 (Richard Smith            2013-05-05 15:51:06 +0000 13320)   AddBuiltinOperatorCandidates(Op, OpLoc, ArgsArray, CandidateSet);
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13321) 
635ed24e1dad8 (Abramo Bagnara           2011-10-05 07:56:41 +0000 13322)   bool HadMultipleCandidates = (CandidateSet.size() > 1);
635ed24e1dad8 (Abramo Bagnara           2011-10-05 07:56:41 +0000 13323) 
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13324)   // Perform overload resolution.
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13325)   OverloadCandidateSet::iterator Best;
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000 13326)   switch (CandidateSet.BestViableFunction(*this, OpLoc, Best)) {
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13327)   case OR_Success: {
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13328)     // We found a built-in operator or an overloaded operator.
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13329)     FunctionDecl *FnDecl = Best->Function;
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000 13330) 
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13331)     if (FnDecl) {
2246167362bf3 (Akira Hatanaka           2017-07-13 06:08:27 +0000 13332)       Expr *Base = nullptr;
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13333)       // We matched an overloaded operator. Build a call to that
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13334)       // operator.
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000 13335) 
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13336)       // Convert the arguments.
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13337)       if (CXXMethodDecl *Method = dyn_cast<CXXMethodDecl>(FnDecl)) {
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000 13338)         CheckMemberOperatorAccess(OpLoc, Args[0], nullptr, Best->FoundDecl);
b3a4400554925 (John McCall              2010-01-28 01:42:12 +0000 13339) 
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 13340)         ExprResult InputRes =
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000 13341)           PerformObjectArgumentInitialization(Input, /*Qualifier=*/nullptr,
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 13342)                                               Best->FoundDecl, Method);
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 13343)         if (InputRes.isInvalid())
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13344)           return ExprError();
2246167362bf3 (Akira Hatanaka           2017-07-13 06:08:27 +0000 13345)         Base = Input = InputRes.get();
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13346)       } else {
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13347)         // Convert the arguments.
dadc575b1e878 (John McCall              2010-08-24 06:29:42 +0000 13348)         ExprResult InputInit
e6600379b1c6f (Douglas Gregor           2009-12-23 17:40:29 +0000 13349)           = PerformCopyInitialization(InitializedEntity::InitializeParameter(
8fb87aec78b52 (Fariborz Jahanian        2010-09-24 17:30:16 +0000 13350)                                                       Context,
8d48e9a26e5e2 (Douglas Gregor           2009-12-23 00:02:00 +0000 13351)                                                       FnDecl->getParamDecl(0)),
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 13352)                                       SourceLocation(),
b268a282a4f19 (John McCall              2010-08-23 23:25:46 +0000 13353)                                       Input);
e6600379b1c6f (Douglas Gregor           2009-12-23 17:40:29 +0000 13354)         if (InputInit.isInvalid())
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13355)           return ExprError();
01a7598561561 (Nikola Smiljanic         2014-05-29 10:55:11 +0000 13356)         Input = InputInit.get();
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13357)       }
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13358) 
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13359)       // Build the actual expression node.
134af91b06493 (Nick Lewycky             2013-02-07 05:08:22 +0000 13360)       ExprResult FnExpr = CreateFunctionRefExpr(*this, FnDecl, Best->FoundDecl,
2246167362bf3 (Akira Hatanaka           2017-07-13 06:08:27 +0000 13361)                                                 Base, HadMultipleCandidates,
2246167362bf3 (Akira Hatanaka           2017-07-13 06:08:27 +0000 13362)                                                 OpLoc);
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 13363)       if (FnExpr.isInvalid())
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 13364)         return ExprError();
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000 13365) 
c156470be5123 (Richard Smith            2013-11-15 02:58:23 +0000 13366)       // Determine the result type.
314cc81b8caac (Alp Toker                2014-01-25 16:55:45 +0000 13367)       QualType ResultTy = FnDecl->getReturnType();
c156470be5123 (Richard Smith            2013-11-15 02:58:23 +0000 13368)       ExprValueKind VK = Expr::getValueKindForType(ResultTy);
c156470be5123 (Richard Smith            2013-11-15 02:58:23 +0000 13369)       ResultTy = ResultTy.getNonLValueExprType(Context);
c156470be5123 (Richard Smith            2013-11-15 02:58:23 +0000 13370) 
030eee4e5c369 (Eli Friedman             2009-11-18 03:58:17 +0000 13371)       Args[0] = Input;
c5885cffc5206 (Bruno Ricci              2018-12-21 15:20:32 +0000 13372)       CallExpr *TheCall = CXXOperatorCallExpr::Create(
8812b0cc5cc09 (Melanie Blower           2020-04-16 08:45:26 -0700 13373)           Context, Op, FnExpr.get(), ArgsArray, ResultTy, VK, OpLoc,
f4aaed3bf16b3 (Melanie Blower           2020-06-26 09:23:45 -0700 13374)           CurFPFeatureOverrides(), Best->IsADLCandidate);
4fa0d5f2bd849 (John McCall              2010-05-06 18:15:07 +0000 13375) 
314cc81b8caac (Alp Toker                2014-01-25 16:55:45 +0000 13376)       if (CheckCallReturnType(FnDecl->getReturnType(), OpLoc, TheCall, FnDecl))
f64a3dae047f5 (Anders Carlsson          2009-10-13 21:19:37 +0000 13377)         return ExprError();
f64a3dae047f5 (Anders Carlsson          2009-10-13 21:19:37 +0000 13378) 
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000 13379)       if (CheckFunctionCall(FnDecl, TheCall,
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000 13380)                             FnDecl->getType()->castAs<FunctionProtoType>()))
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000 13381)         return ExprError();
008e7bf92343b (Tyker                    2020-02-04 19:23:33 +0100 13382)       return CheckForImmediateInvocation(MaybeBindToTemporary(TheCall), FnDecl);
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13383)     } else {
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13384)       // We matched a built-in operator. Convert the arguments, then
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13385)       // break out so that we will build the appropriate built-in
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13386)       // operator node.
5f6ab9a8bf307 (George Burgess IV        2017-06-08 20:55:21 +0000 13387)       ExprResult InputRes = PerformImplicitConversion(
1ef7554efd1ad (Richard Smith            2018-06-27 20:30:34 +0000 13388)           Input, Best->BuiltinParamTypes[0], Best->Conversions[0], AA_Passing,
1ef7554efd1ad (Richard Smith            2018-06-27 20:30:34 +0000 13389)           CCK_ForBuiltinOverloadedOp);
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 13390)       if (InputRes.isInvalid())
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 13391)         return ExprError();
01a7598561561 (Nikola Smiljanic         2014-05-29 10:55:11 +0000 13392)       Input = InputRes.get();
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13393)       break;
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 13394)     }
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 13395)   }
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13396) 
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 13397)   case OR_No_Viable_Function:
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 13398)     // This is an erroneous use of an operator which can be overloaded by
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 13399)     // a non-member function. Check for non-member operators which were
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 13400)     // defined too late to be candidates.
e54c307bb4ed9 (Richard Smith            2013-05-05 15:51:06 +0000 13401)     if (DiagnoseTwoPhaseOperatorLookup(*this, Op, OpLoc, ArgsArray))
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 13402)       // FIXME: Recover by calling the found function.
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 13403)       return ExprError();
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 13404) 
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 13405)     // No viable function; fall through to handling this as a
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 13406)     // built-in operator, which will produce an error message for us.
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 13407)     break;
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13408) 
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 13409)   case OR_Ambiguous:
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 13410)     CandidateSet.NoteCandidates(
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 13411)         PartialDiagnosticAt(OpLoc,
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 13412)                             PDiag(diag::err_ovl_ambiguous_oper_unary)
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 13413)                                 << UnaryOperator::getOpcodeStr(Opc)
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 13414)                                 << Input->getType() << Input->getSourceRange()),
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 13415)         *this, OCD_AmbiguousCandidates, ArgsArray,
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 13416)         UnaryOperator::getOpcodeStr(Opc), OpLoc);
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 13417)     return ExprError();
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 13418) 
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 13419)   case OR_Deleted:
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 13420)     CandidateSet.NoteCandidates(
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 13421)         PartialDiagnosticAt(OpLoc, PDiag(diag::err_ovl_deleted_oper)
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 13422)                                        << UnaryOperator::getOpcodeStr(Opc)
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 13423)                                        << Input->getSourceRange()),
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 13424)         *this, OCD_AllCandidates, ArgsArray, UnaryOperator::getOpcodeStr(Opc),
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 13425)         OpLoc);
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 13426)     return ExprError();
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 13427)   }
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13428) 
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13429)   // Either we found no viable overloaded operator or we matched a
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13430)   // built-in operator. In either case, fall through to trying to
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13431)   // build a built-in operation.
b268a282a4f19 (John McCall              2010-08-23 23:25:46 +0000 13432)   return CreateBuiltinUnaryOp(OpLoc, Opc, Input);
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13433) }
084d855a17f27 (Douglas Gregor           2009-03-13 23:49:33 +0000 13434) 
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13435) /// Perform lookup for an overloaded binary operator.
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13436) void Sema::LookupOverloadedBinOp(OverloadCandidateSet &CandidateSet,
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13437)                                  OverloadedOperatorKind Op,
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13438)                                  const UnresolvedSetImpl &Fns,
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13439)                                  ArrayRef<Expr *> Args, bool PerformADL) {
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13440)   SourceLocation OpLoc = CandidateSet.getLocation();
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13441) 
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13442)   OverloadedOperatorKind ExtraOp =
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13443)       CandidateSet.getRewriteInfo().AllowRewrittenCandidates
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13444)           ? getRewrittenOverloadedOperator(Op)
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13445)           : OO_None;
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13446) 
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13447)   // Add the candidates from the given function set. This also adds the
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13448)   // rewritten candidates using these functions if necessary.
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13449)   AddNonMemberOperatorCandidates(Fns, Args, CandidateSet);
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13450) 
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13451)   // Add operator candidates that are member functions.
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13452)   AddMemberOperatorCandidates(Op, OpLoc, Args, CandidateSet);
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13453)   if (CandidateSet.getRewriteInfo().shouldAddReversed(Op))
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13454)     AddMemberOperatorCandidates(Op, OpLoc, {Args[1], Args[0]}, CandidateSet,
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13455)                                 OverloadCandidateParamOrder::Reversed);
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13456) 
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13457)   // In C++20, also add any rewritten member candidates.
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13458)   if (ExtraOp) {
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13459)     AddMemberOperatorCandidates(ExtraOp, OpLoc, Args, CandidateSet);
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13460)     if (CandidateSet.getRewriteInfo().shouldAddReversed(ExtraOp))
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13461)       AddMemberOperatorCandidates(ExtraOp, OpLoc, {Args[1], Args[0]},
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13462)                                   CandidateSet,
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13463)                                   OverloadCandidateParamOrder::Reversed);
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13464)   }
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13465) 
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13466)   // Add candidates from ADL. Per [over.match.oper]p2, this lookup is not
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13467)   // performed for an assignment operator (nor for operator[] nor operator->,
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13468)   // which don't get here).
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13469)   if (Op != OO_Equal && PerformADL) {
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13470)     DeclarationName OpName = Context.DeclarationNames.getCXXOperatorName(Op);
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13471)     AddArgumentDependentLookupCandidates(OpName, OpLoc, Args,
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13472)                                          /*ExplicitTemplateArgs*/ nullptr,
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13473)                                          CandidateSet);
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13474)     if (ExtraOp) {
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13475)       DeclarationName ExtraOpName =
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13476)           Context.DeclarationNames.getCXXOperatorName(ExtraOp);
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13477)       AddArgumentDependentLookupCandidates(ExtraOpName, OpLoc, Args,
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13478)                                            /*ExplicitTemplateArgs*/ nullptr,
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13479)                                            CandidateSet);
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13480)     }
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13481)   }
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13482) 
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13483)   // Add builtin operator candidates.
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13484)   //
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13485)   // FIXME: We don't add any rewritten candidates here. This is strictly
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13486)   // incorrect; a builtin candidate could be hidden by a non-viable candidate,
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13487)   // resulting in our selecting a rewritten builtin candidate. For example:
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13488)   //
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13489)   //   enum class E { e };
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13490)   //   bool operator!=(E, E) requires false;
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13491)   //   bool k = E::e != E::e;
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13492)   //
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13493)   // ... should select the rewritten builtin candidate 'operator==(E, E)'. But
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13494)   // it seems unreasonable to consider rewritten builtin candidates. A core
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13495)   // issue has been filed proposing to removed this requirement.
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13496)   AddBuiltinOperatorCandidates(Op, OpLoc, Args, CandidateSet);
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13497) }
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13498) 
9fc8faf9e6197 (Adrian Prantl            2018-05-09 01:00:01 +0000 13499) /// Create a binary operation that may resolve to an overloaded
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13500) /// operator.
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13501) ///
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13502) /// \param OpLoc The location of the operator itself (e.g., '+').
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13503) ///
a92ffb011eef7 (Craig Topper             2015-12-10 08:51:49 +0000 13504) /// \param Opc The BinaryOperatorKind that describes this operator.
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13505) ///
18348b6218e4c (James Dennett            2012-06-22 08:52:37 +0000 13506) /// \param Fns The set of non-member functions that will be
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13507) /// considered by overload resolution. The caller needs to build this
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13508) /// set based on the context using, e.g.,
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13509) /// LookupOverloadedOperatorName() and ArgumentDependentLookup(). This
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13510) /// set should not contain any member functions; those will be added
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13511) /// by CreateOverloadedBinOp().
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13512) ///
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13513) /// \param LHS Left-hand argument.
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13514) /// \param RHS Right-hand argument.
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13515) /// \param PerformADL Whether to consider operator candidates found by ADL.
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13516) /// \param AllowRewrittenCandidates Whether to consider candidates found by
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13517) ///        C++20 operator rewrites.
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13518) /// \param DefaultedFn If we are synthesizing a defaulted operator function,
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13519) ///        the function in question. Such a function is never a candidate in
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13520) ///        our overload resolution. This also enables synthesizing a three-way
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13521) ///        comparison from < and == as described in C++20 [class.spaceship]p1.
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13522) ExprResult Sema::CreateOverloadedBinOp(SourceLocation OpLoc,
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13523)                                        BinaryOperatorKind Opc,
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13524)                                        const UnresolvedSetImpl &Fns, Expr *LHS,
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13525)                                        Expr *RHS, bool PerformADL,
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13526)                                        bool AllowRewrittenCandidates,
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13527)                                        FunctionDecl *DefaultedFn) {
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13528)   Expr *Args[2] = { LHS, RHS };
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000 13529)   LHS=RHS=nullptr; // Please use only Args instead of LHS/RHS couple
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13530) 
6a30894391ca6 (Aaron Ballman            2020-04-21 15:37:19 -0400 13531)   if (!getLangOpts().CPlusPlus20)
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13532)     AllowRewrittenCandidates = false;
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13533) 
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13534)   OverloadedOperatorKind Op = BinaryOperator::getOverloadedOperator(Opc);
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13535) 
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13536)   // If either side is type-dependent, create an appropriate dependent
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13537)   // expression.
e9899d9769661 (Douglas Gregor           2009-08-26 17:08:25 +0000 13538)   if (Args[0]->isTypeDependent() || Args[1]->isTypeDependent()) {
4c4c1dfc2b768 (John McCall              2010-01-26 03:27:55 +0000 13539)     if (Fns.empty()) {
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 13540)       // If there are no functions to store, just build a dependent
5287f091b269e (Douglas Gregor           2009-11-05 00:51:44 +0000 13541)       // BinaryOperator or CompoundAssignment.
31dc90801746e (Haojian Wu               2020-10-07 09:50:43 +0200 13542)       if (BinaryOperator::isCompoundAssignmentOp(Opc))
31dc90801746e (Haojian Wu               2020-10-07 09:50:43 +0200 13543)         return CompoundAssignOperator::Create(
31dc90801746e (Haojian Wu               2020-10-07 09:50:43 +0200 13544)             Context, Args[0], Args[1], Opc, Context.DependentTy, VK_LValue,
31dc90801746e (Haojian Wu               2020-10-07 09:50:43 +0200 13545)             OK_Ordinary, OpLoc, CurFPFeatureOverrides(), Context.DependentTy,
31dc90801746e (Haojian Wu               2020-10-07 09:50:43 +0200 13546)             Context.DependentTy);
31dc90801746e (Haojian Wu               2020-10-07 09:50:43 +0200 13547)       return BinaryOperator::Create(Context, Args[0], Args[1], Opc,
31dc90801746e (Haojian Wu               2020-10-07 09:50:43 +0200 13548)                                     Context.DependentTy, VK_RValue, OK_Ordinary,
31dc90801746e (Haojian Wu               2020-10-07 09:50:43 +0200 13549)                                     OpLoc, CurFPFeatureOverrides());
5287f091b269e (Douglas Gregor           2009-11-05 00:51:44 +0000 13550)     }
4c4c1dfc2b768 (John McCall              2010-01-26 03:27:55 +0000 13551) 
4c4c1dfc2b768 (John McCall              2010-01-26 03:27:55 +0000 13552)     // FIXME: save results of ADL from here?
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000 13553)     CXXRecordDecl *NamingClass = nullptr; // lookup ignores member operators
d6d2f18905433 (Abramo Bagnara           2010-08-11 22:01:17 +0000 13554)     // TODO: provide better source location info in DNLoc component.
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13555)     DeclarationName OpName = Context.DeclarationNames.getCXXOperatorName(Op);
d6d2f18905433 (Abramo Bagnara           2010-08-11 22:01:17 +0000 13556)     DeclarationNameInfo OpNameInfo(OpName, OpLoc);
ed5a18fc0399d (Richard Smith            2020-08-06 15:57:35 -0700 13557)     ExprResult Fn = CreateUnresolvedLookupExpr(
ed5a18fc0399d (Richard Smith            2020-08-06 15:57:35 -0700 13558)         NamingClass, NestedNameSpecifierLoc(), OpNameInfo, Fns, PerformADL);
ed5a18fc0399d (Richard Smith            2020-08-06 15:57:35 -0700 13559)     if (Fn.isInvalid())
ed5a18fc0399d (Richard Smith            2020-08-06 15:57:35 -0700 13560)       return ExprError();
ed5a18fc0399d (Richard Smith            2020-08-06 15:57:35 -0700 13561)     return CXXOperatorCallExpr::Create(Context, Op, Fn.get(), Args,
c5885cffc5206 (Bruno Ricci              2018-12-21 15:20:32 +0000 13562)                                        Context.DependentTy, VK_RValue, OpLoc,
f4aaed3bf16b3 (Melanie Blower           2020-06-26 09:23:45 -0700 13563)                                        CurFPFeatureOverrides());
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13564)   }
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13565) 
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000 13566)   // Always do placeholder-like conversions on the RHS.
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000 13567)   if (checkPlaceholderForOverload(*this, Args[1]))
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000 13568)     return ExprError();
e26a872b02740 (John McCall              2010-12-04 08:14:53 +0000 13569) 
526ab47a55734 (John McCall              2011-10-25 17:37:35 +0000 13570)   // Do placeholder-like conversion on the LHS; note that we should
526ab47a55734 (John McCall              2011-10-25 17:37:35 +0000 13571)   // not get here with a PseudoObject LHS.
526ab47a55734 (John McCall              2011-10-25 17:37:35 +0000 13572)   assert(Args[0]->getObjectKind() != OK_ObjCProperty);
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000 13573)   if (checkPlaceholderForOverload(*this, Args[0]))
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000 13574)     return ExprError();
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000 13575) 
6a96bf7d6e33d (Sebastian Redl           2009-11-18 23:10:33 +0000 13576)   // If this is the assignment operator, we only perform overload resolution
6a96bf7d6e33d (Sebastian Redl           2009-11-18 23:10:33 +0000 13577)   // if the left-hand side is a class or enumeration type. This is actually
6a96bf7d6e33d (Sebastian Redl           2009-11-18 23:10:33 +0000 13578)   // a hack. The standard requires that we do overload resolution between the
6a96bf7d6e33d (Sebastian Redl           2009-11-18 23:10:33 +0000 13579)   // various built-in candidates, but as DR507 points out, this can lead to
6a96bf7d6e33d (Sebastian Redl           2009-11-18 23:10:33 +0000 13580)   // problems. So we do it this way, which pretty much follows what GCC does.
6a96bf7d6e33d (Sebastian Redl           2009-11-18 23:10:33 +0000 13581)   // Note that we go the traditional code path for compound assignment forms.
e302792b6155b (John McCall              2010-08-25 11:45:40 +0000 13582)   if (Opc == BO_Assign && !Args[0]->getType()->isOverloadableType())
e9899d9769661 (Douglas Gregor           2009-08-26 17:08:25 +0000 13583)     return CreateBuiltinBinOp(OpLoc, Opc, Args[0], Args[1]);
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13584) 
e26a872b02740 (John McCall              2010-12-04 08:14:53 +0000 13585)   // If this is the .* operator, which is not overloadable, just
e26a872b02740 (John McCall              2010-12-04 08:14:53 +0000 13586)   // create a built-in binary operator.
e26a872b02740 (John McCall              2010-12-04 08:14:53 +0000 13587)   if (Opc == BO_PtrMemD)
e26a872b02740 (John McCall              2010-12-04 08:14:53 +0000 13588)     return CreateBuiltinBinOp(OpLoc, Opc, Args[0], Args[1]);
e26a872b02740 (John McCall              2010-12-04 08:14:53 +0000 13589) 
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13590)   // Build the overload set.
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13591)   OverloadCandidateSet CandidateSet(
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13592)       OpLoc, OverloadCandidateSet::CSK_Operator,
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13593)       OverloadCandidateSet::OperatorRewriteInfo(Op, AllowRewrittenCandidates));
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13594)   if (DefaultedFn)
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13595)     CandidateSet.exclude(DefaultedFn);
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13596)   LookupOverloadedBinOp(CandidateSet, Op, Fns, Args, PerformADL);
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13597) 
635ed24e1dad8 (Abramo Bagnara           2011-10-05 07:56:41 +0000 13598)   bool HadMultipleCandidates = (CandidateSet.size() > 1);
635ed24e1dad8 (Abramo Bagnara           2011-10-05 07:56:41 +0000 13599) 
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13600)   // Perform overload resolution.
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13601)   OverloadCandidateSet::iterator Best;
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000 13602)   switch (CandidateSet.BestViableFunction(*this, OpLoc, Best)) {
1a99f441e64c8 (Sebastian Redl           2009-04-16 17:51:27 +0000 13603)     case OR_Success: {
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13604)       // We found a built-in operator or an overloaded operator.
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13605)       FunctionDecl *FnDecl = Best->Function;
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13606) 
fcea7fbdba1bd (Richard Smith            2020-02-10 06:05:59 -0800 13607)       bool IsReversed = Best->isReversed();
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13608)       if (IsReversed)
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13609)         std::swap(Args[0], Args[1]);
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13610) 
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13611)       if (FnDecl) {
2246167362bf3 (Akira Hatanaka           2017-07-13 06:08:27 +0000 13612)         Expr *Base = nullptr;
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13613)         // We matched an overloaded operator. Build a call to that
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13614)         // operator.
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13615) 
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13616)         OverloadedOperatorKind ChosenOp =
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13617)             FnDecl->getDeclName().getCXXOverloadedOperator();
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13618) 
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13619)         // C++2a [over.match.oper]p9:
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13620)         //   If a rewritten operator== candidate is selected by overload
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13621)         //   resolution for an operator@, its return type shall be cv bool
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13622)         if (Best->RewriteKind && ChosenOp == OO_EqualEqual &&
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13623)             !FnDecl->getReturnType()->isBooleanType()) {
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700 13624)           bool IsExtension =
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700 13625)               FnDecl->getReturnType()->isIntegralOrUnscopedEnumerationType();
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700 13626)           Diag(OpLoc, IsExtension ? diag::ext_ovl_rewrite_equalequal_not_bool
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700 13627)                                   : diag::err_ovl_rewrite_equalequal_not_bool)
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13628)               << FnDecl->getReturnType() << BinaryOperator::getOpcodeStr(Opc)
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13629)               << Args[0]->getSourceRange() << Args[1]->getSourceRange();
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13630)           Diag(FnDecl->getLocation(), diag::note_declared_at);
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700 13631)           if (!IsExtension)
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700 13632)             return ExprError();
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13633)         }
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13634) 
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13635)         if (AllowRewrittenCandidates && !IsReversed &&
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700 13636)             CandidateSet.getRewriteInfo().isReversible()) {
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700 13637)           // We could have reversed this operator, but didn't. Check if some
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13638)           // reversed form was a viable candidate, and if so, if it had a
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13639)           // better conversion for either parameter. If so, this call is
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13640)           // formally ambiguous, and allowing it is an extension.
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700 13641)           llvm::SmallVector<FunctionDecl*, 4> AmbiguousWith;
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13642)           for (OverloadCandidate &Cand : CandidateSet) {
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700 13643)             if (Cand.Viable && Cand.Function && Cand.isReversed() &&
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700 13644)                 haveSameParameterTypes(Context, Cand.Function, FnDecl, 2)) {
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13645)               for (unsigned ArgIdx = 0; ArgIdx < 2; ++ArgIdx) {
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13646)                 if (CompareImplicitConversionSequences(
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13647)                         *this, OpLoc, Cand.Conversions[ArgIdx],
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13648)                         Best->Conversions[ArgIdx]) ==
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13649)                     ImplicitConversionSequence::Better) {
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700 13650)                   AmbiguousWith.push_back(Cand.Function);
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700 13651)                   break;
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13652)                 }
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13653)               }
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700 13654)             }
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700 13655)           }
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700 13656) 
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700 13657)           if (!AmbiguousWith.empty()) {
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700 13658)             bool AmbiguousWithSelf =
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700 13659)                 AmbiguousWith.size() == 1 &&
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700 13660)                 declaresSameEntity(AmbiguousWith.front(), FnDecl);
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700 13661)             Diag(OpLoc, diag::ext_ovl_ambiguous_oper_binary_reversed)
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700 13662)                 << BinaryOperator::getOpcodeStr(Opc)
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700 13663)                 << Args[0]->getType() << Args[1]->getType() << AmbiguousWithSelf
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700 13664)                 << Args[0]->getSourceRange() << Args[1]->getSourceRange();
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700 13665)             if (AmbiguousWithSelf) {
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700 13666)               Diag(FnDecl->getLocation(),
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700 13667)                    diag::note_ovl_ambiguous_oper_binary_reversed_self);
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700 13668)             } else {
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700 13669)               Diag(FnDecl->getLocation(),
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700 13670)                    diag::note_ovl_ambiguous_oper_binary_selected_candidate);
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700 13671)               for (auto *F : AmbiguousWith)
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700 13672)                 Diag(F->getLocation(),
dc4259d5a3840 (Richard Smith            2020-03-20 13:19:26 -0700 13673)                      diag::note_ovl_ambiguous_oper_binary_reversed_candidate);
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13674)             }
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13675)           }
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13676)         }
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13677) 
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13678)         // Convert the arguments.
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13679)         if (CXXMethodDecl *Method = dyn_cast<CXXMethodDecl>(FnDecl)) {
b3a4400554925 (John McCall              2010-01-28 01:42:12 +0000 13680)           // Best->Access is only meaningful for class members.
a0296f7987c0a (John McCall              2010-03-19 07:35:19 +0000 13681)           CheckMemberOperatorAccess(OpLoc, Args[0], Args[1], Best->FoundDecl);
b3a4400554925 (John McCall              2010-01-28 01:42:12 +0000 13682) 
8e543b3d46932 (Chandler Carruth         2010-12-12 08:17:55 +0000 13683)           ExprResult Arg1 =
8e543b3d46932 (Chandler Carruth         2010-12-12 08:17:55 +0000 13684)             PerformCopyInitialization(
8e543b3d46932 (Chandler Carruth         2010-12-12 08:17:55 +0000 13685)               InitializedEntity::InitializeParameter(Context,
8e543b3d46932 (Chandler Carruth         2010-12-12 08:17:55 +0000 13686)                                                      FnDecl->getParamDecl(0)),
03ff2596cb161 (Nikola Smiljanic         2014-05-29 14:05:12 +0000 13687)               SourceLocation(), Args[1]);
0a70c4d9a2e5f (Douglas Gregor           2009-12-22 21:44:34 +0000 13688)           if (Arg1.isInvalid())
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13689)             return ExprError();
0a70c4d9a2e5f (Douglas Gregor           2009-12-22 21:44:34 +0000 13690) 
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 13691)           ExprResult Arg0 =
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000 13692)             PerformObjectArgumentInitialization(Args[0], /*Qualifier=*/nullptr,
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 13693)                                                 Best->FoundDecl, Method);
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 13694)           if (Arg0.isInvalid())
0a70c4d9a2e5f (Douglas Gregor           2009-12-22 21:44:34 +0000 13695)             return ExprError();
2246167362bf3 (Akira Hatanaka           2017-07-13 06:08:27 +0000 13696)           Base = Args[0] = Arg0.getAs<Expr>();
01a7598561561 (Nikola Smiljanic         2014-05-29 10:55:11 +0000 13697)           Args[1] = RHS = Arg1.getAs<Expr>();
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13698)         } else {
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13699)           // Convert the arguments.
8e543b3d46932 (Chandler Carruth         2010-12-12 08:17:55 +0000 13700)           ExprResult Arg0 = PerformCopyInitialization(
8e543b3d46932 (Chandler Carruth         2010-12-12 08:17:55 +0000 13701)             InitializedEntity::InitializeParameter(Context,
8e543b3d46932 (Chandler Carruth         2010-12-12 08:17:55 +0000 13702)                                                    FnDecl->getParamDecl(0)),
03ff2596cb161 (Nikola Smiljanic         2014-05-29 14:05:12 +0000 13703)             SourceLocation(), Args[0]);
0a70c4d9a2e5f (Douglas Gregor           2009-12-22 21:44:34 +0000 13704)           if (Arg0.isInvalid())
0a70c4d9a2e5f (Douglas Gregor           2009-12-22 21:44:34 +0000 13705)             return ExprError();
0a70c4d9a2e5f (Douglas Gregor           2009-12-22 21:44:34 +0000 13706) 
8e543b3d46932 (Chandler Carruth         2010-12-12 08:17:55 +0000 13707)           ExprResult Arg1 =
8e543b3d46932 (Chandler Carruth         2010-12-12 08:17:55 +0000 13708)             PerformCopyInitialization(
8e543b3d46932 (Chandler Carruth         2010-12-12 08:17:55 +0000 13709)               InitializedEntity::InitializeParameter(Context,
8e543b3d46932 (Chandler Carruth         2010-12-12 08:17:55 +0000 13710)                                                      FnDecl->getParamDecl(1)),
03ff2596cb161 (Nikola Smiljanic         2014-05-29 14:05:12 +0000 13711)               SourceLocation(), Args[1]);
0a70c4d9a2e5f (Douglas Gregor           2009-12-22 21:44:34 +0000 13712)           if (Arg1.isInvalid())
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13713)             return ExprError();
01a7598561561 (Nikola Smiljanic         2014-05-29 10:55:11 +0000 13714)           Args[0] = LHS = Arg0.getAs<Expr>();
01a7598561561 (Nikola Smiljanic         2014-05-29 10:55:11 +0000 13715)           Args[1] = RHS = Arg1.getAs<Expr>();
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13716)         }
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13717) 
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13718)         // Build the actual expression node.
635ed24e1dad8 (Abramo Bagnara           2011-10-05 07:56:41 +0000 13719)         ExprResult FnExpr = CreateFunctionRefExpr(*this, FnDecl,
2246167362bf3 (Akira Hatanaka           2017-07-13 06:08:27 +0000 13720)                                                   Best->FoundDecl, Base,
635ed24e1dad8 (Abramo Bagnara           2011-10-05 07:56:41 +0000 13721)                                                   HadMultipleCandidates, OpLoc);
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 13722)         if (FnExpr.isInvalid())
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 13723)           return ExprError();
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13724) 
c156470be5123 (Richard Smith            2013-11-15 02:58:23 +0000 13725)         // Determine the result type.
314cc81b8caac (Alp Toker                2014-01-25 16:55:45 +0000 13726)         QualType ResultTy = FnDecl->getReturnType();
c156470be5123 (Richard Smith            2013-11-15 02:58:23 +0000 13727)         ExprValueKind VK = Expr::getValueKindForType(ResultTy);
c156470be5123 (Richard Smith            2013-11-15 02:58:23 +0000 13728)         ResultTy = ResultTy.getNonLValueExprType(Context);
c156470be5123 (Richard Smith            2013-11-15 02:58:23 +0000 13729) 
c5885cffc5206 (Bruno Ricci              2018-12-21 15:20:32 +0000 13730)         CXXOperatorCallExpr *TheCall = CXXOperatorCallExpr::Create(
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13731)             Context, ChosenOp, FnExpr.get(), Args, ResultTy, VK, OpLoc,
f4aaed3bf16b3 (Melanie Blower           2020-06-26 09:23:45 -0700 13732)             CurFPFeatureOverrides(), Best->IsADLCandidate);
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 13733) 
314cc81b8caac (Alp Toker                2014-01-25 16:55:45 +0000 13734)         if (CheckCallReturnType(FnDecl->getReturnType(), OpLoc, TheCall,
e4f4b5e919adc (Anders Carlsson          2009-10-13 22:43:21 +0000 13735)                                 FnDecl))
e4f4b5e919adc (Anders Carlsson          2009-10-13 22:43:21 +0000 13736)           return ExprError();
e4f4b5e919adc (Anders Carlsson          2009-10-13 22:43:21 +0000 13737) 
d24d5f2b79790 (Nick Lewycky             2013-01-24 02:03:08 +0000 13738)         ArrayRef<const Expr *> ArgsArray(Args, 2);
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000 13739)         const Expr *ImplicitThis = nullptr;
d24d5f2b79790 (Nick Lewycky             2013-01-24 02:03:08 +0000 13740)         // Cut off the implicit 'this'.
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000 13741)         if (isa<CXXMethodDecl>(FnDecl)) {
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000 13742)           ImplicitThis = ArgsArray[0];
d24d5f2b79790 (Nick Lewycky             2013-01-24 02:03:08 +0000 13743)           ArgsArray = ArgsArray.slice(1);
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000 13744)         }
36d0b2b49f7c8 (Richard Trieu            2015-01-13 02:32:02 +0000 13745) 
36d0b2b49f7c8 (Richard Trieu            2015-01-13 02:32:02 +0000 13746)         // Check for a self move.
36d0b2b49f7c8 (Richard Trieu            2015-01-13 02:32:02 +0000 13747)         if (Op == OO_Equal)
36d0b2b49f7c8 (Richard Trieu            2015-01-13 02:32:02 +0000 13748)           DiagnoseSelfMove(Args[0], Args[1], OpLoc);
36d0b2b49f7c8 (Richard Trieu            2015-01-13 02:32:02 +0000 13749) 
7e5cea5b509f5 (Tomas Matheson           2021-02-19 17:33:56 +0000 13750)         if (ImplicitThis) {
7e5cea5b509f5 (Tomas Matheson           2021-02-19 17:33:56 +0000 13751)           QualType ThisType = Context.getPointerType(ImplicitThis->getType());
7e5cea5b509f5 (Tomas Matheson           2021-02-19 17:33:56 +0000 13752)           QualType ThisTypeFromDecl = Context.getPointerType(
7e5cea5b509f5 (Tomas Matheson           2021-02-19 17:33:56 +0000 13753)               cast<CXXMethodDecl>(FnDecl)->getThisObjectType());
7e5cea5b509f5 (Tomas Matheson           2021-02-19 17:33:56 +0000 13754) 
7e5cea5b509f5 (Tomas Matheson           2021-02-19 17:33:56 +0000 13755)           CheckArgAlignment(OpLoc, FnDecl, "'this'", ThisType,
7e5cea5b509f5 (Tomas Matheson           2021-02-19 17:33:56 +0000 13756)                             ThisTypeFromDecl);
7e5cea5b509f5 (Tomas Matheson           2021-02-19 17:33:56 +0000 13757)         }
7e5cea5b509f5 (Tomas Matheson           2021-02-19 17:33:56 +0000 13758) 
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000 13759)         checkCall(FnDecl, nullptr, ImplicitThis, ArgsArray,
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000 13760)                   isa<CXXMethodDecl>(FnDecl), OpLoc, TheCall->getSourceRange(),
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000 13761)                   VariadicDoesNotApply);
d24d5f2b79790 (Nick Lewycky             2013-01-24 02:03:08 +0000 13762) 
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13763)         ExprResult R = MaybeBindToTemporary(TheCall);
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13764)         if (R.isInvalid())
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13765)           return ExprError();
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13766) 
5a5f5350e1cbe (Richard Smith            2020-06-29 19:02:47 -0700 13767)         R = CheckForImmediateInvocation(R, FnDecl);
5a5f5350e1cbe (Richard Smith            2020-06-29 19:02:47 -0700 13768)         if (R.isInvalid())
5a5f5350e1cbe (Richard Smith            2020-06-29 19:02:47 -0700 13769)           return ExprError();
5a5f5350e1cbe (Richard Smith            2020-06-29 19:02:47 -0700 13770) 
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13771)         // For a rewritten candidate, we've already reversed the arguments
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13772)         // if needed. Perform the rest of the rewrite now.
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13773)         if ((Best->RewriteKind & CRK_DifferentOperator) ||
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13774)             (Op == OO_Spaceship && IsReversed)) {
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13775)           if (Op == OO_ExclaimEqual) {
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13776)             assert(ChosenOp == OO_EqualEqual && "unexpected operator name");
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13777)             R = CreateBuiltinUnaryOp(OpLoc, UO_LNot, R.get());
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13778)           } else {
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13779)             assert(ChosenOp == OO_Spaceship && "unexpected operator name");
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13780)             llvm::APSInt Zero(Context.getTypeSize(Context.IntTy), false);
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13781)             Expr *ZeroLiteral =
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13782)                 IntegerLiteral::Create(Context, Zero, Context.IntTy, OpLoc);
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13783) 
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13784)             Sema::CodeSynthesisContext Ctx;
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13785)             Ctx.Kind = Sema::CodeSynthesisContext::RewritingOperatorAsSpaceship;
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13786)             Ctx.Entity = FnDecl;
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13787)             pushCodeSynthesisContext(Ctx);
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13788) 
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13789)             R = CreateOverloadedBinOp(
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13790)                 OpLoc, Opc, Fns, IsReversed ? ZeroLiteral : R.get(),
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13791)                 IsReversed ? R.get() : ZeroLiteral, PerformADL,
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13792)                 /*AllowRewrittenCandidates=*/false);
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13793) 
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13794)             popCodeSynthesisContext();
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13795)           }
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13796)           if (R.isInvalid())
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13797)             return ExprError();
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13798)         } else {
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13799)           assert(ChosenOp == Op && "unexpected operator name");
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13800)         }
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13801) 
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13802)         // Make a note in the AST if we did any rewriting.
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13803)         if (Best->RewriteKind != CRK_None)
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13804)           R = new (Context) CXXRewrittenBinaryOperator(R.get(), IsReversed);
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13805) 
5a5f5350e1cbe (Richard Smith            2020-06-29 19:02:47 -0700 13806)         return R;
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13807)       } else {
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13808)         // We matched a built-in operator. Convert the arguments, then
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13809)         // break out so that we will build the appropriate built-in
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13810)         // operator node.
1ef7554efd1ad (Richard Smith            2018-06-27 20:30:34 +0000 13811)         ExprResult ArgsRes0 = PerformImplicitConversion(
1ef7554efd1ad (Richard Smith            2018-06-27 20:30:34 +0000 13812)             Args[0], Best->BuiltinParamTypes[0], Best->Conversions[0],
1ef7554efd1ad (Richard Smith            2018-06-27 20:30:34 +0000 13813)             AA_Passing, CCK_ForBuiltinOverloadedOp);
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 13814)         if (ArgsRes0.isInvalid())
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13815)           return ExprError();
01a7598561561 (Nikola Smiljanic         2014-05-29 10:55:11 +0000 13816)         Args[0] = ArgsRes0.get();
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13817) 
1ef7554efd1ad (Richard Smith            2018-06-27 20:30:34 +0000 13818)         ExprResult ArgsRes1 = PerformImplicitConversion(
1ef7554efd1ad (Richard Smith            2018-06-27 20:30:34 +0000 13819)             Args[1], Best->BuiltinParamTypes[1], Best->Conversions[1],
1ef7554efd1ad (Richard Smith            2018-06-27 20:30:34 +0000 13820)             AA_Passing, CCK_ForBuiltinOverloadedOp);
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 13821)         if (ArgsRes1.isInvalid())
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 13822)           return ExprError();
01a7598561561 (Nikola Smiljanic         2014-05-29 10:55:11 +0000 13823)         Args[1] = ArgsRes1.get();
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13824)         break;
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13825)       }
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13826)     }
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13827) 
66950a32d9083 (Douglas Gregor           2009-09-30 21:46:01 +0000 13828)     case OR_No_Viable_Function: {
66950a32d9083 (Douglas Gregor           2009-09-30 21:46:01 +0000 13829)       // C++ [over.match.oper]p9:
66950a32d9083 (Douglas Gregor           2009-09-30 21:46:01 +0000 13830)       //   If the operator is the operator , [...] and there are no
66950a32d9083 (Douglas Gregor           2009-09-30 21:46:01 +0000 13831)       //   viable functions, then the operator is assumed to be the
66950a32d9083 (Douglas Gregor           2009-09-30 21:46:01 +0000 13832)       //   built-in operator and interpreted according to clause 5.
e302792b6155b (John McCall              2010-08-25 11:45:40 +0000 13833)       if (Opc == BO_Comma)
66950a32d9083 (Douglas Gregor           2009-09-30 21:46:01 +0000 13834)         break;
66950a32d9083 (Douglas Gregor           2009-09-30 21:46:01 +0000 13835) 
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13836)       // When defaulting an 'operator<=>', we can try to synthesize a three-way
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13837)       // compare result using '==' and '<'.
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13838)       if (DefaultedFn && Opc == BO_Cmp) {
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13839)         ExprResult E = BuildSynthesizedThreeWayComparison(OpLoc, Fns, Args[0],
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13840)                                                           Args[1], DefaultedFn);
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13841)         if (E.isInvalid() || E.isUsable())
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13842)           return E;
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13843)       }
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13844) 
2a8c18d991188 (Alexander Kornienko      2018-04-06 15:14:32 +0000 13845)       // For class as left operand for assignment or compound assignment
8e543b3d46932 (Chandler Carruth         2010-12-12 08:17:55 +0000 13846)       // operator do not fall through to handling in built-in, but report that
8e543b3d46932 (Chandler Carruth         2010-12-12 08:17:55 +0000 13847)       // no overloaded assignment operator found
dadc575b1e878 (John McCall              2010-08-24 06:29:42 +0000 13848)       ExprResult Result = ExprError();
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 13849)       StringRef OpcStr = BinaryOperator::getOpcodeStr(Opc);
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 13850)       auto Cands = CandidateSet.CompleteCandidates(*this, OCD_AllCandidates,
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 13851)                                                    Args, OpLoc);
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 13852)       if (Args[0]->getType()->isRecordType() &&
e302792b6155b (John McCall              2010-08-25 11:45:40 +0000 13853)           Opc >= BO_Assign && Opc <= BO_OrAssign) {
027de2adcd43f (Sebastian Redl           2009-05-21 11:50:50 +0000 13854)         Diag(OpLoc,  diag::err_ovl_no_viable_oper)
027de2adcd43f (Sebastian Redl           2009-05-21 11:50:50 +0000 13855)              << BinaryOperator::getOpcodeStr(Opc)
e9899d9769661 (Douglas Gregor           2009-08-26 17:08:25 +0000 13856)              << Args[0]->getSourceRange() << Args[1]->getSourceRange();
a31efa07ff703 (Eli Friedman             2013-08-28 20:35:35 +0000 13857)         if (Args[0]->getType()->isIncompleteType()) {
a31efa07ff703 (Eli Friedman             2013-08-28 20:35:35 +0000 13858)           Diag(OpLoc, diag::note_assign_lhs_incomplete)
a31efa07ff703 (Eli Friedman             2013-08-28 20:35:35 +0000 13859)             << Args[0]->getType()
a31efa07ff703 (Eli Friedman             2013-08-28 20:35:35 +0000 13860)             << Args[0]->getSourceRange() << Args[1]->getSourceRange();
a31efa07ff703 (Eli Friedman             2013-08-28 20:35:35 +0000 13861)         }
66950a32d9083 (Douglas Gregor           2009-09-30 21:46:01 +0000 13862)       } else {
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 13863)         // This is an erroneous use of an operator which can be overloaded by
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 13864)         // a non-member function. Check for non-member operators which were
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 13865)         // defined too late to be candidates.
b24b9aa298311 (Ahmed Charles            2012-02-25 11:00:22 +0000 13866)         if (DiagnoseTwoPhaseOperatorLookup(*this, Op, OpLoc, Args))
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 13867)           // FIXME: Recover by calling the found function.
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 13868)           return ExprError();
998a591e32613 (Richard Smith            2011-06-05 22:42:48 +0000 13869) 
66950a32d9083 (Douglas Gregor           2009-09-30 21:46:01 +0000 13870)         // No viable function; try to create a built-in operation, which will
66950a32d9083 (Douglas Gregor           2009-09-30 21:46:01 +0000 13871)         // produce an error. Then, show the non-viable candidates.
66950a32d9083 (Douglas Gregor           2009-09-30 21:46:01 +0000 13872)         Result = CreateBuiltinBinOp(OpLoc, Opc, Args[0], Args[1]);
027de2adcd43f (Sebastian Redl           2009-05-21 11:50:50 +0000 13873)       }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 13874)       assert(Result.isInvalid() &&
66950a32d9083 (Douglas Gregor           2009-09-30 21:46:01 +0000 13875)              "C++ binary operator overloading is missing candidates!");
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 13876)       CandidateSet.NoteCandidates(*this, Args, Cands, OpcStr, OpLoc);
62b95d88dc14f (Benjamin Kramer          2012-08-23 21:35:17 +0000 13877)       return Result;
66950a32d9083 (Douglas Gregor           2009-09-30 21:46:01 +0000 13878)     }
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13879) 
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13880)     case OR_Ambiguous:
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 13881)       CandidateSet.NoteCandidates(
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 13882)           PartialDiagnosticAt(OpLoc, PDiag(diag::err_ovl_ambiguous_oper_binary)
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 13883)                                          << BinaryOperator::getOpcodeStr(Opc)
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 13884)                                          << Args[0]->getType()
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 13885)                                          << Args[1]->getType()
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 13886)                                          << Args[0]->getSourceRange()
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 13887)                                          << Args[1]->getSourceRange()),
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 13888)           *this, OCD_AmbiguousCandidates, Args, BinaryOperator::getOpcodeStr(Opc),
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 13889)           OpLoc);
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13890)       return ExprError();
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13891) 
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13892)     case OR_Deleted:
74f7d50f6a5b2 (Douglas Gregor           2012-02-15 19:33:52 +0000 13893)       if (isImplicitlyDeleted(Best->Function)) {
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13894)         FunctionDecl *DeletedFD = Best->Function;
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13895)         DefaultedFunctionKind DFK = getDefaultedFunctionKind(DeletedFD);
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13896)         if (DFK.isSpecialMember()) {
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13897)           Diag(OpLoc, diag::err_ovl_deleted_special_oper)
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13898)             << Args[0]->getType() << DFK.asSpecialMember();
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13899)         } else {
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13900)           assert(DFK.isComparison());
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13901)           Diag(OpLoc, diag::err_ovl_deleted_comparison)
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13902)             << Args[0]->getType() << DeletedFD;
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13903)         }
6f1e2c6d19a7f (Richard Smith            2012-04-02 20:59:25 +0000 13904) 
de1a487402585 (Richard Smith            2012-12-28 12:23:24 +0000 13905)         // The user probably meant to call this special member. Just
de1a487402585 (Richard Smith            2012-12-28 12:23:24 +0000 13906)         // explain why it's deleted.
5253d9138eb31 (Richard Smith            2019-11-06 12:03:12 -0800 13907)         NoteDeletedFunction(DeletedFD);
de1a487402585 (Richard Smith            2012-12-28 12:23:24 +0000 13908)         return ExprError();
74f7d50f6a5b2 (Douglas Gregor           2012-02-15 19:33:52 +0000 13909)       }
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 13910)       CandidateSet.NoteCandidates(
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13911)           PartialDiagnosticAt(
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13912)               OpLoc, PDiag(diag::err_ovl_deleted_oper)
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13913)                          << getOperatorSpelling(Best->Function->getDeclName()
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13914)                                                     .getCXXOverloadedOperator())
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13915)                          << Args[0]->getSourceRange()
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 13916)                          << Args[1]->getSourceRange()),
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 13917)           *this, OCD_AllCandidates, Args, BinaryOperator::getOpcodeStr(Opc),
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 13918)           OpLoc);
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13919)       return ExprError();
0d1da2298aaa8 (John McCall              2010-01-12 00:44:57 +0000 13920)   }
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13921) 
66950a32d9083 (Douglas Gregor           2009-09-30 21:46:01 +0000 13922)   // We matched a built-in operator; build it.
e9899d9769661 (Douglas Gregor           2009-08-26 17:08:25 +0000 13923)   return CreateBuiltinBinOp(OpLoc, Opc, Args[0], Args[1]);
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13924) }
1baf54e1aa8a1 (Douglas Gregor           2009-03-13 18:40:31 +0000 13925) 
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13926) ExprResult Sema::BuildSynthesizedThreeWayComparison(
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13927)     SourceLocation OpLoc, const UnresolvedSetImpl &Fns, Expr *LHS, Expr *RHS,
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13928)     FunctionDecl *DefaultedFn) {
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13929)   const ComparisonCategoryInfo *Info =
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13930)       Context.CompCategories.lookupInfoForType(DefaultedFn->getReturnType());
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13931)   // If we're not producing a known comparison category type, we can't
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13932)   // synthesize a three-way comparison. Let the caller diagnose this.
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13933)   if (!Info)
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13934)     return ExprResult((Expr*)nullptr);
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13935) 
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13936)   // If we ever want to perform this synthesis more generally, we will need to
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13937)   // apply the temporary materialization conversion to the operands.
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13938)   assert(LHS->isGLValue() && RHS->isGLValue() &&
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13939)          "cannot use prvalue expressions more than once");
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13940)   Expr *OrigLHS = LHS;
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13941)   Expr *OrigRHS = RHS;
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13942) 
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13943)   // Replace the LHS and RHS with OpaqueValueExprs; we're going to refer to
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13944)   // each of them multiple times below.
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13945)   LHS = new (Context)
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13946)       OpaqueValueExpr(LHS->getExprLoc(), LHS->getType(), LHS->getValueKind(),
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13947)                       LHS->getObjectKind(), LHS);
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13948)   RHS = new (Context)
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13949)       OpaqueValueExpr(RHS->getExprLoc(), RHS->getType(), RHS->getValueKind(),
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13950)                       RHS->getObjectKind(), RHS);
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13951) 
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13952)   ExprResult Eq = CreateOverloadedBinOp(OpLoc, BO_EQ, Fns, LHS, RHS, true, true,
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13953)                                         DefaultedFn);
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13954)   if (Eq.isInvalid())
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13955)     return ExprError();
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13956) 
f495de43bd5da (Richard Smith            2019-12-16 17:40:03 -0800 13957)   ExprResult Less = CreateOverloadedBinOp(OpLoc, BO_LT, Fns, LHS, RHS, true,
f495de43bd5da (Richard Smith            2019-12-16 17:40:03 -0800 13958)                                           true, DefaultedFn);
f495de43bd5da (Richard Smith            2019-12-16 17:40:03 -0800 13959)   if (Less.isInvalid())
f495de43bd5da (Richard Smith            2019-12-16 17:40:03 -0800 13960)     return ExprError();
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13961) 
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13962)   ExprResult Greater;
f495de43bd5da (Richard Smith            2019-12-16 17:40:03 -0800 13963)   if (Info->isPartial()) {
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13964)     Greater = CreateOverloadedBinOp(OpLoc, BO_LT, Fns, RHS, LHS, true, true,
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13965)                                     DefaultedFn);
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13966)     if (Greater.isInvalid())
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13967)       return ExprError();
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13968)   }
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13969) 
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13970)   // Form the list of comparisons we're going to perform.
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13971)   struct Comparison {
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13972)     ExprResult Cmp;
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13973)     ComparisonCategoryResult Result;
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13974)   } Comparisons[4] =
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13975)   { {Eq, Info->isStrong() ? ComparisonCategoryResult::Equal
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13976)                           : ComparisonCategoryResult::Equivalent},
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13977)     {Less, ComparisonCategoryResult::Less},
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13978)     {Greater, ComparisonCategoryResult::Greater},
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13979)     {ExprResult(), ComparisonCategoryResult::Unordered},
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13980)   };
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13981) 
f495de43bd5da (Richard Smith            2019-12-16 17:40:03 -0800 13982)   int I = Info->isPartial() ? 3 : 2;
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13983) 
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13984)   // Combine the comparisons with suitable conditional expressions.
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13985)   ExprResult Result;
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13986)   for (; I >= 0; --I) {
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13987)     // Build a reference to the comparison category constant.
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13988)     auto *VI = Info->lookupValueInfo(Comparisons[I].Result);
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13989)     // FIXME: Missing a constant for a comparison category. Diagnose this?
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13990)     if (!VI)
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13991)       return ExprResult((Expr*)nullptr);
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13992)     ExprResult ThisResult =
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13993)         BuildDeclarationNameExpr(CXXScopeSpec(), DeclarationNameInfo(), VI->VD);
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13994)     if (ThisResult.isInvalid())
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13995)       return ExprError();
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13996) 
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13997)     // Build a conditional unless this is the final case.
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13998)     if (Result.get()) {
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 13999)       Result = ActOnConditionalOp(OpLoc, OpLoc, Comparisons[I].Cmp.get(),
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 14000)                                   ThisResult.get(), Result.get());
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 14001)       if (Result.isInvalid())
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 14002)         return ExprError();
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 14003)     } else {
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 14004)       Result = ThisResult;
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 14005)     }
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 14006)   }
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 14007) 
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 14008)   // Build a PseudoObjectExpr to model the rewriting of an <=> operator, and to
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 14009)   // bind the OpaqueValueExprs before they're (repeatedly) used.
2ba4e3a4598b1 (Melanie Blower           2020-04-10 13:34:46 -0700 14010)   Expr *SyntacticForm = BinaryOperator::Create(
2ba4e3a4598b1 (Melanie Blower           2020-04-10 13:34:46 -0700 14011)       Context, OrigLHS, OrigRHS, BO_Cmp, Result.get()->getType(),
2ba4e3a4598b1 (Melanie Blower           2020-04-10 13:34:46 -0700 14012)       Result.get()->getValueKind(), Result.get()->getObjectKind(), OpLoc,
f4aaed3bf16b3 (Melanie Blower           2020-06-26 09:23:45 -0700 14013)       CurFPFeatureOverrides());
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 14014)   Expr *SemanticForm[] = {LHS, RHS, Result.get()};
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 14015)   return PseudoObjectExpr::Create(Context, SyntacticForm, SemanticForm, 2);
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 14016) }
cafc7416baf7e (Richard Smith            2019-12-04 15:25:27 -0800 14017) 
dadc575b1e878 (John McCall              2010-08-24 06:29:42 +0000 14018) ExprResult
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14019) Sema::CreateOverloadedArraySubscriptExpr(SourceLocation LLoc,
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14020)                                          SourceLocation RLoc,
b268a282a4f19 (John McCall              2010-08-23 23:25:46 +0000 14021)                                          Expr *Base, Expr *Idx) {
b268a282a4f19 (John McCall              2010-08-23 23:25:46 +0000 14022)   Expr *Args[2] = { Base, Idx };
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14023)   DeclarationName OpName =
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14024)       Context.DeclarationNames.getCXXOperatorName(OO_Subscript);
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14025) 
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14026)   // If either side is type-dependent, create an appropriate dependent
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14027)   // expression.
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14028)   if (Args[0]->isTypeDependent() || Args[1]->isTypeDependent()) {
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14029) 
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000 14030)     CXXRecordDecl *NamingClass = nullptr; // lookup ignores member operators
d6d2f18905433 (Abramo Bagnara           2010-08-11 22:01:17 +0000 14031)     // CHECKME: no 'operator' keyword?
d6d2f18905433 (Abramo Bagnara           2010-08-11 22:01:17 +0000 14032)     DeclarationNameInfo OpNameInfo(OpName, LLoc);
d6d2f18905433 (Abramo Bagnara           2010-08-11 22:01:17 +0000 14033)     OpNameInfo.setCXXOperatorNameRange(SourceRange(LLoc, RLoc));
ed5a18fc0399d (Richard Smith            2020-08-06 15:57:35 -0700 14034)     ExprResult Fn = CreateUnresolvedLookupExpr(
ed5a18fc0399d (Richard Smith            2020-08-06 15:57:35 -0700 14035)         NamingClass, NestedNameSpecifierLoc(), OpNameInfo, UnresolvedSet<0>());
ed5a18fc0399d (Richard Smith            2020-08-06 15:57:35 -0700 14036)     if (Fn.isInvalid())
ed5a18fc0399d (Richard Smith            2020-08-06 15:57:35 -0700 14037)       return ExprError();
e66edc18ae0fc (John McCall              2009-11-24 19:00:30 +0000 14038)     // Can't add any actual overloads yet
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14039) 
ed5a18fc0399d (Richard Smith            2020-08-06 15:57:35 -0700 14040)     return CXXOperatorCallExpr::Create(Context, OO_Subscript, Fn.get(), Args,
c5885cffc5206 (Bruno Ricci              2018-12-21 15:20:32 +0000 14041)                                        Context.DependentTy, VK_RValue, RLoc,
f4aaed3bf16b3 (Melanie Blower           2020-06-26 09:23:45 -0700 14042)                                        CurFPFeatureOverrides());
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14043)   }
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14044) 
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000 14045)   // Handle placeholders on both operands.
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000 14046)   if (checkPlaceholderForOverload(*this, Args[0]))
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000 14047)     return ExprError();
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000 14048)   if (checkPlaceholderForOverload(*this, Args[1]))
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000 14049)     return ExprError();
e26a872b02740 (John McCall              2010-12-04 08:14:53 +0000 14050) 
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14051)   // Build an empty overload set.
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000 14052)   OverloadCandidateSet CandidateSet(LLoc, OverloadCandidateSet::CSK_Operator);
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14053) 
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14054)   // Subscript can only be overloaded as a member function.
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14055) 
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14056)   // Add operator candidates that are member functions.
e54c307bb4ed9 (Richard Smith            2013-05-05 15:51:06 +0000 14057)   AddMemberOperatorCandidates(OO_Subscript, LLoc, Args, CandidateSet);
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14058) 
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14059)   // Add builtin operator candidates.
e54c307bb4ed9 (Richard Smith            2013-05-05 15:51:06 +0000 14060)   AddBuiltinOperatorCandidates(OO_Subscript, LLoc, Args, CandidateSet);
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14061) 
635ed24e1dad8 (Abramo Bagnara           2011-10-05 07:56:41 +0000 14062)   bool HadMultipleCandidates = (CandidateSet.size() > 1);
635ed24e1dad8 (Abramo Bagnara           2011-10-05 07:56:41 +0000 14063) 
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14064)   // Perform overload resolution.
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14065)   OverloadCandidateSet::iterator Best;
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000 14066)   switch (CandidateSet.BestViableFunction(*this, LLoc, Best)) {
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14067)     case OR_Success: {
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14068)       // We found a built-in operator or an overloaded operator.
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14069)       FunctionDecl *FnDecl = Best->Function;
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14070) 
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14071)       if (FnDecl) {
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14072)         // We matched an overloaded operator. Build a call to that
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14073)         // operator.
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14074) 
a0296f7987c0a (John McCall              2010-03-19 07:35:19 +0000 14075)         CheckMemberOperatorAccess(LLoc, Args[0], Args[1], Best->FoundDecl);
58cc69d4c1516 (John McCall              2010-01-27 01:50:18 +0000 14076) 
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14077)         // Convert the arguments.
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14078)         CXXMethodDecl *Method = cast<CXXMethodDecl>(FnDecl);
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 14079)         ExprResult Arg0 =
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000 14080)           PerformObjectArgumentInitialization(Args[0], /*Qualifier=*/nullptr,
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 14081)                                               Best->FoundDecl, Method);
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 14082)         if (Arg0.isInvalid())
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14083)           return ExprError();
01a7598561561 (Nikola Smiljanic         2014-05-29 10:55:11 +0000 14084)         Args[0] = Arg0.get();
a68e51e3a1803 (Anders Carlsson          2010-01-29 18:37:50 +0000 14085) 
a68e51e3a1803 (Anders Carlsson          2010-01-29 18:37:50 +0000 14086)         // Convert the arguments.
dadc575b1e878 (John McCall              2010-08-24 06:29:42 +0000 14087)         ExprResult InputInit
a68e51e3a1803 (Anders Carlsson          2010-01-29 18:37:50 +0000 14088)           = PerformCopyInitialization(InitializedEntity::InitializeParameter(
8fb87aec78b52 (Fariborz Jahanian        2010-09-24 17:30:16 +0000 14089)                                                       Context,
a68e51e3a1803 (Anders Carlsson          2010-01-29 18:37:50 +0000 14090)                                                       FnDecl->getParamDecl(0)),
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 14091)                                       SourceLocation(),
03ff2596cb161 (Nikola Smiljanic         2014-05-29 14:05:12 +0000 14092)                                       Args[1]);
a68e51e3a1803 (Anders Carlsson          2010-01-29 18:37:50 +0000 14093)         if (InputInit.isInvalid())
a68e51e3a1803 (Anders Carlsson          2010-01-29 18:37:50 +0000 14094)           return ExprError();
a68e51e3a1803 (Anders Carlsson          2010-01-29 18:37:50 +0000 14095) 
01a7598561561 (Nikola Smiljanic         2014-05-29 10:55:11 +0000 14096)         Args[1] = InputInit.getAs<Expr>();
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14097) 
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14098)         // Build the actual expression node.
a2a299e586bf3 (Argyrios Kyrtzidis       2012-02-08 01:21:13 +0000 14099)         DeclarationNameInfo OpLocInfo(OpName, LLoc);
a2a299e586bf3 (Argyrios Kyrtzidis       2012-02-08 01:21:13 +0000 14100)         OpLocInfo.setCXXOperatorNameRange(SourceRange(LLoc, RLoc));
635ed24e1dad8 (Abramo Bagnara           2011-10-05 07:56:41 +0000 14101)         ExprResult FnExpr = CreateFunctionRefExpr(*this, FnDecl,
134af91b06493 (Nick Lewycky             2013-02-07 05:08:22 +0000 14102)                                                   Best->FoundDecl,
2246167362bf3 (Akira Hatanaka           2017-07-13 06:08:27 +0000 14103)                                                   Base,
635ed24e1dad8 (Abramo Bagnara           2011-10-05 07:56:41 +0000 14104)                                                   HadMultipleCandidates,
a2a299e586bf3 (Argyrios Kyrtzidis       2012-02-08 01:21:13 +0000 14105)                                                   OpLocInfo.getLoc(),
a2a299e586bf3 (Argyrios Kyrtzidis       2012-02-08 01:21:13 +0000 14106)                                                   OpLocInfo.getInfo());
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 14107)         if (FnExpr.isInvalid())
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 14108)           return ExprError();
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14109) 
c156470be5123 (Richard Smith            2013-11-15 02:58:23 +0000 14110)         // Determine the result type
314cc81b8caac (Alp Toker                2014-01-25 16:55:45 +0000 14111)         QualType ResultTy = FnDecl->getReturnType();
c156470be5123 (Richard Smith            2013-11-15 02:58:23 +0000 14112)         ExprValueKind VK = Expr::getValueKindForType(ResultTy);
c156470be5123 (Richard Smith            2013-11-15 02:58:23 +0000 14113)         ResultTy = ResultTy.getNonLValueExprType(Context);
c156470be5123 (Richard Smith            2013-11-15 02:58:23 +0000 14114) 
f4aaed3bf16b3 (Melanie Blower           2020-06-26 09:23:45 -0700 14115)         CXXOperatorCallExpr *TheCall = CXXOperatorCallExpr::Create(
f4aaed3bf16b3 (Melanie Blower           2020-06-26 09:23:45 -0700 14116)             Context, OO_Subscript, FnExpr.get(), Args, ResultTy, VK, RLoc,
f4aaed3bf16b3 (Melanie Blower           2020-06-26 09:23:45 -0700 14117)             CurFPFeatureOverrides());
314cc81b8caac (Alp Toker                2014-01-25 16:55:45 +0000 14118)         if (CheckCallReturnType(FnDecl->getReturnType(), LLoc, TheCall, FnDecl))
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14119)           return ExprError();
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14120) 
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000 14121)         if (CheckFunctionCall(Method, TheCall,
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000 14122)                               Method->getType()->castAs<FunctionProtoType>()))
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000 14123)           return ExprError();
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000 14124) 
b268a282a4f19 (John McCall              2010-08-23 23:25:46 +0000 14125)         return MaybeBindToTemporary(TheCall);
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14126)       } else {
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14127)         // We matched a built-in operator. Convert the arguments, then
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14128)         // break out so that we will build the appropriate built-in
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14129)         // operator node.
1ef7554efd1ad (Richard Smith            2018-06-27 20:30:34 +0000 14130)         ExprResult ArgsRes0 = PerformImplicitConversion(
1ef7554efd1ad (Richard Smith            2018-06-27 20:30:34 +0000 14131)             Args[0], Best->BuiltinParamTypes[0], Best->Conversions[0],
1ef7554efd1ad (Richard Smith            2018-06-27 20:30:34 +0000 14132)             AA_Passing, CCK_ForBuiltinOverloadedOp);
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 14133)         if (ArgsRes0.isInvalid())
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14134)           return ExprError();
01a7598561561 (Nikola Smiljanic         2014-05-29 10:55:11 +0000 14135)         Args[0] = ArgsRes0.get();
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 14136) 
1ef7554efd1ad (Richard Smith            2018-06-27 20:30:34 +0000 14137)         ExprResult ArgsRes1 = PerformImplicitConversion(
1ef7554efd1ad (Richard Smith            2018-06-27 20:30:34 +0000 14138)             Args[1], Best->BuiltinParamTypes[1], Best->Conversions[1],
1ef7554efd1ad (Richard Smith            2018-06-27 20:30:34 +0000 14139)             AA_Passing, CCK_ForBuiltinOverloadedOp);
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 14140)         if (ArgsRes1.isInvalid())
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 14141)           return ExprError();
01a7598561561 (Nikola Smiljanic         2014-05-29 10:55:11 +0000 14142)         Args[1] = ArgsRes1.get();
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14143) 
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14144)         break;
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14145)       }
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14146)     }
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14147) 
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14148)     case OR_No_Viable_Function: {
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14149)       PartialDiagnostic PD = CandidateSet.empty()
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14150)           ? (PDiag(diag::err_ovl_no_oper)
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14151)              << Args[0]->getType() << /*subscript*/ 0
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14152)              << Args[0]->getSourceRange() << Args[1]->getSourceRange())
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14153)           : (PDiag(diag::err_ovl_no_viable_subscript)
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14154)              << Args[0]->getType() << Args[0]->getSourceRange()
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14155)              << Args[1]->getSourceRange());
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14156)       CandidateSet.NoteCandidates(PartialDiagnosticAt(LLoc, PD), *this,
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14157)                                   OCD_AllCandidates, Args, "[]", LLoc);
0237485287e9b (John McCall              2010-01-07 02:04:15 +0000 14158)       return ExprError();
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14159)     }
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14160) 
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14161)     case OR_Ambiguous:
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14162)       CandidateSet.NoteCandidates(
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14163)           PartialDiagnosticAt(LLoc, PDiag(diag::err_ovl_ambiguous_oper_binary)
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14164)                                         << "[]" << Args[0]->getType()
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14165)                                         << Args[1]->getType()
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14166)                                         << Args[0]->getSourceRange()
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14167)                                         << Args[1]->getSourceRange()),
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 14168)           *this, OCD_AmbiguousCandidates, Args, "[]", LLoc);
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14169)       return ExprError();
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14170) 
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14171)     case OR_Deleted:
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14172)       CandidateSet.NoteCandidates(
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14173)           PartialDiagnosticAt(LLoc, PDiag(diag::err_ovl_deleted_oper)
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14174)                                         << "[]" << Args[0]->getSourceRange()
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14175)                                         << Args[1]->getSourceRange()),
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14176)           *this, OCD_AllCandidates, Args, "[]", LLoc);
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14177)       return ExprError();
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14178)     }
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14179) 
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14180)   // We matched a built-in operator; build it.
b268a282a4f19 (John McCall              2010-08-23 23:25:46 +0000 14181)   return CreateBuiltinArraySubscriptExpr(Args[0], LLoc, Args[1], RLoc);
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14182) }
adba46edc224c (Sebastian Redl           2009-10-29 20:17:01 +0000 14183) 
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000 14184) /// BuildCallToMemberFunction - Build a call to a member
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000 14185) /// function. MemExpr is the expression that refers to the member
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000 14186) /// function (and includes the object parameter), Args/NumArgs are the
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000 14187) /// arguments to the function call (not including the object
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000 14188) /// parameter). The caller needs to validate that the member
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 14189) /// expression refers to a non-static member function or an overloaded
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 14190) /// member function.
556e4eba4404a (Haojian Wu               2020-11-29 22:31:42 +0100 14191) ExprResult Sema::BuildCallToMemberFunction(Scope *S, Expr *MemExprE,
556e4eba4404a (Haojian Wu               2020-11-29 22:31:42 +0100 14192)                                            SourceLocation LParenLoc,
556e4eba4404a (Haojian Wu               2020-11-29 22:31:42 +0100 14193)                                            MultiExprArg Args,
556e4eba4404a (Haojian Wu               2020-11-29 22:31:42 +0100 14194)                                            SourceLocation RParenLoc,
556e4eba4404a (Haojian Wu               2020-11-29 22:31:42 +0100 14195)                                            bool AllowRecovery) {
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 14196)   assert(MemExprE->getType() == Context.BoundMemberTy ||
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 14197)          MemExprE->getType() == Context.OverloadTy);
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 14198) 
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000 14199)   // Dig out the member expression. This holds both the object
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000 14200)   // argument and the member function we're referring to.
10eae1851d3f6 (John McCall              2009-11-30 22:42:35 +0000 14201)   Expr *NakedMemExpr = MemExprE->IgnoreParens();
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 14202) 
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 14203)   // Determine whether this is a call to a pointer-to-member function.
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 14204)   if (BinaryOperator *op = dyn_cast<BinaryOperator>(NakedMemExpr)) {
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 14205)     assert(op->getType() == Context.BoundMemberTy);
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 14206)     assert(op->getOpcode() == BO_PtrMemD || op->getOpcode() == BO_PtrMemI);
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 14207) 
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 14208)     QualType fnType =
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 14209)       op->getRHS()->getType()->castAs<MemberPointerType>()->getPointeeType();
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 14210) 
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 14211)     const FunctionProtoType *proto = fnType->castAs<FunctionProtoType>();
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 14212)     QualType resultType = proto->getCallResultType(Context);
314cc81b8caac (Alp Toker                2014-01-25 16:55:45 +0000 14213)     ExprValueKind valueKind = Expr::getValueKindForType(proto->getReturnType());
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 14214) 
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 14215)     // Check that the object type isn't more qualified than the
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 14216)     // member function we're calling.
c61eaa5920161 (Anastasia Stulova        2019-01-28 11:37:49 +0000 14217)     Qualifiers funcQuals = proto->getMethodQuals();
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 14218) 
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 14219)     QualType objectType = op->getLHS()->getType();
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 14220)     if (op->getOpcode() == BO_PtrMemI)
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 14221)       objectType = objectType->castAs<PointerType>()->getPointeeType();
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 14222)     Qualifiers objectQuals = objectType.getQualifiers();
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 14223) 
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 14224)     Qualifiers difference = objectQuals - funcQuals;
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 14225)     difference.removeObjCGCAttr();
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 14226)     difference.removeAddressSpace();
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 14227)     if (difference) {
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 14228)       std::string qualsString = difference.getAsString();
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 14229)       Diag(LParenLoc, diag::err_pointer_to_member_call_drops_quals)
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 14230)         << fnType.getUnqualifiedType()
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 14231)         << qualsString
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 14232)         << (qualsString.find(' ') == std::string::npos ? 1 : 2);
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 14233)     }
35a6ef4c35cca (Nick Lewycky             2014-01-11 02:50:57 +0000 14234) 
70e7aa4a4ed36 (Serge Pavlov             2020-07-24 12:04:19 +0700 14235)     CXXMemberCallExpr *call = CXXMemberCallExpr::Create(
70e7aa4a4ed36 (Serge Pavlov             2020-07-24 12:04:19 +0700 14236)         Context, MemExprE, Args, resultType, valueKind, RParenLoc,
70e7aa4a4ed36 (Serge Pavlov             2020-07-24 12:04:19 +0700 14237)         CurFPFeatureOverrides(), proto->getNumParams());
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 14238) 
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000 14239)     if (CheckCallReturnType(proto->getReturnType(), op->getRHS()->getBeginLoc(),
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000 14240)                             call, nullptr))
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 14241)       return ExprError();
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 14242) 
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000 14243)     if (ConvertArgumentsForCall(call, op, nullptr, proto, Args, RParenLoc))
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 14244)       return ExprError();
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 14245) 
9be9c6804f514 (Richard Trieu            2013-06-22 02:30:38 +0000 14246)     if (CheckOtherCall(call, proto))
9be9c6804f514 (Richard Trieu            2013-06-22 02:30:38 +0000 14247)       return ExprError();
9be9c6804f514 (Richard Trieu            2013-06-22 02:30:38 +0000 14248) 
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 14249)     return MaybeBindToTemporary(call);
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 14250)   }
0009fcc39e19e (John McCall              2011-04-26 20:42:42 +0000 14251) 
556e4eba4404a (Haojian Wu               2020-11-29 22:31:42 +0100 14252)   // We only try to build a recovery expr at this level if we can preserve
556e4eba4404a (Haojian Wu               2020-11-29 22:31:42 +0100 14253)   // the return type, otherwise we return ExprError() and let the caller
556e4eba4404a (Haojian Wu               2020-11-29 22:31:42 +0100 14254)   // recover.
556e4eba4404a (Haojian Wu               2020-11-29 22:31:42 +0100 14255)   auto BuildRecoveryExpr = [&](QualType Type) {
556e4eba4404a (Haojian Wu               2020-11-29 22:31:42 +0100 14256)     if (!AllowRecovery)
556e4eba4404a (Haojian Wu               2020-11-29 22:31:42 +0100 14257)       return ExprError();
556e4eba4404a (Haojian Wu               2020-11-29 22:31:42 +0100 14258)     std::vector<Expr *> SubExprs = {MemExprE};
556e4eba4404a (Haojian Wu               2020-11-29 22:31:42 +0100 14259)     llvm::for_each(Args, [&SubExprs](Expr *E) { SubExprs.push_back(E); });
556e4eba4404a (Haojian Wu               2020-11-29 22:31:42 +0100 14260)     return CreateRecoveryExpr(MemExprE->getBeginLoc(), RParenLoc, SubExprs,
556e4eba4404a (Haojian Wu               2020-11-29 22:31:42 +0100 14261)                               Type);
556e4eba4404a (Haojian Wu               2020-11-29 22:31:42 +0100 14262)   };
ced8bdf74a4f2 (David Majnemer           2015-02-25 17:36:15 +0000 14263)   if (isa<CXXPseudoDestructorExpr>(NakedMemExpr))
c5885cffc5206 (Bruno Ricci              2018-12-21 15:20:32 +0000 14264)     return CallExpr::Create(Context, MemExprE, Args, Context.VoidTy, VK_RValue,
70e7aa4a4ed36 (Serge Pavlov             2020-07-24 12:04:19 +0700 14265)                             RParenLoc, CurFPFeatureOverrides());
ced8bdf74a4f2 (David Majnemer           2015-02-25 17:36:15 +0000 14266) 
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000 14267)   UnbridgedCastsSet UnbridgedCasts;
9c785c217b3f9 (Dmitri Gribenko          2013-05-09 21:02:07 +0000 14268)   if (checkArgPlaceholdersForOverload(*this, Args, UnbridgedCasts))
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000 14269)     return ExprError();
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000 14270) 
10eae1851d3f6 (John McCall              2009-11-30 22:42:35 +0000 14271)   MemberExpr *MemExpr;
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000 14272)   CXXMethodDecl *Method = nullptr;
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000 14273)   DeclAccessPair FoundDecl = DeclAccessPair::make(nullptr, AS_public);
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000 14274)   NestedNameSpecifier *Qualifier = nullptr;
10eae1851d3f6 (John McCall              2009-11-30 22:42:35 +0000 14275)   if (isa<MemberExpr>(NakedMemExpr)) {
10eae1851d3f6 (John McCall              2009-11-30 22:42:35 +0000 14276)     MemExpr = cast<MemberExpr>(NakedMemExpr);
10eae1851d3f6 (John McCall              2009-11-30 22:42:35 +0000 14277)     Method = cast<CXXMethodDecl>(MemExpr->getMemberDecl());
16df1e59f2bb7 (John McCall              2010-03-30 21:47:33 +0000 14278)     FoundDecl = MemExpr->getFoundDecl();
cc3f325fa69e7 (Douglas Gregor           2010-03-03 23:55:11 +0000 14279)     Qualifier = MemExpr->getQualifier();
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000 14280)     UnbridgedCasts.restore();
10eae1851d3f6 (John McCall              2009-11-30 22:42:35 +0000 14281)   } else {
10eae1851d3f6 (John McCall              2009-11-30 22:42:35 +0000 14282)     UnresolvedMemberExpr *UnresExpr = cast<UnresolvedMemberExpr>(NakedMemExpr);
cc3f325fa69e7 (Douglas Gregor           2010-03-03 23:55:11 +0000 14283)     Qualifier = UnresExpr->getQualifier();
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 14284) 
6e9f8f6374349 (John McCall              2009-12-03 04:06:58 +0000 14285)     QualType ObjectType = UnresExpr->getBaseType();
0282432039ab9 (Douglas Gregor           2011-01-26 19:30:28 +0000 14286)     Expr::Classification ObjectClassification
0282432039ab9 (Douglas Gregor           2011-01-26 19:30:28 +0000 14287)       = UnresExpr->isArrow()? Expr::Classification::makeSimpleLValue()
0282432039ab9 (Douglas Gregor           2011-01-26 19:30:28 +0000 14288)                             : UnresExpr->getBase()->Classify(Context);
10eae1851d3f6 (John McCall              2009-11-30 22:42:35 +0000 14289) 
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000 14290)     // Add overload candidates
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000 14291)     OverloadCandidateSet CandidateSet(UnresExpr->getMemberLoc(),
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000 14292)                                       OverloadCandidateSet::CSK_Normal);
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000 14293) 
2d74de96325e4 (John McCall              2009-12-01 22:10:20 +0000 14294)     // FIXME: avoid copy.
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000 14295)     TemplateArgumentListInfo TemplateArgsBuffer, *TemplateArgs = nullptr;
2d74de96325e4 (John McCall              2009-12-01 22:10:20 +0000 14296)     if (UnresExpr->hasExplicitTemplateArgs()) {
2d74de96325e4 (John McCall              2009-12-01 22:10:20 +0000 14297)       UnresExpr->copyTemplateArgumentsInto(TemplateArgsBuffer);
2d74de96325e4 (John McCall              2009-12-01 22:10:20 +0000 14298)       TemplateArgs = &TemplateArgsBuffer;
2d74de96325e4 (John McCall              2009-12-01 22:10:20 +0000 14299)     }
2d74de96325e4 (John McCall              2009-12-01 22:10:20 +0000 14300) 
10eae1851d3f6 (John McCall              2009-11-30 22:42:35 +0000 14301)     for (UnresolvedMemberExpr::decls_iterator I = UnresExpr->decls_begin(),
10eae1851d3f6 (John McCall              2009-11-30 22:42:35 +0000 14302)            E = UnresExpr->decls_end(); I != E; ++I) {
10eae1851d3f6 (John McCall              2009-11-30 22:42:35 +0000 14303) 
6e9f8f6374349 (John McCall              2009-12-03 04:06:58 +0000 14304)       NamedDecl *Func = *I;
6e9f8f6374349 (John McCall              2009-12-03 04:06:58 +0000 14305)       CXXRecordDecl *ActingDC = cast<CXXRecordDecl>(Func->getDeclContext());
6e9f8f6374349 (John McCall              2009-12-03 04:06:58 +0000 14306)       if (isa<UsingShadowDecl>(Func))
6e9f8f6374349 (John McCall              2009-12-03 04:06:58 +0000 14307)         Func = cast<UsingShadowDecl>(Func)->getTargetDecl();
6e9f8f6374349 (John McCall              2009-12-03 04:06:58 +0000 14308) 
0282432039ab9 (Douglas Gregor           2011-01-26 19:30:28 +0000 14309) 
64225794119ee (Francois Pichet          2011-01-18 05:04:39 +0000 14310)       // Microsoft supports direct constructor calls.
bbafb8a745736 (David Blaikie            2012-03-11 07:00:24 +0000 14311)       if (getLangOpts().MicrosoftExt && isa<CXXConstructorDecl>(Func)) {
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000 14312)         AddOverloadCandidate(cast<CXXConstructorDecl>(Func), I.getPair(), Args,
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000 14313)                              CandidateSet,
76b9027f352a8 (Richard Smith            2019-05-09 03:59:21 +0000 14314)                              /*SuppressUserConversions*/ false);
64225794119ee (Francois Pichet          2011-01-18 05:04:39 +0000 14315)       } else if ((Method = dyn_cast<CXXMethodDecl>(Func))) {
d33198420ddad (Douglas Gregor           2009-10-24 04:59:53 +0000 14316)         // If explicit template arguments were provided, we can't call a
d33198420ddad (Douglas Gregor           2009-10-24 04:59:53 +0000 14317)         // non-template member function.
2d74de96325e4 (John McCall              2009-12-01 22:10:20 +0000 14318)         if (TemplateArgs)
d33198420ddad (Douglas Gregor           2009-10-24 04:59:53 +0000 14319)           continue;
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 14320) 
a0296f7987c0a (John McCall              2010-03-19 07:35:19 +0000 14321)         AddMethodCandidate(Method, I.getPair(), ActingDC, ObjectType,
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000 14322)                            ObjectClassification, Args, CandidateSet,
0282432039ab9 (Douglas Gregor           2011-01-26 19:30:28 +0000 14323)                            /*SuppressUserConversions=*/false);
6b51f28e82646 (John McCall              2009-11-23 01:53:49 +0000 14324)       } else {
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000 14325)         AddMethodTemplateCandidate(
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000 14326)             cast<FunctionTemplateDecl>(Func), I.getPair(), ActingDC,
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000 14327)             TemplateArgs, ObjectType, ObjectClassification, Args, CandidateSet,
49a3ad21d6034 (Rui Ueyama               2019-07-16 04:46:31 +0000 14328)             /*SuppressUserConversions=*/false);
6b51f28e82646 (John McCall              2009-11-23 01:53:49 +0000 14329)       }
5ed5ae476e5c7 (Douglas Gregor           2009-08-21 18:42:58 +0000 14330)     }
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000 14331) 
10eae1851d3f6 (John McCall              2009-11-30 22:42:35 +0000 14332)     DeclarationName DeclName = UnresExpr->getMemberName();
10eae1851d3f6 (John McCall              2009-11-30 22:42:35 +0000 14333) 
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000 14334)     UnbridgedCasts.restore();
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000 14335) 
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000 14336)     OverloadCandidateSet::iterator Best;
6326b098852be (Haojian Wu               2020-12-14 08:45:13 +0100 14337)     bool Succeeded = false;
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000 14338)     switch (CandidateSet.BestViableFunction(*this, UnresExpr->getBeginLoc(),
9331ed89f8d34 (Nick Lewycky             2010-11-20 01:29:55 +0000 14339)                                             Best)) {
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000 14340)     case OR_Success:
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000 14341)       Method = cast<CXXMethodDecl>(Best->Function);
16df1e59f2bb7 (John McCall              2010-03-30 21:47:33 +0000 14342)       FoundDecl = Best->FoundDecl;
a0296f7987c0a (John McCall              2010-03-19 07:35:19 +0000 14343)       CheckUnresolvedMemberAccess(UnresExpr, Best->FoundDecl);
22262abd78af0 (Richard Smith            2013-05-04 06:44:46 +0000 14344)       if (DiagnoseUseOfDecl(Best->FoundDecl, UnresExpr->getNameLoc()))
6326b098852be (Haojian Wu               2020-12-14 08:45:13 +0100 14345)         break;
d667641542527 (Faisal Vali              2013-06-15 11:54:37 +0000 14346)       // If FoundDecl is different from Method (such as if one is a template
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000 14347)       // and the other a specialization), make sure DiagnoseUseOfDecl is
d667641542527 (Faisal Vali              2013-06-15 11:54:37 +0000 14348)       // called on both.
d667641542527 (Faisal Vali              2013-06-15 11:54:37 +0000 14349)       // FIXME: This would be more comprehensively addressed by modifying
d667641542527 (Faisal Vali              2013-06-15 11:54:37 +0000 14350)       // DiagnoseUseOfDecl to accept both the FoundDecl and the decl
d667641542527 (Faisal Vali              2013-06-15 11:54:37 +0000 14351)       // being used.
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000 14352)       if (Method != FoundDecl.getDecl() &&
d667641542527 (Faisal Vali              2013-06-15 11:54:37 +0000 14353)                       DiagnoseUseOfDecl(Method, UnresExpr->getNameLoc()))
6326b098852be (Haojian Wu               2020-12-14 08:45:13 +0100 14354)         break;
6326b098852be (Haojian Wu               2020-12-14 08:45:13 +0100 14355)       Succeeded = true;
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000 14356)       break;
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000 14357) 
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000 14358)     case OR_No_Viable_Function:
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14359)       CandidateSet.NoteCandidates(
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14360)           PartialDiagnosticAt(
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14361)               UnresExpr->getMemberLoc(),
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14362)               PDiag(diag::err_ovl_no_viable_member_function_in_call)
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14363)                   << DeclName << MemExprE->getSourceRange()),
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14364)           *this, OCD_AllCandidates, Args);
6326b098852be (Haojian Wu               2020-12-14 08:45:13 +0100 14365)       break;
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000 14366)     case OR_Ambiguous:
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14367)       CandidateSet.NoteCandidates(
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14368)           PartialDiagnosticAt(UnresExpr->getMemberLoc(),
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14369)                               PDiag(diag::err_ovl_ambiguous_member_call)
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14370)                                   << DeclName << MemExprE->getSourceRange()),
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 14371)           *this, OCD_AmbiguousCandidates, Args);
6326b098852be (Haojian Wu               2020-12-14 08:45:13 +0100 14372)       break;
171c45ab0c19b (Douglas Gregor           2009-02-18 21:56:37 +0000 14373)     case OR_Deleted:
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14374)       CandidateSet.NoteCandidates(
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14375)           PartialDiagnosticAt(UnresExpr->getMemberLoc(),
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14376)                               PDiag(diag::err_ovl_deleted_member_call)
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14377)                                   << DeclName << MemExprE->getSourceRange()),
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14378)           *this, OCD_AllCandidates, Args);
6326b098852be (Haojian Wu               2020-12-14 08:45:13 +0100 14379)       break;
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000 14380)     }
6326b098852be (Haojian Wu               2020-12-14 08:45:13 +0100 14381)     // Overload resolution fails, try to recover.
6326b098852be (Haojian Wu               2020-12-14 08:45:13 +0100 14382)     if (!Succeeded)
6326b098852be (Haojian Wu               2020-12-14 08:45:13 +0100 14383)       return BuildRecoveryExpr(chooseRecoveryType(CandidateSet, &Best));
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000 14384) 
16df1e59f2bb7 (John McCall              2010-03-30 21:47:33 +0000 14385)     MemExprE = FixOverloadedFunctionReference(MemExprE, FoundDecl, Method);
2d74de96325e4 (John McCall              2009-12-01 22:10:20 +0000 14386) 
2d74de96325e4 (John McCall              2009-12-01 22:10:20 +0000 14387)     // If overload resolution picked a static member, build a
2d74de96325e4 (John McCall              2009-12-01 22:10:20 +0000 14388)     // non-member call based on that function.
2d74de96325e4 (John McCall              2009-12-01 22:10:20 +0000 14389)     if (Method->isStatic()) {
9c785c217b3f9 (Dmitri Gribenko          2013-05-09 21:02:07 +0000 14390)       return BuildResolvedCallExpr(MemExprE, Method, LParenLoc, Args,
9c785c217b3f9 (Dmitri Gribenko          2013-05-09 21:02:07 +0000 14391)                                    RParenLoc);
2d74de96325e4 (John McCall              2009-12-01 22:10:20 +0000 14392)     }
2d74de96325e4 (John McCall              2009-12-01 22:10:20 +0000 14393) 
10eae1851d3f6 (John McCall              2009-11-30 22:42:35 +0000 14394)     MemExpr = cast<MemberExpr>(MemExprE->IgnoreParens());
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000 14395)   }
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000 14396) 
314cc81b8caac (Alp Toker                2014-01-25 16:55:45 +0000 14397)   QualType ResultType = Method->getReturnType();
7decc9e4ea6c5 (John McCall              2010-11-18 06:31:45 +0000 14398)   ExprValueKind VK = Expr::getValueKindForType(ResultType);
7decc9e4ea6c5 (John McCall              2010-11-18 06:31:45 +0000 14399)   ResultType = ResultType.getNonLValueExprType(Context);
7decc9e4ea6c5 (John McCall              2010-11-18 06:31:45 +0000 14400) 
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000 14401)   assert(Method && "Member call to something that isn't a method?");
ab9dbc1d124cd (Simon Pilgrim            2020-01-14 14:15:51 +0000 14402)   const auto *Proto = Method->getType()->castAs<FunctionProtoType>();
70e7aa4a4ed36 (Serge Pavlov             2020-07-24 12:04:19 +0700 14403)   CXXMemberCallExpr *TheCall = CXXMemberCallExpr::Create(
70e7aa4a4ed36 (Serge Pavlov             2020-07-24 12:04:19 +0700 14404)       Context, MemExprE, Args, ResultType, VK, RParenLoc,
70e7aa4a4ed36 (Serge Pavlov             2020-07-24 12:04:19 +0700 14405)       CurFPFeatureOverrides(), Proto->getNumParams());
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000 14406) 
c4859baea4af6 (Anders Carlsson          2009-10-10 00:06:20 +0000 14407)   // Check for a valid return type.
314cc81b8caac (Alp Toker                2014-01-25 16:55:45 +0000 14408)   if (CheckCallReturnType(Method->getReturnType(), MemExpr->getMemberLoc(),
b268a282a4f19 (John McCall              2010-08-23 23:25:46 +0000 14409)                           TheCall, Method))
556e4eba4404a (Haojian Wu               2020-11-29 22:31:42 +0100 14410)     return BuildRecoveryExpr(ResultType);
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 14411) 
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000 14412)   // Convert the object argument (for a non-static member function call).
16df1e59f2bb7 (John McCall              2010-03-30 21:47:33 +0000 14413)   // We only need to do this if there was actually an overload; otherwise
16df1e59f2bb7 (John McCall              2010-03-30 21:47:33 +0000 14414)   // it was done at lookup.
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 14415)   if (!Method->isStatic()) {
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 14416)     ExprResult ObjectArg =
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 14417)       PerformObjectArgumentInitialization(MemExpr->getBase(), Qualifier,
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 14418)                                           FoundDecl, Method);
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 14419)     if (ObjectArg.isInvalid())
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 14420)       return ExprError();
01a7598561561 (Nikola Smiljanic         2014-05-29 10:55:11 +0000 14421)     MemExpr->setBase(ObjectArg.get());
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 14422)   }
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000 14423) 
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000 14424)   // Convert the rest of the arguments
9c785c217b3f9 (Dmitri Gribenko          2013-05-09 21:02:07 +0000 14425)   if (ConvertArgumentsForCall(TheCall, MemExpr, Method, Proto, Args,
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000 14426)                               RParenLoc))
556e4eba4404a (Haojian Wu               2020-11-29 22:31:42 +0100 14427)     return BuildRecoveryExpr(ResultType);
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000 14428) 
9c785c217b3f9 (Dmitri Gribenko          2013-05-09 21:02:07 +0000 14429)   DiagnoseSentinelCalls(Method, LParenLoc, Args);
ff4b407009962 (Eli Friedman             2012-02-18 04:48:30 +0000 14430) 
55ce352d4d011 (Richard Smith            2012-06-25 20:30:08 +0000 14431)   if (CheckFunctionCall(Method, TheCall, Proto))
2d74de96325e4 (John McCall              2009-12-01 22:10:20 +0000 14432)     return ExprError();
8c84c206d95e8 (Anders Carlsson          2009-08-16 03:42:12 +0000 14433) 
aea6ade63a5e8 (George Burgess IV        2015-09-25 17:53:16 +0000 14434)   // In the case the method to call was not selected by the overloading
aea6ade63a5e8 (George Burgess IV        2015-09-25 17:53:16 +0000 14435)   // resolution process, we still need to handle the enable_if attribute. Do
0d546534d3e7e (George Burgess IV        2016-11-10 21:47:12 +0000 14436)   // that here, so it will not hide previous -- and more relevant -- errors.
add6ab5084903 (George Burgess IV        2016-11-16 21:31:25 +0000 14437)   if (auto *MemE = dyn_cast<MemberExpr>(NakedMemExpr)) {
0dfb43deb6d55 (Richard Smith            2020-05-28 15:02:18 -0700 14438)     if (const EnableIfAttr *Attr =
0dfb43deb6d55 (Richard Smith            2020-05-28 15:02:18 -0700 14439)             CheckEnableIf(Method, LParenLoc, Args, true)) {
add6ab5084903 (George Burgess IV        2016-11-16 21:31:25 +0000 14440)       Diag(MemE->getMemberLoc(),
aea6ade63a5e8 (George Burgess IV        2015-09-25 17:53:16 +0000 14441)            diag::err_ovl_no_viable_member_function_in_call)
aea6ade63a5e8 (George Burgess IV        2015-09-25 17:53:16 +0000 14442)           << Method << Method->getSourceRange();
aea6ade63a5e8 (George Burgess IV        2015-09-25 17:53:16 +0000 14443)       Diag(Method->getLocation(),
177399e2277c3 (George Burgess IV        2017-01-09 04:12:14 +0000 14444)            diag::note_ovl_candidate_disabled_by_function_cond_attr)
aea6ade63a5e8 (George Burgess IV        2015-09-25 17:53:16 +0000 14445)           << Attr->getCond()->getSourceRange() << Attr->getMessage();
aea6ade63a5e8 (George Burgess IV        2015-09-25 17:53:16 +0000 14446)       return ExprError();
aea6ade63a5e8 (George Burgess IV        2015-09-25 17:53:16 +0000 14447)     }
aea6ade63a5e8 (George Burgess IV        2015-09-25 17:53:16 +0000 14448)   }
aea6ade63a5e8 (George Burgess IV        2015-09-25 17:53:16 +0000 14449) 
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000 14450)   if ((isa<CXXConstructorDecl>(CurContext) ||
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000 14451)        isa<CXXDestructorDecl>(CurContext)) &&
47061ee5bc64f (Anders Carlsson          2011-05-06 14:25:31 +0000 14452)       TheCall->getMethodDecl()->isPure()) {
47061ee5bc64f (Anders Carlsson          2011-05-06 14:25:31 +0000 14453)     const CXXMethodDecl *MD = TheCall->getMethodDecl();
47061ee5bc64f (Anders Carlsson          2011-05-06 14:25:31 +0000 14454) 
ccb3738527581 (Davide Italiano          2015-07-14 23:36:10 +0000 14455)     if (isa<CXXThisExpr>(MemExpr->getBase()->IgnoreParenCasts()) &&
ccb3738527581 (Davide Italiano          2015-07-14 23:36:10 +0000 14456)         MemExpr->performsVirtualDispatch(getLangOpts())) {
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000 14457)       Diag(MemExpr->getBeginLoc(),
47061ee5bc64f (Anders Carlsson          2011-05-06 14:25:31 +0000 14458)            diag::warn_call_to_pure_virtual_member_function_from_ctor_dtor)
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000 14459)           << MD->getDeclName() << isa<CXXDestructorDecl>(CurContext)
eb10b065f2a87 (Bruno Ricci              2020-07-27 23:22:21 +0100 14460)           << MD->getParent();
47061ee5bc64f (Anders Carlsson          2011-05-06 14:25:31 +0000 14461) 
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000 14462)       Diag(MD->getBeginLoc(), diag::note_previous_decl) << MD->getDeclName();
ccb3738527581 (Davide Italiano          2015-07-14 23:36:10 +0000 14463)       if (getLangOpts().AppleKext)
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000 14464)         Diag(MemExpr->getBeginLoc(), diag::note_pure_qualified_call_kext)
eb10b065f2a87 (Bruno Ricci              2020-07-27 23:22:21 +0100 14465)             << MD->getParent() << MD->getDeclName();
5925926a2fc0f (Chandler Carruth         2011-06-27 08:31:58 +0000 14466)     }
47061ee5bc64f (Anders Carlsson          2011-05-06 14:25:31 +0000 14467)   }
5a9259caa9b78 (Nico Weber               2016-01-15 21:45:31 +0000 14468) 
5a9259caa9b78 (Nico Weber               2016-01-15 21:45:31 +0000 14469)   if (CXXDestructorDecl *DD =
5a9259caa9b78 (Nico Weber               2016-01-15 21:45:31 +0000 14470)           dyn_cast<CXXDestructorDecl>(TheCall->getMethodDecl())) {
5a9259caa9b78 (Nico Weber               2016-01-15 21:45:31 +0000 14471)     // a->A::f() doesn't go through the vtable, except in AppleKext mode.
d35f706cc2849 (Justin Lebar             2016-07-12 23:23:01 +0000 14472)     bool CallCanBeVirtual = !MemExpr->hasQualifier() || getLangOpts().AppleKext;
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000 14473)     CheckVirtualDtorCall(DD, MemExpr->getBeginLoc(), /*IsDelete=*/false,
5a9259caa9b78 (Nico Weber               2016-01-15 21:45:31 +0000 14474)                          CallCanBeVirtual, /*WarnOnNonAbstractTypes=*/true,
5a9259caa9b78 (Nico Weber               2016-01-15 21:45:31 +0000 14475)                          MemExpr->getMemberLoc());
5a9259caa9b78 (Nico Weber               2016-01-15 21:45:31 +0000 14476)   }
5a9259caa9b78 (Nico Weber               2016-01-15 21:45:31 +0000 14477) 
008e7bf92343b (Tyker                    2020-02-04 19:23:33 +0100 14478)   return CheckForImmediateInvocation(MaybeBindToTemporary(TheCall),
008e7bf92343b (Tyker                    2020-02-04 19:23:33 +0100 14479)                                      TheCall->getMethodDecl());
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000 14480) }
97fd6e24c4e09 (Douglas Gregor           2008-12-22 05:46:06 +0000 14481) 
91cea0ad1e4cd (Douglas Gregor           2008-11-19 21:05:33 +0000 14482) /// BuildCallToObjectOfClassType - Build a call to an object of class
91cea0ad1e4cd (Douglas Gregor           2008-11-19 21:05:33 +0000 14483) /// type (C++ [over.call.object]), which can end up invoking an
91cea0ad1e4cd (Douglas Gregor           2008-11-19 21:05:33 +0000 14484) /// overloaded function call operator (@c operator()) or performing a
91cea0ad1e4cd (Douglas Gregor           2008-11-19 21:05:33 +0000 14485) /// user-defined conversion on the object argument.
faf5fb4b78c79 (John McCall              2010-08-26 23:41:50 +0000 14486) ExprResult
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 14487) Sema::BuildCallToObjectOfClassType(Scope *S, Expr *Obj,
b0846b0f5101c (Douglas Gregor           2008-12-06 00:22:45 +0000 14488)                                    SourceLocation LParenLoc,
d3b75560aa07b (Dmitri Gribenko          2013-05-09 23:32:58 +0000 14489)                                    MultiExprArg Args,
91cea0ad1e4cd (Douglas Gregor           2008-11-19 21:05:33 +0000 14490)                                    SourceLocation RParenLoc) {
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000 14491)   if (checkPlaceholderForOverload(*this, Obj))
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000 14492)     return ExprError();
03ff2596cb161 (Nikola Smiljanic         2014-05-29 14:05:12 +0000 14493)   ExprResult Object = Obj;
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000 14494) 
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000 14495)   UnbridgedCastsSet UnbridgedCasts;
d3b75560aa07b (Dmitri Gribenko          2013-05-09 23:32:58 +0000 14496)   if (checkArgPlaceholdersForOverload(*this, Args, UnbridgedCasts))
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000 14497)     return ExprError();
e26a872b02740 (John McCall              2010-12-04 08:14:53 +0000 14498) 
b58e51c304112 (Nico Weber               2014-11-19 05:21:39 +0000 14499)   assert(Object.get()->getType()->isRecordType() &&
b58e51c304112 (Nico Weber               2014-11-19 05:21:39 +0000 14500)          "Requires object type argument");
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000 14501) 
91cea0ad1e4cd (Douglas Gregor           2008-11-19 21:05:33 +0000 14502)   // C++ [over.call.object]p1:
91cea0ad1e4cd (Douglas Gregor           2008-11-19 21:05:33 +0000 14503)   //  If the primary-expression E in the function call syntax
44b83eea308ef (Eli Friedman             2009-08-05 19:21:58 +0000 14504)   //  evaluates to a class object of type "cv T", then the set of
91cea0ad1e4cd (Douglas Gregor           2008-11-19 21:05:33 +0000 14505)   //  candidate functions includes at least the function call
91cea0ad1e4cd (Douglas Gregor           2008-11-19 21:05:33 +0000 14506)   //  operators of T. The function call operators of T are obtained by
91cea0ad1e4cd (Douglas Gregor           2008-11-19 21:05:33 +0000 14507)   //  ordinary lookup of the name operator() in the context of
91cea0ad1e4cd (Douglas Gregor           2008-11-19 21:05:33 +0000 14508)   //  (E).operator().
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000 14509)   OverloadCandidateSet CandidateSet(LParenLoc,
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000 14510)                                     OverloadCandidateSet::CSK_Operator);
91f84216f78f5 (Douglas Gregor           2008-12-11 16:49:14 +0000 14511)   DeclarationName OpName = Context.DeclarationNames.getCXXOperatorName(OO_Call);
c473cbb3b2316 (Douglas Gregor           2009-11-15 07:48:03 +0000 14512) 
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 14513)   if (RequireCompleteType(LParenLoc, Object.get()->getType(),
7bfb2d026ec99 (Douglas Gregor           2012-05-04 16:32:21 +0000 14514)                           diag::err_incomplete_object_call, Object.get()))
c473cbb3b2316 (Douglas Gregor           2009-11-15 07:48:03 +0000 14515)     return true;
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 14516) 
ab9dbc1d124cd (Simon Pilgrim            2020-01-14 14:15:51 +0000 14517)   const auto *Record = Object.get()->getType()->castAs<RecordType>();
27b18f8144b7c (John McCall              2009-11-17 02:14:36 +0000 14518)   LookupResult R(*this, OpName, LParenLoc, LookupOrdinaryName);
27b18f8144b7c (John McCall              2009-11-17 02:14:36 +0000 14519)   LookupQualifiedName(R, Record->getDecl());
27b18f8144b7c (John McCall              2009-11-17 02:14:36 +0000 14520)   R.suppressDiagnostics();
27b18f8144b7c (John McCall              2009-11-17 02:14:36 +0000 14521) 
c473cbb3b2316 (Douglas Gregor           2009-11-15 07:48:03 +0000 14522)   for (LookupResult::iterator Oper = R.begin(), OperEnd = R.end();
358e7745ed8fd (Douglas Gregor           2009-11-07 17:23:56 +0000 14523)        Oper != OperEnd; ++Oper) {
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 14524)     AddMethodCandidate(Oper.getPair(), Object.get()->getType(),
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000 14525)                        Object.get()->Classify(Context), Args, CandidateSet,
49a3ad21d6034 (Rui Ueyama               2019-07-16 04:46:31 +0000 14526)                        /*SuppressUserConversion=*/false);
358e7745ed8fd (Douglas Gregor           2009-11-07 17:23:56 +0000 14527)   }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 14528) 
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000 14529)   // C++ [over.call.object]p2:
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000 14530)   //   In addition, for each (non-explicit in C++0x) conversion function
38b2d3fa3e49a (Douglas Gregor           2011-07-23 18:59:35 +0000 14531)   //   declared in T of the form
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000 14532)   //
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000 14533)   //        operator conversion-type-id () cv-qualifier;
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000 14534)   //
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000 14535)   //   where cv-qualifier is the same cv-qualification as, or a
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000 14536)   //   greater cv-qualification than, cv, and where conversion-type-id
f49fdf8337440 (Douglas Gregor           2008-11-20 13:33:37 +0000 14537)   //   denotes the type "pointer to function of (P1,...,Pn) returning
f49fdf8337440 (Douglas Gregor           2008-11-20 13:33:37 +0000 14538)   //   R", or the type "reference to pointer to function of
f49fdf8337440 (Douglas Gregor           2008-11-20 13:33:37 +0000 14539)   //   (P1,...,Pn) returning R", or the type "reference to function
f49fdf8337440 (Douglas Gregor           2008-11-20 13:33:37 +0000 14540)   //   of (P1,...,Pn) returning R", a surrogate call function [...]
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000 14541)   //   is also considered as a candidate function. Similarly,
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000 14542)   //   surrogate call functions are added to the set of candidate
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000 14543)   //   functions for each conversion function declared in an
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000 14544)   //   accessible base class provided the function is not hidden
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000 14545)   //   within T by another intervening declaration.
b4ef66832dee0 (Benjamin Kramer          2015-02-06 17:25:10 +0000 14546)   const auto &Conversions =
b4ef66832dee0 (Benjamin Kramer          2015-02-06 17:25:10 +0000 14547)       cast<CXXRecordDecl>(Record->getDecl())->getVisibleConversionFunctions();
b4ef66832dee0 (Benjamin Kramer          2015-02-06 17:25:10 +0000 14548)   for (auto I = Conversions.begin(), E = Conversions.end(); I != E; ++I) {
6e9f8f6374349 (John McCall              2009-12-03 04:06:58 +0000 14549)     NamedDecl *D = *I;
6e9f8f6374349 (John McCall              2009-12-03 04:06:58 +0000 14550)     CXXRecordDecl *ActingContext = cast<CXXRecordDecl>(D->getDeclContext());
6e9f8f6374349 (John McCall              2009-12-03 04:06:58 +0000 14551)     if (isa<UsingShadowDecl>(D))
6e9f8f6374349 (John McCall              2009-12-03 04:06:58 +0000 14552)       D = cast<UsingShadowDecl>(D)->getTargetDecl();
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 14553) 
74ba25ca5a34e (Douglas Gregor           2009-10-21 06:18:39 +0000 14554)     // Skip over templated conversion functions; they aren't
74ba25ca5a34e (Douglas Gregor           2009-10-21 06:18:39 +0000 14555)     // surrogates.
6e9f8f6374349 (John McCall              2009-12-03 04:06:58 +0000 14556)     if (isa<FunctionTemplateDecl>(D))
74ba25ca5a34e (Douglas Gregor           2009-10-21 06:18:39 +0000 14557)       continue;
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000 14558) 
6e9f8f6374349 (John McCall              2009-12-03 04:06:58 +0000 14559)     CXXConversionDecl *Conv = cast<CXXConversionDecl>(D);
38b2d3fa3e49a (Douglas Gregor           2011-07-23 18:59:35 +0000 14560)     if (!Conv->isExplicit()) {
38b2d3fa3e49a (Douglas Gregor           2011-07-23 18:59:35 +0000 14561)       // Strip the reference type (if any) and then the pointer type (if
38b2d3fa3e49a (Douglas Gregor           2011-07-23 18:59:35 +0000 14562)       // any) to get down to what might be a function type.
38b2d3fa3e49a (Douglas Gregor           2011-07-23 18:59:35 +0000 14563)       QualType ConvType = Conv->getConversionType().getNonReferenceType();
38b2d3fa3e49a (Douglas Gregor           2011-07-23 18:59:35 +0000 14564)       if (const PointerType *ConvPtrType = ConvType->getAs<PointerType>())
38b2d3fa3e49a (Douglas Gregor           2011-07-23 18:59:35 +0000 14565)         ConvType = ConvPtrType->getPointeeType();
38b2d3fa3e49a (Douglas Gregor           2011-07-23 18:59:35 +0000 14566) 
38b2d3fa3e49a (Douglas Gregor           2011-07-23 18:59:35 +0000 14567)       if (const FunctionProtoType *Proto = ConvType->getAs<FunctionProtoType>())
38b2d3fa3e49a (Douglas Gregor           2011-07-23 18:59:35 +0000 14568)       {
38b2d3fa3e49a (Douglas Gregor           2011-07-23 18:59:35 +0000 14569)         AddSurrogateCandidate(Conv, I.getPair(), ActingContext, Proto,
d3b75560aa07b (Dmitri Gribenko          2013-05-09 23:32:58 +0000 14570)                               Object.get(), Args, CandidateSet);
38b2d3fa3e49a (Douglas Gregor           2011-07-23 18:59:35 +0000 14571)       }
38b2d3fa3e49a (Douglas Gregor           2011-07-23 18:59:35 +0000 14572)     }
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000 14573)   }
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000 14574) 
635ed24e1dad8 (Abramo Bagnara           2011-10-05 07:56:41 +0000 14575)   bool HadMultipleCandidates = (CandidateSet.size() > 1);
635ed24e1dad8 (Abramo Bagnara           2011-10-05 07:56:41 +0000 14576) 
91cea0ad1e4cd (Douglas Gregor           2008-11-19 21:05:33 +0000 14577)   // Perform overload resolution.
91cea0ad1e4cd (Douglas Gregor           2008-11-19 21:05:33 +0000 14578)   OverloadCandidateSet::iterator Best;
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000 14579)   switch (CandidateSet.BestViableFunction(*this, Object.get()->getBeginLoc(),
67ef14fe486e1 (Richard Smith            2017-09-26 18:37:55 +0000 14580)                                           Best)) {
91cea0ad1e4cd (Douglas Gregor           2008-11-19 21:05:33 +0000 14581)   case OR_Success:
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000 14582)     // Overload resolution succeeded; we'll build the appropriate call
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000 14583)     // below.
91cea0ad1e4cd (Douglas Gregor           2008-11-19 21:05:33 +0000 14584)     break;
91cea0ad1e4cd (Douglas Gregor           2008-11-19 21:05:33 +0000 14585) 
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14586)   case OR_No_Viable_Function: {
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14587)     PartialDiagnostic PD =
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14588)         CandidateSet.empty()
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14589)             ? (PDiag(diag::err_ovl_no_oper)
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14590)                << Object.get()->getType() << /*call*/ 1
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14591)                << Object.get()->getSourceRange())
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14592)             : (PDiag(diag::err_ovl_no_viable_object_call)
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14593)                << Object.get()->getType() << Object.get()->getSourceRange());
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14594)     CandidateSet.NoteCandidates(
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14595)         PartialDiagnosticAt(Object.get()->getBeginLoc(), PD), *this,
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14596)         OCD_AllCandidates, Args);
91cea0ad1e4cd (Douglas Gregor           2008-11-19 21:05:33 +0000 14597)     break;
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14598)   }
91cea0ad1e4cd (Douglas Gregor           2008-11-19 21:05:33 +0000 14599)   case OR_Ambiguous:
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14600)     CandidateSet.NoteCandidates(
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14601)         PartialDiagnosticAt(Object.get()->getBeginLoc(),
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14602)                             PDiag(diag::err_ovl_ambiguous_object_call)
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14603)                                 << Object.get()->getType()
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14604)                                 << Object.get()->getSourceRange()),
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 14605)         *this, OCD_AmbiguousCandidates, Args);
91cea0ad1e4cd (Douglas Gregor           2008-11-19 21:05:33 +0000 14606)     break;
171c45ab0c19b (Douglas Gregor           2009-02-18 21:56:37 +0000 14607) 
171c45ab0c19b (Douglas Gregor           2009-02-18 21:56:37 +0000 14608)   case OR_Deleted:
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14609)     CandidateSet.NoteCandidates(
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14610)         PartialDiagnosticAt(Object.get()->getBeginLoc(),
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14611)                             PDiag(diag::err_ovl_deleted_object_call)
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14612)                                 << Object.get()->getType()
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14613)                                 << Object.get()->getSourceRange()),
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14614)         *this, OCD_AllCandidates, Args);
171c45ab0c19b (Douglas Gregor           2009-02-18 21:56:37 +0000 14615)     break;
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000 14616)   }
91cea0ad1e4cd (Douglas Gregor           2008-11-19 21:05:33 +0000 14617) 
b412e174db384 (Douglas Gregor           2010-07-25 18:17:45 +0000 14618)   if (Best == CandidateSet.end())
91cea0ad1e4cd (Douglas Gregor           2008-11-19 21:05:33 +0000 14619)     return true;
91cea0ad1e4cd (Douglas Gregor           2008-11-19 21:05:33 +0000 14620) 
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000 14621)   UnbridgedCasts.restore();
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000 14622) 
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000 14623)   if (Best->Function == nullptr) {
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000 14624)     // Since there is no function declaration, this is one of the
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000 14625)     // surrogate candidates. Dig out the conversion function.
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000 14626)     CXXConversionDecl *Conv
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000 14627)       = cast<CXXConversionDecl>(
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000 14628)                          Best->Conversions[0].UserDefined.ConversionFunction);
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000 14629) 
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000 14630)     CheckMemberOperatorAccess(LParenLoc, Object.get(), nullptr,
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000 14631)                               Best->FoundDecl);
22262abd78af0 (Richard Smith            2013-05-04 06:44:46 +0000 14632)     if (DiagnoseUseOfDecl(Best->FoundDecl, LParenLoc))
22262abd78af0 (Richard Smith            2013-05-04 06:44:46 +0000 14633)       return ExprError();
fb9662ae71a2d (Simon Pilgrim            2017-06-01 18:17:18 +0000 14634)     assert(Conv == Best->FoundDecl.getDecl() &&
d667641542527 (Faisal Vali              2013-06-15 11:54:37 +0000 14635)              "Found Decl & conversion-to-functionptr should be same, right?!");
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000 14636)     // We selected one of the surrogate functions that converts the
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000 14637)     // object parameter to a function pointer. Perform the conversion
255b85f03c5db (Richard Smith            2019-05-08 01:36:36 +0000 14638)     // on the object argument, then let BuildCallExpr finish the job.
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 14639) 
774cf79987ccd (Fariborz Jahanian        2009-09-28 18:35:46 +0000 14640)     // Create an implicit member expr to refer to the conversion operator.
78cfcb56a10e7 (Fariborz Jahanian        2009-09-28 23:23:40 +0000 14641)     // and then call it.
635ed24e1dad8 (Abramo Bagnara           2011-10-05 07:56:41 +0000 14642)     ExprResult Call = BuildCXXMemberCallExpr(Object.get(), Best->FoundDecl,
635ed24e1dad8 (Abramo Bagnara           2011-10-05 07:56:41 +0000 14643)                                              Conv, HadMultipleCandidates);
668443efb1db5 (Douglas Gregor           2011-01-20 00:18:04 +0000 14644)     if (Call.isInvalid())
668443efb1db5 (Douglas Gregor           2011-01-20 00:18:04 +0000 14645)       return ExprError();
b0cf297654585 (Abramo Bagnara           2011-11-16 22:46:05 +0000 14646)     // Record usage of conversion in an implicit cast.
f1cd6593da3ad (Serge Pavlov             2020-09-12 21:54:14 +0700 14647)     Call = ImplicitCastExpr::Create(
f1cd6593da3ad (Serge Pavlov             2020-09-12 21:54:14 +0700 14648)         Context, Call.get()->getType(), CK_UserDefinedConversion, Call.get(),
f1cd6593da3ad (Serge Pavlov             2020-09-12 21:54:14 +0700 14649)         nullptr, VK_RValue, CurFPFeatureOverrides());
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 14650) 
255b85f03c5db (Richard Smith            2019-05-08 01:36:36 +0000 14651)     return BuildCallExpr(S, Call.get(), LParenLoc, Args, RParenLoc);
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000 14652)   }
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000 14653) 
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000 14654)   CheckMemberOperatorAccess(LParenLoc, Object.get(), nullptr, Best->FoundDecl);
49ec2e694c6e4 (John McCall              2010-01-28 01:54:34 +0000 14655) 
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000 14656)   // We found an overloaded operator(). Build a CXXOperatorCallExpr
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000 14657)   // that calls this method, using Object for the implicit object
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000 14658)   // parameter and passing along the remaining arguments.
ab7897ac44769 (Douglas Gregor           2008-11-19 22:57:39 +0000 14659)   CXXMethodDecl *Method = cast<CXXMethodDecl>(Best->Function);
1fefe417f0ffd (Nico Weber               2012-11-09 06:06:14 +0000 14660) 
1fefe417f0ffd (Nico Weber               2012-11-09 06:06:14 +0000 14661)   // An error diagnostic has already been printed when parsing the declaration.
9512d3f161860 (Nico Weber               2012-11-09 08:38:04 +0000 14662)   if (Method->isInvalidDecl())
1fefe417f0ffd (Nico Weber               2012-11-09 06:06:14 +0000 14663)     return ExprError();
1fefe417f0ffd (Nico Weber               2012-11-09 06:06:14 +0000 14664) 
ab9dbc1d124cd (Simon Pilgrim            2020-01-14 14:15:51 +0000 14665)   const auto *Proto = Method->getType()->castAs<FunctionProtoType>();
b3fd5cfa81b83 (Alp Toker                2014-01-21 00:32:38 +0000 14666)   unsigned NumParams = Proto->getNumParams();
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000 14667) 
a2a299e586bf3 (Argyrios Kyrtzidis       2012-02-08 01:21:13 +0000 14668)   DeclarationNameInfo OpLocInfo(
a2a299e586bf3 (Argyrios Kyrtzidis       2012-02-08 01:21:13 +0000 14669)                Context.DeclarationNames.getCXXOperatorName(OO_Call), LParenLoc);
a2a299e586bf3 (Argyrios Kyrtzidis       2012-02-08 01:21:13 +0000 14670)   OpLocInfo.setCXXOperatorNameRange(SourceRange(LParenLoc, RParenLoc));
134af91b06493 (Nick Lewycky             2013-02-07 05:08:22 +0000 14671)   ExprResult NewFn = CreateFunctionRefExpr(*this, Method, Best->FoundDecl,
2246167362bf3 (Akira Hatanaka           2017-07-13 06:08:27 +0000 14672)                                            Obj, HadMultipleCandidates,
a2a299e586bf3 (Argyrios Kyrtzidis       2012-02-08 01:21:13 +0000 14673)                                            OpLocInfo.getLoc(),
a2a299e586bf3 (Argyrios Kyrtzidis       2012-02-08 01:21:13 +0000 14674)                                            OpLocInfo.getInfo());
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 14675)   if (NewFn.isInvalid())
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 14676)     return true;
91cea0ad1e4cd (Douglas Gregor           2008-11-19 21:05:33 +0000 14677) 
6ef089d21c885 (Bruno Ricci              2018-12-03 13:23:56 +0000 14678)   // The number of argument slots to allocate in the call. If we have default
6ef089d21c885 (Bruno Ricci              2018-12-03 13:23:56 +0000 14679)   // arguments we need to allocate space for them as well. We additionally
6ef089d21c885 (Bruno Ricci              2018-12-03 13:23:56 +0000 14680)   // need one more slot for the object parameter.
6ef089d21c885 (Bruno Ricci              2018-12-03 13:23:56 +0000 14681)   unsigned NumArgsSlots = 1 + std::max<unsigned>(Args.size(), NumParams);
6ef089d21c885 (Bruno Ricci              2018-12-03 13:23:56 +0000 14682) 
8b1a6bd8d05c3 (Benjamin Kramer          2013-09-25 13:10:11 +0000 14683)   // Build the full argument list for the method call (the implicit object
8b1a6bd8d05c3 (Benjamin Kramer          2013-09-25 13:10:11 +0000 14684)   // parameter is placed at the beginning of the list).
6ef089d21c885 (Bruno Ricci              2018-12-03 13:23:56 +0000 14685)   SmallVector<Expr *, 8> MethodArgs(NumArgsSlots);
02a0acd0bc3e2 (Douglas Gregor           2009-01-13 05:10:00 +0000 14686) 
a8a7d0f371619 (Chris Lattner            2009-04-12 08:11:20 +0000 14687)   bool IsError = false;
a8a7d0f371619 (Chris Lattner            2009-04-12 08:11:20 +0000 14688) 
91cea0ad1e4cd (Douglas Gregor           2008-11-19 21:05:33 +0000 14689)   // Initialize the implicit object parameter.
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 14690)   ExprResult ObjRes =
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000 14691)     PerformObjectArgumentInitialization(Object.get(), /*Qualifier=*/nullptr,
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 14692)                                         Best->FoundDecl, Method);
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 14693)   if (ObjRes.isInvalid())
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 14694)     IsError = true;
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 14695)   else
62b95d88dc14f (Benjamin Kramer          2012-08-23 21:35:17 +0000 14696)     Object = ObjRes;
6ef089d21c885 (Bruno Ricci              2018-12-03 13:23:56 +0000 14697)   MethodArgs[0] = Object.get();
a8a7d0f371619 (Chris Lattner            2009-04-12 08:11:20 +0000 14698) 
91cea0ad1e4cd (Douglas Gregor           2008-11-19 21:05:33 +0000 14699)   // Check the argument types.
b3fd5cfa81b83 (Alp Toker                2014-01-21 00:32:38 +0000 14700)   for (unsigned i = 0; i != NumParams; i++) {
91cea0ad1e4cd (Douglas Gregor           2008-11-19 21:05:33 +0000 14701)     Expr *Arg;
d3b75560aa07b (Dmitri Gribenko          2013-05-09 23:32:58 +0000 14702)     if (i < Args.size()) {
91cea0ad1e4cd (Douglas Gregor           2008-11-19 21:05:33 +0000 14703)       Arg = Args[i];
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000 14704) 
02a0acd0bc3e2 (Douglas Gregor           2009-01-13 05:10:00 +0000 14705)       // Pass the argument.
7c5fe48060c0d (Anders Carlsson          2010-01-29 18:43:53 +0000 14706) 
dadc575b1e878 (John McCall              2010-08-24 06:29:42 +0000 14707)       ExprResult InputInit
7c5fe48060c0d (Anders Carlsson          2010-01-29 18:43:53 +0000 14708)         = PerformCopyInitialization(InitializedEntity::InitializeParameter(
8fb87aec78b52 (Fariborz Jahanian        2010-09-24 17:30:16 +0000 14709)                                                     Context,
7c5fe48060c0d (Anders Carlsson          2010-01-29 18:43:53 +0000 14710)                                                     Method->getParamDecl(i)),
b268a282a4f19 (John McCall              2010-08-23 23:25:46 +0000 14711)                                     SourceLocation(), Arg);
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 14712) 
7c5fe48060c0d (Anders Carlsson          2010-01-29 18:43:53 +0000 14713)       IsError |= InputInit.isInvalid();
01a7598561561 (Nikola Smiljanic         2014-05-29 10:55:11 +0000 14714)       Arg = InputInit.getAs<Expr>();
02a0acd0bc3e2 (Douglas Gregor           2009-01-13 05:10:00 +0000 14715)     } else {
dadc575b1e878 (John McCall              2010-08-24 06:29:42 +0000 14716)       ExprResult DefArg
1bc688dc6029f (Douglas Gregor           2009-11-09 19:27:57 +0000 14717)         = BuildCXXDefaultArgExpr(LParenLoc, Method, Method->getParamDecl(i));
1bc688dc6029f (Douglas Gregor           2009-11-09 19:27:57 +0000 14718)       if (DefArg.isInvalid()) {
1bc688dc6029f (Douglas Gregor           2009-11-09 19:27:57 +0000 14719)         IsError = true;
1bc688dc6029f (Douglas Gregor           2009-11-09 19:27:57 +0000 14720)         break;
1bc688dc6029f (Douglas Gregor           2009-11-09 19:27:57 +0000 14721)       }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 14722) 
01a7598561561 (Nikola Smiljanic         2014-05-29 10:55:11 +0000 14723)       Arg = DefArg.getAs<Expr>();
02a0acd0bc3e2 (Douglas Gregor           2009-01-13 05:10:00 +0000 14724)     }
91cea0ad1e4cd (Douglas Gregor           2008-11-19 21:05:33 +0000 14725) 
6ef089d21c885 (Bruno Ricci              2018-12-03 13:23:56 +0000 14726)     MethodArgs[i + 1] = Arg;
91cea0ad1e4cd (Douglas Gregor           2008-11-19 21:05:33 +0000 14727)   }
91cea0ad1e4cd (Douglas Gregor           2008-11-19 21:05:33 +0000 14728) 
91cea0ad1e4cd (Douglas Gregor           2008-11-19 21:05:33 +0000 14729)   // If this is a variadic call, handle args passed through "...".
91cea0ad1e4cd (Douglas Gregor           2008-11-19 21:05:33 +0000 14730)   if (Proto->isVariadic()) {
91cea0ad1e4cd (Douglas Gregor           2008-11-19 21:05:33 +0000 14731)     // Promote the arguments (C99 6.5.2.2p7).
b3fd5cfa81b83 (Alp Toker                2014-01-21 00:32:38 +0000 14732)     for (unsigned i = NumParams, e = Args.size(); i < e; i++) {
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000 14733)       ExprResult Arg = DefaultVariadicArgumentPromotion(Args[i], VariadicMethod,
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000 14734)                                                         nullptr);
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 14735)       IsError |= Arg.isInvalid();
6ef089d21c885 (Bruno Ricci              2018-12-03 13:23:56 +0000 14736)       MethodArgs[i + 1] = Arg.get();
91cea0ad1e4cd (Douglas Gregor           2008-11-19 21:05:33 +0000 14737)     }
91cea0ad1e4cd (Douglas Gregor           2008-11-19 21:05:33 +0000 14738)   }
91cea0ad1e4cd (Douglas Gregor           2008-11-19 21:05:33 +0000 14739) 
6ef089d21c885 (Bruno Ricci              2018-12-03 13:23:56 +0000 14740)   if (IsError)
6ef089d21c885 (Bruno Ricci              2018-12-03 13:23:56 +0000 14741)     return true;
a8a7d0f371619 (Chris Lattner            2009-04-12 08:11:20 +0000 14742) 
d3b75560aa07b (Dmitri Gribenko          2013-05-09 23:32:58 +0000 14743)   DiagnoseSentinelCalls(Method, LParenLoc, Args);
ff4b407009962 (Eli Friedman             2012-02-18 04:48:30 +0000 14744) 
6ef089d21c885 (Bruno Ricci              2018-12-03 13:23:56 +0000 14745)   // Once we've built TheCall, all of the expressions are properly owned.
6ef089d21c885 (Bruno Ricci              2018-12-03 13:23:56 +0000 14746)   QualType ResultTy = Method->getReturnType();
6ef089d21c885 (Bruno Ricci              2018-12-03 13:23:56 +0000 14747)   ExprValueKind VK = Expr::getValueKindForType(ResultTy);
6ef089d21c885 (Bruno Ricci              2018-12-03 13:23:56 +0000 14748)   ResultTy = ResultTy.getNonLValueExprType(Context);
6ef089d21c885 (Bruno Ricci              2018-12-03 13:23:56 +0000 14749) 
f4aaed3bf16b3 (Melanie Blower           2020-06-26 09:23:45 -0700 14750)   CXXOperatorCallExpr *TheCall = CXXOperatorCallExpr::Create(
f4aaed3bf16b3 (Melanie Blower           2020-06-26 09:23:45 -0700 14751)       Context, OO_Call, NewFn.get(), MethodArgs, ResultTy, VK, RParenLoc,
f4aaed3bf16b3 (Melanie Blower           2020-06-26 09:23:45 -0700 14752)       CurFPFeatureOverrides());
6ef089d21c885 (Bruno Ricci              2018-12-03 13:23:56 +0000 14753) 
6ef089d21c885 (Bruno Ricci              2018-12-03 13:23:56 +0000 14754)   if (CheckCallReturnType(Method->getReturnType(), LParenLoc, TheCall, Method))
6ef089d21c885 (Bruno Ricci              2018-12-03 13:23:56 +0000 14755)     return true;
6ef089d21c885 (Bruno Ricci              2018-12-03 13:23:56 +0000 14756) 
55ce352d4d011 (Richard Smith            2012-06-25 20:30:08 +0000 14757)   if (CheckFunctionCall(Method, TheCall, Proto))
bc4c1078365b6 (Anders Carlsson          2009-08-16 01:56:34 +0000 14758)     return true;
bc4c1078365b6 (Anders Carlsson          2009-08-16 01:56:34 +0000 14759) 
008e7bf92343b (Tyker                    2020-02-04 19:23:33 +0100 14760)   return CheckForImmediateInvocation(MaybeBindToTemporary(TheCall), Method);
91cea0ad1e4cd (Douglas Gregor           2008-11-19 21:05:33 +0000 14761) }
91cea0ad1e4cd (Douglas Gregor           2008-11-19 21:05:33 +0000 14762) 
e0e79bdef62a5 (Douglas Gregor           2008-11-20 16:27:02 +0000 14763) /// BuildOverloadedArrowExpr - Build a call to an overloaded @c operator->
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000 14764) ///  (if one exists), where @c Base is an expression of class type and
e0e79bdef62a5 (Douglas Gregor           2008-11-20 16:27:02 +0000 14765) /// @c Member is the name of the member we're trying to find.
dadc575b1e878 (John McCall              2010-08-24 06:29:42 +0000 14766) ExprResult
0c51de4ab1ae1 (Kaelyn Uhrain            2013-07-31 17:38:24 +0000 14767) Sema::BuildOverloadedArrowExpr(Scope *S, Expr *Base, SourceLocation OpLoc,
0c51de4ab1ae1 (Kaelyn Uhrain            2013-07-31 17:38:24 +0000 14768)                                bool *NoArrowOperatorFound) {
8e543b3d46932 (Chandler Carruth         2010-12-12 08:17:55 +0000 14769)   assert(Base->getType()->isRecordType() &&
8e543b3d46932 (Chandler Carruth         2010-12-12 08:17:55 +0000 14770)          "left-hand side must have class type");
11289f4280768 (Mike Stump               2009-09-09 15:08:12 +0000 14771) 
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000 14772)   if (checkPlaceholderForOverload(*this, Base))
4124c4924d634 (John McCall              2011-10-17 18:40:02 +0000 14773)     return ExprError();
e26a872b02740 (John McCall              2010-12-04 08:14:53 +0000 14774) 
bc077cf5897af (John McCall              2010-02-08 23:07:23 +0000 14775)   SourceLocation Loc = Base->getExprLoc();
bc077cf5897af (John McCall              2010-02-08 23:07:23 +0000 14776) 
e0e79bdef62a5 (Douglas Gregor           2008-11-20 16:27:02 +0000 14777)   // C++ [over.ref]p1:
e0e79bdef62a5 (Douglas Gregor           2008-11-20 16:27:02 +0000 14778)   //
e0e79bdef62a5 (Douglas Gregor           2008-11-20 16:27:02 +0000 14779)   //   [...] An expression x->m is interpreted as (x.operator->())->m
e0e79bdef62a5 (Douglas Gregor           2008-11-20 16:27:02 +0000 14780)   //   for a class object x of type T if T::operator->() exists and if
e0e79bdef62a5 (Douglas Gregor           2008-11-20 16:27:02 +0000 14781)   //   the operator is selected as the best match function by the
e0e79bdef62a5 (Douglas Gregor           2008-11-20 16:27:02 +0000 14782)   //   overload resolution mechanism (13.3).
8e543b3d46932 (Chandler Carruth         2010-12-12 08:17:55 +0000 14783)   DeclarationName OpName =
8e543b3d46932 (Chandler Carruth         2010-12-12 08:17:55 +0000 14784)     Context.DeclarationNames.getCXXOperatorName(OO_Arrow);
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000 14785)   OverloadCandidateSet CandidateSet(Loc, OverloadCandidateSet::CSK_Operator);
d806156d54595 (Douglas Gregor           2009-08-06 03:17:00 +0000 14786) 
bc077cf5897af (John McCall              2010-02-08 23:07:23 +0000 14787)   if (RequireCompleteType(Loc, Base->getType(),
7bfb2d026ec99 (Douglas Gregor           2012-05-04 16:32:21 +0000 14788)                           diag::err_typecheck_incomplete_tag, Base))
132e70bfa4352 (Eli Friedman             2009-11-18 01:28:03 +0000 14789)     return ExprError();
132e70bfa4352 (Eli Friedman             2009-11-18 01:28:03 +0000 14790) 
27b18f8144b7c (John McCall              2009-11-17 02:14:36 +0000 14791)   LookupResult R(*this, OpName, OpLoc, LookupOrdinaryName);
ab9dbc1d124cd (Simon Pilgrim            2020-01-14 14:15:51 +0000 14792)   LookupQualifiedName(R, Base->getType()->castAs<RecordType>()->getDecl());
27b18f8144b7c (John McCall              2009-11-17 02:14:36 +0000 14793)   R.suppressDiagnostics();
78b549399413c (Anders Carlsson          2009-09-10 23:18:36 +0000 14794) 
78b549399413c (Anders Carlsson          2009-09-10 23:18:36 +0000 14795)   for (LookupResult::iterator Oper = R.begin(), OperEnd = R.end();
6e9f8f6374349 (John McCall              2009-12-03 04:06:58 +0000 14796)        Oper != OperEnd; ++Oper) {
0282432039ab9 (Douglas Gregor           2011-01-26 19:30:28 +0000 14797)     AddMethodCandidate(Oper.getPair(), Base->getType(), Base->Classify(Context),
49a3ad21d6034 (Rui Ueyama               2019-07-16 04:46:31 +0000 14798)                        None, CandidateSet, /*SuppressUserConversion=*/false);
6e9f8f6374349 (John McCall              2009-12-03 04:06:58 +0000 14799)   }
e0e79bdef62a5 (Douglas Gregor           2008-11-20 16:27:02 +0000 14800) 
635ed24e1dad8 (Abramo Bagnara           2011-10-05 07:56:41 +0000 14801)   bool HadMultipleCandidates = (CandidateSet.size() > 1);
635ed24e1dad8 (Abramo Bagnara           2011-10-05 07:56:41 +0000 14802) 
e0e79bdef62a5 (Douglas Gregor           2008-11-20 16:27:02 +0000 14803)   // Perform overload resolution.
e0e79bdef62a5 (Douglas Gregor           2008-11-20 16:27:02 +0000 14804)   OverloadCandidateSet::iterator Best;
5c32be0053403 (John McCall              2010-08-24 20:38:10 +0000 14805)   switch (CandidateSet.BestViableFunction(*this, OpLoc, Best)) {
e0e79bdef62a5 (Douglas Gregor           2008-11-20 16:27:02 +0000 14806)   case OR_Success:
e0e79bdef62a5 (Douglas Gregor           2008-11-20 16:27:02 +0000 14807)     // Overload resolution succeeded; we'll build the call below.
e0e79bdef62a5 (Douglas Gregor           2008-11-20 16:27:02 +0000 14808)     break;
e0e79bdef62a5 (Douglas Gregor           2008-11-20 16:27:02 +0000 14809) 
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14810)   case OR_No_Viable_Function: {
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14811)     auto Cands = CandidateSet.CompleteCandidates(*this, OCD_AllCandidates, Base);
1bb5dbf628889 (Kaelyn Uhrain            2013-07-11 22:38:30 +0000 14812)     if (CandidateSet.empty()) {
1bb5dbf628889 (Kaelyn Uhrain            2013-07-11 22:38:30 +0000 14813)       QualType BaseType = Base->getType();
0c51de4ab1ae1 (Kaelyn Uhrain            2013-07-31 17:38:24 +0000 14814)       if (NoArrowOperatorFound) {
0c51de4ab1ae1 (Kaelyn Uhrain            2013-07-31 17:38:24 +0000 14815)         // Report this specific error to the caller instead of emitting a
0c51de4ab1ae1 (Kaelyn Uhrain            2013-07-31 17:38:24 +0000 14816)         // diagnostic, as requested.
0c51de4ab1ae1 (Kaelyn Uhrain            2013-07-31 17:38:24 +0000 14817)         *NoArrowOperatorFound = true;
0c51de4ab1ae1 (Kaelyn Uhrain            2013-07-31 17:38:24 +0000 14818)         return ExprError();
0c51de4ab1ae1 (Kaelyn Uhrain            2013-07-31 17:38:24 +0000 14819)       }
bad7fb09b2d16 (Kaelyn Uhrain            2013-07-15 19:54:54 +0000 14820)       Diag(OpLoc, diag::err_typecheck_member_reference_arrow)
bad7fb09b2d16 (Kaelyn Uhrain            2013-07-15 19:54:54 +0000 14821)         << BaseType << Base->getSourceRange();
1bb5dbf628889 (Kaelyn Uhrain            2013-07-11 22:38:30 +0000 14822)       if (BaseType->isRecordType() && !BaseType->isPointerType()) {
bad7fb09b2d16 (Kaelyn Uhrain            2013-07-15 19:54:54 +0000 14823)         Diag(OpLoc, diag::note_typecheck_member_reference_suggestion)
1bb5dbf628889 (Kaelyn Uhrain            2013-07-11 22:38:30 +0000 14824)           << FixItHint::CreateReplacement(OpLoc, ".");
1bb5dbf628889 (Kaelyn Uhrain            2013-07-11 22:38:30 +0000 14825)       }
1bb5dbf628889 (Kaelyn Uhrain            2013-07-11 22:38:30 +0000 14826)     } else
e0e79bdef62a5 (Douglas Gregor           2008-11-20 16:27:02 +0000 14827)       Diag(OpLoc, diag::err_ovl_no_viable_oper)
d806156d54595 (Douglas Gregor           2009-08-06 03:17:00 +0000 14828)         << "operator->" << Base->getSourceRange();
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14829)     CandidateSet.NoteCandidates(*this, Base, Cands);
d806156d54595 (Douglas Gregor           2009-08-06 03:17:00 +0000 14830)     return ExprError();
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14831)   }
e0e79bdef62a5 (Douglas Gregor           2008-11-20 16:27:02 +0000 14832)   case OR_Ambiguous:
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14833)     CandidateSet.NoteCandidates(
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14834)         PartialDiagnosticAt(OpLoc, PDiag(diag::err_ovl_ambiguous_oper_unary)
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14835)                                        << "->" << Base->getType()
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14836)                                        << Base->getSourceRange()),
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 14837)         *this, OCD_AmbiguousCandidates, Base);
d806156d54595 (Douglas Gregor           2009-08-06 03:17:00 +0000 14838)     return ExprError();
171c45ab0c19b (Douglas Gregor           2009-02-18 21:56:37 +0000 14839) 
171c45ab0c19b (Douglas Gregor           2009-02-18 21:56:37 +0000 14840)   case OR_Deleted:
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14841)     CandidateSet.NoteCandidates(
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14842)         PartialDiagnosticAt(OpLoc, PDiag(diag::err_ovl_deleted_oper)
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14843)                                        << "->" << Base->getSourceRange()),
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14844)         *this, OCD_AllCandidates, Base);
d806156d54595 (Douglas Gregor           2009-08-06 03:17:00 +0000 14845)     return ExprError();
e0e79bdef62a5 (Douglas Gregor           2008-11-20 16:27:02 +0000 14846)   }
e0e79bdef62a5 (Douglas Gregor           2008-11-20 16:27:02 +0000 14847) 
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000 14848)   CheckMemberOperatorAccess(OpLoc, Base, nullptr, Best->FoundDecl);
a0296f7987c0a (John McCall              2010-03-19 07:35:19 +0000 14849) 
e0e79bdef62a5 (Douglas Gregor           2008-11-20 16:27:02 +0000 14850)   // Convert the object parameter.
e0e79bdef62a5 (Douglas Gregor           2008-11-20 16:27:02 +0000 14851)   CXXMethodDecl *Method = cast<CXXMethodDecl>(Best->Function);
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 14852)   ExprResult BaseResult =
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000 14853)     PerformObjectArgumentInitialization(Base, /*Qualifier=*/nullptr,
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 14854)                                         Best->FoundDecl, Method);
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 14855)   if (BaseResult.isInvalid())
d806156d54595 (Douglas Gregor           2009-08-06 03:17:00 +0000 14856)     return ExprError();
01a7598561561 (Nikola Smiljanic         2014-05-29 10:55:11 +0000 14857)   Base = BaseResult.get();
9ecea26443d3f (Douglas Gregor           2008-11-21 03:04:22 +0000 14858) 
e0e79bdef62a5 (Douglas Gregor           2008-11-20 16:27:02 +0000 14859)   // Build the operator call.
134af91b06493 (Nick Lewycky             2013-02-07 05:08:22 +0000 14860)   ExprResult FnExpr = CreateFunctionRefExpr(*this, Method, Best->FoundDecl,
2246167362bf3 (Akira Hatanaka           2017-07-13 06:08:27 +0000 14861)                                             Base, HadMultipleCandidates, OpLoc);
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 14862)   if (FnExpr.isInvalid())
0129629fd34a8 (John Wiegley             2011-04-08 18:41:53 +0000 14863)     return ExprError();
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 14864) 
314cc81b8caac (Alp Toker                2014-01-25 16:55:45 +0000 14865)   QualType ResultTy = Method->getReturnType();
7decc9e4ea6c5 (John McCall              2010-11-18 06:31:45 +0000 14866)   ExprValueKind VK = Expr::getValueKindForType(ResultTy);
7decc9e4ea6c5 (John McCall              2010-11-18 06:31:45 +0000 14867)   ResultTy = ResultTy.getNonLValueExprType(Context);
f4aaed3bf16b3 (Melanie Blower           2020-06-26 09:23:45 -0700 14868)   CXXOperatorCallExpr *TheCall =
f4aaed3bf16b3 (Melanie Blower           2020-06-26 09:23:45 -0700 14869)       CXXOperatorCallExpr::Create(Context, OO_Arrow, FnExpr.get(), Base,
f4aaed3bf16b3 (Melanie Blower           2020-06-26 09:23:45 -0700 14870)                                   ResultTy, VK, OpLoc, CurFPFeatureOverrides());
e4f4b5e919adc (Anders Carlsson          2009-10-13 22:43:21 +0000 14871) 
314cc81b8caac (Alp Toker                2014-01-25 16:55:45 +0000 14872)   if (CheckCallReturnType(Method->getReturnType(), OpLoc, TheCall, Method))
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000 14873)     return ExprError();
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000 14874) 
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000 14875)   if (CheckFunctionCall(Method, TheCall,
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000 14876)                         Method->getType()->castAs<FunctionProtoType>()))
ce6284b17984a (George Burgess IV        2017-01-28 02:19:40 +0000 14877)     return ExprError();
2d9c47ea6cd3a (Eli Friedman             2011-04-04 01:18:25 +0000 14878) 
2d9c47ea6cd3a (Eli Friedman             2011-04-04 01:18:25 +0000 14879)   return MaybeBindToTemporary(TheCall);
e0e79bdef62a5 (Douglas Gregor           2008-11-20 16:27:02 +0000 14880) }
e0e79bdef62a5 (Douglas Gregor           2008-11-20 16:27:02 +0000 14881) 
bcc22fc4e1b2c (Richard Smith            2012-03-09 08:00:36 +0000 14882) /// BuildLiteralOperatorCall - Build a UserDefinedLiteral by creating a call to
bcc22fc4e1b2c (Richard Smith            2012-03-09 08:00:36 +0000 14883) /// a literal operator described by the provided lookup results.
bcc22fc4e1b2c (Richard Smith            2012-03-09 08:00:36 +0000 14884) ExprResult Sema::BuildLiteralOperatorCall(LookupResult &R,
bcc22fc4e1b2c (Richard Smith            2012-03-09 08:00:36 +0000 14885)                                           DeclarationNameInfo &SuffixInfo,
bcc22fc4e1b2c (Richard Smith            2012-03-09 08:00:36 +0000 14886)                                           ArrayRef<Expr*> Args,
bcc22fc4e1b2c (Richard Smith            2012-03-09 08:00:36 +0000 14887)                                           SourceLocation LitEndLoc,
bcc22fc4e1b2c (Richard Smith            2012-03-09 08:00:36 +0000 14888)                                        TemplateArgumentListInfo *TemplateArgs) {
bcc22fc4e1b2c (Richard Smith            2012-03-09 08:00:36 +0000 14889)   SourceLocation UDSuffixLoc = SuffixInfo.getCXXLiteralOperatorNameLoc();
c67fdd4eb95f1 (Richard Smith            2012-03-07 08:35:16 +0000 14890) 
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000 14891)   OverloadCandidateSet CandidateSet(UDSuffixLoc,
100b24abc5a08 (Richard Smith            2014-04-17 01:52:14 +0000 14892)                                     OverloadCandidateSet::CSK_Normal);
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 14893)   AddNonMemberOperatorCandidates(R.asUnresolvedSet(), Args, CandidateSet,
974c8b7e2fde5 (Richard Smith            2019-10-19 00:04:43 +0000 14894)                                  TemplateArgs);
c67fdd4eb95f1 (Richard Smith            2012-03-07 08:35:16 +0000 14895) 
bcc22fc4e1b2c (Richard Smith            2012-03-09 08:00:36 +0000 14896)   bool HadMultipleCandidates = (CandidateSet.size() > 1);
bcc22fc4e1b2c (Richard Smith            2012-03-09 08:00:36 +0000 14897) 
bcc22fc4e1b2c (Richard Smith            2012-03-09 08:00:36 +0000 14898)   // Perform overload resolution. This will usually be trivial, but might need
bcc22fc4e1b2c (Richard Smith            2012-03-09 08:00:36 +0000 14899)   // to perform substitutions for a literal operator template.
bcc22fc4e1b2c (Richard Smith            2012-03-09 08:00:36 +0000 14900)   OverloadCandidateSet::iterator Best;
bcc22fc4e1b2c (Richard Smith            2012-03-09 08:00:36 +0000 14901)   switch (CandidateSet.BestViableFunction(*this, UDSuffixLoc, Best)) {
bcc22fc4e1b2c (Richard Smith            2012-03-09 08:00:36 +0000 14902)   case OR_Success:
bcc22fc4e1b2c (Richard Smith            2012-03-09 08:00:36 +0000 14903)   case OR_Deleted:
bcc22fc4e1b2c (Richard Smith            2012-03-09 08:00:36 +0000 14904)     break;
bcc22fc4e1b2c (Richard Smith            2012-03-09 08:00:36 +0000 14905) 
bcc22fc4e1b2c (Richard Smith            2012-03-09 08:00:36 +0000 14906)   case OR_No_Viable_Function:
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14907)     CandidateSet.NoteCandidates(
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14908)         PartialDiagnosticAt(UDSuffixLoc,
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14909)                             PDiag(diag::err_ovl_no_viable_function_in_call)
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14910)                                 << R.getLookupName()),
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14911)         *this, OCD_AllCandidates, Args);
bcc22fc4e1b2c (Richard Smith            2012-03-09 08:00:36 +0000 14912)     return ExprError();
bcc22fc4e1b2c (Richard Smith            2012-03-09 08:00:36 +0000 14913) 
bcc22fc4e1b2c (Richard Smith            2012-03-09 08:00:36 +0000 14914)   case OR_Ambiguous:
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14915)     CandidateSet.NoteCandidates(
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14916)         PartialDiagnosticAt(R.getNameLoc(), PDiag(diag::err_ovl_ambiguous_call)
5e328050503c5 (David Blaikie            2019-05-03 00:44:50 +0000 14917)                                                 << R.getLookupName()),
70f59b5bbc84d (Richard Smith            2019-10-23 17:54:10 -0700 14918)         *this, OCD_AmbiguousCandidates, Args);
bcc22fc4e1b2c (Richard Smith            2012-03-09 08:00:36 +0000 14919)     return ExprError();
c67fdd4eb95f1 (Richard Smith            2012-03-07 08:35:16 +0000 14920)   }
c67fdd4eb95f1 (Richard Smith            2012-03-07 08:35:16 +0000 14921) 
bcc22fc4e1b2c (Richard Smith            2012-03-09 08:00:36 +0000 14922)   FunctionDecl *FD = Best->Function;
134af91b06493 (Nick Lewycky             2013-02-07 05:08:22 +0000 14923)   ExprResult Fn = CreateFunctionRefExpr(*this, FD, Best->FoundDecl,
2246167362bf3 (Akira Hatanaka           2017-07-13 06:08:27 +0000 14924)                                         nullptr, HadMultipleCandidates,
bcc22fc4e1b2c (Richard Smith            2012-03-09 08:00:36 +0000 14925)                                         SuffixInfo.getLoc(),
bcc22fc4e1b2c (Richard Smith            2012-03-09 08:00:36 +0000 14926)                                         SuffixInfo.getInfo());
bcc22fc4e1b2c (Richard Smith            2012-03-09 08:00:36 +0000 14927)   if (Fn.isInvalid())
bcc22fc4e1b2c (Richard Smith            2012-03-09 08:00:36 +0000 14928)     return true;
c67fdd4eb95f1 (Richard Smith            2012-03-07 08:35:16 +0000 14929) 
c67fdd4eb95f1 (Richard Smith            2012-03-07 08:35:16 +0000 14930)   // Check the argument types. This should almost always be a no-op, except
c67fdd4eb95f1 (Richard Smith            2012-03-07 08:35:16 +0000 14931)   // that array-to-pointer decay is applied to string literals.
c67fdd4eb95f1 (Richard Smith            2012-03-07 08:35:16 +0000 14932)   Expr *ConvArgs[2];
e54c307bb4ed9 (Richard Smith            2013-05-05 15:51:06 +0000 14933)   for (unsigned ArgIdx = 0, N = Args.size(); ArgIdx != N; ++ArgIdx) {
c67fdd4eb95f1 (Richard Smith            2012-03-07 08:35:16 +0000 14934)     ExprResult InputInit = PerformCopyInitialization(
c67fdd4eb95f1 (Richard Smith            2012-03-07 08:35:16 +0000 14935)       InitializedEntity::InitializeParameter(Context, FD->getParamDecl(ArgIdx)),
c67fdd4eb95f1 (Richard Smith            2012-03-07 08:35:16 +0000 14936)       SourceLocation(), Args[ArgIdx]);
c67fdd4eb95f1 (Richard Smith            2012-03-07 08:35:16 +0000 14937)     if (InputInit.isInvalid())
c67fdd4eb95f1 (Richard Smith            2012-03-07 08:35:16 +0000 14938)       return true;
01a7598561561 (Nikola Smiljanic         2014-05-29 10:55:11 +0000 14939)     ConvArgs[ArgIdx] = InputInit.get();
c67fdd4eb95f1 (Richard Smith            2012-03-07 08:35:16 +0000 14940)   }
c67fdd4eb95f1 (Richard Smith            2012-03-07 08:35:16 +0000 14941) 
314cc81b8caac (Alp Toker                2014-01-25 16:55:45 +0000 14942)   QualType ResultTy = FD->getReturnType();
c67fdd4eb95f1 (Richard Smith            2012-03-07 08:35:16 +0000 14943)   ExprValueKind VK = Expr::getValueKindForType(ResultTy);
c67fdd4eb95f1 (Richard Smith            2012-03-07 08:35:16 +0000 14944)   ResultTy = ResultTy.getNonLValueExprType(Context);
c67fdd4eb95f1 (Richard Smith            2012-03-07 08:35:16 +0000 14945) 
c5885cffc5206 (Bruno Ricci              2018-12-21 15:20:32 +0000 14946)   UserDefinedLiteral *UDL = UserDefinedLiteral::Create(
c5885cffc5206 (Bruno Ricci              2018-12-21 15:20:32 +0000 14947)       Context, Fn.get(), llvm::makeArrayRef(ConvArgs, Args.size()), ResultTy,
70e7aa4a4ed36 (Serge Pavlov             2020-07-24 12:04:19 +0700 14948)       VK, LitEndLoc, UDSuffixLoc, CurFPFeatureOverrides());
c67fdd4eb95f1 (Richard Smith            2012-03-07 08:35:16 +0000 14949) 
314cc81b8caac (Alp Toker                2014-01-25 16:55:45 +0000 14950)   if (CheckCallReturnType(FD->getReturnType(), UDSuffixLoc, UDL, FD))
c67fdd4eb95f1 (Richard Smith            2012-03-07 08:35:16 +0000 14951)     return ExprError();
c67fdd4eb95f1 (Richard Smith            2012-03-07 08:35:16 +0000 14952) 
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000 14953)   if (CheckFunctionCall(FD, UDL, nullptr))
c67fdd4eb95f1 (Richard Smith            2012-03-07 08:35:16 +0000 14954)     return ExprError();
c67fdd4eb95f1 (Richard Smith            2012-03-07 08:35:16 +0000 14955) 
008e7bf92343b (Tyker                    2020-02-04 19:23:33 +0100 14956)   return CheckForImmediateInvocation(MaybeBindToTemporary(UDL), FD);
c67fdd4eb95f1 (Richard Smith            2012-03-07 08:35:16 +0000 14957) }
c67fdd4eb95f1 (Richard Smith            2012-03-07 08:35:16 +0000 14958) 
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 14959) /// Build a call to 'begin' or 'end' for a C++11 for-range statement. If the
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 14960) /// given LookupResult is non-empty, it is assumed to describe a member which
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 14961) /// will be invoked. Otherwise, the function will be found via argument
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 14962) /// dependent lookup.
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 14963) /// CallExpr is set to a valid expression and FRS_Success returned on success,
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 14964) /// otherwise CallExpr is set to ExprError() and some non-success value
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 14965) /// is returned.
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 14966) Sema::ForRangeStatus
9f690bd80bb67 (Richard Smith            2015-10-27 06:02:45 +0000 14967) Sema::BuildForRangeBeginEndCall(SourceLocation Loc,
9f690bd80bb67 (Richard Smith            2015-10-27 06:02:45 +0000 14968)                                 SourceLocation RangeLoc,
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 14969)                                 const DeclarationNameInfo &NameInfo,
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 14970)                                 LookupResult &MemberLookup,
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 14971)                                 OverloadCandidateSet *CandidateSet,
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 14972)                                 Expr *Range, ExprResult *CallExpr) {
9f690bd80bb67 (Richard Smith            2015-10-27 06:02:45 +0000 14973)   Scope *S = nullptr;
9f690bd80bb67 (Richard Smith            2015-10-27 06:02:45 +0000 14974) 
67ef14fe486e1 (Richard Smith            2017-09-26 18:37:55 +0000 14975)   CandidateSet->clear(OverloadCandidateSet::CSK_Normal);
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 14976)   if (!MemberLookup.empty()) {
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 14977)     ExprResult MemberRef =
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 14978)         BuildMemberReferenceExpr(Range, Range->getType(), Loc,
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 14979)                                  /*IsPtr=*/false, CXXScopeSpec(),
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 14980)                                  /*TemplateKWLoc=*/SourceLocation(),
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000 14981)                                  /*FirstQualifierInScope=*/nullptr,
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 14982)                                  MemberLookup,
6924dcdf6f737 (Aaron Ballman            2015-09-01 14:49:24 +0000 14983)                                  /*TemplateArgs=*/nullptr, S);
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 14984)     if (MemberRef.isInvalid()) {
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 14985)       *CallExpr = ExprError();
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 14986)       return FRS_DiagnosticIssued;
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 14987)     }
255b85f03c5db (Richard Smith            2019-05-08 01:36:36 +0000 14988)     *CallExpr = BuildCallExpr(S, MemberRef.get(), Loc, None, Loc, nullptr);
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 14989)     if (CallExpr->isInvalid()) {
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 14990)       *CallExpr = ExprError();
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 14991)       return FRS_DiagnosticIssued;
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 14992)     }
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 14993)   } else {
ed5a18fc0399d (Richard Smith            2020-08-06 15:57:35 -0700 14994)     ExprResult FnR = CreateUnresolvedLookupExpr(/*NamingClass=*/nullptr,
ed5a18fc0399d (Richard Smith            2020-08-06 15:57:35 -0700 14995)                                                 NestedNameSpecifierLoc(),
ed5a18fc0399d (Richard Smith            2020-08-06 15:57:35 -0700 14996)                                                 NameInfo, UnresolvedSet<0>());
ed5a18fc0399d (Richard Smith            2020-08-06 15:57:35 -0700 14997)     if (FnR.isInvalid())
ed5a18fc0399d (Richard Smith            2020-08-06 15:57:35 -0700 14998)       return FRS_DiagnosticIssued;
ed5a18fc0399d (Richard Smith            2020-08-06 15:57:35 -0700 14999)     UnresolvedLookupExpr *Fn = cast<UnresolvedLookupExpr>(FnR.get());
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 15000) 
9c785c217b3f9 (Dmitri Gribenko          2013-05-09 21:02:07 +0000 15001)     bool CandidateSetError = buildOverloadedCallSet(S, Fn, Fn, Range, Loc,
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 15002)                                                     CandidateSet, CallExpr);
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 15003)     if (CandidateSet->empty() || CandidateSetError) {
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 15004)       *CallExpr = ExprError();
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 15005)       return FRS_NoViableFunction;
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 15006)     }
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 15007)     OverloadCandidateSet::iterator Best;
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 15008)     OverloadingResult OverloadResult =
f2ceec4811c35 (Stephen Kelly            2018-08-09 21:08:08 +0000 15009)         CandidateSet->BestViableFunction(*this, Fn->getBeginLoc(), Best);
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 15010) 
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 15011)     if (OverloadResult == OR_No_Viable_Function) {
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 15012)       *CallExpr = ExprError();
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 15013)       return FRS_NoViableFunction;
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 15014)     }
9c785c217b3f9 (Dmitri Gribenko          2013-05-09 21:02:07 +0000 15015)     *CallExpr = FinishOverloadedCallExpr(*this, S, Fn, Fn, Loc, Range,
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000 15016)                                          Loc, nullptr, CandidateSet, &Best,
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 15017)                                          OverloadResult,
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 15018)                                          /*AllowTypoCorrection=*/false);
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 15019)     if (CallExpr->isInvalid() || OverloadResult != OR_Success) {
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 15020)       *CallExpr = ExprError();
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 15021)       return FRS_DiagnosticIssued;
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 15022)     }
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 15023)   }
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 15024)   return FRS_Success;
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 15025) }
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 15026) 
0f38443616f50 (Sam Panzer               2012-08-21 00:52:01 +0000 15027) 
cd695e500de7e (Douglas Gregor           2008-11-10 20:40:00 +0000 15028) /// FixOverloadedFunctionReference - E is an expression that refers to
cd695e500de7e (Douglas Gregor           2008-11-10 20:40:00 +0000 15029) /// a C++ overloaded function (possibly with some parentheses and
cd695e500de7e (Douglas Gregor           2008-11-10 20:40:00 +0000 15030) /// perhaps a '&' around it). We have resolved the overloaded function
cd695e500de7e (Douglas Gregor           2008-11-10 20:40:00 +0000 15031) /// to the function declaration Fn, so patch up the expression E to
fcb4ab4420793 (Anders Carlsson          2009-10-21 17:16:23 +0000 15032) /// refer (possibly indirectly) to Fn. Returns the new expr.
a8ae222d0e8ba (John McCall              2010-04-06 21:38:20 +0000 15033) Expr *Sema::FixOverloadedFunctionReference(Expr *E, DeclAccessPair Found,
16df1e59f2bb7 (John McCall              2010-03-30 21:47:33 +0000 15034)                                            FunctionDecl *Fn) {
cd695e500de7e (Douglas Gregor           2008-11-10 20:40:00 +0000 15035)   if (ParenExpr *PE = dyn_cast<ParenExpr>(E)) {
16df1e59f2bb7 (John McCall              2010-03-30 21:47:33 +0000 15036)     Expr *SubExpr = FixOverloadedFunctionReference(PE->getSubExpr(),
16df1e59f2bb7 (John McCall              2010-03-30 21:47:33 +0000 15037)                                                    Found, Fn);
51c538bee4d75 (Douglas Gregor           2009-11-20 19:42:02 +0000 15038)     if (SubExpr == PE->getSubExpr())
c3007a21450f4 (John McCall              2010-10-26 07:05:15 +0000 15039)       return PE;
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 15040) 
51c538bee4d75 (Douglas Gregor           2009-11-20 19:42:02 +0000 15041)     return new (Context) ParenExpr(PE->getLParen(), PE->getRParen(), SubExpr);
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 15042)   }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 15043) 
51c538bee4d75 (Douglas Gregor           2009-11-20 19:42:02 +0000 15044)   if (ImplicitCastExpr *ICE = dyn_cast<ImplicitCastExpr>(E)) {
16df1e59f2bb7 (John McCall              2010-03-30 21:47:33 +0000 15045)     Expr *SubExpr = FixOverloadedFunctionReference(ICE->getSubExpr(),
16df1e59f2bb7 (John McCall              2010-03-30 21:47:33 +0000 15046)                                                    Found, Fn);
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 15047)     assert(Context.hasSameType(ICE->getSubExpr()->getType(),
51c538bee4d75 (Douglas Gregor           2009-11-20 19:42:02 +0000 15048)                                SubExpr->getType()) &&
091f04256a60c (Douglas Gregor           2009-10-23 22:18:25 +0000 15049)            "Implicit cast type cannot be determined from overload");
cf1421650953d (John McCall              2010-08-07 06:22:56 +0000 15050)     assert(ICE->path_empty() && "fixing up hierarchy conversion?");
51c538bee4d75 (Douglas Gregor           2009-11-20 19:42:02 +0000 15051)     if (SubExpr == ICE->getSubExpr())
c3007a21450f4 (John McCall              2010-10-26 07:05:15 +0000 15052)       return ICE;
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 15053) 
f1cd6593da3ad (Serge Pavlov             2020-09-12 21:54:14 +0700 15054)     return ImplicitCastExpr::Create(Context, ICE->getType(), ICE->getCastKind(),
f1cd6593da3ad (Serge Pavlov             2020-09-12 21:54:14 +0700 15055)                                     SubExpr, nullptr, ICE->getValueKind(),
f1cd6593da3ad (Serge Pavlov             2020-09-12 21:54:14 +0700 15056)                                     CurFPFeatureOverrides());
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 15057)   }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 15058) 
ff7bd8bacd130 (Aaron Ballman            2016-09-02 13:45:40 +0000 15059)   if (auto *GSE = dyn_cast<GenericSelectionExpr>(E)) {
ff7bd8bacd130 (Aaron Ballman            2016-09-02 13:45:40 +0000 15060)     if (!GSE->isResultDependent()) {
ff7bd8bacd130 (Aaron Ballman            2016-09-02 13:45:40 +0000 15061)       Expr *SubExpr =
ff7bd8bacd130 (Aaron Ballman            2016-09-02 13:45:40 +0000 15062)           FixOverloadedFunctionReference(GSE->getResultExpr(), Found, Fn);
ff7bd8bacd130 (Aaron Ballman            2016-09-02 13:45:40 +0000 15063)       if (SubExpr == GSE->getResultExpr())
ff7bd8bacd130 (Aaron Ballman            2016-09-02 13:45:40 +0000 15064)         return GSE;
ff7bd8bacd130 (Aaron Ballman            2016-09-02 13:45:40 +0000 15065) 
ff7bd8bacd130 (Aaron Ballman            2016-09-02 13:45:40 +0000 15066)       // Replace the resulting type information before rebuilding the generic
ff7bd8bacd130 (Aaron Ballman            2016-09-02 13:45:40 +0000 15067)       // selection expression.
8b871d96d780b (Aaron Ballman            2016-09-02 18:31:31 +0000 15068)       ArrayRef<Expr *> A = GSE->getAssocExprs();
8b871d96d780b (Aaron Ballman            2016-09-02 18:31:31 +0000 15069)       SmallVector<Expr *, 4> AssocExprs(A.begin(), A.end());
ff7bd8bacd130 (Aaron Ballman            2016-09-02 13:45:40 +0000 15070)       unsigned ResultIdx = GSE->getResultIndex();
ff7bd8bacd130 (Aaron Ballman            2016-09-02 13:45:40 +0000 15071)       AssocExprs[ResultIdx] = SubExpr;
ff7bd8bacd130 (Aaron Ballman            2016-09-02 13:45:40 +0000 15072) 
db07683d866bd (Bruno Ricci              2019-01-26 14:15:10 +0000 15073)       return GenericSelectionExpr::Create(
ff7bd8bacd130 (Aaron Ballman            2016-09-02 13:45:40 +0000 15074)           Context, GSE->getGenericLoc(), GSE->getControllingExpr(),
ff7bd8bacd130 (Aaron Ballman            2016-09-02 13:45:40 +0000 15075)           GSE->getAssocTypeSourceInfos(), AssocExprs, GSE->getDefaultLoc(),
ff7bd8bacd130 (Aaron Ballman            2016-09-02 13:45:40 +0000 15076)           GSE->getRParenLoc(), GSE->containsUnexpandedParameterPack(),
ff7bd8bacd130 (Aaron Ballman            2016-09-02 13:45:40 +0000 15077)           ResultIdx);
ff7bd8bacd130 (Aaron Ballman            2016-09-02 13:45:40 +0000 15078)     }
ff7bd8bacd130 (Aaron Ballman            2016-09-02 13:45:40 +0000 15079)     // Rather than fall through to the unreachable, return the original generic
ff7bd8bacd130 (Aaron Ballman            2016-09-02 13:45:40 +0000 15080)     // selection expression.
ff7bd8bacd130 (Aaron Ballman            2016-09-02 13:45:40 +0000 15081)     return GSE;
ff7bd8bacd130 (Aaron Ballman            2016-09-02 13:45:40 +0000 15082)   }
ff7bd8bacd130 (Aaron Ballman            2016-09-02 13:45:40 +0000 15083) 
51c538bee4d75 (Douglas Gregor           2009-11-20 19:42:02 +0000 15084)   if (UnaryOperator *UnOp = dyn_cast<UnaryOperator>(E)) {
e302792b6155b (John McCall              2010-08-25 11:45:40 +0000 15085)     assert(UnOp->getOpcode() == UO_AddrOf &&
cd695e500de7e (Douglas Gregor           2008-11-10 20:40:00 +0000 15086)            "Can only take the address of an overloaded function");
6f233ef1d893d (Douglas Gregor           2009-02-11 01:18:59 +0000 15087)     if (CXXMethodDecl *Method = dyn_cast<CXXMethodDecl>(Fn)) {
6f233ef1d893d (Douglas Gregor           2009-02-11 01:18:59 +0000 15088)       if (Method->isStatic()) {
6f233ef1d893d (Douglas Gregor           2009-02-11 01:18:59 +0000 15089)         // Do nothing: static member functions aren't any different
6f233ef1d893d (Douglas Gregor           2009-02-11 01:18:59 +0000 15090)         // from non-member functions.
d14a86427f9cd (John McCall              2009-11-21 08:51:07 +0000 15091)       } else {
028ed91127254 (Alp Toker                2013-12-06 17:56:43 +0000 15092)         // Fix the subexpression, which really has to be an
e66edc18ae0fc (John McCall              2009-11-24 19:00:30 +0000 15093)         // UnresolvedLookupExpr holding an overloaded member function
e66edc18ae0fc (John McCall              2009-11-24 19:00:30 +0000 15094)         // or template.
16df1e59f2bb7 (John McCall              2010-03-30 21:47:33 +0000 15095)         Expr *SubExpr = FixOverloadedFunctionReference(UnOp->getSubExpr(),
16df1e59f2bb7 (John McCall              2010-03-30 21:47:33 +0000 15096)                                                        Found, Fn);
d14a86427f9cd (John McCall              2009-11-21 08:51:07 +0000 15097)         if (SubExpr == UnOp->getSubExpr())
c3007a21450f4 (John McCall              2010-10-26 07:05:15 +0000 15098)           return UnOp;
d14a86427f9cd (John McCall              2009-11-21 08:51:07 +0000 15099) 
d14a86427f9cd (John McCall              2009-11-21 08:51:07 +0000 15100)         assert(isa<DeclRefExpr>(SubExpr)
d14a86427f9cd (John McCall              2009-11-21 08:51:07 +0000 15101)                && "fixed to something other than a decl ref");
d14a86427f9cd (John McCall              2009-11-21 08:51:07 +0000 15102)         assert(cast<DeclRefExpr>(SubExpr)->getQualifier()
d14a86427f9cd (John McCall              2009-11-21 08:51:07 +0000 15103)                && "fixed to a member ref with no nested name qualifier");
d14a86427f9cd (John McCall              2009-11-21 08:51:07 +0000 15104) 
d14a86427f9cd (John McCall              2009-11-21 08:51:07 +0000 15105)         // We have taken the address of a pointer to member
d14a86427f9cd (John McCall              2009-11-21 08:51:07 +0000 15106)         // function. Perform the computation here so that we get the
d14a86427f9cd (John McCall              2009-11-21 08:51:07 +0000 15107)         // appropriate pointer to member type.
d14a86427f9cd (John McCall              2009-11-21 08:51:07 +0000 15108)         QualType ClassType
d14a86427f9cd (John McCall              2009-11-21 08:51:07 +0000 15109)           = Context.getTypeDeclType(cast<RecordDecl>(Method->getDeclContext()));
d14a86427f9cd (John McCall              2009-11-21 08:51:07 +0000 15110)         QualType MemPtrType
d14a86427f9cd (John McCall              2009-11-21 08:51:07 +0000 15111)           = Context.getMemberPointerType(Fn->getType(), ClassType.getTypePtr());
02d57cc92cb82 (David Majnemer           2016-06-30 03:02:03 +0000 15112)         // Under the MS ABI, lock down the inheritance model now.
02d57cc92cb82 (David Majnemer           2016-06-30 03:02:03 +0000 15113)         if (Context.getTargetInfo().getCXXABI().isMicrosoft())
02d57cc92cb82 (David Majnemer           2016-06-30 03:02:03 +0000 15114)           (void)isCompleteType(UnOp->getOperatorLoc(), MemPtrType);
d14a86427f9cd (John McCall              2009-11-21 08:51:07 +0000 15115) 
f5360d4bb3376 (Melanie Blower           2020-05-01 10:32:06 -0700 15116)         return UnaryOperator::Create(
f5360d4bb3376 (Melanie Blower           2020-05-01 10:32:06 -0700 15117)             Context, SubExpr, UO_AddrOf, MemPtrType, VK_RValue, OK_Ordinary,
f4aaed3bf16b3 (Melanie Blower           2020-06-26 09:23:45 -0700 15118)             UnOp->getOperatorLoc(), false, CurFPFeatureOverrides());
6f233ef1d893d (Douglas Gregor           2009-02-11 01:18:59 +0000 15119)       }
6f233ef1d893d (Douglas Gregor           2009-02-11 01:18:59 +0000 15120)     }
16df1e59f2bb7 (John McCall              2010-03-30 21:47:33 +0000 15121)     Expr *SubExpr = FixOverloadedFunctionReference(UnOp->getSubExpr(),
16df1e59f2bb7 (John McCall              2010-03-30 21:47:33 +0000 15122)                                                    Found, Fn);
51c538bee4d75 (Douglas Gregor           2009-11-20 19:42:02 +0000 15123)     if (SubExpr == UnOp->getSubExpr())
c3007a21450f4 (John McCall              2010-10-26 07:05:15 +0000 15124)       return UnOp;
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 15125) 
f4aaed3bf16b3 (Melanie Blower           2020-06-26 09:23:45 -0700 15126)     return UnaryOperator::Create(Context, SubExpr, UO_AddrOf,
f4aaed3bf16b3 (Melanie Blower           2020-06-26 09:23:45 -0700 15127)                                  Context.getPointerType(SubExpr->getType()),
f4aaed3bf16b3 (Melanie Blower           2020-06-26 09:23:45 -0700 15128)                                  VK_RValue, OK_Ordinary, UnOp->getOperatorLoc(),
f4aaed3bf16b3 (Melanie Blower           2020-06-26 09:23:45 -0700 15129)                                  false, CurFPFeatureOverrides());
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 15130)   }
d14a86427f9cd (John McCall              2009-11-21 08:51:07 +0000 15131) 
d14a86427f9cd (John McCall              2009-11-21 08:51:07 +0000 15132)   if (UnresolvedLookupExpr *ULE = dyn_cast<UnresolvedLookupExpr>(E)) {
2d74de96325e4 (John McCall              2009-12-01 22:10:20 +0000 15133)     // FIXME: avoid copy.
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000 15134)     TemplateArgumentListInfo TemplateArgsBuffer, *TemplateArgs = nullptr;
e66edc18ae0fc (John McCall              2009-11-24 19:00:30 +0000 15135)     if (ULE->hasExplicitTemplateArgs()) {
2d74de96325e4 (John McCall              2009-12-01 22:10:20 +0000 15136)       ULE->copyTemplateArgumentsInto(TemplateArgsBuffer);
2d74de96325e4 (John McCall              2009-12-01 22:10:20 +0000 15137)       TemplateArgs = &TemplateArgsBuffer;
e66edc18ae0fc (John McCall              2009-11-24 19:00:30 +0000 15138)     }
e66edc18ae0fc (John McCall              2009-11-24 19:00:30 +0000 15139) 
7dcd73340ba51 (Richard Smith            2019-06-04 18:30:46 +0000 15140)     DeclRefExpr *DRE =
7dcd73340ba51 (Richard Smith            2019-06-04 18:30:46 +0000 15141)         BuildDeclRefExpr(Fn, Fn->getType(), VK_LValue, ULE->getNameInfo(),
7dcd73340ba51 (Richard Smith            2019-06-04 18:30:46 +0000 15142)                          ULE->getQualifierLoc(), Found.getDecl(),
7dcd73340ba51 (Richard Smith            2019-06-04 18:30:46 +0000 15143)                          ULE->getTemplateKeywordLoc(), TemplateArgs);
635ed24e1dad8 (Abramo Bagnara           2011-10-05 07:56:41 +0000 15144)     DRE->setHadMultipleCandidates(ULE->getNumDecls() > 1);
635ed24e1dad8 (Abramo Bagnara           2011-10-05 07:56:41 +0000 15145)     return DRE;
d14a86427f9cd (John McCall              2009-11-21 08:51:07 +0000 15146)   }
d14a86427f9cd (John McCall              2009-11-21 08:51:07 +0000 15147) 
10eae1851d3f6 (John McCall              2009-11-30 22:42:35 +0000 15148)   if (UnresolvedMemberExpr *MemExpr = dyn_cast<UnresolvedMemberExpr>(E)) {
6b51f28e82646 (John McCall              2009-11-23 01:53:49 +0000 15149)     // FIXME: avoid copy.
c3ec149bb238c (Craig Topper             2014-05-26 06:22:03 +0000 15150)     TemplateArgumentListInfo TemplateArgsBuffer, *TemplateArgs = nullptr;
2d74de96325e4 (John McCall              2009-12-01 22:10:20 +0000 15151)     if (MemExpr->hasExplicitTemplateArgs()) {
2d74de96325e4 (John McCall              2009-12-01 22:10:20 +0000 15152)       MemExpr->copyTemplateArgumentsInto(TemplateArgsBuffer);
2d74de96325e4 (John McCall              2009-12-01 22:10:20 +0000 15153)       TemplateArgs = &TemplateArgsBuffer;
2d74de96325e4 (John McCall              2009-12-01 22:10:20 +0000 15154)     }
2d74de96325e4 (John McCall              2009-12-01 22:10:20 +0000 15155) 
2d74de96325e4 (John McCall              2009-12-01 22:10:20 +0000 15156)     Expr *Base;
2d74de96325e4 (John McCall              2009-12-01 22:10:20 +0000 15157) 
7decc9e4ea6c5 (John McCall              2010-11-18 06:31:45 +0000 15158)     // If we're filling in a static method where we used to have an
7decc9e4ea6c5 (John McCall              2010-11-18 06:31:45 +0000 15159)     // implicit member access, rewrite to a simple decl ref.
2d74de96325e4 (John McCall              2009-12-01 22:10:20 +0000 15160)     if (MemExpr->isImplicitAccess()) {
2d74de96325e4 (John McCall              2009-12-01 22:10:20 +0000 15161)       if (cast<CXXMethodDecl>(Fn)->isStatic()) {
7dcd73340ba51 (Richard Smith            2019-06-04 18:30:46 +0000 15162)         DeclRefExpr *DRE = BuildDeclRefExpr(
7dcd73340ba51 (Richard Smith            2019-06-04 18:30:46 +0000 15163)             Fn, Fn->getType(), VK_LValue, MemExpr->getNameInfo(),
7dcd73340ba51 (Richard Smith            2019-06-04 18:30:46 +0000 15164)             MemExpr->getQualifierLoc(), Found.getDecl(),
7dcd73340ba51 (Richard Smith            2019-06-04 18:30:46 +0000 15165)             MemExpr->getTemplateKeywordLoc(), TemplateArgs);
635ed24e1dad8 (Abramo Bagnara           2011-10-05 07:56:41 +0000 15166)         DRE->setHadMultipleCandidates(MemExpr->getNumDecls() > 1);
635ed24e1dad8 (Abramo Bagnara           2011-10-05 07:56:41 +0000 15167)         return DRE;
b15af899fb4b4 (Douglas Gregor           2010-01-07 23:12:05 +0000 15168)       } else {
b15af899fb4b4 (Douglas Gregor           2010-01-07 23:12:05 +0000 15169)         SourceLocation Loc = MemExpr->getMemberLoc();
b15af899fb4b4 (Douglas Gregor           2010-01-07 23:12:05 +0000 15170)         if (MemExpr->getQualifier())
0da1d43e1600a (Douglas Gregor           2011-02-28 20:01:57 +0000 15171)           Loc = MemExpr->getQualifierLoc().getBeginLoc();
8458c9ef42390 (Richard Smith            2019-05-24 01:35:07 +0000 15172)         Base =
49a3ad21d6034 (Rui Ueyama               2019-07-16 04:46:31 +0000 15173)             BuildCXXThisExpr(Loc, MemExpr->getBaseType(), /*IsImplicit=*/true);
b15af899fb4b4 (Douglas Gregor           2010-01-07 23:12:05 +0000 15174)       }
2d74de96325e4 (John McCall              2009-12-01 22:10:20 +0000 15175)     } else
c3007a21450f4 (John McCall              2010-10-26 07:05:15 +0000 15176)       Base = MemExpr->getBase();
6b51f28e82646 (John McCall              2009-11-23 01:53:49 +0000 15177) 
4adb38cdf4004 (John McCall              2011-04-27 00:36:17 +0000 15178)     ExprValueKind valueKind;
4adb38cdf4004 (John McCall              2011-04-27 00:36:17 +0000 15179)     QualType type;
4adb38cdf4004 (John McCall              2011-04-27 00:36:17 +0000 15180)     if (cast<CXXMethodDecl>(Fn)->isStatic()) {
4adb38cdf4004 (John McCall              2011-04-27 00:36:17 +0000 15181)       valueKind = VK_LValue;
4adb38cdf4004 (John McCall              2011-04-27 00:36:17 +0000 15182)       type = Fn->getType();
4adb38cdf4004 (John McCall              2011-04-27 00:36:17 +0000 15183)     } else {
4adb38cdf4004 (John McCall              2011-04-27 00:36:17 +0000 15184)       valueKind = VK_RValue;
eba323ab4453b (Yunzhong Gao             2015-05-01 02:04:32 +0000 15185)       type = Context.BoundMemberTy;
eba323ab4453b (Yunzhong Gao             2015-05-01 02:04:32 +0000 15186)     }
eba323ab4453b (Yunzhong Gao             2015-05-01 02:04:32 +0000 15187) 
84be998497669 (Richard Smith            2019-06-06 23:24:18 +0000 15188)     return BuildMemberExpr(
84be998497669 (Richard Smith            2019-06-06 23:24:18 +0000 15189)         Base, MemExpr->isArrow(), MemExpr->getOperatorLoc(),
eba323ab4453b (Yunzhong Gao             2015-05-01 02:04:32 +0000 15190)         MemExpr->getQualifierLoc(), MemExpr->getTemplateKeywordLoc(), Fn, Found,
84be998497669 (Richard Smith            2019-06-06 23:24:18 +0000 15191)         /*HadMultipleCandidates=*/true, MemExpr->getMemberNameInfo(),
84be998497669 (Richard Smith            2019-06-06 23:24:18 +0000 15192)         type, valueKind, OK_Ordinary, TemplateArgs);
51c538bee4d75 (Douglas Gregor           2009-11-20 19:42:02 +0000 15193)   }
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 15194) 
c3007a21450f4 (John McCall              2010-10-26 07:05:15 +0000 15195)   llvm_unreachable("Invalid reference to overloaded function");
cd695e500de7e (Douglas Gregor           2008-11-10 20:40:00 +0000 15196) }
cd695e500de7e (Douglas Gregor           2008-11-10 20:40:00 +0000 15197) 
f9cbcc4cc2e26 (NAKAMURA Takumi          2011-01-27 07:10:08 +0000 15198) ExprResult Sema::FixOverloadedFunctionReference(ExprResult E,
dadc575b1e878 (John McCall              2010-08-24 06:29:42 +0000 15199)                                                 DeclAccessPair Found,
dadc575b1e878 (John McCall              2010-08-24 06:29:42 +0000 15200)                                                 FunctionDecl *Fn) {
03ff2596cb161 (Nikola Smiljanic         2014-05-29 14:05:12 +0000 15201)   return FixOverloadedFunctionReference(E.get(), Found, Fn);
3e1e527826048 (Douglas Gregor           2009-12-09 23:02:17 +0000 15202) }
