// ----------------------
// COMPARE
// ----------------------

impl forall [T2:! Type, U2:! Type, T1:! CompareWith(T2), U1:! CompareWith(U2)]
    (T1, U1) as CompareWith((T2, U2)) {
  fn Equal[me: Self](other: (T2, U2)) -> Bool {
    let (l1: T1, l2: U1) = me;
    let (r1: T2, r2: U2) = other;
    var comp: i32 = __intrinsic_int_compare(me, other);
        if (comp == -1) {
          return Ordering.Less();
        }
        if (comp == 0) {
          return Ordering.Equivalent();
        }
        if (comp == 1) {
          return Ordering.Greater();
        }
        return Ordering.Incomparable();
  }
}

choice Ordering {
  Less,
  Equivalent,
  Greater,
  Incomparable
}

interface CompareWith(U:! Type) {
  fn Compare[me: Self](u: U) -> Ordering;
  // TODO: Add `default fn` for Less, LessOrEquivalent, Greater, and GreaterOrEquivalent once it's available.
}
// TODO: constraint Ordered { ... }

impl i32 as CompareWith(Self) {
  fn Compare[me: Self](other: Self) -> Ordering {
    var comp: i32 = __intrinsic_int_compare(me, other);
    if (comp == -1) {
      return Ordering.Less;
    }
    if (comp == 0) {
      return Ordering.Equivalent;
    }
    if (comp == 1) {
      return Ordering.Greater;
    }
    return Ordering.Incomparable;

  }
}

impl String as CompareWith(Self) {
  fn Compare[me: Self](other: Self) -> Ordering {
    var comp: i32 = __intrinsic_str_compare(me, other);
    if (comp == -1) {
      return Ordering.Less;
    }
    if (comp == 0) {
      return Ordering.Equivalent;
    }
    if (comp == 1) {
      return Ordering.Greater;
    }
    return Ordering.Incomparable;
  }
}

interface LessWith(U:! Type) {
  fn Less[me: Self](other: U) -> Bool;
}

impl i32 as LessWith(Self) {
  fn Less[me: Self](other: Self) -> Bool {
    return me.Compare(other) == Ordering.Less;
  }
}

impl String as LessWith(Self) {
  fn Less[me: Self](other: Self) -> Bool {
    return me.Compare(other) == Ordering.Less;
  }
}