// -*- C++ -*-
//===------------------------ functional ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_FUNCTIONAL
#define _LIBCPP_FUNCTIONAL

/*
    functional synopsis

namespace std
{

template <class Arg, class Result>
struct unary_function
{
    typedef Arg    argument_type;
    typedef Result result_type;
};

template <class Arg1, class Arg2, class Result>
struct binary_function
{
    typedef Arg1   first_argument_type;
    typedef Arg2   second_argument_type;
    typedef Result result_type;
};

template <ObjectType T>
class reference_wrapper
    : public unary_function<T1, R> // if wrapping a unary functor
    : public binary_function<T1, T2, R> // if wraping a binary functor
{
public:
    // types
    typedef T type;
    typedef see below result_type; // Not always defined

    // construct/copy/destroy
    reference_wrapper(T&);
    reference_wrapper(T&&) = delete; // do not bind to temps
    reference_wrapper(const reference_wrapper<T>& x);

    // assignment
    reference_wrapper& operator=(const reference_wrapper<T>& x);

    // access
    operator T& () const;
    T& get() const;

    // invoke
    template <class... ArgTypes>
      requires Callable<T, ArgTypes&&...>
        Callable<T, ArgTypes&&...>::result_type
          operator() (ArgTypes&&...) const;
};

template <ObjectType T> reference_wrapper<T> ref(T& t);
template <ObjectType T> void ref(const T&& t) = delete; // LWG 688
template <ObjectType T> reference_wrapper<T> ref(reference_wrapper<T>t);

template <ObjectType T> reference_wrapper<const T> cref(const T& t);
template <ObjectType T> void cref(const T&& t) = delete; // LWG 688
template <ObjectType T> reference_wrapper<const T> cref(reference_wrapper<T> t);

template <class T>
struct plus : binary_function<T, T, T>
{
    T operator()(const T& x, const T& y) const;
};

template <class T>
struct minus : binary_function<T, T, T>
{
    T operator()(const T& x, const T& y) const;
};

template <class T>
struct multiplies : binary_function<T, T, T>
{
    T operator()(const T& x, const T& y) const;
};

template <class T>
struct divides : binary_function<T, T, T>
{
    T operator()(const T& x, const T& y) const;
};

template <class T>
struct modulus : binary_function<T, T, T>
{
    T operator()(const T& x, const T& y) const;
};

template <class T>
struct negate : unary_function<T, T>
{
    T operator()(const T& x) const;
};

template <class T>
struct equal_to : binary_function<T, T, bool>
{
    bool operator()(const T& x, const T& y) const;
};

template <class T>
struct not_equal_to : binary_function<T, T, bool>
{
    bool operator()(const T& x, const T& y) const;
};

template <class T>
struct greater : binary_function<T, T, bool>
{
    bool operator()(const T& x, const T& y) const;
};

template <class T>
struct less : binary_function<T, T, bool>
{
    bool operator()(const T& x, const T& y) const;
};

template <class T>
struct greater_equal : binary_function<T, T, bool>
{
    bool operator()(const T& x, const T& y) const;
};

template <class T>
struct less_equal : binary_function<T, T, bool>
{
    bool operator()(const T& x, const T& y) const;
};

template <class T>
struct logical_and : binary_function<T, T, bool>
{
    bool operator()(const T& x, const T& y) const;
};

template <class T>
struct logical_or : binary_function<T, T, bool>
{
    bool operator()(const T& x, const T& y) const;
};

template <class T>
struct logical_not : unary_function<T, bool>
{
    bool operator()(const T& x) const;
};

template <class Predicate>
class unary_negate
    : public unary_function<typename Predicate::argument_type, bool>
{
public:
    explicit unary_negate(const Predicate& pred);
    bool operator()(const typename Predicate::argument_type& x) const;
};

template <class Predicate> unary_negate<Predicate> not1(const Predicate& pred);

template <class Predicate>
class binary_negate
    : public binary_function<typename Predicate::first_argument_type,
                             typename Predicate::second_argument_type,
                             bool>
{
public:
    explicit binary_negate(const Predicate& pred);
    bool operator()(const typename Predicate::first_argument_type& x,
                    const typename Predicate::second_argument_type& y) const;
};

template <class Predicate> binary_negate<Predicate> not2(const Predicate& pred);

template<class T> struct is_bind_expression;
template<class T> struct is_placeholder;

template<CopyConstructible Fn, CopyConstructible... Types> 
  unspecified bind(Fn, Types...);
template<Returnable R, CopyConstructible Fn, CopyConstructible... Types> 
  unspecified bind(Fn, Types...);

namespace placeholders { 
  // M is the implementation-defined number of placeholders 
  extern unspecified _1;
  extern unspecified _2;
  . 
  . 
  . 
  extern unspecified _M;
}

template <class Operation>
class binder1st
    : public unary_function<typename Operation::second_argument_type,
                            typename Operation::result_type>
{
protected:
    Operation                               op;
    typename Operation::first_argument_type value;
public:
    binder1st(const Operation& x, const typename Operation::first_argument_type y);
    typename Operation::result_type operator()(      typename Operation::second_argument_type& x) const;
    typename Operation::result_type operator()(const typename Operation::second_argument_type& x) const;
};

template <class Operation, class T>
binder1st<Operation> bind1st(const Operation& op, const T& x);

template <class Operation>
class binder2nd
    : public unary_function<typename Operation::first_argument_type,
                            typename Operation::result_type>
{
protected:
    Operation                                op;
    typename Operation::second_argument_type value;
public:
    binder2nd(const Operation& x, const typename Operation::second_argument_type y);
    typename Operation::result_type operator()(      typename Operation::first_argument_type& x) const;
    typename Operation::result_type operator()(const typename Operation::first_argument_type& x) const;
};

template <class Operation, class T>
binder2nd<Operation> bind2nd(const Operation& op, const T& x);

template <class Arg, class Result>
class pointer_to_unary_function : public unary_function<Arg, Result>
{
public:
    explicit pointer_to_unary_function(Result (*f)(Arg));
    Result operator()(Arg x) const;
};

template <class Arg, class Result>
pointer_to_unary_function<Arg,Result> ptr_fun(Result (*f)(Arg));

template <class Arg1, class Arg2, class Result>
class pointer_to_binary_function : public binary_function<Arg1, Arg2, Result>
{
public:
    explicit pointer_to_binary_function(Result (*f)(Arg1, Arg2));
    Result operator()(Arg1 x, Arg2 y) const;
};

template <class Arg1, class Arg2, class Result>
pointer_to_binary_function<Arg1,Arg2,Result> ptr_fun(Result (*f)(Arg1,Arg2));

template<class S, class T>
class mem_fun_t : public unary_function<T*, S>
{
public:
    explicit mem_fun_t(S (T::*p)());
    S operator()(T* p) const;
};

template<class S, class T, class A>
class mem_fun1_t : public binary_function<T*, A, S>
{
public:
    explicit mem_fun1_t(S (T::*p)(A));
    S operator()(T* p, A x) const;
};

template<class S, class T>          mem_fun_t<S,T>    mem_fun(S (T::*f)());
template<class S, class T, class A> mem_fun1_t<S,T,A> mem_fun(S (T::*f)(A));

template<class S, class T>
class mem_fun_ref_t : public unary_function<T, S>
{
public:
    explicit mem_fun_ref_t(S (T::*p)());
    S operator()(T& p) const;
};

template<class S, class T, class A>
class mem_fun1_ref_t : public binary_function<T, A, S>
{
public:
    explicit mem_fun1_ref_t(S (T::*p)(A));
    S operator()(T& p, A x) const;
};

template<class S, class T>          mem_fun_ref_t<S,T>    mem_fun_ref(S (T::*f)());
template<class S, class T, class A> mem_fun1_ref_t<S,T,A> mem_fun_ref(S (T::*f)(A));

template <class S, class T>
class const_mem_fun_t : public unary_function<const T*, S>
{
public:
    explicit const_mem_fun_t(S (T::*p)() const);
    S operator()(const T* p) const;
};

template <class S, class T, class A>
class const_mem_fun1_t : public binary_function<const T*, A, S>
{
public:
    explicit const_mem_fun1_t(S (T::*p)(A) const);
    S operator()(const T* p, A x) const;
};

template <class S, class T>          const_mem_fun_t<S,T>    mem_fun(S (T::*f)() const);
template <class S, class T, class A> const_mem_fun1_t<S,T,A> mem_fun(S (T::*f)(A) const);

template <class S, class T>
class const_mem_fun_ref_t : public unary_function<T, S>
{
public:
    explicit const_mem_fun_ref_t(S (T::*p)() const);
    S operator()(const T& p) const;
};

template <class S, class T, class A>
class const_mem_fun1_ref_t : public binary_function<T, A, S>
{
public:
    explicit const_mem_fun1_ref_t(S (T::*p)(A) const);
    S operator()(const T& p, A x) const;
};

template <class S, class T>          const_mem_fun_ref_t<S,T>    mem_fun_ref(S (T::*f)() const);
template <class S, class T, class A> const_mem_fun1_ref_t<S,T,A> mem_fun_ref(S (T::*f)(A) const);

class bad_function_call
    : public exception
{
};

template<Returnable R, class T> unspecified mem_fn(R T::* pm);
template<Returnable R, class T, CopyConstructible... Args> 
  unspecified mem_fn(R (T::* pm)(Args...));
template<Returnable R, class T, CopyConstructible... Args> 
  unspecified mem_fn(R (T::* pm)(Args...) const);
template<Returnable R, class T, CopyConstructible... Args> 
  unspecified mem_fn(R (T::* pm)(Args...) volatile);
template<Returnable R, class T, CopyConstructible... Args> 
  unspecified mem_fn(R (T::* pm)(Args...) const volatile);

template<FunctionType> class function; // undefined

template<Returnable R, CopyConstructible... ArgTypes>
class function<R(ArgTypes...)>
  : public unary_function<T1, R>      // iff sizeof...(ArgTypes) == 1 and
                                      // ArgTypes contains T1
  : public binary_function<T1, T2, R> // iff sizeof...(ArgTypes) == 2 and
                                      // ArgTypes contains T1 and T2
{
public:
    typedef R result_type;

    // 20.7.16.2.1, construct/copy/destroy:
    explicit function();
    function(nullptr_t);
    function(const function&);
    function(function&&);
    template<class F>
      requires CopyConstructible<F> && Callable<F, ArgTypes...>
            && Convertible<Callable<F, ArgTypes...>::result_type, R>
      function(F);
//     template<class F>
//       requires CopyConstructible<F> && Callable<F, ArgTypes...>
//             && Convertible<Callable<F, ArgTypes...>::result_type, R>
//       function(F&&);
    template<Allocator Alloc>
      function(allocator_arg_t, const Alloc&);
    template<Allocator Alloc>
      function(allocator_arg_t, const Alloc&, nullptr_t);
    template<Allocator Alloc>
      function(allocator_arg_t, const Alloc&, const function&);
    template<Allocator Alloc>
      function(allocator_arg_t, const Alloc&, function&&);
    template<class F, Allocator Alloc>
      function(allocator_arg_t, const Alloc&, F);
//     template<class F, Allocator Alloc>
//       function(allocator_arg_t, const Alloc&, F&&);

    function& operator=(const function&);
    function& operator=(function&&);
    function& operator=(nullptr_t);
    template<class F>
      requires CopyConstructible<F> && Callable<F, ArgTypes..>
            && Convertible<Callable<F, ArgTypes...>::result_type
      function& operator=(F);
//     template<class F>
//       requires CopyConstructible<F> && Callable<F, ArgTypes...>
//             && Convertible<Callable<F, ArgTypes...>::result_type, R>
//       function& operator=(F&&);
    template<class F>
      requires Callable<F, ArgTypes...>
            && Convertible<Callable<F, ArgTypes...>::result_type, R>
      function& operator=(reference_wrapper<F>);

    ~function();

    // 20.7.16.2.2, function modifiers:
    void swap(function&);
    template<class F, Allocator Alloc>
      requires Callable<F, ArgTypes...>
            && Convertible<Callable<F, ArgTypes...>::result_type, R>
      void assign(F, const Alloc&);

    // 20.7.16.2.3, function capacity:
    explicit operator bool() const;

    // deleted overloads close possible hole in the type system
    template<class R2, class... ArgTypes2>
      bool operator==(const function<R2(ArgTypes2...)>&) = delete;
    template<class R2, class... ArgTypes2>
      bool operator!=(const function<R2(ArgTypes2...)>&) = delete;

    // 20.7.16.2.4, function invocation:
    R operator()(ArgTypes...) const;

    // 20.7.16.2.5, function target access:
    const std::type_info& target_type() const;
    template <typename T>
      requires Callable<T, ArgTypes...>
            && Convertible<Callable<T, ArgTypes...>::result_type, R>
      T* target();
    template <typename T>
      requires Callable<T, ArgTypes...>
            && Convertible<Callable<T, ArgTypes...>::result_type, R>
      const T* target() const;
};

// 20.7.16.2.6, Null pointer comparisons: 
template <MoveConstructible R, MoveConstructible ... ArgTypes> 
  bool operator==(const function<R(ArgTypes...)>&, nullptr_t);

template <MoveConstructible R, MoveConstructible ... ArgTypes> 
  bool operator==(nullptr_t, const function<R(ArgTypes...)>&);

template <MoveConstructible R, MoveConstructible ... ArgTypes> 
  bool operator!=(const function<R(ArgTypes...)>&, nullptr_t);

template <MoveConstructible  R, MoveConstructible ... ArgTypes> 
  bool operator!=(nullptr_t, const function<R(ArgTypes...)>&);

// 20.7.16.2.7, specialized algorithms: 
template <MoveConstructible  R, MoveConstructible ... ArgTypes> 
  void swap(function<R(ArgTypes...)>&, function<R(ArgTypes...)>&);

template <class T> struct hash;

template <> struct hash<bool>;
template <> struct hash<char>;
template <> struct hash<signed char>;
template <> struct hash<unsigned char>;
template <> struct hash<char16_t>;
template <> struct hash<char32_t>;
template <> struct hash<wchar_t>;
template <> struct hash<short>;
template <> struct hash<unsigned short>;
template <> struct hash<int>;
template <> struct hash<unsigned int>;
template <> struct hash<long>;
template <> struct hash<long long>;
template <> struct hash<unsigned long>;
template <> struct hash<unsigned long long>;

template <> struct hash<float>;
template <> struct hash<double>;
template <> struct hash<long double>;

template<class T> struct hash<T*>;

}  // std

POLICY:  For non-variadic implementations, the number of arguments is limited
         to 3.  It is hoped that the need for non-variadic implementations
         will be minimal.

*/

#include <__config>
#include <type_traits>
#include <typeinfo>
#include <exception>
#include <memory>
#include <tuple>

#include <__functional_base>

#pragma GCC system_header

_LIBCPP_BEGIN_NAMESPACE_STD

template <class _Tp>
struct plus : binary_function<_Tp, _Tp, _Tp>
{
    _LIBCPP_INLINE_VISIBILITY _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x + __y;}
};

template <class _Tp>
struct minus : binary_function<_Tp, _Tp, _Tp>
{
    _LIBCPP_INLINE_VISIBILITY _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x - __y;}
};

template <class _Tp>
struct multiplies : binary_function<_Tp, _Tp, _Tp>
{
    _LIBCPP_INLINE_VISIBILITY _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x * __y;}
};

template <class _Tp>
struct divides : binary_function<_Tp, _Tp, _Tp>
{
    _LIBCPP_INLINE_VISIBILITY _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x / __y;}
};

template <class _Tp>
struct modulus : binary_function<_Tp, _Tp, _Tp>
{
    _LIBCPP_INLINE_VISIBILITY _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x % __y;}
};

template <class _Tp>
struct negate : unary_function<_Tp, _Tp>
{
    _LIBCPP_INLINE_VISIBILITY _Tp operator()(const _Tp& __x) const
        {return -__x;}
};

template <class _Tp>
struct equal_to : binary_function<_Tp, _Tp, bool>
{
    _LIBCPP_INLINE_VISIBILITY bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x == __y;}
};

template <class _Tp>
struct not_equal_to : binary_function<_Tp, _Tp, bool>
{
    _LIBCPP_INLINE_VISIBILITY bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x != __y;}
};

template <class _Tp>
struct greater : binary_function<_Tp, _Tp, bool>
{
    _LIBCPP_INLINE_VISIBILITY bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x > __y;}
};

template <class _Tp>
struct less : binary_function<_Tp, _Tp, bool>
{
    _LIBCPP_INLINE_VISIBILITY bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x < __y;}
};

template <class _Tp>
struct greater_equal : binary_function<_Tp, _Tp, bool>
{
    _LIBCPP_INLINE_VISIBILITY bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x >= __y;}
};

template <class _Tp>
struct less_equal : binary_function<_Tp, _Tp, bool>
{
    _LIBCPP_INLINE_VISIBILITY bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x <= __y;}
};

template <class _Tp>
struct logical_and : binary_function<_Tp, _Tp, bool>
{
    _LIBCPP_INLINE_VISIBILITY bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x && __y;}
};

template <class _Tp>
struct logical_or : binary_function<_Tp, _Tp, bool>
{
    _LIBCPP_INLINE_VISIBILITY bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x || __y;}
};

template <class _Tp>
struct logical_not : unary_function<_Tp, bool>
{
    _LIBCPP_INLINE_VISIBILITY bool operator()(const _Tp& __x) const
        {return !__x;}
};

template <class _Tp>
struct bit_and : binary_function<_Tp, _Tp, _Tp>
{
    _LIBCPP_INLINE_VISIBILITY _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x & __y;}
};

template <class _Tp>
struct bit_or : binary_function<_Tp, _Tp, _Tp>
{
    _LIBCPP_INLINE_VISIBILITY _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x | __y;}
};

template <class _Tp>
struct bit_xor : binary_function<_Tp, _Tp, _Tp>
{
    _LIBCPP_INLINE_VISIBILITY _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x ^ __y;}
};

template <class _Predicate>
class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
{
    _Predicate __pred_;
public:
    _LIBCPP_INLINE_VISIBILITY explicit unary_negate(const _Predicate& __pred)
        : __pred_(__pred) {}
    _LIBCPP_INLINE_VISIBILITY bool operator()(const typename _Predicate::argument_type& __x) const
        {return !__pred_(__x);}
};

template <class _Predicate>
inline _LIBCPP_INLINE_VISIBILITY
unary_negate<_Predicate>
not1(const _Predicate& __pred) {return unary_negate<_Predicate>(__pred);}

template <class _Predicate>
class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
                             typename _Predicate::second_argument_type,
                             bool>
{
    _Predicate __pred_;
public:
    _LIBCPP_INLINE_VISIBILITY explicit binary_negate(const _Predicate& __pred)
        : __pred_(__pred) {}
    _LIBCPP_INLINE_VISIBILITY bool operator()(const typename _Predicate::first_argument_type& __x,
                    const typename _Predicate::second_argument_type& __y) const
        {return !__pred_(__x, __y);}
};

template <class _Predicate>
inline _LIBCPP_INLINE_VISIBILITY
binary_negate<_Predicate>
not2(const _Predicate& __pred) {return binary_negate<_Predicate>(__pred);}

template <class __Operation>
class binder1st
    : public unary_function<typename __Operation::second_argument_type,
                            typename __Operation::result_type>
{
protected:
    __Operation                               op;
    typename __Operation::first_argument_type value;
public:
    _LIBCPP_INLINE_VISIBILITY binder1st(const __Operation& __x,
                               const typename __Operation::first_argument_type __y)
        : op(__x), value(__y) {}
    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()
        (typename __Operation::second_argument_type& __x) const
            {return op(value, __x);}
    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()
        (const typename __Operation::second_argument_type& __x) const
            {return op(value, __x);}
};

template <class __Operation, class _Tp>
inline _LIBCPP_INLINE_VISIBILITY
binder1st<__Operation>
bind1st(const __Operation& __op, const _Tp& __x)
    {return binder1st<__Operation>(__op, __x);}

template <class __Operation>
class binder2nd
    : public unary_function<typename __Operation::first_argument_type,
                            typename __Operation::result_type>
{
protected:
    __Operation                                op;
    typename __Operation::second_argument_type value;
public:
    binder2nd(const __Operation& __x, const typename __Operation::second_argument_type __y)
        : op(__x), value(__y) {}
    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()
        (      typename __Operation::first_argument_type& __x) const
            {return op(__x, value);}
    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()
        (const typename __Operation::first_argument_type& __x) const
            {return op(__x, value);}
};

template <class __Operation, class _Tp>
inline _LIBCPP_INLINE_VISIBILITY
binder2nd<__Operation>
bind2nd(const __Operation& __op, const _Tp& __x)
    {return binder2nd<__Operation>(__op, __x);}

template <class _Arg, class _Result>
class pointer_to_unary_function : public unary_function<_Arg, _Result>
{
    _Result (*__f_)(_Arg);
public:
    _LIBCPP_INLINE_VISIBILITY explicit pointer_to_unary_function(_Result (*__f)(_Arg))
        : __f_(__f) {}
    _LIBCPP_INLINE_VISIBILITY _Result operator()(_Arg __x) const
        {return __f_(__x);}
};

template <class _Arg, class _Result>
inline _LIBCPP_INLINE_VISIBILITY
pointer_to_unary_function<_Arg,_Result>
ptr_fun(_Result (*__f)(_Arg))
    {return pointer_to_unary_function<_Arg,_Result>(__f);}

template <class _Arg1, class _Arg2, class _Result>
class pointer_to_binary_function : public binary_function<_Arg1, _Arg2, _Result>
{
    _Result (*__f_)(_Arg1, _Arg2);
public:
    _LIBCPP_INLINE_VISIBILITY explicit pointer_to_binary_function(_Result (*__f)(_Arg1, _Arg2))
        : __f_(__f) {}
    _LIBCPP_INLINE_VISIBILITY _Result operator()(_Arg1 __x, _Arg2 __y) const
        {return __f_(__x, __y);}
};

template <class _Arg1, class _Arg2, class _Result>
inline _LIBCPP_INLINE_VISIBILITY
pointer_to_binary_function<_Arg1,_Arg2,_Result>
ptr_fun(_Result (*__f)(_Arg1,_Arg2))
    {return pointer_to_binary_function<_Arg1,_Arg2,_Result>(__f);}

template<class _Sp, class _Tp>
class mem_fun_t : public unary_function<_Tp*, _Sp>
{
    _Sp (_Tp::*__p_)();
public:
    _LIBCPP_INLINE_VISIBILITY explicit mem_fun_t(_Sp (_Tp::*__p)())
        : __p_(__p) {}
    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp* __p) const
        {return (__p->*__p_)();}
};

template<class _Sp, class _Tp, class _Ap>
class mem_fun1_t : public binary_function<_Tp*, _Ap, _Sp>
{
    _Sp (_Tp::*__p_)(_Ap);
public:
    _LIBCPP_INLINE_VISIBILITY explicit mem_fun1_t(_Sp (_Tp::*__p)(_Ap))
        : __p_(__p) {}
    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp* __p, _Ap __x) const
        {return (__p->*__p_)(__x);}
};

template<class _Sp, class _Tp>
inline _LIBCPP_INLINE_VISIBILITY
mem_fun_t<_Sp,_Tp>
mem_fun(_Sp (_Tp::*__f)())
    {return mem_fun_t<_Sp,_Tp>(__f);}

template<class _Sp, class _Tp, class _Ap>
inline _LIBCPP_INLINE_VISIBILITY
mem_fun1_t<_Sp,_Tp,_Ap>
mem_fun(_Sp (_Tp::*__f)(_Ap))
    {return mem_fun1_t<_Sp,_Tp,_Ap>(__f);}

template<class _Sp, class _Tp>
class mem_fun_ref_t : public unary_function<_Tp, _Sp>
{
    _Sp (_Tp::*__p_)();
public:
    _LIBCPP_INLINE_VISIBILITY explicit mem_fun_ref_t(_Sp (_Tp::*__p)())
        : __p_(__p) {}
    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp& __p) const
        {return (__p.*__p_)();}
};

template<class _Sp, class _Tp, class _Ap>
class mem_fun1_ref_t : public binary_function<_Tp, _Ap, _Sp>
{
    _Sp (_Tp::*__p_)(_Ap);
public:
    _LIBCPP_INLINE_VISIBILITY explicit mem_fun1_ref_t(_Sp (_Tp::*__p)(_Ap))
        : __p_(__p) {}
    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp& __p, _Ap __x) const
        {return (__p.*__p_)(__x);}
};

template<class _Sp, class _Tp>
inline _LIBCPP_INLINE_VISIBILITY
mem_fun_ref_t<_Sp,_Tp>
mem_fun_ref(_Sp (_Tp::*__f)())
    {return mem_fun_ref_t<_Sp,_Tp>(__f);}

template<class _Sp, class _Tp, class _Ap>
inline _LIBCPP_INLINE_VISIBILITY
mem_fun1_ref_t<_Sp,_Tp,_Ap>
mem_fun_ref(_Sp (_Tp::*__f)(_Ap))
    {return mem_fun1_ref_t<_Sp,_Tp,_Ap>(__f);}

template <class _Sp, class _Tp>
class const_mem_fun_t : public unary_function<const _Tp*, _Sp>
{
    _Sp (_Tp::*__p_)() const;
public:
    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun_t(_Sp (_Tp::*__p)() const)
        : __p_(__p) {}
    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp* __p) const
        {return (__p->*__p_)();}
};

template <class _Sp, class _Tp, class _Ap>
class const_mem_fun1_t : public binary_function<const _Tp*, _Ap, _Sp>
{
    _Sp (_Tp::*__p_)(_Ap) const;
public:
    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun1_t(_Sp (_Tp::*__p)(_Ap) const)
        : __p_(__p) {}
    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp* __p, _Ap __x) const
        {return (__p->*__p_)(__x);}
};

template <class _Sp, class _Tp>
inline _LIBCPP_INLINE_VISIBILITY
const_mem_fun_t<_Sp,_Tp>
mem_fun(_Sp (_Tp::*__f)() const)
    {return const_mem_fun_t<_Sp,_Tp>(__f);}

template <class _Sp, class _Tp, class _Ap>
inline _LIBCPP_INLINE_VISIBILITY
const_mem_fun1_t<_Sp,_Tp,_Ap>
mem_fun(_Sp (_Tp::*__f)(_Ap) const)
    {return const_mem_fun1_t<_Sp,_Tp,_Ap>(__f);}

template <class _Sp, class _Tp>
class const_mem_fun_ref_t : public unary_function<_Tp, _Sp>
{
    _Sp (_Tp::*__p_)() const;
public:
    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun_ref_t(_Sp (_Tp::*__p)() const)
        : __p_(__p) {}
    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp& __p) const
        {return (__p.*__p_)();}
};

template <class _Sp, class _Tp, class _Ap>
class const_mem_fun1_ref_t : public binary_function<_Tp, _Ap, _Sp>
{
    _Sp (_Tp::*__p_)(_Ap) const;
public:
    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun1_ref_t(_Sp (_Tp::*__p)(_Ap) const)
        : __p_(__p) {}
    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp& __p, _Ap __x) const
        {return (__p.*__p_)(__x);}
};

template <class _Sp, class _Tp>
inline _LIBCPP_INLINE_VISIBILITY
const_mem_fun_ref_t<_Sp,_Tp>
mem_fun_ref(_Sp (_Tp::*__f)() const)
    {return const_mem_fun_ref_t<_Sp,_Tp>(__f);}

template <class _Sp, class _Tp, class _Ap>
inline _LIBCPP_INLINE_VISIBILITY
const_mem_fun1_ref_t<_Sp,_Tp,_Ap>
mem_fun_ref(_Sp (_Tp::*__f)(_Ap) const)
    {return const_mem_fun1_ref_t<_Sp,_Tp,_Ap>(__f);}


#ifdef _LIBCPP_HAS_NO_VARIADICS

#include <__functional_03>

#else  // _LIBCPP_HAS_NO_VARIADICS

template <class _Tp>
class __mem_fn
    : public __weak_result_type<_Tp>
{
public:
    // types
    typedef _Tp type;
private:
    type __f_;

public:
    _LIBCPP_INLINE_VISIBILITY __mem_fn(type __f) : __f_(__f) {}

    // invoke
    template <class... _ArgTypes>
       typename __invoke_return<type, _ArgTypes...>::type
          operator() (_ArgTypes&&... __args)
          {
              return __invoke(__f_, _STD::forward<_ArgTypes>(__args)...);
          }
};

template<class _R, class _T>
inline _LIBCPP_INLINE_VISIBILITY
__mem_fn<_R _T::*>
mem_fn(_R _T::* __pm)
{
    return __mem_fn<_R _T::*>(__pm);
}

template<class _R, class _T, class ..._Args>
inline _LIBCPP_INLINE_VISIBILITY
__mem_fn<_R (_T::*)(_Args...)>
mem_fn(_R (_T::* __pm)(_Args...))
{
    return __mem_fn<_R (_T::*)(_Args...)>(__pm);
}

template<class _R, class _T, class ..._Args>
inline _LIBCPP_INLINE_VISIBILITY
__mem_fn<_R (_T::*)(_Args...) const>
mem_fn(_R (_T::* __pm)(_Args...) const)
{
    return __mem_fn<_R (_T::*)(_Args...) const>(__pm);
}

template<class _R, class _T, class ..._Args>
inline _LIBCPP_INLINE_VISIBILITY
__mem_fn<_R (_T::*)(_Args...) volatile>
mem_fn(_R (_T::* __pm)(_Args...) volatile)
{
    return __mem_fn<_R (_T::*)(_Args...) volatile>(__pm);
}

template<class _R, class _T, class ..._Args>
inline _LIBCPP_INLINE_VISIBILITY
__mem_fn<_R (_T::*)(_Args...) const volatile>
mem_fn(_R (_T::* __pm)(_Args...) const volatile)
{
    return __mem_fn<_R (_T::*)(_Args...) const volatile>(__pm);
}

// bad_function_call

class bad_function_call
    : public exception
{
};

template<class _Fp> class function; // undefined

namespace __function
{

template<class _R, class ..._ArgTypes>
struct __maybe_derive_from_unary_function
{
};

template<class _R, class _A1>
struct __maybe_derive_from_unary_function<_R(_A1)>
    : public unary_function<_A1, _R>
{
};

template<class _R, class ..._ArgTypes>
struct __maybe_derive_from_binary_function
{
};

template<class _R, class _A1, class _A2>
struct __maybe_derive_from_binary_function<_R(_A1, _A2)>
    : public binary_function<_A1, _A2, _R>
{
};

template<class _Fp> class __base;

template<class _R, class ..._ArgTypes>
class __base<_R(_ArgTypes...)>
{
    __base(const __base&);
    __base& operator=(const __base&);
public:
    __base() {}
    virtual ~__base() {}
    virtual __base* __clone() const = 0;
    virtual void __clone(__base*) const = 0;
    virtual void destroy() = 0;
    virtual void destroy_deallocate() = 0;
    virtual _R operator()(_ArgTypes&& ...) = 0;
    virtual const void* target(const type_info&) const = 0;
    virtual const std::type_info& target_type() const = 0;
};

template<class _FD, class _Alloc, class _FB> class __func;

template<class _F, class _Alloc, class _R, class ..._ArgTypes>
class __func<_F, _Alloc, _R(_ArgTypes...)>
    : public  __base<_R(_ArgTypes...)>
{
    __compressed_pair<_F, _Alloc> __f_;
public:
    explicit __func(_F __f) : __f_(_STD::move(__f)) {}
    explicit __func(_F __f, _Alloc __a) : __f_(_STD::move(__f), _STD::move(__a)) {}
    virtual __base<_R(_ArgTypes...)>* __clone() const;
    virtual void __clone(__base<_R(_ArgTypes...)>*) const;
    virtual void destroy();
    virtual void destroy_deallocate();
    virtual _R operator()(_ArgTypes&& ... __arg);
    virtual const void* target(const type_info&) const;
    virtual const std::type_info& target_type() const;
};

template<class _F, class _Alloc, class _R, class ..._ArgTypes>
__base<_R(_ArgTypes...)>*
__func<_F, _Alloc, _R(_ArgTypes...)>::__clone() const
{
    typedef typename _Alloc::template rebind<__func>::other _A;
    _A __a(__f_.second());
    typedef __allocator_destructor<_A> _D;
    unique_ptr<__func, _D> __hold(__a.allocate(1), _D(__a, 1));
    ::new (__hold.get()) __func(__f_.first(), _Alloc(__a));
    return __hold.release();
}

template<class _F, class _Alloc, class _R, class ..._ArgTypes>
void
__func<_F, _Alloc, _R(_ArgTypes...)>::__clone(__base<_R(_ArgTypes...)>* __p) const
{
    ::new (__p) __func(__f_.first(), __f_.second());
}

template<class _F, class _Alloc, class _R, class ..._ArgTypes>
void
__func<_F, _Alloc, _R(_ArgTypes...)>::destroy()
{
    __f_.~__compressed_pair<_F, _Alloc>();
}

template<class _F, class _Alloc, class _R, class ..._ArgTypes>
void
__func<_F, _Alloc, _R(_ArgTypes...)>::destroy_deallocate()
{
    typedef typename _Alloc::template rebind<__func>::other _A;
    _A __a(__f_.second());
    __f_.~__compressed_pair<_F, _Alloc>();
    __a.deallocate(this, 1);
}

template<class _F, class _Alloc, class _R, class ..._ArgTypes>
_R
__func<_F, _Alloc, _R(_ArgTypes...)>::operator()(_ArgTypes&& ... __arg)
{
    return __invoke(__f_.first(), _STD::forward<_ArgTypes>(__arg)...);
}

template<class _F, class _Alloc, class _R, class ..._ArgTypes>
const void*
__func<_F, _Alloc, _R(_ArgTypes...)>::target(const type_info& __ti) const
{
    if (__ti == typeid(_F))
        return &__f_.first();
    return (const void*)0;
}

template<class _F, class _Alloc, class _R, class ..._ArgTypes>
const std::type_info&
__func<_F, _Alloc, _R(_ArgTypes...)>::target_type() const
{
    return typeid(_F);
}

}  // __function

template<class _R, class ..._ArgTypes>
class function<_R(_ArgTypes...)>
    : public __function::__maybe_derive_from_unary_function<_R(_ArgTypes...)>,
      public __function::__maybe_derive_from_binary_function<_R(_ArgTypes...)>
{
    typedef __function::__base<_R(_ArgTypes...)> __base;
    aligned_storage<3*sizeof(void*)>::type __buf_;
    __base* __f_;

    template <class _F>
        static bool __not_null(const _F&) {return true;}
    template <class _R2, class ..._A>
        static bool __not_null(_R2 (*__p)(_A...)) {return __p;}
    template <class _R2, class _C, class ..._A>
        static bool __not_null(_R2 (_C::*__p)(_A...)) {return __p;}
    template <class _R2, class _C, class ..._A>
        static bool __not_null(_R2 (_C::*__p)(_A...) const) {return __p;}
    template <class _R2, class _C, class ..._A>
        static bool __not_null(_R2 (_C::*__p)(_A...) volatile) {return __p;}
    template <class _R2, class _C, class ..._A>
        static bool __not_null(_R2 (_C::*__p)(_A...) const volatile) {return __p;}
    template <class _R2, class ..._A>
        static bool __not_null(const function<_R(_A...)>& __p) {return __p;}
public:
    typedef _R result_type;

    // 20.7.16.2.1, construct/copy/destroy:
    explicit function() : __f_(0) {}
    function(nullptr_t) : __f_(0) {}
    function(const function&);
#ifdef _LIBCPP_MOVE
    function(function&&);
#endif
    template<class _F>
      function(_F,
               typename enable_if<!is_integral<_F>::value>::type* = 0);

//     template<class _Alloc>
//       function(allocator_arg_t, const _Alloc&);
//     template<Allocator Alloc>
//       function(allocator_arg_t, const Alloc&, nullptr_t);
//     template<Allocator Alloc>
//       function(allocator_arg_t, const Alloc&, const function&);
//     template<Allocator Alloc>
//       function(allocator_arg_t, const Alloc&, function&&);
//     template<class F, Allocator Alloc>
//       function(allocator_arg_t, const Alloc&, F);

    function& operator=(const function&);
    function& operator=(function&&);
    function& operator=(nullptr_t);
    template<class _F>
      typename enable_if
      <
        !is_integral<typename decay<_F>::type>::value,
        function&
      >::type
      operator=(_F&&);

    ~function();

    // 20.7.16.2.2, function modifiers:
    void swap(function&);
//     template<class _F, class _Alloc>
//       void assign(_F, const _Alloc&);

    // 20.7.16.2.3, function capacity:
    /*explicit*/ operator bool() const {return __f_;}

private:
    // deleted overloads close possible hole in the type system
    template<class _R2, class... _ArgTypes2>
      bool operator==(const function<_R2(_ArgTypes2...)>&);// = delete;
    template<class _R2, class... _ArgTypes2>
      bool operator!=(const function<_R2(_ArgTypes2...)>&);// = delete;
public:
    // 20.7.16.2.4, function invocation:
    _R operator()(_ArgTypes...) const;

    // 20.7.16.2.5, function target access:
    const std::type_info& target_type() const;
    template <typename _T> _T* target();
    template <typename _T> const _T* target() const;
};

template<class _R, class ..._ArgTypes>
function<_R(_ArgTypes...)>::function(const function& __f)
{
    if (__f.__f_ == 0)
        __f_ = 0;
    else if (__f.__f_ == (const __base*)&__f.__buf_)
    {
        __f_ = (__base*)&__buf_;
        __f.__f_->__clone(__f_);
    }
    else
        __f_ = __f.__f_->__clone();
}

template<class _R, class ..._ArgTypes>
function<_R(_ArgTypes...)>::function(function&& __f)
{
    if (__f.__f_ == 0)
        __f_ = 0;
    else if (__f.__f_ == (__base*)&__f.__buf_)
    {
        __f_ = (__base*)&__buf_;
        __f.__f_->__clone(__f_);
    }
    else
    {
        __f_ = __f.__f_;
        __f.__f_ = 0;
    }
}

template<class _R, class ..._ArgTypes>
template <class _F>
function<_R(_ArgTypes...)>::function(_F __f,
                                     typename enable_if<!is_integral<_F>::value>::type*)
    : __f_(0)
{
    if (__not_null(__f))
    {
        typedef __function::__func<_F, allocator<_F>, _R(_ArgTypes...)> _FF;
        if (sizeof(_FF) <= sizeof(__buf_))
        {
            __f_ = (__base*)&__buf_;
            ::new (__f_) _FF(_STD::move(__f));
        }
        else
        {
            typedef allocator<_FF> _A;
            _A __a;
            typedef __allocator_destructor<_A> _D;
            unique_ptr<__base, _D> __hold(__a.allocate(1), _D(__a, 1));
            ::new (__hold.get()) _FF(_STD::move(__f), allocator<_F>(__a));
            __f_ = __hold.release();
        }
    }
}

template<class _R, class ..._ArgTypes>
function<_R(_ArgTypes...)>&
function<_R(_ArgTypes...)>::operator=(const function& __f)
{
    function(__f).swap(*this);
    return *this;
}

template<class _R, class ..._ArgTypes>
function<_R(_ArgTypes...)>&
function<_R(_ArgTypes...)>::operator=(function&& __f)
{
    if (__f_ == (__base*)&__buf_)
        __f_->destroy();
    else if (__f_)
        __f_->destroy_deallocate();
    __f_ = 0;
    if (__f.__f_ == 0)
        __f_ = 0;
    else if (__f.__f_ == (__base*)&__f.__buf_)
    {
        __f_ = (__base*)&__buf_;
        __f.__f_->__clone(__f_);
    }
    else
    {
        __f_ = __f.__f_;
        __f.__f_ = 0;
    }
}

template<class _R, class ..._ArgTypes>
function<_R(_ArgTypes...)>&
function<_R(_ArgTypes...)>::operator=(nullptr_t)
{
    if (__f_ == (__base*)&__buf_)
        __f_->destroy();
    else if (__f_)
        __f_->destroy_deallocate();
    __f_ = 0;
}

template<class _R, class ..._ArgTypes>
template <class _F>
typename enable_if
<
    !is_integral<typename decay<_F>::type>::value,
    function<_R(_ArgTypes...)>&
>::type
function<_R(_ArgTypes...)>::operator=(_F&& __f)
{
    function(_STD::forward<_F>(__f)).swap(*this);
    return *this;
}

template<class _R, class ..._ArgTypes>
function<_R(_ArgTypes...)>::~function()
{
    if (__f_ == (__base*)&__buf_)
        __f_->destroy();
    else if (__f_)
        __f_->destroy_deallocate();
}

template<class _R, class ..._ArgTypes>
void
function<_R(_ArgTypes...)>::swap(function& __f)
{
    if (__f_ == (__base*)&__buf_ && __f.__f_ == (__base*)&__f.__buf_)
    {
        typename aligned_storage<sizeof(__buf_)>::type __tempbuf;
        __base* __t = (__base*)&__tempbuf;
        __f_->__clone(__t);
        __f_->destroy();
        __f_ = 0;
        __f.__f_->__clone((__base*)&__buf_);
        __f.__f_->destroy();
        __f.__f_ = 0;
        __f_ = (__base*)&__buf_;
        __t->__clone((__base*)&__f.__buf_);
        __t->destroy();
        __f.__f_ = (__base*)&__f.__buf_;
    }
    else if (__f_ == (__base*)&__buf_)
    {
        __f_->__clone((__base*)&__f.__buf_);
        __f_->destroy();
        __f_ = __f.__f_;
        __f.__f_ = (__base*)&__f.__buf_;
    }
    else if (__f.__f_ == (__base*)&__f.__buf_)
    {
        __f.__f_->__clone((__base*)&__buf_);
        __f.__f_->destroy();
        __f.__f_ = __f_;
        __f_ = (__base*)&__buf_;
    }
    else
        _STD::swap(__f_, __f.__f_);
}

template<class _R, class ..._ArgTypes>
_R
function<_R(_ArgTypes...)>::operator()(_ArgTypes... __arg) const
{
    if (__f_ == 0)
        throw bad_function_call();
    return (*__f_)(_STD::forward<_ArgTypes>(__arg)...);
}

template<class _R, class ..._ArgTypes>
const std::type_info&
function<_R(_ArgTypes...)>::target_type() const
{
    if (__f_ == 0)
        return typeid(void);
    return __f_->target_type();
}

template<class _R, class ..._ArgTypes>
template <typename _T>
_T*
function<_R(_ArgTypes...)>::target()
{
    if (__f_ == 0)
        return (_T*)0;
    return (_T*)__f_->target(typeid(_T));
}

template<class _R, class ..._ArgTypes>
template <typename _T>
const _T*
function<_R(_ArgTypes...)>::target() const
{
    if (__f_ == 0)
        return (const _T*)0;
    return (const _T*)__f_->target(typeid(_T));
}

template <class _R, class... _ArgTypes> 
inline _LIBCPP_INLINE_VISIBILITY
bool
operator==(const function<_R(_ArgTypes...)>& __f, nullptr_t) {return !__f;}

template <class _R, class... _ArgTypes> 
inline _LIBCPP_INLINE_VISIBILITY
bool
operator==(nullptr_t, const function<_R(_ArgTypes...)>& __f) {return !__f;}

template <class _R, class... _ArgTypes> 
inline _LIBCPP_INLINE_VISIBILITY
bool
operator!=(const function<_R(_ArgTypes...)>& __f, nullptr_t) {return (bool)__f;}

template <class _R, class... _ArgTypes> 
inline _LIBCPP_INLINE_VISIBILITY
bool
operator!=(nullptr_t, const function<_R(_ArgTypes...)>& __f) {return (bool)__f;}

template <class _R, class... _ArgTypes> 
inline _LIBCPP_INLINE_VISIBILITY
void
swap(function<_R(_ArgTypes...)>& __x, function<_R(_ArgTypes...)>& __y)
{return __x.swap(__y);}

template<class _Tp> struct __is_bind_expression : public false_type {};
template<class _Tp> struct is_bind_expression
    : public __is_bind_expression<typename remove_cv<_Tp>::type> {};

template<class _Tp> struct __is_placeholder : public integral_constant<int, 0> {};
template<class _Tp> struct is_placeholder
    : public __is_placeholder<typename remove_cv<_Tp>::type> {};

namespace placeholders
{

template <int _N> struct __ph {};

extern __ph<1>   _1;
extern __ph<2>   _2;
extern __ph<3>   _3;
extern __ph<4>   _4;
extern __ph<5>   _5;
extern __ph<6>   _6;
extern __ph<7>   _7;
extern __ph<8>   _8;
extern __ph<9>   _9;
extern __ph<10> _10;

}  // placeholders

template<int _N>
struct __is_placeholder<placeholders::__ph<_N> >
    : public integral_constant<int, _N> {};

template <class _Tp, class _Uj>
inline _LIBCPP_INLINE_VISIBILITY
_Tp&
__mu(reference_wrapper<_Tp> __t, _Uj&)
{
    return __t.get();
}

template <bool _IsBindExpr, class _Ti, class ..._Uj>
struct __mu_return1 {};

template <class _Ti, class ..._Uj>
struct __mu_return1<true, _Ti, _Uj...>
{
    typedef typename result_of<_Ti(_Uj...)>::type type;
};


template <class _Ti, class ..._Uj, size_t ..._Indx>
inline _LIBCPP_INLINE_VISIBILITY
typename __mu_return1<true, _Ti, _Uj...>::type
__mu_expand(_Ti& __ti, tuple<_Uj...>&& __uj, __tuple_indices<_Indx...>)
{
    return __ti(_STD::forward<typename tuple_element<_Indx, _Uj>::type>(get<_Indx>(__uj))...);
}

template <class _Ti, class ..._Uj>
inline _LIBCPP_INLINE_VISIBILITY
typename enable_if
<
    is_bind_expression<_Ti>::value,
    typename __mu_return1<is_bind_expression<_Ti>::value, _Ti, _Uj...>::type
>::type
__mu(_Ti& __ti, tuple<_Uj...>& __uj)
{
    typedef typename __make_tuple_indices<sizeof...(_Uj)>::type __indices;
    return  __mu_expand(__ti, __uj, __indices());
}

template <bool IsPh, class _Ti, class _Uj>
struct __mu_return2 {};

template <class _Ti, class _Uj>
struct __mu_return2<true, _Ti, _Uj>
{
    typedef typename tuple_element<is_placeholder<_Ti>::value - 1, _Uj>::type type;
};

template <class _Ti, class _Uj>
inline _LIBCPP_INLINE_VISIBILITY
typename enable_if
<
    0 < is_placeholder<_Ti>::value,
    typename __mu_return2<0 < is_placeholder<_Ti>::value, _Ti, _Uj>::type
>::type
__mu(_Ti&, _Uj& __uj)
{
    const size_t _Indx = is_placeholder<_Ti>::value - 1;
    // compiler bug workaround
    typename tuple_element<_Indx, _Uj>::type __t = get<_Indx>(__uj);
    return __t;
//    return _STD::forward<typename tuple_element<_Indx, _Uj>::type>(get<_Indx>(__uj));
}

template <class _Ti, class _Uj>
inline _LIBCPP_INLINE_VISIBILITY
typename enable_if
<
    !is_bind_expression<_Ti>::value &&
    is_placeholder<_Ti>::value == 0 &&
    !__is_reference_wrapper<_Ti>::value,
    _Ti&
>::type
__mu(_Ti& __ti, _Uj& __uj)
{
    return __ti;
}

template <class _Ti, bool IsBindEx, bool IsPh, class _TupleUj>
struct ____mu_return;

template <class _Ti, class ..._Uj>
struct ____mu_return<_Ti, true, false, tuple<_Uj...> >
{
    typedef typename result_of<_Ti(_Uj...)>::type type;
};

template <class _Ti, class _TupleUj>
struct ____mu_return<_Ti, false, true, _TupleUj>
{
    typedef typename tuple_element<is_placeholder<_Ti>::value - 1,
                                   _TupleUj>::type&& type;
};

template <class _Ti, class _TupleUj>
struct ____mu_return<_Ti, false, false, _TupleUj>
{
    typedef _Ti& type;
};

template <class _Ti, class _TupleUj>
struct __mu_return
    : public ____mu_return<_Ti,
                           is_bind_expression<_Ti>::value,
                           0 < is_placeholder<_Ti>::value,
                           _TupleUj>
{
};

template <class _Ti, class _TupleUj>
struct __mu_return<reference_wrapper<_Ti>, _TupleUj>
{
    typedef _Ti& type;
};

template <class _F, class _BoundArgs, class _TupleUj>
struct __bind_return;

template <class _F, class ..._BoundArgs, class _TupleUj>
struct __bind_return<_F, tuple<_BoundArgs...>, _TupleUj>
{
    typedef typename __invoke_return
    <
        _F&,
        typename __mu_return
        <
            _BoundArgs,
            _TupleUj
        >::type...
    >::type type;
};

template <class _F, class ..._BoundArgs, class _TupleUj>
struct __bind_return<_F, const tuple<_BoundArgs...>, _TupleUj>
{
    typedef typename __invoke_return
    <
        _F&,
        typename __mu_return
        <
            const _BoundArgs,
            _TupleUj
        >::type...
    >::type type;
};

template <class _F, class _BoundArgs, size_t ..._Indx, class _Args>
inline _LIBCPP_INLINE_VISIBILITY
typename __bind_return<_F, _BoundArgs, _Args>::type
__apply_functor(_F& __f, _BoundArgs& __bound_args, __tuple_indices<_Indx...>,
                _Args&& __args)
{
    return __invoke(__f, __mu(get<_Indx>(__bound_args), __args)...);
}

template<class _F, class ..._BoundArgs> 
class __bind
    : public __weak_result_type<_F>
{
    _F __f_;
    tuple<_BoundArgs...> __bound_args_;

    typedef typename __make_tuple_indices<sizeof...(_BoundArgs)>::type __indices;
public:
    __bind(__bind&& __b)
        : __f_(_STD::move(__b.__f_)),
          __bound_args_(_STD::move(__b.__bound_args_)) {}

    template <class _G, class ..._BA>
      explicit __bind(_G&& __f, _BA&& ...__bound_args)
        : __f_(_STD::forward<_G>(__f)),
          __bound_args_(_STD::forward<_BA>(__bound_args)...) {}

    template <class ..._Args>
        typename __bind_return<_F, tuple<_BoundArgs...>, tuple<_Args&&...> >::type
        operator()(_Args&& ...__args)
        {
            // compiler bug workaround
            return __apply_functor(__f_, __bound_args_, __indices(), 
                                  tuple<_Args&&...>(__args...));
        }

    template <class ..._Args>
        typename __bind_return<_F, tuple<_BoundArgs...>, tuple<_Args&&...> >::type
        operator()(_Args&& ...__args) const
        {
            return __apply_functor(__f_, __bound_args_, __indices(), 
                                   tuple<_Args&&...>(__args...));
        }
};

template<class _F, class ..._BoundArgs> 
struct __is_bind_expression<__bind<_F, _BoundArgs...> > : public true_type {};

template<class _R, class _F, class ..._BoundArgs> 
class __bind_r
    : public __bind<_F, _BoundArgs...>
{
    typedef __bind<_F, _BoundArgs...> base;
public:
    typedef _R result_type;

    template <class _G, class ..._BA>
      explicit __bind_r(_G&& __f, _BA&& ...__bound_args)
        : base(_STD::forward<_G>(__f),
               _STD::forward<_BA>(__bound_args)...) {}

    template <class ..._Args>
        result_type
        operator()(_Args&& ...__args)
        {
            return base::operator()(_STD::forward<_Args>(__args)...);
        }

    template <class ..._Args>
        result_type
        operator()(_Args&& ...__args) const
        {
            return base::operator()(_STD::forward<_Args>(__args)...);
        }
};

template<class _R, class _F, class ..._BoundArgs> 
struct __is_bind_expression<__bind_r<_R, _F, _BoundArgs...> > : public true_type {};

template<class _F, class ..._BoundArgs> 
inline _LIBCPP_INLINE_VISIBILITY
__bind<typename decay<_F>::type, typename decay<_BoundArgs>::type...>
bind(_F&& __f, _BoundArgs&&... __bound_args)
{
    typedef __bind<typename decay<_F>::type, typename decay<_BoundArgs>::type...> type;
    return type(_STD::forward<_F>(__f), _STD::forward<_BoundArgs>(__bound_args)...);
}

template<class _R, class _F, class ..._BoundArgs> 
inline _LIBCPP_INLINE_VISIBILITY
__bind_r<_R, typename decay<_F>::type, typename decay<_BoundArgs>::type...>
bind(_F&& __f, _BoundArgs&&... __bound_args)
{
    typedef __bind_r<_R, typename decay<_F>::type, typename decay<_BoundArgs>::type...> type;
    return type(_STD::forward<_F>(__f), _STD::forward<_BoundArgs>(__bound_args)...);
}

#endif  // _LIBCPP_HAS_NO_VARIADICS

template <>
struct hash<bool>
    : public unary_function<bool, size_t>
{
    size_t operator()(bool __v) const {return static_cast<size_t>(__v);}
};

template <>
struct hash<char>
    : public unary_function<char, size_t>
{
    size_t operator()(char __v) const {return static_cast<size_t>(__v);}
};

template <>
struct hash<signed char>
    : public unary_function<signed char, size_t>
{
    size_t operator()(signed char __v) const {return static_cast<size_t>(__v);}
};

template <>
struct hash<unsigned char>
    : public unary_function<unsigned char, size_t>
{
    size_t operator()(unsigned char __v) const {return static_cast<size_t>(__v);}
};

#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS

template <>
struct hash<char16_t>
    : public unary_function<char16_t, size_t>
{
    size_t operator()(char16_t __v) const {return static_cast<size_t>(__v);}
};

template <>
struct hash<char32_t>
    : public unary_function<char32_t, size_t>
{
    size_t operator()(char32_t __v) const {return static_cast<size_t>(__v);}
};

#endif

template <>
struct hash<wchar_t>
    : public unary_function<wchar_t, size_t>
{
    size_t operator()(wchar_t __v) const {return static_cast<size_t>(__v);}
};

template <>
struct hash<short>
    : public unary_function<short, size_t>
{
    size_t operator()(short __v) const {return static_cast<size_t>(__v);}
};

template <>
struct hash<unsigned short>
    : public unary_function<unsigned short, size_t>
{
    size_t operator()(unsigned short __v) const {return static_cast<size_t>(__v);}
};

template <>
struct hash<int>
    : public unary_function<int, size_t>
{
    size_t operator()(int __v) const {return static_cast<size_t>(__v);}
};

template <>
struct hash<unsigned int>
    : public unary_function<unsigned int, size_t>
{
    size_t operator()(unsigned int __v) const {return static_cast<size_t>(__v);}
};

template <>
struct hash<long>
    : public unary_function<long, size_t>
{
    size_t operator()(long __v) const {return static_cast<size_t>(__v);}
};

template <>
struct hash<unsigned long>
    : public unary_function<unsigned long, size_t>
{
    size_t operator()(unsigned long __v) const {return static_cast<size_t>(__v);}
};

template <>
struct hash<long long>
    : public unary_function<long long, size_t>
{
    size_t operator()(long long __v) const
    {
        size_t __r = 0;
        const size_t* const __p = reinterpret_cast<const size_t*>(&__v);
        for (unsigned __i = 0; __i < sizeof(argument_type)/sizeof(size_t); ++__i)
            __r ^= __p[__i];
        return __r;
    }
};

template <>
struct hash<unsigned long long>
    : public unary_function<unsigned long long, size_t>
{
    size_t operator()(unsigned long long __v) const
    {
        size_t __r = 0;
        const size_t* const __p = reinterpret_cast<const size_t*>(&__v);
        for (unsigned __i = 0; __i < sizeof(argument_type)/sizeof(size_t); ++__i)
            __r ^= __p[__i];
        return __r;
    }
};

template <>
struct hash<float>
    : public unary_function<float, size_t>
{
    size_t operator()(float __v) const
    {
        if (__v == 0)
            return 0;
        const size_t* const __p = reinterpret_cast<const size_t*>(&__v);
        return *__p;
    }
};

template <>
struct hash<double>
    : public unary_function<double, size_t>
{
    size_t operator()(double __v) const
    {
        if (__v == 0)
            return 0;
        size_t __r = 0;
        const size_t* const __p = reinterpret_cast<const size_t*>(&__v);
        for (unsigned __i = 0; __i < sizeof(argument_type)/sizeof(size_t); ++__i)
            __r ^= __p[__i];
        return __r;
    }
};

template <>
struct hash<long double>
    : public unary_function<long double, size_t>
{
    size_t operator()(long double __v) const
    {
        if (__v == 0)
            return 0;
        size_t __r = 0;
        const size_t* const __p = reinterpret_cast<const size_t*>(&__v);
        for (unsigned __i = 0; __i < sizeof(argument_type)/sizeof(size_t); ++__i)
            __r ^= __p[__i];
        return __r;
    }
};

template<class _Tp>
struct hash<_Tp*>
    : public unary_function<_Tp*, size_t>
{
    size_t operator()(_Tp* __v) const
    {
        const size_t* const __p = reinterpret_cast<const size_t*>(&__v);
        return *__p;
    }
};

_LIBCPP_END_NAMESPACE_STD

#endif  // _LIBCPP_FUNCTIONAL
