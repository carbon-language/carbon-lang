// -*- C++ -*-
//===-------------------------- unordered_map -----------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_UNORDERED_MAP
#define _LIBCPP_UNORDERED_MAP

/*

    unordered_map synopsis

#include <initializer_list>

namespace std
{

template <class Key, class T, class Hash = hash<Key>, class Pred = equal_to<Key>,
          class Alloc = allocator<pair<const Key, T>>>
class unordered_map
{
public:
    // types
    typedef Key                                                        key_type;
    typedef T                                                          mapped_type;
    typedef Hash                                                       hasher;
    typedef Pred                                                       key_equal;
    typedef Alloc                                                      allocator_type;
    typedef pair<const key_type, mapped_type>                          value_type;
    typedef value_type&                                                reference;
    typedef const value_type&                                          const_reference;
    typedef typename allocator_traits<allocator_type>::pointer         pointer;
    typedef typename allocator_traits<allocator_type>::const_pointer   const_pointer;
    typedef typename allocator_traits<allocator_type>::size_type       size_type;
    typedef typename allocator_traits<allocator_type>::difference_type difference_type;

    typedef /unspecified/ iterator;
    typedef /unspecified/ const_iterator;
    typedef /unspecified/ local_iterator;
    typedef /unspecified/ const_local_iterator;

    explicit unordered_map(size_type n = 0, const hasher& hf = hasher(),
                           const key_equal& eql = key_equal(),
                           const allocator_type& a = allocator_type());
    template <class InputIterator>
        unordered_map(InputIterator f, InputIterator l,
                      size_type n = 0, const hasher& hf = hasher(),
                      const key_equal& eql = key_equal(),
                      const allocator_type& a = allocator_type());
    explicit unordered_map(const allocator_type&);
    unordered_map(const unordered_map&);
    unordered_map(const unordered_map&, const Allocator&);
    unordered_map(unordered_map&&);
    unordered_map(unordered_map&&, const Allocator&);
    unordered_map(initializer_list<value_type>, size_type n = 0,
                  const hasher& hf = hasher(), const key_equal& eql = key_equal(),
                  const allocator_type& a = allocator_type());
    ~unordered_map();
    unordered_map& operator=(const unordered_map&);
    unordered_map& operator=(unordered_map&&);
    unordered_map& operator=(initializer_list<value_type>);

    allocator_type get_allocator() const;

    bool      empty() const;
    size_type size() const;
    size_type max_size() const;

    iterator       begin();
    iterator       end();
    const_iterator begin()  const;
    const_iterator end()    const;
    const_iterator cbegin() const;
    const_iterator cend()   const;

    template <class... Args>
        pair<iterator, bool> emplace(Args&&... args);
    template <class... Args>
        iterator emplace_hint(const_iterator position, Args&&... args);
    pair<iterator, bool> insert(const value_type& obj);
    template <class P>
        pair<iterator, bool> insert(P&& obj);
    iterator insert(const_iterator hint, const value_type& obj);
    template <class P>
        iterator insert(const_iterator hint, P&& obj);
    template <class InputIterator>
        void insert(InputIterator first, InputIterator last);
    void insert(initializer_list<value_type>);

    iterator erase(const_iterator position);
    size_type erase(const key_type& k);
    iterator erase(const_iterator first, const_iterator last);
    void clear();

    void swap(unordered_map&);

    hasher hash_function() const;
    key_equal key_eq() const;

    iterator       find(const key_type& k);
    const_iterator find(const key_type& k) const;
    size_type count(const key_type& k) const;
    pair<iterator, iterator>             equal_range(const key_type& k);
    pair<const_iterator, const_iterator> equal_range(const key_type& k) const;

    mapped_type& operator[](const key_type& k);
    mapped_type& operator[](key_type&& k);

    mapped_type&       at(const key_type& k);
    const mapped_type& at(const key_type& k) const;

    size_type bucket_count() const;
    size_type max_bucket_count() const;

    size_type bucket_size(size_type n) const;
    size_type bucket(const key_type& k) const;

    local_iterator       begin(size_type n);
    local_iterator       end(size_type n);
    const_local_iterator begin(size_type n) const;
    const_local_iterator end(size_type n) const;
    const_local_iterator cbegin(size_type n) const;
    const_local_iterator cend(size_type n) const;

    float load_factor() const;
    float max_load_factor() const;
    void max_load_factor(float z);
    void rehash(size_type n);
    void reserve(size_type n);
};

template <class Key, class T, class Hash, class Pred, class Alloc>
    void swap(unordered_map<Key, T, Hash, Pred, Alloc>& x,
              unordered_map<Key, T, Hash, Pred, Alloc>& y);

template <class Key, class T, class Hash, class Pred, class Alloc>
    bool
    operator==(const unordered_map<Key, T, Hash, Pred, Alloc>& x,
               const unordered_map<Key, T, Hash, Pred, Alloc>& y);

template <class Key, class T, class Hash, class Pred, class Alloc>
    bool
    operator!=(const unordered_map<Key, T, Hash, Pred, Alloc>& x,
               const unordered_map<Key, T, Hash, Pred, Alloc>& y);

template <class Key, class T, class Hash = hash<Key>, class Pred = equal_to<Key>,
          class Alloc = allocator<pair<const Key, T>>>
class unordered_multimap
{
public:
    // types
    typedef Key                                                        key_type;
    typedef T                                                          mapped_type;
    typedef Hash                                                       hasher;
    typedef Pred                                                       key_equal;
    typedef Alloc                                                      allocator_type;
    typedef pair<const key_type, mapped_type>                          value_type;
    typedef value_type&                                                reference;
    typedef const value_type&                                          const_reference;
    typedef typename allocator_traits<allocator_type>::pointer         pointer;
    typedef typename allocator_traits<allocator_type>::const_pointer   const_pointer;
    typedef typename allocator_traits<allocator_type>::size_type       size_type;
    typedef typename allocator_traits<allocator_type>::difference_type difference_type;

    typedef /unspecified/ iterator;
    typedef /unspecified/ const_iterator;
    typedef /unspecified/ local_iterator;
    typedef /unspecified/ const_local_iterator;

    explicit unordered_multimap(size_type n = 0, const hasher& hf = hasher(),
                           const key_equal& eql = key_equal(),
                           const allocator_type& a = allocator_type());
    template <class InputIterator>
        unordered_multimap(InputIterator f, InputIterator l,
                      size_type n = 0, const hasher& hf = hasher(),
                      const key_equal& eql = key_equal(),
                      const allocator_type& a = allocator_type());
    explicit unordered_multimap(const allocator_type&);
    unordered_multimap(const unordered_multimap&);
    unordered_multimap(const unordered_multimap&, const Allocator&);
    unordered_multimap(unordered_multimap&&);
    unordered_multimap(unordered_multimap&&, const Allocator&);
    unordered_multimap(initializer_list<value_type>, size_type n = 0,
                  const hasher& hf = hasher(), const key_equal& eql = key_equal(),
                  const allocator_type& a = allocator_type());
    ~unordered_multimap();
    unordered_multimap& operator=(const unordered_multimap&);
    unordered_multimap& operator=(unordered_multimap&&);
    unordered_multimap& operator=(initializer_list<value_type>);

    allocator_type get_allocator() const;

    bool      empty() const;
    size_type size() const;
    size_type max_size() const;

    iterator       begin();
    iterator       end();
    const_iterator begin()  const;
    const_iterator end()    const;
    const_iterator cbegin() const;
    const_iterator cend()   const;

    template <class... Args>
        iterator emplace(Args&&... args);
    template <class... Args>
        iterator emplace_hint(const_iterator position, Args&&... args);
    iterator insert(const value_type& obj);
    template <class P>
        iterator insert(P&& obj);
    iterator insert(const_iterator hint, const value_type& obj);
    template <class P>
        iterator insert(const_iterator hint, P&& obj);
    template <class InputIterator>
        void insert(InputIterator first, InputIterator last);
    void insert(initializer_list<value_type>);

    iterator erase(const_iterator position);
    size_type erase(const key_type& k);
    iterator erase(const_iterator first, const_iterator last);
    void clear();

    void swap(unordered_multimap&);

    hasher hash_function() const;
    key_equal key_eq() const;

    iterator       find(const key_type& k);
    const_iterator find(const key_type& k) const;
    size_type count(const key_type& k) const;
    pair<iterator, iterator>             equal_range(const key_type& k);
    pair<const_iterator, const_iterator> equal_range(const key_type& k) const;

    size_type bucket_count() const;
    size_type max_bucket_count() const;

    size_type bucket_size(size_type n) const;
    size_type bucket(const key_type& k) const;

    local_iterator       begin(size_type n);
    local_iterator       end(size_type n);
    const_local_iterator begin(size_type n) const;
    const_local_iterator end(size_type n) const;
    const_local_iterator cbegin(size_type n) const;
    const_local_iterator cend(size_type n) const;

    float load_factor() const;
    float max_load_factor() const;
    void max_load_factor(float z);
    void rehash(size_type n);
    void reserve(size_type n);
};

template <class Key, class T, class Hash, class Pred, class Alloc>
    void swap(unordered_multimap<Key, T, Hash, Pred, Alloc>& x,
              unordered_multimap<Key, T, Hash, Pred, Alloc>& y);

template <class Key, class T, class Hash, class Pred, class Alloc>
    bool
    operator==(const unordered_multimap<Key, T, Hash, Pred, Alloc>& x,
               const unordered_multimap<Key, T, Hash, Pred, Alloc>& y);

template <class Key, class T, class Hash, class Pred, class Alloc>
    bool
    operator!=(const unordered_multimap<Key, T, Hash, Pred, Alloc>& x,
               const unordered_multimap<Key, T, Hash, Pred, Alloc>& y);

}  // std

*/

#include <__config>
#include <__hash_table>
#include <functional>
#include <stdexcept>

#pragma GCC system_header

_LIBCPP_BEGIN_NAMESPACE_STD

template <class _Tp, class _Hash, bool = is_empty<_Hash>::value>
class __unordered_map_hasher
    : private _Hash
{
public:
    __unordered_map_hasher() : _Hash() {}
    __unordered_map_hasher(const _Hash& __h) : _Hash(__h) {}
    const _Hash& hash_function() const {return *this;}
    size_t operator()(const _Tp& __x) const
        {return static_cast<const _Hash&>(*this)(__x.first);}
    size_t operator()(const typename _Tp::first_type& __x) const
        {return static_cast<const _Hash&>(*this)(__x);}
};

template <class _Tp, class _Hash>
class __unordered_map_hasher<_Tp, _Hash, false>
{
    _Hash __hash_;
public:
    __unordered_map_hasher() : __hash_() {}
    __unordered_map_hasher(const _Hash& __h) : __hash_(__h) {}
    const _Hash& hash_function() const {return __hash_;}
    size_t operator()(const _Tp& __x) const
        {return __hash_(__x.first);}
    size_t operator()(const typename _Tp::first_type& __x) const
        {return __hash_(__x);}
};

template <class _Tp, class _Pred, bool = is_empty<_Pred>::value>
class __unordered_map_equal
    : private _Pred
{
public:
    __unordered_map_equal() : _Pred() {}
    __unordered_map_equal(const _Pred& __p) : _Pred(__p) {}
    const _Pred& key_eq() const {return *this;}
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return static_cast<const _Pred&>(*this)(__x.first, __y.first);}
    bool operator()(const typename _Tp::first_type& __x, const _Tp& __y) const
        {return static_cast<const _Pred&>(*this)(__x, __y.first);}
    bool operator()(const _Tp& __x, const typename _Tp::first_type& __y) const
        {return static_cast<const _Pred&>(*this)(__x.first, __y);}
    bool operator()(const typename _Tp::first_type& __x, 
                    const typename _Tp::first_type& __y) const
        {return static_cast<const _Pred&>(*this)(__x, __y);}
};

template <class _Tp, class _Pred>
class __unordered_map_equal<_Tp, _Pred, false>
{
    _Pred __pred_;
public:
    __unordered_map_equal() : __pred_() {}
    __unordered_map_equal(const _Pred& __p) : __pred_(__p) {}
    const _Pred& key_eq() const {return __pred_;}
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __pred_(__x.first, __y.first);}
    bool operator()(const typename _Tp::first_type& __x, const _Tp& __y) const
        {return __pred_(__x, __y.first);}
    bool operator()(const _Tp& __x, const typename _Tp::first_type& __y) const
        {return __pred_(__x.first, __y);}
    bool operator()(const typename _Tp::first_type& __x,
                    const typename _Tp::first_type& __y) const
        {return __pred_(__x, __y);}
};

template <class _Alloc>
class __hash_map_node_destructor
{
    typedef _Alloc                              allocator_type;
    typedef allocator_traits<allocator_type>    __alloc_traits;
    typedef typename __alloc_traits::value_type::value_type value_type;
public:
    typedef typename __alloc_traits::pointer    pointer;
private:
    typedef typename value_type::first_type     first_type;
    typedef typename value_type::second_type    second_type;

    allocator_type& __na_;

    __hash_map_node_destructor& operator=(const __hash_map_node_destructor&);

public:
    bool __first_constructed;
    bool __second_constructed;

    explicit __hash_map_node_destructor(allocator_type& __na)
        : __na_(__na),
          __first_constructed(false),
          __second_constructed(false)
        {}

#ifdef _LIBCPP_MOVE
    __hash_map_node_destructor(__hash_node_destructor<allocator_type>&& __x)
        : __na_(__x.__na_),
          __first_constructed(__x.__value_constructed),
          __second_constructed(__x.__value_constructed)
        {
            __x.__value_constructed = false;
        }
#else
    __hash_map_node_destructor(const __hash_node_destructor<allocator_type>& __x)
        : __na_(__x.__na_),
          __first_constructed(__x.__value_constructed),
          __second_constructed(__x.__value_constructed)
        {
            const_cast<bool&>(__x.__value_constructed) = false;
        }
#endif

    void operator()(pointer __p)
    {
        if (__second_constructed)
            __alloc_traits::destroy(__na_, addressof(__p->__value_.second));
        if (__first_constructed)
            __alloc_traits::destroy(__na_, addressof(__p->__value_.first));
        if (__p)
            __alloc_traits::deallocate(__na_, __p, 1);
    }
};

template <class _HashIterator>
class __hash_map_iterator
{
    _HashIterator __i_;

    typedef pointer_traits<typename _HashIterator::pointer>      __pointer_traits;
    typedef const typename _HashIterator::value_type::first_type key_type;
    typedef typename _HashIterator::value_type::second_type      mapped_type;
public:
    typedef forward_iterator_tag                                 iterator_category;
    typedef pair<key_type, mapped_type>                          value_type;
    typedef typename _HashIterator::difference_type              difference_type;
    typedef value_type&                                          reference;
    typedef typename __pointer_traits::template
#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES
            rebind<value_type>
#else
            rebind<value_type>::other
#endif
                                                                 pointer;

    __hash_map_iterator() {}

    __hash_map_iterator(_HashIterator __i) : __i_(__i) {}

    reference operator*() const {return *operator->();}
    pointer operator->() const {return (pointer)__i_.operator->();}

    __hash_map_iterator& operator++() {++__i_; return *this;}
    __hash_map_iterator operator++(int)
    {
        __hash_map_iterator __t(*this);
        ++(*this);
        return __t;
    }

    friend bool operator==(const __hash_map_iterator& __x, const __hash_map_iterator& __y)
        {return __x.__i_ == __y.__i_;}
    friend bool operator!=(const __hash_map_iterator& __x, const __hash_map_iterator& __y)
        {return __x.__i_ != __y.__i_;}

    template <class, class, class, class, class> friend class unordered_map;
    template <class, class, class, class, class> friend class unordered_multimap;
    template <class> friend class __hash_const_iterator;
    template <class> friend class __hash_const_local_iterator;
    template <class> friend class __hash_map_const_iterator;
};

template <class _HashIterator>
class __hash_map_const_iterator
{
    _HashIterator __i_;

    typedef pointer_traits<typename _HashIterator::pointer>      __pointer_traits;
    typedef const typename _HashIterator::value_type::first_type key_type;
    typedef typename _HashIterator::value_type::second_type      mapped_type;
public:
    typedef forward_iterator_tag                                 iterator_category;
    typedef pair<key_type, mapped_type>                          value_type;
    typedef typename _HashIterator::difference_type              difference_type;
    typedef const value_type&                                    reference;
    typedef typename __pointer_traits::template
#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES
            rebind<value_type>
#else
            rebind<value_type>::other
#endif
                                                                 pointer;

    __hash_map_const_iterator() {}

    __hash_map_const_iterator(_HashIterator __i) : __i_(__i) {}
    __hash_map_const_iterator(
            __hash_map_iterator<typename _HashIterator::__non_const_iterator> __i)
                : __i_(__i.__i_) {}

    reference operator*() const {return *operator->();}
    pointer operator->() const {return (pointer)__i_.operator->();}

    __hash_map_const_iterator& operator++() {++__i_; return *this;}
    __hash_map_const_iterator operator++(int)
    {
        __hash_map_const_iterator __t(*this);
        ++(*this);
        return __t;
    }

    friend bool operator==(const __hash_map_const_iterator& __x, const __hash_map_const_iterator& __y)
        {return __x.__i_ == __y.__i_;}
    friend bool operator!=(const __hash_map_const_iterator& __x, const __hash_map_const_iterator& __y)
        {return __x.__i_ != __y.__i_;}

    template <class, class, class, class, class> friend class unordered_map;
    template <class, class, class, class, class> friend class unordered_multimap;
    template <class> friend class __hash_const_iterator;
    template <class> friend class __hash_const_local_iterator;
};

template <class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = equal_to<_Key>,
          class _Alloc = allocator<pair<const _Key, _Tp> > >
class unordered_map
{
public:
    // types
    typedef _Key                                           key_type;
    typedef _Tp                                            mapped_type;
    typedef _Hash                                          hasher;
    typedef _Pred                                          key_equal;
    typedef _Alloc                                         allocator_type;
    typedef pair<const key_type, mapped_type>              value_type;
    typedef value_type&                                    reference;
    typedef const value_type&                              const_reference;

private:
    typedef pair<key_type, mapped_type>                    __value_type;
    typedef __unordered_map_hasher<__value_type, hasher>   __hasher;
    typedef __unordered_map_equal<__value_type, key_equal> __key_equal;
    typedef typename allocator_traits<allocator_type>::template
#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES
            rebind_alloc<__value_type>
#else
            rebind_alloc<__value_type>::other
#endif
                                                           __allocator_type;

    typedef __hash_table<__value_type, __hasher,
                         __key_equal,  __allocator_type>   __table;

    __table __table_;

    typedef typename __table::__node_pointer               __node_pointer;
    typedef typename __table::__node_const_pointer         __node_const_pointer;
    typedef typename __table::__node_traits                __node_traits;
    typedef typename __table::__node_allocator             __node_allocator;
    typedef typename __table::__node                       __node;
    typedef __hash_map_node_destructor<__node_allocator>   _D;
    typedef unique_ptr<__node, _D>                         __node_holder;
    typedef allocator_traits<allocator_type>               __alloc_traits;
public:
    typedef typename __alloc_traits::pointer         pointer;
    typedef typename __alloc_traits::const_pointer   const_pointer;
    typedef typename __alloc_traits::size_type       size_type;
    typedef typename __alloc_traits::difference_type difference_type;

    typedef __hash_map_iterator<typename __table::iterator>       iterator;
    typedef __hash_map_const_iterator<typename __table::const_iterator> const_iterator;
    typedef __hash_map_iterator<typename __table::local_iterator> local_iterator;
    typedef __hash_map_const_iterator<typename __table::const_local_iterator> const_local_iterator;

    unordered_map() {} // = default;
    explicit unordered_map(size_type __n, const hasher& __hf = hasher(),
                           const key_equal& __eql = key_equal());
    unordered_map(size_type __n, const hasher& __hf,
                  const key_equal& __eql,
                  const allocator_type& __a);
    template <class _InputIterator>
        unordered_map(_InputIterator __first, _InputIterator __last);
    template <class _InputIterator>
        unordered_map(_InputIterator __first, _InputIterator __last,
                      size_type __n, const hasher& __hf = hasher(),
                      const key_equal& __eql = key_equal());
    template <class _InputIterator>
        unordered_map(_InputIterator __first, _InputIterator __last,
                      size_type __n, const hasher& __hf,
                      const key_equal& __eql,
                      const allocator_type& __a);
    explicit unordered_map(const allocator_type& __a);
    unordered_map(const unordered_map& __u);
    unordered_map(const unordered_map& __u, const allocator_type& __a);
#ifdef _LIBCPP_MOVE
    unordered_map(unordered_map&& __u);
    unordered_map(unordered_map&& __u, const allocator_type& __a);
#endif
    unordered_map(initializer_list<value_type> __il);
    unordered_map(initializer_list<value_type> __il, size_type __n,
                  const hasher& __hf = hasher(), const key_equal& __eql = key_equal());
    unordered_map(initializer_list<value_type> __il, size_type __n,
                  const hasher& __hf, const key_equal& __eql,
                  const allocator_type& __a);
    // ~unordered_map() = default;
    // unordered_map& operator=(const unordered_map& __u) = default;
#ifdef _LIBCPP_MOVE
    unordered_map& operator=(unordered_map&& __u);
#endif
    unordered_map& operator=(initializer_list<value_type> __il);

    allocator_type get_allocator() const
        {return allocator_type(__table_.__node_alloc());}

    bool      empty() const {return __table_.size() == 0;}
    size_type size() const  {return __table_.size();}
    size_type max_size() const {return __table_.max_size();}

    iterator       begin()        {return __table_.begin();}
    iterator       end()          {return __table_.end();}
    const_iterator begin()  const {return __table_.begin();}
    const_iterator end()    const {return __table_.end();}
    const_iterator cbegin() const {return __table_.begin();}
    const_iterator cend()   const {return __table_.end();}

#ifdef _LIBCPP_MOVE
    pair<iterator, bool> emplace()
        {return __table_.__emplace_unique();}

    template <class _A0,
              class = typename enable_if<is_convertible<_A0, value_type>::value>::type>
        pair<iterator, bool> emplace(_A0&& __a0)
            {return __table_.__emplace_unique(_STD::forward<_A0>(__a0));}

    template <class _A0, class... _Args,
              class = typename enable_if<is_convertible<_A0, key_type>::value>::type>
        pair<iterator, bool> emplace(_A0&& __a0, _Args&&... __args);

    iterator emplace_hint(const_iterator)
        {return __table_.__emplace_unique().first;}

    template <class _A0,
              class = typename enable_if<is_convertible<_A0, value_type>::value>::type>
        iterator emplace_hint(const_iterator, _A0&& __a0)
            {return __table_.__emplace_unique(_STD::forward<_A0>(__a0)).first;}

    template <class _A0, class... _Args,
              class = typename enable_if<is_convertible<_A0, key_type>::value>::type>
        iterator emplace_hint(const_iterator, _A0&& __a0, _Args&&... __args)
            {return emplace(_STD::forward<_A0>(__a0),
                            _STD::forward<_Args>(__args)...).first;}
#endif
    pair<iterator, bool> insert(const value_type& __x)
        {return __table_.__insert_unique(__x);}
#ifdef _LIBCPP_MOVE
    template <class _P,
              class = typename enable_if<is_convertible<_P, value_type>::value>::type>
        pair<iterator, bool> insert(_P&& __x)
            {return __table_.__insert_unique(_STD::forward<_P>(__x));}
#endif
    iterator insert(const_iterator, const value_type& __x)
        {return insert(__x).first;}
#ifdef _LIBCPP_MOVE
    template <class _P,
              class = typename enable_if<is_convertible<_P, value_type>::value>::type>
        iterator insert(const_iterator, _P&& __x)
            {return insert(_STD::forward<_P>(__x)).first;}
#endif
    template <class _InputIterator>
        void insert(_InputIterator __first, _InputIterator __last);
    void insert(initializer_list<value_type> __il)
        {insert(__il.begin(), __il.end());}

    iterator erase(const_iterator __p) {return __table_.erase(__p.__i_);}
    size_type erase(const key_type& __k) {return __table_.__erase_unique(__k);}
    iterator erase(const_iterator __first, const_iterator __last)
        {return __table_.erase(__first.__i_, __last.__i_);}
    void clear() {__table_.clear();}

    void swap(unordered_map& __u) {__table_.swap(__u.__table_);}

    hasher hash_function() const
        {return __table_.hash_function().hash_function();}
    key_equal key_eq() const
        {return __table_.key_eq().key_eq();}

    iterator       find(const key_type& __k)       {return __table_.find(__k);}
    const_iterator find(const key_type& __k) const {return __table_.find(__k);}
    size_type count(const key_type& __k) const {return __table_.__count_unique(__k);}
    pair<iterator, iterator>             equal_range(const key_type& __k)
        {return __table_.__equal_range_unique(__k);}
    pair<const_iterator, const_iterator> equal_range(const key_type& __k) const
        {return __table_.__equal_range_unique(__k);}

    mapped_type& operator[](const key_type& __k);
#ifdef _LIBCPP_MOVE
    mapped_type& operator[](key_type&& __k);
#endif

    mapped_type&       at(const key_type& __k);
    const mapped_type& at(const key_type& __k) const;

    size_type bucket_count() const {return __table_.bucket_count();}
    size_type max_bucket_count() const {return __table_.max_bucket_count();}

    size_type bucket_size(size_type __n) const
        {return __table_.bucket_size(__n);}
    size_type bucket(const key_type& __k) const {return __table_.bucket(__k);}

    local_iterator       begin(size_type __n)        {return __table_.begin(__n);}
    local_iterator       end(size_type __n)          {return __table_.end(__n);}
    const_local_iterator begin(size_type __n) const  {return __table_.cbegin(__n);}
    const_local_iterator end(size_type __n) const    {return __table_.cend(__n);}
    const_local_iterator cbegin(size_type __n) const {return __table_.cbegin(__n);}
    const_local_iterator cend(size_type __n) const   {return __table_.cend(__n);}

    float load_factor() const {return __table_.load_factor();}
    float max_load_factor() const {return __table_.max_load_factor();}
    void max_load_factor(float __mlf) {__table_.max_load_factor(__mlf);}
    void rehash(size_type __n) {__table_.rehash(__n);}
    void reserve(size_type __n) {__table_.reserve(__n);}

private:
#ifdef _LIBCPP_MOVE
    template <class _A0, class... _Args,
              class = typename enable_if<is_convertible<_A0, key_type>::value>::type>
        __node_holder __construct_node(_A0&& __a0, _Args&&... __args);
    template <class _A0,
              class = typename enable_if<is_convertible<_A0, value_type>::value>::type>
        __node_holder __construct_node(_A0&& __a0);
#else
    __node_holder __construct_node(const key_type& __k);
#endif
};

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        size_type __n, const hasher& __hf, const key_equal& __eql)
    : __table_(__hf, __eql)
{
    __table_.rehash(__n);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        size_type __n, const hasher& __hf, const key_equal& __eql,
        const allocator_type& __a)
    : __table_(__hf, __eql, __a)
{
    __table_.rehash(__n);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        const allocator_type& __a)
    : __table_(__a)
{
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        _InputIterator __first, _InputIterator __last)
{
    insert(__first, __last);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        _InputIterator __first, _InputIterator __last, size_type __n,
        const hasher& __hf, const key_equal& __eql)
    : __table_(__hf, __eql)
{
    __table_.rehash(__n);
    insert(__first, __last);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        _InputIterator __first, _InputIterator __last, size_type __n,
        const hasher& __hf, const key_equal& __eql, const allocator_type& __a)
    : __table_(__hf, __eql, __a)
{
    __table_.rehash(__n);
    insert(__first, __last);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        const unordered_map& __u)
    : __table_(__u.__table_)
{
    __table_.rehash(__u.bucket_count());
    insert(__u.begin(), __u.end());
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        const unordered_map& __u, const allocator_type& __a)
    : __table_(__u.__table_, __a)
{
    __table_.rehash(__u.bucket_count());
    insert(__u.begin(), __u.end());
}

#ifdef _LIBCPP_MOVE

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        unordered_map&& __u)
    : __table_(_STD::move(__u.__table_))
{
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        unordered_map&& __u, const allocator_type& __a)
    : __table_(_STD::move(__u.__table_), __a)
{
    if (__a != __u.get_allocator())
    {
        iterator __i = __u.begin();
        while (__u.size() != 0)
            __table_.__insert_unique(
                _STD::move(__u.__table_.remove((__i++).__i_)->__value_)
                                    );
    }
}

#endif

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        initializer_list<value_type> __il)
{
    insert(__il.begin(), __il.end());
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        initializer_list<value_type> __il, size_type __n, const hasher& __hf,
        const key_equal& __eql)
    : __table_(__hf, __eql)
{
    __table_.rehash(__n);
    insert(__il.begin(), __il.end());
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        initializer_list<value_type> __il, size_type __n, const hasher& __hf,
        const key_equal& __eql, const allocator_type& __a)
    : __table_(__hf, __eql, __a)
{
    __table_.rehash(__n);
    insert(__il.begin(), __il.end());
}

#ifdef _LIBCPP_MOVE

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator=(unordered_map&& __u)
{
    __table_ = _STD::move(__u.__table_);
    return *this;
}

#endif

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator=(
        initializer_list<value_type> __il)
{
    __table_.__assign_unique(__il.begin(), __il.end());
    return *this;
}

#ifdef _LIBCPP_MOVE

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _A0, class... _Args,
          class // = typename enable_if<is_convertible<_A0, key_type>::value>::type
         >
typename unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::__node_holder
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::__construct_node(_A0&& __a0,
                                                                 _Args&&... __args)
{
    __node_allocator& __na = __table_.__node_alloc();
    __node_holder __h(__node_traits::allocate(__na, 1), _D(__na));
    __node_traits::construct(__na, addressof(__h->__value_.first),
                             _STD::forward<_A0>(__a0));
    __h.get_deleter().__first_constructed = true;
    __node_traits::construct(__na, addressof(__h->__value_.second),
                             _STD::forward<_Args>(__args)...);
    __h.get_deleter().__second_constructed = true;
    return __h;
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _A0,
          class // = typename enable_if<is_convertible<_A0, value_type>::value>::type
         >
typename unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::__node_holder
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::__construct_node(_A0&& __a0)
{
    __node_allocator& __na = __table_.__node_alloc();
    __node_holder __h(__node_traits::allocate(__na, 1), _D(__na));
    __node_traits::construct(__na, addressof(__h->__value_),
                             _STD::forward<_A0>(__a0));
    __h.get_deleter().__first_constructed = true;
    __h.get_deleter().__second_constructed = true;
    return __h;
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _A0, class... _Args,
          class // = typename enable_if<is_convertible<_A0, key_type>::value>::type
         >
pair<typename unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::iterator, bool>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::emplace(_A0&& __a0, _Args&&... __args)
{
    __node_holder __h = __construct_node(_STD::forward<_A0>(__a0),
                                         _STD::forward<_Args>(__args)...);
    pair<iterator, bool> __r = __table_.__node_insert_unique(__h.get());
    if (__r.second)
        __h.release();
    return __r;
}

#else

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
typename unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::__node_holder
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::__construct_node(const key_type& __k)
{
    __node_allocator& __na = __table_.__node_alloc();
    __node_holder __h(__node_traits::allocate(__na, 1), _D(__na));
    __node_traits::construct(__na, addressof(__h->__value_.first), __k);
    __h.get_deleter().__first_constructed = true;
    __node_traits::construct(__na, addressof(__h->__value_.second));
    __h.get_deleter().__second_constructed = true;
    return _STD::move(__h);
}

#endif

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
inline
void
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::insert(_InputIterator __first,
                                                       _InputIterator __last)
{
    for (; __first != __last; ++__first)
        __table_.__insert_unique(*__first);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
_Tp&
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator[](const key_type& __k)
{
    iterator __i = find(__k);
    if (__i != end())
        return __i->second;
    __node_holder __h = __construct_node(__k);
    pair<iterator, bool> __r = __table_.__node_insert_unique(__h.get());
    __h.release();
    return __r.first->second;
}

#ifdef _LIBCPP_MOVE

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
_Tp&
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator[](key_type&& __k)
{
    iterator __i = find(__k);
    if (__i != end())
        return __i->second;
    __node_holder __h = __construct_node(_STD::move(__k));
    pair<iterator, bool> __r = __table_.__node_insert_unique(__h.get());
    __h.release();
    return __r.first->second;
}

#endif

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
_Tp&
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::at(const key_type& __k)
{
    iterator __i = find(__k);
#ifndef _LIBCPP_NO_EXCEPTIONS
    if (__i == end())
        throw out_of_range("unordered_map::at: key not found");
#endif
    return __i->second;
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
const _Tp&
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::at(const key_type& __k) const
{
    const_iterator __i = find(__k);
#ifndef _LIBCPP_NO_EXCEPTIONS
    if (__i == end())
        throw out_of_range("unordered_map::at: key not found");
#endif
    return __i->second;
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline
void
swap(unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
{
    __x.swap(__y);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
bool
operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
           const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
{
    if (__x.size() != __y.size())
        return false;
    typedef typename unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::const_iterator
                                                                 const_iterator;
    for (const_iterator __i = __x.begin(), __ex = __x.end(), __ey = __y.end();
            __i != __ex; ++__i)
    {
        const_iterator __j = __y.find(__i->first);
        if (__j == __ey || !(*__i == *__j))
            return false;
    }
    return true;
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline
bool
operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
           const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
{
    return !(__x == __y);
}

template <class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = equal_to<_Key>,
          class _Alloc = allocator<pair<const _Key, _Tp> > >
class unordered_multimap
{
public:
    // types
    typedef _Key                                           key_type;
    typedef _Tp                                            mapped_type;
    typedef _Hash                                          hasher;
    typedef _Pred                                          key_equal;
    typedef _Alloc                                         allocator_type;
    typedef pair<const key_type, mapped_type>              value_type;
    typedef value_type&                                    reference;
    typedef const value_type&                              const_reference;

private:
    typedef pair<key_type, mapped_type>                    __value_type;
    typedef __unordered_map_hasher<__value_type, hasher>   __hasher;
    typedef __unordered_map_equal<__value_type, key_equal> __key_equal;
    typedef typename allocator_traits<allocator_type>::template
#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES
            rebind_alloc<__value_type>
#else
            rebind_alloc<__value_type>::other
#endif
                                                           __allocator_type;

    typedef __hash_table<__value_type, __hasher,
                         __key_equal,  __allocator_type>   __table;

    __table __table_;

    typedef typename __table::__node_traits                __node_traits;
    typedef typename __table::__node_allocator             __node_allocator;
    typedef typename __table::__node                       __node;
    typedef __hash_map_node_destructor<__node_allocator>   _D;
    typedef unique_ptr<__node, _D>                         __node_holder;
    typedef allocator_traits<allocator_type>               __alloc_traits;
public:
    typedef typename __alloc_traits::pointer         pointer;
    typedef typename __alloc_traits::const_pointer   const_pointer;
    typedef typename __alloc_traits::size_type       size_type;
    typedef typename __alloc_traits::difference_type difference_type;

    typedef __hash_map_iterator<typename __table::iterator>       iterator;
    typedef __hash_map_const_iterator<typename __table::const_iterator> const_iterator;
    typedef __hash_map_iterator<typename __table::local_iterator> local_iterator;
    typedef __hash_map_const_iterator<typename __table::const_local_iterator> const_local_iterator;

    unordered_multimap() {} // = default
    explicit unordered_multimap(size_type __n, const hasher& __hf = hasher(),
                                const key_equal& __eql = key_equal());
    unordered_multimap(size_type __n, const hasher& __hf,
                                const key_equal& __eql,
                                const allocator_type& __a);
    template <class _InputIterator>
        unordered_multimap(_InputIterator __first, _InputIterator __last);
    template <class _InputIterator>
        unordered_multimap(_InputIterator __first, _InputIterator __last,
                      size_type __n, const hasher& __hf = hasher(),
                      const key_equal& __eql = key_equal());
    template <class _InputIterator>
        unordered_multimap(_InputIterator __first, _InputIterator __last,
                      size_type __n, const hasher& __hf,
                      const key_equal& __eql,
                      const allocator_type& __a);
    explicit unordered_multimap(const allocator_type& __a);
    unordered_multimap(const unordered_multimap& __u);
    unordered_multimap(const unordered_multimap& __u, const allocator_type& __a);
#ifdef _LIBCPP_MOVE
    unordered_multimap(unordered_multimap&& __u);
    unordered_multimap(unordered_multimap&& __u, const allocator_type& __a);
#endif
    unordered_multimap(initializer_list<value_type> __il);
    unordered_multimap(initializer_list<value_type> __il, size_type __n,
                       const hasher& __hf = hasher(),
                       const key_equal& __eql = key_equal());
    unordered_multimap(initializer_list<value_type> __il, size_type __n,
                       const hasher& __hf, const key_equal& __eql,
                       const allocator_type& __a);
    // ~unordered_multimap() = default;
    // unordered_multimap& operator=(const unordered_multimap& __u) = default;
#ifdef _LIBCPP_MOVE
    unordered_multimap& operator=(unordered_multimap&& __u);
#endif
    unordered_multimap& operator=(initializer_list<value_type> __il);

    allocator_type get_allocator() const
        {return allocator_type(__table_.__node_alloc());}

    bool      empty() const {return __table_.size() == 0;}
    size_type size() const  {return __table_.size();}
    size_type max_size() const {return __table_.max_size();}

    iterator       begin()        {return __table_.begin();}
    iterator       end()          {return __table_.end();}
    const_iterator begin()  const {return __table_.begin();}
    const_iterator end()    const {return __table_.end();}
    const_iterator cbegin() const {return __table_.begin();}
    const_iterator cend()   const {return __table_.end();}

#ifdef _LIBCPP_MOVE
    iterator emplace()
        {return __table_.__emplace_multi();}

    template <class _A0,
              class = typename enable_if<is_convertible<_A0, value_type>::value>::type>
        iterator emplace(_A0&& __a0)
            {return __table_.__emplace_multi(_STD::forward<_A0>(__a0));}

    template <class _A0, class... _Args,
              class = typename enable_if<is_convertible<_A0, key_type>::value>::type>
        iterator emplace(_A0&& __a0, _Args&&... __args);

    iterator emplace_hint(const_iterator __p)
        {return __table_.__emplace_hint_multi(__p.__i_);}

    template <class _A0,
              class = typename enable_if<is_convertible<_A0, value_type>::value>::type>
        iterator emplace_hint(const_iterator __p, _A0&& __a0)
            {return __table_.__emplace_hint_multi(__p.__i_, _STD::forward<_A0>(__a0));}

    template <class _A0, class... _Args,
              class = typename enable_if<is_convertible<_A0, key_type>::value>::type>
        iterator emplace_hint(const_iterator __p, _A0&& __a0, _Args&&... __args);
#endif
    iterator insert(const value_type& __x) {return __table_.__insert_multi(__x);}
#ifdef _LIBCPP_MOVE
    template <class _P,
              class = typename enable_if<is_convertible<_P, value_type>::value>::type>
        iterator insert(_P&& __x)
            {return __table_.__insert_multi(_STD::forward<_P>(__x));}
#endif
    iterator insert(const_iterator __p, const value_type& __x)
        {return __table_.__insert_multi(__p.__i_, __x);}
#ifdef _LIBCPP_MOVE
    template <class _P,
              class = typename enable_if<is_convertible<_P, value_type>::value>::type>
        iterator insert(const_iterator __p, _P&& __x)
            {return __table_.__insert_multi(__p.__i_, _STD::forward<_P>(__x));}
#endif
    template <class _InputIterator>
        void insert(_InputIterator __first, _InputIterator __last);
    void insert(initializer_list<value_type> __il)
        {insert(__il.begin(), __il.end());}

    iterator erase(const_iterator __p) {return __table_.erase(__p.__i_);}
    size_type erase(const key_type& __k) {return __table_.__erase_multi(__k);}
    iterator erase(const_iterator __first, const_iterator __last)
        {return __table_.erase(__first.__i_, __last.__i_);}
    void clear() {__table_.clear();}

    void swap(unordered_multimap& __u) {__table_.swap(__u.__table_);}

    hasher hash_function() const
        {return __table_.hash_function().hash_function();}
    key_equal key_eq() const
        {return __table_.key_eq().key_eq();}

    iterator       find(const key_type& __k)       {return __table_.find(__k);}
    const_iterator find(const key_type& __k) const {return __table_.find(__k);}
    size_type count(const key_type& __k) const {return __table_.__count_multi(__k);}
    pair<iterator, iterator>             equal_range(const key_type& __k)
        {return __table_.__equal_range_multi(__k);}
    pair<const_iterator, const_iterator> equal_range(const key_type& __k) const
        {return __table_.__equal_range_multi(__k);}

    size_type bucket_count() const {return __table_.bucket_count();}
    size_type max_bucket_count() const {return __table_.max_bucket_count();}

    size_type bucket_size(size_type __n) const
        {return __table_.bucket_size(__n);}
    size_type bucket(const key_type& __k) const {return __table_.bucket(__k);}

    local_iterator       begin(size_type __n)        {return __table_.begin(__n);}
    local_iterator       end(size_type __n)          {return __table_.end(__n);}
    const_local_iterator begin(size_type __n) const  {return __table_.cbegin(__n);}
    const_local_iterator end(size_type __n) const    {return __table_.cend(__n);}
    const_local_iterator cbegin(size_type __n) const {return __table_.cbegin(__n);}
    const_local_iterator cend(size_type __n) const   {return __table_.cend(__n);}

    float load_factor() const {return __table_.load_factor();}
    float max_load_factor() const {return __table_.max_load_factor();}
    void max_load_factor(float __mlf) {__table_.max_load_factor(__mlf);}
    void rehash(size_type __n) {__table_.rehash(__n);}
    void reserve(size_type __n) {__table_.reserve(__n);}

private:
#ifdef _LIBCPP_MOVE
    template <class _A0, class... _Args,
              class = typename enable_if<is_convertible<_A0, key_type>::value>::type>
        __node_holder __construct_node(_A0&& __a0, _Args&&... __args);
    template <class _A0,
              class = typename enable_if<is_convertible<_A0, value_type>::value>::type>
        __node_holder __construct_node(_A0&& __a0);
#endif
};

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        size_type __n, const hasher& __hf, const key_equal& __eql)
    : __table_(__hf, __eql)
{
    __table_.rehash(__n);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        size_type __n, const hasher& __hf, const key_equal& __eql,
        const allocator_type& __a)
    : __table_(__hf, __eql, __a)
{
    __table_.rehash(__n);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        _InputIterator __first, _InputIterator __last)
{
    insert(__first, __last);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        _InputIterator __first, _InputIterator __last, size_type __n,
        const hasher& __hf, const key_equal& __eql)
    : __table_(__hf, __eql)
{
    __table_.rehash(__n);
    insert(__first, __last);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        _InputIterator __first, _InputIterator __last, size_type __n,
        const hasher& __hf, const key_equal& __eql, const allocator_type& __a)
    : __table_(__hf, __eql, __a)
{
    __table_.rehash(__n);
    insert(__first, __last);
}


template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        const allocator_type& __a)
    : __table_(__a)
{
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        const unordered_multimap& __u)
    : __table_(__u.__table_)
{
    __table_.rehash(__u.bucket_count());
    insert(__u.begin(), __u.end());
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        const unordered_multimap& __u, const allocator_type& __a)
    : __table_(__u.__table_, __a)
{
    __table_.rehash(__u.bucket_count());
    insert(__u.begin(), __u.end());
}

#ifdef _LIBCPP_MOVE

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        unordered_multimap&& __u)
    : __table_(_STD::move(__u.__table_))
{
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        unordered_multimap&& __u, const allocator_type& __a)
    : __table_(_STD::move(__u.__table_), __a)
{
    if (__a != __u.get_allocator())
    {
        iterator __i = __u.begin();
        while (__u.size() != 0)
{
            __table_.__insert_multi(
                _STD::move(__u.__table_.remove((__i++).__i_)->__value_)
                                   );
}
    }
}

#endif

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        initializer_list<value_type> __il)
{
    insert(__il.begin(), __il.end());
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        initializer_list<value_type> __il, size_type __n, const hasher& __hf,
        const key_equal& __eql)
    : __table_(__hf, __eql)
{
    __table_.rehash(__n);
    insert(__il.begin(), __il.end());
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        initializer_list<value_type> __il, size_type __n, const hasher& __hf,
        const key_equal& __eql, const allocator_type& __a)
    : __table_(__hf, __eql, __a)
{
    __table_.rehash(__n);
    insert(__il.begin(), __il.end());
}

#ifdef _LIBCPP_MOVE

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::operator=(unordered_multimap&& __u)
{
    __table_ = _STD::move(__u.__table_);
    return *this;
}

#endif

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::operator=(
        initializer_list<value_type> __il)
{
    __table_.__assign_multi(__il.begin(), __il.end());
    return *this;
}

#ifdef _LIBCPP_MOVE

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _A0, class... _Args,
          class // = typename enable_if<is_convertible<_A0, key_type>::value>::type
         >
typename unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::__node_holder
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::__construct_node(
        _A0&& __a0, _Args&&... __args)
{
    __node_allocator& __na = __table_.__node_alloc();
    __node_holder __h(__node_traits::allocate(__na, 1), _D(__na));
    __node_traits::construct(__na, addressof(__h->__value_.first),
                             _STD::forward<_A0>(__a0));
    __h.get_deleter().__first_constructed = true;
    __node_traits::construct(__na, addressof(__h->__value_.second),
                             _STD::forward<_Args>(__args)...);
    __h.get_deleter().__second_constructed = true;
    return __h;
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _A0,
          class // = typename enable_if<is_convertible<_A0, value_type>::value>::type
         >
typename unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::__node_holder
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::__construct_node(_A0&& __a0)
{
    __node_allocator& __na = __table_.__node_alloc();
    __node_holder __h(__node_traits::allocate(__na, 1), _D(__na));
    __node_traits::construct(__na, addressof(__h->__value_),
                             _STD::forward<_A0>(__a0));
    __h.get_deleter().__first_constructed = true;
    __h.get_deleter().__second_constructed = true;
    return __h;
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _A0, class... _Args,
          class // = typename enable_if<is_convertible<_A0, key_type>::value>::type
         >
typename unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::iterator
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::emplace(_A0&& __a0, _Args&&... __args)
{
    __node_holder __h = __construct_node(_STD::forward<_A0>(__a0),
                                         _STD::forward<_Args>(__args)...);
    iterator __r = __table_.__node_insert_multi(__h.get());
    __h.release();
    return __r;
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _A0, class... _Args,
          class // = typename enable_if<is_convertible<_A0, key_type>::value>::type
         >
typename unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::iterator
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::emplace_hint(
        const_iterator __p, _A0&& __a0, _Args&&... __args)
{
    __node_holder __h = __construct_node(_STD::forward<_A0>(__a0),
                                         _STD::forward<_Args>(__args)...);
    iterator __r = __table_.__node_insert_multi(__p.__i_, __h.get());
    __h.release();
    return __r;
}

#endif

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
inline
void
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::insert(_InputIterator __first,
                                                            _InputIterator __last)
{
    for (; __first != __last; ++__first)
        __table_.__insert_multi(*__first);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline
void
swap(unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
{
    __x.swap(__y);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
bool
operator==(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
           const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
{
    if (__x.size() != __y.size())
        return false;
    typedef typename unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::const_iterator
                                                                 const_iterator;
    typedef pair<const_iterator, const_iterator> _EqRng;
    for (const_iterator __i = __x.begin(), __ex = __x.end(); __i != __ex;)
    {
        _EqRng __xeq = __x.equal_range(__i->first);
        _EqRng __yeq = __y.equal_range(__i->first);
        if (_STD::distance(__xeq.first, __xeq.second) !=
            _STD::distance(__yeq.first, __yeq.second) ||
                  !_STD::is_permutation(__xeq.first, __xeq.second, __yeq.first))
            return false;
        __i = __xeq.second;
    }
    return true;
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline
bool
operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
           const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
{
    return !(__x == __y);
}

_LIBCPP_END_NAMESPACE_STD

#endif  // _LIBCPP_UNORDERED_MAP
