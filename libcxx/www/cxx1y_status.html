<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
          "http://www.w3.org/TR/html4/strict.dtd">
<!-- Material used from: HTML 4.01 specs: http://www.w3.org/TR/html401/ -->
<html>
<head>
  <META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
  <title>libc++ C++1Y Status</title>
  <link type="text/css" rel="stylesheet" href="menu.css">
  <link type="text/css" rel="stylesheet" href="content.css">
</head>

<body>
<div id="menu">
  <div>
    <a href="http://llvm.org/">LLVM Home</a>
  </div>

  <div class="submenu">
    <label>libc++ Info</label>
    <a href="/index.html">About</a>
  </div>

  <div class="submenu">
    <label>Quick Links</label>
    <a href="http://lists.cs.uiuc.edu/mailman/listinfo/cfe-dev">cfe-dev</a>
    <a href="http://lists.cs.uiuc.edu/mailman/listinfo/cfe-commits">cfe-commits</a>
    <a href="http://llvm.org/bugs/">Bug Reports</a>
    <a href="http://llvm.org/svn/llvm-project/libcxx/trunk/">Browse SVN</a>
    <a href="http://llvm.org/viewvc/llvm-project/libcxx/trunk/">Browse ViewVC</a>
  </div>
</div>

<div id="content">
  <!--*********************************************************************-->
  <h1>libc++ C++1Y Status</h1>
  <!--*********************************************************************-->

  <p>In April 2013, the C++ standard committee approved the draft for the next version of the C++ standard, known as "C++1Y" (probably to be C++14)</p>
  <p>The draft standard includes papers and issues that were voted on at the previous three meetings (Kona, Portland, and Bristol)</p>
  <p>This page shows the status of libc++; the status of clang's support of the language features is <a href="http://clang.llvm.org/cxx_status.html">here</a>.</p>

  <p>The groups that have contributed papers:
  <ul>
    <li>CWG - Core Language Working group</li>
    <li>LWG - Library working group</li>
    <li>SG1 - Study group #1 (Concurrency working group)</li>
  </ul>
  </p>
  
  <h3>Paper Status</h3>
  <table id="papers" border="1">
	<tr><th>Paper #</th><th>Group</th><th>Paper Name</th><th>Meeting</th><th>Status</th><th>First released version</th></tr>

	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3346.pdf">3346</a></td><td>LWG</td><td>Terminology for Container Element Requirements - Rev 1</td><td>Kona</td><td>Complete</td><td>3.4</td></tr>
	<tr><td></td><td></td><td></td><td></td><td></td><td></td></tr>

<!-- 	<tr><td>3323</td><td>CWG</td><td>A Proposal to Tweak Certain C++ Contextual Conversions, v3</td><td>Portland</td><td></td><td></td></tr> -->
	
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3421.htm">3421</a></td><td>LWG</td><td>Making Operator Functors greater&lt;&gt;</td><td>Portland</td><td>Complete</td><td>3.4</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3462.html">3462</a></td><td>LWG</td><td>std::result_of and SFINAE</td><td>Portland</td><td>Complete</td><td>3.4</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3469.html">3469</a></td><td>LWG</td><td>Constexpr Library Additions: chrono, v3</td><td>Portland</td><td>Complete</td><td>3.4</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3470.html">3470</a></td><td>LWG</td><td>Constexpr Library Additions: containers, v2</td><td>Portland</td><td>Complete</td><td>3.4</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3471.html">3471</a></td><td>LWG</td><td>Constexpr Library Additions: utilities, v3</td><td>Portland</td><td>Complete</td><td>3.4</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3302.html">3302</a></td><td>LWG</td><td>Constexpr Library Additions: complex, v2</td><td>Portland</td><td>Complete</td><td>3.4</td></tr>
	<tr><td></td><td></td><td></td><td></td><td></td><td></td></tr>

<!-- 	<tr><td>3472</td><td>CWG</td><td>Binary Literals in the C++ Core Language</td><td>Bristol</td><td></td><td></td></tr> -->
<!-- 	<tr><td>3624</td><td>CWG</td><td>Core Issue 1512: Pointer comparison vs qualification conversions (revision 3)</td><td>Bristol</td><td></td><td></td></tr> -->
<!-- 	<tr><td>3639</td><td>CWG</td><td>Runtime-sized arrays with automatic storage duration (revision 5)</td><td>Bristol</td><td></td><td></td></tr> -->
<!-- 	<tr><td>3638</td><td>CWG</td><td>Return type deduction for normal functions</td><td>Bristol</td><td></td><td></td></tr> -->
<!-- 	<tr><td>3648</td><td>CWG</td><td>Wording Changes for Generalized Lambda-capture</td><td>Bristol</td><td></td><td></td></tr> -->
<!-- 	<tr><td>3653</td><td>CWG</td><td>Member initializers and aggregates</td><td>Bristol</td><td></td><td></td></tr> -->
<!-- 	<tr><td>3667</td><td>CWG</td><td>Drafting for Core 1402</td><td>Bristol</td><td></td><td></td></tr> -->
<!-- 	<tr><td>3652</td><td>CWG</td><td>Relaxing constraints on constexpr functions" and "constexpr member functions and implicit const</td><td>Bristol</td><td></td><td></td></tr> -->
<!-- 	<tr><td>3664</td><td>CWG</td><td>Clarifying Memory Allocation</td><td>Bristol</td><td></td><td></td></tr> -->
<!-- 	<tr><td>3651</td><td>CWG</td><td>Variable Templates (Revision 1)</td><td>Bristol</td><td></td><td></td></tr> -->
<!-- 	<tr><td>3649</td><td>CWG</td><td>Generic (Polymorphic) Lambda Expressions (Revision 3)</td><td>Bristol</td><td></td><td></td></tr> -->
	
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3545.pdf">3545</a></td><td>LWG</td><td>An Incremental Improvement to integral_constant</td><td>Bristol</td><td>Complete</td><td>3.4</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3644.pdf">3644</a></td><td>LWG</td><td>Null Forward Iterators</td><td>Bristol</td><td>Complete</td><td>3.4</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3668.html">3668</a></td><td>LWG</td><td>std::exchange()</td><td>Bristol</td><td>Complete</td><td>3.4</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3658.html">3658</a></td><td>LWG</td><td>Compile-time integer sequences</td><td>Bristol</td><td>Complete</td><td>3.4</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3670.html">3670</a></td><td>LWG</td><td>Addressing Tuples by Type</td><td>Bristol</td><td>Complete</td><td>3.4</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3671.html">3671</a></td><td>LWG</td><td>Making non-modifying sequence operations more robust</td><td>Bristol</td><td>Complete</td><td>3.4</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3656.htm">3656</a></td><td>LWG</td><td>make_unique</td><td>Bristol</td><td>Complete</td><td>3.4</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3654.html">3654</a></td><td>LWG</td><td>Quoted Strings</td><td>Bristol</td><td>Complete</td><td>3.4</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3642.pdf">3642</a></td><td>LWG</td><td>User-defined Literals</td><td>Bristol</td><td>Complete</td><td>3.4</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3655.pdf">3655</a></td><td>LWG</td><td>TransformationTraits Redux (excluding part 4)</td><td>Bristol</td><td>Complete</td><td>3.4</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3657.htm">3657</a></td><td>LWG</td><td>Adding heterogeneous comparison lookup to associative containers</td><td>Bristol</td><td>Complete</td><td>3.4</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3672.html">3672</a></td><td>LWG</td><td>A proposal to add a utility class to represent optional objects</td><td>Bristol</td><td><I>Removed from Draft Standard</I></td><td>n/a</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3669.pdf">3669</a></td><td>LWG</td><td>Fixing constexpr member functions without const</td><td>Bristol</td><td>Complete</td><td>3.4</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3662.html">3662</a></td><td>LWG</td><td>C++ Dynamic Arrays (dynarray)</td><td>Bristol</td><td><I>Removed from Draft Standard</I></td><td>n/a</td></tr>
	
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3659.html">3659</a></td><td>SG1</td><td>Shared Locking in C++</td><td>Bristol</td><td>Complete</td><td>3.4</td></tr>

 	<tr><td></td><td></td><td></td><td></td><td></td><td></td></tr>
	<tr><td><a href="http://wiki.edg.com/twiki/pub/Wg21chicago2013/FormalMotions/N3779-complex_literals.pdf">3779</a></td><td>LWG</td><td>User-defined Literals for std::complex</td><td>Chicago</td><td>Complete</td><td>3.4</td></tr>
	<tr><td><a href="http://wiki.edg.com/twiki/pub/Wg21chicago2013/FormalMotions/N3789.txt">3789</a></td><td>LWG</td><td>Constexpr Library Additions: functional</td><td>Chicago</td><td>Complete</td><td>3.4</td></tr>
	<tr><td><a href="http://wiki.edg.com/twiki/pub/Wg21chicago2013/FormalMotions/n3778.html">3778</a></td><td>CWG</td><td>Sized deallocation</td><td>Chicago</td><td></td><td></td></tr>
 	<tr><td></td><td></td><td></td><td></td><td></td><td></td></tr>

	<tr><td><a href="http://wiki.edg.com/twiki/pub/Wg21issaquah/FormalMotions/N3924_rand-note-v2.pdf">3924</a></td><td>LWG</td><td>Discouraging rand() in C++14</td><td>Issaquah</td><td></td><td></td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3887">3887</a></td><td>LWG</td><td>Consistent Metafunction Aliases</td><td>Issaquah</td><td></td><td></td></tr>

<!--  	<tr><td></td><td></td><td></td><td></td><td></td><td></td></tr> -->
  </table>

  <h3>Library Working group Issues Status</h3>
<!--   <I>Note: "NAD" means that the issue was deemed "Not a defect"</I> -->
  <table id="issues" border="1">
	<tr><th>Issue #</th><th>Issue Name</th><th>Meeting</th><th>Status</th></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1214">1214</a></td><td>Insufficient/inconsistent key immutability requirements for associative containers</td><td>Kona</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2009">2009</a></td><td>Reporting out-of-bound values on numeric string conversions</td><td>Kona</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2010">2010</a></td><td>is_* traits for binding operations can't be meaningfully specialized</td><td>Kona</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2015">2015</a></td><td>Incorrect pre-conditions for some type traits</td><td>Kona</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2021">2021</a></td><td>Further incorrect usages of result_of</td><td>Kona</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2028">2028</a></td><td>messages_base::catalog overspecified</td><td>Kona</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2033">2033</a></td><td>Preconditions of reserve, shrink_to_fit, and resize functions</td><td>Kona</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2039">2039</a></td><td>Issues with std::reverse and std::copy_if</td><td>Kona</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2044">2044</a></td><td>No definition of "Stable" for copy algorithms</td><td>Kona</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2045">2045</a></td><td>forward_list::merge and forward_list::splice_after with unequal allocators</td><td>Kona</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2047">2047</a></td><td>Incorrect "mixed" move-assignment semantics of unique_ptr</td><td>Kona</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2050">2050</a></td><td>Unordered associative containers do not use allocator_traits to define member types</td><td>Kona</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2053">2053</a></td><td>Errors in regex bitmask types</td><td>Kona</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2061">2061</a></td><td>make_move_iterator and arrays</td><td>Kona</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2064">2064</a></td><td>More noexcept issues in basic_string</td><td>Kona</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2065">2065</a></td><td>Minimal allocator interface</td><td>Kona</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2067">2067</a></td><td>packaged_task should have deleted copy c'tor with const parameter</td><td>Kona</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2069">2069</a></td><td>Inconsistent exception spec for basic_string move constructor</td><td>Kona</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2096">2096</a></td><td>Incorrect constraints of future::get in regard to MoveAssignable</td><td>Kona</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2102">2102</a></td><td>Why is std::launch an implementation-defined type?</td><td>Kona</td><td>Complete</td></tr>
  <tr><td></td><td></td><td></td><td></td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2071">2071</a></td><td>std::valarray move-assignment</td><td>Portland</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2074">2074</a></td><td>Off by one error in std::reverse_copy</td><td>Portland</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2081">2081</a></td><td>Allocator requirements should include CopyConstructible 2083 const-qualification on weak_ptr::owner_before</td><td>Portland</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2083">2083</a></td><td>const-qualification on weak_ptr::owner_before</td><td>Portland</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2086">2086</a></td><td>Overly generic type support for math functions</td><td>Portland</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2099">2099</a></td><td>Unnecessary constraints of va_start() usage</td><td>Portland</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2103">2103</a></td><td>std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::propagate_on_container_move_assignment</td><td>Portland</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2105">2105</a></td><td>Inconsistent requirements on const_iterator's value_type</td><td>Portland</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2110">2110</a></td><td>remove can't swap but note says it might</td><td>Portland</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2123">2123</a></td><td>merge() allocator requirements for lists versus forward lists</td><td>Portland</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2005">2005</a></td><td>unordered_map::insert(T&&) protection should apply to map too</td><td>Portland</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2011">2011</a></td><td>Unexpected output required of strings</td><td>Portland</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2048">2048</a></td><td>Unnecessary mem_fn overloads</td><td>Portland</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2049">2049</a></td><td>is_destructible is underspecified</td><td>Portland</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2056">2056</a></td><td>future_errc enums start with value 0 (invalid value for broken_promise)</td><td>Portland</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2058">2058</a></td><td>valarray and begin/end</td><td>Portland</td><td>Complete</td></tr>
  <tr><td></td><td></td><td></td><td></td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2091">2091</a></td><td>Misplaced effect in m.try_lock_for()</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2092">2092</a></td><td>Vague Wording for condition_variable_any</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2093">2093</a></td><td>Throws clause of condition_variable::wait with predicate</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2094">2094</a></td><td>duration conversion overflow shouldn't participate in overload resolution</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2122">2122</a></td><td>merge() stability for lists versus forward lists</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2128">2128</a></td><td>Absence of global functions cbegin/cend</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2145">2145</a></td><td>error_category default constructor</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2147">2147</a></td><td>Unclear hint type in Allocator's allocate function</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2148">2148</a></td><td>Hashing enums should be supported directly by std::hash</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2149">2149</a></td><td>Concerns about 20.8/5</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2162">2162</a></td><td>allocator_traits::max_size missing noexcept</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2163">2163</a></td><td>nth_element requires inconsistent post-conditions</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2169">2169</a></td><td>Missing reset() requirements in unique_ptr specialization</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2172">2172</a></td><td>Does atomic_compare_exchange_* accept v == nullptr arguments?</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2080">2080</a></td><td>Specify when once_flag becomes invalid</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2098">2098</a></td><td>promise throws clauses</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2109">2109</a></td><td>Incorrect requirements for hash specializations</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2130">2130</a></td><td>missing ordering constraints for fences</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2138">2138</a></td><td>atomic_flag::clear ordering constraints</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2140">2140</a></td><td>notify_all_at_thread_exit synchronization</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2144">2144</a></td><td>Missing noexcept specification in type_index</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2174">2174</a></td><td>wstring_convert::converted() should be noexcept</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2175">2175</a></td><td>string_convert and wbuffer_convert validity</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2176">2176</a></td><td>Special members for wstring_convert and wbuffer_convert</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2177">2177</a></td><td>Requirements on Copy/MoveInsertable</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2185">2185</a></td><td>Missing throws clause for future/shared_future::wait_for/wait_until</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2187">2187</a></td><td>vector&lt;bool&gt; is missing emplace and emplace_back member functions</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2190">2190</a></td><td>ordering of condition variable operations, reflects Posix discussion</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2196">2196</a></td><td>Specification of is_*[copy/move]_[constructible/assignable] unclear for non-referencable types</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2197">2197</a></td><td>Specification of is_[un]signed unclear for non-arithmetic types</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2200">2200</a></td><td>Data race avoidance for all containers, not only for sequences</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2203">2203</a></td><td>scoped_allocator_adaptor uses wrong argument types for piecewise construction</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2207">2207</a></td><td>basic_string::at should not have a Requires clause</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2209">2209</a></td><td>assign() overspecified for sequence containers</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2210">2210</a></td><td>Missing allocator-extended constructor for allocator-aware containers</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2211">2211</a></td><td>Replace ambiguous use of "Allocator" in container requirements</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2222">2222</a></td><td>Inconsistency in description of forward_list::splice_after single-element overload</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2225">2225</a></td><td>Unrealistic header inclusion checks required</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2229">2229</a></td><td>Standard code conversion facets underspecified</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2231">2231</a></td><td>DR 704 removes complexity guarantee for clear()</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2235">2235</a></td><td>Undefined behavior without proper requirements on basic_string constructors</td><td>Bristol</td><td>Complete</td></tr>
    <tr><td></td><td></td><td></td><td></td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2141">2141</a></td><td>common_type trait produces reference types</td><td>Chicago</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2235">2235</a></td><td>Undefined behavior without proper requirements on basic_string constructors</td><td>Chicago</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2246">2246</a></td><td>unique_ptr assignment effects w.r.t. deleter</td><td>Chicago</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2247">2247</a></td><td>Type traits and std::nullptr_t</td><td>Chicago</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2085">2085</a></td><td>Wrong description of effect 1 of basic_istream::ignore</td><td>Chicago</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2087">2087</a></td><td>iostream_category() and noexcept</td><td>Chicago</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2143">2143</a></td><td>ios_base::xalloc should be thread-safe</td><td>Chicago</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2150">2150</a></td><td>Unclear specification of find_end</td><td>Chicago</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2180">2180</a></td><td>Exceptions from std::seed_seq operations</td><td>Chicago</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2194">2194</a></td><td>Impossible container requirements for adaptor types</td><td>Chicago</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2013">2013</a></td><td>Do library implementers have the freedom to add constexpr?</td><td>Chicago</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2018">2018</a></td><td>regex_traits::isctype Returns clause is wrong</td><td>Chicago</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2078">2078</a></td><td>Throw specification of async() incomplete</td><td>Chicago</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2097">2097</a></td><td>packaged_task constructors should be constrained</td><td>Chicago</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2100">2100</a></td><td>Timed waiting functions cannot timeout if launch::async policy used</td><td>Chicago</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2120">2120</a></td><td>What should async do if neither 'async' nor 'deferred' is set in policy?</td><td>Chicago</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2159">2159</a></td><td>atomic_flag initialization</td><td>Chicago</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2275">2275</a></td><td>Why is forward_as_tuple not constexpr?</td><td>Chicago</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2284">2284</a></td><td>Inconsistency in allocator_traits::max_size</td><td>Chicago</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2298">2298</a></td><td>is_nothrow_constructible is always false because of create&lt;&gt;</td><td>Chicago</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2300">2300</a></td><td>Redundant sections for map and multimap members should be removed</td><td>Chicago</td><td>Complete</td></tr>
	<tr><td>National Body comment 'GB 9'</td>                                                        <td>Remove gets from C++14</td><td>Chicago</td><td>Complete</td></tr>
    <tr><td></td><td></td><td></td><td></td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2135">2135</a></td><td>Unclear requirement for exceptions thrown in condition_variable::wait()</td><td>Issaquah</td><td></td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2141">2141</a></td><td>std::hash is vulnerable to collision DoS attack</td><td>Issaquah</td><td></td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2142">2142</a></td><td>packaged_task::operator() synchronization too broad?</td><td>Issaquah</td><td></td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2240">2240</a></td><td>Probable misuse of term "function scope" in [thread.condition]</td><td>Issaquah</td><td></td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2252">2252</a></td><td>Strong guarantee on vector::push_back() still broken with C++11?</td><td>Issaquah</td><td></td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2257">2257</a></td><td>Simplify container requirements with the new algorithms</td><td>Issaquah</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2268">2268</a></td><td>Setting a default argument in the declaration of a member function assign of std::basic_string</td><td>Issaquah</td><td></td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2271">2271</a></td><td>regex_traits::lookup_classname specification unclear</td><td>Issaquah</td><td></td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2272">2272</a></td><td>quoted should use char_traits::eq for character comparison</td><td>Issaquah</td><td></td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2278">2278</a></td><td>User-defined literals for Standard Library types</td><td>Issaquah</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2280">2280</a></td><td>begin / end for arrays should be constexpr and noexcept</td><td>Issaquah</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2285">2285</a></td><td>make_reverse_iterator</td><td>Issaquah</td><td></td></tr>

	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2299">2299</a></td><td>Effects of inaccessible key_compare::is_transparent type are not clear</td><td>Issaquah</td><td>Complete</td></tr>

	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1450">1450</a></td><td>Contradiction in regex_constants</td><td>Issaquah</td><td></td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2003">2003</a></td><td>String exception inconsistency in erase.</td><td>Issaquah</td><td></td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2112">2112</a></td><td>User-defined classes that cannot be derived from</td><td>Issaquah</td><td></td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2132">2132</a></td><td>std::function ambiguity</td><td>Issaquah</td><td></td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2182">2182</a></td><td>Container::[const_]reference types are misleadingly specified</td><td>Issaquah</td><td></td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2188">2188</a></td><td>Reverse iterator does not fully support targets that overload operator&</td><td>Issaquah</td><td></td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2193">2193</a></td><td>Default constructors for standard library containers are explicit</td><td>Issaquah</td><td></td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2205">2205</a></td><td>Problematic postconditions of regex_match and regex_search</td><td>Issaquah</td><td></td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2213">2213</a></td><td>Return value of std::regex_replace</td><td>Issaquah</td><td></td></tr>

	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2258">2258</a></td><td>a.erase(q1, q2) unable to directly return q2</td><td>Issaquah</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2263">2263</a></td><td>Comparing iterators and allocator pointers with different const-character</td><td>Issaquah</td><td></td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2293">2293</a></td><td>Wrong facet used by num_put::do_put</td><td>Issaquah</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2301">2301</a></td><td>Why is std::tie not constexpr?</td><td>Issaquah</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2304">2304</a></td><td>Complexity of count in unordered associative containers</td><td>Issaquah</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2306">2306</a></td><td>match_results::reference should be value_type&, not const value_type&</td><td>Issaquah</td><td></td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2308">2308</a></td><td>Clarify container destructor requirements w.r.t. std::array</td><td>Issaquah</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2313">2313</a></td><td>tuple_size should always derive from integral_constant<size_t, N></td><td>Issaquah</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2314">2314</a></td><td>apply() should return decltype(auto) and use decay_t before tuple_size</td><td>Issaquah</td><td></td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2315">2315</a></td><td>weak_ptr should be movable</td><td>Issaquah</td><td></td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2316">2316</a></td><td>weak_ptr::lock() should be atomic</td><td>Issaquah</td><td></td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2317">2317</a></td><td>The type property queries should be UnaryTypeTraits returning size_t</td><td>Issaquah</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2320">2320</a></td><td>select_on_container_copy_construction() takes allocators, not containers</td><td>Issaquah</td><td></td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2322">2322</a></td><td>Associative(initializer_list, stuff) constructors are underspecified</td><td>Issaquah</td><td></td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2323">2323</a></td><td>vector::resize(n, t)'s specification should be simplified</td><td>Issaquah</td><td></td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2324">2324</a></td><td>Insert iterator constructors should use addressof()</td><td>Issaquah</td><td></td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2329">2329</a></td><td>regex_match()/regex_search() with match_results should forbid temporary strings</td><td>Issaquah</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2330">2330</a></td><td>regex("meow", regex::icase) is technically forbidden but should be permitted</td><td>Issaquah</td><td></td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2332">2332</a></td><td>regex_iterator/regex_token_iterator should forbid temporary regexes</td><td>Issaquah</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2339">2339</a></td><td>Wording issue in nth_element</td><td>Issaquah</td><td></td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2341">2341</a></td><td>Inconsistency between basic_ostream::seekp(pos) and basic_ostream::seekp(off, dir)</td><td>Issaquah</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2344">2344</a></td><td>quoted()'s interaction with padding is unclear</td><td>Issaquah</td><td></td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2346">2346</a></td><td>integral_constant's member functions should be marked noexcept</td><td>Issaquah</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2350">2350</a></td><td>min, max, and minmax should be constexpr</td><td>Issaquah</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2356">2356</a></td><td>Stability of erasure in unordered associative containers</td><td>Issaquah</td><td></td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2357">2357</a></td><td>Remaining "Assignable" requirement</td><td>Issaquah</td><td></td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2359">2359</a></td><td>How does regex_constants::nosubs affect basic_regex::mark_count()?</td><td>Issaquah</td><td></td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2360">2360</a></td><td>reverse_iterator::operator*() is unimplementable</td><td>Issaquah</td><td></td></tr>
<!-- 	<tr><td></td><td></td><td></td><td></td></tr> -->
  </table>

  <p>Last Updated: 14-Feb-2014</p>
</div>
</body>
</html>
