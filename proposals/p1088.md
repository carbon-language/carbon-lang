# Generic details 10: interface implemented requirements

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/1088)

<!-- toc -->

## Table of contents

-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Details](#details)
-   [Rationale based on Carbon's goals](#rationale-based-on-carbons-goals)
-   [Alternatives considered](#alternatives-considered)
    -   [Less strict about requirements with `where` clauses](#less-strict-about-requirements-with-where-clauses)

<!-- tocstop -->

## Problem

TODO: What problem are you trying to solve? How important is that problem? Who
is impacted by it?

## Background

TODO: Is there any background that readers should consider to fully understand
this problem and your approach to solving it?

## Proposal

-   Requiring another type to implement an interface
    ```
    interface IntLike {
      impl i32 as As(Self);
    }
    interface CommonTypeWith(T:! Type) {
      impl T as CommonTypeWith(Self);
    }
    ```
-   Difficulty of `where` clauses.
-   Observe declarations for saying types implement interfaces, see
    [discussion in #typesystem on Discord](https://discord.com/channels/655572317891461132/708431657849585705/938167784565792848)
    and not just for interface-interface dependencies, but also blanket impls

TODO: Briefly and at a high level, how do you propose to solve the problem? Why
will that in fact solve it?

## Details

TODO: Fully explain the details of the proposed solution.

## Rationale based on Carbon's goals

TODO: How does this proposal effectively advance Carbon's goals? Rather than
re-stating the full motivation, this should connect that motivation back to
Carbon's stated goals for the project or language. This may evolve during
review. Use links to appropriate goals, for example:

-   [Community and culture](/docs/project/goals.md#community-and-culture)
-   [Language tools and ecosystem](/docs/project/goals.md#language-tools-and-ecosystem)
-   [Performance-critical software](/docs/project/goals.md#performance-critical-software)
-   [Software and language evolution](/docs/project/goals.md#software-and-language-evolution)
-   [Code that is easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write)
-   [Practical safety and testing mechanisms](/docs/project/goals.md#practical-safety-and-testing-mechanisms)
-   [Fast and scalable development](/docs/project/goals.md#fast-and-scalable-development)
-   [Modern OS platforms, hardware architectures, and environments](/docs/project/goals.md#modern-os-platforms-hardware-architectures-and-environments)
-   [Interoperability with and migration from existing C++ code](/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code)

## Alternatives considered

TODO: What alternative solutions have you considered?

### Less strict about requirements with `where` clauses

We could allow
[requirements with `where` constraints](/docs/design/generics/details.md#requirements-with-where-constraints)
to be satisfied by implementations that could be specialized, as long as the
constraints were still satisfied. Unfortunately, this is not a condition that
can be checked locally. Continuing the example from that section, consider four
packages

-   A package defining the two interfaces

    ```
    package Interfaces api;
    interface A(T:! Type) {
      let Result:! Type;
    }
    interface B(T:! Type) {
      impl as A(T) where .Result == i32;
    }
    ```

-   A package defining a type that is used as a parameter to interfaces `A` and
    `B` in blanket impls:

    ```
    package Param api;
    import Interfaces;
    class P {}
    external impl [T:! Type] T as Interfaces.A(P) where .Result = i32 { }
    // Question:Is this blanket impl of `Interfaces.A(P)` sufficient
    // to allow us to make this blanket impl of `Interfaces.B(P)`?
    external impl [T:! Type] T as Interfaces.B(P) { }
    ```

-   A package defining a type that implements the interface `A` with a wildcard
    impl:

    ```
    package Class api;
    import Interfaces;
    class C {}
    external impl [T:! Type] C as Interfaces.A(T) where .Result = bool { }
    ```

-   And a package that tries to use the above packages together:

    ```
    package Main;
    import Interfaces;
    import Param;
    import Class;

    fn F[V:! Interfaces.B(Param.P)](x: V);
    fn Run() {
      var c: Class.C = {};
      // Does Class.C implement Interfaces.B(Param.P)?
      F(c);
    }
    ```

Package `Param` has an implementation of `Interfaces.B(Param.P)` for any `T`,
which should include `T == Class.C`. The requirement in `Interfaces.B` in this
case is that `T == Class.C` must implement `Interfaces.A(Param.P)`, which it
does, and `Class.C.(Interfaces.A(Param.P).Result)` must be `i32`. This would
hold using the blanket implementation defined in `Param`, but the wildcard impl
defined in package `Class` has higher priority and sets the associated type
`.Result` to `bool` instead.

The conclusion is that this problem would only be detected during
monomorphization, and could cause independent libraries to be incompatible with
each other even when they work separately. These were significant enough
downsides that we wanted to see if we could live with the restrictions that
allowed local checking first. We don't know if developers will want to declare
their parameterized implementations `final` in this situation anyway, even with
[the limitations on `final`](/docs/design/generics/details.md#libraries-that-can-contain-final-impls).

This problem was discussed in
[the #generics channel on Discord](https://discord.com/channels/655572317891461132/941071822756143115/941089885475962940).
