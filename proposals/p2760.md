# Consistent `class` and `interface` syntax

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/2760)

<!-- toc -->

## Table of contents

-   [Abstract](#abstract)
-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Details](#details)
    -   [Class inheritance](#class-inheritance)
    -   [Class implementing an interface](#class-implementing-an-interface)
    -   [Class conditional implementation](#class-conditional-implementation)
    -   [Adapters](#adapters)
    -   [Interfaces](#interfaces)
-   [Future work: mixins](#future-work-mixins)
-   [Rationale](#rationale)
-   [Alternatives considered](#alternatives-considered)
    -   [Use `extends` instead of `extend`](#use-extends-instead-of-extend)
    -   [Allow interfaces to `require` another interface without writing `Self impls`](#allow-interfaces-to-require-another-interface-without-writing-self-impls)
    -   [Continue to use `impl as` for interface requirements](#continue-to-use-impl-as-for-interface-requirements)
    -   [Allow more control over access to mixins](#allow-more-control-over-access-to-mixins)
    -   [Continue to use `adapter` or `adaptor` instead of `adapt`](#continue-to-use-adapter-or-adaptor-instead-of-adapt)
    -   [Use something other syntax for extending adapters](#use-something-other-syntax-for-extending-adapters)

<!-- tocstop -->

## Abstract

Update syntax of `class` and `interface` definitions to be more consistent.
Constructs that add names to the class or interface from another definition are
always prefixed by the `extend` keyword.

Implements the decisions in:

-   [#995: Generics external impl versus extends](https://github.com/carbon-language/carbon-lang/issues/995),
-   [#1159: adaptor versus adapter may be harder to spell than we'd like](https://github.com/carbon-language/carbon-lang/issues/1159),
-   [#2580: How should Carbon handle conditionally implemented internal interfaces](https://github.com/carbon-language/carbon-lang/issues/2580),
    and
-   [#2770: Terminology for internal and external implementations](https://github.com/carbon-language/carbon-lang/issues/2770).

## Problem

Classes and adapters, prior to this proposal, use `impl` to say that an
interface is
[implemented internally](https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/generics/terminology.md#internal-impl),
which means that the names that are members of the interface are included as
names of the class. The keyword `external` is added to indicate the names should
not be included. Interfaces and named constraints, in contrast, use `impl` to
mean another interface is required, but its names are not included. Instead, to
include the names, the `extends` keyword used instead of `impl`.

| Include names:            | Yes       | No              |
| ------------------------- | --------- | --------------- |
| `class`, `adapter`        | `impl`    | `external impl` |
| `interface`, `constraint` | `extends` | `impl`          |

In the time since this syntax has been introduced, we have found `external` in
particular easy to accidentally omit.

In addition to resolving this inconsistency, it would be an advantage if readers
of a class could quickly scan the definition to identify other places to look
for members that contribute to the class' API.

## Background

These proposals that defined the syntax for these entities that are being
modified:

-   [#553: Generics details part 1](https://github.com/carbon-language/carbon-lang/pull/553)
    defined the syntax for classes implementing interfaces, internally or
    externally, and the syntax for named constraints (then "structural
    interfaces") and interfaces requiring or extending other interfaces.
-   [#731: Generics details 2: adapters, associated types, parameterized interfaces](https://github.com/carbon-language/carbon-lang/pull/731)
    defined the syntax for adapters and extending adapters.
-   [#1084: Generics details 9: forward declarations](https://github.com/carbon-language/carbon-lang/pull/1084)
    allowed forward declaration of implementations, so internal `impl`
    declarations may appear outside of a class definition, and `external impl`
    declarations may appear inside.
-   [#777: Inheritance](https://github.com/carbon-language/carbon-lang/pull/777)
    defined the syntax for a class to extend a base class.

No proposal so far has defined how forward declarations work for classes. The
rule used for forward `interface`, `constraint`, and `impl` declarations is that
declaration part of the definition is everything up to the opening `{` of the
definition body. See
[the forward declaration section of the Generics details design doc](https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/generics/details.md#forward-declarations-and-cyclic-references)
added in proposal
[#1084: Generics details 9: forward declarations](https://github.com/carbon-language/carbon-lang/pull/1084).

This proposal incorporates the decisions made in these question-for-leads
issues:

-   [#995: Generics external impl versus extends](https://github.com/carbon-language/carbon-lang/issues/995),
-   [#1159: adaptor versus adapter may be harder to spell than we'd like](https://github.com/carbon-language/carbon-lang/issues/1159),
-   [#2580: How should Carbon handle conditionally implemented internal interfaces](https://github.com/carbon-language/carbon-lang/issues/2580),
    and
-   [#2770: Terminology for internal and external implementations](https://github.com/carbon-language/carbon-lang/issues/2770).

Some of thinking around the resolution of #995 was documented in
[issue #2293: reconsider syntax for internal / external implementation of interfaces](https://github.com/carbon-language/carbon-lang/issues/2293),
which was closed as a duplicate of #995.

In addition to modifying syntax from previous proposals,
[#995](https://github.com/carbon-language/carbon-lang/issues/995) also gives a
syntax for using a mixin in a class. Mixins are described as a use case in
[#561: Basic classes: use cases, struct literals, struct types, and future work](https://github.com/carbon-language/carbon-lang/pull/561),
but have not been added in any proposal. Question-for-leads issue
[#1000: Mixins: base classes or data members?](https://github.com/carbon-language/carbon-lang/issues/1000),
does state that a class will treat a mixin syntactically like a data member
instead of a base class.

## Proposal

Any declaration that adds the names from another entity shall start with the
(new) `extend` keyword. This includes:

-   _Inheritance_: A class now indicates that it inherits from a base class
    using an

    > `extend base:` _base-class_ `;`

    declaration inside the class definition. The `extend` keyword indicates that
    the API of the base class is included.

-   _Adapters_: Adapter types are now declared as a class, with an

    > [ `extend` ] `adapt` _adapted-class_ `;`

    declaration inside the definition, as an alternative to a base class
    declaration. The optional `extend` keyword controls whether the API of the
    adapted class is included.

-   _Implementations_: Internal implementations are marked with the `extend`
    keyword on the declaration inside the class. Only the declaration inside the
    class, which is required for internal implementations, uses the `extend`
    keyword. External implementations are not marked.

    > [ `extend` ] `impl` ...

-   _Interfaces_: The `extends` declaration in an interface definition is
    replaced by an `extend` declaration, with no change except removing the `s`
    from the end of the keyword. Other interface requirements are now written
    using a `require` declaration, with a constraint that matches a `where`
    clause. This means

    > `impl as` _required-interface_ `;`

    will now be written as

    > `require Self impls` _required-interface_ `;`

In summary:

| Before                          | After                                   |
| ------------------------------- | --------------------------------------- |
| `class D extends B { ... }`     | `class D { extend base: B; ... }`       |
| `external impl C as Sub;`       | `impl C as Sub;`                        |
| `class C { impl as Sortable; }` | `class C { extend impl as Sortable; }`  |
| `adapter A for C { ... }`       | `class A { adapt C; ... }`              |
| `adapter A extends C { ... }`   | `class A { extend adapt C; ... }`       |
| `interface I { impl as J; }`    | `interface I { require Self impls J; }` |
| `interface I { extends J; }`    | `interface I { extend J; }`             |

None of `adapt`, `extends`, `external` will continue to be keywords. To match
these changes, "internal implementations" will now be referred to as "extended
implementations," and we will no longer use "external" to refer to
implementations.

In addition, we drop the syntax for conditionally implemented internal
interfaces. Instead, an external interface implementation can be combined with
aliases to the members of the interface.

## Details

### Class inheritance

What was previously written:

```
base class B;
class D extends B;
class D extends B {
  ...
}
```

is now written:

```
base class B;
class D;
class D {
  extend base: B;
  ...
}
```

An extend base class declaration may appear in the body of a class definition,
and has this form:

> `extend` `base` `:` _type-expression_ `;`

The `extend base: B;` declaration must appear before any other data member
declaration, including any [mixin declaration](#future-work-mixins), once those
are added. This reflects both the importance of the information, and the fact
that the base subobject appears first in the memory layout of objects.

Note that `base` is already a keyword, for example used in `base class`
declarations. The colon in `base: B` is to indicate that `base` acts like a data
member for
[purposes of initialization](https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/classes.md#constructors).

Since the declaration part of a definition is the part before the curly braces
(`{`...`}`) with the definition, this new syntax moves the information about
extending a base class out of the declaration and into the definition. This
makes forward declarations more concise, but less type checking can be done with
an incomplete type.

### Class implementing an interface

What was previously written:

```
interface Sortable;
interface Add;
interface Sub;
class C;

// Forward declaration says whether external.
impl C as Sortable;
external impl C as Add;

class C {
  // Internal impl contributes to the API.
  impl as Sortable;

  // External impl of an operator.
  external impl as Add;
}

// External impl of an operator.
external impl C as Sub;

// Definition of `impl` declared earlier.
impl C as Sortable { ... }
external impl C as Add { ... }
```

is now written:

```
interface Sortable;
interface Add;
interface Sub;
class C;

// Forward declaration same whether extended or not.
impl C as Sortable;
impl C as Add;

class C {
  // Extended impl contributes to the API.
  extend impl as Sortable;

  // (Non-extended) Impl of an operator.
  impl as Add;
}

// (Non-extended) Impl of an operator.
impl C as Sub;

// Definition of `impl` declared earlier.
impl C as Sortable { ... }
impl C as Add { ... }
```

Whether an interface is extended or not is now only reflected in its declaration
inside the class body, not in any declaration or definition outside.

An `impl` declaration, with this proposal, must have one of these two forms:

-   Without an `extend` keyword prefix, used for non-extended `impl`
    declarations and for all `impl` declarations outside of a class body:

    <!-- prettier-ignore -->
    > `impl` [`forall` `[` _deduced-parameters_ `]`] [_type-expression_] `as`
    > _facet-type-expression_ (`;`|`{` _impl-body_ `}`)

    The _type-expression_ is required outside of a class body, otherwise it
    defaults to `Self`.

-   With an `extend` keyword prefix, to indicate this implementation is
    extended, only in a class body:

    > `extend` `impl` `as` _facet-type-expression_ (`;`|`{` _impl-body_ `}`)

    Note that this form does not allow either a `forall` clause nor a
    _type-expression_ before the `as` keyword. This reflects the restriction
    that
    [wildcard `impl` declarations must never be extended (formerly: "always be external")](https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/generics/details.md#wildcard-impl-declarations),
    and that this proposal removes support for
    [extended (formerly "internal") conditional implementation](#class-conditional-implementation).

### Class conditional implementation

We remove direct support for conditionally implemented extended (formerly
"internal") interfaces, called
[conditional conformance](https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/generics/details.md#conditional-conformance).
We can work around this restriction by using an non-extended interface
implementation and aliases to the members of the interface.

What was previously written:

```
interface Printable {
  fn Print[self: Self]();
}

class Vector(T:! type) {
  // ...

  impl forall [U:! Printable] Vector(U) as Printable {
    fn Print[self: Self]();
  }
}
```

is now written:

```
interface Printable {
  fn Print[self: Self]();
}

class Vector(T:! type) {
  // ...
  alias Print = Printable.Print;
}

impl forall [U:! Printable] Vector(U) as Printable {
  fn Print[self: Self]();
}
```

The way this works is that `Vector.Print` is equivalent to
`Vector.(Printable.Print)`, which may or may not be defined. The name
`Vector.Print` can no longer be conditional, and the meaning of that name is
fixed. However, the implementation of `Printable` for `Vector(T)` may not exist
for some types `T`.

### Adapters

What was previously written:

```
class C;
// Forward declarations of adapters.
adapter A for C;
adapter E extends C;

// Definitions of an adapter.
adapter A for C {
  ...
}
// Definition of an extending adapter.
adapter E extends C {
  ...
}
```

is now written:

```
class C;
// Forward declarations of adapters.
class A;
class E;

// Definitions of an adapter.
class A {
  adapt C;
  ...
}
// Definition of an extending adapter.
class E {
  extend adapt C;
  ...
}
```

Note:

-   Adapters are now a special case of classes, not a distinct top-level
    declaration.
-   Classes with `adapt` still must not contain anything that was previously
    forbidden for adapters: no fields, no base class, no virtual methods, no
    implementations of virtual methods, and so on.
-   The `adapt` declaration must appear before
    [mixin declarations](#future-work-mixins), if any.
-   The syntax for an `adapt` declaration inside a class body is:

    > [`extend`] `adapt` _type-expression_ `;`

### Interfaces

What was previously written:

```
interface A { let T:! Type; }
interface B { let U:! Type; }
interface C { let V:! Type; }
interface D { let W:! Type; }

interface I {
  // Interface is incorporated into `I`.
  extends A where .T == i32;
  extends B where .U == i32;

  // No impact on `I`s interface, but an implementation must exist.
  impl as C where .V == i32;
  impl as D where .W == i32;
}
```

is now written:

```
interface A { let T:! Type; }
interface B { let U:! Type; }
interface C { let V:! Type; }
interface D { let W:! Type; }

interface I {
  // `A`'s interface is incorporated into `I`.
  extend A;

  // Anything that could be in a `where` clause can
  // be in a `require` declaration:
  require A.T == i32;

  // Can combine `extend` with `where`.
  extend B where B.U == i32;

  // No impact on `I`s interface, but an
  // implementation must exist.
  require Self impls C where .V == i32;

  // Again the `where` clause can be located
  // in a separate `require` declaration.
  require Self impls D;
  require D.W == i32;
}
```

Notes:

-   The same change applies to named constraints, and is intended to be used in
    the future for named predicates used as template constraints.
-   One syntax for constraints in either `where` clauses or `require`
    declarations.
-   Want to open up the syntax to expressing more general constraints.
-   Syntax for a `require` declaration in an interface or named constraint:

    > `require` _where-constraint-argument_ `;`

-   Syntax for an `extend` declaration in an interface or named constraint:

    > `extend` _facet-type-expression_ `;`

## Future work: mixins

Mixins have not been defined in a proposal so far. However, part of the process
of resolving
[issue #995](https://github.com/carbon-language/carbon-lang/issues/995) was
deciding on a syntax for including a mixin in a class. This was done in order to
make sure that class declarations that included names from another entity were
treated consistently, for example always starting with the `extend` keyword.

```
// Mixin declarations and definitions are
// outside the scope of this proposal.
mixin M1;
mixin M2;

class C {
  // Mixing in mixin M1
  extend m: M1;

  // Mixing in mixin M2. This member is not named.
  // Initialized using `M2.MakeDefault()`.
  extend _: M2 = M2.MakeDefault();

  // Alternative to the above `M2` that uses a
  // private name instead of no name:
  extend private m2: M2;
}
```

The declaration that a class uses a mixin is called a "mix" declaration. The
syntax of a mix declaration is:

<!-- prettier-ignore -->
> `extend` [`private`|`protected`] (`_`|_id_) `:` _mixin-expression_ [`=`
> _initializer-expression_] `;`

The _id_ part of the mix declaration defines the name assigned to that mixin
subobject. This name is may be used to access members of the mixin and to
initialize the mixin in a constructor for the class. The optional `private` or
`protected` access specifier controls the access to this name.

With this proposal, base class declarations appear in the body of the class
definition, like data members, so decision of whether mixins are more like base
classes or data members of issue
[#1000: Mixins: base classes or data members?](https://github.com/carbon-language/carbon-lang/issues/1000)
is less significant. Like base classes, the mix declaration syntax begins with
`extend`. Like data members, a class may have multiple mix declarations and they
may be intermixed with field declarations. The layout of the memory of an object
reflects the order of the declarations in the class body, defining the order of
the mixin and field subobjects.

## Rationale

The main reason for the new syntax is consistency and simplification:

-   The use of the `extend` keyword is the consistent way to mark what other
    entities are consulted during name lookup.
-   The `class` declaration is simplified by moving more into the definition
    body.
-   Making adapters a kind of class removes a kind of top-level declaration,
    simplification, and matches how base classes are declared, a consistency.
-   Dropping the class conditional implementation is a simplification.

These consistency and simplification improvements help:

-   ease the implementation of
    [language tools and ecosystem](/docs/project/goals.md#language-tools-and-ecosystem)
    by reducing the size of the language, and providing regularities
    implementations can use to reuse code or more easily identify relevant parts
    of the code for queries;
-   make Carbon code
    [easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write).
-   teaching the language, since there is less to learn.

## Alternatives considered

### Use `extends` instead of `extend`

Keyword `extend` was chosen over `extends` to parallel `impl`, a declaration,
instead of `impls`, a binary predicate, decided in
[issue #2495](https://github.com/carbon-language/carbon-lang/issues/2495) and
accepted in
[proposal #2483](https://github.com/carbon-language/carbon-lang/pull/2483).

We chose to use `require` instead of `requires` and `adapt` instead of `adapts`
for the same consistency.

### Allow interfaces to `require` another interface without writing `Self impls`

We considered allowing `interface I { require J; }` as a short-hand for
`interface I { require Self impls J; }`. This is something we would consider
adding in the future based on experience with the current approach, but for now
we wanted to maintain consistency with the constraint syntax of `where` clauses.

This decision and rationale was described in
[this comment in #995](https://github.com/carbon-language/carbon-lang/issues/995#issuecomment-1416659207).

### Continue to use `impl as` for interface requirements

There were a few reasons motivating the change to use the new `require`
declarations in interfaces and named constraints, instead of using `impl as` to
match how a type could satisfy that requirement. These mostly came down to some
observed breaks in the parallel structure between the requirement in interfaces
and the satisfaction of that requirement in types.

-   Whether an interface `I` extends or just requires another interface `J` is
    independent of whether a type implementing `I` extends or just implements
    `J`.
-   If `R` requires interface `I`, the implementation of `R` for a type won't
    have the implementation of `I` as a nested sub-block.
-   With the change in
    [#2173: Associated constant assignment versus equality](https://github.com/carbon-language/carbon-lang/pull/2173),
    the behavior of `impl as` in interfaces is different from in classes with
    respect to rewrites of associated types, motivating a change to make those
    look more different.

Furthermore, we had a desire to be able to express the full range of constraints
in `where` clauses in named constraints, and we wanted the transformation from a
`where` clause to a named constraint to be straightforward. We also wanted the
syntax for constraints to be the same between interfaces and named constraints,
at least for all constraints that were allowed in both.

This was discussed in
[#generics-and-templates on 2023-01-30](https://discord.com/channels/655572317891461132/941071822756143115/1069691751968817283)
and in
[issue #995](https://github.com/carbon-language/carbon-lang/issues/995#issuecomment-1412478644).

### Allow more control over access to mixins

There were three different aspects of mixins that we considered giving control
over access:

-   the inclusion of names exported by the mixin into the mixer class,
-   the ability to cast between the mixin and the mixer class types, and
-   the ability to use the name of the mixin given by the mixer class to access
    members of the mixin.

The only examples we had where the mixer class would not want to include the
names exported by the mixin were cases where the mixin had nothing to export.
This led to
[the position](https://github.com/carbon-language/carbon-lang/issues/995#issuecomment-1325746398)
that the mixin would control which of its member would be included into the
mixer class' API -- that is the mixin would "inject" members rather than
"export" them and leave it up to the mixer class to import them.

We had concerns that there might be name conflicts, but we thought those might
be handled by some other mechanism. This is being considered in
question-for-leads issue
[#2745: Name conflicts beyond inheritance](https://github.com/carbon-language/carbon-lang/issues/2745).

We wanted mixin member names to behave consistently like other class member
names, and so default to public but can have a `private` modifier to make
public, following
[#665: `private` vs `public` _syntax_ strategy, as well as other visibility tools like `external`/`api`/etc.](https://github.com/carbon-language/carbon-lang/issues/665).
We decided to put the `private` keyword _between_ the `extend` keyword and the
member name for two reasons:

-   to make it easier to scan for all uses of `extend` in a class, and
-   to make it clearer that the `private` access control only applies to the
    member name, not what the `extend` controls.

We did not see a use case for controlling the ability to cast between the mixin
and the mixer class types separately from being able to access the name the
mixin member of the mixin class. This was consistent with our desire to limit
declarations to a single access control specifier per declaration, see
[this update in #995](https://github.com/carbon-language/carbon-lang/issues/995#issuecomment-1322892195).

### Continue to use `adapter` or `adaptor` instead of `adapt`

We didn't want to allow both `adapter` and `adaptor`, since that adds complexity
for readers and tooling, but neither seemed clearly dominant enough in usage to
pick one over the other. By moving the declaration into the body of the class
definition, we were able to switch from the noun form to the verb form of
`adapt`, which doesn't have an alternate form in common usage. See
[#1159: adaptor versus adapter may be harder to spell than we'd like](https://github.com/carbon-language/carbon-lang/issues/1159)
for the discussion.

We also considered using `adapts` in a class declaration, as in
`class PlayableSong adapts Song { ... }`, see
[this comment in #1159](https://github.com/carbon-language/carbon-lang/issues/1159#issuecomment-1316669416).
This would have also worked, but was not consistent with our resolution of
[#995: Generics external impl versus extends](https://github.com/carbon-language/carbon-lang/issues/995).

### Use something other syntax for extending adapters

In the
[open discussion on 2023-02-27](https://docs.google.com/document/d/1gnJBTfY81fZYvI_QXjwKk1uQHYBNHGqRLI2BS_cYYNQ/edit?resourcekey=0-ql1Q1WvTcDvhycf8LbA9DQ#heading=h.9steyq834zuq),
we discussed some alternatives to `extend adapt` _adapted-class_ `;`:

-   Adding `and` to make it read more like fluent English:

    > `extend and adapt` _adapted-class_ `;`

-   Make the extending and adapting be separate declarations:

    > `extend` _adapted-class_ `;` <br> > `adapt` _adapted-class_ `;`

-   Make the only way to make an extending adapter is trying to inherit from a
    final base class

    > `extend base:` _adapted-class_ `;`
