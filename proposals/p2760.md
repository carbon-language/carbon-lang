# Consistent `class` and `interface` syntax

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/2760)

<!-- toc -->

## Table of contents

-   [Abstract](#abstract)
-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Details](#details)
    -   [Class inheritance](#class-inheritance)
    -   [Class implementing an interface](#class-implementing-an-interface)
    -   [Class conditional implementation](#class-conditional-implementation)
    -   [Adapters](#adapters)
    -   [Interfaces](#interfaces)
-   [Future work: mixins](#future-work-mixins)
-   [Rationale](#rationale)
-   [Alternatives considered](#alternatives-considered)
    -   [Use `extends` instead of `extend`](#use-extends-instead-of-extend)
    -   [Allow interfaces to `require` another interface without writing `Self impls`](#allow-interfaces-to-require-another-interface-without-writing-self-impls)
    -   [Allow more control over access to mixins](#allow-more-control-over-access-to-mixins)

<!-- tocstop -->

## Abstract

Update syntax of `class` and `interface` definitions to be more consistent.
Constructs that add names to the class or interface from another definition are
always prefixed by the `extend` keyword.

Implements the decisions in:

-   [#995: Generics external impl versus extends](https://github.com/carbon-language/carbon-lang/issues/995),
-   [#1159: adaptor versus adapter may be harder to spell than we'd like](https://github.com/carbon-language/carbon-lang/issues/1159),
    and
-   [#2580: How should Carbon handle conditionally implemented internal interfaces](https://github.com/carbon-language/carbon-lang/issues/2580).

## Problem

Classes and adapters, prior to this proposal, use `impl` to say that an
interface is
[implemented internally](https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/generics/terminology.md#internal-impl),
which means that the names that are members of the interface are included as
names of the class. The keyword `external` is added to indicate the names should
not be included. Interfaces and named constraints, in contrast, use `impl` to
mean another interface is required, but its names are not included. Instead, to
include the names, the `extends` keyword used instead of `impl`.

| Include names:            | Yes       | No              |
| ------------------------- | --------- | --------------- |
| `class`, `adapter`        | `impl`    | `external impl` |
| `interface`, `constraint` | `extends` | `impl`          |

In the time since this syntax has been introduced, we have found `external` in
particular easy to accidentally omit.

In addition to resolving this inconsistency, it would be an advantage if readers
of a class could quickly scan the definition to identify other places to look
for members that contribute to the class' API.

## Background

These proposals that defined the syntax for these entities that are being
modified:

-   [#553: Generics details part 1](https://github.com/carbon-language/carbon-lang/pull/553)
    defined the syntax for classes implementing interfaces, internally or
    externally, and the syntax for named constraints (then "structural
    interfaces") and interfaces requiring or extending other interfaces.
-   [#731: Generics details 2: adapters, associated types, parameterized interfaces](https://github.com/carbon-language/carbon-lang/pull/731)
    defined the syntax for adapters and extending adapters.
-   [#1084: Generics details 9: forward declarations](https://github.com/carbon-language/carbon-lang/pull/1084)
    allowed forward declaration of implementations, so internal `impl`
    declarations may appear outside of a class definition, and `external impl`
    declarations may appear inside.
-   [#777: Inheritance](https://github.com/carbon-language/carbon-lang/pull/777)
    defined the syntax for a class to extend a base class.

No proposal so far has defined how forward declarations work for classes. The
rule used for forward `interface`, `constraint`, and `impl` declarations is that
declaration part of the definition is everything up to the opening `{` of the
definition body. See
[the forward declaration section of the Generics details design doc](https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/generics/details.md#forward-declarations-and-cyclic-references)
added in proposal
[#1084: Generics details 9: forward declarations](https://github.com/carbon-language/carbon-lang/pull/1084).

This proposal incorporates the decisions made in these question-for-leads
issues:

-   [#995: Generics external impl versus extends](https://github.com/carbon-language/carbon-lang/issues/995),
-   [#1159: adaptor versus adapter may be harder to spell than we'd like](https://github.com/carbon-language/carbon-lang/issues/1159),
    and
-   [#2580: How should Carbon handle conditionally implemented internal interfaces](https://github.com/carbon-language/carbon-lang/issues/2580).

In addition to modifying syntax from previous proposals,
[#995](https://github.com/carbon-language/carbon-lang/issues/995) also gives a
syntax for using a mixin in a class. Mixins are described as a use case in
[#561: Basic classes: use cases, struct literals, struct types, and future work](https://github.com/carbon-language/carbon-lang/pull/561),
but have not been added in any proposal. Question-for-leads issue
[#1000: Mixins: base classes or data members?](https://github.com/carbon-language/carbon-lang/issues/1000),
does state that a class will treat a mixin syntactically like a data member
instead of a base class.

## Proposal

Any declaration that adds the names from another entity shall start with the
(new) `extend` keyword. Neither `extends` nor `external` will continue to be
keywords.

| Before                          | After                                   |
| ------------------------------- | --------------------------------------- |
| `class D extends B { ... }`     | `class D { extend base: B; ... }`       |
| `external impl C as Sub;`       | `impl C as Sub;`                        |
| `class C { impl as Sortable; }` | `class C { extend impl as Sortable; }`  |
| `adapter A for C { ... }`       | `class A { adapt C; ... }`              |
| `adapter A extends C { ... }`   | `class A { extend adapt C; ... }`       |
| `interface I { impl as J; }`    | `interface I { require Self impls J; }` |
| `interface I { extends J; }`    | `interface I { extend J; }`             |

In addition, we drop the syntax for conditionally implemented internal
interfaces. Instead, an external interface implementation can be combined with
aliases to the members of the interface.

## Details

### Class inheritance

What was previously written:

```
base class B;
class D extends B;
class D extends B {
  ...
}
```

is now written:

```
base class B;
class D;
class D {
  extend base: B;
  ...
}
```

An extend base class declaration may appear in the body of a class definition,
and has this form:

> `extend` `base` `:` _type-expression_ `;`

The `extend base: B;` declaration must appear before any other data member
declaration, including any [mixin declaration](#future-work-mixins), once those
are added. This reflects both the importance of the information, and the fact
that the base subobject appears first in the memory layout of objects.

Note that `base` is already a keyword, for example used in `base class`
declarations. The colon in `base: B` is to indicate that `base` acts like a data
member for
[purposes of initialization](https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/classes.md#constructors).

Since the declaration part of a definition is the part before the curly braces
(`{`...`}`) with the definition, this new syntax moves the information about
extending a base class out of the declaration and into the definition. This
makes forward declarations more concise, but less type checking can be done with
an incomplete type.

### Class implementing an interface

What was previously written:

```
interface Sortable;
interface Add;
interface Sub;
class C;

// Forward declaration says whether external.
impl C as Sortable;
external impl C as Add;

class C {
  // Internal impl contributes to the API.
  impl as Sortable;

  // External impl of an operator.
  external impl as Add;
}

// External impl of an operator.
external impl C as Sub;

// Definition of `impl` declared earlier.
impl C as Sortable { ... }
external impl C as Add { ... }
```

is now written:

```
interface Sortable;
interface Add;
interface Sub;
class C;

// Forward declaration same whether external or not.
impl C as Sortable;
impl C as Add;

class C {
  // Internal impl contributes to the API.
  extend impl as Sortable;

  // External impl of an operator.
  impl as Add;
}

// External impl of an operator.
impl C as Sub;

// Definition of `impl` declared earlier.
impl C as Sortable { ... }
impl C as Add { ... }
```

Whether an interface is internal or external is now only reflected in its
declaration inside the class body, not in any declaration or definition outside.

An `impl` declaration, with this proposal, must have one of these two forms:

-   Without an `extend` keyword prefix, used for external `impl` declarations
    and for `impl` declarations outside of a class body:

    <!-- prettier-ignore -->
    > `impl` [`forall` `[` _deduced-parameters_ `]`] [_type-expression_] `as`
    > _constraint-expression_ (`;`|`{` _impl-body_ `}`)

    The _type-expression_ is required outside of a class body.

-   With an `extend` keyword prefix, to indicate this implementation is
    internal, only in a class body:

    > `extend` `impl` `as` _constraint-expression_ (`;`|`{` _impl-body_ `}`)

    Note that this form does not allow either a `forall` clause nor a
    _type-expression_ before the `as` keyword. This reflects the restriction
    that
    [wildcard `impl` declarations must always be external](https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/generics/details.md#wildcard-impl-declarations),
    and that this proposal removes support for
    [internal conditional implementation](#class-conditional-implementation).

**Open Question**: do we change the "internal" versus "external" terminology for
implementations?

### Class conditional implementation

We remove direct support for conditionally implemented internal interfaces,
called
[conditional conformance](https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/generics/details.md#conditional-conformance).
We can work around this restriction by using an external interface
implementation and aliases to the members of the interface.

What was previously written:

```
interface Printable {
  fn Print[self: Self]();
}

class Vector(T:! type) {
  // ...

  impl forall [U:! Printable] Vector(U) as Printable {
    fn Print[self: Self]();
  }
}
```

is now written:

```
interface Printable {
  fn Print[self: Self]();
}

class Vector(T:! type) {
  // ...
  alias Print = Printable.Print;
}

impl forall [U:! Printable] Vector(U) as Printable {
  fn Print[self: Self]();
}
```

The way this works is that `Vector.Print` is equivalent to
`Vector.(Printable.Print)`, which may or may not be defined. The name
`Vector.Print` can no longer be conditional, and the meaning of that name is
fixed. However, the implementation of `Printable` for `Vector(T)` may not exist
for some types `T`.

### Adapters

What was previously written:

```
class C;
// Forward declarations of adapters.
adapter A for C;
adapter E extends C;

// Definitions of an adapter.
adapter A for C {
  ...
}
// Definition of an extending adapter.
adapter E extends C {
  ...
}
```

is now written:

```
class C;
// Forward declarations of adapters.
class A;
class E;

// Definitions of an adapter.
class A {
  adapt C;
  ...
}
// Definition of an extending adapter.
class E {
  extend adapt C;
  ...
}
```

Note:

-   Adapters are now a special case of classes, not a distinct top-level
    declaration.
-   Classes with `adapt` still must not contain anything that was previously
    forbidden for adapters: no fields, no base class, no virtual methods, no
    implementations of virtual methods, and so on.
-   The `adapt` declaration must appear before
    [mixin declarations](#future-work-mixins), if any.
-   The syntax for an `adapt` declaration inside a class body is:

    > [`extend`] `adapt` _type-expression_ `;`

### Interfaces

What was previously written:

```
interface A { let T:! Type; }
interface B { let U:! Type; }
interface C { let V:! Type; }
interface D { let W:! Type; }

interface I {
  // Interface is incorporated into `I`.
  extends A where .T == i32;
  extends B where .U == i32;

  // No impact on `I`s interface, but an implementation must exist.
  impl as C where .V == i32;
  impl as D where .W == i32;
}
```

is now written:

```
interface A { let T:! Type; }
interface B { let U:! Type; }
interface C { let V:! Type; }
interface D { let W:! Type; }

interface I {
  // `A`'s interface is incorporated into `I`.
  extend A;

  // Anything that could be in a `where` clause can
  // be in a `require` declaration:
  require A.T == i32;

  // Can combine `extend` with `where`.
  extend B where B.U == i32;

  // No impact on `I`s interface, but an
  // implementation must exist.
  require Self impls C where .V == i32;

  // Again the `where` clause can be located
  // in a separate `require` declaration.
  require Self impls D;
  require D.W == i32;
}
```

Notes:

-   One syntax for constraints in either `where` clauses or `require`
    declarations.
-   Want to open up the syntax to expressing more general constraints.
-   Syntax for a `require` declaration in an interface or named constraint:

    > `require` _where-constraint-argument_ `;`

-   Syntax for an `extend` declaration in an interface or named constraint:

    > `extend` _constraint-expression_ `;`

## Future work: mixins

Mixins have not been defined in a proposal so far. However, part of the process
of resolving
[issue #995](https://github.com/carbon-language/carbon-lang/issues/995) was
deciding on a syntax for including a mixin in a class. This was done in order to
make sure that class declarations that included names from another entity were
treated consistently, for example always starting with the `extend` keyword.

```
// Mixin declarations and definitions are
// outside the scope of this proposal.
mixin M1;
mixin M2;

class C {
  // Mixing in mixin M1
  extend m: M1;

  // Mixing in mixin M2. This member is not named.
  // Initialized using `M2.MakeDefault()`.
  extend _: M2 = M2.MakeDefault();

  // Alternative to the above `M2` that uses a
  // private name instead of no name:
  extend private m2: M2;
}
```

The declaration that a class uses a mixin is called a "mix" declaration. The
syntax of a mix declaration is:

<!-- prettier-ignore -->
> `extend` [`private`|`protected`] (`_`|_id_) `:` _mixin-expression_ [`=`
> _initializer-expression_] `;`

The _id_ part of the mix declaration defines the name assigned to that mixin
subobject. This name is may be used to access members of the mixin and to
initialize the mixin in a constructor for the class. The optional `private` or
`protected` access specifier controls the access to this name.

With this proposal, base class declarations appear in the body of the class
definition, like data members, so decision of whether mixins are more like base
classes or data members of issue
[#1000: Mixins: base classes or data members?](https://github.com/carbon-language/carbon-lang/issues/1000)
is less significant. Like base classes, the mix declaration syntax begins with
`extend`. Like data members, a class may have multiple mix declarations and they
may be intermixed with field declarations. The layout of the memory of an object
reflects the order of the declarations in the class body, defining the order of
the mixin and field subobjects.

## Rationale

TODO: How does this proposal effectively advance Carbon's goals? Rather than
re-stating the full motivation, this should connect that motivation back to
Carbon's stated goals and principles. This may evolve during review. Use links
to appropriate sections of [`/docs/project/goals.md`](/docs/project/goals.md),
and/or to documents in [`/docs/project/principles`](/docs/project/principles).
For example:

-   [Language tools and ecosystem](/docs/project/goals.md#language-tools-and-ecosystem)
-   [Code that is easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write)

Consistency is also easier to teach.

## Alternatives considered

### Use `extends` instead of `extend`

Keyword `extend` was chosen over `extends` to parallel `impl`, a declaration,
instead of `impls`, a binary predicate, decided in
[issue #2495](https://github.com/carbon-language/carbon-lang/issues/2495) and
accepted in
[proposal #2483](https://github.com/carbon-language/carbon-lang/pull/2483).

We chose to use `require` instead of `requires` for the same consistency.

### Allow interfaces to `require` another interface without writing `Self impls`

FIXME: Allow `interface I { require J; }` instead of
`interface I { require Self impls J; }`.

### Allow more control over access to mixins

FIXME
