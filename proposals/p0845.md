# `as` expressions

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/845)

<!-- toc -->

## Table of contents

-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Rationale based on Carbon's goals](#rationale-based-on-carbons-goals)
-   [Alternatives considered](#alternatives-considered)
    -   [Merge `as` and `assume_as`](#merge-as-and-assume_as)
    -   [`as` only performs implicit conversions](#as-only-performs-implicit-conversions)
    -   [Different name for `assume_as`](#different-name-for-assume_as)

<!-- tocstop -->

## Problem

We would like to provide a notation for the following operations:

-   Requesting a type conversion in order to select an operation to perform, or
    to resolve an ambiguity between possible operations:
    ```
    fn Ratio(a: i32, b: i32) -> f64 {
      // Note that a / b would invoke a different / operation.
      return a / (b as f64);
    }
    ```
-   Requesting a type conversion to a narrower type, where the developer
    believes the value is a value of the narrower type:
    ```
    fn Extract(p: Base*) -> i32 {
      if (p->kind == DerivedKind) {
        // I promise that p points to a Derived.
        return (p assume_as Derived*)->value;
      }
      return -1;
    }
    fn ByteEncode(n: i32) -> Optional(i8) {
      if (n >= i8.MinValue and n <= i8.MaxValue) {
        // I promise that n fits in i8.
        return .Some(n assume_as i8);
      }
      return .None;
    }
    ```
-   Specifying the type that an expression will have or will be converted into,
    for documentation purposes.
    ```
    class Thing {
      var id: i32;
    }
    fn PrintThing(t: Thing) {
      // 'as i32' reminds the reader what type we're printing.
      Print(t.id as i32);
    }
    ```
-   Specifying the type that an expression is expected to have, potentially
    after implicit conversions, as a form of static assertion.
    ```
    fn Munge() {
      // I expect this expression to produce a Widget but I'm getting compiler
      // errors and I'd like to narrow down why.
      F(Some().Complex().Expression() as Widget);
    }
    ```

In general, the developer wants to specify that an expression should be
considered to produce a value of a particular type, and that type might be more
general than the type of the expression, the same as the type of the expression,
more specific than the type of the expression, or perhaps might represent a
different way of viewing the value.

The first of the above problems is especially important in Carbon due to the use
of facet types for generics. Explicit conversions of types to interfaces will be
necessary in order to select the meaning of operations, because the same member
name on different facet types for the same underlying type will in general have
different meanings.

For this proposal, the following are out of scope:

-   Requesting a type conversion that changes the value, such as by truncation.
-   Determining whether a value can be represented in a narrower type.

## Background

C++ provides a collection of different kinds of casts and conversions from an
expression `x` to a type `T`:

-   Copy-initialization: `T v = x;`
-   Direct-initialization: `T v(x);`
-   Named casts:
    -   `static_cast<T>(x)`
    -   `const_cast<T>(x)`
    -   `reinterpret_cast<T>(x)`
    -   `dynamic_cast<T>(x)`
-   C-style casts: `T(x)` or equivalently `(T)x`
    -   These can do anything that `static_cast`, `const_cast`, and
        `reinterpret_cast` can do, but ignore access control on base classes.
-   List-initialization: `T{x}`
    -   This can do anything that implicit conversion can do, and can also
        initialize a single -- real or notional -- subobject of `T`.
    -   Narrowing conversions are disallowed.

These conversions are all different, and each of them has some surprising or
unsafe behavior.

Swift provides four forms of type casting operation:

-   `x as T` performs a conversion from subtype to supertype.
-   `x as! T` performs a conversion from supertype to subtype, with the
    assumption that the value inhabits the subtype.
-   `x as? T` performs a conversion from supertype to subtype, producing an
    `Optional`.
-   `T(x)` and similar construction expressions are used to convert between
    types without a subtyping relationship, such as between integer and
    floating-point types.

In Swift, `x as T` is always unsurprising and safe.

Rust provides the following:

-   `x as T` performs a conversion to type `T`.
    -   When there is no corresponding value, some specified value is produced:
        this conversion will perform 2's complement truncation on integers and
        will saturate when converting large floating-point values to integers.
    -   Conversions between distinct pointer types, and between pointers and
        integers, are permitted. Rust treats accesses through pointers as
        unsafe, but not pointer arithmetic or casting.

This cast can perform some conversions with surprising results, such as integer
truncation. It can also have surprising performance implications, because it
defines the behavior of converting an out-of-range value -- for example, when
converting from floating-point to integer -- in ways that aren't supported
across all modern targets.

Haskell and Scala support type ascription notation, `x : T`. This has also been
proposed for Rust. This notation constrains the type checker to find a type for
the expression `x` that is consistent with `T`, and is used:

-   for documentation purposes,
-   to guide the type checker to select a particular meaning of the code in the
    presence of ambiguity, and
-   as a diagnostic tool when attempting to understand type inference failures.

## Proposal

Carbon provides two explicit cast operations:

-   `x as T` performs an unsurprising and safe conversion from `x` to type `T`.
    -   This can be used to perform any implicit conversion explicitly. As in
        Swift, this can therefore be used to convert from subtype to supertype.
    -   This can also be used to perform an unsurprising and safe conversion
        that cannot be performed implicitly because it's lossy, such as from
        `i32` to `f32`.
-   `x assume_as T` performs an unsurprising conversion from `x` to `T`, in the
    case where it is not necessarily statically known that `x` can be
    represented in type `T`. The value of `x` is assumed to be representable in
    type `T`, and the case where `x` cannot be represented in type `T` is a
    programming error.
    -   As in Swift, this can be used to convert from supertype to subtype.
    -   This can also be used to perform a conversion that is unsurprising and
        safe for some subset of the possible values of type `x`, such as from
        `f32` to `i32`.
    -   Any conversion that can be performed by `as` can also be performed by
        `assume_as`.

See changes to the design for details.

## Rationale based on Carbon's goals

-   [Community and culture](/docs/project/goals.md#community-and-culture)
-   [Language tools and ecosystem](/docs/project/goals.md#language-tools-and-ecosystem)
-   [Performance-critical software](/docs/project/goals.md#performance-critical-software)
-   [Software and language evolution](/docs/project/goals.md#software-and-language-evolution)
-   [Code that is easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write)
-   [Practical safety and testing mechanisms](/docs/project/goals.md#practical-safety-and-testing-mechanisms)
-   [Fast and scalable development](/docs/project/goals.md#fast-and-scalable-development)
-   [Modern OS platforms, hardware architectures, and environments](/docs/project/goals.md#modern-os-platforms-hardware-architectures-and-environments)
-   [Interoperability with and migration from existing C++ code](/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code)

## Alternatives considered

### Merge `as` and `assume_as`

We could provide a single type-casting operator that can perform more of the
conversions supported by `assume_as`. The remaining conversions could be
relegated to some other syntax.

One particularly appealing option would be to permit `as` to convert freely
between integer and floating-point types, but not permit it to convert from
supertype to subtype.

Advantage:

-   Developers many not want to be reminded about the possibility of overflow in
    conversions to integer types.
-   This would make `as` more consistent with arithmetic operations, which will
    likely have no overt indication that they're unsafe in the presence of
    integer overflow.

Disadvantage:

-   No clear foundation for which conversions can be performed by `as` and which
    cannot.
-   An `as` expression would be less suitable for selecting which operation to
    perform if it can be unsafe.
-   Under maintenance, every usage of `as` would need additional scrutiny
    because it's not in general a safe operation.

### `as` only performs implicit conversions

We could limit `as` to performing only implicit conversions. This would mean
that `as` cannot perform lossy conversions.

Advantage:

-   One fewer set of rules for developers to be aware of.

Disadvantage:

-   Converting between integer and floating-point types is common, and providing
    built-in syntax for it seems valuable.

### Different name for `assume_as`

We could use a different name for `assume_as`, such as `unsafe_as` or `as!`.

Advantage of `as!`:

-   Terser.

Disadvantage of `as!`:

-   Including a `!` as a suffix on a word-shaped operator would be novel and
    risks making the lexing rules less uniform.
-   We are planning for the `!` punctuation symbol to be used to indicate a
    compile-time operation, such as a generic or template parameter, or a
    metaprogramming operation.

Advantage of `unsafe_as`:

-   Clearer that violation of the assumption is a programming error.

Disadvantage of `unsafe_as`:

-   Less clear about what aspect of the conversion is unsafe, and that the
    conversion is safe if the input value is suitable.
