# Types are values of type `Type`

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/2360)

<!-- toc -->

## Table of contents

-   [Abstract](#abstract)
-   [Problem](#problem)
    -   [Tuples behave inconsistently](#tuples-behave-inconsistently)
    -   [Qualified access to constraint members is inconsistent](#qualified-access-to-constraint-members-is-inconsistent)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Details](#details)
    -   [Terminology](#terminology)
    -   [Compound member access](#compound-member-access)
    -   [Tuple and struct literals](#tuple-and-struct-literals)
    -   [Name lookup into values with constrained types](#name-lookup-into-values-with-constrained-types)
-   [Rationale](#rationale)
-   [Alternatives considered](#alternatives-considered)
    -   [Alternative terminology](#alternative-terminology)

<!-- tocstop -->

## Abstract

Define a "type" to be a value of type `Type`. Contexts expecting a type perform
an implicit conversion to `Type`. Values like `()` and `(i32, i32)` and `{}` are
no longer types, but instead implicitly convert to `Type`. Values of interface
or constraint type (now called "kinds") are similarly not formally types but
implicitly convert to `Type`.

The practical impact to the semantics are relatively small. This is primarily
establishing more principled and clear terminology and concepts in the design
with a few more narrow fixes and improvements to the design's consistency.

## Problem

### Tuples behave inconsistently

Currently, the type of `(i32, i32)` is `(Type, Type)`, and similarly the type of
`(Type, Type)` is also `(Type, Type)`. This leads to an inconsistency: for most
values, asking for the type, then the type-of-type, and so on, quickly leads to
`Type`, whose type is `Type`. But for a few values, notably tuples and empty
structs, we instead bottom out at a different value.

This leads to implementation complexity and a lack of clarity around what is or
is not a type. It is easy to find examples where explorer misbehaves or crashes
due to getting tuple values and types mixed up.

Moreover, this inconsistency is limited to a few built-in types. There is no way
to design a class type so it behaves like a tuple type.

### Qualified access to constraint members is inconsistent

Given the expression `x.(Interface.Function)`, where the function is an instance
method, the behavior depends on whether `x` is a type.

-   If `x` is not a type, but a value of type `T`, this requires
    `T is Interface` and looks for `Function` in the corresponding `impl`.
    Instance binding is performed.
-   If `x` is a type, this requires `x` to have symbolic value phase and
    requires that `x is Interface`. The result is an unbound member name.

This dual meaning has some problematic consequences:

-   Even if `Interface.Function` is non-dependent, if `x` depends on a template
    parameter then we must treat the compound member access as being dependent.
    Qualification cannot be used to avoid dependence in templates.
-   Worse, if `x` is a template parameter, the interpretation will differ
    between instantiations, meaning that a template and a checked generic will
    have a discontinuity in behavior when `x` happens to be a type.
-   While it is possible to `impl Type as ...`, this rule means it is not
    possible to directly invoke methods that have been implemented this way. For
    example, given an `impl Type as DebugPrintable`,
    `i32.(DebugPrintable.Print)()` will look for `i32 as DebugPrintable` not
    `Type as DebugPrintable`.

## Background

-   [#989: Member access expressions](/proposals/p0989.md) introduced the
    current compound member access rules.
-   [Issue #495](https://github.com/carbon-language/carbon-lang/issues/495)
    suggested adding an implicit conversion from tuples of types to type `Type`.
-   [Issue #508](https://github.com/carbon-language/carbon-lang/issues/508)
    raised the question of whether we want tuples like `((), (), ())` to be
    self-typed.

## Proposal

Instead of treating type-like values as being types regardless of the type of
those values, we define a _type_ as being a value of type `Type`. Therefore:

-   `()` is a value of type `() as Type`, not a value of type `()` (because the
    latter is not a type).
    -   `() as Type` is a value of type `Type`.
    -   Similarly, `(i32, i32)` is of type `(Type, Type) as Type`, which is of
        type `Type`.
    -   Similarly, `{}` is of type `{} as Type`, which is of type `Type`.
    -   More generally, _the type of any type is `Type`_.
-   Given `T:! Hashable`, `T` is formally not a type, because it is not of type
    `Type`. Indeed, member lookup into `Type`, and hence into types, finds
    nothing, but member lookup into `T` finds members of `Hashable`.
-   Contexts in which a type is required, such as on the right hand side of a
    `:` or `:!` binding or the return type of a function, perform an implicit
    conversion to type `Type`.
    -   This means that a user-defined type can implement `ImplicitAs(Type)`,
        annotated in whatever way we eventually decide to annotate functions
        that are usable at compile time, and values of that type will be usable
        as types, in the same way that `()` and `{}` are.
-   There are no singleton type-of-types. It's still possible to have, for
    example, the type of `i32` be a type whose only value is `i32`. The value
    `i32` would then not formally be a type, as its type would not be `Type`,
    but it could still implicitly convert to `Type`, as `()` does, if we so
    desire.
    -   This extends to other cases: we could say that for integer literals,
        which we have recently been describing as having type `IntLiteral(n)`,
        there is an `impl IntLiteral(n) as ImplicitAs(Type)` which converts a
        value of type `IntLiteral(n)` to the `Type` value `IntLiteral(n)`. This
        would then permit `let v: 0 = 0;`.
    -   Such changes to `i32` or integer literals are not part of this proposal.

## Details

### Terminology

The changes to the language rules in this proposal are fairly small, but there
is a significant change in how we describe those rules. We now use the following
terminology:

-   A _type_ is a value of type `Type`.
-   A _kind_ is a constrained or unconstrained version of `Type`, such as an
    interface type or a named constraint type. We previously referred to a kind
    as a type-of-type, but that is no longer accurate, as the type of any type
    is now by definition `Type`.
    -   When one kind has a superset of the constraints of another kind, we say
        it is a _subkind_. For example, `Hashable & Movable` is a subkind of
        `Hashable`, which is a subkind of `Type`.
-   A _facet_ is a value of a kind other than `Type`. For example,
    `i32 as Hashable` is a facet. Note that facets are not types.
-   We use the term _generic type_ to refer to a type or facet introduced by a
    `:!` binding, such as in a generic parameter or associated constant.
    -   This gives rise to terms such as _generic type parameter_ and
        _associated generic type_.
    -   It is worth noting that a generic type is not necessarily a type, as its
        type may be an interface or constraint rather than `Type`.

### Compound member access

The syntax `x.(Y)`, where `Y` names an instance member, now always performs
instance binding. Therefore, for a suitable `DebugPrintable`:

-   `1.(DebugPrintable.Print)()` still prints `1`, as before.
-   `i32.(DebugPrintable.Print)()` now prints `i32`, rather than forming a
    member name.
-   `1.(i32.(DebugPrintable.Print))()` is now an error, rather than printing
    `1`.

In order to get the old effect of `x.(MyType.(MyInterface.InstanceMember))()`,
one can now write `x.((MyType as MyInterface).InstanceMember)()`. This behaves
the same as the member access in:

```
fn F(MyType:! MyInterface, x: MyType) -> auto {
  return x.(MyType.InstanceMember)();
}
```

... because it is the same thing. `MyType as InstanceMember` is a facet, which
roughly corresponds to a fully-instanstiated `impl`, and lookup into a facet
finds members of that corresponding `impl`. And if `MyType` is declared as
`MyType:! MyInterface` instead of as `MyType:! Type`, then of course `MyType`
and `MyType as MyInterface` are equivalent.

### Tuple and struct literals

A tuple literal such as `(1, 2, 3)` produces a tuple value. Its type cannot be
written directly as a literal: the literal `(i32, i32, i32)` also produces a
tuple value, not a type value. However, the type of `(1, 2, 3)` is easy to
express: it is the result of implicitly converting `(i32, i32, i32)` to a type,
so for example `(i32, i32, i32) as Type` evaluates to the type of `(1, 2, 3)`.

There is no conversion from a tuple type to a tuple value, because tuple types
are values of type `Type`, and the type `Type` does not implicitly convert to a
tuple type. For metaprogramming, it is likely that we will benefit from having a
mechanism to convert a tuple type into a tuple of types, but this is likely to
be possible using a variadic:

```
@'''
Takes a tuple of values. Returns a tuple containing the types of those values.
'''
fn TupleTypeToTupleOfTypes[Types:! Type,...](x: (Types,...)) -> auto {
  return (Types,...);
}
```

### Name lookup into values with constrained types

Given a generic function with a generic type parameter, uses of that parameter
will be implicitly converted to type `Type`. For example:

```
fn F[T:! Printable](x: T) { x.Print(); }
```

... is equivalent to ...

```
fn F[T:! Printable](x: T as Type) { x.Print(); }
```

As a result, we can no longer describe lookup for `x` as looking into the
type-of-type, that is, the type of the expression after `x:`, because after
implicit conversion, that expression is of type `Type`. Instead, lookup will
look into the type of `x`, which symbolically evaluates to `T`, and will look at
the value `T` to determine where else to look. Because `T` is symbolically the
name of a generic type parameter, we will look in the type of `T`, which is
`Printable`.

## Rationale

-   [Language tools and ecosystem](/docs/project/goals.md#language-tools-and-ecosystem)
    -   Making the behavior of tuples and empty structs more like other types is
        easier for tooling to handle.
-   [Software and language evolution](/docs/project/goals.md#software-and-language-evolution)
    -   The transition between templates and generics is made smoother by
        changing compound member access to behave consistently regardless of
        whether the left-hand operand is a type.
-   [Code that is easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write)
    -   Bottoming out at the same type, `Type`, for all types is likely to be
        easier to understand. However, having `(i32, i32)` not be the type of a
        pair of integers, but instead be _implicitly convertible to_ the type of
        a pair of integers, is likely to be harder to understand. It's unclear
        which of these will be more dominant, but the new behavior is more
        consistent.

## Alternatives considered

### Alternative terminology

We considered various alternatives for the terminology choices listed above.

Instead of "kind" we considered:

-   constraint type
    -   Concern: a "foo type" can mean "a type that is also a foo" like "class
        type" or it can mean "a type that holds foos" like "integer type".
-   constrained type
    -   Concern: for some of us, this name seemed to better describe facets than
        kinds.
-   constraint
    -   Concern: this may sound like it should refer to a boolean predicate,
        `T is C`, not `C` itself.

Instead of "generic type" we considered:

-   archetype
    -   Concern: the usage here didn't match some of our intuitions based on
        existing usage of this term.
    -   Concern: while this might fit usage within the scope of the parameter,
        it fits usage from outside the scope less well. It seemed awkward to say
        that a class has an archetype parameter, as opposed to our chosen
        terminology of a generic type parameter.
-   constrained type variable
    -   Concern: for some of us, the name "constrained type" seemed to better
        describe kinds than facets.
-   type-like
    -   Concern: derived terms like "generic type-like parameter" and
        "associated type-like constant" are awkward.
-   kinded
    -   Concern: derived terms like "generic kinded parameter" and "associated
        kinded constant" are awkward.

Instead of "facet" we considered:

-   impl
    -   Concern: facets are analogous to `impl`s but are not in direct
        correspondence, because a facet can be for a constraint that involves
        multiple interfaces and hence potentially multiple `impl`s, and an
        `impl` can be for a constraint that involves multiple interfaces and
        hence a facet can refer to only _part of_ an `impl`.
-   archetype
    -   Concern: this seems inappropriate for non-generic facets, such as
        `i32 as Hashable`.
-   witness
    -   Concern: doesn't quite represent what we mean: a facet is more like a
        pair of a type and a witness that that type implements the facet's type.
