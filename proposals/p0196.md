# Language-level safety strategy

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/196)

## Table of contents

<!-- toc -->

-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Alternatives considered](#alternatives-considered)
    -   [Full compile-time enforced safety by default (Rust's model)](#full-compile-time-enforced-safety-by-default-rusts-model)
    -   [Rust's model but without preventing data races](#rusts-model-but-without-preventing-data-races)
    -   [Dynamic lifetime safety and compile-time enforced safety otherwise (Swift's model)](#dynamic-lifetime-safety-and-compile-time-enforced-safety-otherwise-swifts-model)
    -   [Dynamic lifetime safety and defined behavior (Java's model)](#dynamic-lifetime-safety-and-defined-behavior-javas-model)

<!-- tocstop -->

## Problem

Carbon needs to have a clear and consistent strategy for approaching the
problems of language-level safety. These problems have been persistent and
growing sources of both bugs and security vulnerabilities in C and C++ software.
Failure to effectively and carefully address safety concerns is likely to
undermine any hope of Carbon being a successful path forward for today's C++
users.

## Background

-   [Fearless Security: Memory Safety](https://hacks.mozilla.org/2019/01/fearless-security-memory-safety/)
-   [A proactive approach to more secure code](https://msrc-blog.microsoft.com/2019/07/16/a-proactive-approach-to-more-secure-code/)
-   [Memory safety](https://www.chromium.org/Home/chromium-security/memory-safety)
-   [MemSafe](https://doi.org/10.1002/spe.2105)
    -   Notably introduces the terms "_spatial_" and "_temporal_" safety.

## Proposal

We propose a safety strategy for Carbon that aims for incrementally increasing
the compile-time proven safety while allowing for dynamic checks to cover what
remains. It also prioritizes dynamic safety checks that are amenable to being
optimized away or being manually disabled for performance-critical use cases
where the added dynamic protections are not a viable trade-off.

## Alternatives considered

### Full compile-time enforced safety by default (Rust's model)

We could commit to the same level of compile-time enforced safety as Rust does.
This still allows for `unsafe` blocks as in Rust, and library types that provide
_dynamic_ safety enforcement but are implemented with some `unsafe` internals.
Note that our intent is to leave the door _open_ to this model despite not
pursuing it initially.

Pros:

-   Full safety (even against data races) provided at compile time.
-   Early evidence shows _significant_ impact in reducing bugs generally.
-   Unsafe operations can effectively be treated as bugs rather than becoming
    "valid", but surprising and often unintended, behaviors.
-   Can likely leverage the huge work of the Rust community to understand what
    is necessary.
-   Careful use of narrow `unsafe` escape hatches can be effectively
    encapsulated behind otherwise safe APIs.

Cons:

-   Effectively requires widespread different design patterns and idioms from
    C++.
    -   Designing data structures to avoid sharing mutable state.
    -   Fully modeling lifetime and exclusivity in the type system.
    -   Increased complexity of node/pointer based data structures like linked
        lists.
-   Many techniques currently used by Rust have unsolved compilation scaling
    challenges due to interprocedural inference and increases in the set of
    types with generic code.
-   Complexity of type system proofs of safety may incentivize unnecessary
    dynamic checking of safety properties. For example, an unnecessary `RefCell`
    or `Rc`.
-   Some of the most essential dynamic safety tools that ease the ergonomic
    burden of the Rust-style lifetime model (`Rc`) introduce _semantic_
    differences that cannot then be eliminated in a context where performance is
    the dominant priority.
-   Remains an open (if fairly difficult) evolution path for the language even
    if we don't eagerly pursue.

### Rust's model but without preventing data races

We could replicate the Rust model as above but additionally not trying to
statically preclude data races.

Pros:

-   Outside of data races provides same benefits as above.

Cons:

-   Unclear that removing the data race prevention aspect (law of exclusivity)
    is sufficient to meaningfully address the cons above. Most of the lifetime
    complexity remains unchanged.
    -   Would no longer need `RefCell`, but would still need `Rc` and `ARc`.

### Dynamic lifetime safety and compile-time enforced safety otherwise (Swift's model)

Swift defaults to dynamically enforced lifetime safety and no data race
prevention, and only requires compile time enforcement of the remaining spatial
safety properties. This _does_ remove the majority of the type system complexity
needed to support the safety in Rust's model.

Pros:

-   Significantly simpler model than Rust's.
-   Safe for all of the most common and important classes of memory safety bugs.

Cons:

-   Results in significant design differences as the distinction between value
    types and "class types" (that are held by a reference counted pointer and
    thus lifetime safe) becomes extremely important.
-   Reference counting based safety introduces significant performance costs
    with very difficult tools for controlling them. This puts the option in
    tension with the performance goal of Carbon.
-   Garbage collection based safety has less direct performance overhead but has
    a greater unpredictability of performance.

### Dynamic lifetime safety and defined behavior (Java's model)

Another approach to safety is to largely provide defined and predictable
behavior for all potential safety violations, which is what Java does (at the
highest level). This, combined with some form of dynamic lifetime management,
otherwise known as garbage collection, forms the basis of Java's safety.

Pros:

-   Among the most robust and well studied models with decades of practical
    usage and analysis for security properties.
-   Extremely suitable for efficient implementation on top of a virtual machine
    like the JVM.

Cons:

-   Extremely high complexity to fully understand the implications of complex
    cases like data races.
-   Tends to require _significant_ performance overhead without the aid of a
    very powerful VM-based execution environment with highly dynamic
    optimizations.
    -   The complexity of the implementation in turn creates difficult to
        _predict_ performance.
