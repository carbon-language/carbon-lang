# Design guidance for safety checking syntax

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/235)

<!-- toc -->

## Table of contents

-   [Problem](#problem)
-   [Background](#background)
    -   [Bounds checking](#bounds-checking)
    -   [Efficient safety for hardened builds](#efficient-safety-for-hardened-builds)
    -   ["assume" proposal for C++](#assume-proposal-for-c)
    -   [Rust safety](#rust-safety)
    -   [Related Carbon safety documentation](#related-carbon-safety-documentation)
    -   [Tentative `$` syntax](#tentative--syntax)
-   [Open question: what high-level approach is desired?](#open-question-what-high-level-approach-is-desired)
    -   [Base example code](#base-example-code)
    -   [Option: Use `@ifdef` to disable safety checks](#option-use-ifdef-to-disable-safety-checks)
    -   [Option: Relocate safety checks](#option-relocate-safety-checks)
    -   [Option: Emphasize](#option-emphasize)
    -   [----------------------](#----------------------)
        -   [Allow flagging code to be removed by optimizer](#allow-flagging-code-to-be-removed-by-optimizer)
    -   [Disabling safety checks](#disabling-safety-checks)
        -   [`$ifdef` metaprogramming](#ifdef-metaprogramming)
        -   [Provide syntax to generate various options for a function](#provide-syntax-to-generate-various-options-for-a-function)
        -   [Each function must implement its own `$checked` logic](#each-function-must-implement-its-own-checked-logic)
            -   [Alternative considered: Allow callers to control checking logic of arbitrary functions](#alternative-considered-allow-callers-to-control-checking-logic-of-arbitrary-functions)
        -   [Open question: what would call sites look like?](#open-question-what-would-call-sites-look-like)
            -   [Function operator](#function-operator)
            -   [Metaprogramming wrapper](#metaprogramming-wrapper)
            -   [Scoped call forms](#scoped-call-forms)

<!-- tocstop -->

## Problem

[Bounds checking](https://en.wikipedia.org/wiki/Bounds_checking) is a common
form of spatial memory safety that we would like to provide in Carbon, in order
to prevent common bugs. We need to choose a syntax for implementing bounds
checking. This could either use existing syntax or a new syntax oriented towards
specialized needs of safety.

In other words:

1. There will be safety checks that, by default, add performance overhead.
2. Some applications may have code where it is _never_ acceptable to have that
   performance overhead, not even in debug or hardened builds.
3. Developers need a way to opt out of the respective safety behaviors.

This question is about what developers should do to opt out of safety behaviors
in, for example, hot-path code.

Given the options and discussion so far, the purpose of this proposal is to get
_guidance_ towards a design path, not to decide details.

## Background

### Bounds checking

Out-Of-Bounds (OOB) is a common programming error affecting application
security. See
[iSecCon-2018-12](https://github.com/google/sanitizers/blob/master/hwaddress-sanitizer/MTE-iSecCon-2018.pdf),
[BlueHat-2019-02](https://github.com/microsoft/MSRC-Security-Research/tree/master/presentations/2019_02_BlueHatIL)
(slide 11), and the
[Project Zero Findings](https://bugs.chromium.org/p/project-zero/issues/list?sort=-id&q=%22use%20after%20free%22&can=1).

The standard solution for out-of-bounds errors is
[bounds checking](https://en.wikipedia.org/wiki/Bounds_checking). Bounds
checking can be broken down into two categories:

-   Index checking, such as checking that an index into a 4-element array is
    between 0 and 3.
-   Range checking, such as checking that a value being assigned to a 16-bit
    integer fits within its capacity.

Note that bounds checks are not always trivial; for example, an
`utf8_print(String: message)` function may want to check that the message
contains only valid UTF-8 characters. This could be considered a range check,
because it's ensuring the contents of the message are within the range of UTF-8
characters.

### Efficient safety for hardened builds

Carbon aims to provide a hardened build with mitigations to prevent all possible
safety violations. This is expected to be a significant performance hit, and
while that may be acceptable for the debug build mode, programs using the
hardened build mode for releases may be more interested in recovering
performance, especially on hot-path code.

When considering syntax for safety, we should do so with the expectation that
developers will be interested in using it to recover performance within hardened
builds, even at greater development cost. As such, it should aim to build
something closer to compile-time provable safety guarantees.

### "assume" proposal for C++

The C++ proposal
"[Contracts have failed to provide a portable “assume”](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1773r0.pdf)"
could be considered to be related to this. Whereas that proposal is focused on
achieving optimizations, similar syntax could also aid in guiding optimizations
for safety checks.

A key nuance of "assume" in the context of safety is that while it may aid
developers in writing code that optimizes, the condition is not checked. As a
result, if used in conjunction with safety, safety should not be expected unless
other features are added.

### Rust safety

Rust safety is not about eliminating all bugs, just sources of undefined
behavior. This includes few specific forms of safety:

-   type-safety,
-   memory-safety (dangling pointer, use-after-free),
-   preventing data races.

There is other behavior that you would certainly want to avoid but is out of
scope for Rust safety, such as
[general race conditions](https://doc.rust-lang.org/nomicon/races.html), integer
overflow, deadlock. The specifics of what bad stuff we are trying to avoid with
a safety system will not be the focus of this document, and we can imagine that
Carbon might have a different list of bad stuff than Rust.

Furthermore, Rust is not aiming to be a completely safe language, where the
compiler ensures safety rules can never be violated. Instead it defines two
"modes": safe and unsafe. In safe mode, the compiler ensures that code is safe
by rejecting it if it doesn't follow certain rules. These rules are generally
sufficient to ensure safety, but not necessary, so you can switch to unsafe mode
to write code outside those rules. This can be for expressivity reasons, like
making a data structure, performance reasons, like avoiding a bounds check, or
to interoperate with code in another language (which the Rust compiler is not
going to validate follows its rules). Unsafe code has extra capabilities but has
to be trusted more since the compiler can't verify it doesn't misbehave. The
intent is that you minimize the amount of untrusted code and then scrutinize it
extra carefully. This safe/unsafe split is also present in other languages such
as C#.

The above is described in great detail in
[The Rustonomicon](https://doc.rust-lang.org/nomicon/), for example
[What Unsafe Can Do](https://doc.rust-lang.org/nomicon/what-unsafe-does.html).
For this document, we are more concerned with what it says about
[How Safe and Unsafe Interact](https://doc.rust-lang.org/nomicon/safe-unsafe-meaning.html):

    The `unsafe` keyword has two uses: to declare the existence of contracts the compiler can't check, and to declare that a programmer has checked that these contracts have been upheld.

Functions, traits, and code blocks may be marked `unsafe` in Rust. Unsafe
functions may only be called inside an unsafe code block. Adding an unsafe code
block makes your code less safe, but marking a function as unsafe should make it
safer, with one caveat. The caveat is that bodies of unsafe functions are
implicitly in an unsafe code block, even when only part of the function needs
it. They also
[extend to the module visibility boundary](https://www.ralfj.de/blog/2016/01/09/the-scope-of-unsafe.html),
which can be a teachability problem. This isn't an inherent part of the model
though.

Unsafe traits may only be implemented inside an `unsafe` code block. (Note: a
trait in Rust is like a protocol in Swift or an interface in Carbon.) A trait
will be marked `unsafe`, though, not because implementations of that trait may
need to access unsafe capabilities, but if it is _unsafe to implement_. Unsafe
code may need a trait not just to do something memory safe, but actually
implement the trait's contract _correctly_ to avoid invoking undefined behavior.
This is part of a general theme that code in an unsafe code block has to be
written very carefully, even when it calls safe code. Otherwise the unsafe code
compromises the safety of the entire system.

An API is _sound_ if all possible uses of it are safe. The goal when writing
code using `unsafe` is to still expose a sound API, but this often requires
careful reasoning. A bit more about soundness in practice in Rust
[here](https://docs.rs/dtolnay/0.0.9/dtolnay/macro._03__soundness_bugs.html).
However note that there are limits to Rust's safety, it does not defend against
actively malicious code. For example, even though `open()` is a safe function,
it won't prevent opening `"/proc/self/mem"` and overwriting the memory of the
process.

More background can be found in this paper:
[Understanding Memory and Thread Safety Practices and Issues in Real-World Rust Programs](https://cseweb.ucsd.edu/~yiying/RustStudy-PLDI20.pdf).

### Related Carbon safety documentation

-   [Carbon: Memory Safety](https://docs.google.com/document/d/1SXC55_hugGkGwmF_rLyPNfTmD9noGWUkooG9jhIfX8Q/edit)
-   [Carbon: Safer Unsafe](https://docs.google.com/document/d/1pvoX0HFkRwvtaRKxAwWrH-z9JWHTb4BciYdlpBNHAlw/edit)
    (integrated into this proposal)

### Tentative `$` syntax

`$` is used here as part of the convention of indicating tentative names. A
decision on a path is not approval of `$` syntax.

## Open question: what high-level approach is desired?

There are several ways that safety could be implemented in Carbon, a couple
which would not require safety-specific features to be added. In order to
establish early consensus among the core team, this proposal revolves around a
single question: what high-level approach is desired?

Some of this extends to a question of what problem we're trying to address; is
the goal of syntax to assist developers who want to _relocate_ safety checks, or
_disable_ safety checks?

This decision has effects on trade-offs between the degree of safety which
continues to be provided and the amount of developer effort to build/maintain
performance-related safety mitigations.

While this will primarily affect developers using the hardened build mode while
optimizing frequently-called functions, it may also affect developers using the
development build mode should they have code which is unexpectedly and severely
impacted by safety checks. For contrast, the performance build mode should
generally not be affected because checks won't be enabled there.

### Base example code

For consideration of this question, it can be helpful to consider code which
would invoke bounds checking in a loop. Conceptually, bounds checks in a loop is
less efficient than demonstrating that bounds will never be violated outside the
loop.

Examples will be based on this code:

```carbon
// Consider `Get` as a Carbon-provided library function.
fn Get(Array: array, Int: index) -> String inline {
  // This is the bounds check of performance interest.
  assert(index >= 0 && index < array.size);
  return array.data[index];
}

// Consider `CustomPrint` as a developer-provided function.
fn CustomPrint(Array: array, Int: index) inline {
  // Note that this operation triggers the above bounds check.
  PrintF("Array[%d]: %s\n", index, array.Get(index));
}

// Consider `CustomPrintAll` as a developer-provided function.
fn CustomPrintRange(Array: array, Int: start, Int: end) {
  for (var Int: i = start; i < end; ++i) {
    CustomPrint(array, i);
  }
}
```

In this example, although a developer may be able to figure out that `start` and
`end` are always between `0` and `array.size`, the optimizer may not. As a
result, the bounds check would still consistently execute. If this becomes a
performance problem, how should the performance problem be fixed?

### Option: Use `@ifdef` to disable safety checks

Developers could be required to use a `@ifdef` metaprogramming syntax. Defines
for `DEBUG_BUILD_MODE`, `PERFORMANCE_BUILD_MODE`, and `HARDENED_BUILD_MODE`
could be provided, and developers could be required to make explicit decisions
about whether code should do checks in particular build modes. This would
require libraries to provide "unchecked" versions of functions to be called from
within an `@ifdef`.

This is offered mainly as a basis for trade-offs of other options. However, some
form of the tools necessary for this approach will likely be present in Carbon
metaprogramming, regardless of whether the option is chosen for safety. This
means the approach could be added as an "escape hatch" for other options,
although that would still require `GetUnchecked` and equivalents to be provided
by Carbon libraries.

For example, a `GetUnchecked` function would be added and called by
`CustomPrint`. `Get` and `CustomPrintRange` would remain unchanged.

```carbon
// The "unchecked" variant of `Get` does no `assert`.
fn GetUnchecked(Array: array, Int: index) -> String inline {
  return array.data[index];
}

// Consider `CustomPrint` as a developer-provided function.
fn CustomPrint(Array: array, Int: index) inline {
  // Note the `@ifdef` only does the bounds check in the debug build mode.
  PrintF("Array[%d]: %s\n", index,
@ifdef DEBUG_BUILD_MODE
        array.Get(index)
@else
        array.GetUnchecked(index)
@endif
        );
}
```

### Option: Relocate safety checks

Carbon could require developers to relocate safety checks, and provide a proof
that the safety check has been relocated that can be verified by the compiler or
optimizer.

This can be considered using the
[`assume` syntax](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1773r0.pdf).
The intent of the `assume` is to make it clearer for the optimizer that the user
is working to prove a later `assert`, which could then be optimized away.

For example:

```carbon
// Consider `CustomPrintAll` as a developer-provided function.
fn CustomPrintRange(Array: array, Int: start, Int: end) {
  assume(start >= 0 && start < array.size);
  assume(end >= 0 && end < array.size);
  for (var Int: i = start; i < end; ++i) {
    CustomPrint(array, i);
  }
}
```

**Forwarding state across calls**

An issue with this approach is how the `assume` is propagated across functions;
in the `CustomPrintRange` example, `CustomPrint` may prevent the `assume` from
being used to optimize away the `assert`s in `Get`. In order to address this,
it's possible that preconditions will need to be _explicitly_ marked in function
signatures, to allow the compiler to forward state.

This may result in an additional `precondition` syntax. This should be expected
to be seen in function signatures that may need to forward `assume` information.
Although this syntax may change based on implementation challenges, it would
need to be something that could easily be handled by the compiler and optimizer.

Extending the example:

```carbon
// Consider `Get` as a Carbon-provided library function.
fn Get(Array: array, Int: index) -> String inline precondition(index >= 0 && index < array.size) {
  // This is the bounds check of performance interest.
  assert(index >= 0 && index < array.size);
  return array.data[index];
}

// Consider `CustomPrint` as a developer-provided function.
fn CustomPrint(Array: array, Int: index) inline precondition(index >= 0 && index < array.size) {
  // Note that this operation triggers the above bounds check.
  PrintF("Array[%d]: %s\n", index, array.Get(index));
}
```

**Trade-offs**

Advantages:

-   The safety check still occurs in the hardened build mode. This extends the
    safety, even though additional syntax is necessary to optimize away the
    `assert`.

-   It's clear at the site of the `assume` what logic is occurring, and the
    rationale that developers are using to optimize the related safety check
    away.

-   The syntax has a level of conciseness because the `assume` and
    `precondition` may be ignored by callers.

-   If a function calls multiple functions with different `precondition`s, it
    should be able to compose the multiple `precondition`s into its own
    `precondition` list. Callers which can only prove a single set of
    `precondition`s could receive only the corresponding optimizations, without
    losing the safety of the other call.

Disadvantages:

-   There is no guarantee that the optimizer will eliminate redundant code.
    Developers will be expected to rely on benchmarks to prove that their
    `assume` is providing the desired optimization.

    -   If there are any side-effects to the assert, or the optimizer cannot
        prove there aren't side-effects, the optimizer will not eliminate
        redundant checks. This may also mean there is only partial logic
        removal, resulting in incomplete optimizations.

    -   If the `precondition` doesn't match either the `assert` or `assume`,
        checks change over time, or optimizations change in some way that no
        longer makes the connection between `assert` and `assume`, optimizations
        will silently break. This should be detected by developers monitoring
        their benchmarks.

-   Optimizations may only occur where developers can provide an equivalent
    proof that is understandable by the compiler. It may prove difficult to
    support non-trivial safety checks.

### Option: Emphasize

### ----------------------

#### Allow flagging code to be removed by optimizer

Optimizations may remove checks regardless of what a developer does. However,
optimizations are not reliable, and after a developer validates they fire, they
may quietly stop triggering due to either variations between build modes, code
changes, or compiler changes.

Whereas a simple `$ifdef` syntax of requiring the developer to disable checks in
order to guarantee that a check does not fire, Carbon could instead build
support for writing tests that verify a check is optimized away.

A basis for this might be a metaprogramming syntax, such as
`$require_removed_by_optimizer`, that errors if the compiler does not remove a
block of code. For example:

```carbon
// Skips the expensive check in performance builds.
fn Get(Int: index) -> String inline {
$ifndef PERFORMANCE_BUILD_MODE
  assert(index >= 0);
$endif
  return data_[index];
}

// Requires that the expensive check be optimized away (provably passes),
// regardless of build mode.
fn GetOptimized(Int: index) -> String inline {
  $require_removed_by_optimizer(assert(index >= 0));
  return data_[index];
}

// Requires that the expensive check be optimized away (provably passes),
// regardless of build mode.
fn FastPrint(Int: index) inline {
   print(GetOptimized(index));
}
```

In this example, the advantage for FastPrint is that it can ensure the assert
can be optimized away, regardless of build mode.

Advantages:

-   Provides a checked way for developers to optimize hardened code.

Disadvantages:

-   Introduces new language syntax.
    -   May require different syntax to make it easier to do compile-time
        proofs.
-   Three versions of `Get()` for developers to choose from: `Get()`,
    `GetUnchecked()`, and `GetOptimized()`.
    -   `GetUnchecked()` remains required because callers of `FastPrint()` may
        in reality not be able to demonstrate that `index >= 0` for the
        optimizer, and affected callers would need to switch to `GetUnchecked()`
        to maintain performance. As a consequence, there may need to be both
        `FastPrintUnchecked()` and `FastPrintOptimized()` as well, spreading the
        number of related methods.
-   No comparable C++ support should be expected.
    -   Achieving similar behavior for C++ interoperability would require Carbon
        wrappers.

### Disabling safety checks

#### `$ifdef` metaprogramming

In C++, the standard response would be to write code like `#ifdef NDEBUG`, and
do conditional safety checks within that block. Through that, build modes
defining NDEBUG will get safety checks, and non-debug release builds can avoid
the overhead of the safety checks.

In Carbon, we could do similar through metaprogramming. For example,
`$ifdef DEBUG_BUILD_MODE` could be used to write debug-specific safety checks.
This can be trivially expanded to cover any other build mode that's added, and
may be supported regardless of safety through a generic define mechanism. There
is no reason to believe this requires additional support.

For developers interested in optimizing hot path code in the hardened build
mode, unchecked versions of functions could be provided; for example,
`Get(Int: index)` being mirrored by `GetUnchecked(Int: index)` on Carbon's
built-in array type. The developers could validate that the code passes checks
in debug builds using `$ifdef`, only calling the unchecked function in hardened
builds.

For example:

```carbon
// Skips the expensive check in performance builds.
fn Get(Int: index) -> String inline {
$ifndef PERFORMANCE_BUILD_MODE
  assert(index >= 0);
$endif
  return data_[index];
}

// Allows optionally skipping the expensive check, regardless of build mode.
fn GetUnchecked(Int: index) -> String inline {
  return data_[index];
}

// Avoids the expensive check in the hardened build mode.
fn FastPrint(Int: index) {
$ifdef DEBUG_BUILD_MODE
   print(Get(index));
$else
   print(GetUnchecked(index));
$endif
}
```

This can be considered the baseline option, because it relies primarily on
library changes rather than language changes.

#### Provide syntax to generate various options for a function

This builds upon the concepts introduced by the preceding approach by making it
easier to maintain the three different versions of the function.

We can add another function marker, `$checked`, that implies `inline` and
generates the three versions that developers might want to choose from, all with
the same function name. These are effectively overloads; a special calling
syntax, `$<char>`, where `<char>` is one of `u`, `o`, or `f`, will be added to
designate which version of the function should be called. If this calling syntax
is not present, the checked version is called. The `$<char>` calling syntax is
invalid for non-`$checked` functions.

To explain these characters:

-   `$u` calls the unchecked version of a function. In other words, no asserts
    are run, and it is up to the caller to validate inputs.
-   `$o` calls the compile-time optimized version of a function. In other words,
    marked asserts must be provable at compile-time, and it will be a compile
    error if that cannot be done.
-   `$f` is only valid within a `$checked` function, and forwards the calling
    mode of the current function to the designated function. For example, if the
    current function was called unchecked, the designated function will be
    called unchecked.
-   If none of the above characters are specified, the checked version is
    called. This is true even for `$checked` functions. When writing example
    function footprints in this proposal, `$c `is sometimes used to emphasize
    that is the checked version (the default behavior), but `$c` is not proposed
    syntax and would never be present in a call site.

For example:

```carbon
fn Get(Int: index) -> String $checked {
  $can_be_removed_by_optimizer(assert(index >= 0));
  return data_[index];
}

// Requires that the expensive check be optimized away (provably passes),
// regardless of build mode.
fn FastPrint(Int: index) inline {
  print(Get$o(index));
}

// Could choose between the optimized or checked versions based on whether the
// compiler can successfully optimize away checks.
fn SafePrint(Int: index) inline {
  print(Get(index));
}
```

This would effectively generate three different versions of `Get()`, equivalent
to what exists in the "allow flagging" approach, but more succinctly coded:

```carbon
fn Get$c(Int: index) -> String {
  assert(index >= 0);
  return data_[index];
}

fn Get$u(Int: index) -> String {
  return data_[index];
}

fn Get$o(Int: index) -> String {
  $require_removed_by_optimizer(assert(index >= 0));
  return data_[index];
}
```

In the examples, `data_[index]` always calls the checked version because no
`$<char>` calling syntax is used. There is no implicit change to what is called
based on the version of `Get()`.

Advantages:

-   Provides a more succinct syntax for implementing more function versions.
-   Allows more optimizations: a function which calls the checked version, such
    as `SafePrint()`, could be promoted to the optimized version if the
    requirements can be proven.
    -   This isn't significant in the given example, but opens the door for
        differing implementations based on whether prerequisites can be proven.
-   Allows broader safety: a function calling `Get$u()` could still be
    compile-time checked against the assert. While the expectation would not be
    a performance improvement (the assert won't run for unchecked), it may catch
    errors where the caller provably has an invalid `index`.
-   Improves Carbon's ergonomics for safety, mirroring a
    [language goal](https://github.com/carbon-language/carbon-lang/blob/trunk/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write).

Disadvantages:

-   Introduces substantially more syntax, and opens the door for even more. A
    couple further syntaxes that should be considered are:
    -   A way to write logic that's conditional based on how the \$checked
        function was called. For example, `$if checked`.
    -   A way to write functions which do only checked and unchecked versions,
        not optimized.
-   No comparable C++ support should be expected.
    -   Achieving similar behavior for C++ interoperability would require Carbon
        wrappers.
-   Improving the ergonomics could lead to unnecessary use, increasing generated
    code size from the three variants.
    -   It may not be obvious to developers that adding the `$checked` attribute
        triples generated code size for the marked function.
    -   Forcing developers to write three copies imposes a developer effort tax
        to reduce copies.

#### Each function must implement its own `$checked` logic

Callers may provide input by calling a particular checked or unchecked form of a
function, but the function implementer explicitly decides how the function
should execute. Each function must implement its own `$checked` logic, assuming
non-default behavior is desired. Consider a call chain of `Function1()` calling
`Function2()` calling `Function3()`, for example:

```carbon
fn Function1() {
  Function2();
}

fn Function2() {
  Function3();
}

fn Function3() $checked {
  // Arbitrary code.
}
```

There is no way for `Function1()` to control whether `Function3()` is checked;
the implementation of `Function2()` decides that. In particular:

-   `Function1()` cannot call an unchecked version of `Function2()`.
    -   As stated
    -   `Function1()` cannot force `Function2()` to call `Function3()` in an
        unchecked way.
-   Even if `Function2()` were `$checked`, it would need to have explicit
    support for calling `Function3` in an unchecked way, such as `Function3$u()`
    or `Function3$f()`.

##### Alternative considered: Allow callers to control checking logic of arbitrary functions

Under the proposed approach, whether a given function will execute as checked is
locally apparent and easy to determine. Any approach allowing `Function1()` to
control whether `Function3()` executes as checked when `Function2()` calls it,
without explicit support from the implementation of `Function2()`, removes that
ease of reading, will have unintended consequences on the ability of debug mode
to detect safety-related logic errors, and consequently increases the risk of
production safety violations.

#### Open question: what would call sites look like?

The `$<char>` call syntax is one option amongst several.

I lean towards a metaprogramming wrapper, and feedback from the core team if
they'd prefer a function operator would be helpful.

##### Function operator

The idea of the `$<char>` operator is that it is short to write, while the
two-character sequence only reserves the first `$` character for this use. This
may be a bit confusing if supported for operators.

For example:

```carbon
fn FastPrint(Int: index) inline {
  print(Get$o(index));
}

fn FastAdd(Int: i, Int: j) -> Int inline {
  return i +$o j
}
```

##### Metaprogramming wrapper

Instead of an operator, functions could be wrapped with a metaprogramming
keyword. This could be thought of as selecting the version to call. It's more
verbose, but clearer in what's happening.

For example, we could add `$optimized_check` to replace the preceding `$o`
operator:

```carbon
fn FastPrint(Int: index) inline {
  return $optimized_check(Get)(index);
}

fn FastAdd(Int: i, Int: j) -> Int inline {
  return i $optimized_check(+) j
}
```

##### Scoped call forms

We could designate that all calls within a scope use the specified form. When
calling functions which are not `$checked`, this could either be treated as a
programming error (require restricting scopes to only `$checked` functions), or
a no-op (making chaining function calls easier).

For example:

```carbon
fn FastPrint(Int: index) inline {
  $use_optimized_check {
    return Get(index);
  }
}

fn FastAdd(Int: i, Int: j) -> Int inline {
  $use_optimized_check {
    return i + j
  }
}
```
