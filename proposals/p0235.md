# Design guidance for safety checking syntax

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/235)

<!-- toc -->

## Table of contents

-   [Problem](#problem)
    -   [Why ask for guidance?](#why-ask-for-guidance)
-   [Background](#background)
    -   [Bounds checking](#bounds-checking)
    -   [Efficient safety for hardened builds](#efficient-safety-for-hardened-builds)
    -   ["assume" proposal for C++](#assume-proposal-for-c)
    -   [Rust safety](#rust-safety)
    -   [Related Carbon safety documentation](#related-carbon-safety-documentation)
    -   [Tentative `$` syntax](#tentative--syntax)
-   [Open question: what high-level approach is desired?](#open-question-what-high-level-approach-is-desired)
    -   [Disabling safety checks](#disabling-safety-checks)
        -   [`$ifdef` metaprogramming](#ifdef-metaprogramming)
        -   [Provide syntax to generate various options for a function](#provide-syntax-to-generate-various-options-for-a-function)
        -   [Each function must implement its own `$checked` logic](#each-function-must-implement-its-own-checked-logic)
            -   [Alternative considered: Allow callers to control checking logic of arbitrary functions](#alternative-considered-allow-callers-to-control-checking-logic-of-arbitrary-functions)
        -   [Open question: what would call sites look like?](#open-question-what-would-call-sites-look-like)
            -   [Function operator](#function-operator)
            -   [Metaprogramming wrapper](#metaprogramming-wrapper)
            -   [Scoped call forms](#scoped-call-forms)
    -   [Relocating safety checks](#relocating-safety-checks)
        -   [Use `assume` syntax](#use-assume-syntax)
        -   [Allow flagging code to be removed by optimizer](#allow-flagging-code-to-be-removed-by-optimizer)

<!-- tocstop -->

## Problem

[Bounds checking](https://en.wikipedia.org/wiki/Bounds_checking) is a common
form of spatial memory safety that we would like to provide in Carbon, in order
to prevent common bugs. We need to choose a syntax for implementing bounds
checking. This could either use existing syntax or a new syntax oriented towards
specialized needs of safety.

In other words:

1. There will be safety checks that, by default, add performance overhead.
2. Some applications may have code where it is _never_ acceptable to have that
   performance overhead, not even in debug or hardened builds.
3. Developers need a way to opt out of the respective safety behaviors.

This question is about what developers should do to opt out of safety behaviors
in, for example, hot-path code.

Given the options and discussion so far, the purpose of this proposal is to get
_guidance_ towards a design path, not to decide details.

### Why ask for guidance?

In response to early drafts using `$checked` syntax, the `$ifdef` approach was
advocated as a solution that could work. Given the advantages and disadvantages
between the approaches, I am trying to get consensus on which approach to use
before proceeding further.

## Background

### Bounds checking

Out-Of-Bounds (OOB) is a common programming error affecting application
security. See
[iSecCon-2018-12](https://github.com/google/sanitizers/blob/master/hwaddress-sanitizer/MTE-iSecCon-2018.pdf),
[BlueHat-2019-02](https://github.com/microsoft/MSRC-Security-Research/tree/master/presentations/2019_02_BlueHatIL)
(slide 11), and the
[Project Zero Findings](https://bugs.chromium.org/p/project-zero/issues/list?sort=-id&q=%22use%20after%20free%22&can=1).

The standard solution for out-of-bounds errors is
[bounds checking](https://en.wikipedia.org/wiki/Bounds_checking). Bounds
checking can be broken down into two categories:

-   Index checking, such as checking that an index into a 4-element array is
    between 0 and 3.
-   Range checking, such as checking that a value being assigned to a 16-bit
    integer fits within its capacity.

Note that bounds checks are not always trivial; for example, an
`utf8_print(String: message)` function may want to check that the message
contains only valid UTF-8 characters. This could be considered a range check,
because it's ensuring the contents of the message are within the range of UTF-8
characters.

### Efficient safety for hardened builds

Carbon aims to provide a hardened build with mitigations to prevent all possible
safety violations. This is expected to be a significant performance hit, and
while that may be acceptable for the debug build mode, programs using the
hardened build mode for releases may be more interested in recovering
performance, especially on hot-path code.

When considering syntax for safety, we should do so with the expectation that
developers will be interested in using it to recover performance within hardened
builds, even at greater development cost. As such, it should aim to build
something closer to compile-time provable safety guarantees.

### "assume" proposal for C++

The C++ proposal
"[Contracts have failed to provide a portable “assume”](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1773r0.pdf)"
could be considered to be related to this. Whereas that proposal is focused on
achieving optimizations, similar syntax could also aid in guiding optimizations
for safety checks.

A key nuance of "assume" in the context of safety is that while it may aid
developers in writing code that optimizes, the condition is not checked. As a
result, if used in conjunction with safety, safety should not be expected unless
other features are added.

### Rust safety

Rust safety is not about eliminating all bugs, just sources of undefined
behavior. This includes few specific forms of safety:

-   type-safety,
-   memory-safety (dangling pointer, use-after-free),
-   preventing data races.

There is other behavior that you would certainly want to avoid but is out of
scope for Rust safety, such as
[general race conditions](https://doc.rust-lang.org/nomicon/races.html), integer
overflow, deadlock. The specifics of what bad stuff we are trying to avoid with
a safety system will not be the focus of this document, and we can imagine that
Carbon might have a different list of bad stuff than Rust.

Furthermore, Rust is not aiming to be a completely safe language, where the
compiler ensures safety rules can never be violated. Instead it defines two
"modes": safe and unsafe. In safe mode, the compiler ensures that code is safe
by rejecting it if it doesn't follow certain rules. These rules are generally
sufficient to ensure safety, but not necessary, so you can switch to unsafe mode
to write code outside those rules. This can be for expressivity reasons, like
making a data structure, performance reasons, like avoiding a bounds check, or
to interoperate with code in another language (which the Rust compiler is not
going to validate follows its rules). Unsafe code has extra capabilities but has
to be trusted more since the compiler can't verify it doesn't misbehave. The
intent is that you minimize the amount of untrusted code and then scrutinize it
extra carefully. This safe/unsafe split is also present in other languages such
as C#.

The above is described in great detail in
[The Rustonomicon](https://doc.rust-lang.org/nomicon/), for example
[What Unsafe Can Do](https://doc.rust-lang.org/nomicon/what-unsafe-does.html).
For this document, we are more concerned with what it says about
[How Safe and Unsafe Interact](https://doc.rust-lang.org/nomicon/safe-unsafe-meaning.html):

    The `unsafe` keyword has two uses: to declare the existence of contracts the compiler can't check, and to declare that a programmer has checked that these contracts have been upheld.

Functions, traits, and code blocks may be marked `unsafe` in Rust. Unsafe
functions may only be called inside an unsafe code block. Adding an unsafe code
block makes your code less safe, but marking a function as unsafe should make it
safer, with one caveat. The caveat is that bodies of unsafe functions are
implicitly in an unsafe code block, even when only part of the function needs
it. They also
[extend to the module visibility boundary](https://www.ralfj.de/blog/2016/01/09/the-scope-of-unsafe.html),
which can be a teachability problem. This isn't an inherent part of the model
though.

Unsafe traits may only be implemented inside an `unsafe` code block. (Note: a
trait in Rust is like a protocol in Swift or an interface in Carbon.) A trait
will be marked `unsafe`, though, not because implementations of that trait may
need to access unsafe capabilities, but if it is _unsafe to implement_. Unsafe
code may need a trait not just to do something memory safe, but actually
implement the trait's contract _correctly_ to avoid invoking undefined behavior.
This is part of a general theme that code in an unsafe code block has to be
written very carefully, even when it calls safe code. Otherwise the unsafe code
compromises the safety of the entire system.

An API is _sound_ if all possible uses of it are safe. The goal when writing
code using `unsafe` is to still expose a sound API, but this often requires
careful reasoning. A bit more about soundness in practice in Rust
[here](https://docs.rs/dtolnay/0.0.9/dtolnay/macro._03__soundness_bugs.html).
However note that there are limits to Rust's safety, it does not defend against
actively malicious code. For example, even though `open()` is a safe function,
it won't prevent opening `"/proc/self/mem"` and overwriting the memory of the
process.

More background can be found in this paper:
[Understanding Memory and Thread Safety Practices and Issues in Real-World Rust Programs](https://cseweb.ucsd.edu/~yiying/RustStudy-PLDI20.pdf).

### Related Carbon safety documentation

-   [Carbon: Memory Safety](https://docs.google.com/document/d/1SXC55_hugGkGwmF_rLyPNfTmD9noGWUkooG9jhIfX8Q/edit)
-   [Carbon: Safer Unsafe](https://docs.google.com/document/d/1pvoX0HFkRwvtaRKxAwWrH-z9JWHTb4BciYdlpBNHAlw/edit)
    (integrated into this proposal)

### Tentative `$` syntax

`$` is used here as part of the convention of indicating tentative names. A
decision on a path is not approval of `$` syntax.

## Open question: what high-level approach is desired?

There are several ways that safety could be implemented in Carbon, a couple
which would not require safety-specific features to be added. In order to
establish early consensus among the core team, this proposal revolves around a
single question: what high-level approach is desired?

Some of this extends to a question of what problem we're trying to address; is
the goal of syntax to assist developers who want to _disable_ safety checks, or
_relocate_ safety checks?

### Disabling safety checks

#### `$ifdef` metaprogramming

In C++, the standard response would be to write code like `#ifdef NDEBUG`, and
do conditional safety checks within that block. Through that, build modes
defining NDEBUG will get safety checks, and non-debug release builds can avoid
the overhead of the safety checks.

In Carbon, we could do similar through metaprogramming. For example,
`$ifdef DEBUG_BUILD_MODE` could be used to write debug-specific safety checks.
This can be trivially expanded to cover any other build mode that's added, and
may be supported regardless of safety through a generic define mechanism. There
is no reason to believe this requires additional support.

For developers interested in optimizing hot path code in the hardened build
mode, unchecked versions of functions could be provided; for example,
`Get(Int: index)` being mirrored by `GetUnchecked(Int: index)` on Carbon's
built-in array type. The developers could validate that the code passes checks
in debug builds using `$ifdef`, only calling the unchecked function in hardened
builds.

For example:

```carbon
// Skips the expensive check in performance builds.
fn Get(Int: index) -> String inline {
$ifndef PERFORMANCE_BUILD_MODE
  assert(index >= 0);
$endif
  return data_[index];
}

// Allows optionally skipping the expensive check, regardless of build mode.
fn GetUnchecked(Int: index) -> String inline {
  return data_[index];
}

// Avoids the expensive check in the hardened build mode.
fn FastPrint(Int: index) {
$ifdef DEBUG_BUILD_MODE
   print(Get(index));
$else
   print(GetUnchecked(index));
$endif
}
```

This can be considered the baseline option, because it relies primarily on
library changes rather than language changes.

#### Provide syntax to generate various options for a function

This builds upon the concepts introduced by the preceding approach by making it
easier to maintain the three different versions of the function.

We can add another function marker, `$checked`, that implies `inline` and
generates the three versions that developers might want to choose from, all with
the same function name. These are effectively overloads; a special calling
syntax, `$<char>`, where `<char>` is one of `u`, `o`, or `f`, will be added to
designate which version of the function should be called. If this calling syntax
is not present, the checked version is called. The `$<char>` calling syntax is
invalid for non-`$checked` functions.

To explain these characters:

-   `$u` calls the unchecked version of a function. In other words, no asserts
    are run, and it is up to the caller to validate inputs.
-   `$o` calls the compile-time optimized version of a function. In other words,
    marked asserts must be provable at compile-time, and it will be a compile
    error if that cannot be done.
-   `$f` is only valid within a `$checked` function, and forwards the calling
    mode of the current function to the designated function. For example, if the
    current function was called unchecked, the designated function will be
    called unchecked.
-   If none of the above characters are specified, the checked version is
    called. This is true even for `$checked` functions. When writing example
    function footprints in this proposal, `$c `is sometimes used to emphasize
    that is the checked version (the default behavior), but `$c` is not proposed
    syntax and would never be present in a call site.

For example:

```carbon
fn Get(Int: index) -> String $checked {
  $can_be_removed_by_optimizer(assert(index >= 0));
  return data_[index];
}

// Requires that the expensive check be optimized away (provably passes),
// regardless of build mode.
fn FastPrint(Int: index) inline {
  print(Get$o(index));
}

// Could choose between the optimized or checked versions based on whether the
// compiler can successfully optimize away checks.
fn SafePrint(Int: index) inline {
  print(Get(index));
}
```

This would effectively generate three different versions of `Get()`, equivalent
to what exists in the "allow flagging" approach, but more succinctly coded:

```carbon
fn Get$c(Int: index) -> String {
  assert(index >= 0);
  return data_[index];
}

fn Get$u(Int: index) -> String {
  return data_[index];
}

fn Get$o(Int: index) -> String {
  $require_removed_by_optimizer(assert(index >= 0));
  return data_[index];
}
```

In the examples, `data_[index]` always calls the checked version because no
`$<char>` calling syntax is used. There is no implicit change to what is called
based on the version of `Get()`.

Advantages:

-   Provides a more succinct syntax for implementing more function versions.
-   Allows more optimizations: a function which calls the checked version, such
    as `SafePrint()`, could be promoted to the optimized version if the
    requirements can be proven.
    -   This isn't significant in the given example, but opens the door for
        differing implementations based on whether prerequisites can be proven.
-   Allows broader safety: a function calling `Get$u()` could still be
    compile-time checked against the assert. While the expectation would not be
    a performance improvement (the assert won't run for unchecked), it may catch
    errors where the caller provably has an invalid `index`.
-   Improves Carbon's ergonomics for safety, mirroring a
    [language goal](https://github.com/carbon-language/carbon-lang/blob/trunk/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write).

Disadvantages:

-   Introduces substantially more syntax, and opens the door for even more. A
    couple further syntaxes that should be considered are:
    -   A way to write logic that's conditional based on how the \$checked
        function was called. For example, `$if checked`.
    -   A way to write functions which do only checked and unchecked versions,
        not optimized.
-   No comparable C++ support should be expected.
    -   Achieving similar behavior for C++ interoperability would require Carbon
        wrappers.
-   Improving the ergonomics could lead to unnecessary use, increasing generated
    code size from the three variants.
    -   It may not be obvious to developers that adding the `$checked` attribute
        triples generated code size for the marked function.
    -   Forcing developers to write three copies imposes a developer effort tax
        to reduce copies.

#### Each function must implement its own `$checked` logic

Callers may provide input by calling a particular checked or unchecked form of a
function, but the function implementer explicitly decides how the function
should execute. Each function must implement its own `$checked` logic, assuming
non-default behavior is desired. Consider a call chain of `Function1()` calling
`Function2()` calling `Function3()`, for example:

```carbon
fn Function1() {
  Function2();
}

fn Function2() {
  Function3();
}

fn Function3() $checked {
  // Arbitrary code.
}
```

There is no way for `Function1()` to control whether `Function3()` is checked;
the implementation of `Function2()` decides that. In particular:

-   `Function1()` cannot call an unchecked version of `Function2()`.
    -   As stated
    -   `Function1()` cannot force `Function2()` to call `Function3()` in an
        unchecked way.
-   Even if `Function2()` were `$checked`, it would need to have explicit
    support for calling `Function3` in an unchecked way, such as `Function3$u()`
    or `Function3$f()`.

##### Alternative considered: Allow callers to control checking logic of arbitrary functions

Under the proposed approach, whether a given function will execute as checked is
locally apparent and easy to determine. Any approach allowing `Function1()` to
control whether `Function3()` executes as checked when `Function2()` calls it,
without explicit support from the implementation of `Function2()`, removes that
ease of reading, will have unintended consequences on the ability of debug mode
to detect safety-related logic errors, and consequently increases the risk of
production safety violations.

#### Open question: what would call sites look like?

The `$<char>` call syntax is one option amongst several.

I lean towards a metaprogramming wrapper, and feedback from the core team if
they'd prefer a function operator would be helpful.

##### Function operator

The idea of the `$<char>` operator is that it is short to write, while the
two-character sequence only reserves the first `$` character for this use. This
may be a bit confusing if supported for operators.

For example:

```carbon
fn FastPrint(Int: index) inline {
  print(Get$o(index));
}

fn FastAdd(Int: i, Int: j) -> Int inline {
  return i +$o j
}
```

##### Metaprogramming wrapper

Instead of an operator, functions could be wrapped with a metaprogramming
keyword. This could be thought of as selecting the version to call. It's more
verbose, but clearer in what's happening.

For example, we could add `$optimized_check` to replace the preceding `$o`
operator:

```carbon
fn FastPrint(Int: index) inline {
  return $optimized_check(Get)(index);
}

fn FastAdd(Int: i, Int: j) -> Int inline {
  return i $optimized_check(+) j
}
```

##### Scoped call forms

We could designate that all calls within a scope use the specified form. When
calling functions which are not `$checked`, this could either be treated as a
programming error (require restricting scopes to only `$checked` functions), or
a no-op (making chaining function calls easier).

For example:

```carbon
fn FastPrint(Int: index) inline {
  $use_optimized_check {
    return Get(index);
  }
}

fn FastAdd(Int: i, Int: j) -> Int inline {
  $use_optimized_check {
    return i + j
  }
}
```

### Relocating safety checks

If the priority is on _relocating_ safety checks, syntax is focused on the
concept that checks must still be run.

#### Use `assume` syntax

The
<code>[assume proposal](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1773r0.pdf)</code>
offers a model for lifting out optimizations into call sites. This can be used
in safety to relocate safety checks, while maintaining provability of safety.

TODO

Advantages:

-   Concise syntax (TODO)

-   It's clear at the site of the `assume` what logic is occurring, and the
    rationale that developers are using to optimize the related safety check
    away.

Disadvantages:

-   There is no guarantee that the written `assume` body matches the
    requirements of the library function.

    -   Adding such a guarantee would require validation of `assume` contents
        with the precondition between both the implementation and call site.
        This means that call sites will be brittle and possibly break if the
        implementation changes in a way that's incompatible with earlier
        assumes. For example, changing the safety check would require a
        multi-step refactoring: adding a new function with the new safety check,
        migrating all callers to the new function and new `assume` logic, then
        deleting the old function.

-   Proving optimizations occur likely relies on developers writing and
    maintaining benchmarks.

-   It's difficult to confidently eliminate costs for the `assume`.
    Optimizations may not be able to remove all code related to the
    optimized-away safety check if it cannot be proven they lack side-effects.

-   It may prove difficult to relocate safety checks to places where they are
    both efficient to run and provable for the optimizer. In these cases,
    developers may still need a way to disable safety checks.

#### Allow flagging code to be removed by optimizer

Optimizations may remove checks regardless of what a developer does. However,
optimizations are not reliable, and after a developer validates they fire, they
may quietly stop triggering due to either variations between build modes, code
changes, or compiler changes.

Whereas a simple `$ifdef` syntax of requiring the developer to disable checks in
order to guarantee that a check does not fire, Carbon could instead build
support for writing tests that verify a check is optimized away.

A basis for this might be a metaprogramming syntax, such as
`$require_removed_by_optimizer`, that errors if the compiler does not remove a
block of code. For example:

```carbon
// Skips the expensive check in performance builds.
fn Get(Int: index) -> String inline {
$ifndef PERFORMANCE_BUILD_MODE
  assert(index >= 0);
$endif
  return data_[index];
}

// Requires that the expensive check be optimized away (provably passes),
// regardless of build mode.
fn GetOptimized(Int: index) -> String inline {
  $require_removed_by_optimizer(assert(index >= 0));
  return data_[index];
}

// Requires that the expensive check be optimized away (provably passes),
// regardless of build mode.
fn FastPrint(Int: index) inline {
   print(GetOptimized(index));
}
```

In this example, the advantage for FastPrint is that it can ensure the assert
can be optimized away, regardless of build mode.

Advantages:

-   Provides a checked way for developers to optimize hardened code.

Disadvantages:

-   Introduces new language syntax.
    -   May require different syntax to make it easier to do compile-time
        proofs.
-   Three versions of `Get()` for developers to choose from: `Get()`,
    `GetUnchecked()`, and `GetOptimized()`.
    -   `GetUnchecked()` remains required because callers of `FastPrint()` may
        in reality not be able to demonstrate that `index >= 0` for the
        optimizer, and affected callers would need to switch to `GetUnchecked()`
        to maintain performance. As a consequence, there may need to be both
        `FastPrintUnchecked()` and `FastPrintOptimized()` as well, spreading the
        number of related methods.
-   No comparable C++ support should be expected.
    -   Achieving similar behavior for C++ interoperability would require Carbon
        wrappers.
