# Termination algorithm for impl selection

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/2687)

<!-- toc -->

## Table of contents

-   [Abstract](#abstract)
-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Details](#details)
    -   [Non-type arguments](#non-type-arguments)
    -   [Proof of termination](#proof-of-termination)
-   [Rationale](#rationale)
-   [Alternatives considered](#alternatives-considered)
    -   [Measure complexity using type tree depth](#measure-complexity-using-type-tree-depth)
    -   [Consider each type parameter in an `impl` declaration separately](#consider-each-type-parameter-in-an-impl-declaration-separately)
    -   [Consider types in the interface being implemented as distinct](#consider-types-in-the-interface-being-implemented-as-distinct)

<!-- tocstop -->

## Abstract

This proposal replaces the termination algorithm for `impl` selection. The
previous algorithm relied a recursion limit, which is counter to
[our goal for predictability](/docs/design/generics/goals.md#predictability).

The replacement is to terminate if any `impl` declaration depends transitively
on itself with a "strict superset" type as one of its parameters.

## Problem

Consider this `impl` declaration:

```
interface I;
impl forall [T:! type where Optional(.Self) is I] T as I;
```

A type like `i32` is a valid value of `T`, and so implements `I`, if
`Optional(i32)` implements `I`. This `impl` declaration could also possibly be
used to give an implementation of `Optional(i32)` for interface `I`, but only if
there was an implementation of `Optional(Optional(i32))` for interface `I`. The
job of the termination rule is to report an error instead of being caught in an
infinite loop in this situation.

Ideally, a termination rule would identify the loop in a minimal way. This has a
few benefits, including reducing compile times and making error messages as
short and understandable as they can be. One downside of the original recursion
limit rule is its tendency to only detect a problem after the loop had been
repeated many times. This is made worse if the recursion limit is large.

Another concern with using a recursion limit is that refactorings that would
otherwise be legal can increase the depth of recursion, causing spurious
failures. The workaround for this and other spurious failures is to increase the
recursion limit. This makes the other problems with using a recursion limit
worse.

## Background

The first termination rule was introduced in proposal
[#920: Generic parameterized impls (details 5)](https://github.com/carbon-language/carbon-lang/pull/920),
following Rust and C++. The problems with using a recursion limit were
[recognized at the time that proposal was written](https://github.com/carbon-language/carbon-lang/blob/f282bca20e41e2f8dc05881d9d6b38213d6c6c87/docs/design/generics/details.md#termination-rule),
but no alternative was known.

Alternatives termination rules have since been discussed:

-   in open discussion on
    [2022-04-13](https://docs.google.com/document/d/1tEt4iM6vfcY0O0DG0uOEMIbaXcZXlNREc2ChNiEtn_w/edit#heading=h.cja3fkwzv9tr),
    prompted by a question on
    [#1088: Generic details 10: interface-implemented requirements](https://github.com/carbon-language/carbon-lang/pull/1088);
    and
-   in issue
    [#2458: Infinite recursion during impl selection](https://github.com/carbon-language/carbon-lang/issues/2458),
    which includes summaries of discussions including those on
    [2023-02-07](https://docs.google.com/document/d/1gnJBTfY81fZYvI_QXjwKk1uQHYBNHGqRLI2BS_cYYNQ/edit?resourcekey=0-ql1Q1WvTcDvhycf8LbA9DQ#heading=h.9u2u6078figt).

PR
[#2602: Implement the termination algorithm for impl selection described in #2458](https://github.com/carbon-language/carbon-lang/pull/2602)
implements the termination rule of this proposal in Explorer.

## Proposal

We replace the termination criteria with a rule that the types in the `impl`
query must never get strictly more complicated. The way we measure the
complexity of a set of types is by counting how many of each base type appears.
A base type is the name of a type without its parameters. For example, the base
types in this query `Pair(Optional(i32), bool) impls AddWith(Optional(i32))`
are:

-   `Pair`
-   `Optional` twice
-   `i32` twice
-   `bool`
-   `AddWith`

A query is strictly more complicated if at least one count increases, and no
count decreases. So `Optional(Optional(i32))` is strictly more complicated than
`Optional(i32)` but not strictly more complicated than `Optional(bool)`.

This rule, when combined with
[the acyclic rule](/docs/design/generics/details.md#acyclic-rule) that a query
can't repeat exactly, [guarantees termination](#proof-of-termination). This rule
is expected to identify a problematic sequence of `impl` declaration
instantiations in a way that is easier for the user to understand. Consider the
example from before,

```
interface I;
impl forall [T:! type where Optional(.Self) is I] T as I;
```

This `impl` declaration matches the query `i32 impls I` as long as
`Optional(i32) impls I`. That is a strictly more complicated query, though,
since it contains all the base types of the starting query (`i32` and `I`), plus
one more (`Optional`). As a result, an error can be given after one step, rather
than after hitting a large recursion limit. And that error can state explicitly
what went wrong: we went from a query with no `Optional` to one with one,
without anything else decreasing.

FIXME: It is robust in the face of refactoring.

## Details

TODO: Fully explain the details of the proposed solution.

### Non-type arguments

FIXME

### Proof of termination

FIXME

## Rationale

TODO: How does this proposal effectively advance Carbon's goals? Rather than
re-stating the full motivation, this should connect that motivation back to
Carbon's stated goals and principles. This may evolve during review. Use links
to appropriate sections of [`/docs/project/goals.md`](/docs/project/goals.md),
and/or to documents in [`/docs/project/principles`](/docs/project/principles).
For example:

-   [Community and culture](/docs/project/goals.md#community-and-culture)
-   [Language tools and ecosystem](/docs/project/goals.md#language-tools-and-ecosystem)
-   [Performance-critical software](/docs/project/goals.md#performance-critical-software)
-   [Software and language evolution](/docs/project/goals.md#software-and-language-evolution)
-   [Code that is easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write)
-   [Practical safety and testing mechanisms](/docs/project/goals.md#practical-safety-and-testing-mechanisms)
-   [Fast and scalable development](/docs/project/goals.md#fast-and-scalable-development)
-   [Modern OS platforms, hardware architectures, and environments](/docs/project/goals.md#modern-os-platforms-hardware-architectures-and-environments)
-   [Interoperability with and migration from existing C++ code](/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code)

## Alternatives considered

TODO: What alternative solutions have you considered?

Status quo discussed above

### Measure complexity using type tree depth

FIXME: problem: sensitive to refactorings that replace a type (like `String`)
with an alias to a parameterized type (like `BasicString(Char8)`).

### Consider each type parameter in an `impl` declaration separately

FIXME: advantage: allows more

FIXME: disadvantage: sensitive to the specifics of how `impl` declarations are
parameterized, raising concerns about refactorings introducing termination rule
failures.

### Consider types in the interface being implemented as distinct

FIXME: advantage: allows more, though not as much as previous alternative

FIXME: advantage: not sensitive to the specifics of how `impl` declarations are
parameterized

Not choosing this alternative now since it is a more complicated rule to
explain. But we would consider this alternative in the future if we find that
the additional cases this rule permits was beneficial in practice.
