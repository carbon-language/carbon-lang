# `extend api`

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/3802)

<!-- toc -->

## Table of contents

-   [Abstract](#abstract)
-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Details](#details)
    -   [`extend api` with interfaces](#extend-api-with-interfaces)
    -   [Use case: Member forwarding](#use-case-member-forwarding)
    -   [Use case: Reference library type](#use-case-reference-library-type)
    -   [Use case: with implicit conversion](#use-case-with-implicit-conversion)
    -   [Use case: extension methods](#use-case-extension-methods)
    -   [Modeling other language constructs](#modeling-other-language-constructs)
    -   [Future work: customizing impl binding](#future-work-customizing-impl-binding)
-   [Rationale](#rationale)
-   [Alternatives considered](#alternatives-considered)
    -   [Allow `extend api` of an incomplete type](#allow-extend-api-of-an-incomplete-type)
    -   [Make some name resolutions cases unambiguous with `extend api`](#make-some-name-resolutions-cases-unambiguous-with-extend-api)

<!-- tocstop -->

## Abstract

Allow types to `extend api` other types, adding the names from the other types
to its namespace, for forwarding and delegation use cases.

## Problem

FIXME: What problem are you trying to solve? How important is that problem? Who
is impacted by it?

**Non-goal:** Addressing how one type can inherit the interface implementations
of another type. This occurs with `extend base` and `extend adapt`. That is
[future work](#future-work-customizing-impl-binding).

## Background

FIXME: Is there any background that readers should consider to fully understand
this problem and your approach to solving it?

## Proposal

We propose adding a declaration in a type definition to find names defined in
another type, [`extend api T`](#extend-api):

```carbon
class Extended {
  fn F[self: Self]();
  fn G[self: Self]();
}

class Extending {
  fn G[self: Self]();
  extend api Extended;
  impl as ImplicitAs(Extended);
}

var e: Extending;
```

This means that lookup into `Extending` also looks in the type `Extended` for
members. In this way, `e.F` will find `e.(Extended.F)`. Note that does not make
`e.F()` actually work unless `Extended.F` was somehow legal to call on an value
of type `Extending`. In the example, this is accomplished by defining an
implicit conversion from `Extending` to `Extended`.

The lookup rules for `extend api` are consistent with the other uses of
`extend`, with conflicts handled as determined by leads issues
[#2355](https://github.com/carbon-language/carbon-lang/issues/2355) and
[#2745](https://github.com/carbon-language/carbon-lang/issues/2745). This means
`Extending` is equivalent to:

```carbon
class Extending {
  fn G[self: Self]();
  alias F = Extended.F;
  impl as ImplicitAs(Extended);
}
```

The extended type is required to be complete at the point of the `extend api`
declaration, so the lookups that will be performed in the the containing class
definition into the extended type can succeed.

## Details

Normally simple member access on a value
[looks in the type of that value](/docs/design/expressions/member_access.md#values).
However, types can designate other entities to also look up in using the
`extend` keyword (see [proposal #2760](/proposals/p2760.md#proposal)):

-   `extend impl as I` adds lookup into the implementation of an interface `I`.
-   `extend base: B` adds lookup into the base class `B`.
-   `extend adapt C` adds lookup into the adapted class `C`.
-   [mixins are also planning](/proposals/p2760.md#future-work-mixins) on using
    an `extend` syntax

For some use cases, we want to be able to add name to lookup into that type
without making other changes to the type, for which we introduce `extend api`,
with consistent lookup rules as the other uses of `extend`, with conflicts
handled as determined by leads issues
[#2355](https://github.com/carbon-language/carbon-lang/issues/2355) and
[#2745](https://github.com/carbon-language/carbon-lang/issues/2745).

The extended type is required to be complete at the point of the `extend api`
declaration, so these lookups into `T` can succeed.

The general rule for resolving ambiguity for `extend`, which we apply here as
well, is that if lookup into `Box(T)` succeeds, then that result is used and no
lookup into `T` is performed. If a class uses `extend` more than once, and finds
the same name more than once, that is an ambiguity error that needs to be
resolved by qualifying the name on use.

> **FIXME:** Are these the right rules in the context of API evolution? See
> [comment on #3720](https://github.com/carbon-language/carbon-lang/pull/3720/files#r1527084183).

> **Note:** This is an alternative to defining an `alias` for each member of the
> extended type. This avoids having to repeat them, which is both lengthy and
> could get out of sync as the class evolves. The `extend api` approach works
> even if, as in this example, we don't know the names of the members of the
> type being extended.

Like other uses of `extend`, an `extend api` declaration do not have access
control modifiers and only operate on public names.

### `extend api` with interfaces

The examples so far use `extend api` between two classes, but we also allow it
with interfaces and named constraints.

For example, a class can `extend api` of an interface it
[conditionally conforms to](/docs/design/generics/details.md#conditional-conformance),
as in:

```carbon
interface A {
  fn F();
}
class C(T:! type) {
  extend api A;
}
impl C(i32) as A { fn F() { ... } }
```

Here, the class `C(T)` implements `A` for some values of `T`, such as `i32`.
Rather than manually individually aliasing the members of `A` in `C`, to make
them available as part of the API of `C`, so that `C(i32).F()` is valid, an
`extend api` declaration includes all of them at once.

Another use case is that an interface can `extend api` of another interface. In
this example,

```carbon
interface A {
  fn F();
}
interface B {
  extend api A;
  fn G();
}
```

`B.F` would be an alias for `A.F`, but without any implied
`require Self impls A`, in contrast with a plain `extend A`. So `extend I;` is
equivalent to `require Self impls I; extend api I;`.

Lastly, an interface could `extend api` a class. This could be done to add
something that acts like `final` functions to the interface, using
[extension methods](https://github.com/carbon-language/carbon-lang/issues/1345),
as in:

```carbon
class Helpers {
  fn F[T:! type, self: T]() { DoStuffWith(self); }
  // ...
}
interface Iface {
  extend api Helpers;
  fn G();
  // ...
}
class C {
  extend impl as Iface;
}
fn Test(c: C) {
  // Calls Helpers.F from extended class Helpers
  c.F();
}
```

Unlike `final` functions in an interface, this approach defines all the helpers
in a separate entity that could be used to extend more than one type.

### Use case: Member forwarding

Consider a class that we want to act like it has the members of another type.
For example, a type `Box(T)` that has a pointer to a `T` object allocated on the
heap:

```carbon
class Box(T:! type) {
  var ptr: T*;
  // ???
}
```

`Box(T)` should act like it has all the members of `T`:

```carbon
class String {
  fn Search[self: Self](c: u8) -> i32;
}
var b: Box(String) = ...;
var position: i32 = b.Search(32);
```

There are two ingredients to make this work:

-   We need some way to make `b.Search` be equivalent to `b.(String.Search)` not
    `b.(Box(String).Search)`.
-   We need the act of binding a method of `String` to a `Box(String)` value
    work by dereferencing the pointer `b.ptr`.

For the first ingredient, we use `extend api` to customize
[simple member access](/docs/design/expressions/member_access.md) for the class
`Box(T)`:

```carbon
class Box(T:! type) {
  var ptr: T*;
  extend api T;
}
```

This means that lookup into `Box(T)` also looks in the type `T` for members. In
this way, `b.Search` will find `b.(String.Search)`.

For the second ingredient, the binding interfaces from
[proposal #3720: "Binding operators"](https://github.com/carbon-language/carbon-lang/pull/3720)
already provide everything needed, we just need to make a parameterized
implementation of them:

```carbon
impl forall [T:! type, U:! ValueBind(T)]
    U as ValueBind(Box(T)) where .Result = U.Result {
  fn Op[self: Self](x: Box(T)) -> Result {
    // Uses `ValueBind(T).Op` based on type of `U`.
    return self.Op(*x.ptr);

    // NOT `return x.ptr->(self)` since that attempts
    // to do reference binding not value binding.
  }
}

impl forall [T:! type, U:! RefBind(T)]
    U as RefBind(Box(T)) where .Result = U.Result {
  fn Op[self: Self](p: Box(T)*) -> Result* {
    return self.Op(p->ptr);
    // Or equivalently:
    // return p->ptr->(self);
  }
}
```

A few observations:

-   These declarations use `Box` to satisfy the orphan rule, and so this
    approach only works with `Box(T)` values, not types that can implicitly
    convert to `Box(T)`.
-   The implementation of the `Op` method is where we follow the pointer member
    `ptr` of `Box(T)` to get a `T` value that is compatible with the member
    being bound. This resolves the type mismatch that is introduced by allowing
    name resolution to find another type's members.
-   We have to be a little careful in the implementation of `ValueBind(Box(T))`
    to still use value binding even when we get a reference expression from
    dereferencing the pointer `ptr`.

With these two ingredients, `b.Search(32)` is equivalent to
`b.(String.Search)(32)`, which is then equivalent to
`b.ptr->(String.Search)(32)` or `b.ptr->Search(32)` (since `b.ptr` has type
`String*`).

### Use case: Reference library type

> FIXME: Give the example of reference library type from
> [this comment on #3720](https://github.com/carbon-language/carbon-lang/pull/3720/files#r1513712572).

The `Box` type that was used as
[an example of member forwarding](#use-case-member-forwarding) preserves the
expression category -- you can only call mutating operations on a `Box`
reference expression, not on a `Box` value expression. For a library reference
type, we instead want to permit value binding for anything where `T` permits
reference binding:

```carbon
class Ref(T:! type) {
  var ptr: T*;
  extend api T;
}
impl forall [T:! type, U:! RefBind(T)]
    U as ValueBind(Ref(T)) where .Result = Ref(U.Result) {
  fn Op[self: Self](p: Ref(T)) -> Ref(Result) {
    return {.ptr = self.Op(p->ptr)};
  }
}
// (Plus impls for the other three combinations of ValueBind and RefBind.)
impl forall [S:! type, T:! Call(S)] Ref(T) as Call(S) where .Result = T.Result {
  // ...
}
```

For example, it could be used as:

```carbon
class C {
  fn F[addr self: Self*]();
  var n: i32;
}
fn F(r: Ref(C)) {
  // OK, even though `r` is a value expression.
  // `r.F` is a `Ref(<bound member function>)`,
  // which is callable.
  r.F();

  // OK, forms a reference to the `n` member.
  let n_ref: Ref(i32) = r.n;
}
```

Note, however, `Ref(T)` doesn't preserve the interface implementations of `T`,
see [future work](#future-work-customizing-impl-binding).

### Use case: with implicit conversion

A class could extend the API of a class it implicitly converts to. For example,
imagine we have a class representing an integer in a restricted range that can
implicitly convert to an integer value.

<!--FIXME: add text once #3720 is merged:
> , see
> [inheritance and other implicit conversions from proposal #3720](p3730.md#inheritance-and-other-implicit-conversions).
-->

```carbon
class InRange(Low:! i32, High:! i32) {
  var value: i32;
  impl as ImplicitAs(i32) {
    fn Convert[self: Self]() -> i32 { return self.value; }
  }
  extend api i32;
}
```

By including `extend api i32`, `InRange` gains support for any non-`addr`
methods on `i32`, like perhaps `Abs`.

### Use case: extension methods

Or a class could have members specifically intended for use by another class, as
[extension methods](https://github.com/carbon-language/carbon-lang/issues/1345)
-- effectively acting as mixin except it can't add member variables.

> **FIXME:** Give an example

### Modeling other language constructs

> FIXME: Show how to model other language constructs with `extend api`, custom
> binding, and implicit (or explicit) conversions, as described in
> [this comment on #3720](https://github.com/carbon-language/carbon-lang/pull/3720/files#r1527089564):
>
> -   other uses of `extend`,
> -   inheritance,
> -   virtual dispatch, and
> -   mixins.

### Future work: customizing impl binding

We might want a mechanism to also get (some) interface implementations from an
extended type. This already occurs for `extend adapt`, from
[proposal #731: Generics details 2: adapters, associated types, parameterized interfaces](https://github.com/carbon-language/carbon-lang/pull/731),
and refined by
[open discussion on 2023-04-06](https://docs.google.com/document/d/1gnJBTfY81fZYvI_QXjwKk1uQHYBNHGqRLI2BS_cYYNQ/edit?resourcekey=0-ql1Q1WvTcDvhycf8LbA9DQ&tab=t.0#heading=h.x4syhdu36xdc)
and [PR #3231](https://github.com/carbon-language/carbon-lang/pull/3231). That
open discussion expressed that interface implementations would also be inherited
with `extend base`, though there are more cases where you can't use a base class
implementation for the derived class than with adapters.

For example, the mechanism might allow customization of impl binding by
implementing an interface. See
[this comment on #3720](https://github.com/carbon-language/carbon-lang/pull/3720/files#r1527083149)
and
[2024-03-18 open discussion](https://docs.google.com/document/d/1s3mMCupmuSpWOFJGnvjoElcBIe2aoaysTIdyczvKX84/edit?resourcekey=0-G095Wc3sR6pW1hLJbGgE0g&tab=t.0#heading=h.23p8d6pqg1qp).
It is unclear how that would work, since the interfaces that would be
implemented by `extend base` and `extend adapt` are different, and
[the rules for conversions allowed by adapters are complex](https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/generics/details.md#adapter-compatibility).

## Rationale

FIXME: How does this proposal effectively advance Carbon's goals? Rather than
re-stating the full motivation, this should connect that motivation back to
Carbon's stated goals and principles. This may evolve during review. Use links
to appropriate sections of [`/docs/project/goals.md`](/docs/project/goals.md),
and/or to documents in [`/docs/project/principles`](/docs/project/principles).
For example:

-   [Community and culture](/docs/project/goals.md#community-and-culture)
-   [Language tools and ecosystem](/docs/project/goals.md#language-tools-and-ecosystem)
-   [Performance-critical software](/docs/project/goals.md#performance-critical-software)
-   [Software and language evolution](/docs/project/goals.md#software-and-language-evolution)
-   [Code that is easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write)
-   [Practical safety and testing mechanisms](/docs/project/goals.md#practical-safety-and-testing-mechanisms)
-   [Fast and scalable development](/docs/project/goals.md#fast-and-scalable-development)
-   [Modern OS platforms, hardware architectures, and environments](/docs/project/goals.md#modern-os-platforms-hardware-architectures-and-environments)
-   [Interoperability with and migration from existing C++ code](/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code)

## Alternatives considered

### Allow `extend api` of an incomplete type

We considered allowing `extend api T` with `T` an incomplete type. This has some
disadvantages:

-   `T` must be complete before the first time name lookup into it is performed.
    Actually avoiding name lookup into `T` is very difficult, though, since you
    need to be very careful to fully qualify (using `package.`) names used in
    the class definition, except those names defined within the class itself.
-   Other uses of `extend`, such as `extend base: T` require the type to be
    complete.
-   We did not have a use case for using `extend api` with an incomplete type.
-   Requiring complete types forces types to be defined in a total order,
    preventing cycles (`A` extends `B` extends `C` extends `A`).

This was discussed in the
[proposal review](https://github.com/carbon-language/carbon-lang/pull/3720/files#r1507988547)
and
[the #typesystem channel on Discord](https://discord.com/channels/655572317891461132/708431657849585705/1217499991329738852).

### Make some name resolutions cases unambiguous with `extend api`

TODO: See
[comment on #3720](https://github.com/carbon-language/carbon-lang/pull/3720/files#r1513671030)
