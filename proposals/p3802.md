# `extend api`

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/3802)

<!-- toc -->

## Table of contents

-   [Abstract](#abstract)
-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Details](#details)
    -   [Use case: Member forwarding](#use-case-member-forwarding)
    -   [Use case: Reference library type](#use-case-reference-library-type)
    -   [Use case: with implicit conversion](#use-case-with-implicit-conversion)
    -   [Use case: extension methods](#use-case-extension-methods)
    -   [`extend api` with interfaces](#extend-api-with-interfaces)
    -   [Modeling other language constructs](#modeling-other-language-constructs)
        -   [Modeling `extend impl`](#modeling-extend-impl)
        -   [Modeling `extend base`](#modeling-extend-base)
        -   [Modeling virtual dispatch](#modeling-virtual-dispatch)
        -   [Modeling `extend adapt`](#modeling-extend-adapt)
        -   [Modeling `extend` in interfaces and named constraints](#modeling-extend-in-interfaces-and-named-constraints)
        -   [Future work: modeling mixins](#future-work-modeling-mixins)
    -   [Future work: customizing impl binding](#future-work-customizing-impl-binding)
-   [Rationale](#rationale)
-   [Alternatives considered](#alternatives-considered)
    -   [Allow `extend api` of an incomplete type](#allow-extend-api-of-an-incomplete-type)
    -   [Make some name resolutions cases unambiguous with `extend api`](#make-some-name-resolutions-cases-unambiguous-with-extend-api)

<!-- tocstop -->

## Abstract

Allow types to `extend api` other types, adding the names from the other type to
its namespace, for forwarding and delegation use cases.

## Problem

Carbon has a number of constructs using the `extend` keyword that allow a type
to extend its API by the API of another type in various ways. For example, a
class can use `extend base` to inherit from a base class, or an interface can
`extend` another interface. One component of this is including the names of the
extended type in the extending type.

This capability is useful on its own, particularly when combined with the
ability customize how binding works for a type, as introduced in
[proposal #3720](https://github.com/carbon-language/carbon-lang/pull/3720), for
example [member forwarding](#use-case-member-forwarding).

It also allows most of the current `extend` constructs to be expressed as
[a rewrite into more primitive language feature](#modeling-other-language-constructs).
This is a useful strategy in general:

-   It gives a concrete way of explaining the language semantics.
-   It means that the rules governing different language constructs are
    consistent, which helps user learning and understanding, and allows the
    implementation to be smaller due to reuse of logic.
-   It gives users additional expressive power through the unbundling of
    capabilities the user might want to use individually, and the ability to
    combine the primitives in new ways.

**Non-goal:** This proposal does not address how one type can inherit the
_interface implementations_ of another type. This occurs with `extend adapt` and
is planned with `extend base`. Controlling that capability is
[future work](#future-work-customizing-impl-binding).

## Background

This proposal builds upon a number of previous proposals:

-   [Proposal #553: Generics details part 1](https://github.com/carbon-language/carbon-lang/pull/553)
    introduced interface extension and a way for classes to include the API of
    implemented interfaces.
-   [Proposal #731: Generics details 2: adapters, associated types, parameterized interfaces](https://github.com/carbon-language/carbon-lang/pull/731)
    defined extending adapters.
-   [#777: Inheritance](https://github.com/carbon-language/carbon-lang/pull/777)
    defined how a class could extend a base class.
-   [Proposal 2760: Consistent `class` and `interface` syntax](https://github.com/carbon-language/carbon-lang/pull/2760)
    changed the syntax to consistently use the `extend` keyword for any language
    construct that involves delegating name lookup to another type.
-   [Proposal #3720: Binding operators](https://github.com/carbon-language/carbon-lang/pull/3720)
    introduced customization of how member binding works, as in `x.y` or
    `x.(y)`. This proposal was originally part of #3720, but was split out.

## Proposal

We propose adding a declaration in a type definition to find names defined in
another type, [`extend api T`](#extend-api):

```carbon
class Extended {
  fn F[self: Self]();
  fn G[self: Self]();
}

class Extending {
  fn G[self: Self]();
  extend api Extended;
  impl as ImplicitAs(Extended);
}

var e: Extending;
```

This means that lookup into `Extending` also looks in the type `Extended` for
members. In this way, `e.F` will find `e.(Extended.F)`. Note that does not make
`e.F()` actually work unless `Extended.F` was somehow legal to call on an value
of type `Extending`. In the example, this is accomplished by defining an
implicit conversion from `Extending` to `Extended`.

Type definitions here include `class`, `interface`, and `constraint`
definitions.

The lookup rules for `extend api` are consistent with the other uses of
`extend`, with conflicts handled as determined by leads issues
[#2355](https://github.com/carbon-language/carbon-lang/issues/2355) and
[#2745](https://github.com/carbon-language/carbon-lang/issues/2745). This means
`Extending` is equivalent to:

```carbon
class Extending {
  fn G[self: Self]();
  alias F = Extended.F;
  impl as ImplicitAs(Extended);
}
```

The extended type is required to be complete at the point of the `extend api`
declaration, so the lookups that will be performed in the the containing class
definition into the extended type can succeed.

## Details

Normally simple member access on a value
[looks in the type of that value](/docs/design/expressions/member_access.md#values).
However, classes can designate other entities to also look up in using the
`extend` keyword (see [proposal #2760](/proposals/p2760.md#proposal)):

-   `extend impl as I` adds lookup into the implementation of an interface `I`.
-   `extend base: B` adds lookup into the base class `B`.
-   `extend adapt C` adds lookup into the adapted class `C`.
-   [mixins are also planning](/proposals/p2760.md#future-work-mixins) on using
    an `extend` syntax

Interfaces and named constraints also
[use the `extend` keyword](/docs/design/generics/details.md#interface-extension)
to lookup into another, which is also required.

For some use cases, we want to be able to add name to lookup into that type
without making other changes to the type, for which we introduce `extend api`,
with consistent lookup rules as the other uses of `extend`, with conflicts
handled as determined by leads issues
[#2355](https://github.com/carbon-language/carbon-lang/issues/2355) and
[#2745](https://github.com/carbon-language/carbon-lang/issues/2745).

The extended type is required to be complete at the point of the `extend api`
declaration, so these lookups into `T` can succeed.

The general rule for resolving ambiguity for `extend`, which we apply here as
well, is that if lookup into `Box(T)` succeeds, then that result is used and no
lookup into `T` is performed. If a class uses `extend` more than once, and finds
the same name more than once, that is an ambiguity error that needs to be
resolved by qualifying the name on use.

> **Future work:** Are these the right rules in the context of API evolution?
> See
> [comment on #3720](https://github.com/carbon-language/carbon-lang/pull/3720/files/97004ac6748a4f39e664d7409401df1811adc25c#r1527084183).

> **Note:** This is an alternative to defining an `alias` for each member of the
> extended type. This avoids having to repeat them, which is both lengthy and
> could get out of sync as the class evolves. The `extend api` approach works
> even if, as in this example, we don't know the names of the members of the
> type being extended.

Like other uses of `extend`, an `extend api` declaration do not have access
control modifiers and only operate on public names.

### Use case: Member forwarding

Consider a class that we want to act like it has the members of another type.
For example, a type `Box(T)` that has a pointer to a `T` object allocated on the
heap:

```carbon
class Box(T:! type) {
  var ptr: T*;
  // ???
}
```

`Box(T)` should act like it has all the members of `T`:

```carbon
class String {
  fn Search[self: Self](c: u8) -> i32;
}
var b: Box(String) = ...;
var position: i32 = b.Search(32);
```

There are two ingredients to make this work:

-   We need some way to make `b.Search` be equivalent to `b.(String.Search)` not
    `b.(Box(String).Search)`.
-   We need the act of binding a method of `String` to a `Box(String)` value
    work by dereferencing the pointer `b.ptr`.

For the first ingredient, we use `extend api` to customize
[simple member access](/docs/design/expressions/member_access.md) for the class
`Box(T)`:

```carbon
class Box(T:! type) {
  var ptr: T*;
  extend api T;
}
```

This means that lookup into `Box(T)` also looks in the type `T` for members. In
this way, `b.Search` will find `b.(String.Search)`.

For the second ingredient, the binding interfaces from
[proposal #3720: "Binding operators"](https://github.com/carbon-language/carbon-lang/pull/3720)
already provide everything needed, we just need to make a parameterized
implementation of them:

```carbon
impl forall [T:! type, U:! ValueBind(T)]
    U as ValueBind(Box(T)) where .Result = U.Result {
  fn Op[self: Self](x: Box(T)) -> Result {
    // Uses `ValueBind(T).Op` based on type of `U`.
    return self.Op(*x.ptr);

    // NOT `return x.ptr->(self)` since that attempts
    // to do reference binding not value binding.
  }
}

impl forall [T:! type, U:! RefBind(T)]
    U as RefBind(Box(T)) where .Result = U.Result {
  fn Op[self: Self](p: Box(T)*) -> Result* {
    return self.Op(p->ptr);
    // Or equivalently:
    // return p->ptr->(self);
  }
}
```

A few observations:

-   These declarations use `Box` to satisfy the orphan rule, and so this
    approach only works with `Box(T)` values, not types that can implicitly
    convert to `Box(T)`.
-   The implementation of the `Op` method is where we follow the pointer member
    `ptr` of `Box(T)` to get a `T` value that is compatible with the member
    being bound. This resolves the type mismatch that is introduced by allowing
    name resolution to find another type's members.
-   We have to be a little careful in the implementation of `ValueBind(Box(T))`
    to still use value binding even when we get a reference expression from
    dereferencing the pointer `ptr`.

With these two ingredients, `b.Search(32)` is equivalent to
`b.(String.Search)(32)` due to `extend api`, which then uses the custom binding
implementation to get something equivalent to `b.ptr->(String.Search)(32)`,
which is the same as `b.ptr->Search(32)` since `b.ptr` has type `String*`.

### Use case: Reference library type

The `Box` type that was used as
[an example of member forwarding](#use-case-member-forwarding) preserves the
expression category -- you can only call mutating operations on a `Box`
reference expression, not on a `Box` value expression. For a library reference
type that would simulate the C++-built-in reference type, we instead want to
permit value binding for anything where `T` permits reference binding. This can
also be done using `extend api` and a different set of binding implementations:

```carbon
class Ref(T:! type) {
  var ptr: T*;
  extend api T;
}
impl forall [T:! type, U:! RefBind(T)]
    U as ValueBind(Ref(T)) where .Result = Ref(U.Result) {
  fn Op[self: Self](p: Ref(T)) -> Ref(Result) {
    return {.ptr = self.Op(p->ptr)};
  }
}
// (Plus impls for the other three combinations of ValueBind and RefBind.)
impl forall [S:! type, T:! Call(S)] Ref(T) as Call(S) where .Result = T.Result {
  // ...
}
```

For example, it could be used as:

```carbon
class C {
  fn F[addr self: Self*]();
  var n: i32;
}
fn F(r: Ref(C)) {
  // OK, even though `r` is a value expression.
  // `r.F` is a `Ref(<bound member function>)`,
  // which is callable.
  r.F();

  // OK, forms a reference to the `n` member.
  let n_ref: Ref(i32) = r.n;
}
```

Note, however, `Ref(T)` doesn't preserve the interface implementations of `T`,
see [future work](#future-work-customizing-impl-binding).

This application of `extend api` and binding was first described in
[this comment on #3720](https://github.com/carbon-language/carbon-lang/pull/3720/files/37e967ff53e89e345eecb49ec79c6dfbe18a3c54#r1513712572).

### Use case: with implicit conversion

A class could extend the API of a class it implicitly converts to. For example,
imagine we have a class representing an integer in a restricted range that can
implicitly convert to an integer value.

<!--FIXME: add text once #3720 is merged:
> , see
> [inheritance and other implicit conversions from proposal #3720](p3720.md#inheritance-and-other-implicit-conversions).
-->

```carbon
class I32InRange(Low:! i32, High:! i32) {
  var value: i32;
  impl as ImplicitAs(i32) {
    fn Convert[self: Self]() -> i32 { return self.value; }
  }
  extend api i32;
}
```

By including `extend api i32`, `I32InRange` gains support for any non-`addr`
methods on `i32`, like perhaps `Abs`. The method `i32.Abs` has a `self` type of
`i32`, which an `I32InRange` value can implicitly convert to.

### Use case: extension methods

A class could have members specifically intended for use by another class, as
[extension methods](https://github.com/carbon-language/carbon-lang/issues/1345)
-- effectively acting as mixin except it can't add member variables.

```carbon
class ThreeExtension {
  fn Three() -> i32 {
    return 3;
  }
}

class EmptyExtension(template T:! type) {
  fn Empty[self: T]() -> bool {
    return self.Size() == 0;
  }
}

class RangeOfI32 {
  var low: i32;
  var high: i32;

  // Adds `Three` class function
  extend api ThreeExtension;
  // Roughly equivalent to:
  // `alias Three = ThreeExtension.Three;`

  fn Size[self: Self]() -> i32 {
    return self.high - self.low;
  }

  // Adds an `Empty` method.
  extend api EmptyExtension(RangeOfI32);
}

// Because of `extend api`, `RangeOfI32.Three` is equivalent to
// `ThreeExtension.Three`.
Assert(RangeOfI32.Three() == 3);

var r: RangeOfI32 = {.low = 2, .high = 5};
// Because of `extend api`, `r.Empty` is equivalent to
// `r.(EmptyExtension(RangeOfI32).Empty)`
Assert(r.Empty() == false);
```

### `extend api` with interfaces

The examples so far use `extend api` between two classes, but we also allow it
with interfaces and named constraints.

For example, a class can `extend api` of an interface it
[conditionally conforms to](/docs/design/generics/details.md#conditional-conformance),
as in:

```carbon
interface A {
  fn F();
}
class C(T:! type) {
  extend api A;
}
impl C(i32) as A { fn F() { ... } }
```

Here, the class `C(T)` implements `A` for some values of `T`, such as `i32`.
Rather than manually individually aliasing the members of `A` in `C`, to make
them available as part of the API of `C`, so that `C(i32).F()` is valid, an
`extend api` declaration includes all of them at once.

Another use case is that an interface can `extend api` of another interface. In
this example,

```carbon
interface A {
  fn F();
}
interface B {
  extend api A;
  fn G();
}
```

`B.F` would be an alias for `A.F`, but without any implied
`require Self impls A`,
[in contrast with a plain `extend A`](#modeling-extend-in-interfaces-and-named-constraints).

Lastly, an interface could `extend api` a class. This could be done to add
something that acts like `final` functions to the interface, using
[extension methods](https://github.com/carbon-language/carbon-lang/issues/1345),
as [can be done with classes](#use-case-extension-methods):

```carbon
class Helpers {
  fn F[T:! type, self: T]() { DoStuffWith(self); }
  // ...
}
interface Iface {
  extend api Helpers;
  fn G();
  // ...
}
class C {
  extend impl as Iface;
}
fn Test(c: C) {
  // Calls Helpers.F from extended class Helpers
  c.F();
}
```

This is approximately equivalent to using an interface with `final` functions:

```carbon
interface Helpers {
  final fn F[self: Self]() { DoStuffWith(self); }
  // ...
}
interface Iface {
  extend Helpers;
  fn G();
  // ...
}
```

This relies on the fact that implementing `Iface` will also implement extended
interfaces like `Helpers`.

### Modeling other language constructs

[This comment on proposal #3720](https://github.com/carbon-language/carbon-lang/pull/3720/files/97004ac6748a4f39e664d7409401df1811adc25c#r1527089564)
observed that `extend api` could be used to model other language constructs
using `extend`.

#### Modeling `extend impl`

```carbon
interface I { ... }
class C {
  extend impl as I;
}
```

is equivalent to:

```carbon
interface I { ... }
class C {
  impl as I;
  extend api I;
}
```

#### Modeling `extend base`

FIXME

#### Modeling virtual dispatch

FIXME

#### Modeling `extend adapt`

First, let us consider `adapt` without `extend`. For example,

```carbon
class A { ... }
class B {
  adapt A;
}
```

is equivalent to:

```carbon
class A { ... }
class B {
  var __a: A;
}
impl B as As(A) {
  fn Convert[self: B]() -> A {
    return self.__a;
  }
}
impl A as As(B) {
  fn Convert[self: A]() -> B {
    return {.__a = self} as B;
  }
}
impl forall [T:! ValueBind(A)]
    T as ValueBind(B) where .Result = T.Result {
  fn Op[self: Self](x: B) -> Result {
    return self.Op(x as A);
  }
}
impl forall [T:! RefBind(A)]
    T as RefBind(B) where .Result = T.Result {
  fn Op[self: Self](p: B*) -> Result* {
    return self.Op(&p->__a);
  }
}
```

In addition, there are `as` conversions that convert reference expressions to
reference expressions, which is currently not expressible by implementing
interfaces.

Note that the blanket implementations of the binding operator interfaces allow
methods of `A` to be used on values and objects of type `B`, as in:

```carbon
class A {
  fn F[self: Self](x: Self) -> Self;
  fn G[self: Self](y: Self) -> Self;
}

class B {
  adapt A;
  alias AG = A.G;
}

var a: A = {};
var b_ref: B = {};
let b_val: B = {};

// Allowed: binds `b_val` to `A.F`. Since `b_val` is a value expression,
// it uses `A.F as ValueBind(B)`, so this is equivalent to
// `(b_val as A).(A.F)(a)`.
b_val.(A.F)(a);

// Allowed: binds `b_ref` to `A.F`. Since `b_ref` is a reference
// expression, it uses `A.F as RefBind(B)`, so this is equivalent to:
// `(&((&b_ref)->__a))->(A.F)(a)`.
b_ref.(A.F)(a);

// These also work, and show how aliases can be used to add methods of
// `A` to `B`.
b_val.AG(a);
b_ref.AG(a);
```

Notice how custom binding implementation adapts the type of `self`, but not any
other `Self` type used in the signature. So `b_ref.(A.F)` is a function that
takes and returns `A` values, not `B` values.

Now consider adding the `extend` modifier before `adapt`, as in:

```carbon
class A {
  fn F[self: Self](x: Self) -> Self;
  fn G[self: Self](y: Self) -> Self;
}

class B {
  extend adapt A;
}
```

The `extend` does two things:

-   It adds `extend api A;` to class `B`. Due to the custom binding
    implementation provided by `adapt A`, this allows calling the methods
    defined on `A` on values and objects of type `B`.

-   For an interface `I`, when no implementation `B as I` is found, it will
    attempt to adapt the implementation `A as I`, as described in
    [the existing "extending adapter" section of the design](/docs/design/generics/details.md#extending-adapter).
    Note though that the the `Self` types in signatures in members of `I`
    **are** changed to `B`, as required to be an implementation of `B as I`,
    though this is
    [not always possible](/docs/design/generics/details.md#adapter-compatibility).
    Allowing the user to do this directly is
    [future work](#future-work-customizing-impl-binding).

#### Modeling `extend` in interfaces and named constraints

The `extend` declaration in interfaces and named constraints is equivalent to a
requirement that the extended type is implemented plus an `extend api` to add
the names of the extended type to the extending type. For example,

```carbon
interface A { ... }
interface B {
  extend A;
}
```

is equivalent to:

```carbon
interface A { ... }
interface B {
  require Self impls A;
  extend api A;
}
```

#### Future work: modeling mixins

FIXME

### Future work: customizing impl binding

We might want a mechanism to also get (some) interface implementations from an
extended type. This already occurs for `extend adapt`, from
[proposal #731: Generics details 2: adapters, associated types, parameterized interfaces](https://github.com/carbon-language/carbon-lang/pull/731),
and refined by
[open discussion on 2023-04-06](https://docs.google.com/document/d/1gnJBTfY81fZYvI_QXjwKk1uQHYBNHGqRLI2BS_cYYNQ/edit?resourcekey=0-ql1Q1WvTcDvhycf8LbA9DQ&tab=t.0#heading=h.x4syhdu36xdc)
and [PR #3231](https://github.com/carbon-language/carbon-lang/pull/3231). That
open discussion expressed that interface implementations would also be inherited
with `extend base`, though there are more cases where you can't use a base class
implementation for the derived class than with adapters.

For example, the mechanism might allow customization of impl binding by
implementing an interface. See
[this comment on #3720](https://github.com/carbon-language/carbon-lang/pull/3720/files/97004ac6748a4f39e664d7409401df1811adc25c#r1527083149)
and
[2024-03-18 open discussion](https://docs.google.com/document/d/1s3mMCupmuSpWOFJGnvjoElcBIe2aoaysTIdyczvKX84/edit?resourcekey=0-G095Wc3sR6pW1hLJbGgE0g&tab=t.0#heading=h.23p8d6pqg1qp).
It is unclear how that would work, since the interfaces that would be
implemented by `extend base` and `extend adapt` are different, and
[the rules for conversions allowed by adapters are complex](https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/generics/details.md#adapter-compatibility).

## Rationale

FIXME: How does this proposal effectively advance Carbon's goals? Rather than
re-stating the full motivation, this should connect that motivation back to
Carbon's stated goals and principles. This may evolve during review. Use links
to appropriate sections of [`/docs/project/goals.md`](/docs/project/goals.md),
and/or to documents in [`/docs/project/principles`](/docs/project/principles).
For example:

-   [Community and culture](/docs/project/goals.md#community-and-culture)
-   [Language tools and ecosystem](/docs/project/goals.md#language-tools-and-ecosystem)
-   [Performance-critical software](/docs/project/goals.md#performance-critical-software)
-   [Software and language evolution](/docs/project/goals.md#software-and-language-evolution)
-   [Code that is easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write)
-   [Practical safety and testing mechanisms](/docs/project/goals.md#practical-safety-and-testing-mechanisms)
-   [Fast and scalable development](/docs/project/goals.md#fast-and-scalable-development)
-   [Modern OS platforms, hardware architectures, and environments](/docs/project/goals.md#modern-os-platforms-hardware-architectures-and-environments)
-   [Interoperability with and migration from existing C++ code](/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code)

## Alternatives considered

### Allow `extend api` of an incomplete type

We considered allowing `extend api T` with `T` an incomplete type. This has some
disadvantages:

-   `T` must be complete before the first time name lookup into it is performed.
    Actually avoiding name lookup into `T` is very difficult, though, since you
    need to be very careful to fully qualify (using `package.`) names used in
    the class definition, except those names defined within the class itself.
-   Other uses of `extend`, such as `extend base: T` require the type to be
    complete.
-   We did not have a use case for using `extend api` with an incomplete type.
-   Requiring complete types forces types to be defined in a total order,
    preventing cycles (`A` extends `B` extends `C` extends `A`).

This was discussed in the
[proposal review](https://github.com/carbon-language/carbon-lang/pull/3720/files#r1507988547)
and
[the #typesystem channel on Discord](https://discord.com/channels/655572317891461132/708431657849585705/1217499991329738852).

### Make some name resolutions cases unambiguous with `extend api`

TODO: See
[comment on #3720](https://github.com/carbon-language/carbon-lang/pull/3720/files#r1513671030)
