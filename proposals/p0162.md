# Syntax of Basic Carbon Features

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/0162)

## Table of contents

<!-- toc -->

-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)

<!-- tocstop -->

## Problem

The purpose of this proposal is to establish some basic syntactic
elements of the Carbon language and make sure that the grammar is
unambiguous and can be parsed by an LALR parser such as `yacc` or
`bison`.  The grammar presented here has indeed been checked by
`bison`. The language features in this basic grammar include control
flow via `if` and `while`, functions, simple structures, choice, and
pattern matching. The main syntactic categories are `declaration`,
`statement`, and `expression`. Establishing these syntactic categories
should help the other proposals choose syntax that is compatible with
the rest of the language.

## Background

The grammar proposed here is based on the Carbon language overview and
on the proposals for pattern matching, structs, tuples, and
metaprogramming. There may be places that this grammar does not
accurately capture what was intended in those proposal, which should
trigger some useful discussion and revisions.

## Proposal

We summarize the three main syntactic categories here and define the
grammar in the next section.

* `declaration` includes function, structure, and choice definitions.

* `statement` includes variable definitions, assignment, blocks, `if`,
    `while`, `match`, `break`, `continue`, and `return`.
    
* `expression` plays three roles. In an initial attempt these roles
    were separate, with three different syntactic categories, but that
    led to ambiguities in the grammar. Folding them into one category
    resolved the ambiguities. The three roles will be teased apart in
    the static and dynamic semantics.

    1. The `expression` category plays the usual role of expressions
       that produce a value, such as integer literals and arithmetic
       expression.

    2. To fascilitate metaprogramming and reflection, `expression`
       also includes type expressions, include literals such as `Int`
       and `Bool` and constructors for function types, etc.

    3. `expression` is also used for patterns, for example, in the
        `case` of a `match`, in the parameters of a function, and on
        the left-hand side of variable definitions.

The proposal also specifies the abstract syntax.

## Details

### Expressions

The following grammar defines the concrete syntax for
expressions. Below we comment on a few unusual aspects of the grammar.

    expression:
      identifier
    | expression '.' identifier
    | expression '[' expression ']'
    | expression ':' identifier
    | integer_literal
    | "true"
    | "false"
    | tuple
    | expression "==" expression
    | expression '+' expression
    | expression '-' expression
    | expression "&&" expression
    | expression "||" expression
    | '!' expression
    | '-' expression
    | expression tuple
    | "auto"
    | "fn" tuple "->" expression
    ;
    tuple:
      '(' field_list ')'
    ;
    field_list:
      /* empty */
    | field
    | field ',' field_list
    ;
    field:
      expression
    | identifier '=' expression
    ;

The grammar rule

    expression:  expression ':' identifier

is for pattern variables. For example, in a variable definition such as

    var Int: x = 0;
    
the `Int: x` is parsed with the grammar rule for pattern variables.
In the above grammar rule, the `expression` to the left of the `:`
must evaluate to a type at compile time.

The grammar rule

    tuple:  '(' field_list ')'
    
is primarily for constructing a tuple, but it is also used for
creating tuple types and tuple patterns, depending on the context in
which the expression occurs.

### Statements

The following grammar defines the concrete syntax for statements.

    statement:
      "var" expression '=' expression ';'
    | expression '=' expression ';'
    | expression ';'
    | "if" '(' expression ')' statement "else" statement
    | "while" '(' expression ')' statement
    | "break" ';'
    | "continue" ';'
    | "return" expression ';'
    | '{' statement_list '}'
    | "match" '(' expression ')' '{' clause_list '}'
    ;
    statement_list:
      statement
    | statement statement_list
    ;
    clause_list:
      /* empty */
    | clause clause_list
    ;
    clause:
      "case" expression "=>" statement
    | "default" "=>" statement 
    ;

In the grammar rule for the variable definition statement

    statement:  "var" expression '=' expression ';'
    
the left-hand-side `expression` is used as a pattern, so it would
typically evaluate to a variable pattern or some other kind of value
(such as a tuple) that contains variable patterns.

Likewise, in the rule for `case`

    clause:  "case" expression "=>" statement

the `expression` is used as a pattern.


### Declarations

The following grammar defines the concrete syntax for declarations.

    declaration:
      "fn" identifier tuple return_type '{' statement_list '}'
    | "fn" identifier tuple ARROW expression ';'
    | "struct" identifier '{' member_list '}'
    | "choice" identifier '{' alternative_list '}'
    ;
    return_type:
      /* empty */
    | ARROW expression
    ;
    member:
      "var" expression ':' identifier ';'
    | "method" identifier expression "->" expression '{' statement_list '}'
    ;
    member_list:
      /* empty */
    | member member_list
    ;
    alternative:
      "alt" identifier expression ';'
    ;
    alternative_list:
      /* empty */
    | alternative alternative_list
    ;
    declaration_list:
      /* empty */
    | declaration declaration_list
    ;

In the grammar fule for function definitions

    declaration:  "fn" identifier tuple "->" expression '{' statement_list '}'

the `expression` before the `->` is used as a pattern to describe the
parameters of the function whereas the `expression` after the `->`
must evaluate to a type at compile-time, to express the return type of
the function. The story is the same for method definitions. 
The grammar for function definitions does not currently include implicit
parameters, but the intent is to add them to the grammar in the future.

In the rule for field declarations

    member:  "var" expression ':' identifier ';'

the `expression` must evaluate to a type at compile time.
The same is true for the `expression` in the grammar
rule for an alternative:

    alternative:  "alt" identifier expression ';'

### Precedence and Associativity

The following defines the precendence and associativity of symbols
used in the grammar. The ordering is from lowest to highest
precendence. The main goal of the choices here is to stay close to
C++.

    nonassoc '{' '}'
    nonassoc ':' ','
    right '=' 
    left "||"
    left "&&"
    left "=="
    left '+' '-'
    right '!' '*' '&'
    left '.' "->"
    nonassoc '(' ')' '[' ']' 

### Abstract Syntax

The output of parsing is an abstract syntax tree.  There are many ways
to define abstract syntax. Here I'll simply use C-style `struct`
definitions.


#### Abstract Syntax for Expressions

    enum ExpKind { Variable, PatternVariable, Dereference, Int, Bool, 
                   PrimitiveOp, Call, Tuple, Index, GetField, 
                   IntT, BoolT, TypeT, FunctionT, AutoT };
    enum Operator { Neg, Add, Sub, Not, And, Or, Eq };

    struct Exp {
      ExpKind tag;
      union {
        string* variable;
        struct { Exp* exp; string* field; } get_field;
        struct { Exp* exp; Exp* i; } index;
        struct { string* name; Exp* type; } pattern_variable;
        int integer;
        bool boolean;
        struct { vector<pair<string,Exp*> >* args; } tuple;
        struct { Operator op; vector<Exp*>* args; } primitive_op;
        struct { Exp* fun; Exp* arg; } call;
        struct { Exp* param; Exp* ret; } function_type;
      } u;
    };

The correspondence between most of the grammar rules and the abstract
syntax is straightforward. However, the parsing the `field_list`
deserves some explanation.  The fields can be labeled with the grammar
rule:

    field:  identifier '=' expression
    
or unlabeled, with the rule

    field: expression
    
The unlabeled fields are given numbers (represented as strings) for
field labels, starting with 0 and going up from left to right.

Regarding the rule for tuples:

    tuple:  '(' field_list ')'

if the field list only has a single unlabeled item, then the parse
result for that item is returned. Otherwise a `tuple` AST node is
created containing the parse results for the fields.


#### Abstract Syntax for Statements

    enum StmtKind { ExpStmt, Assign, VarDef, Delete, If, Return, Seq, Block, 
                    While, Break, Continue, Match };

    struct Stmt {
      int lineno;
      StmtKind tag;
      union {
        Exp* exp;
        struct { Exp* lhs; Exp* rhs; } assign;
        struct { Exp* pat; Exp* init; } variable_definition;
        struct { Exp* cond; Stmt* thn; Stmt* els; } if_stmt;
        Exp* return_stmt;
        struct { Stmt* stmt; Stmt* next; } sequence;
        struct { Stmt* stmt; } block;
        struct { Exp* cond; Stmt* body; } while_stmt;
        struct { Exp* exp; list< pair<Exp*,Stmt*> >* clauses; } match_stmt;
      } u;
    };

#### Abstract Syntax for Declarations

    struct FunDef {
      string name;
      Exp* param_pattern;
      Exp* return_type;
      Stmt* body;
    };

    enum MemberKind { FieldMem };

    struct Member {
      MemberKind tag;
      union {
        struct { string* name; Exp* type; } field;
      } u;
    };

    struct StructDef {
      string* name;
      list<Member*>* members; 
    };

    enum DeclKind { FunDecl, StructDecl, ChoiceDecl };

    struct Decl {
      DeclKind tag;
      union {
        struct FunDef* fun_def;
        struct StructDef* struct_def;
        struct { string* name; list<pair<string, Exp*> >* alts; } choice_def;
      } u;
    };
