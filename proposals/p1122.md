# Extension methods

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/1122)

<!-- toc -->

## Table of contents

-   [Problem](#problem)
-   [Background](#background)
    -   [Problems with extension methods](#problems-with-extension-methods)
-   [Proposal](#proposal)
-   [Details](#details)
-   [Rationale based on Carbon's goals](#rationale-based-on-carbons-goals)
-   [Alternatives considered](#alternatives-considered)
    -   [Require `me` to have a type involving `Self`](#require-me-to-have-a-type-involving-self)
    -   [Disallow `me` where `Self` is not in scope](#disallow-me-where-self-is-not-in-scope)

<!-- tocstop -->

## Problem

[Extension methods](https://en.wikipedia.org/wiki/Extension_method) provide a
convenient way for one part of a program to extend an interface provided by
another part of the same program. This is a convenient but non-essential
feature.

In most languages with extension methods, they are invoked with a syntax that
exactly matches normal method call syntax. This creates serious
[problems](#problems-with-extension-methods). However, Carbon's notation for
`me` parameters and for compound member accesses are able to provide the
functionality of extension methods without the costs.

It is currently unclear whether Carbon's design permits extension methods: while
there is an obvious syntax that would provide them, we have no explicit rule or
decision that says whether they are permitted.

## Background

[Wikipedia](https://en.wikipedia.org/wiki/Extension_method) provides a good
description of the state of extension methods in popular languages. C++ has no
corresponding feature. In Rust, all methods, whether in an inherent `impl` or a
trait `impl`, effectively declare extension methods, as they are found by member
access and aren't provided as part of the definition of the type.

### Problems with extension methods

The major problem with extension methods is that they create an evolutionary
problem: if library A provides a type, and library B provides an extension
method for that type, and a consumer C of library A and B calls that extension
method, then the pure addition of a matching method in library A may result in
ambiguities. Alternatively, if the extension method is preferred over the method
in the type, then a pure addition of an extension method may result in
ambiguities.

Worse, if two separate libraries provide an extension method for the same type
with the same name, any consumer of both libraries will have problems accessing
either extension method, and a pure addition of an extension method in one
library risks introducing ambiguity with an extension method in a different
library.

A separate but related concern is that lookup for extension methods may in
general need to look in a large number of unrelated places. If the receiver type
can be generic, non-trivial inference and checking steps may be required for
each potential candidate to determine which operation should be used. This is
reminiscent of the high compile-time costs of ADL for overloaded operators in
C++, and with good reason: ad-hoc out-of-class operator overloads have a lot of
the same properties as extension methods.

## Proposal

Carbon does not restrict which functions can have a `me` method.

## Details

No changes are made to the language rules, but for clarity, here are the
consequences of the current rules:

-   The terms "method" and "member function" are now completely orthogonal: we
    have both member functions that are not methods and methods that are not
    member functions.
    ```
    fn NotMethodNotMemberFunction();
    fn MethodButNotMemberFunction[me: i32]();
    class ClassWithMemberFunctions {
      fn NotMethodButMemberFunction();
      fn MethodAndMemberFunctionToo[me: Self]();
    }
    ```
-   We give the name "extension method" to a method that can't ever be called
    using a simple member access notation `a.Function()`.
-   Any method can be called using compound member access notation
    `a.(Function)()`, where the name `Function` may be qualified if necessary.
-   Methods can only be called using member access notation. For example,
    `MethodButNotMemberFunction(5)` is an error, as is
    `X.MethodAndMemberFunctionToo({} as X)`.
-   The existence and value of the name `Self` depends on the lexical context in
    which `Self` appears. Whether `me` is declared and the type of `me` is not
    relevant.
-   If the type of `me` is parameterized, a method, including one declared
    inside a class, can be used for any type satisfying the parameters:
    ```
    class SomethingMachine {
      fn DoSomething[template T:! Type, me: T]();
    }
    // ✅ Calls the above method with `T` deduced as `IntLiteral(47)`.
    47.(SomethingMachine.DoSomething)();
    ```

Note that this approach avoids both the evolutionary problems and the
compile-time performance problems by using normal name lookup to resolve the
name of extension methods, rather than augmenting member access to additionally
look for non-member names.

## Rationale based on Carbon's goals

-   [Software and language evolution](/docs/project/goals.md#software-and-language-evolution)
    -   Avoids creating problems for library evolution by not introducing any
        new name lookup rules.
-   [Code that is easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write)
    -   Improves ergonomics by allowing local, ad-hoc introduction of extension
        methods without the syntactic overhead of an adaptor.
    -   Allowing methods to be declared anywhere is a simpler rule to remember
        and understand than introducing some kind of restriction that the
        receiver type must be in some way related to the `class` or `impl` in
        which it is declared, or restricting to only classes but not restricting
        to related classes.
    -   A uniform name lookup rule is easier to understand than other approaches
        towards extension methods.
-   [Interoperability with and migration from existing C++ code](/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code)
    -   Calling extension methods from C++ may present a challenge, as there is
        no C++ syntax to do so, but this challenge already exists when calling
        methods of an external impl from C++, so this cost is likely minimal.

This approach is also motivated by
[MacLennan's](https://csis.pace.edu/~bergin/slides/Maclennan.html) principles of
orthogonality, regularity, and simplicity.

## Alternatives considered

We could disallow extension methods, in various different ways.

### Require `me` to have a type involving `Self`

We could restrict `me` parameters to only locations where `Self` is in scope,
and require its type to be compatible with `Self` in some sense.

Advantages:

-   Every method is a method on the current `Self` type, making the recipient
    easier to reason about.

Disadvantages:

-   Rules out some use cases, such as providing a method whose receiver type is
    a derived-class type.
-   Requires additional syntactic overhead to customize what names can appear
    after a `.`, such as defining an `adapter`.
-   Unclear in exactly what sense we would require type compatibility. This
    especially applies when the type of `me` is parameterized.

### Disallow `me` where `Self` is not in scope

We could restrict `me` parameters to only functions that are defined in the
scope of a type.

With this restriction, one can still write extension methods as described in
this proposal with a local syntactic workaround:

```
class ExtensionMethodWrapper {
  fn ExtensionMethod[me: i32]();
}
alias ExtensionMethod = ExtensionMethodWrapper.ExtensionMethod;
// ✅ OK, unless we add some other rule to prevent it.
5.(ExtensionMethod)();
```

As a consequence, this doesn't provide any real guarantees about the receiver
type of a method nor where a method called on an object may be declared.
