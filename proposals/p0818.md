# Constraints for generics (generics details 3)

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/818)

<!-- toc -->

## Table of contents

-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Rationale based on Carbon's goals](#rationale-based-on-carbons-goals)
-   [Alternatives considered](#alternatives-considered)
    -   [Inline constraints instead of `.Self`](#inline-constraints-instead-of-self)
    -   [Different keyword than `where`](#different-keyword-than-where)
    -   [Inline constraints instead of `.Self`](#inline-constraints-instead-of-self-1)
    -   [Self reference instead of `.Self`](#self-reference-instead-of-self)
    -   [Implied constraints across declarations](#implied-constraints-across-declarations)
    -   [No implied constraints](#no-implied-constraints)
    -   [Type inequality constraints](#type-inequality-constraints)
    -   [`where .Self is ...` could act like an external impl](#where-self-is--could-act-like-an-external-impl)
    -   [Automatic type equality](#automatic-type-equality)
        -   [Restricted equality constraints](#restricted-equality-constraints)
        -   [No explicit restrictions](#no-explicit-restrictions)

<!-- tocstop -->

## Problem

We want to Carbon to have a high quality generics feature that achieves the
goals set out in [#24](https://github.com/carbon-language/carbon-lang/pull/24).
This is too big to land in a single proposal. This proposal continues
[#553](https://github.com/carbon-language/carbon-lang/pull/553) defining the
details of:

-   adapters
-   associated types and other constants
-   parameterized interfaces

## Background

This is a follow on to these previous generics proposals:

-   [#24: Generics goals](https://github.com/carbon-language/carbon-lang/pull/24)
-   [#447: Generics terminology](https://github.com/carbon-language/carbon-lang/pull/447)
-   [#524: Generics overview](https://github.com/carbon-language/carbon-lang/pull/524)
-   [#553: Generics details part 1](https://github.com/carbon-language/carbon-lang/pull/553)
-   [#731: Generics details 2: adapters, associated types, parameterized interfaces](https://github.com/carbon-language/carbon-lang/pull/731)

Some of the content for this proposal was extracted from a larger
[Generics combined draft proposal](https://github.com/carbon-language/carbon-lang/pull/36).

## Proposal

This is a proposal to add two sections to
[this design document on generics details](/docs/design/generics/details.md).

## Rationale based on Carbon's goals

Much of this rationale for generics was captured in the
[Generics goals proposal](https://github.com/carbon-language/carbon-lang/pull/24).
The specific decisions for this constraint design were motivated by:

-   [Software and language evolution](/docs/project/goals.md#software-and-language-evolution)
    -   The manual generic type equality approach being proposed could be
        extended to automatically observe more types as being equal without
        breaking existing code.
    -   Adding or growing an `observe` statement has been designed to be
        non-breaking since they can't introduce name conflicts, only make more
        code legal.
    -   This constraint system is expressive and does not have artificial limits
        that would be needed to support automatic type equality.
-   [Code that is easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write)
    -   Attaching `where` clauses to type-of-types addresses more use cases than
        attaching them to declarations, allowing the design to be smaller, see
        [#780](https://github.com/carbon-language/carbon-lang/issues/780).
    -   The manual generic type equality approach is very simple and easy to
        understand how it works. It unfortunately is a bit more verbose, leading
        to more to read and write.
-   [Fast and scalable development](/docs/project/goals.md#fast-and-scalable-development)
    -   The manual generic type equality approach does much less work at compile
        time than the automatic approach. The extra work would only be done to
        produce an error message that includes the changes to the source needed
        to avoid repeating that work. In effect, the source code holds a cache
        of the facts needed to compile it.

## Alternatives considered

FIXME: Look through [this appendix](appendix-requires-constraints.md) for other
alternatives and rationale.

### Inline constraints instead of `.Self`

FIXME: Issue
[#780: How to write constraints](https://github.com/carbon-language/carbon-lang/issues/780)
considered other forms that constraints could be written:

-   `where` clauses on declarations instead of types (Swift and Rust) - doesn't
    work with trait objects
-   parameter passing style used by Rust - can't express some kinds of
    constraints
-   whole expression constraint intersections - also can't express some
    constraints, allows setting one name in two interfaces at once, concerns
    about this making `&` be not associative / commutative

FIXME: The
["parameterized type implements interface"](/docs/design/generics/details.md#parameterized-type-implements-interface)
case motivated Rust to
[add support for `where` clauses](https://rust-lang.github.io/rfcs/0135-where.html#motivation).

### Different keyword than `where`

FIXME: other keywords: `requires`, `with`, `if`

### Inline constraints instead of `.Self`

FIXME: Alternative to using `.Self` for
[recursive constraints](/docs/design/generics/details.md#recursive-constraints).

However, you can't always avoid using `.Self`, since naming the constraint
before using it doesn't allow you to define the `Container` interface above,
since the named constraint refers to `Container` in its definition.

**Rejected alternative:** To use this `constraint` trick to define `Container`,
you'd have to allow it to be defined inline in the `Container` definition:

```
interface Container {
  let ElementType:! Type;

  constraint ContainerIsSlice {
    extends Container where Container.SliceType == Self;
  }
  let SliceType:! ContainerIsSlice where .ElementType == ElementType;

  fn GetSlice[addr me: Self*](start: IteratorType,
                                    IteratorType: end) -> SliceType;
}
```

### Self reference instead of `.Self`

FIXME: Alternative to using `.Self` for
[recursive constraints](/docs/design/generics/details.md#recursive-constraints).

**Rejected alternative:** We could use the name of the type being declared
inside the type declaration, as in `T:! HasAbs(.MagnitudeType = T)`.

### Implied constraints across declarations

If constraints on an associated type could be implied by any declaration in the
interface, readers and the type checker would be required to scan the entire
interface definition and perform many type declaration lookups to understand the
constraints on that associated type. This is particularly important when those
constraints can be obscured in recursive references to the same interface:

```
interface I {
  let A:! Type;
  let B:! Type;
  let C:! Type;
  let D:! Type;
  let E:! Type;
  let SwapType:! I where .A == B and .B == A and .C == C
                     and .D == D and .E == E;
  let CycleType:! I where .A == B and .B == C and .C == D
                      and .D == E and .E ==  A;
  fn LookUp(hm: HashMap(D, E)*) -> E;
  fn Foo(x: Bar(A, B));
}
```

This applies equally to parameters:

```
interface I(A:! Type, B:! Type, C:! Type, D:! Type, E:! Type) {
  let SwapType:! I(B, A, C, D, E);
  let CycleType:! I(B, C, D, E, A);
  fn LookUp(hm: HashMap(D, E)*) -> E;
  fn Foo(x: Bar(A, B));
}
```

All of the type arguments to `I` must actually implement `Hashable`, since
[an adjacent swap and a cycle generate the full symmetry group on 5 elements](https://www.mathcounterexamples.net/generating-the-symmetric-group-with-a-transposition-and-a-maximal-length-cycle/)).
And additional restrictions on those types would depend on the definition of
`Bar`. For example, this definition

```
class Bar(A:! Type, B:! ComparableWith(A)) { ... }
```

would imply that all the type arguments to `I` would have to be comparable with
each other. This propagation problem means that allowing constraints to be
implied in this context is substantial, and potentially unbounded, work for the
compiler and human readers.

From this we conclude that we need the initial declaration part of an
`interface`, type definition, or associated type declaration to include a
complete description of all needed constraints.

### No implied constraints

Issue [#809](https://github.com/carbon-language/carbon-lang/issues/809)
considered whether Carbon would support implied constraints. The conclusion was
that implied constraints was an important ergonomic improvement. The framing as
a rewrite to a `where` restriction that did not affect the generic type
parameter's unqualified API seemed like something that could be explained to
users. Potential problems where a specialization of a generic type might allow
that type to be instantiated for types that don't satisfy the normal constraints
will be considered in the future along with the specialization feature.

We also considered the alternative where the user would need to explicitly opt
in to this behavior by adding `& auto` or `& implied_requirements` to their type
constraint, as in:

```
fn LookUp[KeyType:! Type & auto](hm: HashMap(KeyType, i32)*,
                                 k: KeyType) -> i32;

fn PrintValueOrDefault[KeyType:! Printable & auto,
                       ValueT:! Printable & HasDefault]
    (map: HashMap(KeyType, ValueT), key: KeyT);
```

### Type inequality constraints

You might want an inequality type constraint, for example, to control overload
resolution:

```
fn F[T:! Type](x: T) -> T { return x; }
fn F(x: Bool) -> String {
  if (x) return "True"; else return "False";
}

fn G[T:! Type where .Self != Bool](x: T) -> T {
  // We need T != Bool for this to type check.
  return F(x);
}
```

There are some problems with supporting this feature, however.
[Negative reasoning in general has been a source of difficulties in the implementation of Rust's type system](http://aturon.github.io/tech/2017/04/24/negative-chalk/).
This is a type of constraint that is more difficult to use since it would have
to be repeated by any generic caller, since nothing else can generically
establish two types are different.

We may be able to overcome these difficulties, but we don't expect this feature
is required since neither Rust nor Swift support it.

### `where .Self is ...` could act like an external impl

FIXME:
https://discord.com/channels/655572317891461132/708431657849585705/895794334723637258

### Automatic type equality

Other languages, such as Swift and Rust, don't require `observe` declarations or
casting for the compiler to recognize two types as transitively equal. The
problem is that there is know way to know how many equality constraints need to
be considered before being able to conclude whether two type expressions are
equal. In fact, the equality relations form a semi-group, where in general
deciding whether two sequences are equivalent is undecidable, see
[Swift type checking is undecidable - Discussion - Swift Forums](https://forums.swift.org/t/swift-type-checking-is-undecidable/39024).

#### Restricted equality constraints

One possible approach to this problem is to apply limitations to the equality
constraints user's are allowed to express. The goal is to identify some
restrictions such that:

-   We have a terminating algorithm to decide if a set of constraints meets the
    restrictions.
-   For constraints that meet the restrictions we have a terminating algorithm
    for deciding which expressions are equal.
-   Expected use cases satisfy the restrictions.

The expected cases are things of these forms:

-   `X == Y`
-   `X == Y.Z`
-   `X == X.Y`
-   `X == Y.X`
-   and _some_ combinations and variations

For example, here are some interfaces that have been translated to Carbon syntax
from Swift standard library protocols:

```
interface IteratorProtocol {
  let Element:! Type;
}

interface Sequence {
  let Element:! Type;
  let Iterator:! IteratorProtocol
    where .Element == Element;
}

interface Collection {
  extends Sequence;
  let Index:! Type;
  let SubSequence:! Collection
    where .Element == Element
      and .SubSequence == SubSequence
      and .Index == Index;
  let Indices:! Collection
    where .Element == Index
      and .Index == Index
      and .SubSequence == Indices;
}
```

One approach we considered is
[regular equivalence classes](p0818/regular_equivalence_classes.md), however we
have not yet been able to figure out how to ensure the algorithm terminates.
This is an approach we would like to reconsider if we find solutions to this
problem once can share this problem more widely.

Other approaches we considered worked in simple cases but had requirements that
could not be validated, since for example they were equivalent to solving the
same word problem that makes transitive equality undecidable in general.

#### No explicit restrictions

If you allow the full undecidable set of `where` clauses, there are some
unpleasant options:

-   Possibly the compiler won't realize that two expressions are equal even
    though they should be.
-   Possibly the compiler will reject some interface declarations as "too
    complicated", due to "running for too many steps", based on some arbitrary
    threshold.

Either way, the compiler will have to perform a lot more work at compile time,
slowing down builds. There is also a danger that composition of things that
separately work or incremental evolution of working code could end up over a
complexity or search depth threshold. In effect, there are still restrictions on
what combinations of equality constraints are allowed, it is just that those
restrictions are implicit in the specifics of the algorithm chosen and execution
limits used.

One approach that has been suggested by
[Slava Pestov](https://forums.swift.org/u/Slava_Pestov) in the context of Swift,
is to
[formalize type equality as a term rewriting system](https://forums.swift.org/t/formalizing-swift-generics-as-a-term-rewriting-system/45175).
Then the equality constraints in an interface or function declaration can be
completed by running the Knuth-Bendix completion algorithm
([1](https://en.wikipedia.org/wiki/Knuth%E2%80%93Bendix_completion_algorithm#Description_of_the_algorithm_for_finitely_presented_monoids),
[2](https://academic.oup.com/comjnl/article/34/1/2/427931)) for some limited
number of steps. If the algorithm completes successfully, type expressions may
then be efficiently canonicalized. However the algorithm can fail, or fail to
terminate before hitting the threshold number of steps, in which case the source
code would have to be rejected. See
[this example implementation](https://gist.github.com/slavapestov/75dbec34f9eba5fb4a4a00b1ee520d0b).
