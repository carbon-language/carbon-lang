# Constraints for generics (generics details 3)

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/818)

<!-- toc -->

## Table of contents

-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Rationale based on Carbon's goals](#rationale-based-on-carbons-goals)
-   [Alternatives considered](#alternatives-considered)
    -   [Inline constraints instead of `.Self`](#inline-constraints-instead-of-self)
    -   [Self reference instead of `.Self`](#self-reference-instead-of-self)
    -   [No implied constraints across declarations](#no-implied-constraints-across-declarations)
    -   [No implied constraints](#no-implied-constraints)
    -   [Type inequality constraints](#type-inequality-constraints)
    -   [Automatic type equality](#automatic-type-equality)
    -   [`where .Self is ...` could act like an external impl](#where-self-is--could-act-like-an-external-impl)

<!-- tocstop -->

## Problem

We want to Carbon to have a high quality generics feature that achieves the
goals set out in [#24](https://github.com/carbon-language/carbon-lang/pull/24).
This is too big to land in a single proposal. This proposal continues
[#553](https://github.com/carbon-language/carbon-lang/pull/553) defining the
details of:

-   adapters
-   associated types and other constants
-   parameterized interfaces

## Background

This is a follow on to these previous generics proposals:

-   [#24: Generics goals](https://github.com/carbon-language/carbon-lang/pull/24)
-   [#447: Generics terminology](https://github.com/carbon-language/carbon-lang/pull/447)
-   [#524: Generics overview](https://github.com/carbon-language/carbon-lang/pull/524)
-   [#553: Generics details part 1](https://github.com/carbon-language/carbon-lang/pull/553)
-   [#731: Generics details 2: adapters, associated types, parameterized interfaces](https://github.com/carbon-language/carbon-lang/pull/731)

Some of the content for this proposal was extracted from a larger
[Generics combined draft proposal](https://github.com/carbon-language/carbon-lang/pull/36).

## Proposal

This is a proposal to add two sections to
[this design document on generics details](/docs/design/generics/details.md) and
an
[appendix with the algorithm that determines archetypes for generic type expressions](/docs/design/generics/appendix-archetype-algorithm.md).

## Rationale based on Carbon's goals

Much of this rationale was captured in the
[Generics goals proposal](https://github.com/carbon-language/carbon-lang/pull/24).

## Alternatives considered

FIXME: Issue
[#780: How to write constraints](https://github.com/carbon-language/carbon-lang/issues/780)
considered other forms that constraints could be written:

-   `where` clauses on declarations instead of types (Swift and Rust) - doesn't
    work with trait objects
-   parameter passing style used by Rust - can't express some kinds of
    constraints
-   whole expression constraint intersections - also can't express some
    constraints, allows setting one name in two interfaces at once, concerns
    about this making `&` be not associative / commutative

FIXME: other keywords: `requires`, `with`, `if`

FIXME: The
["parameterized type implements interface"](/docs/design/generics/details.md#parameterized-type-implements-interface)
case motivated Rust to
[add support for `where` clauses](https://rust-lang.github.io/rfcs/0135-where.html#motivation).

FIXME: Look through [this appendix](appendix-requires-constraints.md) for other
alternatives and rationale.

### Inline constraints instead of `.Self`

FIXME: Alternative to using `.Self` for
[recursive constraints](/docs/design/generics/details.md#recursive-constraints).

However, you can't always avoid using `.Self`, since naming the constraint
before using it doesn't allow you to define the `Container` interface above,
since the named constraint refers to `Container` in its definition.

**Rejected alternative:** To use this `constraint` trick to define `Container`,
you'd have to allow it to be defined inline in the `Container` definition:

```
interface Container {
  let ElementType:! Type;

  constraint ContainerIsSlice {
    extends Container where Container.SliceType == Self;
  }
  let SliceType:! ContainerIsSlice where .ElementType == ElementType;

  fn GetSlice[addr me: Self*](start: IteratorType,
                                    IteratorType: end) -> SliceType;
}
```

### Self reference instead of `.Self`

FIXME: Alternative to using `.Self` for
[recursive constraints](/docs/design/generics/details.md#recursive-constraints).

**Rejected alternative:** We could use the name of the type being declared
inside the type declaration, as in `T:! HasAbs(.MagnitudeType = T)`.

### No implied constraints across declarations

If constraints on an associated type could be implied by any declaration in the
interface, readers and the type checker would be required to scan the entire
interface definition and perform many type declaration lookups to understand the
constraints on that associated type. This is particularly important when those
constraints can be obscured in recursive references to the same interface:

```
interface I {
  let A:! Type;
  let B:! Type;
  let C:! Type;
  let D:! Type;
  let E:! Type;
  let SwapType:! I where .A == B and .B == A and .C == C
                     and .D == D and .E == E;
  let CycleType:! I where .A == B and .B == C and .C == D
                      and .D == E and .E ==  A;
  fn LookUp(hm: HashMap(D, E)*) -> E;
  fn Foo(x: Bar(A, B));
}
```

This applies equally to parameters:

```
interface I(A:! Type, B:! Type, C:! Type, D:! Type, E:! Type) {
  let SwapType:! I(B, A, C, D, E);
  let CycleType:! I(B, C, D, E, A);
  fn LookUp(hm: HashMap(D, E)*) -> E;
  fn Foo(x: Bar(A, B));
}
```

All of the type arguments to `I` must actually implement `Hashable`, since
[an adjacent swap and a cycle generate the full symmetry group on 5 elements](https://www.mathcounterexamples.net/generating-the-symmetric-group-with-a-transposition-and-a-maximal-length-cycle/)).
And additional restrictions on those types would depend on the definition of
`Bar`. For example, this definition

```
class Bar(A:! Type, B:! ComparableWith(A)) { ... }
```

would imply that all the type arguments to `I` would have to be comparable with
each other. This propagation problem means that allowing constraints to be
implied in this context is substantial, and potentially unbounded, work for the
compiler and human readers.

From this we conclude that we need the initial declaration part of an
`interface`, type definition, or associated type declaration to include a
complete description of all needed constraints.

### No implied constraints

Issue [#809](https://github.com/carbon-language/carbon-lang/issues/809)
considered whether Carbon would support implied constraints. The conclusion was
that implied constraints was an important ergonomic improvement. The framing as
a rewrite to a `where` restriction that did not affect the generic type
parameter's unqualified API seemed like something that could be explained to
users. Potential problems where a specialization of a generic type might allow
that type to be instantiated for types that don't satisfy the normal constraints
will be considered in the future along with the specialization feature.

We also considered the alternative where the user would need to explicitly opt
in to this behavior by adding `& auto` or `& implied_requirements` to their type
constraint, as in:

```
fn LookUp[KeyType:! Type & auto](hm: HashMap(KeyType, i32)*,
                                 k: KeyType) -> i32;

fn PrintValueOrDefault[KeyType:! Printable & auto,
                       ValueT:! Printable & HasDefault]
    (map: HashMap(KeyType, ValueT), key: KeyT);
```

### Type inequality constraints

You might want an inequality type constraint, for example, to control overload
resolution:

```
fn F[T:! Type](x: T) -> T { return x; }
fn F(x: Bool) -> String {
  if (x) return "True"; else return "False";
}

fn G[T:! Type where .Self != Bool](x: T) -> T {
  // We need T != Bool for this to type check.
  return F(x);
}
```

There are some problems with supporting this feature, however.
[Negative reasoning in general has been a source of difficulties in the implementation of Rust's type system](http://aturon.github.io/tech/2017/04/24/negative-chalk/).
This is a type of constraint that is more difficult to use since it would have
to be repeated by any generic caller, since nothing else can generically
establish two types are different.

We may be able to overcome these difficulties, but we don't expect this feature
is required since neither Rust nor Swift support it.

### Automatic type equality

FIXME

### `where .Self is ...` could act like an external impl

FIXME:
https://discord.com/channels/655572317891461132/708431657849585705/895794334723637258
