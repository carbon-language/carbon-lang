# Constraints for generics (generics details 3)

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/818)

<!-- toc -->

## Table of contents

-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Rationale based on Carbon's goals](#rationale-based-on-carbons-goals)
-   [Alternatives considered](#alternatives-considered)
    -   [Inline constraints instead of `.Self`](#inline-constraints-instead-of-self)
    -   [Self reference instead of `.Self`](#self-reference-instead-of-self)
    -   [No inferred/implied constraints for interfaces](#no-inferredimplied-constraints-for-interfaces)
    -   [No implied constraints](#no-implied-constraints)
    -   [No cyclic constraints](#no-cyclic-constraints)
    -   [No conflicting constraints on an associated type](#no-conflicting-constraints-on-an-associated-type)

<!-- tocstop -->

## Problem

We want to Carbon to have a high quality generics feature that achieves the
goals set out in [#24](https://github.com/carbon-language/carbon-lang/pull/24).
This is too big to land in a single proposal. This proposal continues
[#553](https://github.com/carbon-language/carbon-lang/pull/553) defining the
details of:

-   adapters
-   associated types and other constants
-   parameterized interfaces

## Background

This is a follow on to these previous generics proposals:

-   [#24: Generics goals](https://github.com/carbon-language/carbon-lang/pull/24)
-   [#447: Generics terminology](https://github.com/carbon-language/carbon-lang/pull/447)
-   [#524: Generics overview](https://github.com/carbon-language/carbon-lang/pull/524)
-   [#553: Generics details part 1](https://github.com/carbon-language/carbon-lang/pull/553)
-   [#731: Generics details 2: adapters, associated types, parameterized interfaces](https://github.com/carbon-language/carbon-lang/pull/731)

Some of the content for this proposal was extracted from a larger
[Generics combined draft proposal](https://github.com/carbon-language/carbon-lang/pull/36).

## Proposal

This is a proposal to add two sections to
[this design document on generics details](/docs/design/generics/details.md) and
an
[appendix with the algorithm that determines archetypes for generic type expressions](/docs/design/generics/appendix-archetype-algorithm.md).

## Rationale based on Carbon's goals

Much of this rationale was captured in the
[Generics goals proposal](https://github.com/carbon-language/carbon-lang/pull/24).

## Alternatives considered

FIXME: Issue
[#780: How to write constraints](https://github.com/carbon-language/carbon-lang/issues/780)
considered other forms that constraints could be written:

-   `where` clauses on declarations instead of types (Swift and Rust) - doesn't
    work with trait objects
-   parameter passing style used by Rust - can't express some kinds of
    constraints
-   whole expression constraint intersections - also can't express some
    constraints, allows setting one name in two interfaces at once, concerns
    about this making `&` be not associative / commutative

FIXME: other keywords: `requires`, `with`, `if`

FIXME: The
["parameterized type implements interface"](/docs/design/generics/details.md#parameterized-type-implements-interface)
case motivated Rust to
[add support for `where` clauses](https://rust-lang.github.io/rfcs/0135-where.html#motivation).

FIXME: Look through [this appendix](appendix-requires-constraints.md) for other
alternatives and rationale.

### Inline constraints instead of `.Self`

FIXME: Alternative to using `.Self` for
[recursive constraints](/docs/design/generics/details.md#recursive-constraints).

However, you can't always avoid using `.Self`, since naming the constraint
before using it doesn't allow you to define the `Container` interface above,
since the named constraint refers to `Container` in its definition.

**Rejected alternative:** To use this `constraint` trick to define `Container`,
you'd have to allow it to be defined inline in the `Container` definition:

```
interface Container {
  let ElementType:! Type;

  constraint ContainerIsSlice {
    extends Container where Container.SliceType == Self;
  }
  let SliceType:! ContainerIsSlice where .ElementType == ElementType;

  fn GetSlice[addr me: Self*](start: IteratorType,
                                    IteratorType: end) -> SliceType;
}
```

### Self reference instead of `.Self`

FIXME: Alternative to using `.Self` for
[recursive constraints](/docs/design/generics/details.md#recursive-constraints).

**Rejected alternative:** We could use the name of the type being declared
inside the type declaration, as in `T:! HasAbs(.MagnitudeType = T)`.

### No inferred/implied constraints for interfaces

FIXME

In interfaces, these constraints can be obscured:

```
interface I(A:! Type, B:! Type, C:! Type, D:! Type, E:! Type) {
  let SwapType:! I(B, A, C, D, E);
  let CycleType:! I(B, C, D, E, A);
  fn LookUp(hm: HashMap(D, E)*) -> E;
  fn Foo(x: Bar(A, B));
}
```

All type arguments to "I" must actually implement `Hashable` (since
[an adjacent swap and a cycle generate the full symmetry group on 5 elements](https://www.mathcounterexamples.net/generating-the-symmetric-group-with-a-transposition-and-a-maximal-length-cycle/)).
And additional restrictions on those types depend on the definition of `Bar`.
For example, this definition

```
class Bar(A:! Type, B:! ComparableWith(A)) { ... }
```

would imply that all the type arguments to `I` would have to be comparable with
every other. This propagation problem means that allowing implicit constraints
to be inferred in this context is substantial (potentially unbounded?) work for
the compiler, and these implied constraints are not at all clear to human
readers of the code either.

**Conclusion:** The initial declaration part of an `interface`, type definition,
or associated type declaration should include complete description of all needed
constraints.

Furthermore, inferring that two types are equal (in contrast to the type bound
constraints described so far) introduces additional problems for establishing
which types are equal in a generic context.

### No implied constraints

Issue [#809](https://github.com/carbon-language/carbon-lang/issues/809)
considered whether Carbon would support implied constraints. The conclusion was
that implied constraints was an important ergonomic improvement. The framing as
a rewrite to a `where` restriction that did not affect the generic type
parameter's unqualified API seemed like something that could be explained to
users. Potential problems where a specialization of a generic type might allow
that type to be instantiated for types that don't satisfy the normal constraints
will be considered in the future along with the specialization feature.

We also considered the alternative where the user would need to explicitly opt
in to this behavior by adding `& auto` or `& implied_requirements` to their type
constraint, as in:

```
fn LookUp[KeyType:! Type & auto](hm: HashMap(KeyType, Int)*,
                                 k: KeyType) -> Int;

fn PrintValueOrDefault[KeyType:! Printable & auto,
                       ValueT:! Printable & HasDefault]
    (map: HashMap(KeyType, ValueT), key: KeyT);
```

### No cyclic constraints

We considered forbidding `where` restrictions that cause a cycle in the
normalized from. This was only to guarantee that type checking would always
terminate, and so was dropped when an alternative approach to establishing
termination was established.

An example of what was previously forbidden:

```
interface Graph {
  let Vertex:! V;
  let Edge:! E where Vertex.Edge == .Self
                 and .Vertex == Vertex;
}
```

normalizes to:

```
Graph
* $2 :! V{.Edge = $1}
  - Vertex as V
  - Edge.Vertex as V
* $1 :! E{.Vertex = $2}
  - Edge as E
  - Vertex.Edge as E
* $0 :! Graph{.Vertex = $2, .Edge = $1}
  - Self as Graph
}
```

These cycles can be introduced even without a `.Self ==` constraint:

```
interface HasCycle {
  let A:! P;
  let B:! Q where .X.Y == A.T and .X == A.T.U;
}
```

which normalizes to:

```
HasCycle
* $4 :! ...{.U = $3}
  - A.T as ...
  - B.X.Y as ...
* $3 :! ...{.Y = $4}
  - A.T.U as ...
  - B.X as ...
* $2 :! P{.T = $4}
  - A as P
* $1 :! Q{.X = $3}
  - B as Q
* $0 :! HasCycle{.A = $2, .B = $1}
  - Self as HasCycle
```

### No conflicting constraints on an associated type

When setting two terms equal, we need to combine the constraints of both terms
to get a type that both satisfy. We considered making combining `A{.X = T}` and
`A{.X = U}` when `T` and `U` are different an error. This was to avoid
recursively constraining `T` and `U` to be equal. The concern was this recursion
might not terminate, but this concern was eventually addressed.

This arises in this example:

```
interface Conflict {
  let T:! C;
  let U:! B;
  let V:! A where .X == T;
  let W:! A where .X == U and .Self == V;
}
```

The error would have said that `V` can't be set to `W` because `V.X == T` and
`W.X == U`. The user would have had to change the source in some way, such as
setting them both to `T` or both to `U` or constraining `T == U`.

We ultimately wanted to support this case, since it arises in the interaction of
`where` constraints that are allowed individually. This can be seen in this
example that would have been rejected:

```
interface ThreeWhereConstraints {
  Z:! A where .Y is Comparable;
  X:! A where .Y is Printable;
  W:! B where .V == Z and .V == X;
}
```

unless `and .Y == Z.Y` was added to the `where` clause on `X`.
