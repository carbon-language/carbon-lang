# Constraints for generics (generics details 3)

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/818)

<!-- toc -->

## Table of contents

-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Rationale based on Carbon's goals](#rationale-based-on-carbons-goals)
-   [Alternatives considered](#alternatives-considered)
    -   [Inline constraints instead of `.Self`](#inline-constraints-instead-of-self)
    -   [Self reference instead of `.Self`](#self-reference-instead-of-self)
    -   [No inferred/implied constraints for interfaces](#no-inferredimplied-constraints-for-interfaces)

<!-- tocstop -->

## Problem

We want to Carbon to have a high quality generics feature that achieves the
goals set out in [#24](https://github.com/carbon-language/carbon-lang/pull/24).
This is too big to land in a single proposal. This proposal continues
[#553](https://github.com/carbon-language/carbon-lang/pull/553) defining the
details of:

-   adapters
-   associated types and other constants
-   parameterized interfaces

## Background

This is a follow on to these previous generics proposals:

-   [#24: Generics goals](https://github.com/carbon-language/carbon-lang/pull/24)
-   [#447: Generics terminology](https://github.com/carbon-language/carbon-lang/pull/447)
-   [#524: Generics overview](https://github.com/carbon-language/carbon-lang/pull/524)
-   [#553: Generics details part 1](https://github.com/carbon-language/carbon-lang/pull/553)
-   [#731: Generics details 2: adapters, associated types, parameterized interfaces](https://github.com/carbon-language/carbon-lang/pull/731)

Some of the content for this proposal was extracted from a larger
[Generics combined draft proposal](https://github.com/carbon-language/carbon-lang/pull/36).

## Proposal

This is a proposal to add two sections to
[this design document on generics details](/docs/design/generics/details.md) and
an
[appendix with the algorithm that determines archetypes for generic type expressions](/docs/design/generics/appendix-archetype-algorithm.md).

## Rationale based on Carbon's goals

Much of this rationale was captured in the
[Generics goals proposal](https://github.com/carbon-language/carbon-lang/pull/24).

## Alternatives considered

FIXME: Issue
[#780: How to write constraints](https://github.com/carbon-language/carbon-lang/issues/780)
considered other forms that constraints could be written:

-   `where` clauses on declarations instead of types (Swift and Rust) - doesn't
    work with trait objects
-   parameter passing style used by Rust - can't express some kinds of
    constraints
-   whole expression constraint intersections - also can't express some
    constraints, allows setting one name in two interfaces at once, concerns
    about this making `&` be not associative / commutative

FIXME: other keywords: `requires`, `with`, `if`

FIXME: The
["parameterized type implements interface"](/docs/design/generics/details.md#parameterized-type-implements-interface)
case motivated Rust to
[add support for `where` clauses](https://rust-lang.github.io/rfcs/0135-where.html#motivation).

FIXME: Look through [this appendix](appendix-requires-constraints.md) for other
alternatives and rationale.

### Inline constraints instead of `.Self`

FIXME: Alternative to using `.Self` for
[recursive constraints](/docs/design/generics/details.md#recursive-constraints).

However, you can't always avoid using `.Self`, since naming the constraint
before using it doesn't allow you to define the `Container` interface above,
since the named constraint refers to `Container` in its definition.

**Rejected alternative:** To use this `constraint` trick to define `Container`,
you'd have to allow it to be defined inline in the `Container` definition:

```
interface Container {
  let ElementType:! Type;

  constraint ContainerIsSlice {
    extends Container where Container.SliceType == Self;
  }
  let SliceType:! ContainerIsSlice where .ElementType == ElementType;

  fn GetSlice[addr me: Self*](start: IteratorType,
                                    IteratorType: end) -> SliceType;
}
```

### Self reference instead of `.Self`

FIXME: Alternative to using `.Self` for
[recursive constraints](/docs/design/generics/details.md#recursive-constraints).

**Rejected alternative:** We could use the name of the type being declared
inside the type declaration, as in `T:! HasAbs(.MagnitudeType = T)`.

### No inferred/implied constraints for interfaces

FIXME

In interfaces, these constraints can be obscured:

```
interface I(A:! Type, B:! Type, C:! Type, D:! Type, E:! Type) {
  let SwapType:! I(B, A, C, D, E);
  let CycleType:! I(B, C, D, E, A);
  fn LookUp(hm: HashMap(D, E)*) -> E;
  fn Foo(x: Bar(A, B));
}
```

All type arguments to "I" must actually implement `Hashable` (since
[an adjacent swap and a cycle generate the full symmetry group on 5 elements](https://www.mathcounterexamples.net/generating-the-symmetric-group-with-a-transposition-and-a-maximal-length-cycle/)).
And additional restrictions on those types depend on the definition of `Bar`.
For example, this definition

```
class Bar(A:! Type, B:! ComparableWith(A)) { ... }
```

would imply that all the type arguments to `I` would have to be comparable with
every other. This propagation problem means that allowing implicit constraints
to be inferred in this context is substantial (potentially unbounded?) work for
the compiler, and these implied constraints are not at all clear to human
readers of the code either.

**Conclusion:** The initial declaration part of an `interface`, type definition,
or associated type declaration should include complete description of all needed
constraints.

Furthermore, inferring that two types are equal (in contrast to the type bound
constraints described so far) introduces additional problems for establishing
which types are equal in a generic context.
