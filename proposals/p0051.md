# Goals

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

**_PLEASE_ DO NOT SHARE OUTSIDE CARBON FORUMS**

[Pull request](https://github.com/carbon-language/carbon-lang/pull/51)

## Table of contents

<!-- toc -->

- [Problem](#problem)
- [Background](#background)
- [Proposal](#proposal)
- [Open questions](#open-questions)
  - [How should interoperability and migration be prioritized?](#how-should-interoperability-and-migration-be-prioritized)
- [Alternatives](#alternatives)
  - [Address community/project priorities differently](#address-communityproject-priorities-differently)
    - [Status quo](#status-quo)
    - [Completely remove the community priority from this document](#completely-remove-the-community-priority-from-this-document)
    - [Add community to the priority list](#add-community-to-the-priority-list)
    - [Merge project goals and language goals](#merge-project-goals-and-language-goals)

<!-- tocstop -->

## Problem

We want to have clear goals for the Carbon project, to both establish and
document where we expect Carbon to be headed. These are aspirational goals, and
we will try our best to achieve all of them. The documented goals should make it
easier for potential users to determine whether Carbon is an appropriate fit for
them.

## Background

Carbon's goals are heavily based on
["Goals and priorities for C++"](https://docs.google.com/document/d/1jrpGk6Sa0bt1u1tSuZtPnVI3inr7A4c0iJC9V2I6zUA/edit).
Many thanks to the authors and contributors for helping us formulate our goals
and priorities.

This proposal was drafted in
[Docs](https://docs.google.com/document/d/1MJvVIDXQrhIj6hZ7NwMDbDch9XLO2VaYrGq29E57meU/edit).

## Proposal

The proposed goals are encapsulated in
[the goals changes](/docs/project/goals.md).

## Open questions

### How should interoperability and migration be prioritized?

Right now, interoperability/migration is priority #7, indicating that when
trade-offs are necessary, interoperability is likely to suffer. Should it be
higher priority? At least some parties believe it should be somewhere in the top
3 priorities, perhaps #1.

Things to consider:

- Is the ability to interoperate/migrate non-negotiable?
  - Which of the other proposed goals are non-negotiable?
- How much are we willing to change the Carbon language away from the baseline
  of C++, making migratability more difficult?
- What happens to interoperability in the face of trade-offs?
- If interoperability and migration is a high enough priority, such as #1,
  should we switch to planning Carbon as an incremental forking of C++?
  - In other words, force a clear interoperability/migration path for all code,
    and all other priorities would fall behind a migration path.

What about example situations? How much do choices about trade-offs define our
priorities?

- C++ has platform-specific sizes and overflow behaviors that are a concern for
  integer types. Carbon's current plans of platform-agnostic sizes and
  performance-focused overflow behaviors hinder migratability. Should we instead
  use types that make migration and interoperability trivial?
- Should hardware architectures supported by Carbon be defined by the ability of
  users to migrate every user off of C++?
- Given C++'s current and future feature sets, should Carbon's evolution ensure
  that we have interoperability and migration plans for everything?

## Alternatives

### Address community/project priorities differently

A community priority was added to address that, while the "Governance and
evolution" doc calls for all decisions to be justified by goals, there was no
clear goal to justify the existence of things like a code of conduct. Similarly,
if performance is the highest priority, then one might decide that retaining a
performance expert may take priority over addressing their bad behavior.

To address this issue, a community priority was added. It is described as
"overarching", although not explicitly part of the numeric priority list. The
intent was to make it clear it's critical, while allowing the numeric priority
list to remain focused on language goals. This is also implied in how the
community goal is covered in detail before all other goals.

#### Status quo

The community priority could be addressed as-is in the proposal.

#### Completely remove the community priority from this document

We could completely remove the community priority from this document.

Pros:

- Allows this to be the "language goals" document.

Cons:

- Creates additional documents that need to be understood to parse language
  goals.
- Makes for less clear prioritization of community, increasing ambiguity on how
  community vs language design conflicts can be resolved.

#### Add community to the priority list

We could make the community priority part of the priority list; for example,
priority #1.

Pros:

- Makes the ordering unambiguous.

Cons:

- Makes what's current a numerated list of language design goals less
  design-focused.
- Prevents saying trivial things like "performance is our top priority".
  - Unless community isn't the top priority, resulting in the problems above.

#### Merge project goals and language goals

Originally, we only had one goals and priorities section. We could re-merge
project goals and language goals.

Pros:

- Makes the document shorter and more concise.
- Tooling can already be considered a priority under "Code that is easy to read,
  understand, and write", and is explicitly mentioned as part of that goal.

Cons:

- Previous setup raised objections over why the community goal wasn't part of
  the priority list.
