# Generics details 8: interface defaults

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/990)

<!-- toc -->

## Table of contents

-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Details](#details)
-   [Rationale based on Carbon's goals](#rationale-based-on-carbons-goals)
-   [Alternatives considered](#alternatives-considered)
    -   [Allow default implementations of required interfaces](#allow-default-implementations-of-required-interfaces)

<!-- tocstop -->

## Problem

TODO: What problem are you trying to solve? How important is that problem? Who
is impacted by it?

## Background

TODO: Is there any background that readers should consider to fully understand
this problem and your approach to solving it?

## Proposal

TODO: Briefly and at a high level, how do you propose to solve the problem? Why
will that in fact solve it?

## Details

TODO: Fully explain the details of the proposed solution.

## Rationale based on Carbon's goals

TODO: How does this proposal effectively advance Carbon's goals? Rather than
re-stating the full motivation, this should connect that motivation back to
Carbon's stated goals for the project or language. This may evolve during
review. Use links to appropriate goals, for example:

-   [Community and culture](/docs/project/goals.md#community-and-culture)
-   [Language tools and ecosystem](/docs/project/goals.md#language-tools-and-ecosystem)
-   [Performance-critical software](/docs/project/goals.md#performance-critical-software)
-   [Software and language evolution](/docs/project/goals.md#software-and-language-evolution)
-   [Code that is easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write)
-   [Practical safety and testing mechanisms](/docs/project/goals.md#practical-safety-and-testing-mechanisms)
-   [Fast and scalable development](/docs/project/goals.md#fast-and-scalable-development)
-   [Modern OS platforms, hardware architectures, and environments](/docs/project/goals.md#modern-os-platforms-hardware-architectures-and-environments)
-   [Interoperability with and migration from existing C++ code](/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code)

## Alternatives considered

TODO: What alternative solutions have you considered?

FIXME: Do not support default implementation of a required interface. Problem:
coherence. Problem: two interfaces providing different defaults. Workaround: use
a blanket impl instead. This requires both interfaces to be in the same library,
since there are dependencies in both directions (one to state the interface
requirement, and the other for the orphan rule applied to the blanket impl), but
that is what is inherently needed to satisfy coherence (or an explicit
implementation of the required interface even when it is empty). Prioritization
between blanket impls resolves the question of what to do when two interfaces
provide different default impls for a common requirement.

FIXME: No requirement that default implementations are not mutually recursive.
Useful in cases where

FIXME: Unlike Rust, Carbon has no plans to do more general inheritance of
implementation.

FIXME: In fact, defaults are a generalization of
[specialization](terminology.md#specialization), as observed
[here](https://rust-lang.github.io/rfcs/1210-impl-specialization.html#default-impls),
as long as we allow more specific implementations to be incomplete and reuse
more general implementations for anything unspecified.

More background in
[this "Specialize to reuse" blog post](http://aturon.github.io/tech/2015/09/18/reuse/).

One variation on this may be default implementations of entire interfaces. For
example, `RandomAccessContainer` extends `Container` with an `IteratorType`
satisfying `RandomAccessIterator`. That is sufficient to provide a default
implementation of the indexing operator (operator `[]`), by way of
[implementing an interface](#operator-overloading).

```
interface RandomAccessContainer {
  // Refinement of the associated type `IteratorType` from `Container`.
  extends Container where .IteratorType is RandomAccessIterator;

  // Either `impl` or `extends` here, depending if you want
  // `RandomAccessContainer`'s API to include these names.
  impl as OperatorIndex(Int) {
    // Default implementation of interface.
    fn Get[me: Self](i: Int) -> ElementType {
      return (this.Begin() + i).Get();
    }
    fn Set[addr me: Self*](i: Int, value: ElementType) {
      (this->Begin() + i).Set(value);
    }
  }
}
```

Note that there is a difference between extending an interface with a `where`
constraint specifying a requirement on an associated type, as is done for
`Container.IteratorType` above, and providing a default value for an associated
type, which can be overridden.

### Allow default implementations of required interfaces

Here are the reasons we considered for not allowing interfaces to provide
default implementations of interfaces they require:

-   This feature would lead to incoherence unless types implementing
    `TotalOrder` also must explicitly implement `PartialOrder`, possibly with an
    empty definition. The problem arises since querying whether `PartialOrder`
    is implemented for a type does not require that an implementation of
    `TotalOrder` be visible.
-   It would be unclear how to resolve the ambiguity of which default to use
    when two different interfaces provide different defaults for a common
    interface requirement.
-   It would be ambiguous whether the required interface should be
    [external](/docs/design/generics/terminology.md#external-impl) or
    [internal](/docs/design/generics/terminology.md#internal-impl) unless
    `PartialOrder` is implemented explicitly.
-   There would be a lot of overlap between default impls and blanket impls.
    Eliminating default impls keeps the language smaller and simpler.
