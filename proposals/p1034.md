# Generic details 9: default impl

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/1034)

<!-- toc -->

## Table of contents

-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Rationale based on Carbon's goals](#rationale-based-on-carbons-goals)
-   [Alternatives considered](#alternatives-considered)
    -   [Status quo using blanket impls](#status-quo-using-blanket-impls)
    -   [Weak impls](#weak-impls)
    -   [Final impls in interfaces](#final-impls-in-interfaces)
    -   [Explicit prioritization of default impls](#explicit-prioritization-of-default-impls)
    -   [Separate default impls from requirements](#separate-default-impls-from-requirements)
    -   [Allow part of a default impl to be defined out of line](#allow-part-of-a-default-impl-to-be-defined-out-of-line)

<!-- tocstop -->

## Problem

We want there to be a convenient way to implement two impls together in a
consistent way. For example, given two types `T1` and `T2` that are equality
comparable to each other, we would like to get the same result no matter which
type appears on the left side of the equal sign.

For equality comparison, it would be reasonable to require that it be defined in
both directions if it is defined for one. In other cases, the order of the
arguments to an operator will matter for some types but not others. For example,
addition is commutative for integers but not strings. We'd like to make it
convenient to specify that addition is commutative for specific pairs of types
without requiring that addition is always commutative.

## Background

In addition to equality and order comparisons, the `CommonType` interface from
[proposal #911: "conditional expressions"](https://github.com/carbon-language/carbon-lang/pull/911)
should be defined symmetrically.

[Rejected proposal #1027: "weak impls"](https://github.com/carbon-language/carbon-lang/pull/1027)
attempted to address these use cases, but in practice that approach
[did not result in the correct prioritization of impls](https://discord.com/channels/655572317891461132/708431657849585705/931740599600709692).
The symptom would be that switching the argument order could result in a
different specialization being selected. This problem arose since the
implementation for one order came from a general blanket impl with low priority,
instead of both argument orders having similar priority.

[Proposal #990](https://github.com/carbon-language/carbon-lang/pull/990) defined
interface defaults, but specifically excluded letting interfaces give defaults
for other interfaces it required. At the time that feature seemed to have too
much overlap with what could be done with blanket impls and was not worth the
additional complexity it would introduce and questions that would need to be
resolved. However, once weak impls were found to be an inadequate solution for
their intended use cases, it was discovered that default implementations would
be able to solve this problem better. These use cases also helped give answers
to the open questions in the design.

## Proposal

We allow an interface to provide a default implementation when it requires or
extends another interface. This is described in detail in
[the "Default implementation of required interface" section of `docs/design/generics/details.md`](/docs/design/generics/details.md#default-implementation-of-required-interface).

## Rationale based on Carbon's goals

This proposal is important for using the intended specialization, particularly
for overloaded operators. Specialization is part of Carbon's
[performance story](/docs/project/goals.md#performance-critical-software).

In addition, providing a default implementation of a required interface directly
in the interface definition rather than in a separate blanket `impl` is expected
to help make Carbon code
[easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write),
since that puts related code together and avoids repeating information relating
those two interfaces together.

## Alternatives considered

### Status quo using blanket impls

[The original proposal that added interface defaults](https://github.com/carbon-language/carbon-lang/pull/990)
[considered and rejected allowing interfaces to proved implementations of required interfaces](p0990.md#allow-default-implementations-of-required-interfaces).
That proposal recommended using blanket impls instead. Since then we have come
to understand that blanket impls don't address an important use case as well as
we want, and so we have attempted to answer the open questions about how this
feature would work:

-   Requiring both interfaces to be defined in the same library addresses
    incoherence concerns.
-   We prioritize impls provided by default just after the impl that triggered
    its instantiation.
-   We resolved rules determining when the default impl would be
    [external](/docs/design/generics/terminology.md#external-impl) or
    [internal](/docs/design/generics/terminology.md#internal-impl) based on
    whether the interface uses `impl as` or `extends`.

We also had specific concerns that there would be cases where a default
implementation is prioritized over an explicit implementation in a way that
would be surprising to users. The main concern is how a default impl is not
visible in the source in the same places as other impls. This is how defaults
work generally, and so seemed like something users would be able to understand,
but is something to be on the lookout for once we gain experience with this
feature.

### Weak impls

We considered allowing declarations in the same library as an interface to mark
some implementations as `weak` and use constraints restricted to the non-`weak`
implementations manually written by users, in
[rejected proposal #1027](https://github.com/carbon-language/carbon-lang/pull/1027).

The
[main problem with this approach](https://discord.com/channels/655572317891461132/708431657849585705/931740599600709692)
is that the weak impls provided by the interface's library in the envisioned use
cases were prioritized incorrectly. For example, with these definitions:

```
interface CommonType(T:! Type) {
  let Result:! Type;
}
weak impl [T:! Type, U:! CommonTypeWith(T)]
    T as CommonTypeWith(U) where .Result = U.Result {}
impl Optional(T) as CommonType(T) where .Result = Optional(T) {}
impl T* as CommonType(Optional(T*)) where .Result = Nullable(T*) {}
```

then the common type of `Optional(T*)` and `T*` would either be `Optional(T*)`
or `Nullable(T*)` depending on the order they were tested. This is because the
blanket `weak` impl is very broad and therefore is given low priority. To get a
symmetric answer, we need the impls corresponding to the two orders to have the
same priority as if the reversed impl was provided explicitly.

### Final impls in interfaces

Under the rules of this proposal, a type can implement an interface that has a
default implementation for another interface only if it would be legal to write
the default implementation explicitly. The
[rules for final impls outside of interfaces](/docs/design/generics/details.md#libraries-that-can-contain-final-impls)
from [proposal #983](https://github.com/carbon-language/carbon-lang/pull/983)
restrict which libraries are allowed to declare a `final` impl. Combining these
rules would mean that interfaces that provide a definition for a required impl
of another interface would have additional restrictions, which seemed surprising
and awkward to use.

Furthermore, these restrictions are essential, otherwise you could make a copy
of an interface to bypass the restrictions on `final`:

```
interface I {
  fn F...();
}
// Defined in the same library as `I`.
interface FinalI {
  fn F...();
  final impl as I { fn F...() { FinalI.F(); } }
}
```

With this definition of `FinalI`, you could get around the rules for final impls
by implementing `FinalI` instead of `I`.

The use cases for `final` impls are well served by `final` blanket impls. The
motivation for default impls do not apply here since `final` prevents higher
priority impls from being defined.

### Explicit prioritization of default impls

We did not include a method of explicitly prioritizing default impls for
simplicity. If the current approach is shown to have problems in practice, we
may add a way to indicate how they are prioritized explicitly in a `match_first`
block.

### Separate default impls from requirements

Right now, the syntax for defining a default impl also defines a matching
requirement at the same time. A workaround for this is provided
[in the proposal](/docs/design/generics/details.md#constraint-weaker-than-default-impl),
but it is surprising and requires a lot of boilerplate. A future proposal may
make changes to address this use case if it is found to be important.

### Allow part of a default impl to be defined out of line

You might want to define part of a default impl out of line for readability or
to break a cycle. This proposal does not address that use case. This should be
addressed in a future proposal if we determine it is needed.
