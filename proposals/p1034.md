# Generic details 9: default impl

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/1034)

<!-- toc -->

## Table of contents

-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Rationale based on Carbon's goals](#rationale-based-on-carbons-goals)
-   [Alternatives considered](#alternatives-considered)

<!-- tocstop -->

## Problem

We want there to be a convenient way to implement two impls together in a
consistent way. For example, given two types `T1` and `T2` that are equality
comparable to each other, we would like to get the same result no matter which
type appears on the left side of the equal sign.

For equality comparison, it would be reasonable to require that it be defined in
both directions if it is defined for one. In other cases, the order of the
arguments to an operator will matter for some types but not others. For example,
addition is commutative for integers but not strings. We'd like to make it
convenient to specify that addition is commutative for specific pairs of types
without requiring that addition is always commutative.

## Background

In addition to equality and order comparisons, the `CommonType` interface from
[proposal #911: "conditional expressions"](https://github.com/carbon-language/carbon-lang/pull/911)
should be defined symmetrically.

[Rejected proposal #1027: "weak impls"](https://github.com/carbon-language/carbon-lang/pull/1027)
attempted to address these use cases, but in practice that approach
[did not result in the correct prioritization of impls](https://discord.com/channels/655572317891461132/708431657849585705/931740599600709692).
The symptom would be that switching the argument order could result in a
different specialization being selected. This problem arose since the
implementation for one order came from a general blanket impl with low priority,
instead of both argument orders having similar priority.

[Proposal #990](https://github.com/carbon-language/carbon-lang/pull/990) defined
interface defaults, but specifically excluded letting interfaces give defaults
for other interfaces it required. At the time that feature seemed to have too
much overlap with what could be done with blanket impls and was not worth the
additional complexity it would introduce and questions that would need to be
resolved. However, once weak impls were found to be an inadequate solution for
their intended use cases, it was discovered that default implementations would
be able to solve this problem better. These use cases also helped give answers
to the open questions in the design.

## Proposal

We allow an interface to provide a default implementation when it requires or
extends another interface. This is described in detail in
[the "FIXME" section of `docs/design/generics/details.md`](docs/design/generics/details.md#FIXME).

## Rationale based on Carbon's goals

TODO: How does this proposal effectively advance Carbon's goals? Rather than
re-stating the full motivation, this should connect that motivation back to
Carbon's stated goals for the project or language. This may evolve during
review. Use links to appropriate goals, for example:

-   [Community and culture](/docs/project/goals.md#community-and-culture)
-   [Language tools and ecosystem](/docs/project/goals.md#language-tools-and-ecosystem)
-   [Performance-critical software](/docs/project/goals.md#performance-critical-software)
-   [Software and language evolution](/docs/project/goals.md#software-and-language-evolution)
-   [Code that is easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write)
-   [Practical safety and testing mechanisms](/docs/project/goals.md#practical-safety-and-testing-mechanisms)
-   [Fast and scalable development](/docs/project/goals.md#fast-and-scalable-development)
-   [Modern OS platforms, hardware architectures, and environments](/docs/project/goals.md#modern-os-platforms-hardware-architectures-and-environments)
-   [Interoperability with and migration from existing C++ code](/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code)

## Alternatives considered

TODO: What alternative solutions have you considered?
