# Generic details 9: default impl

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/1034)

<!-- toc -->

## Table of contents

-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Rationale based on Carbon's goals](#rationale-based-on-carbons-goals)
-   [Alternatives considered](#alternatives-considered)
    -   [Status quo using blanket impls](#status-quo-using-blanket-impls)
    -   [Weak impls](#weak-impls)
    -   [Final impls in interfaces](#final-impls-in-interfaces)

<!-- tocstop -->

## Problem

We want there to be a convenient way to implement two impls together in a
consistent way. For example, given two types `T1` and `T2` that are equality
comparable to each other, we would like to get the same result no matter which
type appears on the left side of the equal sign.

For equality comparison, it would be reasonable to require that it be defined in
both directions if it is defined for one. In other cases, the order of the
arguments to an operator will matter for some types but not others. For example,
addition is commutative for integers but not strings. We'd like to make it
convenient to specify that addition is commutative for specific pairs of types
without requiring that addition is always commutative.

## Background

In addition to equality and order comparisons, the `CommonType` interface from
[proposal #911: "conditional expressions"](https://github.com/carbon-language/carbon-lang/pull/911)
should be defined symmetrically.

[Rejected proposal #1027: "weak impls"](https://github.com/carbon-language/carbon-lang/pull/1027)
attempted to address these use cases, but in practice that approach
[did not result in the correct prioritization of impls](https://discord.com/channels/655572317891461132/708431657849585705/931740599600709692).
The symptom would be that switching the argument order could result in a
different specialization being selected. This problem arose since the
implementation for one order came from a general blanket impl with low priority,
instead of both argument orders having similar priority.

[Proposal #990](https://github.com/carbon-language/carbon-lang/pull/990) defined
interface defaults, but specifically excluded letting interfaces give defaults
for other interfaces it required. At the time that feature seemed to have too
much overlap with what could be done with blanket impls and was not worth the
additional complexity it would introduce and questions that would need to be
resolved. However, once weak impls were found to be an inadequate solution for
their intended use cases, it was discovered that default implementations would
be able to solve this problem better. These use cases also helped give answers
to the open questions in the design.

## Proposal

We allow an interface to provide a default implementation when it requires or
extends another interface. This is described in detail in
[the "FIXME" section of `docs/design/generics/details.md`](docs/design/generics/details.md#FIXME).

## Rationale based on Carbon's goals

TODO: How does this proposal effectively advance Carbon's goals? Rather than
re-stating the full motivation, this should connect that motivation back to
Carbon's stated goals for the project or language. This may evolve during
review. Use links to appropriate goals, for example:

-   [Community and culture](/docs/project/goals.md#community-and-culture)
-   [Language tools and ecosystem](/docs/project/goals.md#language-tools-and-ecosystem)
-   [Performance-critical software](/docs/project/goals.md#performance-critical-software)
-   [Software and language evolution](/docs/project/goals.md#software-and-language-evolution)
-   [Code that is easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write)
-   [Practical safety and testing mechanisms](/docs/project/goals.md#practical-safety-and-testing-mechanisms)
-   [Fast and scalable development](/docs/project/goals.md#fast-and-scalable-development)
-   [Modern OS platforms, hardware architectures, and environments](/docs/project/goals.md#modern-os-platforms-hardware-architectures-and-environments)
-   [Interoperability with and migration from existing C++ code](/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code)

## Alternatives considered

### Status quo using blanket impls

[The original proposal that added interface defaults](https://github.com/carbon-language/carbon-lang/pull/990)
[considered and rejected allowing interfaces to proved implementations of required interfaces](p0990.md#allow-default-implementations-of-required-interfaces).
That proposal recommended using blanket impls instead. Since then we have come
to understand that blanket impls don't address an important use case as well,
and so we have attempted to answer the open questions about how this feature
would work:

-   Requiring both interfaces to be defined in the same library addresses
    incoherence concerns.
-   FIXME: Need a way to prioritized impls provided by default against
    overlapping
-   We resolved rules determining when the default impl would be
    [external](/docs/design/generics/terminology.md#external-impl) or
    [internal](/docs/design/generics/terminology.md#internal-impl).

We also had specific concerns that there would be cases where a default
implementation is prioritized over an explicit implementation in a way that
would be surprising to users. The main concern is how a default impl is not
visible in the source in the same places as other impls. This is how defaults
work generally, and so seemed like something users would be able to understand,
but is something to be on the lookout for once we gain experience with this
feature.

### Weak impls

We considered allowing declarations in the same library as an interface to mark
some implementations as `weak` and use constraints restricted to the non-`weak`
implementations manually written by users, in
[rejected proposal #1027](https://github.com/carbon-language/carbon-lang/pull/1027).

The
[main problem with this approach](https://discord.com/channels/655572317891461132/708431657849585705/931740599600709692)
is that the weak impls provided by the interface's library in the envisioned use
cases were prioritized incorrectly. For example, with these definitions:

```
interface CommonType(T:! Type) {
  let Result:! Type;
}
weak impl [T:! Type, U:! CommonTypeWith(T)]
    T as CommonTypeWith(U) where .Result = U.Result {}
impl Optional(T) as CommonType(T) where .Result = Optional(T) {}
impl T* as CommonType(Optional(T*)) where .Result = Nullable(T*) {}
```

then the common type of `Optional(T*)` and `T*` would either be `Optional(T*)`
or `Nullable(T*)` depending on the order they were tested. This is because the
blanket `weak` impl is very broad and therefore is given low priority. To get a
symmetric answer, we need the impls corresponding to the two orders to have the
similar priority as the reversed impl was provided explicitly.

### Final impls in interfaces

Under the rules of this proposal, a type can implement an interface that has a
default implementation for another interface only if it would be legal to write
the default implementation explicitly. The
[rules for final impls outside of interfaces](/docs/design/generics/details.md#libraries-that-can-contain-final-impls)
from [proposal #983](https://github.com/carbon-language/carbon-lang/pull/983)
restrict which libraries are allowed to declare a `final` impl. Combining these
rules would mean that interfaces that provide a definition for a required impl
of another interface would have additional restrictions, which seemed surprising
and awkward to use.

Furthermore, these restrictions are essential, otherwise you could make a copy
of an interface to bypass the restrictions on `final`:

```
interface I {
  fn F...();
}
// Defined in the same library as `I`.
interface FinalI {
  fn F...();
  final impl as I { fn F...() { FinalI.F(); } }
}
```

With this definition of `FinalI`, you could get around the rules for final impls
by implementing `FinalI` instead of `I`.

The use cases for `final` impls are well served by `final` blanket impls. The
motivation for default impls do not apply here since `final` prevents higher
priority impls from being defined.
