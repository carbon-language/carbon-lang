# Template generics

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/2200)

<!-- toc -->

## Table of contents

-   [Abstract](#abstract)
-   [Problem](#problem)
-   [Background](#background)
-   [Terminology](#terminology)
-   [Proposal](#proposal)
-   [Details](#details)
    -   [Syntax](#syntax)
    -   [Value phases](#value-phases)
    -   [`auto`](#auto)
    -   [Template constraints](#template-constraints)
    -   [Name lookup](#name-lookup)
    -   [Transition from C++ templates to Carbon checked generics](#transition-from-c-templates-to-carbon-checked-generics)
        -   [To template Carbon with structural constraints](#to-template-carbon-with-structural-constraints)
        -   [To interface constraints](#to-interface-constraints)
        -   [To checked generic](#to-checked-generic)
    -   [Validity can depend on value](#validity-can-depend-on-value)
    -   [Branching on type identity](#branching-on-type-identity)
-   [Rationale](#rationale)
-   [Alternatives considered](#alternatives-considered)
    -   [Only checked generics](#only-checked-generics)
    -   [SFINAE](#sfinae)
    -   [Template API specialization](#template-api-specialization)
    -   [Value phase of bindings determined by initializer](#value-phase-of-bindings-determined-by-initializer)
-   [Future work](#future-work)
    -   [Expanded template constraints](#expanded-template-constraints)
    -   [Predicates: constraints on values](#predicates-constraints-on-values)
    -   [Generics calling templates](#generics-calling-templates)

<!-- tocstop -->

## Abstract

FIXME: Describe, in a succinct paragraph, the gist of this document. This
paragraph should be reproduced verbatim in the PR summary.

## Problem

Starting with
[#24: Generics goals](https://github.com/carbon-language/carbon-lang/pull/24),
we have assumed templates (also known as "template generics" in Carbon) will be
a feature of Carbon, but it has not been an accepted part of the design. We now
understand enough about how they should fit into the language to decide that we
are including the feature in the language, and how.

Template generics will address these use cases:

-   They provide a step in the transition from C++ templates to Carbon checked
    generics.
-   They provide a generics programming model familiar to C++ developers.
-   They allow Carbon to separate features that we don't want to expose by
    default in checked generics. These are features that pierce abstraction
    boundaries that we want to discourage for software engineering reasons or at
    least mark when they are in use. Examples in this category include:
    -   Compile-time duck typing features that use the structural properties of
        types, like having a method with a particular name, rather than semantic
        properties like implementing an interface.
    -   Branching in code based on type identity.

Out of scope for this proposal are any questions about passing a checked generic
argument value to a template parameter. See question-for-leads issue
[#2153: Generics calling templates](https://github.com/carbon-language/carbon-lang/issues/2153).

## Background

Templates are the mechanism for performing
[generic programming](https://en.wikipedia.org/wiki/Generic_programming) in C++,
see [cppreference.com](https://en.cppreference.com/w/cpp/language/templates).

There have been a number of prior proposals and questions-for-leads issues on
template generics on which this proposal builds:

-   Proposal
    [#24: Generics goals](https://github.com/carbon-language/carbon-lang/pull/24)
    talked about the reasons for templates, without committing Carbon to
    including them. These reasons include making it easier to transition C++
    template code to Carbon and providing functionality outside of what we want
    to support with checked generics.
-   Proposal
    [#447: Generics terminology](https://github.com/carbon-language/carbon-lang/pull/447)
    defined terminology. This included some of the differences between checked
    and template generics, and definitions for terms like _instantiation_.
-   Proposal
    [#553: Generic details part 1](https://github.com/carbon-language/carbon-lang/pull/553)
    defined `auto` as a template construct, and described how templates do not
    require constraints to find member names.
-   Question-for-leads issue
    [#565: Generic syntax to replace provisional `$`s](https://github.com/carbon-language/carbon-lang/issues/565)
    implemented in proposal
    [#676: `:!` generic syntax](https://github.com/carbon-language/carbon-lang/pull/676)
    defined the syntax for template bindings.
-   Proposal
    [#731: Generics details 2: adapters, associated types, parameterized interfaces](https://github.com/carbon-language/carbon-lang/pull/731)
    included that template values may be passed to generic parameters.
-   Proposal
    [#818: Constraints for generics](https://github.com/carbon-language/carbon-lang/pull/818)
    included `template constraint` to defined named constraints with fewer
    restrictions for use with template parameters.
-   Proposal
    [#875: Principle: information accumulation](https://github.com/carbon-language/carbon-lang/pull/875)
    considered how the principle benefited and was impacted by templates.
-   Question-for-leads issue
    [#949: Constrained template name lookup](https://github.com/carbon-language/carbon-lang/issues/949)
    implemented in proposal
    [#989: Member access expressions](https://github.com/carbon-language/carbon-lang/pull/989)
    defined how name lookup works for template parameters. It provided a path to
    incrementally adopt constraints on template parameters, a stepping stone to
    transitioning to checked generics.
-   Proposal
    [#950: Generics details 6: remove facets](https://github.com/carbon-language/carbon-lang/pull/950)
    included the impact on the semantics of templates in its rationale.
-   Proposal
    [#1146: Generic details 12: parameterized types](https://github.com/carbon-language/carbon-lang/pull/1146)
    allowed template type parameters.
-   Proposal
    [#1270: Update and expand README content and motivation for Carbon](https://github.com/carbon-language/carbon-lang/pull/1270)
    advertised that Carbon would support templates for "seamless C++ interop."
-   Terminology was updated in proposal
    [#2138: Checked and template generic terminology](https://github.com/carbon-language/carbon-lang/pull/2138).

TODO: Update if proposal
[#2188: Pattern matching syntax and semantics](https://github.com/carbon-language/carbon-lang/pull/2188)
is accepted first.

## Terminology

-   A _dependent_ name or expression is one whose meaning depends on, that is
    varies with, some (checked or template) generic parameter. This is
    consistent with the meaning of this term in
    [C++](https://en.cppreference.com/w/cpp/language/dependent_name), but is
    different from
    ["dependent types"](https://en.wikipedia.org/wiki/Dependent_type).
-   [_Instantiation_](/docs/design/generics/terminology.md#instantiation),
    _substitution_, or
    [_monomorphizaton_](https://en.wikipedia.org/wiki/Monomorphization) is the
    process of duplicating the implementation of a function and then
    substituting in the values of any (checked or template) generic arguments.
-   Errors that are only detected once the argument value from the call site are
    known as _monomorphization errors_. These mostly occur in expressions
    dependent on some template parameter, but can also occur for other reasons
    like hitting an implementation limit.
-   _SFINAE_ stands for "Substitution failure is not an error", which is the
    policy in C++, see
    [cppreference](https://en.cppreference.com/w/cpp/language/sfinae),
    [wikipedia](https://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error).
    It means that functions from an overload set with monorphization errors, or
    "substitution failure", are simply ignored instead of causing compilation to
    fail.

## Proposal

We propose that template generics are included as an official feature of Carbon.

In many ways, template generic parameters work like checked generic parameters.
The following are true for any kind of generic parameter:

-   The value passed to a generic parameter must be able to be evaluated at
    compile time.
-   Generic parameters may have constraints that will be enforced by the
    compiler on the value supplied by the caller.
-   The compiler may choose to generate multiple copies of a generic function
    for different values of the generic parameters.

The main differences between checked and templated generics are:

-   Member lookup into a templated type looks in both the actual type value
    provided by the caller in addition to in any constraints on that type see
    [proposal #989](https://github.com/carbon-language/carbon-lang/pull/989).
-   A templated parameter may be used in ways where the validity of the result
    depends on the value of the parameter, not just its type.

As a consequence of these differences, type checking of any expression dependent
on a templated parameter may not be completed until its value is known. In
addition, templated generics support branching on the value of a templated type.

In contrast with C++ templates, with Carbon template generics:

-   Substitution failure is an error. In C++, [the SFINAE rule](#terminology)
    will skip functions in overload resolution that fail to instantiate.
    Instead, Carbon template parameters use constraints to control when the
    function is available.
-   Carbon template specialization does not allow ad hoc changes to the API of
    the function or type being specialized, only its implementation. This is in
    contrast to C++, where
    [C++'s `std::vector<bool>`](https://en.cppreference.com/w/cpp/container/vector_bool)
    has different return types for certain methods. Anything that can vary in an
    API must be explicitly marked using associated types of an interface, as is
    described in the
    ["parameterized type specialization" design](/docs/design/generics/details.md#specialization).
-   Constraints on a Carbon template type affect how lookup is done into that
    type, as described in
    [proposal #989](https://github.com/carbon-language/carbon-lang/pull/989).

## Details

### Syntax

Template generic bindings are declared using the `template` keyword in addition
to the `:!` of all generic bindings. All generic bindings can only be used in
`let` context to produce r-values, not in a `var` context to produce l-values.
This includes `let` declarations, as in:

```carbon
// `N` is a constant that may be used in types.
let template N:! i64 = 4;
var my_array: [u8; N] = (255, 128, 64, 255);
```

Function parameters also default to a `let` context and may use `template`:

```carbon
// `U` is a templated type parameter that must be specified
// explicitly by the caller.
fn Cast[template T:! Type](x: T, template U:! Type) -> U {
  return x as U;
}

let x: i32 = 7;
// Calls `Cast` with `T` set to `i32` and `U` set to `i64`.
let y: auto = Cast(x, i64);
// Type of `y` is `i64`.
```

Branching on the value of a templated type will be done using a `match`
statement, but is outside the scope of this proposal. See instead pending
proposal
[#2188: Pattern matching syntax and semantics](https://github.com/carbon-language/carbon-lang/pull/2188).

### Value phases

R-values are divided into three different _value phases_:

-   A _constant_ has a value known at compile time, and that value is available
    during type checking, for example to use as the size of an array. These
    include literals (integer, floating-point, string), concrete type values
    (like `f64` or `Optional(i32*)`), expressions in terms of constants, and
    values of `template` parameters.
-   A _symbolic value_ has a value that will be known at the code generation
    stage of compilation when monomorphization happens, but is not known during
    type checking. This includes checked-generic parameters, and type
    expressions with checked-generic arguments, like `Optional(T*)`.
-   A _runtime value_ has a dynamic value only known at runtime.

So:

-   A `let template T:! ...` or `fn F(template T:! ...)` declaration binds `T`
    with constant value phase,
-   A `let T:! ...` or `fn F(T:! ...)` declaration binds `T` with symbolic value
    phase,
-   A `let x: ...` or `fn F(x: ...)` declaration binds `x` with runtime value
    phase.

**Note:** The naming of value phases is the subject of open question-for-leads
issue
[#1391: New name for "constant" value phase](https://github.com/carbon-language/carbon-lang/issues/1391).
This terminology comes from
[a discussion in #typesystem on Discord](https://discord.com/channels/655572317891461132/708431657849585705/992817321074774098),
in particular
[this message](https://discord.com/channels/655572317891461132/708431657849585705/994396535561408623).

**Note:** The situations in which a value with one phase can be used to
initialize a binding with a different value phase is partially considered in
question-for-leads issue
[#2153: Generics calling templates](https://github.com/carbon-language/carbon-lang/issues/2153).

FIXME: what is definitely allowed

FIXME: value phase of expressions

### `auto`

The `auto` keyword is a shortcut for an unnamed templated type, as in:

```carbon
// Type of `x` is the same as the return type of function `F`.
let x: auto = F();
```

This was first added to Carbon in proposal
[#553: Generic details part 1](https://github.com/carbon-language/carbon-lang/pull/553)
and further specified by open proposal
[#2188: Pattern matching syntax and semantics](https://github.com/carbon-language/carbon-lang/pull/2188).

The `auto` keyword may also be used to omit the return type, as specified in
[#826: Function return type inference](https://github.com/carbon-language/carbon-lang/pull/826).
This feature is being reconsidered in the open question-for-leads issue
[#1008: How much complexity should we invest in deduced/inferred return types?](https://github.com/carbon-language/carbon-lang/issues/1008).

The semantics of `let x:! auto = ...` is the subject of open question-for-leads
issue
[#996: Generic `let` with `auto`?](https://github.com/carbon-language/carbon-lang/issues/996).

### Template constraints

Template constraints have already been introduced in proposal
[#818: Constraints for generics](https://github.com/carbon-language/carbon-lang/pull/818).
In brief, a `template constraint` declaration is like a `constraint`
declaration, except that it may also contain function and field declarations,
called _structural constraints_. Only types with matching declarations will
satisfying the template constraint. Note that the declarations matching the
structural constraints must be in the type declaration itself, not in an
external impl.

```carbon
interface A { fn F[me: Self](); }
interface B { fn F[me: Self](); }
class C { }
external impl C as A;
external impl C as B;
template constraint HasF {
  fn F[me: Self]();
}
fn G[template T:! HasF](x: T);
var y: C = {};
// Can't call `G` with with `y` since it doesn't have any internal
// implementation of a method `F` satisfying `HasF`, even though `C`
// externally implements both `A` and `B` with such an `F`. May
// define an adapter for `C` to get a type that implements `HasF`,
// with `A.F`, `B.F`, or some other definition.
```

This was discussed in
[#generics-and-templates on 2022-09-20](https://discord.com/channels/655572317891461132/941071822756143115/1021903925613449316).

Structural constraints do not affect [name lookup](#name-lookup) into template
type parameters. They guarantee that a name will be available in the type, but
don't change the outcome.

```carbon
template constraint HasF {
  fn F[me: Self]();
}
class C {
  fn F[me: Self]();
}
fn G[template T:! HasF](x: T) {
  x.F();
}
var y: C = {};
// Call to `F` inside `G` is not ambiguous since
// `C.F` and `HasF.F` refer to the same function.
G(y);
```

Whether template constraints may be used as constraints on checked-generic
parameters is being considered in question-for-leads issue
[#2153: Generics calling templates](https://github.com/carbon-language/carbon-lang/issues/2153).
Even if we allow a checked-generic parameter to use a template constraint, we
want to focus checked generics on semantic properties encapsulated in
interfaces, not structural properties tested by template constraints. So we
would not allow lookup into checked-generic type to find type members outside of
an interface:

```carbon
template constraint HasF {
  fn F[me: Self]();
}
// ❓ If we allow a checked generic to use a template
// constraint, as in:
fn H[T:! HasF](x: T) {
  // We still will not support calling `F` on `x`:
  // ❌ x.F();
}
```

These members would only be found using a template type parameter.

[Expanding the kinds of template constraints](#expanded-template-constraints)
and
[defining a way to put constraints on values](#predicates-constraints-on-values)
are both [future work](#future-work).

### Name lookup

Name lookup for templates has already been decided in question-for-leads issue
[#949: Constrained template name lookup](https://github.com/carbon-language/carbon-lang/issues/949)
and proposal
[#989: Member access expressions](https://github.com/carbon-language/carbon-lang/pull/989).
Briefly, name lookup is done both in the actual type value supplied at the call
site and the interface constraints on the parameter. If the name is found in
both, it is an error if they resolve to different entities.

Look up into the calling type gives _compile-time duck typing_ behavior, much
like C++ templates, as in:

```carbon
fn F[template T:! Type](x: T) {
  // Calls whatever `M` is declared in `T`, and will
  // fail if `T` does not have a matching member `M`.
  x.M();
}

class C1 { fn M[me: Self](); }
var x1: C1 = {};
// Calls `F` with `T` equal to `C1`, which succeeds.
F(x1);

class C2 { fn M[addr me: Self*](); }
var x2: C2 = {};
// Calls `F` with `T` equal to `C2`, which fails,
// since `x` is an r-value in `F` and `C2.M` requires
// an l-value.
F(x2);

class C3 { fn M[me: Self](p: i32); }
var x3: C3 = {};
// Calls `F` with `T` equal to `C3`, which fails,
// since `C3.M` must be passed an argument value.
F(x3);

class C4 { fn M[me: Self](p: i32 = 4); }
var x4: C4 = {};
// Calls `F` with `T` equal to `C4`, which succeeds,
// using the default value of `4` for `p` when
// calling `C4.M`.
F(x4);

class C5 { var v: i32; }
var x5: C5 = {.v = 5};
// Calls `F` with `T` equal to `C5`, which fails,
// since `T` has no member `M`.
F(x5);
```

Note that in some cases of looking up a qualified name, lookup will not depend
on the value of the template parameter and can be checked before instantiation,
as in:

```carbon
interface A {
  fn F[me: Self]();
}

fn G[template T:! A](x: T) {
  // No question what this resolves to, can be checked
  // when `G` is defined:
  x.(A.F)();

  // Will generate a monomorphization error if
  // `T.F` means something different than `T.(A.F)`,
  // can only be checked when `G` is called:
  x.F();
}
```

### Transition from C++ templates to Carbon checked generics

We have a specific
[goal for generics](/docs/design/generics/goals.md#upgrade-path-from-templates)
that we have a smooth story for transitioning from C++ templates to Carbon
checked generics. Adding template generics to Carbon allows this to be done in
steps. These steps serve two purposes. One is to allow any updates needed for
callers and types used as parameters to be done incrementally. The second is to
avoid any silent changes in semantics that would occur from jumping directly to
Carbon checked generics. Each step will either preserve the meaning of the code
or result in compile failures.

#### To template Carbon with structural constraints

The first step is to convert the C++ function with one or more template
parameters to a Carbon function with template generic parameters. Any
[non-type template parameters](https://en.cppreference.com/w/cpp/language/template_parameters#Non-type_template_parameter)
can be converted to template generic parameters with the equivalent type, as in:

```
// This C++ function:
void F_CPlusPlus<int N>();

// gets converted to Carbon:
fn F_Carbon(template N:! i32);
```

Other template parameters can either be declared without constraints, using
`template T:! Type`, or using [structural constraints](#template-constraints).

To see if this transition can cause silent changes in meaning, consider how this
new Carbon function will be different from the old C++ one:

-   The conversion of the body of the code in the function could introduce
    differences, but only template concerns are in scope for this proposal.
-   The C++ code could use ad hoc API specialization. The only way to translate
    that to Carbon is through
    [explicit parameterization of the API](/docs/design/generics/details.md#specialization),
    which is not expected to introduce silent changes in meaning.
-   The C++ code could rely on [SFINAE](#terminology). C++ uses of
    `std::enable_if` should be translated to equivalent
    [template constraints](#template-constraints). Generally making substitution
    failure an error is expected to make less code compile, not introduce silent
    changes in meaning.
-   As long as the constraints on template type parameters are
    [structural](#template-constraints) and not interface constraints, the name
    lookup rules into those type parameters will consistently look in the type
    for both C++ and Carbon.

#### To interface constraints

FIXME: Explain story, even though already accepted in question-for-leads issue
[#949: Constrained template name lookup](https://github.com/carbon-language/carbon-lang/issues/949)
and implemented in proposal
[#989: Member access expressions](https://github.com/carbon-language/carbon-lang/pull/989).

FIXME: Step 1 is to define or identify the interfaces that will be required. Do
the existing types being used with this template already provide this
functionality by implementing an existing interface?

FIXME: Step 2: Two choices, for each interface to be required:

FIXME: A. implement interface for every type before changing from template
constraint to interface.

FIXME: B. Create templated impl of interface, providing an implementation of
interface for every type satisfying template constraint. Can then switch
function to use interface instead of template constraint. Individual
implementations of interface will take priority over blanket impl. Can remove
blanket impl once interface implemented for all types.

FIXME: Step 3: Callers will fail if type doesn't implement interface or there is
a name conflict between the type and interface.

FIXME: Can add qualifications to the body of the templated function to specify
which names should come from type and which from interfaces required by
constraints.

#### To checked generic

FIXME: Name lookup will stop looking at the type. Definition will compile as
long as all names can be found in constraints, which is the condition for this
change being safe.

FIXME: Qualifications may be removed. If they are needed, compiler will complain
about ambiguity in the definition of the function.

### Validity can depend on value

FIXME: A templated parameter may be used in ways where the validity of the
result depends on the value of the parameter, not just its type. Example:
whether two array types are compatible depends on whether they have the same
size. With a symbolic constant sizes, they will only be considered equal if the
compiler can show that the two sizes are equal always symbolicly. If the size is
a template parameter, the checking will be delayed until the value of the
template parameter is known.

### Branching on type identity

FIXME: Branching in code based on type identity, for example in a `match`
statement, which would effectively be an implementation of "typecase."

## Rationale

TODO: How does this proposal effectively advance Carbon's goals? Rather than
re-stating the full motivation, this should connect that motivation back to
Carbon's stated goals and principles. This may evolve during review. Use links
to appropriate sections of [`/docs/project/goals.md`](/docs/project/goals.md),
and/or to documents in [`/docs/project/principles`](/docs/project/principles).
For example:

-   [Community and culture](/docs/project/goals.md#community-and-culture)
-   [Language tools and ecosystem](/docs/project/goals.md#language-tools-and-ecosystem)
-   [Performance-critical software](/docs/project/goals.md#performance-critical-software)
-   [Software and language evolution](/docs/project/goals.md#software-and-language-evolution)
-   [Code that is easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write)
-   [Practical safety and testing mechanisms](/docs/project/goals.md#practical-safety-and-testing-mechanisms)
-   [Fast and scalable development](/docs/project/goals.md#fast-and-scalable-development)
-   [Modern OS platforms, hardware architectures, and environments](/docs/project/goals.md#modern-os-platforms-hardware-architectures-and-environments)
-   [Interoperability with and migration from existing C++ code](/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code)

## Alternatives considered

### Only checked generics

FIXME: Rust's approach

FIXME: Reasons are above

### SFINAE

FIXME: confusion about source of error

### Template API specialization

FIXME: See approach:
[specialization of parameterized types](/docs/design/generics/details.md#specialization)

FIXME: Incompatible with checked generics

### Value phase of bindings determined by initializer

FIXME: Types versus non-type values. Name lookup rules different for types.

FIXME: Link to open discussion notes

## Future work

### Expanded template constraints

FIXME: follow C++ concepts to see the range of kinds of constraints found to be
useful in practice:

-   https://en.cppreference.com/w/cpp/language/constraints
-   https://en.cppreference.com/w/cpp/language/requires
-   [Examples of named requirements for the C++ standard library](https://en.cppreference.com/w/cpp/named_req)

### Predicates: constraints on values

FIXME: See question-for-leads issue
[#2153: Generics calling templates](https://github.com/carbon-language/carbon-lang/issues/2153).

### Generics calling templates

FIXME: See question-for-leads issue
[#2153: Generics calling templates](https://github.com/carbon-language/carbon-lang/issues/2153).
