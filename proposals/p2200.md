# Basic templates

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/2200)

<!-- toc -->

## Table of contents

-   [Abstract](#abstract)
-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Details](#details)
    -   [Value phases](#value-phases)
    -   [Name lookup](#name-lookup)
    -   [Transition from C++ templates to Carbon checked generics](#transition-from-c-templates-to-carbon-checked-generics)
-   [Rationale](#rationale)
-   [Alternatives considered](#alternatives-considered)

<!-- tocstop -->

## Abstract

TODO: Describe, in a succinct paragraph, the gist of this document. This
paragraph should be reproduced verbatim in the PR summary.

## Problem

FIXME: Starting with
[#24: Generics goals](https://github.com/carbon-language/carbon-lang/pull/24),
templates have been \_\_, not an accepted part of the design. We now understand
enough about how they should fit into the language to decide that we are
including the feature in the language, and how.

FIXME: Use cases addressed:

-   FIXME: Transition for C++ templates
-   FIXME: Familiarity for C++ developers
-   FIXME: Gate for features we don't want to expose by default in checked
    generics for software engineering reasons since they pierce abstraction
    boundaries

    -   FIXME: Compile-time duck typing features that use the structural
        properties of types, like having a method with a particular name, rather
        than semantic properties like implementing an interface.
    -   FIXME: Branching in code based on type identity, for example in a
        `match` statement, which would effectively be an implementation of
        `typecase`

        > Thatte, Satish. (1994). Semantics of Type Classes Revisited.. 208-219.
        > 10.1145/182409.182459.

Out of scope for this proposal are any questions about passing a checked generic
argument value to a template parameter. See question-for-leads issue
[#2153: Generics calling templates](https://github.com/carbon-language/carbon-lang/issues/2153).

## Background

TODO: Is there any background that readers should consider to fully understand
this problem and your approach to solving it?

There have been a number of prior proposals and questions-for-leads issues on
templates on which this proposal builds:

-   Proposal
    [#24: Generics goals](https://github.com/carbon-language/carbon-lang/pull/24)
    talked about the reasons for templates, without committing Carbon to
    including them. These reasons include making it easier to transition C++
    template code to Carbon and providing functionality outside of what we want
    to support with checked generics.
-   Proposal
    [#447: Generics terminology](https://github.com/carbon-language/carbon-lang/pull/447)
    defined terminology. This included some of the differences between checked
    and template generics, and definitions for terms like _instantiation_.
-   Proposal
    [#553: Generic details part 1](https://github.com/carbon-language/carbon-lang/pull/553)
    defined `auto` as a template construct, and described how templates do not
    require constraints to find member names.
-   Question-for-leads issue
    [#565: Generic syntax to replace provisional `$`s](https://github.com/carbon-language/carbon-lang/issues/565)
    implemented in proposal
    [#676: `:!` generic syntax](https://github.com/carbon-language/carbon-lang/pull/676)
    defined the syntax for template bindings.
-   Proposal
    [#731: Generics details 2: adapters, associated types, parameterized interfaces](https://github.com/carbon-language/carbon-lang/pull/731)
    included that template values may be passed to generic parameters.
-   Proposal
    [#818: Constraints for generics](https://github.com/carbon-language/carbon-lang/pull/818)
    included `template constraint` to defined named constraints with fewer
    restrictions for use with template parameters.
-   Proposal
    [#875: Principle: information accumulation](https://github.com/carbon-language/carbon-lang/pull/875)
    considered how the principle benefited and was impacted by templates.
-   Question-for-leads issue
    [#949: Constrained template name lookup](https://github.com/carbon-language/carbon-lang/issues/949)
    implemented in proposal
    [#989: Member access expressions](https://github.com/carbon-language/carbon-lang/pull/989)
    defined how name lookup works for template parameters. It provided a path to
    incrementally adopt constraints on template parameters, a stepping stone to
    transitioning to checked generics.
-   Proposal
    [#950: Generics details 6: remove facets](https://github.com/carbon-language/carbon-lang/pull/950)
    included the impact on the semantics of templates in its rationale.
-   Proposal
    [#1146: Generic details 12: parameterized types](https://github.com/carbon-language/carbon-lang/pull/1146)
    allowed template type parameters.
-   Proposal
    [#1270: Update and expand README content and motivation for Carbon](https://github.com/carbon-language/carbon-lang/pull/1270)
    advertised that Carbon would support templates for "seamless C++ interop."
-   Terminology was updated in proposal
    [#2138: Checked and template generic terminology](https://github.com/carbon-language/carbon-lang/pull/2138).

TODO: Update if proposal
[#2188: Pattern matching syntax and semantics](https://github.com/carbon-language/carbon-lang/pull/2188)
is accepted first.

Terminology: FIXME

-   [Dependent names](/docs/design/generics/terminology.md#dependent-names)
-   [Instantiation](/docs/design/generics/terminology.md#instantiation)

## Proposal

FIXME Templates are officially a feature by Carbon.

FIXME Describe instantiation and monomorphization errors.

In many ways, template generic parameters work like checked generic parameters.
The following are true for any kind of generic parameter:

-   The value passed to a generic parameter must be able to be evaluated at
    compile time.
-   Generic parameters may have constraints that will be enforced by the
    compiler on the value supplied by the caller.
-   FIXME

The main differences between checked and templated generics are:

-   Type checking of any expression dependent on a templated parameter may not
    be completed until its value is known.
-   FIXME: Name lookup

FIXME: In contrast with C++ templates, no SFINAE. Specialization of a template
affects implementation, not API, unlike C++'s `vector<bool>` situation. No
current support for template-template parameters.

## Details

### Value phases

FIXME

### Name lookup

FIXME

Note that in some cases of looking up a qualified name, lookup will not depend
on the value of the template parameter and can be checked before instantiation,
as in:

```carbon
interface A {
  fn F[me: Self]();
}

fn G[template T:! A](x: T) {
  // No question what this resolves to.
  x.(A.F)();
  // Monomorphization error if `T.F` means something
  // different than `T.(A.F)`.
  x.F();
}
```

### Transition from C++ templates to Carbon checked generics

FIXME: Explain story, even though already accepted in uestion-for-leads issue
[#949: Constrained template name lookup](https://github.com/carbon-language/carbon-lang/issues/949)
and implemented in proposal
[#989: Member access expressions](https://github.com/carbon-language/carbon-lang/pull/989).

## Rationale

TODO: How does this proposal effectively advance Carbon's goals? Rather than
re-stating the full motivation, this should connect that motivation back to
Carbon's stated goals and principles. This may evolve during review. Use links
to appropriate sections of [`/docs/project/goals.md`](/docs/project/goals.md),
and/or to documents in [`/docs/project/principles`](/docs/project/principles).
For example:

-   [Community and culture](/docs/project/goals.md#community-and-culture)
-   [Language tools and ecosystem](/docs/project/goals.md#language-tools-and-ecosystem)
-   [Performance-critical software](/docs/project/goals.md#performance-critical-software)
-   [Software and language evolution](/docs/project/goals.md#software-and-language-evolution)
-   [Code that is easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write)
-   [Practical safety and testing mechanisms](/docs/project/goals.md#practical-safety-and-testing-mechanisms)
-   [Fast and scalable development](/docs/project/goals.md#fast-and-scalable-development)
-   [Modern OS platforms, hardware architectures, and environments](/docs/project/goals.md#modern-os-platforms-hardware-architectures-and-environments)
-   [Interoperability with and migration from existing C++ code](/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code)

## Alternatives considered

TODO: What alternative solutions have you considered?
