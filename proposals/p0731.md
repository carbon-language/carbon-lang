# Generics details 2: adapters, associated types, parameterized interfaces

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/731)

<!-- toc -->

## Table of contents

-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Details](#details)
-   [Rationale based on Carbon's goals](#rationale-based-on-carbons-goals)
-   [Alternatives considered](#alternatives-considered)
    -   [Syntax for associated constants](#syntax-for-associated-constants)
    -   [Value patterns](#value-patterns)
    -   [Deduced interface parameters](#deduced-interface-parameters)
        -   [Rationale for the rejection](#rationale-for-the-rejection)
            -   [Impl lookup rules with deducible interface parameters](#impl-lookup-rules-with-deducible-interface-parameters)
    -   [Others](#others)

<!-- tocstop -->

## Problem

We want to Carbon to have a high quality generics feature that achieves the
goals set out in [#24](https://github.com/carbon-language/carbon-lang/pull/24).
This is too big to land in a single proposal. This proposal continues
[#553](https://github.com/carbon-language/carbon-lang/pull/553) defining the
details of:

-   adapters
-   associated types and other constants
-   parameterized interfaces

## Background

This is a follow on to these previous generics proposals:

-   [#24: Generics goals](https://github.com/carbon-language/carbon-lang/pull/24)
-   [#447: Generics terminology](https://github.com/carbon-language/carbon-lang/pull/447)
-   [#524: Generics overview](https://github.com/carbon-language/carbon-lang/pull/524)
-   [#553: Generics details part 1](https://github.com/carbon-language/carbon-lang/pull/553)

The content for this proposal was extracted from a larger
[Generics combined draft proposal](https://github.com/carbon-language/carbon-lang/pull/36).

## Proposal

This is a proposal to add multiple sections to
[this design document on generics details](/docs/design/generics/details.md).

## Details

TODO: Fully explain the details of the proposed solution.

## Rationale based on Carbon's goals

TODO: How does this proposal effectively advance Carbon's goals? Rather than
re-stating the full motivation, this should connect that motivation back to
Carbon's stated goals for the project or language. This may evolve during
review.

## Alternatives considered

### Syntax for associated constants

Associated constants use `let` with `:!` to express that these are compile-time
values, matching the use in classes described in [#772](p0722.md#let-constants).

### Value patterns

We considered an alternative to the `type_of` approach from
[the parameterized interfaces section](/docs/design/generics/details.md#parameterized-interfaces)
for binding `T` to a type mentioned later in the parameter list. We could
instead allow functions to have value patterns without a `:`, as in:

```
fn PeekAtTopOfStackParameterized
    [T:! Type, StackType:! StackParameterized(T)]
    (s: StackType*, T) -> T { ... }
```

However, we don't want to allow value patterns more generally so we can reject
declarations like `fn F(Int)` when users almost certainly meant `fn F(i: Int)`.

### Deduced interface parameters

The Carbon team considered and then rejected the idea that we would have two
kinds of interface parameters. "Multi" parameters would work as described in the
[detailed design document](/docs/design/generics/details.md#parameterized-interfaces).
"Deducible" type parameters would only allow one implementation of an interface,
not one per interface & type parameter combination. These deducible type
parameters could be inferred like
[associated types](/docs/design/generics/details.md#associated-types) are. For
example, we could make a `Stack` interface that took a deducible `ElementType`
parameter. You would only be able to implement that interface once for a type,
which would allow you to infer the `ElementType` parameter like so:

```
fn PeekAtTopOfStack[ElementType:$ Type, StackType:$ Stack(ElementType)]
    (s: StackType*) -> ElementType { ... }
```

This can result in more concise code for interfaces where you generally need to
talk about some parameter anytime you use that interface. For example,
`NTuple(N, type)` is much shorter without having to specify names with the
arguments.

#### Rationale for the rejection

-   Having only one type of parameter simplifies the language.
-   Multi parameters express something we need, while deducible parameters can
    always be changed to associated types.
-   One implementation per interface & type parameter combination is more
    consistent with other parameterized constructs in Carbon. For example,
    parameterized types `Foo(A)` and `Foo(B)` are distinct, unconnected types.
-   It would be hard to give clear guidance on when to use associated types
    versus deducible type parameters, since which is best for a particular use
    is more of a subtle judgement call.
-   Deducible parameters in structural interfaces require additional rules to
    ensure they can be deduced unambiguously.

In addition, deducible interface parameters would complicate the lookup rules
for impls.

##### Impl lookup rules with deducible interface parameters

Interface implementation is Carbon's only language construct that allows open
extension, and this sort of open extension is needed to address the "expression
problem" in programming language design. However, we need to limit which
libraries can implement an interface for a type so we can be guaranteed to see
the implementation when we try and use it.

So the question becomes: can we allow an implementation of a parameterized
interface `I(T)` for a type `A` to be in the same library as `T`, or can it only
be provided with `I` or `A`? The answer is "yes" if `T` is "multi" and "no" if
`T` is deducible.

The problem with defining the implementation with a deducible `T` is that it
would allow users to violate
[coherence](/docs/design/generics/goals.md#coherence). Consider this collection
of libraries, where there are implementations for an interface `I(T)` for a type
`A`, and those implementations are in the libraries defining the type parameter:

```
package X library "I and A" api;

interface I(Type:$ T) { ... }

struct A { ... }
```

```
package Y library "T1" api;

import X library "I and A";

struct T1 { ... }

// Type `X.A` has an implementation for `X.I(T)` for `T == Y.T1`.
impl X.I(T1) for X.A { ... }
```

```
package Z library "T2" api;

import X library "I and A";

struct T2 { ... }

// Type `X.A` has an implementation for `X.I(T)` for `T == Z.T2`.
impl X.I(T2) for X.A { ... }
```

```
package Main api;

import X library "I and A";
// Consider what happens if we include different combinations
// of the following two statements:
// import Y library "T1";
// import Z library "T2";

// Function `F` is called with value `a` with type `U`,
// where `U` implements interface `X.I(T)` for some type `T`.
fn F[Type:$ T, X.I(T):$ U](U:$ a) { ... }

fn Main() {
  var X.A: a = X.A.Init();
  F(a);
}
```

(In the example, each library is in a different package, but the packages are
not the important part here.)

The `F(a)` call triggers a lookup for implementations of the interface `X.I(T)`
for some `T`. There exists such implementations in both libraries `Y.T1` and
`Z.T2` for different values of `T`. This has a number of sad consequences:

-   "Import what you use" is hard to measure: libraries `Y.T1` and `Z.T2` are
    important and used even though `Y` and `Z` are not mentioned outside the
    `import` statement.
-   The call `F(a)` has different interpretations depending on what libraries
    are imported:
    -   If neither is imported, it is an error.
    -   If both are imported, it is ambiguous.
    -   If only one is imported, you get totally different code executed
        depending on which it is.
-   We have no way of enforcing a "one implementation per interface" rule that
    would prevent the call to `F` from being ambiguous.

Basically, there is nothing guaranteeing that we import libraries defining the
types that are used as interface parameters if we allow the interface parameters
to be deduced.

### Others

Other alternatives considered will be in a future proposal. Some of them can be
seen in a rough form in
[#36](https://github.com/carbon-language/carbon-lang/pull/36).
