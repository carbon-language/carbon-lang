# Generic details 13: Dynamic wrapper types

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/1149)

<!-- toc -->

## Table of contents

-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Details](#details)
-   [Rationale based on Carbon's goals](#rationale-based-on-carbons-goals)
-   [Alternatives considered](#alternatives-considered)
    -   [Not marking object-safe interfaces](#not-marking-object-safe-interfaces)
    -   [Filtering out non-object safe methods](#filtering-out-non-object-safe-methods)
    -   [More primitive building block](#more-primitive-building-block)
    -   [Generic functions opt-in to allowing dynamic types](#generic-functions-opt-in-to-allowing-dynamic-types)

<!-- tocstop -->

## Problem

TODO: What problem are you trying to solve? How important is that problem? Who
is impacted by it?

## Background

TODO: Is there any background that readers should consider to fully understand
this problem and your approach to solving it?

## Proposal

TODO: Briefly and at a high level, how do you propose to solve the problem? Why
will that in fact solve it?

## Details

TODO: Fully explain the details of the proposed solution.

## Rationale based on Carbon's goals

TODO: How does this proposal effectively advance Carbon's goals? Rather than
re-stating the full motivation, this should connect that motivation back to
Carbon's stated goals for the project or language. This may evolve during
review. Use links to appropriate goals, for example:

-   [Community and culture](/docs/project/goals.md#community-and-culture)
-   [Language tools and ecosystem](/docs/project/goals.md#language-tools-and-ecosystem)
-   [Performance-critical software](/docs/project/goals.md#performance-critical-software)
-   [Software and language evolution](/docs/project/goals.md#software-and-language-evolution)
-   [Code that is easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write)
-   [Practical safety and testing mechanisms](/docs/project/goals.md#practical-safety-and-testing-mechanisms)
-   [Fast and scalable development](/docs/project/goals.md#fast-and-scalable-development)
-   [Modern OS platforms, hardware architectures, and environments](/docs/project/goals.md#modern-os-platforms-hardware-architectures-and-environments)
-   [Interoperability with and migration from existing C++ code](/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code)

## Alternatives considered

### Not marking object-safe interfaces

By marking interfaces that are intended to be used as the constraint on a
dynamic type, we give information about how that interface may be evolved. It
also allows the compiler to diagnose when an interface does not meet the
object-safe requirements when it is declared rather than when it is used.

A downside of this approach is that there may be interfaces that satisfy the
object-safe restriction, that types already implement, and that developers want
to use as the argument to `DynPtr` but can't. Another downside is that
interfaces that are marked object-safe is not sufficient, there are additional
requirements about associated constants that must be satisfied.

FIXME

### Filtering out non-object safe methods

FIXME: surprising

FIXME: can't diagnose problems until late

FIXME: workaround is to split interface into an object-safe subset and the
complete interface that extends the former

FIXME: dynamic object using the object-safe version of an interface does not
satisfy the full interface

TODO: What alternative solutions have you considered?

### More primitive building block

A more primitive building block would allow users to create their own types like
`DynPtr(C)`. For example, something that had a pointer to two value or even an
array of values of the same type. Our idea for a primitive was that a class
could have a type member as a `let`, as in:

```
class TwoThings {
  // Note the `let` here.
  let T:! Copyable;
  // These must be pointers so `TwoThings` has fixed size.
  var a: T*;
  var b: T*;
}
```

There would be some restrictions for type safety.

```
fn F(x: TwoThings) {
  // Allowed: since `x` is a `let, can be sure that
  // `x.T` is the same at different times.
  *x.a = *x.b;
  var m: i32 = 0;
  var n: i32 = 0;
  // Allowed: deduces value of `y.T` as `i32`.
  var y: TwoThings = {.a = &m, .b = &n};
  // Error: can't specify the value of `T`.
  var z: TwoThings = {.T = i32, .a = &m, .b = &n};
  // Allowed: assignment of whole object with `let`,
  // might modify `y.T`.
  y = x;
  // Error: can't modify `let`.
  y.T = bool;
  // Error: since `y` is a `var`, can't be sure
  // that `y.T` is the same at different times.
  *y.a = *y.b;
}
```

The idea is that type-checking will look through `let`s but not `var`s in
general. `x` here is a `let`, as is `x.T`, so we can determine that the types of
`*x.a` and `*x.b` are the same. If `x` were a `var` like `y`, then we couldn't,
because we couldn't be sure that the value of `.T` doesn't change, for example
by assignment.

The problem with explicitly specifying the type `z.T` is that it means that
checking the assignment or initialization requires looking at the _value_ of
part of the right-hand-side struct literal, not only at its type. This will
interact badly with using an interface to model implicit conversion. So we would
require it to be deduced rather than specified.

We decided this didn't need to be in this proposal, but that we would consider
it in the future:

-   Rust gets by with `&dyn trait` and `Box<dyn trait>`, which argues that those
    cover most use cases.
-   Even with this more primitive building block, there will likely still be
    significant machinery needed around constraint parameter to build `DynPtr`
    and friends out of it.
-   Even if we do add the primitive, we would still keep `DynPtr` and friends in
    the standard library, and expect to use those library types the vast
    majority of the time.

We concluded `DynPtr` and friends would be enough for now, and we could revisit
this decision once we knew more.

This was
[discussed on 2022-03-31](https://docs.google.com/document/d/1cRrhRrmaUf2hVi2lFcHsYo2j0jI6t9RGZoYjWhRxp14/edit?resourcekey=0-xWHBEZ8zIqnJiB4yfBSLfA#heading=h.i0skbgnq4hnj).

### Generic functions opt-in to allowing dynamic types

Instead of providing `DynValue(C)`, which allows any generic function with an
object-safe constraint to be used with dynamic dispatch, we could have the
generic function opt in to allowing dynamic dispatch. The function author would
write the type parameter like `T:! MaybeDyn(C)` instead of `T:! C`, and
`DynBox(C)` would implement `MaybeDyn(C)`.

However, such constraints could only ever be best-effort since the caller of the
function could always write their own type-erased wrapper type. Furthermore, the
performance overhead of using `DynValue(C)` would generally be within a constant
factor of static dispatch. For these reasons, we
[decided](https://discord.com/channels/655572317891461132/941071822756143115/959583656471572530)
to provide `DynValue(C)`.
