# Code and name organization

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/107)

## Table of contents

<!-- toc -->

-   [Problem](#problem)
-   [Proposal](#proposal)
    -   [Out-of-scope issues](#out-of-scope-issues)
-   [Open questions for the decision](#open-questions-for-the-decision)
    -   [Should we remove one of the `namespace` keywords?](#should-we-remove-one-of-the-namespace-keywords)
    -   [Should we use the package name or the `package` keyword to refer to the current package?](#should-we-use-the-package-name-or-the-package-keyword-to-refer-to-the-current-package)
-   [Justification](#justification)

<!-- tocstop -->

## Problem

How do developers store code for the compiler, and access it for reuse?

## Proposal

Adopt an approach with tiered files, libraries, packages and namespaces in the
design.

### Out-of-scope issues

Related issues that are out-of-scope for this proposal are:

-   Access control: while there is some implicit access control from interface
    vs implementation considerations for libraries, they are more about
    addressing circular dependencies in code.

-   Aliasing implementation: while the `alias` keyword is critical to how easy
    or difficult refactoring is, it should be designed on its own.

-   Compilation details: this proposal sets up a framework that should enable
    well-designed compilation, but does not set about to design how compilation
    will work.

-   Entity names duplicating package names: Whether
    [`DateTime.DateTime`](https://docs.python.org/3/library/datetime.html) is
    allowed is not being addressed here. Name lookup is likely to address this
    better, including offering syntax that could refer to it if needed.

-   File-private identifiers: Something similar to C++ `static` functions may
    exist. However, that will be addressed separately.

-   Package management: while we want to choose syntax that won't impose
    barriers on building package management into Carbon, we should not make
    assumptions about how package management should work.

-   Prelude package, or fundamentals: while we've discussed how to handle name
    lookup for things like `Int32`, this proposal mainly lays out a framework
    where options for addressing that are possible.

This proposal should not be interpreted as addressing these issues. A separate
discussion of these issues will remain necessary.

## Open questions for the decision

Extended open question comparisons may be found in
[this doc](https://docs.google.com/document/d/1J8GX9uw5AxBz5Q22MLHJOfzLq4WJqKL-q1VwnKGHG-k/edit#)
in addition to the `code_and_organization.md` alternatives section.

### Should we remove one of the `namespace` keywords?

Right now, the `namespace` keyword can be used in two places:

-   On the `package` keyword
    ([alternative to remove](/docs/design/code_and_name_organization.md#remove-the-namespace-keyword-from-package-and-import))
-   On its own
    ([alternative to remove](/docs/design/code_and_name_organization.md#coarser-namespace-granularity))

Does the core team agree with the approach to `namespace` keywords? If not,
which approach is preferred?

### Should we use the package name or the `package` keyword to refer to the current package?

Given the code sample:

```carbon
package Math library("Stats") api;
api struct Stats { ... }
struct Quantiles {
  fn Stats();
  fn Build() {
    ...
    var SYNTAX.Stats: b;
    ...
  }
}
```

Is the `SYNTAX`:

-   `Math`, as in `Math.Stats`?
-   `package`, as in `package.Stats`?
-   Some other solution?

This is detailed in the
[referring to the package as `package`](/docs/design/code_and_name_organization.md#referring-to-the-package-as-package)
alternative.

Does the core team agree with the approach to self-referential names? If not,
does the alternative capture what the core team wants to be turned into the
proposal, or is some other approach preferred?

### Should we switch to a library-oriented structure that's package-agnostic?

Right now, the `package` syntax is very package-oriented. We could instead
eliminate package semantics from code and organization, relying only on
libraries and removing the link to distribution. This is the
[collapse the package concept into libraries](/docs/design/code_and_name_organization.md#collapse-the-package-concept-into-libraries)
alternative.

Does the core team agree with the approach to packages and libraries? If not,
does the alternative capture what the core team wants to be turned into the
proposal, or is some other approach preferred?

## Justification

-   [Software and language evolution](/docs/project/goals.md#software-and-language-evolution):

    -   The syntax and interactions between `package` and `import` should enable
        moving code between files and libraries with fewer modifications to
        callers, easing maintenance of large codebases.

        -   In C++ terms, `#include` updates are avoidable when moving code
            around.

-   [Code that is easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write):

    -   By setting up imports so that each name in a file is unique, we make the
        meaning of symbols clear and easier to understand.

    -   The proposed `namespace` syntax additionally makes it clear when the
        file's default namespace is not being used.

        -   This is in contrast to C++ namespaces, where the entire body of code
            above the line of code in question may be used to start a namespace.

        -   Although the file-level namespace provides some contextual scoping,
            it is at a static location in the file as the first line of code,
            and is easily checked as such.

    -   Clearly marking interfaces will make it easier for both client code and
        IDE tab completion to more easily determine which APIs can be used from
        a given library.

-   [Fast and scalable development](/docs/projects/goals.md#fast-and-scalable-development):

    -   The structure of libraries and imports should help enable separate
        compilation.

-   [Interoperability with and migration from existing C++ code](/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code):

    -   The syntax of `import` should enable extending imports for use in
        interop code.
