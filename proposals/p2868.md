# Allow overlap with a `final impl` if identical

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/2868)

<!-- toc -->

## Table of contents

-   [Abstract](#abstract)
-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Details](#details)
-   [Rationale](#rationale)
-   [Alternatives considered](#alternatives-considered)
    -   [Allow interfaces with member functions to compare equal](#allow-interfaces-with-member-functions-to-compare-equal)

<!-- tocstop -->

## Abstract

Allow an `impl` to overlap with a `final impl` if they agree on the overlap.
Agreement is defined as all values comparing equal, and functions never
comparing equal.

## Problem

TODO: What problem are you trying to solve? How important is that problem? Who
is impacted by it?

## Background

TODO: Is there any background that readers should consider to fully understand
this problem and your approach to solving it?

[#1077: find a way to permit impls of CommonTypeWith where the LHS and RHS type overlap](https://github.com/carbon-language/carbon-lang/issues/1077)

## Proposal

TODO: Briefly and at a high level, how do you propose to solve the problem? Why
will that in fact solve it?

## Details

TODO: Fully explain the details of the proposed solution.

## Rationale

This proposal is intentionally keeping the language small by making a simple
rule that addresses the only identified use case and nothing more. This benefits

-   [Language tools and ecosystem](/docs/project/goals.md#language-tools-and-ecosystem)
-   [Code that is easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write)

by relying on Carbon's commitment to
[software and language evolution](/docs/project/goals.md#software-and-language-evolution)
to update our approach as needed, rather then trying to proactively address
concerns ahead of time.

## Alternatives considered

### Allow interfaces with member functions to compare equal

There are some specific cases where the compiler can verify that two functions
are the same without having to compare their definitions. For example, two
implementations that don't implement a function and instead inherit the default
from the interface could be considered equal. This creates an evolution hazard,
though, that copying the definition from the interface into the implementation
means that the interface could now compare not equal without any change in
behavior. For now, the simple rule that we don't compare functions at all is
sufficient for our identified use cases. This is something we would reconsider
given new use cases.
