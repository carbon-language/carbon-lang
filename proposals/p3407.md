# Clarify name bindings in namespaces.

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/3407)

<!-- toc -->

## Table of contents

-   [Abstract](#abstract)
-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Rationale](#rationale)
-   [Alternatives considered](#alternatives-considered)
    -   [Allow prefixing a tuple binding pattern with a namespace](#allow-prefixing-a-tuple-binding-pattern-with-a-namespace)
    -   [Allow mixing namespaces within a binding pattern](#allow-mixing-namespaces-within-a-binding-pattern)
    -   [Disallow declaring namespaces other than the file scope](#disallow-declaring-namespaces-other-than-the-file-scope)

<!-- tocstop -->

## Abstract

-   Require namespace members be declared in the same name scope as the
    namespace is declared.
-   Allow binding patterns to directly declare names in namespaces.
-   Disallow using different namespaces in the same binding pattern.

## Problem

While the trivial case of `var NS.a` seems to be supported as a consequence of
proposal
[#107: Code and name organization](https://github.com/carbon-language/carbon-lang/pull/107),
there are a couple syntactic options when binding multiple names.

Also, there's no clear decision around code such as:

```
namespace NS;
class ClassT {
  // Is this a class member accessed through `NS`, or a file scope member inside
  // `NS`? What is its lifetime?
  var NS.a = 0;
}
```

This proposal mainly aims to remove these ambiguities.

## Background

Namespaces are covered in
[code and name organization](/docs/design/code_and_name_organization/#namespaces).
Binding patterns are covered in
[pattern matching](/docs/design/pattern_matching.md#binding-patterns).

There's some discussion of `var` in
[values, variables, and pointers](/docs/design/values.md), but it's specific to
locals. That doesn't address other use cases, such as globals or member
variables.

## Proposal

When used to declare names in binding patterns, as in `var` or `let`, all names
must be in the same namespace. Declaring members of a namespace inside of an
unrelated scope is invalid.

See the changes to
[code and name organization](/docs/design/code_and_name_organization/#namespaces)
for reference.

## Rationale

-   [Performance-critical software](/docs/project/goals.md#performance-critical-software)

    -   Only allowing binding patterns to declare variables in the same
        namespace allows for a guarantee that the memory can be sequentially
        allocated. This allows for copy elision on initializers with function
        calls.

-   [Code that is easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write)

    -   Requiring that declarations of multiple names use `NS.a` syntax is
        consistent with the single variable case.
    -   Requiring namespace members be declared while in the same name scope as
        the namespace itself makes lifetimes clearer.

## Alternatives considered

### Allow prefixing a tuple binding pattern with a namespace

We could use the namespace to prefix the binding tuple. For example:

```carbon
var NS.(a: i32, b: i32) = (3, 4);
```

It's rare that we would have a single statement declare multiple names. As a
consequence, the separation of the namespace qualifier from the declared
identifier might end up unique to this syntax. In that context, we prefer `NS.a`
for consistency with other cases, such as `class NS.class`.

### Allow mixing namespaces within a binding pattern

We could allow mixing namespaces in a binding pattern. For example:

```carbon
var (e: i32, NS.f: i32) = (5, 6);
var (FirstNS.g: i32, SecondNS.h: i32) = (7, 8);
```

That would offer the possibility of mixing use inside scopes:

```carbon
namespace NS;

class ClassT {
  var (static class_member: i32,
       NS.namespace_member: i32,
       package.package_member: i32) = InitData();
}
```

Note here that static syntax for class members is not defined: I'm assuming for
argument's sake that we expect something similar, but this could also be:

```
  let (class_member: i32,
       var NS.namespace_member: i32,
       var package.package_member: i32) = InitData();
```

It's not obvious how memory for the above should be allocated. There are two
options:

-   The three values are sequentially allocated, even though they belong to
    different name scopes. This allows for return value optimizations to work,
    but may cause issues for how we consider name scopes and lifetimes.
-   The three values are separately allocated, grouping allocations by name
    scope. This breaks return value optimizations, but simplifies requirements
    around name scopes and lifetimes.

Both options have issues; it would likely prove difficult to set this up such
that return value optimizations would consistently work, across all potential
uses of this syntax. That would introduce some variability in performance based
on unclear context, something we would like to avoid.

Without mixing namespaces, static initialization case can still be addressed,
albeit with more work. For example:

```carbon
namespace NS;

let init_data: auto = InitData();

class ClassT {
  var static class_member: i32 = init_data[0];
}

var NS.namespace_member: i32 = init_data[1];
var package_member: i32 = init_data[2];
```

Rather than forcing a choice, this alternative is discarded in order to require
syntax -- and resulting performance -- be clearer.

### Disallow declaring namespaces other than the file scope

We could disallow declaring namespaces in scopes other than the file scope.
Combined with requiring members of namespaces to only be declared at the file
scope, this would prevent their use in other contexts.

This would be consistent with C++. However, we believe the current design
doesn't actively interfere with Carbon, and it could prove useful in some
situations. For example, perhaps a complex class would find a member namespace
useful:

```
class Complex {
   namespace OptionSet1;
   class OptionSet1.MemberClassA;
   class OptionSet1.MemberClassB;

   namespace OptionSet2;
   class OptionSet2.MemberClassC;
   class OptionSet2.MemberClassD;
}
```

This would be easy to work around if disallowed (for example, combine names for
`OptionSet1MemberClassA`). This is both good and bad; disallowing it would be
cheap, but it may mask friction from not providing the feature.

Although we're not sure how useful this will prove to be, we will allow the
syntax and may reevaluate in the future.
