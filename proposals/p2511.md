# Assignment statements

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/2511)

<!-- toc -->

## Table of contents

-   [Abstract](#abstract)
-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Details](#details)
-   [Rationale](#rationale)
-   [Alternatives considered](#alternatives-considered)
    -   [Allow assignment as a subexpression](#allow-assignment-as-a-subexpression)
    -   [Allow chained assignment](#allow-chained-assignment)
    -   [Do not provide increment and decrement](#do-not-provide-increment-and-decrement)
    -   [Define `$=` in terms of `$`](#define--in-terms-of-)
    -   [Do not allow overloading the behavior of `=`](#do-not-allow-overloading-the-behavior-of-)

<!-- tocstop -->

## Abstract

Assignment is permitted only as a complete statement, not as a subexpression.
Assignment and compound assignment syntax follow C++ in all other respects.
Pre-increment is provided. Post-increment is not. Uses of all of these operators
are translated into calls to interface members.

## Problem

Assignment is a cornerstone of imperative programming. Carbon does not currently
have an approved proposal describing the syntax and interpretation of
assignment.

## Background

In C-family languages, there are three kinds of assignment-like operators:

-   Simple assignment: `variable = value`
-   Compound assignment: `variable $= value`, for some binary operators `$`,
    meaning `variable = variable $ value`, except that `variable` is evaluated
    only once.
-   Increment and decrement: `++variable` and `--variable` meaning
    `variable += 1` and `variable -= 1`, and `variable++` and `variable--`
    acting similarly but returning the prior value of `variable`.

These operators behave mostly like other binary operators, and in particular the
above expression forms can be used as subexpressions of other expressions.

Chained assignment is supported, and associates from right to left: `a = b = 1`
assigns `1` to `b`, then assigns the result of that assignment to `a`. In C++,
that result is typically an lvalue referring to `b`, but in C, it is an rvalue
containing the result of converting `1` to the type of `b`. Note that all other
operators in C and C++ associate in the other direction.

These operators have a collection of known issues, including:

-   Confusion between assignment and comparison, for example in constructs such
    as `if (variable = 3) { ... }`. This is sufficiently rife that a de facto
    compiler-warning-enforced convention has arisen of using additional
    parentheses for the rare cases when assignment is intended:
    `if ((variable = 3))`.
-   Risk of unsequenced modification and access to the same variable, resulting
    in undefined behavior. For example, `n = a + n++;` has undefined behavior in
    C and C++ for this reason, because the act of incrementing `n` is not
    sequenced with respect to the rest of the computation, including the
    assignment.
-   In C++, post-increment can be a performance trap, because it is expected to
    return the old value of the variable, which might otherwise not be
    preserved. The additional copying may be optimized away if the `operator++`
    can be inlined, at the cost of additional work for the compiler.
-   In C++, overloading an operator `$` does not automatically provide a
    matching `$=`, resulting in additional work or incomplete operator sets.

## Proposal

C-family assignment operators are provided as statements:

-   `variable = value;` is a simple assignment statement.
-   `variable $= value;` is a compound assignment for each binary operator `$`,
    other than comparisons. `<=` and `>=` mean "less than or equal to" and
    "greater than or equal to", not "compare and assign".
-   `++variable;` and `--variable;` are supported as increment and decrement
    syntax. Because these are statements, there is no distinction between pre-
    and post-increment, and post-increment is not provided.

These operations are translated into calls on interfaces.

## Details

See the changes to the design.

This proposal does not define the semantics of assignment that are provided for
classes by default. Leads issue
[#686](https://github.com/carbon-language/carbon-lang/issues/686) gives some
rules, but those rules are not part of this proposal.

## Rationale

-   [Language tools and ecosystem](/docs/project/goals.md#language-tools-and-ecosystem)
    -   The values of variables can only change if either the address is taken,
        including implicitly by `addr` self parameters, or at assignment
        statements, making it easier to reason about where the value of a
        variable can change in the control flow of a function.
-   [Software and language evolution](/docs/project/goals.md#software-and-language-evolution)
    -   This approach is conservative and can evolve to support assignment as a
        subexpression.
-   [Code that is easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write)
    -   Assignments in subexpressions tend to be hard for humans to read and
        understand. Disallowing them at the language level avoids the potential
        for confusion, making code easier to read at the cost of making certain
        constructs such as `n = arr[i++];` a little harder to write.
    -   Easier to write a complete operator set because both `$` and `$=` can be
        provided by implementing a single interface.
-   [Practical safety and testing mechanisms](/docs/project/goals.md#practical-safety-and-testing-mechanisms)
    -   Replaces correctness warning on `if (a = b)` with a language rule.
-   [Interoperability with and migration from existing C++ code](/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code)
    -   Providing largely the same set of symbols makes migration easier.
    -   Some cost may be imposed by forcing a translation from assignment in
        subexpressions to assignment as separate statements.

## Alternatives considered

### Allow assignment as a subexpression

We could allow some or all forms of assignment as subexpressions, either with
the same syntax or with some other syntax. For now, we are choosing to not
pursue these options in order to gather data around how important they are. If
we wish to allow assignment as a subexpression, we should consider adopting
something like Python's "walrus operator" `variable := value` instead of using
an `=` symbol.

If we allow a three-term form of `for` statements, `for (init; cond; incr)`, we
could allow assignment in the `incr` term. However, we currently do not support
this syntax.

### Allow chained assignment

As a special case of assignment as a subexpression, we could allow chained
assignment:

```
a = b = c = 0;
```

We could restrict this to only apply to simple assignment, not cases like
`a += b -= c *= 2;`

In leads issue [#451](https://github.com/carbon-language/carbon-lang/issues/451)
it was decided that we would initially not support chained assignment.

### Do not provide increment and decrement

We could remove `++var;` and `--var;` in favor of `var += 1;` and `var -= 1;`.
However, developers coming from C-family languages will expect these operators
to exist, and they may more directly convey the intended semantics of counting
than a `+=` operation would.

### Define `$=` in terms of `$`

Instead of defining `$` in terms of `$=`, we could define `$=` in terms of `$`
and `=`. We choose not to do this because our experience from C++ is that `$=`
can frequently be implemented more efficiently than `$`, by operating in-place
and reusing allocated storage from the left-hand operand.

However, the details of parameter passing and lifetimes in the Carbon object
model have not been fully developed at this point, and it may be the case that
implementing `$=` in terms of `$` and `=` doesn't impose a penalty. If that is
the case, then this decision should be revisited.

### Do not allow overloading the behavior of `=`

We could define that an `=` expression always carries out these steps:

-   Initialize a value of the left-hand operand's type from the right-hand
    operand.
-   Destroy the left-hand operand.
-   Move the value created earlier into the left-hand operand.

However, this removes some flexibility and could harm performance, for example
in the case where the left-hand operand has a buffer that it could reuse to
store its new value.
