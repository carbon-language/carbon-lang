# Unqualified names

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/855)

<!-- toc -->

## Table of contents

-   [Problem](#problem)
-   [Background](#background)
    -   [Qualified versus unqualified names](#qualified-versus-unqualified-names)
    -   [Lexical name lookup](#lexical-name-lookup)
    -   [Forward references](#forward-references)
    -   [C++ unqualified name lookup](#c-unqualified-name-lookup)
    -   [Name shadowing](#name-shadowing)
    -   [Name spaces and name filtering](#name-spaces-and-name-filtering)
    -   [Name hiding](#name-hiding)
    -   [Argument-dependent name lookup](#argument-dependent-name-lookup)
-   [Proposal](#proposal)
-   [Details](#details)
-   [Rationale based on Carbon's goals](#rationale-based-on-carbons-goals)
-   [Alternatives considered](#alternatives-considered)

<!-- tocstop -->

## Problem

When an unqualified name appears in a Carbon source file, we need to know what
it means.

## Background

### Qualified versus unqualified names

We expect two forms of name to appear in Carbon source files:

-   An _unqualified name_ is a name that is looked up in an ambient lookup
    environment. In our current skeleton design, this includes all names not
    preceded by a `.` token.
-   A _qualified name_ is a name that is looked up in some explicitly specified
    context. In our current skeleton design, this includes all names preceded by
    a `.` token.

Note that struct literal syntax, `{.a = 3, .b = 5}`, uses a bare designator of
the form `.name` with no preceding type. We consider this to be a qualified
name, even though the context in which the entity is named is determined
implicitly.

This proposal is concerned only with the behavior of unqualified names. The
behavior of qualified name lookup will in general depend on the context in which
the name is qualified: `Namespace.Foo` will look for a namespace member,
`Class.Foo` will look for a class member, `instance.Foo` will look for a member
in the type of `instance` or perhaps in its type-of-type, and so on.

### Lexical name lookup

The mechanism used for unqualified name lookup in most modern programming
languages is based on lexical scopes, and operates as follows:

-   A scope is a contiguous region of the program.
-   Certain language constructs define a new scope. For example, scopes may be
    introduced by braces `{...}`, or by certain language constructs.
-   Scopes nest lexically -- one scope is inside another scope if its syntax is
    nested within the syntax of that scope.
-   Names are introduced by certain kinds of declarations, such as variable and
    function declarations, and become visible in whatever scope they are
    introduced within.
-   Name lookup for an unqualified name searches from the current scope to
    lexically-enclosing scopes, in order, and stops when a scope is discovered
    in which the name was introduced.

### Forward references

Unqualified lookup in some programming languages will find names declared after
the point of lookup. Others will only find names declared prior to the point of
use.

In C, lookup only finds names with prior declarations, with the exception of
`goto` labels, which are found even if they're declared later in the same
function.

The choice to only find prior declarations is motivated, in part, by a simple
and efficient lexical name lookup algorithm: a single mapping from name to the
current declaration of that name, called an _environment_, is maintained. A
declaration updates the map by setting itself as the current declaration of its
name. When a scope is exited, the environment is restored to its state prior to
entering the scope. Resolving the meaning of a reference to a name then requires
only a single map lookup. Variants of this environment-based lexical name lookup
mechanism are common in formalisms of programming languages.

In Java, lookup considers all names declared in a class scope, but only
considers names declared earlier in a function scope. For example:

```
public class App {
  public static void main(String[] args) {
    // OK, names `App.n`. Does not consider later-declared local variable.
    int m = n;
    int n;
  }
  private static int n;
}
```

In C#, lookup always considers all names declared in a scope, even in function
scope, but it's an error to use a local variable before it's declared. For
example:

```
public class App
{
  public static void Main()
  {
    // Error, `n` is not declared yet. Does not refer to `App.n`.
    int m = n;
    int n;
  }
  static int n;
}
```

In Python, lookup considers all names declared in a function scope, but only
considers earlier-declared names in a class scope. Note that Python considers
local variables to be declared if they are assigned to. For example:

```
def f():
  # Error, local variable 'x' referenced before assignment
  m = n
  n = 0
n = 1

# But ...
class X(object):
  # OK, refers to global n
  m = n
  n = 0
```

In Rust, lookup in a function-local scope only considers names declared earlier;
lookup in other scopes will find names declared later. For example:

```
fn main() {
  let n: i32 = 1;
  {
    // Finds outer `n`, not `n` declared below.
    let m: i32 = n;
    let n: i32 = 2;
    // Finds `g` declared below.
    print!("{} {}", m, g);
  }
}
const g: i32 = 3;
```

### C++ unqualified name lookup

C++ name lookup only finds earlier-declared names, except within certain
contexts nested within a class scope -- function bodies, default arguments,
exception specifications, default member initializers -- in which contexts
later-declared class member names are also found.

```
struct X {
  // OK, finds later-declared Y.
  void f() { Y y; }
  // Error, does not find later-declared Y.
  Y y;
  struct Y {};
};
```

C++ name lookup is not lexical, for three main reasons:

-   C++ permits separating the declaration of an entity from its definition, and
    the definition can in general be in a different lexical scope from the
    declaration. In this case, lookup in the definition can find names from
    scopes that enclose the declaration, even if they do not enclose the
    definition:
    ```
    namespace A {
      struct B {
        int f();
        int n;
      };
      int m;
    }
    // Effectively re-enters the scopes A and B.
    void A::B::f() {
      // Finds A::n and A::B::m even though neither is in a
      // lexically-enclosing scope.
      return n + m;
    }
    ```
-   Namespaces can be closed and reopened, and names from one opening of a
    namespace are visible in the next:
    ```
    namespace N {
      int a;
    }
    namespace N {
      // OK, even though `a` was not declared in a lexically-enclosing
      // contiguous scope.
      int b = a;
    }
    ```
-   Whenever unqualified lookup searches a class, non-dependent base classes are
    also considered before considering lexically-enclosing scopes:
    ```
    struct A {
      struct X {};
    };
    struct X {};
    struct B : A {
      // Finds `A::X`, not `::X`.
      X x;
    };
    ```
    However, the restriction to only non-dependent base classes is a source of
    confusion and inconsistency:
    ```
    template<typename T> struct C {
      struct X {};
      int n;
    };
    template<typename T> struct D : C<T> {
      // Finds `::X`, never `C<T>::X`.
      X x;
      // Error, can't find `n`. Use `this->n` to name `C<T>::n`.
      int get() { return n; }
    };
    ```

### Name shadowing

The name lookup rules must specify what happens when the same name is declared
in an outer scope and an inner scope. The most common rules are:

-   The inner name _shadows_ the outer name: name lookup stops when the inner
    name is found, and the outer name is not considered.
-   Such a declaration is invalid.

It is common to use a shadowing rule in some circumstances and reject in others.
For example, C++ disallows shadowing the name of a template parameter, and Rust
disallows shadowing the name of a global variable or constant, but both
languages permit name shadowing in other situations.

### Name spaces and name filtering

In some languages, there are multiple independent name spaces in which names can
be declared and looked up. For example, in C, names following `struct`, `union`,
and `enum` inhabit a different name space from variables and functions, and
`goto` labels inhabit a third name space:

```
void f() {
  struct x { int n; };
  int x;
x:
  // `struct x` names the struct, `{x}` names the variable...
  struct x y = {x};
  // ... and `goto x` names the label.
  goto x;
}
```

In C++, the situation is more complicated. Instead of having separate name
spaces, different kinds of lookups may choose to ignore some subset of the names
declared in a scope:

```
namespace a {
    int a;
    // OK, this `a` names the variable.
    int b = a;
    // Lookup to the left of a `::` ignores non-namespace, non-type names,
    // so this `a` names the namespace instead.
    int c = a::b;
}
```

### Name hiding

When two declarations introduce the same name in the same scope, C++ sometimes
employs a name hiding rule: the name of a variable, function, field, or
enumerator hides the name of a class or enumeration:

```
int a;
struct a { using b = int; };
// This names `int a`, which hides `struct a`.
int n = a;
// This lookup filters out `int a` and finds `struct a`.
a::b x;
```

This rule exists for backwards compatibility with C code, in which the two
declarations would not conflict because they are in different name spaces.

In C++, both this case and name shadowing are referred to as name hiding, even
though they are completely different mechanisms that operate at different layers
of the name lookup process; we will call this same-scope case "name hiding" and
will call the across-scopes case "name shadowing".

### Argument-dependent name lookup

In C++, unquailfied function names can resolve to a function that is not found
in an enclosing scope and is instead found in namespaces associated with its
argument types. This means that an unqualified function name may sometimes be
assumed to have the same semantics in all namespaces:

```
namespace A {
  struct Array { ... };
  void swap(Array&, Array&);
  void reverse(Array&);
}
namespace B {
  struct String { ... };
  void swap(String&, String&);
  String reverse(String);
}
```

Here, programmers are likely expected to assume that the name `swap` has
consistent semantics across all namespaces in the program, and that it is
reasonable to find a `swap` function by way of ADL, but that the name `reverse`
does not have these properties. In C++, there is no declarative statement of
this intent, and it must be inferred by the programmer.

## Proposal

Carbon will use a lexical name lookup rule, with the exception that namespace
scopes and class scopes are re-entered in out-of-line definitions, like in C++.

Unqualified name lookup will only find earlier-declared entities.

There is no name shadowing. Rather, name lookup searches all enclosing scopes,
and is ambiguous if the same name is found in more than one scope.

There is no name hiding. Within a single scope, a name can only be given a
single meaning. As a special case, that single meaning might be that the name is
an overloaded function, but we will view an overloaded function as a single
indivisible entity for this purpose rather than as a collection of distinct
functions. In particular, unlike C++, we will never combine two overloaded
functions from different scopes to form a single overloaded function.

There is only one name space, and no lookup filtering. All unqualified name
lookups are performed uniformly irrespective of how the name is used.

There is no argument-dependent name lookup. Instead, name lookup is performed
statically, and may resolve to a member of an interface; if so, the
implementation of that interface may be selected based on argument types.

## Details

TODO: Fully explain the details of the proposed solution.

## Rationale based on Carbon's goals

TODO: How does this proposal effectively advance Carbon's goals? Rather than
re-stating the full motivation, this should connect that motivation back to
Carbon's stated goals for the project or language. This may evolve during
review. Use links to appropriate goals, for example:

-   [Community and culture](/docs/project/goals.md#community-and-culture)
-   [Language tools and ecosystem](/docs/project/goals.md#language-tools-and-ecosystem)
-   [Performance-critical software](/docs/project/goals.md#performance-critical-software)
-   [Software and language evolution](/docs/project/goals.md#software-and-language-evolution)
-   [Code that is easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write)
-   [Practical safety and testing mechanisms](/docs/project/goals.md#practical-safety-and-testing-mechanisms)
-   [Fast and scalable development](/docs/project/goals.md#fast-and-scalable-development)
-   [Modern OS platforms, hardware architectures, and environments](/docs/project/goals.md#modern-os-platforms-hardware-architectures-and-environments)
-   [Interoperability with and migration from existing C++ code](/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code)

## Alternatives considered

TODO: What alternative solutions have you considered?
