# Keyword extensibility

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/93)

## Table of contents

<!-- toc -->

- [Problem](#problem)
- [Background](#background)
  - [Words, keywords, identifiers](#words-keywords-identifiers)
  - [Designators](#designators)
  - [Evolution](#evolution)
- [Proposal](#proposal)
- [Details](#details)
  - [Context sensitivity](#context-sensitivity)
  - [File-at-a-time transition](#file-at-a-time-transition)
  - [Reserved words](#reserved-words)
    - [Open questions for reserved words](#open-questions-for-reserved-words)
  - [Raw identifiers](#raw-identifiers)
  - [Name lookup impact](#name-lookup-impact)
  - [Grammar impact](#grammar-impact)
  - [Tooling impact](#tooling-impact)
  - [Attack vector](#attack-vector)
- [Alternatives considered](#alternatives-considered)

<!-- tocstop -->

## Problem

"The older I get, the less I care about making tech decisions right and the more
I care about retaining the ability to change a wrong one." -- @dbrady, Twitter

A major goal of the Carbon language is to support language evolution. We know we
will not produce a complete and perfect design on our first iteration, and we
will want to add features and functionality over time. This proposal focuses on
one specific area of language evolution: the addition of keywords.

We have seen the evolution of C++ be negatively impacted by the inability to
claim keywords when it would be useful to do so. For example:

- The keywords `static` and `using` were used for multiple distinct purposes to
  avoid adding new keywords.
- The keywords `nullptr` and `constexpr` were intentionally selected to avoid
  conflicts with user code; `null` and `constant` would likely have been better
  choices.
- The keywords `co_await`, `co_yield`, and `co_return` had undesirable `co_`
  prefixes added to avoid conflicting with the more natural names `await` and
  `yield`, which were both in use in certain important domains.
- The keywords `module`, `import`, `override`, and `final` were made
  context-sensitive to avoid collisions with user code.
- The keywords `requires` and `concept` were added to the language despite being
  in heavy use in user code, creating a barrier to upgrading to C++20.

We would like to avoid this class of problems by construction in Carbon.

## Background

### Words, keywords, identifiers

Carbon source code will be formed of various lexical elements serving different
functionality. One important lexical element is a word, such as `Foo` or `fn` or
`Int`.

An appearance of a word in a source file is a word token. There are two
different kinds of word tokens:

- A _keyword token_, which matches a terminal symbol for that specific word in
  grammar productions. For example, the grammar production for a function
  declaration includes a reference to the word `fn`, which will only match a
  keyword token for the word `fn`.

- An _identifier token_, which matches the terminal symbol _identifier_.

Example:

> ```
> fn Foo() {}
> ```
>
> Here, the `fn` token is a keyword token and the `Foo` token is an identifier
> token.

A word is a _keyword_ if it appears as a terminal symbol in any grammar
production -- that is, if it can meaningfully be used as a keyword token. The
set of keywords is expected to change over time.

For each word token, we must decide whether to treat it as a keyword token or an
identifier token. Traditionally, this choice depends only on the word: if the
word is a keyword, the word token is a keyword token, and otherwise the word
token is an identifier token. This proposal suggests a different choice,
depending on the context in which the word appears.

### Designators

A member access expression such as `foo.bar` is lexically treated as a word
token `foo` followed by a designator token `.bar`, not as a word token `foo`
followed by an operator `.` followed by a word token `bar`. This proposal only
addresses word tokens, not designator tokens, so it applies to the `foo` token
in such an expression, but not to the `.bar` token.

### Evolution

A change to a programming language is an API change. There are many ways that an
API change can be propagated to its consumers, with differing costs and
differing applicability. These properties of an API change would be ideal:

- The API change can be made without affecting any existing API users.

- API users can incrementally adopt the new API.

- If the goal is to remove an old API:

  - Users of the new and old API can coexist.

  - The transition from old API to new API can be automated.

  - The automation is known to always be correct.

- Once migration is complete, the old API can be removed.

In the context of this proposal, the old API is use of a particular word as an
identifier, and the new API is use of that same word as a keyword.

See also
["Large-Scale Changes at Google: Lessons Learned from 5 Yrs of Mass Migrations" -- Hyrum Wright, CppCon 2018](https://www.youtube.com/watch?v=TrC6ROeV4GI).

## Proposal

- If a word is declared as an identifier in a particular scope, then word tokens
  naming that word in that scope are identifier tokens. Otherwise, if the word
  is a keyword, they are keyword tokens. Otherwise, the usage is invalid.

- Within each source file, we require a consistent choice to be made: either
  every word token for a given word is an identifier token or every word token
  for that word is a keyword token.

- We have a set of _reserved words_, which are not allowed to be used as
  identifier tokens. These might be keywords, or they might be words with
  spellings we wish to disallow, such as words containing a double-underscore.

- A _raw identifier_ syntax is provided to permit any word to be used as an
  identifier, even if it is a reserved word or is used as a keyword token in the
  same source file.

This approach means that adding new keywords is always a backwards-compatible
change. No existing Carbon code is invalidated by a change that adds a new
keyword, because all word tokens naming that word are still interpreted as
identifier tokens, not as keyword tokens. The change can be adopted
incrementally, one file at a time. In each file, declarations and uses of the
word that are not part of an externally-visible API can be renamed to a
different word, and the remaining uses can be changed to use raw identifier
syntax. Finally, once a suitable transition period has completed, the word can
optionally be added to the set of reserved words.

## Details

### Context sensitivity

A declaration of a name causes name lookup for that word in the same lexical
scope to find the entity declared. For example:

```
// Declares 'x'.
var Int: x = 1;
// The 'x' here refers to the name bound on the previous line.
return x;
```

Each such declaration contains a word token that specifies the name bound by
that declaration. In the example above, this is the first `x` token. Every other
word token in a Carbon program is looked up by recursively searching outwards
through lexical scopes until a lexical scope is encountered in which the word is
declared. If the outermost lexical scope of the file is encountered, the prelude
-- which contains declarations of words such as `Int` -- is searched.

If this lookup finds nothing, then the word token is instead interpreted as a
keyword token. Note that if the word is not a keyword, this will result in an
error, as the program will not match any grammar production.

Example:

> ```carbon
> // Lookup of 'fn' finds nothing, so 'fn' is a keyword.
> // Word 'Foo' is declared here, so is not looked up.
> // Lookup of 'Int' finds 'Int' in the Carbon prelude.
> fn Foo() -> Int {
>   // Error, Bar not declared and not a known keyword.
>   Bar();
> }
>
> fn Bar() {
>   // OK, this is the 'Foo' declared a few lines above.
>   Foo();
> }
>
> // Lookup of each 'var' finds nothing, so 'var' is a keyword.
> // This is an error because there is no matching grammar production.
> var Int: x = var;
>
> // Lookup of 'fred' finds nothing, so 'foo' is a keyword.
> // This is an error because there is no matching grammar production.
> var Int: x = fred;
> ```

Such lookup can be performed very efficiently, for example by tracking the
current lookup result for each word in a hash table.

[Designators](#designators) are not subject to this lookup rule. An expression
such as `bar.foo` might interpret `bar` as a keyword token, but will never
interpret `foo` as a keyword token, even if `foo` is a
[reserved word](#reserved-words).

The strict lexical lookup rule described above guarantees not only that new
keywords can be added as a non-breaking change, but also that declaring new
identifiers in the Carbon prelude can be a non-breaking change, and that adding
new identifiers in user code cannot affect the meaning of any word token in any
other source file. In order for such non-keyword additions to not break existing
code, we would need to apply additional constraints to the language design. For
example:

- If we want the addition of a new prelude identifier to be a non-breaking
  change, it must be valid to shadow a newly-added identifier in the prelude
  from user code.

- If we want the addition of a new identifier in an arbitrary scope in a source
  file to be a non-breaking change, we need unqualified name lookup to only look
  in a single scope.

Such considerations are out of scope for this proposal, but should be kept in
mind when exploring the above areas in the context of other proposals.

### File-at-a-time transition

Given the basic approach, we cannot ensure that a snippet of Carbon code means
the same thing in all contexts. For example, `lambda()-1` might be built-in
syntax that forms a simple closure object that returns `-1` when `lambda` is a
keyword token, but might be a function call otherwise. However, we can ensure
local consistency within a single source file by disallowing use of a word as an
identifier token in some contexts and as a keyword token in others.

We therefore require that each source file makes a single consistent choice for
each word: either that word is only used as a keyword token, or it is only used
as an (unqualified) identifier token, never both. While a program that violates
this rule is invalid, we still assign meaning to it; such meaning may be useful
to tooling that operates on invalid source files.

While the rule is phrased as a property of the source file as a whole, this
restriction can be enforced by a single forward pass through the source file,
for example, while parsing: for each word, we can track whether it has ever been
used as an identifier token, or ever used as a keyword token, in the current
source file, and issue a diagnostic as soon as we would mark it as having been
used both ways.

This restriction does not apply to [designators](#designators). It is fine to
access a member `x.yield` even in a source file where `yield` is used as a
keyword token, and `X(.yield = 123)` is similarly unproblematic in such a source
file.

### Reserved words

We may want to disallow using some keywords as identifier tokens in cases where
there is no evolutionary benefit to permitting such use. For example:

- We could choose to reserve the complete initial set of keywords. Such words
  cannot possibly have non-keyword uses in any existing Carbon code, because no
  such code exists.
- We could reserve at least those words that we expect to be used as keyword
  tokens in every Carbon source file, such as `var`, `fn`.
- We could reserve all words that have been keywords for some time period. For
  example, we could reserve words one year after we give them predefined
  meaning.
- We could reserve words that we think are plausible future keywords, or that
  are keywords in C++, to discourage Carbon code from conflicting with expected
  language evolution paths or with our interoperability goal.

We might introduce keywords that we never intend to reserve. For example, we
might choose to never reserve the word `yield`, on the basis that it is a useful
noun that is important in several industries and domains such as finance and
manufacturing, but still use it as a keyword in the context of generators.

This proposal suggests that we classify some possibly-empty set of words as
_reserved_. A declaration that would bind a reserved word is invalid.
Consequently, in a valid program, every word token naming a reserved word is a
keyword token. However, this proposal does not suggest reserving any words.

[Designators](#designators) and [raw identifiers](#raw-identifiers) are allowed
to name reserved words.

#### Open questions for reserved words

We should establish a reserved words policy. In particular, we should choose:

- Which words should we reserve?

- How do we communicate the intent to reserve new words to the Carbon community?

- How long a notice period is provided after determining the intent to reserve a
  word, before reserving it?

The intent is for these questions to be answered separately from this proposal;
this proposal seeks to create a framework within which such a policy decision
can be established.

Until such a policy is established, proposals should not perform ad-hoc
reservation of words, and instead, no words should be reserved.

### Raw identifiers

Within a single source file, it may be desirable to use the same word as both an
identifier token and as a keyword token. For example, a financial library may
want to both declare a field named `yield` -- perhaps as part of a longstanding
externally-visible API -- and also implement generators using a `yield` keyword.
In such cases, the non-keyword uses of `yield` can be represented with raw
identifier syntax.

The concrete syntax for raw identifiers is out of scope for this proposal, and
will be covered by a separate proposal. Rust uses a `r#` prefix for this
purpose, leading to raw identifiers such as `r#yield`, and a similar syntax in
Carbon would be plausible, but is not proposed here.

Raw identifiers do not conflict with uses of the same word as a keyword token.
When a name is declared with a raw identifier, unqualified name lookups only
find it if they too use a raw identifier.

If a word is ever declared with a raw identifier in a source file, it cannot be
used as a non-raw identifier token in that same source file. Allowing such uses
would permit inconsistency, but would bring no benefit.

### Name lookup impact

In order for the strategy described in this proposal to be viable, we require
that unqualified name lookup only ever finds names that are lexically defined in
the same file. We want to be able to determine the grammatical structure of a
Carbon source file without considering its imports, and this would not be
possible if the classification of a word token as a keyword token or identifier
token can depend on the contents of other files.

### Grammar impact

We require that the Carbon grammar make it clear and straightforward to
determine which constructs introduce names, what names they introduce, and the
boundaries of scopes. These are good properties on general principle, but doubly
so under this proposal as these properties can also influence the grammatical
structure of Carbon programs.

Additionally, we cannot permit optional non-reserved keywords in positions where
it would be ambiguous whether they are names being introduced or keywords
preceding a name. For example, suppose we permit `var Int: ref x` to declare `x`
as a reference to an `Int`, and we make the name introduced after a `:`
optional. Then a construct such as `var Int: ref` becomes ambiguous. Is this
declaring an anonymous reference, or is it declaring a variable named `ref`?

These restrictions seem unlikely to cause significant problems in practice, and
are generally aligned with our goal of making Carbon code easy to read.

### Tooling impact

Each Carbon tool will need to choose whether to precisely model the Carbon
keyword rules, or to use a heuristic to approximate the rules. For example, a
tool that does not wish to model the rules precisely could assume that all uses
of keywords are interpreted as keyword tokens, or it could look at the local
syntactic context to determine if it's plausible that a use of a keyword is a
keyword token.

Simple syntax highlighters for Carbon code may wish to highlight all uses of
keywords as if they are keyword tokens. Not only is this likely good enough for
most use cases, it will also give Carbon programmers a visual clue that a word
they are using as an identifier is a keyword, which may encourage the programmer
to rename the identifier or convert it to a raw identifier.

The Carbon formatting tool will determine by simple syntactic analysis whether
each use of a word is a keyword token or not. Further, it should be able to
convert identifiers that collide with keywords into raw identifiers, in both the
case where the keyword is expected to become reserved and when the same word is
used as a keyword token elsewhere in the source file.

Tools that perform analysis and transformations on Carbon code will typically
not need to concern themselves unduly with these rules. Tools starting with a
parse tree will have already had the identifier / keyword choice resolved during
parsing. Tools that perform rewrites should be careful to not introduce names
that are keywords in general, but if such names are introduced in new code, the
Carbon formatter should replace them with raw identifiers as needed.

### Attack vector

It should be noted that this approach introduces a novel risk of underhanded
code that appears to mean one thing but means a different thing, by shadowing a
keyword with an identifier. This risk is discussed in
[Initial Analysis of Underhanded Source Code (Wheeler 2020)](https://www.ida.org/-/media/feature/publications/i/in/initial-analysis-of-underhanded-source-code/d-13166.ashx)
(page 4-2).

It's unclear to what extent this is a practical concern. We would expect that
shadowing of keywords with identifiers would be noticed and called out during
code review. The size of the attack window can be reduced by reserving keywords
soon after they are introduced, or by configuring code review tools to reject
changes that would introduce an identifier that collides with a keyword into a
file that did not previously use that word as an identifier.

## Alternatives considered

We could use a different lexical syntax for keywords versus identifiers. For
example, we could reserve `lower_snake_case` or `ALL_CAPS` for keywords, and
require identifiers to contain at least one uppercase or lowercase letter,
respectively. C followed this approach for most keywords added after C89,
styling them with a `_Leading_underscore`, and providing headers that exposed
the intended name as a macro. Our C++ compatibility goal strongly suggests that
we not restrict the lexical space for identifiers, and our ergonomics goal
strongly suggests that we do not `_Uglify` our keywords.

We could ask Carbon programmers to "import" the keywords they intend to use in
the same way they would import any other name, at least for any keywords added
after the initial release of Carbon. We could even extend this to the initial
keyword set, if we provide a way to access the keywords necessary to write an
"import" declaration, such as a "raw keyword" syntax. This is both feasible and
has a compelling purity, but the resulting boilerplate would not support our
goal of making Carbon code easy to write. This approach could even be extended
to allow keywords to be renamed, scoped, and so on, and to having multiple
different language extension libraries expose the same keyword with different
meanings. That would be powerful functionality, but would work against our goal
of making Carbon code easy to read and understand. This approach would also tend
to suggest either making the Carbon prelude empty or never adding names to it,
which would harm our goals of making Carbon code easy to write and supporting
language evolution, respectively.

We could do nothing at the level of the Carbon language design, and instead
address this issue on a case-by-case basis when adding keywords by picking words
that are unlikely to conflict with existing code. We know from experience with
C++ that this leads to suboptimal outcomes.

We could introduce a notion of versions or epochs for the Carbon language, with
a different set of keywords at each such version. Source files could be expected
to declare which version of the language they are using, or this could be
specified within the build language, and an explicit transition step would be
required to move a source file from one version to the next. In practice, this
would incentivize staying on older versions of Carbon, in order to avoid the
transition cost, and would work against the live-at-head ethos we wish to
inspire in Carbon programmers.
