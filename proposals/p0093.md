# Keyword extensibility

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/93)

## Table of contents

<!-- toc -->

- [Problem](#problem)
- [Background](#background)
  - [Words, keywords, identifiers](#words-keywords-identifiers)
  - [Evolution](#evolution)
- [Proposal](#proposal)
- [Details](#details)
  - [Context sensitivity](#context-sensitivity)
  - [File-at-a-time transition](#file-at-a-time-transition)
  - [Reserved words](#reserved-words)
  - [Raw identifiers](#raw-identifiers)
  - [Name lookup impact](#name-lookup-impact)
  - [Grammar impact](#grammar-impact)
  - [Tooling impact](#tooling-impact)
  - [Attack vector](#attack-vector)
- [Alternatives considered](#alternatives-considered)

<!-- tocstop -->

## Problem

"The older I get, the less I care about making tech decisions right and the more
I care about retaining the ability to change a wrong one." -- @dbrady, Twitter

A major goal of the Carbon language is to support language evolution. We know we
will not produce a complete and perfect design on our first iteration, and we
will want to add features and functionality over time. This proposal focuses on
one specific area of language evolution: the addition of keywords.

We have seen the evolution of C++ be repeatedly harmed by the inability to claim
keywords when it would be appropriate to do so. For example:

- The keywords `static` and `using` were used for multiple purposes to avoid
  adding new keywords.
- The keywords `nullptr` and `constexpr` were intentionally selected to avoid
  conflicts with user code; `null` and `constant` would likely have been better
  choices.
- The keywords `co_await`, `co_yield`, and `co_return` had undesirable `co_`
  prefixes added to avoid conflicting with the more natural names `await` and
  `yield`, which were both in use in certain important domains.
- The keywords `module`, `import`, `override`, and `final` were made
  context-sensitive to avoid collisions with user code.
- The keywords `requires` and `concept` were added to the language despite being
  in heavy use in user code, creating a barrier to upgrading to C++20.

We would like to avoid this problem by construction in Carbon.

## Background

### Words, keywords, identifiers

Carbon source code will be formed of various lexical elements serving different
functionality. One important lexical element is a word, such as `Foo` or `fn` or
`Int`.

Words serve one of two distinct purposes in Carbon source code:

- They can have _predefined meaning_ as part of a Carbon grammatical construct,
  such as the `fn` in `fn Foo() {}`.

- They can be supplied with _user-defined meaning_, such as the `Foo` in
  `fn Foo() {}` or in `Foo();`.

The set of words that have a predefined meaning is expected to change over time.

Each token that is lexically a word either uses that word's predefined meaning
or has a user-defined meaning. A word token that uses the word's predefined
meaning is a _keyword_. A word token that uses a user-defined meaning is an
_identifier_.

### Evolution

A change to a programming language is an API change. There are many ways that an
API change can be propagated to its consumers, with differing costs and
differing applicability. These properties of an API change would be ideal:

- The API change can be made without affecting any existing API users.

- API users can incrementally adopt the new API.

- If the goal is to remove an old API:

  - Users of the new and old API can coexist.

  - The transition from old API to new API can be automated.

  - The automation is known to always be correct.

- Once migration is complete, the old API can be removed.

In the context of this proposal, the old API is use of a particular word as an
identifier, and the new API is use of that same word as a keyword.

See also
["Large-Scale Changes at Google: Lessons Learned from 5 Yrs of Mass Migrations" -- Hyrum Wright, CppCon 2018](https://www.youtube.com/watch?v=TrC6ROeV4GI).

## Proposal

- If a word is declared as an identifier in a particular scope, then uses of
  that word in that scope are identifiers. Otherwise, if the word has predefined
  meaning, the uses are keywords. Otherwise, they are invalid.

- Within each source file, we require a consistent choice to be made: either
  every use of a word is treated as an identifier or every use of that word is
  treated as a keyword.

- We have a set of _reserved words_. Some words with predefined meaning might be
  reserved, as might words with spellings we wish to disallow, such as words
  containing a double-underscore. Reserved words are not allowed to be used as
  identifiers.

- A _raw identifier_ syntax is provided to permit any word to be used as an
  identifier without colliding with keywords, even if it is a reserved word.

This approach means that giving additional words a predefined meaning is always
a backwards-compatible change. No existing Carbon code is invalidated by a
change that adds a new predefined meaning to a word, because all uses of that
word are still interpreted as an identifier. The change can be adopted
incrementally, one file at a time. In each file, declarations and uses of the
word that are not part of an externally-visible API can be renamed to a
different word, and the remanining uses can be changed to use raw identifier
syntax. Finally, once a suitable transition period has completed, the word can
optionally be added to the set of reserved words.

## Details

### Context sensitivity

A declaration of a name causes name lookup for that word in the same lexical
scope to find the entity declared. For example:

```
// Declares 'x'.
var Int: x = 1;
// The 'x' here refers to the name bound on the previous line.
return x;
```

Each such declaration contains a word token that describes the name bound by
that declaration. Every other word token in a Carbon program is looked up by
recursively searching outwards through lexical scopes until a lexical scope is
encountered in which the word is declared as an identifier. If the outermost
lexical scope of the file is encountered, the Carbon prelude -- which contains
declarations of words such as `Int` -- is searched.

If this lookup finds nothing, then the word token is instead interpreted as a
keyword, as if there were one additional lexical scope in which all keywords
reside. For example:

```carbon
// Lookup of 'fn' finds nothing, so 'fn' is a keyword.
// Word 'Foo' is declared here, so is not looked up.
// Lookup of 'Int' finds 'Int' in the Carbon prelude.
fn Foo() -> Int {
  // Error, Bar not declared and not a known keyword.
  Bar();
}

fn Bar() {
  // OK, this is the 'Foo' declared a few lines above.
  Foo();
}
```

Such lookup can be performed very efficiently, for example by tracking the
current lookup result for each name in a hash table.

It is an important property that identifiers from the Carbon prelude and Carbon
keywords are essentially equivalent in this scheme: in particular, this means
that adding identifiers to the prelude can be a non-breaking change in the same
way that adding keywords is a non-breaking change. Note that in order to ensure
this property holds, we also need to exempt identifiers in the prelude from any
name shadowing restrictions, but such considerations are out of scope for this
proposal.

A name used in a member access expression, such as the `foo` in
`your_library.foo` or `some_struct.foo`, is lexically treated as a designator
`.foo` rather than as a word `foo`, and so is not subject to these restrictions.
It is valid to refer to `your_library.foo` even if `foo` is a
[reserved word](#reserved-words).

### File-at-a-time transition

Given the basic approach, we cannot ensure that a snippet of Carbon code means
the same thing in all contexts. For example, `lambda()-1` might be built-in
syntax that forms a simple closure object that returns `-1` when `lambda` is a
keyword, but might be a function call otherwise. However, we can ensure local
consistency within a single source file by disallowing use of a word as an
identifier in some contexts and as a keyword in others.

We therefore require that each source file makes a single consistent choice for
each word: either that word is used as a keyword, or it is used as an
(unqualified) identifier, never both.

While the rule is phrased as a property of the source file as a whole, this
restriction can be enforced by a single forward pass through the source file,
for example, while parsing: for each word, we can track whether it has ever been
used as an identifier, or ever used as a keyword, in the current source file,
and issue a diagnostic as soon as we would mark it as having been used both
ways.

This restriction does not apply to designators -- that is, words preceded by a
period. It is fine to access a member `x.yield` even in a source file where
`yield` is a keyword, and similarly `X{.yield = 123}` is unproblematic.

### Reserved words

We may want to disallow using some Carbon keywords as identifiers in cases where
there is no evolutionary benefit to permitting such use. For example:

- We could choose to reserve the complete set of words with predefined meaning.
  Such words cannot possibly have non-keyword uses in any existing Carbon code,
  because no such code exists.
- We could reserve at least those words that we expect to be used as keywords in
  every Carbon source file, such as `var`, `fn`.
- We could reserve all words that have had a predefined meaning for some time
  period. For example, we could reserve words one year after we give them
  predefined meaning.

There may be keywords that we wish to support but never intend to reserve. For
example, we might choose to never reserve the `yield` keyword, on the basis that
it is a useful noun that is important in several industries and domains such as
finance and manufacturing, but still treat it as a keyword in the context of
generators.

When a keyword is added, we should decide and publicize a choice of whether we
intend to eventually reserve that word, in order to give the Carbon community
time to transition. Implementations may wish to add a warning at that time for
uses of the word as an identifier, and upgrade that warning to an error once the
word becomes reserved.

Further, we should establish a policy that guides our decision of whether and
when to reserve words.

This proposal does not suggest reserving any words, and nor does it propose any
specific policy for determining which words should be reserved in future, but
without prejudice: we establish a framework that supports reserving words, and
leave it for future proposals to discuss which words, if any, should be
reserved.

### Raw identifiers

Within a single source file, it may be desirable to use the same word as both an
identifier and as a keyword. For example, a financial library may want to both
declare a field named `yield` -- perhaps as part of a longstanding
externally-visible API -- and also provide generators using `yield` as a
keyword. In such cases, the uses of `yield` as an identifier can be replaced
with the corresponding raw identifier.

The concrete syntax for raw identifiers is out of scope for this proposal, and
will be covered by a separate proposal. As a placeholder, we imagine using a
`r#` prefix to designate raw identifiers, such as `r#yield`.

Raw identifiers do not conflict with uses of the same word as a keyword. When a
name is declared with a raw identifier, unqualified name lookups only find it if
they too use a raw identifier.

If a word is ever declared with a raw identifier in a source file, it cannot be
used as a non-raw identifier in that same source file. (The only reason to use a
raw identifier is to avoid a conflict with a keyword, and such conflict should
be avoided consistently throughout the entire file.)

### Name lookup impact

In order for this strategy to be viable, we require that unqualified name lookup
only ever finds names that are lexically defined in the same file. We want to be
able to determine the grammatical structure of a Carbon source file without
considering its imports, and this would not be possible if the classification of
a word as a keyword or identifier can depend on the contents of other files.

### Grammar impact

We require that the Carbon grammar make it clear and straightforward to
determine which constructs introduce names, what names they introduce, and the
boundaries of scopes. These are good properties on general principle, but doubly
so under this proposal as these properties can also influence the grammatical
structure of Carbon programs.

Additionally, we cannot permit optional non-reserved keywords in positions where
it would be ambiguous whether they are names being introduced or keywords
preceding a name. For example, suppose we permit `var Int: ref x` to declare `x`
as a reference to an `Int`, and we make the name introduced after a `:`
optional. Then a construct such as `var Int: ref` becomes ambiguous. Is this
declaring an anonymous reference, or is it declaring a variable named `ref`?

These restrictions seem unlikely to cause significant problems in practice, and
are generally aligned with our goal of making Carbon code easy to read.

### Tooling impact

Each Carbon tool will need to choose whether to precisely model the Carbon
keyword rules, or to use a heuristic to approximate the rules. For example, a
tool that does not wish to model the rules precisely could assume that all words
with predefined meaning are interpreted as keywords, or it could look at the
local syntactic context to determine if use of a word as a keyword is plausible.

Simple syntax highlighters for Carbon code may wish to treat all words that
might be keywords as being keywords. Not only is this likely good enough for
most use cases, it will also give Carbon programmers a visual clue that a word
they are using as an identifier conflicts with a use as a keyword, which may
encourage the programmer to rename the identifier or convert it to a raw
identifier.

The Carbon formatting tool will determine by simple syntactic analysis whether
each use of a word is a keyword or not. Further, it should be able to convert
identifiers that collide with keywords into raw identifiers, in both the case
where the keyword is expected to become reserved and when the same word is used
as a keyword elsewhere in the source file.

Tools that perform analysis and transformations on Carbon code will typically
not need to concern themselves unduly with these rules. Tools starting with a
parse tree will have already had the identifier / keyword choice resolved during
parsing. Tools that perform rewrites should be careful to not introduce Carbon
keywords as identifiers in general, but if such identifiers are introduced in
new code, the Carbon formatter should rename them to raw identifiers as needed.

### Attack vector

It should be noted that this approach introduces a novel risk of underhanded
code that appears to mean one thing but means a different thing, by shadowing a
keyword with an identifier. This risk is discussed in
[Initial Analysis of Underhanded Source Code (Wheeler 2020)](https://www.ida.org/-/media/feature/publications/i/in/initial-analysis-of-underhanded-source-code/d-13166.ashx)
(page 4-2).

It's unclear to what extent this is a practical concern. We would expect that
shadowing of keywords with identifiers would be noticed and called out during
code review. The size of the attack window can be reduced by reserving keywords
soon after they are introduced, or by configuring code review tools to reject
changes that would introduce an identifier that collides with a keyword into a
file that did not previously use that word as an identifier.

## Alternatives considered

We could use a different lexical syntax for keywords versus identifiers. For
example, we could reserve `lower_snake_case` or `ALL_CAPS` for keywords, and
require identifiers to contain at least one uppercase or lowercase letter,
respectively. C followed this approach for most keywords added after C89,
styling them with a `_Leading_underscore`, and providing headers that exposed
the intended name as a macro. Our C++ compatibility goal strongly suggests that
we not restrict the lexical space for identifiers, and our ergonomics goal
strongly suggests that we do not `_Uglify` our keywords.

We could ask Carbon programmers to "import" the keywords they intend to use in
the same way they would import any other name, at least for any keywords added
after the initial release of Carbon. We could even extend this to the initial
keyword set, if we provide a way to access the keywords necessary to write an
"import" declaration (such as a "raw keyword" syntax). This is both feasible and
has a compelling purity, but the resulting boilerplate would not support our
goal of making Carbon code easy to write. This approach could even be extended
to allow keywords to be renamed, scoped, and so on, and to having multiple
different language extension libraries expose the same keyword with different
meanings. That would be powerful functionality, but would work against our goal
of making Carbon code easy to read and understand. This approach would also tend
to suggest either making the Carbon prelude empty or never adding names to it,
which would harm our goals of making Carbon code easy to write and supporting
language evolution, respectively.

We could do nothing at the level of the Carbon language design, and instead
address this issue on a case-by-case basis when adding keywords by picking words
that are unlikely to conflict with existing code. We know from experience with
C++ that this leads to suboptimal outcomes.

We could introduce a notion of versions or epochs for the Carbon language, with
a different set of keywords at each such version. Source files could be expected
to declare which version of the language they are using, or this could be
specified within the build language, and an explicit transition step would be
required to move a source file from one version to the next. In practice, this
would incentivize staying on older versions of Carbon, in order to avoid the
transition cost, and would work against the live-at-head ethos we wish to
inspire in Carbon programmers.
