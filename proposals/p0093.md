# Keyword extensibility

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/93)

## Table of contents

<!-- toc -->

- [Problem](#problem)
- [Background](#background)
  - [Words, keywords, identifiers](#words-keywords-identifiers)
  - [Evolution](#evolution)
- [Proposal](#proposal)
- [Details](#details)
  - [Context sensitivity](#context-sensitivity)
  - [File-at-a-time transition](#file-at-a-time-transition)
  - [Reserved words](#reserved-words)
  - [Raw identifiers](#raw-identifiers)
  - [Name lookup impact](#name-lookup-impact)
  - [Grammar impact](#grammar-impact)
  - [Tooling impact](#tooling-impact)
  - [Attack vector](#attack-vector)
- [Alternatives considered](#alternatives-considered)

<!-- tocstop -->

## Problem

"The older I get, the less I care about making tech decisions right and the more
I care about retaining the ability to change a wrong one." -- @dbrady, Twitter

A major goal of the Carbon language is to support language evolution. We know we
will not produce a complete and perfect design on our first iteration, and we
will want to add features and functionality over time. This proposal focuses on
one specific area of language evolution: the addition of keywords.

We have seen the evolution of C++ be repeatedly harmed by the inability to claim
keywords when it would be appropriate to do so. For example:

- The keywords `static` and `using` were used for multiple purposes to avoid
  adding new keywords.
- The keywords `nullptr` and `constexpr` were intentionally selected to avoid
  conflicts with user code; `null` and `constant` would likely have been better
  choices.
- The keywords `co_await`, `co_yield`, and `co_return` had undesirable `co_`
  prefixes added to avoid conflicting with the more natural names `await` and
  `yield`, which were both in use in certain important domains.
- The keywords `module`, `import`, `override`, and `final` were made
  context-sensitive to avoid collisions with user code.
- The keywords `requires` and `concept` were added to the language despite being
  in heavy use in user code, creating a barrier to upgrading to C++20.

We would like to avoid this problem by construction in Carbon.

## Background

### Words, keywords, identifiers

Carbon source code will be formed of various lexical elements serving different
functionality. One important lexical element is a word, such as `Foo` or `fn` or
`Int`.

Words serve one of two distinct purposes in Carbon source code:

- They can have known meaning as part of predefined grammatical constructs, such
  as the `fn` in `fn Foo() {}`.

- They can be supplied with user-defined meaning, such as the `Foo` in
  `fn Foo() {}` or in `Foo();`.

The set of words that are used in Carbon grammatical constructs is expected to
change over time.

### Evolution

A change to a programming language is an API change. There are many ways that an
API change can be propagated to its consumers, with differing costs and
differing applicability. These properties of an API change would be ideal:

- The API change can be made without affecting any existing API users.

- API users can incrementally adopt the new API.

- If the goal is to remove an old API:

  - Users of the new and old API can coexist.

  - The transition from old API to new API can be automated.

  - The automation is known to always be correct.

- Once migration is complete, the old API can be removed.

In the context of this proposal, the old API is use of a particular word as an
identifier, and the new API is use of that same word as a keyword.

See also
["Large-Scale Changes at Google: Lessons Learned from 5 Yrs of Mass Migrations" -- Hyrum Wright, CppCon 2018](https://www.youtube.com/watch?v=TrC6ROeV4GI).

## Proposal

- If a word is declared as an identifier in a particular context, then uses in
  that context treat it as an identifier. Otherwise, it is a keyword.

- Within each source file, we require a consistent choice to be made: either
  every use of a word is treated as an identifier or every use of that word is
  treated as a keyword.

- We have a set of _reserved words_, which might include some core Carbon
  keywords such as `fn`. Reserved words are not allowed to be used as
  identifiers.

- A _raw identifier_ syntax is provided to permit any word to be used as an
  identifier without colliding with keywords. For example, the word `var` can be
  used as an identifier by spelling it as `r#var`.

This approach means that adding new keywords is always a backwards-compatible
change. No existing Carbon code is invalidated by a change that adds a new
keyword, because all uses of that word are still interpreted as an identifier.
The new keyword can be adopted incrementally, one file at a time, by either
renaming uses of that word to a different word or, where the word is part of an
externally-visible API, by using raw identifier syntax. Finally, once a suitable
transition period has completed, the word can optionally be added to the set of
reserved words.

## Details

### Context sensitivity

We require that every identifier is declared in the same source file in which it
is used as an unqualified name, prior that use, in the same or an enclosing
lexical scope (or that it comes from the Carbon prelude).

```carbon
fn Foo() {
  // error, Bar not declared and not a known keyword
  Bar();
}

fn Bar() {
  // OK, this is the Foo from a few lines above.
  Foo();
}
```

This applies not only to names of entities introduced in the same source file,
but also to names imported from other source files and other packages.
Therefore, the meaning of any word can be determined by starting from the
appearance of the word and searching upwards and outwards for an introduction of
that word. If no declaration is found, this leaves three possibilities:

- The word is implicitly introduced by the Carbon prelude.

- The word is a Carbon keyword.

- The use of the word is invalid.

Such lookup can be performed very efficiently, for example by tracking the
current lookup result for each name in a hash table.

It is an important property that identifiers from the Carbon prelude and Carbon
keywords are essentially equivalent in this scheme: in particular, this means
that adding identifiers to the prelude can be a non-breaking change in the same
way that adding keywords is a non-breaking change. In order to permit this, we
would need to exempt identifiers in the prelude from any name shadowing
restrictions, but such considerations are out of scope for this proposal.

### File-at-a-time transition

Given the basic approach, we cannot ensure that a snippet of Carbon code means
the same thing in all contexts. For example, `lambda()-1` might be built-in
syntax that forms a simple closure object that returns `-1` when `lambda` is a
keyword, but might be a function call otherwise. However, we can ensure local
consistency within a single source file, by disallowing use of a word as an
identifier in some contexts and as a keyword in others.

We therefore require that each source file makes a single consistent choice for
each word: either that word is used as a keyword, or it is used as an
(unqualified) identifier, never both.

While the rule is phrased as a property of the source file as a whole, this
restriction can be enforced by a single forward pass through the source file
(for example, while parsing): for each word, we can track whether it has ever
been used as an identifier, or ever used as a keyword, in the current source
file, and issue a diagnostic as soon as we would mark it as having been used
both ways.

This restriction does not apply to designators -- that is, words preceded by a
period. It is fine to access a member `x.yield` even in a source file where
`yield` is a keyword, and similarly `X{.yield = 123}` is unproblematic.

### Reserved words

We may want to disallow using some Carbon keywords as identifiers, in cases
where there is no evolutionary benefit to permitting such use. For example, we
could reserve the complete set of initial Carbon keywords, on the basis that
they cannot possibly have non-keyword uses in any existing Carbon code (because
there is none). Or we could reserve at least those words that we expect to be
used in every Carbon source file, such as `var`, `fn`, and so on.

There may be keywords that we wish to support but never intend to reserve. For
example, we might choose to never reserve the `yield` keyword, on the basis that
it is a useful noun that is important in several industries and domains such as
finance and manufacturing, but still treat it as a keyword in the context of
generators.

When a keyword is added, we should decide and publicize a choice of whether we
intend to eventually reserve that word, in order to give the Carbon community
time to transition. Implementations may wish to add a warning at that time for
uses of the word as an identifier, and upgrade that warning to an error once the
word becomes reserved.

This proposal does not suggest reserving any words, but without prejudice: we
establish a framework that supports reserving words, and leave it for future
proposals to discuss which words (if any) should be reserved.

### Raw identifiers

Within a single source file, it may be desirable to use the same word as both an
identifier and as a keyword. For example, a financial library may want to both
declare a field named `yield` -- perhaps as part of a longstanding
externally-visible API -- and also provide generators using `yield` as a
keyword. In such cases, the uses of `yield` as an identifier can be replaced
with `r#yield`.

Raw identifiers do not conflict with uses of the same word as a keyword. When a
name is declared with a raw identifier, unqualified name lookups only find it if
they too use a raw identifier.

If a word is ever declared with a raw identifier in a source file, it cannot be
used as a non-raw identifier in that same source file. (The only reason to use a
raw identifier is to avoid a conflict with a keyword, and such conflict should
be avoided consistently throughout the entire file.)

### Name lookup impact

In order for this strategy to be viable, we require that unqualified name lookup
only ever finds names that are lexically defined in the same file. We want to be
able to determine the grammatical structure of a Carbon source file without
considering its imports, and this would not be possible if the classification of
a word as a keyword or identifier can depend on the contents of other files.

### Grammar impact

We require that the Carbon grammar make it clear and straightforward to
determine which constructs introduce names, what names they introduce, and the
boundaries of scopes. These are good properties on general principle, but doubly
so under this proposal as these properties can also influence the grammatical
structure of Carbon programs.

Additionally, we cannot permit optional (non-reserved) keywords in positions
where it would be ambiguous whether they are names being introduced or keywords
preceding a name. For example, suppose we permit `var Int: ref x` to declare `x`
as a reference to an `Int`, and we make the name introduced after a `:`
optional. Then a construct such as `var Int: ref` becomes ambiguous. Is this
declaring an anonymous reference, or is it declaring a variable named `ref`?

These restrictions seem unlikely to cause significant problems in practice, and
are generally aligned with our goal of making Carbon code easy to read.

### Tooling impact

Each Carbon tool will need to choose whether it wishes to precisely model the
Carbon keyword rules, or to assume that all known keywords are in fact
interpreted as keywords, or use some heuristics between these two positions.

Simple syntax highlighters for Carbon code may wish to treat all words that
might be keywords as being keywords. Not only is this likely good enough for
most use cases, it will also give Carbon programmers a visual clue that a word
they are using as an identifier conflicts with a use as a keyword, which may
encourage the programmer to rename the identifier or convert it to a raw
identifier.

The Carbon formatting tool will determine by simple syntactic analysis whether
each use of a word is a keyword or not. Further, it should be able to convert
identifiers that collide with keywords into raw identifiers, in both the case
where the keyword is expected to become reserved and when the same word is used
as a keyword elsewhere in the source file.

Tools that perform analysis and transformations on Carbon code will typically
not need to concern themselves unduly with these rules. Tools starting with a
parse tree will have already had the identifier / keyword choice resolved during
parsing. Tools that perform rewrites should be careful to not introduce Carbon
keywords as identifiers in general, but if such identifiers are introduced in
new code, the Carbon formatter should rename them to raw identifiers as needed.

### Attack vector

It should be noted that this approach introduces a novel risk of underhanded
code that appears to mean one thing but means a different thing, by shadowing a
keyword with an identifier. This risk is discussed in
[Initial Analysis of Underhanded Source Code (Wheeler 2020)](https://www.ida.org/-/media/feature/publications/i/in/initial-analysis-of-underhanded-source-code/d-13166.ashx)
(page 4-2).

It's unclear to what extent this is a practical concern. We would expect that
shadowing of keywords with identifiers would be noticed and called out during
code review. The size of the attack window can be reduced by reserving keywords
soon after they are introduced, or by configuring code review tools to reject
changes that would introduce an identifier that collides with a keyword into a
file that did not previously use that word as an identifier.

## Alternatives considered

We could use a different lexical syntax for keywords versus identifiers. For
example, we could reserve `lower_snake_case` or `ALL_CAPS` for keywords, and
require identifiers to contain at least one uppercase or lowercase letter
(respectively). C followed this approach for most keywords added after C89,
styling them with a `_Leading_underscore`, and providing headers that exposed
the intended name as a macro. Our C++ compatibility goal strongly suggests that
we not restrict the lexical space for identifiers, and our ergonomics goal
strongly suggests that we do not `_Uglify` our keywords.

We could ask Carbon programmers to "import" the keywords they intend to use in
the same way they would import any other name. This is both feasible and has a
compelling purity, but the resulting boilerplate would not support our goal of
making Carbon code easy to write. This approach could even be extended to allow
keywords to be renamed, scoped, and so on, and to having multiple different
language extension libraries expose the same keyword with different meanings.
That would be powerful functionality, but would work against our goal of making
Carbon code easy to read and understand.

We could do nothing at the level of the Carbon language design, and instead
address this issue on a case-by-case basis when adding keywords by picking words
that are unlikely to conflict with existing code. We know from experience with
C++ that this leads to suboptimal outcomes.

We could introduce a notion of versions or epochs for the Carbon language, with
a different set of keywords at each such version. Source files could be expected
to declare which version of the language they are using, or this could be
specified within the build language, and an explicit transition step would be
required to move a source file from one version to the next. In practice, this
would incentivize staying on older versions of Carbon, in order to avoid the
transition cost, and would work against the live-at-head ethos we wish to
inspire in Carbon programmers.
