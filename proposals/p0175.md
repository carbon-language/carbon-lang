# C++ interoperability goals

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/175)

## Table of contents

<!-- toc -->

-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
    -   [Philosophy](#philosophy)
    -   [Language goal influences](#language-goal-influences)
        -   [Performance-critical software](#performance-critical-software)
        -   [Software and language evolution](#software-and-language-evolution)
        -   [Code that is easy to read, understand, and write](#code-that-is-easy-to-read-understand-and-write)
        -   [Practical safety guarantees and testing mechanisms](#practical-safety-guarantees-and-testing-mechanisms)
        -   [Fast and scalable development](#fast-and-scalable-development)
        -   [Modern OS platforms, hardware architectures, and environments](#modern-os-platforms-hardware-architectures-and-environments)
        -   [Interoperability with and migration from existing C++ code](#interoperability-with-and-migration-from-existing-c-code)
    -   [Goals](#goals)
        -   [Support mixing Carbon and C/C++ toolchains](#support-mixing-carbon-and-cc-toolchains)
        -   [Minimize bridge code](#minimize-bridge-code)
        -   [Allow use of advanced C++ features](#allow-use-of-advanced-c-features)
        -   [Unsurprising mappings C/C++ and Carbon types](#unsurprising-mappings-cc-and-carbon-types)
    -   [Non-goals](#non-goals)
        -   [Offer full parity between a Carbon-only toolchain and mixing C++/Carbon toolchains](#offer-full-parity-between-a-carbon-only-toolchain-and-mixing-ccarbon-toolchains)
        -   [Minimal bridge code for calling into Carbon](#minimal-bridge-code-for-calling-into-carbon)
        -   [Support all C/C++ code without bridge code](#support-all-cc-code-without-bridge-code)
        -   [Compile Carbon to the C/C++ ABI](#compile-carbon-to-the-cc-abi)
        -   [Use the C/C++ ABI for all Carbon interoperability](#use-the-cc-abi-for-all-carbon-interoperability)
        -   [Non-zero overhead conversions must be optional](#non-zero-overhead-conversions-must-be-optional)

<!-- tocstop -->

## Problem

[Carbon's goals](/docs/project/goals.md) include "Interoperability with and
migration from existing C++ code". This proposal aims to provide additional
detail to that goal, beyond what makes sense to have in the main goals document.

## Background

Interoperability and migration are key to Carbon. However, performance and
evolution are _higher_ priorities. This proposal aims to outline at what this
should end up looking like in Carbon, as well as indicating a couple trade-offs
that will occur.

## Proposal

### Philosophy

The C/C++ interoperability layer of Carbon is the section wherein a specific,
restricted set of C/C++ APIs can be expressed in a way that's callable from
Carbon, and similar for calling Carbon from C/C++. This requires expressing one
language as a subset of the other. Our goal is that the constraint of
expressivity is loose enough that the resulting amount of bridge code is
sustainable.

The design for interoperability between Carbon and C/C++ hinges on:

1.  The ability to interoperate with a wide variety of code, such as
    classes/structs, not just free functions.
2.  A willingness to expose the idioms of C/C++ into Carbon code, and the other
    way around, when necessary to maximize performance of the interoperability
    layer.
3.  The use of wrappers and generic programming, including templates, to
    minimize or eliminate runtime overhead.

These things come together when looking at how custom data structures in C++ are
exposed into Carbon, and the other way around. In both languages, it is
reasonable and even common to have customized low-level data structures, such as
associative containers. For example, there are numerous data structures for
mapping from a key to a value that might be "best", including hash tables,
linked hash tables, sorted vectors, and btrees. Even for a given data structure,
there may be slow but meaningful evolution in implementations strategies.

The result is that it will often be reasonable to directly expose a C++ data
structure to Carbon without converting it to a "native" or "idiomatic" Carbon
data structure. For many data structures, code will reasonably support multiple
different implementations, even if there is an extremely good default. C++ data
structures can be exposed as another implementation, and wrappers could be added
if it's useful to make usage more idiomatic for Carbon.

The reverse is also true. C++ code will often not care, or can be refactored to
not care, what specific data structure is used. Carbon data structures can be
exposed as yet another implementation in C++, and wrapped to match C++ idioms.

### Language goal influences

#### Performance-critical software

Interoperability with C/C++ will be frequently used in Carbon, whether it's
C/C++ developers trying out Carbon, incrementally migrating a large C/C++
codebase, or continuing to use a C/C++ library long-term. In all cases, it must
be possible to write interoperable code with zero overhead; copies must not be
required.

#### Software and language evolution

Interoperability will require the addition of features to Carbon which are
unique to it. However, these features must not unduly impinge the overall
evolution of Carbon. In particular, only a subset of Carbon features will
support interoperability with C/C++. To do otherwise would restrict Carbon's
feature set.

#### Code that is easy to read, understand, and write

Interoperability-related Carbon code will likely be more difficult to read than
other, more idiomatic Carbon code. This is okay: aiming to make Carbon code
readable doesn't mean that it needs to _all_ be trivial to read. At the same
time, the extra costs that interoperability exerts on Carbon developers should
be minimized.

#### Practical safety guarantees and testing mechanisms

Safety is important to maintain around interoperability code, and mitigations
should be provided where possible. However, native Carbon code will be easier to
make safe than Carbon code that invokes C/C++. C/C++ code will not benefit from
the same set of safety mechanisms that Carbon offers. As a result, safety
guarantees will be weaker around interoperability layers.

#### Fast and scalable development

The interoperability layer will likely have tooling limitations similar to
C/C++. C/C++ code will need to be compiled and parsed in order to provide
interoperability, yet the syntax of C/C++ is outside the scope of Carbon.

#### Modern OS platforms, hardware architectures, and environments

Interoperability will apply to the intersection of environments supported by
both Carbon and C/C++. Pragmatically, Carbon will likely be the limiting factor
here.

#### Interoperability with and migration from existing C++ code

Interoperability is itself a language goal for Carbon. The language design must
be mindful of the prioritization; trade-offs harming other goals may still be
made so long as they offer greater benefits for interoperability and Carbon as a
whole.

### Goals

#### Support mixing Carbon and C/C++ toolchains

The Carbon toolchain will support compiling C/C++ code. It will contain a
customized C/C++ compiler that enables some more advanced interoperability
features, such as calling Carbon templates from C/C++.

Mixing toolchains will also be supported in both directions:

-   C/C++ ABI-compatible libraries compiled by a non-Carbon toolchain will be
    usable from Carbon.
-   The Carbon toolchain will support, as an option, generating a C/C++
    ABI-compatible library for use with non-Carbon toolchains.

Mixing toolchains restricts functionality to what's feasible with the C/C++ ABI.
For example, developers should expect that Carbon templates will be callable
from C++ when using the Carbon toolchain, and will not be available when mixing
toolchains because it would require a substantially different and more complex
interoperability implementation. This degraded interoperability should still be
sufficient for most developers, albeit with the potential of more bridge code.

#### Minimize bridge code

The majority of simple C/C++ interfaces should be usable from Carbon without any
custom bridge code and without any runtime overhead, and similar when calling
Carbon from C/C++. That is, Carbon code should be able to call most C/C++ code
without any code changes to add support for interoperability. This includes
using C/C++ code compiled with a non-Carbon toolchain, so long as the C/C++
headers can be parsed by the Carbon toolchain.

Our priority is that Carbon developers should be able to easily reuse the mature
ecosystem of C/C++ libraries provided by third-parties. A third-party library's
language choice should not be a barrier to Carbon adoption.

Even for first-party libraries, migration of C/C++ codebases to Carbon will
often be incremental due to human costs of executing and verifying source
migrations. Minimizing the amount of bridge code required should be expected to
simplify such migrations.

#### Allow use of advanced C++ features

There should be support for most idiomatic usage of advanced C++ features. For
example, templates, overload sets, and ADL.

Although these features can be considered "advanced", their use is endemic
throughout C++ code, including STL. Support for such features is key to
supporting migration from C++ features.

#### Unsurprising mappings C/C++ and Carbon types

Carbon will provide unsurprising mappings for common types.

**Primitive types** will have mappings with zero overhead conversions. They are
frequently used, making it important that interoperability code be able to use
them seamlessly.

The storage and representation will need to be equivalent in both languages. For
example, if a C/C++ `__int64` maps to Carbon's `Int64`, the memory layout of
both types must be identical.

Semantics need to be similar, but edge-case behaviors don't need to be
identical. We will use this where we believe Carbon provides better default
behavior. For example, where C/C++ would have modulo wrapping on integers,
Carbon could instead have trapping behavior on the default-mapped primitive
types.

**Non-owning vocabulary types**, such as pointers and references, will have
transparent, automatic translation between C++ and Carbon non-owning vocabulary
types with zero overhead.

**Other vocabulary types** will typically have reasonable, but potentially
non-zero overhead, conversions available to map into Carbon vocabulary types.

### Non-goals

#### Offer full parity between a Carbon-only toolchain and mixing C++/Carbon toolchains

[As noted above](#support-mixing-carbon-and-cc-toolchains), the best-supported
way of using the bidirectional Carbon/C++ interoperability will be to compile
C++ code with the Carbon toolchain. Mixed toolchains will be supported with
degraded interoperability.

The only way that we can make mixed toolchain support equivalent to Carbon-only
toolchain support is if all interoperability solutions must work with mixed
toolchains. The feature of calling Carbon templates from C++ code is key when
analyzing this option.

With a Carbon toolchain compiling both Carbon and C++ code, we can have the C++
code use compiler code paths that use portions of the Carbon AST generated by
the template code. While this approach is still complex and may not always work,
it should offer substantial value and ability to migrate C++ code to Carbon
without requiring parallel maintenance of implementations in C++.

With a mixed toolchain, the C++ toolchain would require Carbon's template be
translated into something it could use, without awareness of Carbon. In C++,
templates exist only in source and are instantiated by the compiler. The desire
to support instantiation from C++ limits possible solutions; althoughCarbon's
toolchain could provide C++ ABI-compatible instantiated versions of the
template, but it cannot support instantiation from C++.

The main approach available would be to support source-level translation of
Carbon templates to C++ by the Carbon toolchain. The C++ toolchain would then be
able to use the generated C++ source. However, while migration support requires
tooling for C++ to Carbon migrations, the other direction would be needed here.
We expect this would add a degree of complexity that would make the feature
substantially more expensive.

As a result, developers should expect that while _most_ features will work
equivalently for mixed toolchains, there will never be full parity.

#### Minimal bridge code for calling into Carbon

Although we consider it a priority to allow calling C/C++ functions from Carbon
without bridge code, we _will not_ avoid requiring bridge code when it comes to
calling Carbon APIs from C++.

**Why:** We expect to modify the C/C++ compiler in order to effectively
auto-generate the necessary wrappers for Carbon to call C/C++. Internally, this
will mean exposing C/C++ code on non-standard Carbon-compatible ABIs.

Automatically exposing Carbon code to C/C++ in the same way would restrict
Carbon to use of the C/C++ ABI. Even to what extent we could work around this,
we are concerned that avoiding bridge code would impose evolution constraints
upon the evolution of Carbon.

#### Support all C/C++ code without bridge code

We do not expect to support all C/C++ corner cases: the complexity of supporting
any given construct must be balanced by the real world need for that support.

-   We may target C++17, and not keep adding interoperability support for later
    C++ features.
    -   There may be interest in supporting some C++20 features, particularly
        modules. However, exhaustive support should not be assumed.
-   For example, we might not prioritize support for non-idiomatic code,
    interfaces, or patterns outside of those in widespread open source libraries
    and used by key contributors.
-   For example, we might not support low-level C ABIs outside of modern 64-bit
    ABIs: Linux, POSIX, and a small subset of Windows' calling conventions.

**Why**:

TODO add more

#### Compile Carbon to the C/C++ ABI

#### Use the C/C++ ABI for all Carbon interoperability

-   We may choose not to use the existing ABI for the C++ language or standard
    library.
    -   It might be reasonable to eventually support these with added runtime
        overhead.

TODO add more

####

TODO more

-   We may choose not to provide exact matches between Carbon and C++ vocabulary
    types.
-   We may choose not to provide full support for unwinding exceptions across
    Carbon and C/C++ boundaries.
-   Interoperability features should not be expected to work for arbitrary C++
    toolchains. While pre-compiled C++ libraries may be callable, the Carbon
    toolchain should be used to compile both C++ and Carbon in order to achieve
    full support.
    -   Carbon must be able to compile C++ headers in order to translate names
        and types, even if it's not used to compile the C++ object files.
    -   While arbitrary C++ code may be able to call into Carbon code that has
        been pre-compiled into a library, a more complex interaction like C++
        code calling Carbon templates requires compilation of _both_ languages
        together.

#### Non-zero overhead conversions must be optional

Non-zero overhead conversions should only be _supported_, never _required_, in
order to offer reliable, unsurprising performance behaviors. This does not mean
that conversions will _always_ be supported, as support is a cost-benefit
decision for specific type mappings. For example, consider conversions between
`std::vector<T>` and an equivalent, idiomatic Carbon type:

-   Making conversions zero-overhead would require the Carbon type to mirror the
    memory layout and implementation semantics of `std::vector<T>`. However,
    this would constrain the evolution of the Carbon type to match C++; while we
    might support that for some interoperability-specific types, we would not
    want to constrain the evolution of idiomatic Carbon types.

-   These conversions may not always be present, but `std::vector<T>` is a
    frequently used type. As a result, we'd likely provide APIs that would offer
    a copy-based conversion to the idiomatic Carbon type.

-   An interface which can hide the difference between whether `std::vector<T>`
    or the equivalent, idiomatic Carbon type is in use may also be offered,
    although this could end up similarly adding performance overhead.

-   It will still be normal to handle `std::vector<T>` in Carbon code without
    conversions, as overhead in common cases is likely to be detrimental to
    applications. Developers should be given the choice of when to convert.
