# C++ interoperability goals

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/175)

## Table of contents

<!-- toc -->

-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
    -   [Philosophy](#philosophy)
    -   [Language goal influences](#language-goal-influences)
        -   [Performance-critical software](#performance-critical-software)
        -   [Software and language evolution](#software-and-language-evolution)
        -   [Code that is easy to read, understand, and write](#code-that-is-easy-to-read-understand-and-write)
        -   [Practical safety guarantees and testing mechanisms](#practical-safety-guarantees-and-testing-mechanisms)
        -   [Fast and scalable development](#fast-and-scalable-development)
        -   [Modern OS platforms, hardware architectures, and environments](#modern-os-platforms-hardware-architectures-and-environments)
        -   [Interoperability with and migration from existing C++ code](#interoperability-with-and-migration-from-existing-c-code)
    -   [Goals](#goals)
        -   [Support mixing Carbon and C/C++ toolchains](#support-mixing-carbon-and-cc-toolchains)
        -   [Minimize bridge code](#minimize-bridge-code)
        -   [Allow use of advanced C++ features](#allow-use-of-advanced-c-features)
        -   [Unsurprising mappings C/C++ and Carbon types](#unsurprising-mappings-cc-and-carbon-types)
    -   [Non-goals](#non-goals)
        -   [Full parity between a Carbon-only toolchain and mixing C++/Carbon toolchains](#full-parity-between-a-carbon-only-toolchain-and-mixing-ccarbon-toolchains)
        -   [Never require bridge code](#never-require-bridge-code)
        -   [Non-zero overhead conversions must be optional](#non-zero-overhead-conversions-must-be-optional)
        -   [Support unwinding exceptions across Carbon and C/C++ boundaries](#support-unwinding-exceptions-across-carbon-and-cc-boundaries)

<!-- tocstop -->

## Problem

[Carbon's goals](/docs/project/goals.md) include "Interoperability with and
migration from existing C++ code". This proposal aims to provide additional
detail to that goal, beyond what makes sense to have in the main goals document.

## Background

Interoperability and migration are key to Carbon. However, performance and
evolution are _higher_ priorities. This proposal aims to outline at what this
should end up looking like in Carbon, as well as indicating a couple trade-offs
that will occur.

## Proposal

### Philosophy

The C/C++ interoperability layer of Carbon is the section wherein a specific,
restricted set of C/C++ APIs can be expressed in a way that's callable from
Carbon, and similar for calling Carbon from C/C++. This requires expressing one
language as a subset of the other. Our goal is that the constraint of
expressivity is loose enough that the resulting amount of bridge code is
sustainable.

The design for interoperability between Carbon and C/C++ hinges on:

1.  The ability to interoperate with a wide variety of code, such as
    classes/structs, not just free functions.
2.  A willingness to expose the idioms of C/C++ into Carbon code, and the other
    way around, when necessary to maximize performance of the interoperability
    layer.
3.  The use of wrappers and generic programming, including templates, to
    minimize or eliminate runtime overhead.

These things come together when looking at how custom data structures in C++ are
exposed into Carbon, and the other way around. In both languages, it is
reasonable and even common to have customized low-level data structures, such as
associative containers. For example, there are numerous data structures for
mapping from a key to a value that might be "best", including hash tables,
linked hash tables, sorted vectors, and btrees. Even for a given data structure,
there may be slow but meaningful evolution in implementations strategies.

The result is that it will often be reasonable to directly expose a C++ data
structure to Carbon without converting it to a "native" or "idiomatic" Carbon
data structure. For many data structures, code will reasonably support multiple
different implementations, even if there is an extremely good default. C++ data
structures can be exposed as another implementation, and wrappers could be added
if it's useful to make usage more idiomatic for Carbon.

The reverse is also true. C++ code will often not care, or can be refactored to
not care, what specific data structure is used. Carbon data structures can be
exposed as yet another implementation in C++, and wrapped to match C++ idioms.

### Language goal influences

#### Performance-critical software

Interoperability with C/C++ will be frequently used in Carbon, whether it's
C/C++ developers trying out Carbon, incrementally migrating a large C/C++
codebase, or continuing to use a C/C++ library long-term. In all cases, it must
be possible to write interoperable code with zero overhead; copies must not be
required.

#### Software and language evolution

Interoperability will require the addition of features to Carbon which are
unique to it. However, these features must not unduly impinge the overall
evolution of Carbon. In particular, only a subset of Carbon features will
support interoperability with C/C++. To do otherwise would restrict Carbon's
feature set.

#### Code that is easy to read, understand, and write

Interoperability-related Carbon code will likely be more difficult to read than
other, more idiomatic Carbon code. This is okay: aiming to make Carbon code
readable doesn't mean that it needs to _all_ be trivial to read. At the same
time, the extra costs that interoperability exerts on Carbon developers should
be minimized.

#### Practical safety guarantees and testing mechanisms

Safety is important to maintain around interoperability code, and mitigations
should be provided where possible. However, native Carbon code will be easier to
make safe than Carbon code that invokes C/C++. C/C++ code will not benefit from
the same set of safety mechanisms that Carbon offers. As a result, safety
guarantees will be weaker around interoperability layers.

#### Fast and scalable development

The interoperability layer will likely have tooling limitations similar to
C/C++. C/C++ code will need to be compiled and parsed in order to provide
interoperability, yet the syntax of C/C++ is outside the scope of Carbon.

#### Modern OS platforms, hardware architectures, and environments

Interoperability will apply to the intersection of environments supported by
both Carbon and C/C++. Pragmatically, Carbon will likely be the limiting factor
here.

#### Interoperability with and migration from existing C++ code

Interoperability is itself a language goal for Carbon. The language design must
be mindful of the prioritization; trade-offs harming other goals may still be
made so long as they offer greater benefits for interoperability and Carbon as a
whole.

### Goals

#### Support mixing Carbon and C/C++ toolchains

The Carbon toolchain will support compiling C/C++ code. It will contain a
customized C/C++ compiler that enables some more advanced interoperability
features, such as calling Carbon templates from C/C++.

Mixing toolchains will also be supported in both directions:

-   C/C++ ABI-compatible libraries compiled by a non-Carbon toolchain will be
    usable from Carbon.
-   The Carbon toolchain will support, as an option, generating a C/C++
    ABI-compatible library for use with non-Carbon toolchains.

Mixing toolchains restricts functionality to what's feasible with the C/C++ ABI.
For example, developers should expect that Carbon templates will be callable
from C++ when using the Carbon toolchain, and will not be available when mixing
toolchains because it would require a substantially different and more complex
interoperability implementation. This degraded interoperability should still be
sufficient for most developers, albeit with the potential of more bridge code.

#### Minimize bridge code

The majority of simple C/C++ interfaces should be usable from Carbon without any
custom bridge code and without any runtime overhead, and similar when calling
Carbon from C/C++. That is, Carbon code should be able to call most C/C++ code
without any code changes to add support for interoperability. This includes
using C/C++ code compiled with a non-Carbon toolchain, so long as the C/C++
headers can be parsed by the Carbon toolchain.

Our priority is that Carbon developers should be able to easily reuse the mature
ecosystem of C/C++ libraries provided by third-parties. A third-party library's
language choice should not be a barrier to Carbon adoption.

Even for first-party libraries, migration of C/C++ codebases to Carbon will
often be incremental due to human costs of executing and verifying source
migrations. Minimizing the amount of bridge code required should be expected to
simplify such migrations.

#### Allow use of advanced C++ features

There should be support for most idiomatic usage of advanced C++ features. For
example, templates, overload sets, and ADL.

Although these features can be considered "advanced", their use is endemic
throughout C++ code, including STL. Support for such features is key to
supporting migration from C++ features.

#### Unsurprising mappings C/C++ and Carbon types

Carbon will provide unsurprising mappings for common types.

**Primitive types** will have mappings with zero overhead conversions. They are
frequently used, making it important that interoperability code be able to use
them seamlessly.

The storage and representation will need to be equivalent in both languages. For
example, if a C/C++ `__int64` maps to Carbon's `Int64`, the memory layout of
both types must be identical.

Semantics need to be similar, but edge-case behaviors don't need to be
identical, allowing Carbon flexibility to evolve. For example, where C/C++ would
have modulo wrapping on integers, Carbon could instead have trapping behavior on
the default-mapped primitive types.

**Non-owning vocabulary types**, such as pointers and references, will have
transparent, automatic translation between C++ and Carbon non-owning vocabulary
types with zero overhead.

**Other vocabulary types** will typically have reasonable, but potentially
non-zero overhead, conversions available to map into Carbon vocabulary types.

### Non-goals

#### Full parity between a Carbon-only toolchain and mixing C++/Carbon toolchains

Making mixed C++/Carbon toolchain support equivalent to Carbon-only toolchain
support affects all interoperability features. Mixed toolchains will have
degraded support because full parity would be too expensive.

The feature of calling Carbon templates from C++ code is key when analyzing this
option.

With a Carbon toolchain compiling both Carbon and C++ code, Carbon templates can
be handled by adding C++ compiler code paths that use portions of the Carbon AST
generated by the Carbon template code. While this approach is still complex and
may not always work, it should offer substantial value and ability to migrate
C++ code to Carbon without requiring parallel maintenance of implementations in
C++.

With a mixed toolchain, the C++ toolchain would require Carbon's template be
translated into something it could use, without awareness of Carbon. In C++,
templates exist only in source and are instantiated by the compiler. The desire
to support instantiation from C++ limits possible solutions; although Carbon's
toolchain could provide C++ ABI-compatible instantiated versions of the
template, it cannot support instantiation from C++.

The main approach available would be to support source-level translation of
Carbon templates to C++ by the Carbon toolchain. The C++ toolchain would then be
able to use the generated C++ source. However, while migration support requires
tooling for C++ to Carbon migrations, the other direction would be needed here.
Supporting Carbon to C++ source migrations for templates would be a high cost to
pay for mixed toolchain support.

Note that this issue differs when considering interoperability for Carbon code
instantiating C++ templates. The C++ templates must be in C++ headers, which
must compile with the Carbon toolchain regardless of whether a separate C++
toolchain is in use. This may also be considered a constraint on mixed toolchain
interoperability, but it's simpler to address and less likely to burden
developers.

To summarize, developers should expect that while _most_ features will work
equivalently for mixed toolchains, there will never be full parity.

#### Never require bridge code

Corner cases of C/C++ will not receive equal support to common cases: the
complexity of supporting any given construct must be balanced by the real world
need for that support. For example:

-   Interoperability will target C++17. Any interoperability support for future
    versions of C++, including features such as C++20 modules, will be based on
    a cost-benefit analysis. Exhaustive support should not be assumed.

-   Support will be focused on idiomatic code, interfaces, and patterns used in
    widespread open source libraries or used by key contributors. C/C++ code
    will have edge cases where the benefits of limiting Carbon's maintenance
    costs by avoiding complex interoperability outweighs the value of avoiding
    bridge code.

-   Support for low-level C ABIs may be focused on modern 64-bit ABIs, including
    Linux, POSIX, and a small subset of Windows' calling conventions.

#### Non-zero overhead conversions must be optional

Non-zero overhead conversions should only be _supported_, never _required_, in
order to offer reliable, unsurprising performance behaviors. This does not mean
that conversions will _always_ be supported, as support is a cost-benefit
decision for specific type mappings. For example, consider conversions between
`std::vector<T>` and an equivalent, idiomatic Carbon type:

-   Making conversions zero-overhead would require the Carbon type to mirror the
    memory layout and implementation semantics of `std::vector<T>`. However,
    this would constrain the evolution of the Carbon type to match C++; while we
    might support that for some interoperability-specific types, we would not
    want to constrain the evolution of idiomatic Carbon types.

-   These conversions may not always be present, but `std::vector<T>` is a
    frequently used type. As a result, we'd likely provide APIs that would offer
    a copy-based conversion to the idiomatic Carbon type.

-   An interface which can hide the difference between whether `std::vector<T>`
    or the equivalent, idiomatic Carbon type is in use may also be offered,
    although this could end up similarly adding performance overhead.

-   It will still be normal to handle `std::vector<T>` in Carbon code without
    conversions, as overhead in common cases is likely to be detrimental to
    applications. Developers should be given the choice of when to convert.

#### Support unwinding exceptions across Carbon and C/C++ boundaries

Exceptions offer insufficient benefit to support full interoperability.
Exception handling will not have interoperability support.
