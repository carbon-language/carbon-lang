# Design direction for sum types

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/157)

## Table of contents

<!-- toc -->

-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Pattern matching](#pattern-matching)
-   [Pattern functions](#pattern-functions)
    -   [Constraints on function evaluation](#constraints-on-function-evaluation)
    -   [Constraints on pattern matching](#constraints-on-pattern-matching)
        -   [Underdetermined patterns](#underdetermined-patterns)
        -   [Match guards](#match-guards)
        -   [Subpattern bindings](#subpattern-bindings)
        -   [Pattern-specific sugar syntaxes](#pattern-specific-sugar-syntaxes)
        -   [Avoidable inconsistencies](#avoidable-inconsistencies)
    -   [Worked example: `ArrayOfZeroes`](#worked-example-arrayofzeroes)
    -   [Alternatives considered](#alternatives-considered)
        -   [Explicit inverses](#explicit-inverses)
        -   [Make alternatives be pattern functions implicitly](#make-alternatives-be-pattern-functions-implicitly)
-   [Shareable storage](#shareable-storage)
    -   [Initialization](#initialization)
        -   [Alternatives considered](#alternatives-considered-1)
    -   [Pattern matching evaluation order](#pattern-matching-evaluation-order)
-   [The `alternatives` block](#the-alternatives-block)
    -   [Alternatives considered](#alternatives-considered-2)
        -   [More concise syntax](#more-concise-syntax)
        -   [Marking alternatives individually](#marking-alternatives-individually)
        -   [Different syntax for `closed`](#different-syntax-for-closed)
-   [`choice`](#choice)
    -   [Alternatives considered](#alternatives-considered-3)
        -   [Separate support for enumerated types](#separate-support-for-enumerated-types)
        -   [Different spelling for `choice`](#different-spelling-for-choice)
        -   [Extend `alternatives` instead](#extend-alternatives-instead)
-   [Alternatives considered](#alternatives-considered-4)
    -   [Indexing by type](#indexing-by-type)

<!-- tocstop -->

## Problem

Many important programming use cases involve values that are most naturally
represented as having one of several alternative forms (called _alternatives_
for short). For example,

-   Optional values, which are pervasive in computing, take the form of either
    values of some underlying type, or a special "not present" value.
-   Functions that cannot throw exceptions often use a return type that can
    represent either a successfully computed result, or some description of how
    the computation failed.
-   Nodes of a parse tree often take different forms depending on the grammar
    production that generated them. For example, a node of a parse tree for
    simple arithmetic expressions might represent either a sum or product
    expression with two child nodes representing the operands, or a
    parenthesized expression with a single child node representing the contents
    of the parentheses.
-   Boolean values take the form of either a "true" value or a "false" value.

What unites these use cases is that the set of alternatives is fixed by the API,
it is possible for user code to determine which alternative is present, and
there is little or nothing you can usefully do with such a value without first
making that determination.

Carbon needs to support defining and working with types representing such
values. Following Carbon's principles, these types need to be easy to define,
understand, and use, and they need to be safe -- in ordinary usage, the type
system should ensure that user code cannot accidentally access the wrong
alternative.

Furthermore, it needs to be possible for type owners to customize the
representations of these types. For example, sum types usually need a
"discriminator" field to indicate which alternative is present, but since it
typically has very few possible values, it can often be packed into padding, or
even the low-order bits of a pointer. Other sum types avoid an explicit
discriminator, and instead reserve certain values to indicate separate
alternatives. For example, a typical C-style pointer can be thought of as an
optional type, with a special null value indicating that no pointer is present,
because the platform guarantees that the null byte pattern is never the
representation of a valid pointer. This sort of customization inherently creates
a risk of implementation bugs that break type safety, but it must be possible
for correctly-implemented customizations to avoid changing the API, and hence
avoid weakening the static safety guarantees for users.

## Background

The terminology in this space is quite fragmented and inconsistent. This
proposal will use the term _sum types_ to refer to types of the kind described
in the problem statement. Note that "sum type" is not being proposed as a
specific Carbon feature, or even as a precisely defined term of art; it is
merely an informal way for this proposal to refer to its motivating use cases,
in much the same way that a structs proposal might refer to "value types".

Carbon as currently envisioned is already capable of approximating support for
sum types. In particular, [pattern matching](/docs/design/pattern_matching.html)
gives us a natural way to express querying which alternative is active, and then
performing computations on that active alternative, which as discussed above is
the primary way of interacting with a sum type. For example, a value-or-error
type `Result(T, Error)` could be implemented like so:

```
// Result(T, Error) holds either a successfully-computed value of type T,
// or metadata about a failure during that computation, or a singleton
// "cancelled" state indicating that the computation successfully complied with
// a request to halt before completion.
struct Result(Type:$$ T, Type:$$ Error) {
  // 0 if this represents a value, 1 if this represents an error, 2 if this
  // represents the cancelled state.
  var Int: discriminator;
  var T: value;
  var E: error;

  fn Success(T: value) -> Result(T, Error) {
    return (.discriminator = 0, .value = value, .error = Error());
  }

  fn Failure(Error: error) -> Result(T, Error) {
    return (.discriminator = 1, .value = T(), .error = error);
  }

  var Result(T, Error):$$ Cancelled =
    (.discriminator = 2, .value = T(), .error = Error());
}
```

A typical usage might look like:

```
fn ParseAsInt(String: s) -> Result(Int, String) {
  var Int: result = 0;
  var auto: it = s.begin();
  while (it != s.end()) {
    if (*it < '0' || *it > '9') {
      return Result(Int, String).Failure("String contains non-digit");
    }
    result += *it - '0';
    result *= 10;
  }
  return Result(Int, String).Success(result);
}

fn GetIntFromUser() -> Int {
  while(True) {
    var String: s = UserPrompt("Please enter a number");
    match (ParseAsInt(s)) {
      case (.discriminator = 0, .value = Int: value, .error = String: _) => {
        return value;
      }
      case (.discriminator = 1, .value = Int: _, .error = String: error) => {
        Display(error);
      }
      case .Cancelled => {
        // We didn't request cancellation, so something is very wrong.
        Terminate();
      }
      default => {
        // Can't happen, because the above cases are exhaustive.
        Assert(False);
      }
    }
  }
}
```

However, this code has several serious deficiencies:

-   The implementation details of `Result` are not encapsulated. This makes the
    `Result` API unsafe: nothing prevents client code from accessing `.value`
    even when `.discriminator` is not 0. This also makes the patterns extremely
    verbose.
-   `.value` and `.error` must both be live throughout the `Result`'s lifetime,
    even when they are not meaningful. Consequently, `Success` must populate
    `.error` with a default-constructed dummy value (and so it won't work if
    `Error` is not default-constructible), `Failure` must do the same for
    `.value`, and `Cancelled` must do the same for both. Furthermore, `Result`
    is bloated by the fact that the two must have separately-allocated storage,
    even though at most one at a time actually stores any data.
-   `.discriminator` should never have any value other than 0, 1, or 2, but the
    compiler can't enforce that property when `Result`s are created, or exploit
    it when `Result`s are used. So, for example, the `match` must have a
    `default` case in order for the compiler and other tools to consider it
    exhaustive, even though that default case should never be entered.

It's also worth noting that the definition of `Result` is largely boilerplate.
Conceptually, the only information needed to specify this type is the names and
parameter types of the two factory functions, plus the fact that every possible
value of `Result` is uniquely described by the name and parameter values of a
call to one of those two functions. Given that information, the compiler could
easily generate the rest of the struct definition. This generated implementation
may not always be as efficient as a hand-coded one could be, but in a lot of
cases that may not matter.

This code arguably exhibits another problem as well: the `return` statements in
`ParseAsInt` are quite verbose, due to the need to explicitly qualify the
function calls with `Result(Int, String)`. In fact, developers might prefer to
avoid having a function call at all, especially in the success case, and instead
rely on implicit conversions to write something like `return result;`. This
proposal will not address that problem, because it appears to be orthogonal to
the design of sum types.

## Proposal

To summarize, the previous section identified three missing features in Carbon,
which together prevent it from adequately supporting sum types:

-   There is no way for pattern matching to operate through an encapsulation
    boundary.
-   There is no way to manually control the lifetimes of subobjects, or enable
    them to share storage.
-   There is no way for a type to specify that a given set of patterns is
    exhaustive.

I propose supporting sum types by introducing three language features to supply
the missing functionality, as well as a sugar syntax for defining a sum type
without micromanaging the implementation details. These features are largely
separable, although there are some dependencies between them, so their detailed
design will be addressed in future proposals, and the details discussed here
should be considered provisional. This proposal merely establishes the overall
design direction for sum types, in the same way that [p0083](p0083.md)
established the overall design direction for the language as a whole.

To support encapsulation in pattern matching, I propose introducing the concept
of a _pattern function_, which is a function that can be invoked as part of a
pattern, even with arguments that contain placeholders. Pattern functions can
only contain the sort of code that could appear directly in a pattern, but they
let us define reusable pattern syntaxes that can do things like encapsulate
hidden implementation details of the object they're matching.

To support manual lifetime control and storage sharing, I propose introducing a
`Storage` type, which represents a fixed-size region of untyped memory and
provides operations for creating and destroying within it, as well as a
`ToStorage` operation for obtaining the object representation of a value.

To allow types to specify an exhaustive set of patterns, as well as to solve
certain problems with accessing untyped memory in a pattern function, I propose
introducing `alternatives { ... }` as a grouping construct within a struct
definition. The elements of an `alternatives` block are pattern functions whose
return type is the enclosing struct type, and they are required to be both
exhaustive and unambiguous, meaning that for any possible value of the type, it
must be possible to obtain it as the return value of exactly one of the
alternatives. Alternatives that take no arguments, which represent singleton
states such as `Cancelled`, can instead be written as static constants. An
`alternatives` block can be marked `closed`, which indicates that client code
can assume no new alternatives will be added in the future.

Using these features, the `Result(T, Error)` example can be rewritten as
follows:

```
struct Result(Type:$$ T, Type:$$ Error) {
  var Int: discriminator;

  var Storage(Max(Sizeof(T), Sizeof(Error)),
              Max(Alignof(T), Alignof(Error))): storage;

  closed alternatives {
    pattern Success(T: value) -> Self {
      return (.discriminator = 0, .storage = ToStorage(value));
    }

    pattern Failure(Error: error) -> Self {
      return (.discriminator = 1, .storage = ToStorage(error));
    }

    var Self:$$ Cancelled = (.discriminator = 2);
  }
}
```

The code for `ParseAsInt` is unchanged, and the rest of the usage example would
look like:

```
fn GetIntFromUser() -> Int {
  while(True) {
    var String: s = UserPrompt("Please enter a number");
    match (ParseAsInt(s)) {
      case .Success(var Int: value) => {
        return value;
      }
      case .Failure(var String: error) => {
        Display(error);
      }
      case .Cancelled => {
        // We didn't request cancellation, so something is very wrong.
        Terminate();
      }
    }
  }
}
```

To allow users to define sum types without micromanaging the implementation
details, I propose introducing `choice` as a convenient syntax for defining a
sum type by specifying only the declarations of the set of alternatives. From
that information, the compiler generates an appropriate object representation,
and synthesizes definitions for the alternatives and special member functions.

Our manual implementation of `Result` doesn't really benefit from having direct
control of the object representation, and doesn't seem to have any additional
API surfaces, so it's well-suited to being defined as a choice type instead:

```
closed choice Result(Type:$$ T, Type:$$ Error) {
  pattern Success(T: value) -> Self;
  pattern Failure(Error: error) -> Self;
  var Self:$$ Cancelled;
}
```

We don't yet have enough of a design for variadics to give an example of a
Carbon counterpart for `std::variant<Ts...>`, but a variant with exactly three
alternative types could be written like so:

```
choice Variant(Type:$$ T1, Type:$$ T2, Type:$$ T3) {
  pattern Value(T1: value) -> Self;
  pattern Value(T2: value) -> Self;
  pattern Value(T3: value) -> Self;
}
```

As an example of a case where manual control of the representation is useful,
here's an example of a type that implements an optional pointer value without
requiring additional storage for a discriminator:

```
struct OptionalPtr(Type:$$ T) {
  var Storage(Sizeof(Ptr(T)), Alignof(Ptr(T))): storage;

  alternatives {
    pattern Value(Ptr(T): ptr) -> Self { return (.storage = ToStorage(ptr)); }
    var Self:$$ Null = (.storage = ArrayOfZeros(Sizeof(Ptr(T))));
  }
}
```

Note that `ArrayOfZeros` can be defined as a pattern function, but only with
some possibly surprising extensions to Carbon's pattern language. See below for
details.

## Pattern matching

This proposal presupposes the following requirements for pattern matching, which
will inform the design of pattern functions:

-   Carbon pattern matching must not only be able to determine whether a pattern
    matches a value, and bind values to its variables, but also be able to
    select the _best_ pattern when more than one matches. Patterns are partially
    ordered by specificity, so for example `(Int: x, 1)` is a better match than
    `(Int: x, Int: y)` in the cases where they both match. This is not a total
    order, or even a weak order (intuitively, a total order with "ties"); for
    example, there is no ordering between `(Int: x, 1, 1)` and either
    `(1, Int: y, Int: z)` or `(1, 1, Int:z)`, but we can't just say that all
    three are "tied", because `(1, 1, Int: z)` is more specialized than
    `(1, Int: y, Int: z)`. This order should at least form a
    [lattice](<https://en.wikipedia.org/wiki/Lattice_(order)>), but that's not
    directly relevant here.
-   Carbon must be able to determine whether a given set of patterns is
    _exhaustive_, meaning that for any possible value at least one of them will
    match. It must also be able to determine whether a set of patterns is
    _ambiguous_, meaning that the set contains two or more patterns that are not
    ordered with respect to each other, and that can match the same value.

These requirements are highly desirable in any pattern matching system, but they
are hard requirements if we want to treat C++-like overload resolution as a form
of pattern matching.

## Pattern functions

Pattern functions have the same declaration syntax as ordinary functions, except
that they are introduced with `pattern` rather than `fn`. However, the function
body is required to be a single `return` statement whose operand expression is a
valid pattern, with each use of a function parameter acting as a variable
binding. One consequence of that constraint is that a given function parameter
cannot be accessed more than once when evaluating the pattern function.

It seems likely that pattern functions will be required to be inline, because
they will probably need to generate very different code depending on the
structure of their arguments, particularly if the arguments contain
placeholders.

The body of a pattern function must consist of a single `return` statement whose
operand is not only a valid expression, but also would be a valid pattern if any
uses of the function parameters were replaced with variable binding patterns.
Furthermore, the semantics of the expression must mirror the semantics of the
pattern. For example, this is a valid pattern function:

```
pattern MakeStruct(Int: x, Int: y) -> MyStruct {
  return (.x = x, .y = y);
}
```

because `(.x = Int: x, .y = Int: y)` is a valid pattern that is guaranteed to
match the result of any call to `MakeStruct` and set `x` and `y` to that call's
arguments, and conversely any value that matches `(.x = Int: x, .y = Int: y)` is
guaranteed to be equal to `MakeStruct(x, y)`.

This mirroring requirement ensures that we can run the function both forwards
and backwards, either evaluating the function on some arguments to produce a
return value, or pattern matching on a purported return value to deduce the
arguments that produced it. The major drawback of this approach is how it
constrains the expressiveness of pattern functions, and it's useful to consider
the forward and reverse aspects of that constraint separately.

### Constraints on function evaluation

In the forward direction, the mirroring requirement is clearly a very limiting
constraint: most function bodies do not consist of a single return statement,
and most expressions are not valid patterns. So it's reasonable to wonder
whether pattern functions have enough expressive power. So far I've come across
two notable examples of code that we are likely to want to express in pattern
functions, but that may not satisfy the mirroring requirement.

The first example is that it seems very difficult to allow a pattern function to
express in-place initialization, such what C++'s placement-new does. In this
proposal, I work around that problem with a special case rule that essentially
treats `storage = ToStorage(obj)` as constructing a copy of `obj` in-place in
the untyped array `storage`, but only when initializing `storage`. However, this
is decidedly a hack. See the section on shareable storage below for details on
this issue.

The second example is memory allocation. We will inevitably want pattern
functions to be able to create, and match, objects that store data on the heap.
In principle this seems feasible: for example, Carbon might have a `Box(T)` type
that represents a heap-allocated `T` object, and a `MakeBox` function for
creating a `Box(T)` from a `T` value. We could then use `MakeBox` in pattern
functions. For example, this is a pattern function that creates/matches objects
of type `IndirectInt`, a hypothetical integer-like type that stores its data on
the heap:

```
struct IndirectInt {
  var Box(Int): i_ptr;
}

pattern IndirectIntOf(Int: i) -> IndirectInt {
  return (.i_ptr = MakeBox(Int, i));
}
```

For this to work, two `Box(T)` values must be considered equal when the `T`
values they hold compare equal, rather than when they are literally the same `T`
object. This is important not only for pattern matching, but also for situations
like automatically generating a struct's comparison operators. Note that other
than these "deep" equality semantics, `Box(T)` would be very similar to C++'s
`std::unique_ptr<T>`, and would probably play a comparable role in the Carbon
ecosystem.

The problem here is that `MakeBox` has to both read and mutate some state that's
not part of its arguments, namely the state of the memory allocator. It's not
clear that we can allow pattern functions to have side effects, or to depend on
side inputs, because those operations are likely to be very difficult to invert.
In this case that mutable state has no effect on the actual value, at least as
far as equality comparison is concerned, but it's not clear whether or how we
can take advantage of that.

In both cases, it seems very possible that we could extend the pattern language
with new primitives that encapsulate the non-invertible part of these
operations, but it's too soon to say what they would look like.

### Constraints on pattern matching

In the reverse direction, the mirroring requirement may prevent us from using
certain pattern matching syntaxes inside pattern functions, namely syntaxes that
don't correspond to expression syntaxes. However, that appears to be a tolerable
constraint, at least for the use cases we're interested in here.

Pattern matching syntaxes in other languages generally don't have many such
syntaxes, but there are a few. The following sections discuss the most notable
examples I've found, and discuss how they affect the viability of this design.

#### Underdetermined patterns

One corollary of the mirroring requirement is that the named variable bindings
in the pattern must uniquely determine the value being matched. This precludes
any pattern which "loses information" about the matched value. Most notably,
this means a pattern function cannot contain wildcard patterns, such as `_`, or
Rust's `..` partial wildcard.

As a more complex example, several languages support combining multiple patterns
disjunctively, yielding a pattern that matches when any of the subpatterns
match. For example, in Rust the pattern `(0, x) | (x, 0)` matches any pair whose
first or second element is `0`, and binds `x` to the other element. Such
patterns lose information about which case successfully matched, and so they
cannot occur in pattern functions.

In such cases, the problem could be partially worked around by changing the code
to preserve the lost information. For example, the `_` pattern can be replaced
with a named function parameter. Note that although `_` cannot appear in a
pattern function, it can appear as an argument to a pattern function in a
top-level pattern, so the caller can discard that part of the pattern if it's
not useful to them.

In the case of disjunctive patterns, preserving the lost information would
essentially require a pattern syntax for defining a variable binding that
records which alternative was selected. Or, to state the problem in the mirrored
sense, we need an expression syntax that uses a variable to select which of
several cases to return. Fortunately, Carbon is likely to have such a syntax
anyway, namely `match` expressions. If we also allow `match` in patterns, a
pattern like `(0, x) | (x, 0)` might be written as:

```
match c {
  case 0 => (0, auto:x)
  case 1 => (auto:x, 0)
  default => Assert(False)
}
```

Note that inside a pattern, the case labels must be expressions, whereas the
match operand and the case bodies can be patterns. Interestingly, this is the
exact opposite of the rule for `match` outside of patterns: in effect, switching
from forward to reverse evaluation reverses the direction of the arrows.

Inside a pattern function, the wildcard and variable bindings would need to be
replaced with function parameters (thereby making both sides expressions):

```
match c {
  case 0 => (0, x)
  case 1 => (x, 0)
  default => Assert(False)
}
```

This is evidently more verbose than the Rust version, but that could be
mitigated with some syntax adjustments, such as a more concise way of asserting
that a match is exhaustive.

The primary difficulty with `match` patterns is that they are prone to
ambiguity. For example, when matching with `(0, 0)`, it's not obvious what value
should be deduced for `c`. However, this problem is not unique to `match`
patterns, but is inherent in any sort of disjunctive patterns. Even though Rust
patterns don't provide an explicit indicator of which case was matched,
suitably-chosen variable bindings can indirectly expose that information. It
appears that Rust chooses the first match, but Carbon could in principle choose
the best match, or require the patterns to be unambiguous. Here again, it's as
if the `=>` arrow has switched directions, because the same ambiguity problem,
and the same possible resolutions, come up on the _left_ side of the arrows when
the `match` isn't in a pattern matching context.

All that being said, it's not clear how important it is to support disjunctive
patterns (Swift doesn't, for example), so it may be simpler to avoid the issue
by not supporting them.

#### Match guards

Several languages support _match guards_, which use a predicate to restrict
pattern matching. For example, in Rust the pattern `Some(x) if x < 5` matches an
`Optional<Int>` value, and binds `x` to the `Int` it contains, only if that
value is less than 5. Match guards are always expressions, not patterns -- for
example, a pattern like `Some(x) if _ < 5` would be nonsensical.

Match guards generally do not satisfy the mirroring requirement; for example,
`Some(x) if x < 5` is not a valid Rust expression. This may be a problem,
because we are likely to want match guards for Carbon, although it's not clear
if there will be important use cases for match guards inside pattern functions.
If there are, a very plausible path forward would be to allow pattern functions
to contain assertions. In the forward direction, these would behave in the
expected way, documenting and optionally enforcing preconditions on the function
call. In the reverse direction, they would function as match guards:

```
fn Foo(Int: x) -> Optional(Int) {
  Assert(x < 5);
  return Some(x);
}
```

This does somewhat complicate the mapping between functions and patterns, but
the additional complexity seems quite tolerable.

Note that some languages provide a way for type authors to specify when two
values are considered to match. For example, in Swift you can overload the `~=`
operator, which returns a boolean indicating whether the left-hand side matches
the right. Both sides of the operator are values rather than patterns, so this
mechanism is effectively syntactic sugar for match guards, or an alternative to
them.

#### Subpattern bindings

Some languages support binding an identifier to a subpattern, rather than only
using identifiers as placeholders. This generally requires a separate syntax.
For example, in Rust the syntax `id @ p` matches the same values as the pattern
`p`, but also binds the name `id` to the matched value. The mirroring
requirement would imply that in an expression, `id @ p` evaluates to the value
of `id`, and also asserts that `id` matches `p`. These semantics seem
conceptually straightforward, but awkardly non-orthogonal and not very useful,
so if Carbon has this syntax at all, we could probably safely limit it to
patterns and pattern functions.

It's interesting to note that we can interpret `p` as a pattern even in the
forward direction (because the primary behavior is supplied by `id`), so we can
probably allow it to contain wildcards. However, it's not clear whether that
will be useful in practice.

#### Pattern-specific sugar syntaxes

In Swift, if `x` is a pattern that matches values of type `T`, `x?` is a pattern
that matches values of type `Optional<T>` that contain a value matching `x`.
However, if `x` is an expression of type `T`, `x?` will generally not be a valid
expression, so such patterns don't satisfy the mirroring requirement. However,
`x?` is purely syntactic sugar for `.some(x)`, which does satisfy the mirroring
requirement. I would tentatively recommend that we avoid introducing
pattern-specific sugar syntaxes for simplicity, but even if we do, by definition
it will always be possible to avoid using them in pattern functions.

#### Avoidable inconsistencies

Swift has an expression syntax `x as T`, which casts the value `x` to static
type `T`. Swift also has a pattern syntax `x as T`, which matches a
dynamically-typed value if its dynamic type is `T`, and its value matches `x`.
Although syntactically identical, these syntaxes don't mirror each other: in the
pattern form, `x` has static type `T`, whereas the expression form is useful
precisely when `x` does _not_ have static type `T`. For example, the pattern
`0 as Int` does not match the expression `0 as Int`, but does match the
expression `0 as Any`. However, this inconsistency doesn't seem necessary,
especially given that in Carbon, the variable binding syntax includes a
mandatory type, so the Carbon counterpart to Swift's `x as T` will presumably be
something like `T: x` or `T: x as Any`, depending on whether converting `T` to
`Any` requires an explicit cast, and that satisfies the mirroring requirement.

### Worked example: `ArrayOfZeroes`

The `OptionalPtr` example above relies on `ArrayOfZeroes`, a pattern function
that takes an integer `N` and returns an `Array(Byte, N)` whose elements are all
zero. It is possible to implement such a pattern function, but it requires some
extensions to Carbon's pattern language that may be surprising:

```
pattern ArrayOfZeroes(UInt:$$ N) -> Array(Byte, N) {
  Array(Byte, N)(ListOfZeroes(N));
}

pattern ListOfZeroes(UInt:$$ N) -> List(Byte) {
  return match (N) {
    case 0 => { .Nil }
    case (UInt: M)+1 => { .Cons(Byte(0), ListOfZeroes(M)); }
  };
}
```

This design requires Carbon to support `match` expressions inside patterns, as
discussed above in the section on underdetermined patterns. More surprisingly,
it requires the ability to use `+1` as a pattern matching operator on unsigned
integers. This is novel in my experience, but I hope the meaning of the code is
relatively clear. Furthermore, although it may seem ad-hoc, it's theoretically
well founded: we're effectively destructuring the unary representation of
counting numbers as `0+1+1+...+1`. In other words, we're treating `UInt` as
though it were a sum type, analogous to

```
closed choice UInt {
  var Self:$$ Zero;
  pattern Successor(Uint) -> Self;
}
```

We could even use a named `Successor` function in place of `+1`, if we wish to
avoid uncertainty about what kinds of arithmetic expressions can appear in
patterns. Whatever the syntax, the ability to use `+1` in patterns is a
fundamental building block for creating pattern functions that involve counting.

This implementation also presupposes a type (called `List(Byte)` here) that can
be used to initialize an `Array`, and that supports pattern matching on the
empty list (spelled `.Nil` here) and on destructuring the first element from a
list (spelled `.Cons(first, rest)` here). These seem like reasonable
requirements for whatever type Carbon uses to represent array literals. If
Carbon uses tuples for that purpose, I expect an approach equivalent to the
above would still work, but I can't directly demonstrate that until we have a
design for variadics.

### Alternatives considered

#### Explicit inverses

Instead of restricting pattern functions to a narrow sublanguage that's usable
in both patterns and expressions, we could allow developers to explicitly
specify the code that should be executed during pattern matching, as well as the
code that should be executed during expression evaluation. This obliges them to
determine the correct inverse computation themselves, but permits them to
express it in terms of the full Carbon language.

However, as discussed earlier, Carbon pattern matching needs to be able to not
only determine whether a pattern matches, but also rank patterns, and determine
whether a set of patterns is exhaustive and/or ambiguous. Defining a custom
pattern in terms of arbitrary forward and reverse functions doesn't give the
compiler enough information to do those things, so the developer would need to
supply additional information in some way, and it's not at all clear how that
would work.

Furthermore, this approach opens the door to user-defined pattern syntaxes that
do not correspond to an expression syntax (as with Swift's `?`), or worse,
user-defined syntaxes that can be used in both expressions and patterns, but
have different meanings in the two contexts (as with Swift's `x as T`). Of
course, that may not be a problem -- I find Swift's choices surprising, but I
don't have any evidence that they've caused confusion for users. However, Carbon
will be breaking new ground by allowing user code to define pattern-matching
abstractions, so it seems advisable to impose fairly strict semantic constraints
on them, at least initially.

#### Make alternatives be pattern functions implicitly

Every function in an `alternatives` block must be a pattern function, and this
proposal has no need for pattern functions outside of `alternatives` blocks.
That being the case, we could eliminate the `pattern` keyword, and instead
specify that functions within an `alternatives` block have special semantics.

I have opted not to do so here because I think it's somewhat clearer to mark
individual functions, and because the ability to define a pattern matching
shorthand seems likely to be useful outside of the context of sum types. For
example, proposal [0087](https://github.com/carbon-language/carbon-lang/pull/87)
suggests introducing an `NTuple` function as a built-in primitive in order to
support variadics, but given some plausible extensions, it could probably be
implemented as an ordinary pattern function in library code.

## Shareable storage

This approach to sum types imposes relatively few requirements on the language
features used to implement shareable storage (meaning, storage that can be
inhabited by different objects at different times), and so this proposal doesn't
describe them in much detail. I'm proposing an untyped byte buffer here because
it's more general, but union types along the lines of proposal
[0139](https://github.com/carbon-language/carbon-lang/pull/139) would work just
as well.

Regardless of the form that shareable storage takes, it won't be able to
intrinsically keep track of whether it currently holds any objects, or the types
or offsets of those objects, because that would require it to maintain
additional hidden storage, and a major goal of this design is to give the
developer explicit control of the object representation. Consequently, it is not
safe to copy, move, assign to, or destroy shareable storage unless it is known
not to be inhabited by an object.

This means that in the general case, the compiler will not be able to generate
safe default implementations for any special member functions of types that have
shareable storage members. However, it can do so if the shareable storage is
part of a sum type, because the `alternatives` block contains enough information
for it to infer what objects are present, by effectively pattern-matching on the
sum type object.

In order for non-sum types to define those functions manually, the design for
shared storage will need to include operations for creating and destroying
objects within it, analogous to placement-`new` and pseudo-destructor calls in
C++.

### Initialization

The most challenging requirement that this approach imposes on the design of
shareable storage is that it must be possible to initialize it from an instance
of any of the values that it can represent, and to do so inside a pattern or
pattern function.

This proposal represents that initialization using a `ToStorage` function call,
such as `.storage = ToStorage(success)` in the example above. However, the
semantics of this code may be somewhat surprising: it doesn't merely copy the
underlying bytes of `success` into `.storage`, it actually creates a new `T`
object within `.storage`, which is directly initialized from `success`. This
assumes that Carbon has some equivalent to C++'s "guaranteed RVO"; this code
cannot be understood as creating a temporary `Storage` array representing a `T`
value and then moving it into `.storage`, because it is not safe to move an
inhabited `Storage` storage array, as discussed above.

`ToStorage` is presented here as a function, but it can't actually be
implemented as a function within the Carbon language. Recall that our motivating
use cases involve invoking `ToStorage` inside pattern functions, so it needs to
be a pattern function itself, assuming it's a function at all. If it were
implemented as Carbon code, it would need to consist of a single expression that
initializes a `Storage` from an object, and the whole problem we're trying to
solve here is to make it possible to write such an expression. Consequently, we
may wish to give it a different syntactic form. This operation is in many ways a
type cast, so the syntactic choice here will depend heavily on the syntax of
Carbon's other casts.

At a deeper level, the problem is that the whole notion of allowing multiple
objects to successively share the same storage is inherently procedural (because
it involves changes in state over time), but pattern matching is fundamentally
descriptive, and hence functional. A design in which user-defined patterns can
be expressed in terms of procedural forward and reverse functions would avoid
this whole problem, by allowing us to express storing the alternative in terms
of procedural code (such as the equivalent of C++'s placement-`new`) rather than
initialization.

#### Alternatives considered

It is tempting to try to mitigate those problems by making the conversion
implicit, so that the code looks like `.storage = success`. However, this would
mean that `Storage` can be implicitly initialized from a value of any type, and
such extremely broad implicit conversions tend to be highly problematic. For
example, consider the definition of `.Null` in the `OptionalPtr` example:

```
var Self:$$ Null = (.storage = ArrayOfZeros(Sizeof(Ptr(T))));
```

If `Storage` were implicitly convertible from any type, and that conversion
caused an object to be created within the `Storage`, this code would no longer
just set the bytes of `.storage` to zero: it would also actually create an
`Array(Byte)` object within `.storage`, which would then need to be subsequently
destroyed before `.storage` is destroyed, or used to store a pointer value.
There are various ways to finesse this issue, but they all involve adding
additional special-case rules in order to avoid or mitigate this consequence of
the general rules.

We don't propose this approach because it doesn't really address the problems
with `ToStorage`; it merely obscures those problems, while introducing a new
problem that would itself require further work to obscure. However, it's worth
noting that the drawbacks of this approach are much less severe if we implement
shared storage using a union rather than an untyped byte array, because the
implicit conversion would not need to be universal.

### Pattern matching evaluation order

As discussed above, Carbon's pattern language must be restricted to operations
that the compiler can automatically invert. The inverse of creating an object of
type `T` in shareable storage is reading an object of type `T` out of shareable
storage. However, since shareable storage will not track the types or offsets of
the objects it contains, this inverse operation is safe only if the shared
storage is known to contain an object of type `T` at that offset.

Consequently, pattern matching evaluation must occur in an order that guarantees
that a suitable object is present before it is loaded from shareable storage.
Correspondingly, the author of the code must structure the pattern match in such
a way that the compiler can find an appropriate evaluation order.

At least for our motivating use cases, this appears to be intuitively
straightforward. Consider the `Result` example we saw earlier:

```
struct Result(Type:$$ T, Type:$$ Error) {
  var Int: discriminator;

  var Storage(Max(Sizeof(T), Sizeof(Error)),
              Max(Alignof(T), Alignof(Error))): storage;

  closed alternatives {
    pattern Success(T: value) -> Self {
      return (.discriminator = 0, .storage = ToStorage(value));
    }

    pattern Failure(Error: error) -> Self {
      return (.discriminator = 1, .storage = ToStorage(error));
    }

    var Self:$$ Cancelled = (.discriminator = 2);
  }
}

...

match (ParseAsInt(s)) {
  case .Success(var Int: value) => {
    return value;
  }
  case .Failure(var String: error) => {
    Display(error);
  }
  case .Cancelled => {
    Terminate();
  }
}
```

When matching `ParseAsInt(s)` with the `Success` pattern, the compiler can
observe that no other alternative sets `.discriminator` to `0`, so it can safely
load a `T` value out of storage once it has successfully matched
`.discriminator` with `0`.

The `OptionalPtr` example is somewhat more subtle:

```
struct OptionalPtr(Type:$$ T) {
  var Storage(Sizeof(Ptr(T)), Alignof(Ptr(T))): storage;

  alternatives {
    pattern Value(Ptr(T): ptr) -> Self { return (.storage = ToStorage(ptr)); }
    var Self:$$ Null = (.storage = ArrayOfZeros(Sizeof(Ptr(T))));
  }
}
```

In this case, the compiler can observe that `.storage` must hold either a `T`
value or an all-zeros bit pattern, so it can safely attempt to match the
`.Value` case only after it has ruled out the `.Null` case, which it can
evaluate unconditionally because that case only requires loading raw bytes,
which is always safe. Consequently, we may want to require that a pattern match
that looks for `.Value` must also have an explicit `.Null` case (rather than a
generic `default` case), so as to make it clear to the reader that the `.Null`
case is being evaluated. If Carbon specifies that pattern matching evaluates
cases in order, we would presumably also require that the `.Null` case is above
the `.Value` case.

We will need to formalize the intuition behind those examples, in the form of
concrete language rules that are strict enough for the compiler to feasibly
perform that sort of symbolic reasoning, and yet permissive enough that type
authors can feasibly understand and follow them, and the compiler can produce
intelligible error messages when they are violated. Furthermore, it would be
strongly preferable if the compiler could detect any errors purely by inspecting
the type definition, rather than delaying them until the type is actually used
in pattern matching.

The design of those rules is deferred to a subsequent proposal. However, one key
requirement is already clear: the compiler must be able to identify all of the
type's alternatives, and know that they exhaustively describe all possible
values of the type. This is a key reason for introducing the `alternatives`
block. For similar reasons, we may also need to introduce some syntax for
marking a single pattern function as being exhaustive (`MakeUnique`, for
example), but such use cases are out of scope for this document because they
don't involve sum types.

## The `alternatives` block

An `alternatives` block designates a set of pattern functions and static
constants as representing an exhaustive and unambiguous set of alternatives for
the type. By defining an `alternatives` block, the type author is guaranteeing
that every possible value of the type matches exactly one of the alternatives.
Consequently, the design of this feature will need to determine how Carbon
handles violations of this guarantee without compromsing Carbon's safety goals.

Although alternatives are always exhaustive as far as the language semantics are
concerned, by default user code will be required to treat them as
non-exhaustive. For example, a `match` statement that has cases for the
alternatives of a sum type will be required to have a `default` case, even if it
also has patterns that match all of the declared alternatives. This ensures that
sum types can be extended with new alternatives without breaking any existing
code.

However, code in the same
[library](/docs/design/code_and_name_organization/#libraries) as the choice type
is not subject to this restriction. Requiring a `default` has little benefit for
that code, because it can easily be updated when a new alternative is added,
without creating any version-skew concerns. Conversely, requiring a `default`
would have higher costs: code that's part of the sum type's API is more likely
to be required to explicitly handle every alternative (consider, for example, an
`Unparse` method on a sum type representing a parse tree). When that's the case,
omitting a `default` provides a build-time guarantee that every alternative has
been handled.

Declaring the alternatives with `closed alternatives` rather than `alternatives`
allows all code to treat the alternatives as exhaustive.

### Alternatives considered

#### More concise syntax

We could introduce a special syntax for declaring alternatives, rather than
using the existing syntaxes for pattern functions and static variables. Such a
syntax could be substantially more concise, because it could omit the components
of a function/variable declaration that are just boilerplate in the context of a
set of alternatives. For example, the alternatives of the `Result(T, Error)`
struct might look like this:

```
closed alternatives {
  Success(T: value) { ... }
  Failure(Error: error) { ... }
  Cancelled = (.discriminator = 2);
}
```

The same simplifications could be applied to `choice` types, so that for example
the `choice` version of `Result` could look like this:

```
choice Result(Type:$$ T, Type:$$ Error) {
  Success(T);
  Failure(Error);
  Cancelled;
}
```

However, this brevity would come at the cost of consistency: there would now be
two structurally different syntaxes for declaring functions, and two
structurally different syntaxes for declaring static constants.

#### Marking alternatives individually

Rather than making `alternatives` a separate block, we could define a syntax for
marking alternatives individually. If we choose not to support pattern functions
that aren't alternatives, this syntax could be an introducer that takes the
place of `pattern`. This would also synergize well with the option of having a
more concise syntax for alternatives, which otherwise may have problems with the
lack of an introducer.

The primary drawback of this approach is that the lack of explicit grouping
could make it more difficult for readers (and perhaps even the compiler) to know
when all the alternatives have been enumerated. It would also mean that we can't
support the admittedly unlikely use case of defining a sum type that has
multiple complete sets of alternatives.

#### Different syntax for `closed`

The `closed` syntax should be considered little more than a placeholder. It's
somewhat unconventional for a modifier to come before an introducer, as with
`closed alternatives`. Reversing the order would fix that problem, but
`alternatives closed` reads quite awkwardly as English. Making `closed` a
keyword would prevent developers from using `closed` as an identifier, which may
be too high a cost for such a niche use case. We could fix that by making it an
attribute rather than a keyword, but it's not clear that Carbon will have
attributes, much less what the syntax would be.

It may be surprising that there is no corresponding `open alternatives` syntax,
but `open` would be meaningless syntactic noise unless we made it mandatory, and
making it mandatory would be poor ergonomics, because developers would be forced
to make an up-front decision between the two, rather than relying on a safe
default. Furthermore, reserving `open` as a keyword seems even more problematic
than reserving `closed`.

## `choice`

A choice type definition has the same general form as an `alternatives` block,
except that:

-   It has `choice` and the type name in place of `alternatives`.
-   It need not (and usually won't) be inside a `struct` definition, because it
    defines a new type, rather than specifying part of an enclosing type
    definition.
-   Its members cannot have definitions, because those definitions will be
    provided by the compiler.

The expected implementation of a `choice` type will be very similar to the
`struct` version of `Result` shown earlier, with a discriminator field and a
storage buffer large enough to hold the argument values of the alternatives. Any
alternative parameter types that are incomplete (or have unknown size for any
other reason) will be represented using owning pointers; among other things,
this will allow users to define recursive choice types. The implementation will
be hidden, of course, and the compiler may be able to generate better code, but
we will design this feature to support at least that baseline implementation
strategy.

One consequence is that although the pattern functions of a choice type can be
overloaded (as in the `Variant` example above), they cannot be templates. More
precisely, the parameter types of a pattern function must be fixed without
knowing the values of any of the arguments. To see why, consider a choice type
like the following, which attempts to emulate `std::any`:

```
choice Any {
  pattern Value[Type:$$ T](T value);
}
```

The problem is that since `T` could be any type, and a single `Any` object could
hold values of different types throughout its lifetime, `Any` can't be
implemented using a storage buffer within the `Any` object. Instead, the storage
buffer for the `T` object would have to be allocated on the heap, but then the
compiler would need to decide whether to apply a small buffer optimization, and
if so what size threshold to use, etc. Allowing choice types to be implemented
in terms of heap allocation would make their performance far less predictable,
contrary to Carbon's performance goals, and would have little offsetting
benefit: these sorts of types appear to be rare, and when needed they should be
implemented in library code, where the performance tradeoffs are explicit and
under programmer control.

If may be possible to relax this restriction when and if we have a design for
supporting non-fixed-size types, although it's worth noting that even that would
not give us a way for `Any` to support assignment.

Carbon will probably have some mechanism for allowing a struct to have
compiler-generated default implementations of operations such as copy, move,
assignment, hashing, and equality comparison, so long as the struct's members
support those operations. Assuming that mechanism exists, choice types will
support it as well, with the parameter types of the pattern functions taking the
place of the member types. However, there are a couple of special cases:

-   choice types cannot be default constructible, unless we provide a separate
    mechanism for specifying which alternative is the default.
-   choice types can be assignable, regardless of whether the parameter types
    are assignable, because assigning to a choice type always destroys the
    existing alternative, rather than assigning to it.

A future proposal for this mechanism will need to consider whether to require an
explicit opt-in to generate these operations.

The compiler-generated definitions of a choice type's alternatives are
unspecified, except that they will satisfy the semantic requirements that apply
to all alternatives.

### Alternatives considered

#### Separate support for enumerated types

This proposal supports enumerated types as a special case of choice types.
However, there may be some benefit to providing special-case support for
enumerated types, similar to C++'s `enum`. In particular:

-   We could more easily avoid the `var Self:$$` boilerplate in enumerator
    declarations.
-   We could allow the developer to specify an underlying type, associate a
    specific value of the underlying type with each enumerator, and convert
    between the enum and the underlying type, which are fairly common practices
    in C++ code. When using choice types, these practices can be emulated by
    defining functions that map between the choice type and the underlying type,
    but that requires a substantial amount of error-prone boilerplate.
    Furthermore, those functions can't reliably be no-ops at the hardware level,
    the way they can be with C++ enums.

I am omitting that from this proposal for simplicity, since it's purely
additive, and not necessary for the goals of this proposal.

#### Different spelling for `choice`

The Rust and Swift counterparts of `choice` are spelled `enum`. I have avoided
this because these types are not really "enumerated types" in the sense of all
values being explicitly enumerated in the code. I chose the spelling `choice`
because "choice type" is one of the only available synonyms for "sum type" that
doesn't have any potentially-misleading associations.

#### Extend `alternatives` instead

Instead of introducing `choice`, we could extend `alternatives` with a syntax
for requesting that the definitions be synthesized rather than provided by the
user. For example, perhaps the abbreviated definition of `Result(T, Error)`
could be written as:

```
struct Result(Type:$$ T, Type:$$ Error) {
  alternatives {
    pattern Success(T: value) -> Self;
    pattern Failure(Error: error) -> Self;
    var Self:$$ Cancelled;
  } = default;
}
```

This approach is somewhat more flexible, because it would permit the type owner
to give `Result` additional member functions without forcing them to supply all
the boilerplate associated with the fully handwritten type definition. However,
it still wouldn't be possible to give `Result` additional data members, because
the generated code for the alternatives would have no way to initialize them, so
structs containing an `alternatives` block would be starkly different from ones
that don't. On a related note, this syntax would be somewhat misleading, because
the compiler would be synthesizing not only the definitions of the alternatives,
but also the special member functions and data members.

This approach would also be more verbose, especially vertically, which will be
especially noticeable since these types will probably be quite small in the
common case.

Alternatively, we could unify the two keywords by eliminating `alternatives` and
using `choice` in its place, with the presence of a name acting to distinguish a
`choice` block from a `choice` type. However, it seems liable to be confusing
for the presence or absence of a name to trigger such stark differences in
semantics. Note also that unlike the previous option, this approach doesn't
allow users to extend the type with additional methods without losing compiler
generation of the alternatives and special member functions.

## Alternatives considered

### Indexing by type

Rather than requiring each alternative to have a distinct name (or at least a
distinct function signature), we could pursue a design that requires each
alternative to have a distinct type. With this approach, which I'll call
"type-indexed" as opposed to "name-indexed", Carbon sum types would much more
closely resemble C++'s `std::variant`, rather than Swift and Rust's `enum` or
the sum types of various functional programming languages.

Either approach can be emulated in terms of the other: the `Variant` example
above shows how we can use overloading to emulate type-indexing in our
name-indexed framework, and conversely a type-indexed type like `std::variant`
can model a name-indexed type like `Result(T,E)` by introducing a wrapper type
for each name, leading to something like
`std::variant<Value<T>, Error<E>, Cancelled>` (note that `std::variant<T,E>`
would not work, because `T` and `E` can be the same type). In either case,
emulating the other model introduces some syntactic overhead: with
name-indexing, `Variant`'s factory functions must be given a name (`Value`) even
though it doesn't really convey any information, and emulating `Result(T,E)` in
terms of type-indexing requires separately defining the wrapper templates
`Value` and `Error`.

The distinction between these two models of sum types seems analogous the
distinction between the tuple and struct models of product types. Tuples and
type-indexed sum types treat the data structurally, in terms of types and
positional indices, but structs and name-indexed sum types require the
components of the data to have names, which contributes to both readability and
type-safety by attaching higher-level semantics to the data.

It is possible that both models of sum types could coexist in Carbon, just as
structs and tuples do. However, that seems unlikely to be a good idea: the
coexistence of tuples and structs is necessitated by the fact that it is quite
difficult to emulate either of them in terms of the other in a type-safe way,
but as we've seen, it's fairly straightforward to emulate either model of sum
types in terms of the other.

Use cases that work best with type-indexing appear to be quite rare, just as use
cases for tuples appear to be quite rare compared to use cases for structs.
Consequently, if Carbon has only one form of sum types, it should probably be
the name-indexed form, as proposed here.

> TODO: We should consider ways of minimizing or avoiding the burden of
> boilerplate factory names like `Value` for type-indexed use cases.
