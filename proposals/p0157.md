# Design direction for sum types

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/157)

## Table of contents

<!-- toc -->

-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
    -   [Additional motivating use cases](#additional-motivating-use-cases)
    -   [In-place mutation](#in-place-mutation)
-   [Pattern functions](#pattern-functions)
    -   [Constraints on function evaluation](#constraints-on-function-evaluation)
    -   [Constraints on pattern matching](#constraints-on-pattern-matching)
        -   [Underdetermined patterns](#underdetermined-patterns)
        -   [Match guards](#match-guards)
        -   [Subpattern bindings](#subpattern-bindings)
        -   [Pattern-specific sugar syntaxes](#pattern-specific-sugar-syntaxes)
        -   [Avoidable inconsistencies](#avoidable-inconsistencies)
    -   [Worked example: `ArrayOfZeroes`](#worked-example-arrayofzeroes)
    -   [Alternatives considered](#alternatives-considered)
        -   [Make alternatives be pattern functions implicitly](#make-alternatives-be-pattern-functions-implicitly)
-   [Shareable storage](#shareable-storage)
    -   [Initialization](#initialization)
        -   [Alternatives considered](#alternatives-considered-1)
    -   [Pattern matching evaluation order](#pattern-matching-evaluation-order)
-   [The `alternatives` block](#the-alternatives-block)
    -   [Alternatives considered](#alternatives-considered-2)
        -   [More concise syntax](#more-concise-syntax)
        -   [Marking alternatives individually](#marking-alternatives-individually)
        -   [Different syntax for `closed`](#different-syntax-for-closed)
-   [`choice`](#choice)
    -   [Alternatives considered](#alternatives-considered-3)
        -   [Separate support for enumerated types](#separate-support-for-enumerated-types)
        -   [Different spelling for `choice`](#different-spelling-for-choice)
        -   [Extend `alternatives` instead](#extend-alternatives-instead)
-   [Alternatives considered](#alternatives-considered-4)
    -   [Indexing by type](#indexing-by-type)
    -   [Pattern matching callbacks](#pattern-matching-callbacks)
    -   [Pattern matching proxies](#pattern-matching-proxies)

<!-- tocstop -->

## Problem

Many important programming use cases involve values that are most naturally
represented as having one of several alternative forms (called _alternatives_
for short). For example,

-   Optional values, which are pervasive in computing, take the form of either
    values of some underlying type, or a special "not present" value.
-   Functions that cannot throw exceptions often use a return type that can
    represent either a successfully computed result, or some description of how
    the computation failed.
-   Nodes of a parse tree often take different forms depending on the grammar
    production that generated them. For example, a node of a parse tree for
    simple arithmetic expressions might represent either a sum or product
    expression with two child nodes representing the operands, or a
    parenthesized expression with a single child node representing the contents
    of the parentheses.
-   Boolean values take the form of either a "true" value or a "false" value.

What unites these use cases is that the set of alternatives is fixed by the API,
it is possible for user code to determine which alternative is present, and
there is little or nothing you can usefully do with such a value without first
making that determination.

Carbon needs to support defining and working with types representing such
values. Following Carbon's principles, these types need to be easy to define,
understand, and use, and they need to be safe -- in ordinary usage, the type
system should ensure that user code cannot accidentally access the wrong
alternative.

Furthermore, it needs to be possible for type owners to customize the
representations of these types. For example, sum types usually need a
"discriminator" field to indicate which alternative is present, but since it
typically has very few possible values, it can often be packed into padding, or
even the low-order bits of a pointer. Other sum types avoid an explicit
discriminator, and instead reserve certain values to indicate separate
alternatives. For example, a typical C-style pointer can be thought of as an
optional type, with a special null value indicating that no pointer is present,
because the platform guarantees that the null byte pattern is never the
representation of a valid pointer. This sort of customization inherently creates
a risk of implementation bugs that break type safety, but it must be possible to
implement such customizations without changing the type's API, and hence without
altering the static safety guarantees for users.

## Background

The terminology in this space is quite fragmented and inconsistent. This
proposal will use the term _sum types_ to refer to types of the kind described
in the problem statement. Note that "sum type" is not being proposed as a
specific Carbon feature, or even as a precisely defined term of art; it is
merely an informal way for this proposal to refer to its motivating use cases,
in much the same way that a structs proposal might refer to "value types".

Carbon as currently envisioned is already capable of approximating support for
sum types. In particular, [pattern matching](/docs/design/pattern_matching.html)
gives us a natural way to express querying which alternative is active, and then
performing computations on that active alternative, which as discussed above is
the primary way of interacting with a sum type. For example, a value-or-error
type `Result(T, Error)` could be implemented like so:

```
// Result(T, Error) holds either a successfully-computed value of type T,
// or metadata about a failure during that computation, or a singleton
// "cancelled" state indicating that the computation successfully complied with
// a request to halt before completion.
struct Result(Type:$$ T, Type:$$ Error) {
  // 0 if this represents a value, 1 if this represents an error, 2 if this
  // represents the cancelled state.
  var Int: discriminator;
  var T: value;
  var Error: error;

  fn Success(T: value) -> Result(T, Error) {
    return (.discriminator = 0, .value = value, .error = Error());
  }

  fn Failure(Error: error) -> Result(T, Error) {
    return (.discriminator = 1, .value = T(), .error = error);
  }

  var Result(T, Error):$$ Cancelled =
    (.discriminator = 2, .value = T(), .error = Error());
}
```

A typical usage might look like:

```
fn ParseAsInt(String: s) -> Result(Int, String) {
  var Int: result = 0;
  var auto: it = s.begin();
  while (it != s.end()) {
    if (*it < '0' || *it > '9') {
      return Result(Int, String).Failure("String contains non-digit");
    }
    result += *it - '0';
    result *= 10;
  }
  return Result(Int, String).Success(result);
}

fn GetIntFromUser() -> Int {
  while(True) {
    var String: s = UserPrompt("Please enter a number");
    match (ParseAsInt(s)) {
      case (.discriminator = 0, .value = Int: value, .error = String: _) => {
        return value;
      }
      case (.discriminator = 1, .value = Int: _, .error = String: error) => {
        Display(error);
      }
      case .Cancelled => {
        // We didn't request cancellation, so something is very wrong.
        Terminate();
      }
      default => {
        // Can't happen, because the above cases are exhaustive.
        Assert(False);
      }
    }
  }
}
```

However, this code has several functional deficiencies:

-   The implementation details of `Result` are not encapsulated. This makes the
    `Result` API unsafe: nothing prevents client code from accessing `.value`
    even when `.discriminator` is not 0. This also makes the patterns extremely
    verbose.
-   `.value` and `.error` must both be live throughout the `Result`'s lifetime,
    even when they are not meaningful. Consequently, `Success` must populate
    `.error` with a default-constructed dummy value (and so it won't work if
    `Error` is not default-constructible), `Failure` must do the same for
    `.value`, and `Cancelled` must do the same for both. Furthermore, `Result`
    is bloated by the fact that the two fields must have separately-allocated
    storage, even though at most one at a time actually stores any data.
-   `.discriminator` should never have any value other than 0, 1, or 2, but the
    compiler can't enforce that property when `Result`s are created, or exploit
    it when `Result`s are used. So, for example, the `match` must have a
    `default` case in order for the compiler and other tools to consider it
    exhaustive, even though that default case should never be entered.

It also has a couple of ergonomic problems:

-   The definition of `Result` is largely boilerplate. Conceptually, the only
    information needed to specify this type is the names and parameter types of
    the two factory functions, the name of the static member `Cancelled`, plus
    the fact that every possible value of `Result` is uniquely described by the
    name and parameter values of a call to one of those two functions, or else
    equal to `Cancelled`. Given that information, the compiler could easily
    generate the rest of the struct definition. This generated implementation
    may not always be as efficient as a hand-coded one could be, but in a lot of
    cases that may not matter.
-   The `return` statements in `ParseAsInt` are quite verbose, due to the need
    to explicitly qualify the function calls with `Result(Int, String)`. In
    fact, developers might prefer to avoid having a function call at all,
    especially in the success case, and instead rely on implicit conversions to
    write something like `return result;`.

## Proposal

To summarize, the previous section identified three missing features in Carbon,
which together prevent it from adequately supporting sum types:

-   There is no way for pattern matching to operate through an encapsulation
    boundary.
-   There is no way to manually control the lifetimes of subobjects, or enable
    them to share storage.
-   There is no way for a type to specify that a given set of patterns is
    exhaustive.
-   There isn't a concise way to define a sum type based on the form of its
    alternatives.
-   There isn't a way to return a specific alternative without restating the
    return type of the function.

I propose supporting sum types by introducing five language features to supply
the missing functionality. These features are largely separable, although there
are some dependencies between them, so their detailed design will be addressed
in future proposals, and the details discussed here should be considered
provisional. This proposal merely establishes the overall design direction for
sum types, in the same way that [p0083](p0083.md) established the overall design
direction for the language as a whole.

To support encapsulation in pattern matching, I propose introducing the concept
of a _pattern function_, which is a function that can be invoked as part of a
pattern, even with arguments that contain placeholders. Pattern functions can
only contain the sort of code that could appear directly in a pattern, but they
let us define reusable pattern syntaxes that can do things like encapsulate
hidden implementation details of the object they're matching.

To support manual lifetime control and storage sharing, I propose introducing a
`Storage` type, which represents a fixed-size region of untyped memory and
provides operations for creating and destroying within it, as well as a
`ToStorage` operation for obtaining the object representation of a value.

To allow types to specify an exhaustive set of patterns, as well as to solve
certain problems with accessing untyped memory in a pattern function, I propose
introducing `alternatives { ... }` as a grouping construct within a struct
definition. The elements of an `alternatives` block are pattern functions whose
return type is the enclosing struct type, and they are required to be both
exhaustive and unambiguous, meaning that for any possible value of the type, it
must be possible to obtain it as the return value of exactly one of the
alternatives. Alternatives that take no arguments, which represent singleton
states such as `Cancelled`, can instead be written as static constants. An
`alternatives` block can be marked `closed`, which indicates that client code
need not be prepared to accept alternatives other than the ones currently
present.

Using these features, the `Result(T, Error)` example can be rewritten as
follows:

```
struct Result(Type:$$ T, Type:$$ Error) {
  var Int: discriminator;

  var Storage(Max(Sizeof(T), Sizeof(Error)),
              Max(Alignof(T), Alignof(Error))): storage;

  closed alternatives {
    pattern Success(T: value) -> Self {
      return (.discriminator = 0, .storage = ToStorage(value));
    }

    pattern Failure(Error: error) -> Self {
      return (.discriminator = 1, .storage = ToStorage(error));
    }

    var Self:$$ Cancelled = (.discriminator = 2);
  }
}
```

The code for `ParseAsInt` is unchanged, and the rest of the usage example would
look like:

```
fn GetIntFromUser() -> Int {
  while(True) {
    var String: s = UserPrompt("Please enter a number");
    match (ParseAsInt(s)) {
      case .Success(var Int: value) => {
        return value;
      }
      case .Failure(var String: error) => {
        Display(error);
      }
      case .Cancelled => {
        // We didn't request cancellation, so something is very wrong.
        Terminate();
      }
    }
  }
}
```

To allow users to define sum types without micromanaging the implementation
details, I propose introducing `choice` as a convenient syntax for defining a
sum type by specifying only the declarations of the set of alternatives. From
that information, the compiler generates an appropriate object representation,
and synthesizes definitions for the alternatives and special member functions.

Our manual implementation of `Result` doesn't really benefit from having direct
control of the object representation, and doesn't seem to have any additional
API surfaces, so it's well-suited to being defined as a choice type instead:

```
closed choice Result(Type:$$ T, Type:$$ Error) {
  pattern Success(T: value) -> Self;
  pattern Failure(Error: error) -> Self;
  var Self:$$ Cancelled;
}
```

Finally, to avoid the boilerplate in `return` statements, I propose that in a
function with return type `T`, a statement of the form `return .F(args)` is
equivalent to `return T.F(args)`.

### Additional motivating use cases

We don't yet have enough of a design for variadics to give an example of a
Carbon counterpart for `std::variant<Ts...>`, but a variant with exactly three
alternative types could be written like so:

```
choice Variant(Type:$$ T1, Type:$$ T2, Type:$$ T3) {
  pattern Value(T1: value) -> Self;
  pattern Value(T2: value) -> Self;
  pattern Value(T3: value) -> Self;
}
```

> **Open question:** Should Carbon have a native syntax for pattern matching on
> the dynamic type of an object? If so, should types like `Variant` be able to
> use it, instead of having the `.Value` boilerplate in every pattern? Should
> this mechanism be aware of subtype relationships (so that a subtype pattern is
> a better match than a supertype pattern)? If so, how are those subtype
> relationships defined?

As an example of a case where manual control of the representation is useful,
here's an example of a type that implements an optional pointer value without
requiring additional storage for a discriminator:

```
struct OptionalPtr(Type:$$ T) {
  var Storage(Sizeof(Ptr(T)), Alignof(Ptr(T))): storage;

  alternatives {
    pattern Value(Ptr(T): ptr) -> Self { return (.storage = ToStorage(ptr)); }
    var Self:$$ Null = (.storage = ArrayOfZeros(Sizeof(Ptr(T))));
  }
}
```

Note that `ArrayOfZeros` can be defined as a pattern function, but only with
some possibly surprising extensions to Carbon's pattern language. See below for
details.

### In-place mutation

Consider the following code:

```
var Optional(Vector(Int)) opt = .Some(...);

match (opt) {
  case .Some(Vector(Int): v) => { v[0] += 1; }
  default => {}
}
```

By analogy with function parameters, it seems clear that `Vector(Int): i`
declares either a new variable or a new constant, so either `v[0] += 1` modifies
that variable, or the code doesn't compile at all. In neither case does it
mutate `opt` itself.

However, as discussed earlier, pattern matching is the primary interface for
interacting with sum types, so it's essential that pattern matching be able to
express in-place mutation somehow. In particular, there needs to be some way of
changing the above code so that it modifies the `Vector` in place. However, not
all parameters of all alternatives will be able to support this, because in some
cases the parameter value will be computed on the fly. For example, if the
low-order bits of a pointer are used to store a discriminator, a binding of that
pointer would need to expose a _copy_ that has the discriminator masked out, and
so any mutations that the user applied via the binding would apply to the copy,
and not the original sum object.

Consequently, opting into in-place mutation probably needs to be done on a
per-binding basis, rather than a per-alternative or per-`match` basis. This will
express programmer intent more precisely, which will allow us to diagnose if
they're trying to mutate a field that doesn't support in-place mutation.

By analogy with function parameters, it's tempting to try to express this opt-in
by changing the type of `v` to `Ptr(Vector(Int))`. However, that doesn't work in
general. For example, suppose we want to pattern match on a
`Variant3(Int, Ptr(Int), String)` -- does `.Value(Ptr(Int))` match the `Int`
case with in-place semantics, the `Ptr(Int)` case with by-value semantics, or
can it match both? The same argument applies to any other type-based opt-in,
unless the two types are indistinguishable by overload resolution (as with `T`
vs. `const T&` in C++).

One way to solve this would be to provide a new kind of binding pattern. For
example, we could introduce `ref Type: name` as a syntax for binding the name
`name` to the object this pattern is matched against (rather than to a new
object with the same value). This syntax is intended to suggest that `ref` is
not part of the type, but rather an introducer for the declaration of `name`,
analogous to `var` and `val`:

```
match (opt) {
  case .Some(ref Vector(Int): v) => { v[0] += 1; }
  default => {}
}
```

Alternatively, we could have a syntax that binds a name to a pointer, rather
than directly to the object, although it's harder to find a concise but mnemonic
introducer to use in that case:

```
match (opt) {
  case .Some(inplace Ptr(Vector(Int)): v) => { (*v)[0] += 1; }
  default => {}
}
```

Rather than introduce a new kind of binding, it might be possible to solve this
problem by introducing a new pattern operator. In particular, we could allow
unary `*` to appear in patterns, with the semantics that `*<pattern>` matches an
object whenever `<pattern>` matches the address of that object.

```
match (opt) {
  case .Some(*(Ptr(Vector(Int)): v)) => { (*v)[0] += 1; }
  default => {}
}
```

This is in some ways more parsimonious, because we're just slightly broadening
the set of expression operators that have a dual role as pattern operators,
rather than introducing an entirely new kind of binding.

This proposal doesn't take a position on what syntax to use, but I an inclined
to prefer `ref Type: name`.

## Pattern functions

Pattern functions have the same declaration syntax as ordinary functions, except
that they are introduced with `pattern` rather than `fn`. However, the function
body is required to be a single `return` statement whose operand expression is a
valid pattern, with each use of a function parameter acting as a variable
binding. One consequence of that constraint is that a given function parameter
cannot be accessed more than once when evaluating the pattern function.

It seems likely that pattern functions will be required to be inline, because
they will probably need to generate very different code depending on the
structure of their arguments, particularly if the arguments contain
placeholders.

The body of a pattern function must consist of a single `return` statement whose
operand is not only a valid expression, but also would be a valid pattern if any
uses of the function parameters were replaced with variable binding patterns.
Furthermore, the semantics of the expression must mirror the semantics of the
pattern. For example, this is a valid pattern function:

```
pattern MakeStruct(Int: x, Int: y) -> MyStruct {
  return (.x = x, .y = y);
}
```

because `(.x = Int: x, .y = Int: y)` is a valid pattern that is guaranteed to
match the result of any call to `MakeStruct` and set `x` and `y` to that call's
arguments, and conversely any value that matches `(.x = Int: x, .y = Int: y)` is
guaranteed to be equal to `MakeStruct(x, y)`.

This mirroring requirement ensures that we can run the function both forwards
and backwards, either evaluating the function on some arguments to produce a
return value, or pattern matching on a purported return value to deduce the
arguments that produced it. The major drawback of this approach is how it
constrains the expressiveness of pattern functions, and it's useful to consider
the forward and reverse aspects of that constraint separately.

### Constraints on function evaluation

In the forward direction, the mirroring requirement is clearly a very limiting
constraint: most function bodies do not consist of a single return statement,
and most expressions are not valid patterns. So it's reasonable to wonder
whether pattern functions have enough expressive power. So far I've come across
two notable examples of code that we are likely to want to express in pattern
functions, but that may not satisfy the mirroring requirement.

The first example is that it seems very difficult to allow a pattern function to
express in-place initialization, such what C++'s placement-new does. In this
proposal, I work around that problem with a special case rule that essentially
treats `storage = ToStorage(obj)` as constructing a copy of `obj` in-place in
the untyped array `storage`, but only when initializing `storage`. However, this
is decidedly a hack. See the section on shareable storage below for details on
this issue.

The second example is memory allocation. We will inevitably want pattern
functions to be able to create, and match, objects that store data on the heap.
In principle this seems feasible: for example, Carbon might have a `Box(T)` type
that represents a heap-allocated `T` object, and a `MakeBox` function for
creating a `Box(T)` from a `T` value. We could then use `MakeBox` in pattern
functions. For example, this is a pattern function that creates/matches objects
of type `IndirectInt`, a hypothetical integer-like type that stores its data on
the heap:

```
struct IndirectInt {
  var Box(Int): i_ptr;
}

pattern IndirectIntOf(Int: i) -> IndirectInt {
  return (.i_ptr = MakeBox(Int, i));
}
```

For this to work, two `Box(T)` values must be considered equal when the `T`
values they hold compare equal, rather than when they are literally the same `T`
object. This is important not only for pattern matching, but also for situations
like automatically generating a struct's comparison operators. Note that other
than these "deep" equality semantics, `Box(T)` would be very similar to C++'s
`std::unique_ptr<T>`, and would probably play a comparable role in the Carbon
ecosystem.

The problem here is that `MakeBox` has to both read and mutate some state that's
not part of its arguments, namely the state of the memory allocator. It's not
clear that we can allow pattern functions to have side effects, or to depend on
side inputs, because those operations are likely to be very difficult to invert.
In this case that mutable state has no effect on the actual value, at least as
far as equality comparison is concerned, but it's not clear whether or how we
can take advantage of that.

In both cases, it seems very possible that we could extend the pattern language
with new primitives that encapsulate the non-invertible part of these
operations, but it's too soon to say what they would look like.

### Constraints on pattern matching

In the reverse direction, the mirroring requirement may prevent us from using
certain pattern matching syntaxes inside pattern functions, namely syntaxes that
don't correspond to expression syntaxes. However, that appears to be a tolerable
constraint, at least for the use cases we're interested in here.

Pattern matching syntaxes in other languages generally don't have many such
syntaxes, but there are a few. The following sections discuss the most notable
examples I've found, and discuss how they affect the viability of this design.

#### Underdetermined patterns

One corollary of the mirroring requirement is that the named variable bindings
in the pattern must uniquely determine the value being matched. This precludes
any pattern which "loses information" about the matched value. Most notably,
this means a pattern function cannot contain wildcard patterns, such as `_`, or
Rust's `..` partial wildcard.

As a more complex example, several languages support combining multiple patterns
disjunctively, yielding a pattern that matches when any of the subpatterns
match. For example, in Rust the pattern `(0, x) | (x, 0)` matches any pair whose
first or second element is `0`, and binds `x` to the other element. Such
patterns lose information about which case successfully matched, and so they
cannot occur in pattern functions.

In such cases, the problem could be partially worked around by changing the code
to preserve the lost information. For example, the `_` pattern can be replaced
with a named function parameter. Note that although `_` cannot appear in a
pattern function, it can appear as an argument to a pattern function in a
top-level pattern, so the caller can discard that part of the pattern if it's
not useful to them.

In the case of disjunctive patterns, preserving the lost information would
essentially require a pattern syntax for defining a variable binding that
records which alternative was selected. Or, to state the problem in the mirrored
sense, we need an expression syntax that uses a variable to select which of
several cases to return. Fortunately, Carbon is likely to have such a syntax
anyway, namely `match` expressions. If we also allow `match` in patterns, a
pattern like `(0, x) | (x, 0)` might be written as:

```
match c {
  case 0 => (0, auto:x)
  case 1 => (auto:x, 0)
  default => Assert(False)
}
```

Note that inside a pattern, the case labels must be expressions, whereas the
match operand and the case bodies can be patterns. Interestingly, this is the
exact opposite of the rule for `match` outside of patterns: in effect, switching
from forward to reverse evaluation reverses the direction of the arrows.

Inside a pattern function, the wildcard and variable bindings would need to be
replaced with function parameters (thereby making both sides expressions):

```
match c {
  case 0 => (0, x)
  case 1 => (x, 0)
  default => Assert(False)
}
```

This is evidently more verbose than the Rust version, but that could be
mitigated with some syntax adjustments, such as a more concise way of asserting
that a match is exhaustive.

The primary difficulty with `match` patterns is that they are prone to
ambiguity. For example, when matching with `(0, 0)`, it's not obvious what value
should be deduced for `c`. However, this problem is not unique to `match`
patterns, but is inherent in any sort of disjunctive patterns. Even though Rust
patterns don't provide an explicit indicator of which case was matched,
suitably-chosen variable bindings can indirectly expose that information. It
appears that Rust chooses the first match, but Carbon could in principle choose
the best match, or require the patterns to be unambiguous. Here again, it's as
if the `=>` arrow has switched directions, because the same ambiguity problem,
and the same possible resolutions, come up on the _left_ side of the arrows when
the `match` isn't in a pattern matching context.

All that being said, it's not clear how important it is to support disjunctive
patterns (Swift doesn't, for example), so it may be simpler to avoid the issue
by not supporting them.

#### Match guards

Several languages support _match guards_, which use a predicate to restrict
pattern matching. For example, in Rust the pattern `Some(x) if x < 5` matches an
`Optional<Int>` value, and binds `x` to the `Int` it contains, only if that
value is less than 5. Match guards are always expressions, not patterns -- for
example, a pattern like `Some(x) if _ < 5` would be nonsensical.

Match guards generally do not satisfy the mirroring requirement; for example,
`Some(x) if x < 5` is not a valid Rust expression. This may be a problem,
because we are likely to want match guards for Carbon, although it's not clear
if there will be important use cases for match guards inside pattern functions.
If there are, a very plausible path forward would be to allow pattern functions
to contain assertions. In the forward direction, these would behave in the
expected way, documenting and optionally enforcing preconditions on the function
call. In the reverse direction, they would function as match guards:

```
fn Foo(Int: x) -> Optional(Int) {
  Assert(x < 5);
  return Some(x);
}
```

This does somewhat complicate the mapping between functions and patterns, but
the additional complexity seems quite tolerable.

Note that some languages provide a way for type authors to specify when two
values are considered to match. For example, in Swift you can overload the `~=`
operator, which returns a boolean indicating whether the left-hand side matches
the right. Both sides of the operator are values rather than patterns, so this
mechanism is effectively syntactic sugar for match guards, or an alternative to
them.

#### Subpattern bindings

Some languages support binding an identifier to a subpattern, rather than only
using identifiers as placeholders. This generally requires a separate syntax.
For example, in Rust the syntax `id @ p` matches the same values as the pattern
`p`, but also binds the name `id` to the matched value. The mirroring
requirement would imply that in an expression, `id @ p` evaluates to the value
of `id`, and also asserts that `id` matches `p`. These semantics seem
conceptually straightforward, but awkardly non-orthogonal and not very useful,
so if Carbon has this syntax at all, we could probably safely limit it to
patterns and pattern functions.

It's interesting to note that we can interpret `p` as a pattern even in the
forward direction (because the primary behavior is supplied by `id`), so we can
probably allow it to contain wildcards. However, it's not clear whether that
will be useful in practice.

#### Pattern-specific sugar syntaxes

In Swift, if `x` is a pattern that matches values of type `T`, `x?` is a pattern
that matches values of type `Optional<T>` that contain a value matching `x`.
However, if `x` is an expression of type `T`, `x?` will generally not be a valid
expression, so such patterns don't satisfy the mirroring requirement. However,
`x?` is purely syntactic sugar for `.some(x)`, which does satisfy the mirroring
requirement. I would tentatively recommend that we avoid introducing
pattern-specific sugar syntaxes for simplicity, but even if we do, by definition
it will always be possible to avoid using them in pattern functions.

#### Avoidable inconsistencies

Swift has an expression syntax `x as T`, which casts the value `x` to static
type `T`. Swift also has a pattern syntax `x as T`, which matches a
dynamically-typed value if its dynamic type is `T`, and its value matches `x`.
Although syntactically identical, these syntaxes don't mirror each other: in the
pattern form, `x` has static type `T`, whereas the expression form is useful
precisely when `x` does _not_ have static type `T`. For example, the pattern
`0 as Int` does not match the expression `0 as Int`, but does match the
expression `0 as Any`. However, this inconsistency doesn't seem necessary,
especially given that in Carbon, the variable binding syntax includes a
mandatory type, so the Carbon counterpart to Swift's `x as T` will presumably be
something like `T: x` or `T: x as Any`, depending on whether converting `T` to
`Any` requires an explicit cast, and that satisfies the mirroring requirement.

### Worked example: `ArrayOfZeroes`

The `OptionalPtr` example above relies on `ArrayOfZeroes`, a pattern function
that takes an integer `N` and returns an `Array(Byte, N)` whose elements are all
zero. It is possible to implement such a pattern function, but it requires some
extensions to Carbon's pattern language that may be surprising:

```
pattern ArrayOfZeroes(UInt:$$ N) -> Array(Byte, N) {
  Array(Byte, N)(ListOfZeroes(N));
}

pattern ListOfZeroes(UInt:$$ N) -> List(Byte) {
  return match (N) {
    case 0 => { .Nil }
    case (UInt: M)+1 => { .Cons(Byte(0), ListOfZeroes(M)); }
  };
}
```

This design requires Carbon to support `match` expressions inside patterns, as
discussed above in the section on underdetermined patterns. More surprisingly,
it requires the ability to use `+1` as a pattern matching operator on unsigned
integers. This is novel in my experience, but I hope the meaning of the code is
relatively clear. Furthermore, although it may seem ad-hoc, it's theoretically
well founded: we're effectively destructuring the unary representation of
counting numbers as `0+1+1+...+1`. In other words, we're treating `UInt` as
though it were a sum type, analogous to

```
closed choice UInt {
  var Self:$$ Zero;
  pattern Successor(Uint) -> Self;
}
```

We could even use a named `Successor` function in place of `+1`, if we wish to
avoid uncertainty about what kinds of arithmetic expressions can appear in
patterns. Whatever the syntax, the ability to use `+1` in patterns is a
fundamental building block for creating pattern functions that involve counting.

This implementation also presupposes a type (called `List(Byte)` here) that can
be used to initialize an `Array`, and that supports pattern matching on the
empty list (spelled `.Nil` here) and on destructuring the first element from a
list (spelled `.Cons(first, rest)` here). These seem like reasonable
requirements for whatever type Carbon uses to represent array literals. If
Carbon uses tuples for that purpose, I expect an approach equivalent to the
above would still work, but I can't directly demonstrate that until we have a
design for variadics.

### Alternatives considered

#### Make alternatives be pattern functions implicitly

Every function in an `alternatives` block must be a pattern function, and this
proposal has no need for pattern functions outside of `alternatives` blocks.
That being the case, we could eliminate the `pattern` keyword, and instead
specify that functions within an `alternatives` block have special semantics.

I have opted not to do so here because I think it's somewhat clearer to mark
individual functions, and because the ability to define a pattern matching
shorthand seems likely to be useful outside of the context of sum types. For
example, proposal [0087](https://github.com/carbon-language/carbon-lang/pull/87)
suggests introducing an `NTuple` function as a built-in primitive in order to
support variadics, but given some plausible extensions, it could probably be
implemented as an ordinary pattern function in library code.

## Shareable storage

This approach to sum types imposes relatively few requirements on the language
features used to implement shareable storage (meaning, storage that can be
inhabited by different objects at different times), and so this proposal doesn't
describe them in much detail. I'm proposing an untyped byte buffer here because
it's more general, but union types along the lines of proposal
[0139](https://github.com/carbon-language/carbon-lang/pull/139) would work just
as well.

Regardless of the form that shareable storage takes, it won't be able to
intrinsically keep track of whether it currently holds any objects, or the types
or offsets of those objects, because that would require it to maintain
additional hidden storage, and a major goal of this design is to give the
developer explicit control of the object representation. Consequently, it is not
safe to copy, move, assign to, or destroy shareable storage unless it is known
not to be inhabited by an object.

This means that in the general case, the compiler will not be able to generate
safe default implementations for any special member functions of types that have
shareable storage members. However, it can do so if the shareable storage is
part of a sum type, because the `alternatives` block contains enough information
for it to infer what objects are present, by effectively pattern-matching on the
sum type object.

In order for non-sum types to define those functions manually, the design for
shared storage will need to include operations for creating and destroying
objects within it, analogous to placement-`new` and pseudo-destructor calls in
C++.

### Initialization

The most challenging requirement that this approach imposes on the design of
shareable storage is that it must be possible to initialize it from an instance
of any of the values that it can represent, and to do so inside a pattern or
pattern function.

This proposal represents that initialization using a `ToStorage` function call,
such as `.storage = ToStorage(success)` in the example above. However, the
semantics of this code may be somewhat surprising: it doesn't merely copy the
underlying bytes of `success` into `.storage`, it actually creates a new `T`
object within `.storage`, which is directly initialized from `success`. This
assumes that Carbon has some equivalent to C++'s "guaranteed RVO"; this code
cannot be understood as creating a temporary `Storage` array representing a `T`
value and then moving it into `.storage`, because it is not safe to move an
inhabited `Storage` storage array, as discussed above.

`ToStorage` is presented here as a function, but it can't actually be
implemented as a function within the Carbon language. Recall that our motivating
use cases involve invoking `ToStorage` inside pattern functions, so it needs to
be a pattern function itself, assuming it's a function at all. If it were
implemented as Carbon code, it would need to consist of a single expression that
initializes a `Storage` from an object, and the whole problem we're trying to
solve here is to make it possible to write such an expression. Consequently, we
may wish to give it a different syntactic form. This operation is in many ways a
type cast, so the syntactic choice here will depend heavily on the syntax of
Carbon's other casts.

At a deeper level, the problem is that the whole notion of allowing multiple
objects to successively share the same storage is inherently procedural (because
it involves changes in state over time), but pattern matching is fundamentally
descriptive, and hence functional. A design in which user-defined patterns can
be expressed in terms of procedural forward and reverse functions would avoid
this whole problem, by allowing us to express storing the alternative in terms
of procedural code (such as the equivalent of C++'s placement-`new`) rather than
initialization.

#### Alternatives considered

It is tempting to try to mitigate those problems by making the conversion
implicit, so that the code looks like `.storage = success`. However, this would
mean that `Storage` can be implicitly initialized from a value of any type, and
such extremely broad implicit conversions tend to be highly problematic. For
example, consider the definition of `.Null` in the `OptionalPtr` example:

```
var Self:$$ Null = (.storage = ArrayOfZeros(Sizeof(Ptr(T))));
```

If `Storage` were implicitly convertible from any type, and that conversion
caused an object to be created within the `Storage`, this code would no longer
just set the bytes of `.storage` to zero: it would also actually create an
`Array(Byte)` object within `.storage`, which would then need to be subsequently
destroyed before `.storage` is destroyed, or used to store a pointer value.
There are various ways to finesse this issue, but they all involve adding
additional special-case rules in order to avoid or mitigate this consequence of
the general rules.

We don't propose this approach because it doesn't really address the problems
with `ToStorage`; it merely obscures those problems, while introducing a new
problem that would itself require further work to obscure. However, it's worth
noting that the drawbacks of this approach are much less severe if we implement
shared storage using a union rather than an untyped byte array, because the
implicit conversion would not need to be universal.

### Pattern matching evaluation order

As discussed above, Carbon's pattern language must be restricted to operations
that the compiler can automatically invert. The inverse of creating an object of
type `T` in shareable storage is reading an object of type `T` out of shareable
storage. However, since shareable storage will not track the types or offsets of
the objects it contains, this inverse operation is safe only if the shared
storage is known to contain an object of type `T` at that offset.

Consequently, pattern matching evaluation must occur in an order that guarantees
that a suitable object is present before it is loaded from shareable storage.
Correspondingly, the author of the code must structure the pattern match in such
a way that the compiler can find an appropriate evaluation order.

At least for our motivating use cases, this appears to be intuitively
straightforward. Consider the `Result` example we saw earlier:

```
struct Result(Type:$$ T, Type:$$ Error) {
  var Int: discriminator;

  var Storage(Max(Sizeof(T), Sizeof(Error)),
              Max(Alignof(T), Alignof(Error))): storage;

  closed alternatives {
    pattern Success(T: value) -> Self {
      return (.discriminator = 0, .storage = ToStorage(value));
    }

    pattern Failure(Error: error) -> Self {
      return (.discriminator = 1, .storage = ToStorage(error));
    }

    var Self:$$ Cancelled = (.discriminator = 2);
  }
}

...

match (ParseAsInt(s)) {
  case .Success(var Int: value) => {
    return value;
  }
  case .Failure(var String: error) => {
    Display(error);
  }
  case .Cancelled => {
    Terminate();
  }
}
```

When matching `ParseAsInt(s)` with the `Success` pattern, the compiler can
observe that no other alternative sets `.discriminator` to `0`, so it can safely
load a `T` value out of storage once it has successfully matched
`.discriminator` with `0`.

The `OptionalPtr` example is somewhat more subtle:

```
struct OptionalPtr(Type:$$ T) {
  var Storage(Sizeof(Ptr(T)), Alignof(Ptr(T))): storage;

  alternatives {
    pattern Value(Ptr(T): ptr) -> Self { return (.storage = ToStorage(ptr)); }
    var Self:$$ Null = (.storage = ArrayOfZeros(Sizeof(Ptr(T))));
  }
}
```

In this case, the compiler can observe that since the `alternatives` block is
required to be exhaustive, `.storage` must hold either a `T` value or an
all-zeros bit pattern, so it can safely attempt to match the `.Value` case only
after it has ruled out the `.Null` case, which it can evaluate unconditionally
because that case only requires loading raw bytes, which is always safe.
Consequently, we may want to require that a pattern match that looks for
`.Value` must also have an explicit `.Null` case (rather than a generic
`default` case), so as to make it clear to the reader that the `.Null` case is
being evaluated. If Carbon specifies that pattern matching evaluates cases in
order, we would presumably also require that the `.Null` case is above the
`.Value` case.

We will need to formalize the intuition behind those examples, in the form of
concrete language rules that are strict enough for the compiler to feasibly
perform that sort of symbolic reasoning, and yet permissive enough that type
authors can feasibly understand and follow them, and the compiler can produce
intelligible error messages when they are violated. Furthermore, it would be
strongly preferable if the compiler could detect any errors purely by inspecting
the type definition, rather than delaying them until the type is actually used
in pattern matching.

The design of those rules is deferred to a subsequent proposal. However, one key
requirement is already clear: the compiler must be able to identify all of the
type's alternatives, and know that they exhaustively describe all possible
values of the type. This is a key reason for introducing the `alternatives`
block. For similar reasons, we may also need to introduce some syntax for
marking a single pattern function as being exhaustive (`MakeUnique`, for
example), but such use cases are out of scope for this document because they
don't involve sum types.

## The `alternatives` block

An `alternatives` block designates a set of pattern functions and static
constants as representing an exhaustive and unambiguous set of alternatives for
the type. By defining an `alternatives` block, the type author is guaranteeing
that every possible value of the type matches exactly one of the alternatives.
Consequently, the design of this feature will need to determine how Carbon
handles violations of this guarantee without compromsing Carbon's safety goals.

Although alternatives are always exhaustive as far as the language semantics are
concerned, by default user code will be required to treat them as
non-exhaustive. For example, a `match` statement that has cases for the
alternatives of a sum type will be required to have a `default` case, even if it
also has patterns that match all of the declared alternatives. This ensures that
sum types can be extended with new alternatives without breaking any existing
code.

However, code in the same
[library](/docs/design/code_and_name_organization/#libraries) as the choice type
is not subject to this restriction. Requiring a `default` has little benefit for
that code, because it can easily be updated when a new alternative is added,
without creating any version-skew concerns. Conversely, requiring a `default`
would have higher costs: code that's part of the sum type's API is more likely
to be required to explicitly handle every alternative (consider, for example, an
`Unparse` method on a sum type representing a parse tree). When that's the case,
omitting a `default` provides a build-time guarantee that every alternative has
been handled.

Declaring the alternatives with `closed alternatives` rather than `alternatives`
allows all code to treat the alternatives as exhaustive.

### Alternatives considered

#### More concise syntax

We could introduce a special syntax for declaring alternatives, rather than
using the existing syntaxes for pattern functions and static variables. Such a
syntax could be substantially more concise, because it could omit the components
of a function/variable declaration that are just boilerplate in the context of a
set of alternatives. For example, the alternatives of the `Result(T, Error)`
struct might look like this:

```
closed alternatives {
  Success(T: value) { ... }
  Failure(Error: error) { ... }
  Cancelled = (.discriminator = 2);
}
```

The same simplifications could be applied to `choice` types, so that for example
the `choice` version of `Result` could look like this:

```
choice Result(Type:$$ T, Type:$$ Error) {
  Success(T);
  Failure(Error);
  Cancelled;
}
```

However, this brevity would come at the cost of consistency: there would now be
two structurally different syntaxes for declaring functions, and two
structurally different syntaxes for declaring static constants.

#### Marking alternatives individually

Rather than making `alternatives` a separate block, we could define a syntax for
marking alternatives individually. If we choose not to support pattern functions
that aren't alternatives, this syntax could be an introducer that takes the
place of `pattern`. This would also synergize well with the option of having a
more concise syntax for alternatives, which otherwise may have problems with the
lack of an introducer.

The primary drawback of this approach is that the lack of explicit grouping
could make it more difficult for readers (and perhaps even the compiler) to know
when all the alternatives have been enumerated. It would also mean that we can't
support the admittedly unlikely use case of defining a sum type that has
multiple complete sets of alternatives.

#### Different syntax for `closed`

The `closed` syntax should be considered little more than a placeholder. It's
somewhat unconventional for a modifier to come before an introducer, as with
`closed alternatives`. Reversing the order would fix that problem, but
`alternatives closed` reads quite awkwardly as English. Making `closed` a
keyword would prevent developers from using `closed` as an identifier, which may
be too high a cost for such a niche use case. We could fix that by making it an
attribute rather than a keyword, but it's not clear that Carbon will have
attributes, much less what the syntax would be.

It may be surprising that there is no corresponding `open alternatives` syntax,
but `open` would be meaningless syntactic noise unless we made it mandatory, and
making it mandatory would be poor ergonomics, because developers would be forced
to make an up-front decision between the two, rather than relying on a safe
default. Furthermore, reserving `open` as a keyword seems even more problematic
than reserving `closed`.

## `choice`

A choice type definition has the same general form as an `alternatives` block,
except that:

-   It has `choice` and the type name in place of `alternatives`.
-   It need not (and usually won't) be inside a `struct` definition, because it
    defines a new type, rather than specifying part of an enclosing type
    definition.
-   Its members cannot have definitions, because those definitions will be
    provided by the compiler.

The expected implementation of a `choice` type will be very similar to the
`struct` version of `Result` shown earlier, with a discriminator field and a
storage buffer large enough to hold the argument values of the alternatives. Any
alternative parameter types that are incomplete (or have unknown size for any
other reason) will be represented using owning pointers; among other things,
this will allow users to define recursive choice types. The implementation will
be hidden, of course, and the compiler may be able to generate better code, but
we will design this feature to support at least that baseline implementation
strategy.

One consequence is that although the pattern functions of a choice type can be
overloaded (as in the `Variant` example above), they cannot be templates. More
precisely, the parameter types of a pattern function must be fixed without
knowing the values of any of the arguments. To see why, consider a choice type
like the following, which attempts to emulate `std::any`:

```
choice Any {
  pattern Value[Type:$$ T](T value);
}
```

The problem is that since `T` could be any type, and a single `Any` object could
hold values of different types throughout its lifetime, `Any` can't be
implemented using a storage buffer within the `Any` object. Instead, the storage
buffer for the `T` object would have to be allocated on the heap, but then the
compiler would need to decide whether to apply a small buffer optimization, and
if so what size threshold to use, etc. Allowing choice types to be implemented
in terms of heap allocation would make their performance far less predictable,
contrary to Carbon's performance goals, and would have little offsetting
benefit: these sorts of types appear to be rare, and when needed they should be
implemented in library code, where the performance tradeoffs are explicit and
under programmer control.

If may be possible to relax this restriction when and if we have a design for
supporting non-fixed-size types, although it's worth noting that even that would
not give us a way for `Any` to support assignment.

Carbon will probably have some mechanism for allowing a struct to have
compiler-generated default implementations of operations such as copy, move,
assignment, hashing, and equality comparison, so long as the struct's members
support those operations. Assuming that mechanism exists, choice types will
support it as well, with the parameter types of the pattern functions taking the
place of the member types. However, there are a couple of special cases:

-   choice types cannot be default constructible, unless we provide a separate
    mechanism for specifying which alternative is the default.
-   choice types can be assignable, regardless of whether the parameter types
    are assignable, because assigning to a choice type always destroys the
    existing alternative, rather than assigning to it.

A future proposal for this mechanism will need to consider whether to require an
explicit opt-in to generate these operations.

The compiler-generated definitions of a choice type's alternatives are
unspecified, except that they will satisfy the semantic requirements that apply
to all alternatives.

### Alternatives considered

#### Separate support for enumerated types

This proposal supports enumerated types as a special case of choice types.
However, there may be some benefit to providing special-case support for
enumerated types, similar to C++'s `enum`. In particular:

-   We could more easily avoid the `var Self:$$` boilerplate in enumerator
    declarations.
-   We could allow the developer to specify an underlying type, associate a
    specific value of the underlying type with each enumerator, and convert
    between the enum and the underlying type, which are fairly common practices
    in C++ code. When using choice types, these practices can be emulated by
    defining functions that map between the choice type and the underlying type,
    but that requires a substantial amount of error-prone boilerplate.
    Furthermore, those functions can't reliably be no-ops at the hardware level,
    the way they can be with C++ enums.

I am omitting that from this proposal for simplicity, since it's purely
additive, and not necessary for the goals of this proposal.

#### Different spelling for `choice`

The Rust and Swift counterparts of `choice` are spelled `enum`. I have avoided
this because these types are not really "enumerated types" in the sense of all
values being explicitly enumerated in the code. I chose the spelling `choice`
because "choice type" is one of the only available synonyms for "sum type" that
doesn't have any potentially-misleading associations.

#### Extend `alternatives` instead

Instead of introducing `choice`, we could extend `alternatives` with a syntax
for requesting that the definitions be synthesized rather than provided by the
user. For example, perhaps the abbreviated definition of `Result(T, Error)`
could be written as:

```
struct Result(Type:$$ T, Type:$$ Error) {
  alternatives {
    pattern Success(T: value) -> Self;
    pattern Failure(Error: error) -> Self;
    var Self:$$ Cancelled;
  } = default;
}
```

This approach is somewhat more flexible, because it would permit the type owner
to give `Result` additional member functions without forcing them to supply all
the boilerplate associated with the fully handwritten type definition. However,
it still wouldn't be possible to give `Result` additional data members, because
the generated code for the alternatives would have no way to initialize them, so
structs containing an `alternatives` block would be starkly different from ones
that don't. On a related note, this syntax would be somewhat misleading, because
the compiler would be synthesizing not only the definitions of the alternatives,
but also the special member functions and data members.

This approach would also be more verbose, especially vertically, which will be
especially noticeable since these types will probably be quite small in the
common case.

Alternatively, we could unify the two keywords by eliminating `alternatives` and
using `choice` in its place, with the presence of a name acting to distinguish a
`choice` block from a `choice` type. However, it seems liable to be confusing
for the presence or absence of a name to trigger such stark differences in
semantics. Note also that unlike the previous option, this approach doesn't
allow users to extend the type with additional methods without losing compiler
generation of the alternatives and special member functions.

## Alternatives considered

### Indexing by type

Rather than requiring each alternative to have a distinct name (or at least a
distinct function signature), we could pursue a design that requires each
alternative to have a distinct type. With this approach, which I'll call
"type-indexed" as opposed to "name-indexed", Carbon sum types would much more
closely resemble C++'s `std::variant`, rather than Swift and Rust's `enum` or
the sum types of various functional programming languages.

Either approach can be emulated in terms of the other: the `Variant` example
above shows how we can use overloading to emulate type-indexing in our
name-indexed framework, and conversely a type-indexed type like `std::variant`
can model a name-indexed type like `Result(T,E)` by introducing a wrapper type
for each name, leading to something like
`std::variant<Value<T>, Error<E>, Cancelled>` (note that `std::variant<T,E>`
would not work, because `T` and `E` can be the same type). In either case,
emulating the other model introduces some syntactic overhead: with
name-indexing, `Variant`'s factory functions must be given a name (`Value`) even
though it doesn't really convey any information, and emulating `Result(T,E)` in
terms of type-indexing requires separately defining the wrapper templates
`Value` and `Error`.

The distinction between these two models of sum types seems analogous the
distinction between the tuple and struct models of product types. Tuples and
type-indexed sum types treat the data structurally, in terms of types and
positional indices, but structs and name-indexed sum types require the
components of the data to have names, which contributes to both readability and
type-safety by attaching higher-level semantics to the data.

It is possible that both models of sum types could coexist in Carbon, just as
structs and tuples do. However, that seems unlikely to be a good idea: the
coexistence of tuples and structs is necessitated by the fact that it is quite
difficult to emulate either of them in terms of the other in a type-safe way,
but as we've seen, it's fairly straightforward to emulate either model of sum
types in terms of the other.

Use cases that work best with type-indexing appear to be quite rare, just as use
cases for tuples appear to be quite rare compared to use cases for structs.
Consequently, if Carbon has only one form of sum types, it should probably be
the name-indexed form, as proposed here.

> TODO: We should consider ways of minimizing or avoiding the burden of
> boilerplate factory names like `Value` for type-indexed use cases.

### Pattern matching callbacks

Rather than requiring the compiler to automatically invert a set of factory
functions in order to use them as patterns, we could allow types to specify how
they participate in pattern matching by supplying explicit code for both
directions. In this approach, the method that implements the reverse direction
would receive a set of continuations representing the different branches of the
match, and it would be responsible for choosing which one to execute. Here's
what that might look like, again revisiting our `Result` example:

```
struct Result(Type:$$ T, Type:$$ Error) {
  var Int: discriminator;

  var Storage(Max(Sizeof(T), Sizeof(Error)),
              Max(Alignof(T), Alignof(Error))): storage;

  fn Success(T: value) -> Self {
    Self result = (.discriminator = 0);
    result.storage->Create(T, value);
    return result;
  }

  fn Failure(Error: error) -> Self {
    Self result = (.discriminator = 1);
    result.storage->Create(Error, error);
    return result;
  }

  var Self:$$ Cancelled = (.discriminator = 2);

  interface MatchContinuation {
    fn Success(lval T: value);
    fn Failure(lval Error: error);
    fn Cancelled();
  }

  impl Matchable(MatchContinuation) {
    method Match[MatchContinuation:$ Continuation](
        Ptr(Self): this, Ptr(Continuation): continuation) {
      match (discriminator) {
        case 0 => {
          continuation->Success(this->storage.Read(T));
        }
        case 1 => {
          continuation->Failure(this->storage.Read(Error));
        }
        case 2 => {
          continuation->Cancelled();
        }
        default => {
          Assert(false);
        }
      }
    }
  }

  // Copy, move, assign, destroy, and similar operations need to be defined
  // explicitly, but are omitted for brevity.
}
```

In this code, `Result` makes itself available for use in pattern matching by
declaring that it implements the `Matchable` interface with a given continuation
interface. That interface, `MatchContinuation` in this case, tells the compiler
what kinds of patterns can be matched against this type, so that it can
typecheck the `match` expression. The compiler then invokes `Match` with a
concrete continuation object containing the actual code that implements the
different branches of the `match` expression, and `Match` invokes the
appropriate continuation.

This proposal assumes that Carbon will have support for defining and
implementing generic interfaces, including interfaces that take interface
parameters, and uses `interface`, `impl`, `method` etc. as **placeholder**
syntax. It can probably be revised to work if interfaces can't be parameterized
that way, or if we don't have a feature like this at all, but it might be
somewhat more awkward.

`lval T: value` is a **placeholder** syntax that indicates that this parameter
can be bound either in-place or by value when pattern matching against `Result`;
omitting the `lval` introducer would indicate that the parameter can only be
bound by value. The "`lval`" spelling is intended to pair with the
`ref Type: value` spelling for opting into in-place semantics in a pattern, and
is motivated by analogy with C++'s concept of an "lvalue": `ref` patterns can
only bind to `lval` parameters, just as non-const references can only bind to
lvalues in C++, because they represent durable objects rather than ephemeral
values. If we choose a different in-place syntax for patterns, we could
presumably find a corresponding syntax to use here.

With this approach, we no longer have pattern functions, or `alternatives`
blocks: factories like `Success` are entirely ordinary Carbon functions, with no
special restrictions. For example, we can now create objects inside `.storage`
procedurally, via a `Create` method. However, the price is that the factory
functions can no longer be used in patterns.

Consequently, the names `Success`, `Failure`, and `Cancelled` are defined twice,
once as factory functions of `Result` and once as member functions of
`MatchContinuation`, with the same arity and argument types in each case. Unlike
in the primary proposal, this correspondence is a design choice by the type
author; there is no language-level requirement that the alternatives correspond
to the factory functions. Consequently, there is no requirement that the factory
functions are exhaustive. There is a requirement that the interface methods are
mutually exclusive, but only in the sense that `Match` is required to call
exactly one of them.

This approach can be extended to support non-sum patterns as well. For example,
a type that wants to match a tuple-shaped pattern like `(Int: i, String: s)`
could define a continuation interface like

```
interface MatchContinuation {
  fn operator()(Int: i, String: s);
}
```

A type's continuation interface can also include a function named
`operator default`, which implements the `default` case of the `match`.
Consequently, any `match` on that type will be required to have a `default`
case, so this has roughly the same effect as omitting `closed` from the
`alternatives` block in the primary proposal.

> **Open question:** Can `Match` actually invoke `operator default`? It might
> sometimes be useful to define a type that can't be matched exhaustively, and
> the mere possibility that the `default` could actually run might help
> encourage client code to implement it robustly, rather than blindly providing
> something like `Assert(False)`. However, if there's no language-level
> guarantee that the `default` case is unreachable if all other alternatives are
> handled, then we won't be able to let same-library code omit the `default`.

This approach has a number of advantages:

-   Types can use the full power of the Carbon language when expressing how they
    participate in pattern matching. In particular, this means `Storage` doesn't
    need a complex initialization API, because its state can be set
    procedurally. More broadly, it's much less likely that a type will be unable
    to participate in pattern matching because of limitations of the language.
-   Patterns are allowed to be underconstrained. This means Carbon can more
    easily include operations like `|` in its pattern language, and it means
    types can make parts of the object state invisible to pattern matching (for
    example, non-salient state like the capacity of a `std::vector`).
-   The language rules are much simpler, and easier to explain, because we don't
    need to specify both "forward" and "reverse" semantics for a subset of the
    language, or specify the boundaries of that subset. Relatedly, it provides a
    simpler correspondence between the Carbon code and the generated assembly,
    which could substantially simplify things like debugging.

However, it also has some substantial drawbacks:

-   Manually-defined sum types will probably require dramatically more code,
    both because the special member functions cannot be generated automatically,
    and because the "forward" and "reverse" directions both require explicit
    code. This additional verbosity not only makes these types more tedious to
    write and read, it also creates a risk of bugs in the code that's being
    written by fallible humans instead of the compiler. The duplication of names
    may also create readability problems.
-   This approach only allows programmers to extend pattern matching to support
    new _types_, not new _operations_. For example, it doesn't directly give us
    a way to define `ArrayOfZeroes(N)` (see above) as an operator that can be
    used in patterns. However, it's possible that this feature could be extended
    to support user-defined pattern operations, by treating them as comparable
    to `Matchable.Match` except that they must be invoked by name rather than
    being invoked implicitly.
-   The process of translating a pattern-match into a `Match` call may require
    special overload resolution rules. Overload resolution is normally driven by
    the types of the arguments, but the concrete type of the argument to `Match`
    may not be known until quite late in the compilation process, because it
    could depend on the details of code generation. Instead, overload resolution
    will have to be driven by some more abstract representation of the "shape"
    of the callsite, such as a dummy type with the same interface as the actual
    argument, but potentially different implementation details. However, this
    might not be visible to users so long as the continuation parameter is
    passed as a generic rather than a template (`:$` rather than `:$$`).
-   Manually-defined sum types default to being closed, rather than open. This
    creates some risk that sum type authors will accidentally lock themselves
    out of the ability to add new alternatives.

One drawback is worth discussing in more depth: Carbon's parameter-passing
semantics might not be expressive enough to support this approach. The current
design is expressed in terms of a restricted form of pass-by-reference, but
there is substantial resistance to supporting any form of reference-like
parameter passing in Carbon. However, it is not clear how a purely pass-by-value
approach could replace the pass-by-reference placeholder design while retaining
its most important properties, such as:

-   The interface definition makes the structure of the sum type clearly legible
    to the reader, and makes it easy for the reader to disregard the distinction
    between parameters that do and do not support in-place binding if it's not
    relevant to them.
-   The code for a by-value binding doesn't depend on whether an in-place
    binding would also be supported.
-   The `Match` function's behavior depends solely on the value of the object,
    and not on any characteristics of the pattern, such as whether any given
    parameter is being bound in-place. Correspondingly, there's no need for a
    mechanism to convey information about the pattern to `Match`.

However, there are a number of other problems that Carbon will need to solve if
we want to avoid supporting pass-by-reference, and it's quite possible that
solving those problems will naturally solve these as well, or at least get us
closer to a solution. However, at this point that's no more than speculation, so
this approach carries a risk that we will eventually be forced to either abandon
it, or accept some form of pass-by-reference in Carbon.

> **Open question:** Does Carbon need to allow user-defined pattern matching
> code to optimize based on the presence of wildcards, and if so, how? In
> theory, `Match` might sometimes be able to avoid substantial amounts of work
> if it knows about wildcards in the pattern, because then it can supply them
> with dummy data rather than having to compute correct values. This is likely
> to be especially valuable if Carbon supports list patterns and variable-length
> wildcards (like Rust's `..`): most list-like types could in principle
> determine whether they match `{1, 2, ..}` in constant time, rather than pass
> their entire contents into the continuation, but the approach described so far
> doesn't allow them to implement such an optimization.

### Pattern matching proxies

As a variant of the previous approach, we could allow types to specify their
pattern-matching behavior in terms of a proxy type that Carbon "natively" knows
how to pattern-match against. In the case of a sum type, this proxy would be a
`choice` type, which means that `choice` needs to be a fundamental part of the
language, rather than syntactic sugar for a sum type struct. Returning once more
to the `Result` example:

```
struct Result(Type:$$ T, Type:$$ Error) {
  // Data members, factories, and special members same as above

  closed choice Choice {
    Success(ref T),
    Failure(ref Error),
    Cancelled
  }

  fn operator match(Ptr(Self): this) -> Choice {
    match (discriminator) {
      case 0 => {
        return .Success(this->storage.Read(T));
      }
      case 1 => {
        return .Failure(this->storage.Read(Error));
      }
      case 2 => {
        return .Cancelled;
      }
      default => {
        Assert(False);
      }
    }
  }
}
```

This approach has many of the same tradeoffs as the callback-based approach: it
substantially simplifies the language, and gives much greater freedom to type
authors, but obliges them to write substantially more code. It also has some
advantages over the callback-based approach:

-   It's somewhat simpler, because it uses return values instead of
    continution-passing
-   It could generalize more easily to allow things like types that can match
    list patterns (if Carbon has those).
-   Since choice types are no longer syntactic sugar for structs with factory
    functions, their syntax no longer needs to mirror the syntax of function
    declarations.

However, it also has several significant drawbacks:

-   It forces us to treat `choice` as a fundamental part of the language: in
    order to implement a sum type, you have to work with an object type whose
    layout and implementation is inherently opaque. This would be a substantial
    departure from C++, and it's difficult to foresee the consequences of that.
    Possibly the closest analogy in C++ is virtual calls, and especially virtual
    base classes, where fundamental operations like `->` and pointer casts can
    involve nontrivial generated code, and some aspects of object layout are
    required to be hidden from the user. However, Carbon seems to be moving away
    from C++ in precisely those ways.
-   It may be somewhat less efficient, because it requires instantiating the
    enclosing `Choice` type (presumably including a discriminator field), rather
    than merely passing the appropriate alternative into the continuation.
-   Not only might it require Carbon to support pass-by-reference, it comes very
    close to requiring Carbon to support reference _types_, which are even more
    contentious and problematic. This is already somewhat evident in the way
    `Choice` is defined, but becomes much clearer when this mechanism is used
    for product types, where allowing mutable bindings would require
    `operator match` to return a tuple of references.
-   The risk of confusion due to duplicate names is somewhat greater: a naive
    reader might think that, for example, `.Success` in the body of
    `operator match` refers to `Self.Success` rather than `Self.Choice.Success`.
    Relatedly, there's some risk that the author may omit the leading `.`, and
    thereby invoke `Self.Success` instead of `Self.Choice.Success`. This will
    probably fail to build, but the errors may be confusing.

I think these drawbacks decisively outweigh the advantages, so I do not
recommend this approach.
