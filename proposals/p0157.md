# Design direction for sum types

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/157)

## Table of contents

<!-- toc -->

-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Pattern matching](#pattern-matching)
-   [Pattern functions](#pattern-functions)
    -   [Alternatives considered](#alternatives-considered)
-   [`StorageArray`](#storagearray)
-   [`choice`](#choice)
    -   [Alternatives considered](#alternatives-considered-1)
        -   [Separate support for enumerated types](#separate-support-for-enumerated-types)
        -   [Different spelling for `choice`](#different-spelling-for-choice)
        -   [Different syntax for `closed`](#different-syntax-for-closed)
        -   [Allowing templated pattern functions](#allowing-templated-pattern-functions)
        -   [Make `choice` an element of a `struct`](#make-choice-an-element-of-a-struct)
        -   [More concise syntax for alternatives](#more-concise-syntax-for-alternatives)
-   [Alternatives considered](#alternatives-considered-2)
    -   [Indexing by type](#indexing-by-type)

<!-- tocstop -->

## Problem

Many important programming use cases involve values that are most naturally
represented as having one of several alternative forms (called _alternatives_
for short). For example,

-   Optional values, which are pervasive in computing, take the form of either
    values of some underlying type, or a special "not present" value.
-   Functions that cannot throw exceptions often use a return type that can
    represent either a successfully computed result, or some description of how
    the computation failed.
-   Nodes of a parse tree often take different forms depending on the grammar
    production that generated them. For example, a node of a parse tree for
    simple arithmetic expressions might represent either a sum or product
    expression with two child nodes representing the operands, or a
    parenthesized expression with a single child node representing the contents
    of the parentheses.
-   Boolean values take the form of either a "true" value or a "false" value.

What unites these use cases is that the set of alternatives is fixed by the API,
it is possible for user code to determine which alternative is present, and
there is little or nothing you can usefully do with such a value without first
making that determination.

Carbon needs to support defining and working with types representing such
values. Following Carbon's principles, these types need to be easy to define,
understand, and use, and they need to be safe -- in ordinary usage, the type
system should ensure that user code cannot accidentally access the wrong
alternative.

Furthermore, it needs to be possible for type owners to customize the
representations of these types. For example, sum types usually need a
"discriminator" field to indicate which alternative is present, but since it
typically has very few possible values, it can often be packed into padding, or
even the low-order bits of a pointer. This sort of customization inherently
creates a risk of implementation bugs that break type safety, but it must be
possible for correctly-implemented customizations to avoid changing the API, and
hence avoid weakening the static safety guarantees for users.

## Background

The terminology in this space is quite fragmented and inconsistent. This
proposal will use the term _sum types_ to refer to types of the kind described
in the problem statement. Note that "sum type" is not being proposed as a
specific Carbon feature, or even as a precisely defined term of art; it is
merely an informal way for this proposal to refer to its motivating use cases,
in much the same way that a structs proposal might refer to "value types".

Carbon as currently envisioned is already capable of approximating support for
sum types. In particular, [pattern matching](/docs/design/pattern_matching.html)
gives us a natural way to express querying which alternative is active, and then
performing computations on that active alternative, which as discussed above is
the primary way of interacting with a sum type. For example, a value-or-error
type `Result(T, Error)` could be implemented like so:

```
// Result(T, Error) holds either a successfully-computed value of type T,
// or metadata about a failure during that computation, or a singleton
// "cancelled" state indicating that the computation successfully complied with
// a request to halt before completion.
struct Result(Type:$$ T, Type:$$ Error) {
  // 0 if this represents a value, 1 if this represents an error, 2 if this
  // represents the cancelled state.
  var Int: discriminator;
  var T: value;
  var E: error;

  fn Success(T: value) -> Result(T, Error) {
    return (.discriminator = 0, .value = value, .error = E());
  }

  fn Failure(Error: error) -> Result(T, Error) {
    return (.discriminator = 1, .value = T(), .error = error);
  }

  var Result(T, Error):$$ Cancelled =
    (.discriminator = 2, .value = T(), .error = E());
}
```

A typical usage might look like:

```
fn ParseAsInt(String: s) -> Result(Int, String) {
  var Int: result = 0;
  var auto: it = s.begin();
  while (it != s.end()) {
    if (*it < '0' || *it > '9') {
      return Result(Int, String).Failure("String contains non-digit");
    }
    result += *it - '0';
    result *= 10;
  }
  return Result(Int, String).Success(result);
}

fn GetIntFromUser() -> Int {
  while(True) {
    var String: s = UserPrompt("Please enter a number");
    match (ParseAsInt(s)) {
      case (.discriminator = 0, .value = Int: value, .error = String: _) => {
        return value;
      }
      case (.discriminator = 1, .value = Int: _, .error = String: error) => {
        Display(error);
      }
      case .Cancelled => {
        // We didn't request cancellation, so something is very wrong.
        Terminate();
      }
      default => {
        // Can't happen, because the above cases are exhaustive.
        Assert(False);
      }
    }
  }
}
```

However, this code suffers from a number of serious deficiencies:

-   The implementation details of `Result` are not encapsulated. This makes the
    `Result` API unsafe: nothing prevents client code from accessing `.value`
    even when `.discriminator` is not 0. This also makes the patterns extremely
    verbose.
-   `.value` and `.error` must both be live throughout the `Result`'s lifetime,
    even when they are not meaningful. Consequently, `Success` must populate
    `.error` with a default-constructed dummy value (and so it won't work if
    `Error` is not default-constructible), `Failure` must do the same for
    `.value`, and `Cancelled` must do the same for both. Furthermore, `Result`
    is bloated by the fact that the two must have separately-allocated storage,
    even though at most one at a time actually stores any data.
-   `.discriminator` should never have any value other than 0, 1, or 2, but the
    compiler can't enforce that property when `Result`s are created, or exploit
    it when `Result`s are used. So, for example, the `match` must have a
    `default` case in order for the compiler and other tools to consider it
    exhaustive, even though that default case should never be entered.
    Furthermore, the type of `.discriminator` is somewhat misleading: its values
    are not numbers, but only symbolic tags. It will never make sense to perform
    arithmetic on it, for example.
-   The definition of `Result` is largely boilerplate. Conceptually, the only
    information needed to specify this type is the names and parameter types of
    the two factory functions, plus the fact that every possible value of
    `Result` is uniquely described by the name and parameter values of a call to
    one of those two functions. Given that information, the compiler could
    easily generate the rest of the struct definition. This generated
    implementation may not always be as efficient as a hand-coded one could be,
    but in a lot of cases that may not matter.

This code arguably exhibits another problem as well: the `return` statements in
`ParseAsInt` are quite verbose, due to the need to explicitly qualify the
function calls with `Result(Int, String)`. In fact, developers might prefer to
avoid having a function call at all, especially in the success case, and instead
rely on implicit conversions to write something like `return result;`. This
proposal will not address that problem, because it appears to be orthogonal to
the design of sum types.

## Proposal

To summarize, the previous section identified four deficiencies in Carbon, which
together prevent it from adequately supporting sum types:

-   There is no way for pattern matching to operate through an encapsulation
    boundary.
-   There is no way to manually control the lifetimes of subobjects, or enable
    them to share storage.
-   There is no way to define an enumerated type.
-   There is no way to define a sum type without micromanaging the details of
    its representation.

I propose supporting sum types by introducing three separate language features
to supply the missing functionality. These features are largely independent and
orthogonal, so their detailed design will be addressed in separate proposals.
This proposal merely establishes the overall design direction for sum types, in
the same way that [p0083](p0083.md) established the overall design direction for
the language as a whole.

To address the lack of encapsulation support in pattern matching, I propose
introducing the concept of a _pattern function_, which is a function that can be
invoked as part of a pattern, even with arguments that contain placeholders.
Pattern functions can only contain the sort of code that could appear directly
in a pattern, but they let us define reusable pattern syntaxes that can do
things like encapsulate hidden implementation details of the object they're
matching.

To address the lack of manual lifetime control and storage sharing, I propose
introducing a new fundamental type `StorageArray`, which represents a contiguous
region of raw memory.

To address the last two deficiencies, I propose introducing `choice` as a
convenient syntax for defining a sum type by specifying the set of possible
alternatives. The alternatives can be represented by factory functions like
`Success` and `Failure`, or singleton constants like `Cancelled`. In either
case, the definitions are omitted, because they are supplied by the compiler.
Choice types whose alternatives are all constants behave as enumerated types. A
choice type can be marked `closed`, which indicates that client code can assume
no new alternatives will be added in the future.

Using these features, the `Result(T, Error)` example can be rewritten as
follows:

```
struct Result(Type:$$ T, Type:$$ Error) {
  closed choice Discriminator {
    var Self:$$ IsValue;
    var Self:$$ IsError;
    var Self:$$ IsCancelled;
  }
  var Discriminator: discriminator;
  var StorageArray(Max(Sizeof(T), Sizeof(E))): storage;

  pattern Success(T: value) -> Result(T, Error) {
    return (.discriminator = Discriminator.IsValue, .storage = value);
  }

  pattern Failure(Error: error) -> Result(T, Error) {
    return (.discriminator = Discriminator.IsError, .storage = error);
  }

  var Self:$$ Cancelled = (.discriminator = Discriminator.IsCancelled);
}
```

The code for `ParseAsInt` is unchanged, and the rest of the usage example would
look like:

```
fn GetIntFromUser() -> Int {
  while(True) {
    var String: s = UserPrompt("Please enter a number");
    match (ParseAsInt(s)) {
      case .Success(var Int: value) => {
        return value;
      }
      case .Failure(var String: error) => {
        Display(error);
      }
      case .Cancelled => {
        // We didn't request cancellation, so something is very wrong.
        Terminate();
      }
    }
  }
}
```

Since our implementation of `Result` doesn't benefit from having direct control
of the object representation, we could instead define it more concisely like so:

```
closed choice Result(Type:$$ T, Type:$$ Error) {
  pattern Success(T: value) -> Self;
  pattern Failure(Error: error) -> Self;
  var Self:$$ Cancelled;
}
```

We don't yet have enough of a design for variadics to give an example of a
Carbon counterpart for `std::variant<Ts...>`, but a variant with exactly three
alternative types could be written like so:

```
choice Variant(Type:$$ T1, Type:$$ T2, Type:$$ T3) {
  pattern Value(T1: value) -> Self;
  pattern Value(T2: value) -> Self;
  pattern Value(T3: value) -> Self;
}
```

## Pattern matching

This proposal presupposes that pattern matching will be built around the
following basic intuition, which I will call the "substitution principle":

> A pattern is an expression in which zero or more terms have been replaced with
> variable binding declarations (`_` can be considered an anonymous binding
> declaration). If the pattern matches a given value, evaluating that expression
> by substituting the bound values back into the pattern will yield that value.

In particular, this implies that any operation that can be used in the body of a
pattern can also be used in an expression. This is not strictly a requirement of
this proposal, but to the extent that Carbon deviates from this principle, this
proposal may fit less well. In particular, if we want to support user-defined
operations that can appear only in patterns, we would need a customization
mechanism that's separate from pattern functions as described in this proposal,
and we may not want to have two separate customization mechanisms.

This proposal requires us to impose some sort of evaluation-order constraint on
pattern matching. For example, when matching `r` with the pattern
`.Success(T: value)` in the example above, we must be able to guarantee that we
do not recursively attempt to match the contents of `.storage` with `value`
until after we have successfully matched `.discriminator` with
`Discriminator.IsValue`. Otherwise, we risk trying to access a `T` object that
isn't actually present in `.storage`.

FIXME: How do we constrain evaluation to accomplish this? We've discussed
requiring that any subpatterns without placeholders be evaluated before any
subpatterns with placeholders, but that seems ad-hoc; it wouldn't protect a
pattern like `(.discriminator = Discriminator.IsValue, .storage = 1)`.

It's also worth noting some pre-existing requirements for pattern matching,
which will inform the design of pattern functions. These requirements are highly
desirable in any pattern matching system, but they are hard requirements if we
want to treat C++-like overload resolution as a form of pattern matching:

-   Carbon pattern matching must not only be able to determine whether a pattern
    matches a value, and bind values to its variables, but also be able to
    select the _best_ pattern when more than one matches. Patterns are partially
    ordered by specificity, so for example `(Int: x, 1)` is a better match than
    `(Int: x, Int: y)` in the cases where they both match. This is not a total
    order, or even a weak order (intuitively, a total order with "ties"); for
    example, there is no ordering between `(Int: x, 1, 1)` and either
    `(1, Int: y, Int: z)` or `(1, 1, Int:z)`, but we can't just say that all
    three are "tied", because `(1, 1, Int: z)` is more specialized than
    `(1, Int: y, Int: z)`. This order should at least form a
    [lattice](<https://en.wikipedia.org/wiki/Lattice_(order)>), but that's not
    directly relevant here.
-   Carbon must be able to determine whether a given set of patterns is
    _exhaustive_, meaning that for any possible value at least one of them will
    match. It must also be able to determine whether a set of patterns is
    _ambiguous_, meaning that the set contains two or more patterns that are not
    ordered with respect to each other, and that can match the same value.

## Pattern functions

Pattern functions have the same declaration syntax as ordinary functions, except
that they are introduced with `pattern` rather than `fn`. However, the function
body is required to be a single `return` statement whose operand expression is a
valid pattern, with the function parameters acting as variable bindings.

It seems likely that pattern functions will be required to be inline, because
they will probably need to generate very different code depending on the
structure of their arguments, particularly if the arguments contain
placeholders.

FIXME: anything else to say about pattern functions?

### Alternatives considered

The substitution principle implies that pattern matching can be thought of as
the inverse of expression evaluation: given the purported value of an
expression, we are trying to work backwards to determine the values for
variables in the expression. This proposal allows users to define custom
patterns in terms of expressions, by restricting their definitions to a narrow
subset of the language that we know how to invert automatically. As an
alternative, we could allow developers to define custom patterns by directly
specifying the code that should be executed during pattern matching. This
obliges them to determine the correct inverse computation themselves, but
permits them to express it in terms of the full Carbon language.

However, this approach creates the risk that user-defined patterns will not
satisfy the substitution principle, either due to bugs or because developers
want to use pattern matching syntax to express logic that has no counterpart in
expression evaluation. Furthermore, it requires the developer to write code for
both the forward and reverse computations, unless we choose to embrace the
possibility of syntaxes that can only occur in patterns, and so don't satisfy
the substitution principle.

Furthermore, as discussed above, Carbon pattern matching needs to be able to not
only determine whether a pattern matches, but also rank patterns, and determine
whether a set of patterns is exhaustive and/or ambiguous. Defining a custom
pattern in terms of arbitrary forward and reverse functions doesn't give the
compiler enough information to do those things, so the developer would need to
supply additional information in some way, and it's not at all clear how that
would work.

## `StorageArray`

This approach to sum types imposes relatively few requirements on the type used
to implement shared storage. I'm proposing an untyped byte buffer here because
it's more general, but union types along the lines of proposal
[0139](https://github.com/carbon-language/carbon-lang/pull/139) would work just
as well.

However, the one major requirement we do have is a tricky one: it must be
possible to initialize an instance of the shared storage type from an instance
of any of the values that it can represent, and to do so inside a pattern or
pattern function. This proposal uses the obvious assignment-style syntax for
that, so in the above example we use `.storage = value` to initialize `.storage`
to hold the value `value`. However, this implies that there is something like an
implicit conversion to `StorageArray(N)` from _any_ type whose size is at most
`N`, and such broad implicit conversions often cause substantial maintenance and
readability problems, at least in C++.

As an alternative, we could require the conversion to be explicit, making the
syntax something like
`.storage = StorageArray(Max(Sizeof(T), Sizeof(E)))(value)`. However, this
requires repeating the size parameter, which is logically redundant and
syntactically somewhat annoying (although an alias could help). We could split
the difference and define a factory function whose return type implicitly
converts to `StorageArray(N)` for any sufficiently large `N`, making the example
look like `.storage = MakeStorageArray(value)`, but that only works if Carbon
provides something equivalent to C++'s "guaranteed RVO", because `T` may not be
movable and `StorageArray(N)` definitely won't (and that guaranteed RVO needs to
work even though the right and left sides of the initialization have different
types).

Either of those alternatives would also be fairly misleading from a readability
perspective, because they look like function or constructor calls, but they
can't actually _be_ function or constructor calls. Recall that this syntax needs
to be usable inside patterns, so these functions would need to be pattern
functions, which means they would need to consist of a single expression that
initializes the `StorageArray(N)`, and the whole problem we're trying to solve
here is to make it possible to write such an expression.

At a deeper level, the problem is that the whole notion of allowing multiple
objects to successively share the same storage is inherently procedural (because
it involves changes in state over time), but pattern matching is fundamentally
descriptive, and hence functional.

A design in which user-defined patterns can be expressed in terms of procedural
forward and reverse functions would avoid this whole problem, by allowing us to
express storing the alternative in terms of procedural code (such as some
equivalent of C++'s placement `new`) rather than initialization.

## `choice`

A choice type definition has the same general form as a struct definition, but a
choice type can only contain declarations of pattern functions and compile-time
constants (in other words, variables declared with `$$`). The definitions of
those members will be provided by the compiler; they cannot be defined in user
code. The return type of the pattern functions, and the type of the constants,
must be the choice type being declared.

The pattern functions of a choice type can be overloaded (as in the `Variant`
example above), but they cannot be templates. More precisely, the parameter
types of a pattern function in a choice type can't depend on any of the
arguments.

Carbon will probably have some mechanism for allowing a struct to have
compiler-generated default implementations of operations such as copy, move,
assignment, hashing, and equality comparison, so long as the struct's members
support those operations. Assuming that mechanism exists, choice types will
support it as well, with the parameter types of the pattern functions taking the
place of the member types. However, there are a couple of special cases:

-   choice types cannot be default constructible, unless we provide a separate
    mechanism for specifying which alternative is the default.
-   choice types can be assignable, regardless of whether the parameter types
    are assignable, because assigning to a choice type always destroys the
    existing alternative, rather than assigning to it.

A future proposal for this mechanism will need to consider whether to require an
explicit opt-in to generate these operations.

The compiler-generated definitions of a choice type's members are unspecified,
except that they will satisfy the following two properties:

-   The alternatives are _mutually exclusive_: an enumerator can only compare
    equal to copies of itself, and the result of calling a factory function can
    only compare equal to the result of calling the same factory function with
    the same arguments.
-   The alternatives are _exhaustive_: every possible value of the type is equal
    to one of the enumerators, or to the result of invoking one of the factory
    functions with some set of arguments.

Although choice types are always exhaustive as far as the language semantics are
concerned, by default user code will be required to treat them as
non-exhaustive. For example, a `match` statement that operates on a value of a
choice type will be required to have a `default` case, even if it also has
patterns that match all of the declared alternatives. This ensures that choice
types can be extended with new alternatives without breaking any existing code.
Declaring a type with `closed choice` rather than `choice` allows client code to
treat the type as exhaustive.

### Alternatives considered

#### Separate support for enumerated types

This proposal supports enumerated types as a special case of choice types.
However, there may be some benefit to providing special-case support for
enumerated types, similar to C++'s `enum`. In particular:

-   We could more easily avoid the `var Self:$$` boilerplate in enumerator
    declarations.
-   We could allow the developer to specify an underlying type, associate a
    specific value of the underlying type with each enumerator, and convert
    between the enum and the underlying type, which are fairly common practices
    in C++ code. When using choice types, these practices can be emulated by
    defining functions that map between the choice type and the underlying type,
    but that requires a substantial amount of error-prone boilerplate.
    Furthermore, those functions can't reliably be no-ops at the hardware level,
    the way they can be with C++ enums.
-   It would allow us to treat choice types as purely syntactic sugar for struct
    definitions. We can't quite do that at present because the desugared form
    would itself contain a `choice` type, as with the long version of `Result`
    above.

I am omitting that from this proposal for simplicity, since it's purely
additive, and not necessary for the goals of this proposal.

#### Different spelling for `choice`

The Rust and Swift counterparts of `choice` are spelled `enum`. I have avoided
this because these types are not really "enumerated types" in the sense that all
values are explicitly enumerated in the code, except in the special case where
there are no factory functions. I chose the spelling `choice` because "choice
type" is one of the only available synonyms for "sum type" that doesn't have any
potentially-misleading associations.

#### Different syntax for `closed`

The `closed` syntax should be considered little more than a placeholder. It's
somewhat unconventional for a modifier to come before an introducer, as with
`closed choice`. Reversing the order would fix that problem, but `choice closed`
reads quite awkwardly as English. Making `closed` a keyword would prevent
developers from using `closed` as an identifier, which may be too high a cost
for such a niche use case. We could fix that by making it an attribute rather
than a keyword, but it's not clear that Carbon will have attributes, much less
what the syntax would be.

It may be surprising that there is no corresponding `open choice` syntax, but
`open` would be meaningless syntactic noise unless we made it mandatory, and
making it mandatory would be poor ergonomics, because developers would be forced
to make an up-front decision between the two, rather than relying on a safe
default. Furthermore, reserving `open` as a keyword seems even more problematic
than reserving `closed`.

#### Allowing templated pattern functions

We could remove the restriction that pattern functions can't be templated. This
would allow defining something like `std::any` as a choice type:

```
choice Any {
  pattern Value[Type:$$ T](T value);
}
```

The problem is that there's no bound on the amount of storage that an instance
of this type would require, so the compiler-generated code would have to
allocate storage on the heap, and decide whether to apply a small-buffer
optimization, and if so what size threshold to use. This would make the
performance of choice types far less predictable, contrary to Carbon's
performance goals, and would have little offsetting benefit: these sorts of
types appear to be rare, and when needed they should be implemented in library
code, where the performance tradeoffs are explicit and under programmer control.

> TODO: we should ensure that such a library type can support pattern matching.
> The primary challenge is that the factory function will need to allocate heap
> memory, so we will need to ensure that pattern functions are permitted do so.
> Resolution of this issue must await a design for heap allocation.

#### Make `choice` an element of a `struct`

Instead of introducing `choice` as a new kind of type declaration, we could
instead treat it as an optional component of a `struct` declaration. For
example, with this approach `Result(T, Error)` would be defined as:

```
struct Result(Type:$$ T, Type:$$ Error) {
  choice {
    pattern Success(T: value) -> Self;
    pattern Failure(Error: error) -> Self;
    var Self:$$ Cancelled;
  }
}
```

This approach is somewhat more flexible, because it would permit the type owner
to give `Result` additional member functions by placing them outside the
`choice` block. However, it still wouldn't be possible to give `Result`
additional data members, because the alternatives would have no way to
initialize them, so structs containing a `choice` block would be starkly
different from ones that don't. This approach would also be more verbose,
especially vertically, which will be especially noticeable since choice types
will probably be quite small in the common case.

A variant of this approach would be to allow `choice` declarations to be either
named, in which case they behave as currently proposed, or anonymous, in which
case they must appear inside a struct, and behave as described here. This would
address the increased verbosity by limiting it to the cases where there's an
offsetting benefit. However, it would make the language more ambiguous, since a
`choice` declaration would have a substantially different meaning depending on
whether it's followed by an identifier.

#### More concise syntax for alternatives

We could introduce a special syntax for declaring alternatives, rather than
using the existing syntaxes for pattern functions and static variables. Such a
syntax could be substantially more concise, because it could omit the components
that are just boilerplate in the context of a choice type. For example, the
definition of `Result(T, Error)` might look like this:

```
choice Result(Type:$$ T, Type:$$ Error) {
  alt Success(T);
  alt Failure(Error);
  alt Cancelled;
}
```

However, this brevity would come at the cost of consistency: there would now be
two structurally different syntaxes for declaring functions, and two
structurally different syntaxes for declaring static constants.

## Alternatives considered

### Indexing by type

Rather than requiring each alternative to have a distinct name (or at least a
distinct function signature), we could pursue a design that requires each
alternative to have a distinct type. With this approach, which I'll call
"type-indexed" as opposed to "name-indexed", Carbon sum types would much more
closely resemble C++'s `std::variant`, rather than Swift and Rust's `enum` or
the sum types of various functional programming languages.

Either approach can be emulated in terms of the other: the `Variant` example
above shows how we can use overloading to emulate type-indexing in our
name-indexed framework, and conversely a type-indexed type like `std::variant`
can model a name-indexed type like `Result(T,E)` by introducing a wrapper type
for each name, leading to something like `std::variant<Value<T>, Error<E>>`
(note that `std::variant<T,E>` would not work, because `T` and `E` can be the
same type). In either case, emulating the other model introduces some syntactic
overhead: with name-indexing, `Variant`'s factory functions must be given a name
(`Value`) even though it doesn't really convey any information, and emulating
`Result(T,E)` in terms of type-indexing requires separately defining the wrapper
templates `Value` and `Error`.

The distinction between these two models of sum types seems analogous the
distinction between the tuple and struct models of product types. Tuples and
type-indexed sum types treat the data structurally, in terms of types and
positional indices, but structs and name-indexed sum types require the
components of the data to have names, which contributes to both readability and
type-safety by attaching higher-level semantics to the data.

It is possible that both models of sum types could coexist in Carbon, just as
structs and tuples do. However, that seems unlikely to be a good idea: the
coexistence of tuples and structs is necessitated by the fact that it is quite
difficult to emulate either of them in terms of the other in a type-safe way,
but as we've seen, it's fairly straightforward to emulate either model of sum
types in terms of the other.

Use cases that work best with type-indexing appear to be quite rare, just as use
cases for tuples appear to be quite rare compared to use cases for structs.
Consequently, if Carbon has only one form of sum types, it should probably be
the name-indexed form, as proposed here.
