# Generics: Set associated constants using `where` constraints

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/1013)

<!-- toc -->

## Table of contents

-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Rationale based on Carbon's goals](#rationale-based-on-carbons-goals)
-   [Alternatives considered](#alternatives-considered)

<!-- tocstop -->

## Problem

There are a variety of contexts we are currently using the keyword `let`:

-   declaring associated constants or types in an interface,
-   defining associated constants or types in an implementation,
-   defining local constant in a function body, and
-   defining class constants.

In all but the implementation case, the semantics are generally similar to the
semantics of passing a value into a function, with some erasing of the specific
value passed and using the type to determine how the name can legally be used.
However,
[proposal #950](https://github.com/carbon-language/carbon-lang/pull/950) has
changed the `let` in an implementation to use the value specified, not its type,
creating an inconsistency with the other uses of `let`.

Furthermore, we have come to the realization that we still want to specify the
values of associated constants and types for an implementation even in an API
file where we only want to make a forward declaration. This makes that
information available to clients that only look at the API file, who need to
know those values for type checking, but otherwise don't need to see the full
definition of the implementation. This suggests that those assignments should be
declared outside of definition block in curly braces `{`...`}`.

Lastly, there is a bit of redundancy in Carbon since `where` clauses are also a
way of specifying the values of associated constants and types in other Carbon
contexts.

## Background

The `let` syntax for setting an associated type in an interface implementation
was originally decided in issue
[#739: Associated type syntax](https://github.com/carbon-language/carbon-lang/issues/739)
and implemented in proposal
[#731: Generics details 2: adapters, associated types, parameterized interfaces](https://github.com/carbon-language/carbon-lang/pull/731).

Proposal
[#950: Generics details 6: remove facets](https://github.com/carbon-language/carbon-lang/pull/950)
made two relevant changes:

-   The type part of a `let` in an `impl` block is no longer "load bearing": the
    only legal types are `auto` and whatever was in the corresponding interface.
    In particular, the `let` in an `impl` block does not erase.
-   There is now a defined meaning for a generic `let` statement in a function
    body that can erase depending on the type specified.

Combined with the `let` in an interface giving you an erased type, or archetype,
this has made the meaning of `let` in an `impl` block inconsistent with other
places using `let`.

## Proposal

The suggested change is to use a `where` clause as part of an `impl` declaration
to specify associated constants and types instead of `let` declarations inside
of the `impl` definition. In effect, it removes `let` declarations from `impl`
blocks in exchange for allowing an `impl` declaration to implement a constraint
expression instead of a simple interface or named constraint.

This proposal updates the following design docs on the generics feature to
reflect this change:

-   [docs/design/generics/overview.md](/docs/design/generics/overview.md)
-   [docs/design/generics/terminology.md](/docs/design/generics/terminology.md)
-   [docs/design/generics/details.md](/docs/design/generics/details.md)

## Rationale based on Carbon's goals

TODO: How does this proposal effectively advance Carbon's goals? Rather than
re-stating the full motivation, this should connect that motivation back to
Carbon's stated goals for the project or language. This may evolve during
review. Use links to appropriate goals, for example:

-   [Community and culture](/docs/project/goals.md#community-and-culture)
-   [Language tools and ecosystem](/docs/project/goals.md#language-tools-and-ecosystem)
-   [Performance-critical software](/docs/project/goals.md#performance-critical-software)
-   [Software and language evolution](/docs/project/goals.md#software-and-language-evolution)
-   [Code that is easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write)
-   [Practical safety and testing mechanisms](/docs/project/goals.md#practical-safety-and-testing-mechanisms)
-   [Fast and scalable development](/docs/project/goals.md#fast-and-scalable-development)
-   [Modern OS platforms, hardware architectures, and environments](/docs/project/goals.md#modern-os-platforms-hardware-architectures-and-environments)
-   [Interoperability with and migration from existing C++ code](/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code)

## Alternatives considered

TODO: What alternative solutions have you considered?
