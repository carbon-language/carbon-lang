# Reduce ambiguity in terminology

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/3162)

<!-- toc -->

## Table of contents

-   [Abstract](#abstract)
-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Details](#details)
-   [Rationale](#rationale)
-   [Alternatives considered](#alternatives-considered)

<!-- tocstop -->

## Abstract

Change terminology away from terms that are ambiguous:

-   Reserve "generic type" for types with (compile-time) parameters, like
    `Vector` in `Vector(T:! type)`. Don't use that term to refer to `T`, as it
    would with
    [#2360](https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p2360.md#terminology).
-   Use the term "compile-time" instead of "constant" to mean "template or
    symbolic." Expand the term "constant" to include values, such as from `let`
    bindings.

## Problem

Right now, the term "generic type" has two meanings. In this example:

```
class Vector(T:! type);
```

Both `Vector` and `T` could be called a "generic type." It would be much less
confusing if one of those two would have a different name.

Similarly, "constant" can currently mean multiple things:

-   "evaluation at compile time," as in "constant evaluation"
-   "not variable," as in `let` instead of `var`
-   "non-mutating view," as in `const T*`

In practice, this has resulted in confusion. For example, the term "constant
bindings" doesn't include all `let` bindings, even though they are not variable
bindings.

## Background

The two meanings of "generic type" come from:

-   Proposal [#2360](/proposals/p2360.md#terminology) defines a generic type to
    be a type or facet introduced by a `:!` binding, such as in a generic
    parameter or associated constant.
-   Other uses of the term generic, such as in generic function, mean a language
    construct with a compile-time parameter (as in
    [Rust](https://doc.rust-lang.org/rust-by-example/generics.html)). This is
    the usage in the broader programming language community, and includes
    calling parameterized types "generic types" (as in
    [Java](https://docs.oracle.com/javase/tutorial/java/generics/types.html),
    [.NET](https://learn.microsoft.com/en-us/dotnet/standard/generics/#terminology),
    [Swift](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/generics/#Generic-Types)).

Issue
[#1391: New name for "constant" value phase](https://github.com/carbon-language/carbon-lang/issues/1391)
implemented in proposal
[#2964: Expression phase terminology](https://github.com/carbon-language/carbon-lang/pull/2964),
expanded the term "constant" from referring to just template constants to also
include symbolic constants from checked generics. Since then proposal
[#2006: Values, variables, pointers, and references](https://github.com/carbon-language/carbon-lang/pull/2006)
introduced the `const` modifier on types, providing a read-only view.

## Proposal

TODO: Briefly and at a high level, how do you propose to solve the problem? Why
will that in fact solve it?

## Details

TODO: Fully explain the details of the proposed solution.

## Rationale

TODO: How does this proposal effectively advance Carbon's goals? Rather than
re-stating the full motivation, this should connect that motivation back to
Carbon's stated goals and principles. This may evolve during review. Use links
to appropriate sections of [`/docs/project/goals.md`](/docs/project/goals.md),
and/or to documents in [`/docs/project/principles`](/docs/project/principles).
For example:

-   [Community and culture](/docs/project/goals.md#community-and-culture)
-   [Language tools and ecosystem](/docs/project/goals.md#language-tools-and-ecosystem)
-   [Performance-critical software](/docs/project/goals.md#performance-critical-software)
-   [Software and language evolution](/docs/project/goals.md#software-and-language-evolution)
-   [Code that is easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write)
-   [Practical safety and testing mechanisms](/docs/project/goals.md#practical-safety-and-testing-mechanisms)
-   [Fast and scalable development](/docs/project/goals.md#fast-and-scalable-development)
-   [Modern OS platforms, hardware architectures, and environments](/docs/project/goals.md#modern-os-platforms-hardware-architectures-and-environments)
-   [Interoperability with and migration from existing C++ code](/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code)

## Alternatives considered

TODO: What alternative solutions have you considered?
