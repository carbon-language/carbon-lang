# Unions

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/0139)

## Table of contents

<!-- toc -->

-   [Problem](#problem)
-   [Proposal](#proposal)
-   [Design rationales](#design-rationales)
    -   [No discriminator](#no-discriminator)
    -   [No type punning](#no-type-punning)
    -   [Unions and field groups are not types](#unions-and-field-groups-are-not-types)
    -   [Unions do not have names](#unions-do-not-have-names)
    -   [`create` and `destroy` are union-only](#create-and-destroy-are-union-only)
    -   [No layout packing at the end of a union](#no-layout-packing-at-the-end-of-a-union)
    -   [Nesting restrictions](#nesting-restrictions)
-   [Deferred decision rationales](#deferred-decision-rationales)
    -   [Safety strategy](#safety-strategy)
    -   [Type punning](#type-punning)

<!-- tocstop -->

## Problem

Software often needs to express concepts such as a value that may or may not be
present, a variable whose value has one of several types, or a set of object
fields, of which only one at a time is present. Carbon will need to support
those use cases, and it will need to do so efficiently.

## Proposal

This proposal introduces _unions_ to act as a low-level primitive underlying all
the use cases described above. The intent is that most users will never need to
use unions directly; instead, they will use libraries and other higher-level
facilities that are implemented in terms of unions. As such, this design focuses
on generality and efficiency, rather than user-friendliness or static safety.

## Design rationales

### No discriminator

In this proposal, Carbon unions are not discriminated: there is no way to query
which field of a union is active, and user code is responsible for ensuring that
a union field is only accessed or destroyed while it is active, and only created
if no union field is active. This motivated by Carbon's performance goals:
embedding a discriminator in every union would be wasteful in cases where the
code can store the discriminator more efficiently elsewhere, or track the active
field by other means. Furthermore, a hidden discriminator field would make it
more difficult for developers to understand and control the layout of their data
in memory (much like the hidden vptr field in many C++ objects).

It will of course be important for Carbon to support discriminated unions (also
known as "sum types", "algebraic data types", "variant types", or "enumerated
types"), especially for use with pattern matching, but they will be addressed by
a separate proposal that builds on this one.

### No type punning

This proposal does not permit accessing an inactive union member. This is unlike
C++, which permits assigning to an active member as a way of making it active,
and permits reading from inactive members when they're part of a common initial
sequence, as well as in a much broader but more nebulous set of
implementation-defined situations.

The fundamental reason for these restrictions is to ensure that the code
expresses the programmer's intent clearly. Accessing a field that happens to
share storage with other fields is a very different operation from
reinterpreting the bytes of an object as if they had a different type. Making
them statically indistinguishable would make the code more difficult to read,
prevents the toolchain from detecting and diagnosing bugs, and may foreclose
useful optimization opportunities.

These restrictions also substantially simplifies the design of the language: we
can much more easily provide a feature that addresses storage-sharing use cases,
and a feature that addresses type-punning use cases, if we do not a priori
require them to be the same feature.

### Unions and field groups are not types

This proposal introduces the concept of a "field group", and specifies that
unions and field groups are not types, but rather elements of a struct
definition. Use cases like `SsoString` can require a union to start at any
alignment, or even between the bits of a byte, but the alignment of a
stand-alone object type is constrained by platform requirements and the fact
that object addresses cannot represent bit-level offsets.

Of course, we could allow the programmer opt into treating a given union as a
type, for example by providing a name between `union` and the opening brace, and
we could further permit (or require) union types to be defined without an
enclosing struct. However, this would substantially complicate the syntax and
semantics of unions; for example, otherwise-identical unions could have
different layouts if one of them is a type. Furthermore, this extra complexity
would provide very little benefit; at best, it would save 8 to 12 characters in
the type definition (`union U {...}` instead of `struct U { union {...} }`).

### Unions do not have names

This proposal does not permit unions to have names. Union names would add a
layer of hierarchy to the names of union fields that seems to be unnecessary in
the common case. For example, it's difficult to come up with a name for the
`SsoString` union that would be anything other than boilerplate
(`sso_str.rep.small.size`? `sso_str.u.small.size`?).

This makes unions somewhat inconsistent with field groups, which are otherwise
very much duals of each other in the same way as sum types and product types,
but this is more of an aesthetic concern than a technical one. More
substantively, there are two cases in which union names seem like they might be
useful. However, in both cases the actual utility seems limited.

First, it's tempting to think of an inactive union as equivalent to an
uninitialized field. If that were the case, initialization shouldn't leave the
union in an inactive state unless the initializer explicitly requests it via a
syntax like `.union_name = uninit`, which would require us to name the union.
However, that's a false analogy: the defining characteristic of an uninitialized
or indeterminate value is that we know nothing about its state, whereas we know
everything there is to know about the state of an inactive union. In particular,
we know that it satisfies the preconditions for the `create:` operation. Thus,
an inactive union is much more like a disengaged optional value than an
uninitialized value. To put the point more pragmatically, we require `= uninit`
to be explicit for types like integers because programmers have a strong default
expectation that an integer variable holds a meaningful value. There is no
corresponding default expectation that unions will always have an active member,
so there is no need for special syntax to opt out of such a default.

Second, it may be surprising that a pattern can match a struct containing a
union, even if the pattern doesn't mention the union or any of its members. If
unions had names, we could avoid that surprise by requiring patterns to
explicitly disregard the union with a syntax like `.union_name = _`. However,
that would be surprising in a different way: `_` would be literally the only
pattern syntax that could appear after the `=` sign. Such a syntax seems to
promise more than it can deliver.

In both cases, giving unions names would at most add a small amount of static
safety around the edges of a construct that is fundamentally not statically
safe.

### `create` and `destroy` are union-only

In this proposal, `create` and `destroy` can only be applied to union members,
not to other struct fields or local variables. This is motivated primarily by
readability: it gives us a rule that the lifetime of a local variable or struct
field always extends to the end of its scope, unless its declaration explicitly
says otherwise.

### No layout packing at the end of a union

This proposal allows a union to be "packed" together with the fields prior to
it, but not the fields following it. It appears to be feasible to allow packing
at the end of a union, but it's not clear that there are any compelling use
cases for it. In particular, packing at the end of a union is not necessary to
compensate for the absence of initial-common-sequence punning. Conversely,
allowing packing at the end of a union would make it more difficult to tell when
accesses to two separate fields can cause a data race.

### Nesting restrictions

This proposal does not allow a union to be directly nested within a union, or a
field group to be directly nested within a field group or struct. Such
constructions would be logically valid: a union nested within a union would be
equivalent to a single union containing both sets of members. Similarly, a field
group nested within a field group or struct would be equivalent to a single
field group or struct containing both sets of members, except that the inner
field group adds a level of hierarchy to the field names. Given the marginal
utility these constructions provide, any occurrences of them seem more likely to
be mistakes than intentional choices that we should support.

## Deferred decision rationales

### Safety strategy

There are serious unresolved questions about how to check for or mitigate
accesses to inactive union members, especially in hardened production builds.
Arguably, it might make sense to postpone adopting this proposal until those
issues are resolved, in case resolving those issues turns out to require a
substantially different design for unions.

However, that seems unlikely to be helpful. This problem is not specific to this
particular design for unions, or indeed to unions as a language feature; we
would encounter much the same problem with any language feature that allows a
subobject pointer to be invalidated while the enclosing complete object is still
live. "Temporal memory safety", the property that objects are not accessed
outside their lifetime, has proven to be quite difficult to check efficiently
even for complete objects; checking subobject lifetimes adds a new layer of
complexity, because we can no longer use techniques like embedding bookkeeping
information before or after the object.

### Type punning

Carbon will almost certainly need some mechanism for reinterpreting the bytes
representing one type as if they represented a different type. This proposal
does not address the design of that feature, other than to say it will be a
separate from unions for the reasons laid out [above](#No_type_punning).

One of the most crucial questions about type-punning is whether it can take
place through pointers. In other words, is it possible to form pointers to
objects of two unrelated types, such that you can store data through one
pointer, and then reinterpret the underlying representation by reading through
the other pointer? If so, that feature might have substantial overlap with
unions, because it can act as an implementation substrate for both Carbon and
C++ unions, and potentially a basis for interoperating between them.
Consequently, it might make sense to design them together.

However, we currently hope that punning through pointers will not be possible in
Carbon, or will be heavily restricted (for example, to only allow punning
between an object's actual type and an array of bytes). If that's the case,
there will be no substantive overlap between that feature and unions, and hence
little benefit in designing them together. Even if that turns out not to be the
case, it seems likely that the design for unions can be retrofitted at that
time.
