# Expression category dependence in operators

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/3985)

<!-- toc -->

## Table of contents

-   [Abstract](#abstract)
-   [Background](#background)
-   [Problem](#problem)
-   [Proposal](#proposal)
-   [Details](#details)
-   [Rationale](#rationale)
-   [Alternatives considered](#alternatives-considered)

<!-- tocstop -->

## Abstract

## Background

Proposal [#2274](https://github.com/carbon-language/carbon-lang/pull/2274)
introduced interfaces for overloaded operators. The interface used depends on
the expression category of the container type being indexed:

> Carbon will support indexing using the conventional `a[i]` subscript syntax.
> When `a` is an l-value, the result of subscripting will always be an l-value,
> but when `a` is an r-value, the result can be an l-value or an r-value,
> depending on which interface the type implements:
>
> -   If subscripting an r-value produces an r-value result, as with an array,
>     the type should implement `IndexWith`.
> -   If subscripting an r-value produces an l-value result, as with a slice,
>     the type should implement `IndirectIndexWith`.
>
> `IndirectIndexWith` is a subtype of `IndexWith`, and subscript expressions are
> rewritten to method calls on `IndirectIndexWith` if the type is known to
> implement that interface, or to method calls on `IndexWith` otherwise.

**Note**: The above predates the renaming of "l-value" to "reference expression"
\*and of "r-value" to "value expression".

Proposal [#3720](https://github.com/carbon-language/carbon-lang/pull/3720)
introduced interfaces for member binding. The interface used also depends on the
expression category of the type being indexed:

> -   For a value expression `x` with type `T` and an expression `y` of type
>     `U`, `x.(y)` is `y.((U as BindToValue(T)).Op)(x)`.
> -   For a reference expression `x` using a member binding `var x: T` and an
>     expression `y` of type `U`, `x.(y)` is `*y.((U as BindToRef(T)).Op)(&x)`.

## Problem

In a generic context, we don't in general know whether the type being
subscripted or indexed implements `IndirectIndexWith` or `BindToRef`. If we
perform a rewrite to the corresponding interfaces in a generic context, the
behavior can depend on which interfaces we happen to know the type implements,
and the behavior can change sharply if we learn more about the interfaces
implemented by the type. This knowledge can even arise implicitly in some cases.

```carbon
class Slice {}
class Element {}
class Member {}

impl Slice as IndirectIndexWith(i32) where .Result = Element;
impl forall [T:! type] Member as BindToValue(T) where .Result = i32 {
  fn Op[self: Self](x: T) -> i32 {
    return 1;
  }
}
impl forall [T:! type] Member as BindToRef(T) where .Result = i32 {
  fn Op[self: Self](x: T) -> i32 {
    return 2;
  }
}

class Generic(T:! type) {}

fn F[I:! IndexWith(i32)](unused g: Generic(I), i: I) -> i32 {
  return i[0].({} as Member);
}

fn Run() {
  Print("{0}", F({}, {} as Slice));
}
```

The behavior here depends on whether `I` is known to implement
`IndirectIndexWith(i32)`.

-   If not, then `i[0]` is a value expression, the binding uses `BindToValue`,
    and the program prints 1.
-   If so, then `i[0]` is a reference expression, the binding uses `BindToRef`,
    and the program prints 2.

In the above, we don't know that `I` implements `IndirectIndexWith(i32)`, so the
program prints 1. But if we make a seemingly-unrelated change to `Generic`:

```diff
-class Generic(T:! type) {}
+class Generic(T:! IndirectIndexWith(i32)) {}
```

then `F` picks up an implicit constraint that `T` implements
`IndirectIndexWith(i32)` then the program now prints 2.

## Proposal

Add another interface, `BindToRefAsValue`:

```carbon
// For a reference expression `x` using a member binding `var x: T`
// and an expression `y` of type `U`, `x.(y)` is
// `y.((U as BindToRefAsValue(T)).Op)(&x)` if `U as BindToRef(T)`
// is not known to be implemented.
interface BindToRefAsValue(T:! type) {
  extend Bind(T);
  fn Op[self: Self](p: T*) -> Result;
}
```

Binding to a reference uses `U as BindToRef(T)` if that interface is known to be
implemented, and `U as BindToRefAsValue(T)` otherwise.

In order to avoid the possibility that adding type information changes behavior,
a `final` blanket implementation of `BindToRefAsValue` in terms of `BindToValue`
is provided. For convenience, in order to allow `BindToRef` types to be passed
to generics with a `BindToRefAsValue` constraint, a non-`final` blanket
implementation of `BindToRefAsValue` in terms of `BindToRef` is provided:

```carbon
match_first {
  final impl forall [T:! type, M:! BindToValue(T)]
      M as BindToRefAsValue(T) {
    fn Op[self: Self](p: T*) -> Result {
      return self.Op(*p);
    }
  }
  impl forall [T:! type, M:! BindToRef(T)]
      M as BindToRefAsValue(T) {
    fn Op[self: Self](p: T*) -> Result {
      return *self.Op(p);
    }
  }
}
```

## Details

Sadly, this approach doesn't work by itself. In the example, we believe `i[0]`
is a value expression when type-checking the generic, so we'll use `BindToValue`
there. And in a non-generic context, we'll believe that `i[0]` is a reference
expression, so we'll use `BindToRef`, not `BindToRefAsValue`. So we still get
two different behaviors.

We could solve the problem by additionally making the expression `i[0]` be
"category-dependent": that is, making it have a (template / instantiated)
dependency on `I` that determines its expression category (but not its type,
which is known when checking the generic). We would then need to ensure that
`i[0].(m)` is valid for a reference expression `i[0]` whenever it's valid for a
value expression `i[0]`, and this proposal would help with that by guaranteeing
that a `BindToValue` implementation implies that _at least_ a `BindToRefAsValue`
implementation exists. The result of the member access would again be
category-dependent.

More generally, we'd either need to require that `X(i[0])` is valid for a
durable reference expression `i[0]` whenever it's valid for a value expression
`i[0]`, or add separate and more restrictive rules for expressions with
dependent categories, for all operations `X`. However, for all other situations
beside member access, it appears to already be the case that if `X` accepts a
value expression, then it accepts a durable reference expression and performs a
value binding.

## Rationale

TODO: How does this proposal effectively advance Carbon's goals? Rather than
re-stating the full motivation, this should connect that motivation back to
Carbon's stated goals and principles. This may evolve during review. Use links
to appropriate sections of [`/docs/project/goals.md`](/docs/project/goals.md),
and/or to documents in [`/docs/project/principles`](/docs/project/principles).
For example:

-   [Community and culture](/docs/project/goals.md#community-and-culture)
-   [Language tools and ecosystem](/docs/project/goals.md#language-tools-and-ecosystem)
-   [Performance-critical software](/docs/project/goals.md#performance-critical-software)
-   [Software and language evolution](/docs/project/goals.md#software-and-language-evolution)
-   [Code that is easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write)
-   [Practical safety and testing mechanisms](/docs/project/goals.md#practical-safety-and-testing-mechanisms)
-   [Fast and scalable development](/docs/project/goals.md#fast-and-scalable-development)
-   [Modern OS platforms, hardware architectures, and environments](/docs/project/goals.md#modern-os-platforms-hardware-architectures-and-environments)
-   [Interoperability with and migration from existing C++ code](/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code)

## Alternatives considered

TODO: What alternative solutions have you considered?
