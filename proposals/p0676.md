# `:!` generic syntax

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/676)

<!-- toc -->

## Table of contents

-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Rationale based on Carbon's goals](#rationale-based-on-carbons-goals)
-   [Alternatives considered](#alternatives-considered)
    -   [Default based on context](#default-based-on-context)
        -   [Square brackets](#square-brackets)
        -   [Angle brackets](#angle-brackets)
    -   [`Template` as a type-of-type](#template-as-a-type-of-type)
    -   [Other spellings that were considered](#other-spellings-that-were-considered)

<!-- tocstop -->

## Problem

Carbon design docs provisionally used `:$` to mark generic parameters. Since
then, [issue #565](https://github.com/carbon-language/carbon-lang/issues/565)
decided to use `:!` more permanently. This proposal is to implement that
decision.

## Background

Most popular languages put generic parameters inside angle brackets (`<`...`>`),
as can be seen on rosettacode.org:
[1](http://rosettacode.org/wiki/Generic_swap),
[2](http://rosettacode.org/wiki/Constrained_genericity).

## Proposal

Generic parameters will be marked using `:!` instead of `:` in the parameter
list. They are listed with the regular parameters if they are to be specified
explicitly by callers.

```
fn Zero(T:! ConvertFrom(Int)) -> T;

var zf: Float32 = Zero(Float32);
```

If they are instead deduced from the (types of) the regular parameters, they are
listed in square brackets (`[`...`]`) before the parameter list in round parens
(`(`...`)`).

```
fn Swap[T:! Movable](a: T*, b: T*);

var i: Int = 1;
var j: Int = 2;
Swap(&i, &j);
```

Template parameters use both a `template` keyword before the parameter and `:!`
in place of `:`.

```
fn FieldNames(template T:! Type) -> String;

Assert(FieldNames(struct {.x: Int, .y: Int}) == "x, y");
```

## Rationale based on Carbon's goals

We are attempting to choose a syntax that advances Carbon's goal of having
[code that is easy to read, understand, and write](https://github.com/carbon-language/carbon-lang/blob/trunk/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write).
This option was chosen since it has the advantage of being very simple and not
relying on any context, in according with the
[#646: low-context-sensitivity principle](https://github.com/carbon-language/carbon-lang/pull/646).

For ease of parsing, we've been trying to avoid using angle brackets (`<`...`>`)
outside of declarations. This is primarily a concern for parameterized types
that can appear in expressions alongside comparison operators (`<` and `>`).

The choice to mark template parameters with a keyword was to make it very
visible when that powerful and dangerous feature was being used. We also liked
the similarities to how a `template` keyword also introduces a C++ template
declaration.

The choice to use the specific symbols `:!` over `:$` or other possibilities was
just a matter of taste.

## Alternatives considered

There were a few other options considered to designate generics in
[issue #565](https://github.com/carbon-language/carbon-lang/issues/565).

Note that we at first considered the possibility that type parameters might
accidentally be declared as dynamic if that was the default. We eventually
decided that we could forbid dynamic type parameters for now, and revisit this
problem if and when we decided to add a dynamic type parameter feature.

### Default based on context

In a given syntactic context, one option is going to be more common than others:

-   Regular explicit parameters would most commonly be dynamic.
-   Deduced parameters would most commonly be generic.
-   Parameters to interfaces and types would most commonly be generic.

We considered making `x: T` be generic or dynamic based on this context. In
cases where this default was not what was intended, there would be a keyword
(`dynamic`, `generic`, or `template`) to explicitly pick.

There were a few variations about whether to treat parameters used as types
differently.

The main benefits of this approach were:

-   It handled dynamic type parameters being allowed but uncommon more
    gracefully.
-   Users could use `:` and it would generally do the right thing.
-   Keywords are generally easier to find in search engines, and more
    self-explanatory.
-   Template parameters in particular were highlighted, a property shared with
    the approach recommended by this proposal.

The main objections to this approach was that it was context-sensitive and there
was a lack of syntactic consistency in the context. That is, the were two kinds
of context, generic and dynamic, and two kinds of brackets, square and parens,
but sometimes the parens would be generic and sometimes not.

#### Square brackets

FIXME: a few variations

Never really broke out of the idea that `[`...`]` were for deduced parameters,
and so didn't really consider `Vector[Int]`.

#### Angle brackets

FIXME: a few variations

### `Template` as a type-of-type

FIXME

### Other spellings that were considered

```
fn CastAVector<T: Type>(v: Vector(T), <DestT: Type>) -> Vector(DestT);
class Vector(<T: Type>) { ... }
```

-   was considered
-   not trivial to parse, but doable
-   too much punctuation
-   nice that `<`...`>` is associated with generics, but with enough differences
    to be concerning

```
fn CastAVector[T: Type](v: Vector(T), [DestT: Type]) -> Vector(DestT);
class Vector([T: Type]) { ... }
```

-   no reason to prefer this over previous option, since `<`...`>` more
    associated with generics than `[`...`]`

Brainstormed a bunch of different spellings of the `:!` position

-   `<id>: Type`
-   `id:# Type`
-   `id:<> Type`
-   `id: <Type>`
-   `generic id: Type`
