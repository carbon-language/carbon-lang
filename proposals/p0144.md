# Numeric literal semantics

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/144)

## Table of contents

<!-- toc -->

## Table of contents

-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Details](#details)
    -   [Prelude support](#prelude-support)
    -   [Implicit conversions](#implicit-conversions)
    -   [Examples](#examples)
-   [Alternatives considered](#alternatives-considered)

<!-- tocstop -->

## Problem

When a numeric literal appears in a program, we need to understand its
semantics:

-   What type does it have?
-   What value is produced by operations on it?
-   When can it validly be used to initialize an object?

## Background

In C++, numeric literals have either an integral type or a floating-point type.
C++ provides permission for implementations to add extended integral types, but
in practice (for bad reasons relating to `intmax_t`) implementations do not do
so, so there are a small finite set of types that any given numeric literal
might have:

-   `int`, `long`, `long long`, or `unsigned` versions of these
-   `float`, `double`, or `long double`

The choice of type is determined solely by the literal.

The C++ approach is error-prone and problematic:

-   Lossy conversions from literals in initializers are permitted.
-   Lossy operations on literals are permitted; for example, on a typical
    implementation, `1 << 60` has value `0` because `1` is a 32-bit type.
-   Attempting to naturally express some values has undefined behavior; for
    example, `int x = -2147483648;` typically results in undefined behavior even
    when -2147483648 is a valid `int` value.
-   Integer literals with value 0 have special semantics that are lost when the
    integer is passed to a function: "perfect" forwarding doesn't work for such
    literals.
-   The built-in types are privileged: only the types listed above have
    literals. There is no syntax for a 64-bit integer literal, only for (for
    example) a `long int` literal, which may or may not 64 bits wide.
-   The type of a literal can be unpredictable in portable code, as it can
    depend on which type a particular value happens to fit into.

## Proposal

Numeric literals have a type derived from their value, and can be converted to
any type that can represent that value.

Simple operations such as arithmetic that involve only literals also produce
values of literal types.

## Details

Numeric literals have a type derived from their value. Two integer literals have
the same type if and only if they represent the same integer. Two real number
literals have the same type if and only if they represent the same real number.

That is:

-   For every integer, there is a type representing literals with that integer
    value.
-   For every dyadic or decadic rational number, there is a type representing
    literals with that real value. Dyadic and decadic rational numbers are those
    real numbers that can be written as a finite digit sequence in base 2 or 10,
    respectively.
-   The types for real numbers are distinct from the types for integers, even
    for real numbers that represent integers. `var Int: x = 1.0;` is invalid.

Primitive operators are available between numeric literals, and produce values
with numeric literal types. For example, the type of `1 + 2` is the same as the
type of `3`.

Numeric types can provide conversions to support initialization from numeric
literals. Because the value of the literal is carried in the type, a type-level
decision can be made as to whether the conversion is valid.

The integer types defined in the standard library permit conversion from integer
literal types whose values are representable in the integer type. The
floating-point types defined in the Carbon library permit conversion from
integer and rational literal types whose values are between the minimum and
maximum finite value representable in the floating-point type.

### Prelude support

The following types are defined in the Carbon prelude:

-   An arbitrary-precision integer type.

    ```
    class BigInt;
    ```

-   A rational type, parameterized by its numerator and denominator types.

    ```
    class Rational(T:! Type);
    ```

    The exact constraints on `T` are not yet decided.

-   A type representing integer literals.

    ```
    class IntLiteral(N:! BigInt);
    ```

-   A type representing floating-point literals.

    ```
    class FloatLiteral(N:! Rational(BigInt));
    ```

All of these types are usable during compilation. `BigInt` supports the same
operations as `Int(n)`. `Rational(T)` supports the same operations as
`Float(n)`.

The types `IntLiteral(n)` and `FloatLiteral(n)` also support primitive integer
and floating-point operations such as arithmetic and comparison, but these
operations are typically heterogeneous: for example, an addition between
`IntLiteral(n)` and `IntLiteral(m)` produces a value of type
`IntLiteral(n + m)`.

### Implicit conversions

`IntLiteral(n)` converts to any sufficiently large integer type, as if by:

```
impl [template N:! BigInt, template M:! u32]
    IntLiteral(N) as ImplicitAs(Int(M))
    if N >= M.MinValue as BigInt and N <= M.MaxValue as BigInt {
  ...
}
impl [template N:! BigInt, template M:! u32]
    IntLiteral(N) as ImplicitAs(Unsigned(M))
    if N >= M.MinValue as BigInt and N <= M.MaxValue as BigInt {
  ...
}
```

The above is for exposition purposes only; various parts of this syntax are not
yet decided.

Similarly, `FloatLiteral(n)` converts to any sufficiently large integer or
floating-point type, except that conversions in which `n` lies exactly half-way
between two values are rejected, as
[previously decided](https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/lexical_conventions/numeric_literals.md#ties).

Similar approaches can be used to write functions that accept literals in a
given range:

```
fn PassMeZero(_: IntLiteral(0));

fn ConvertToInt8[template N:! BigInt](_: IntLiteral(N)) -> i8
    if N >= -128 and N <= 127 {
  return N as i8;
}
```

### Examples

```carbon
// This is OK: the initializer is of the integer literal type with value
// -2147483648 despite being written as a unary `-` applied to a literal.
var Int: x = -2147483648;

// This initializes y to 2^60.
var Int64: y = 1 << 60;

// This forms a rational literal whose value is one third, and converts it to
// the nearest representable value of type `Float64`.
var Float64: z = 1.0 / 3.0;

// This is an error: 300 cannot be represented in type `Int8`.
var Int8: c = 300;

fn f[Type:$$ T](T: v) {
  var Int: x = v * 2;
}

// OK: x = 2'000'000'000.
f(1'000'000'000);

// error: 4'000'000'000 can't be represented in type `Int`.
f(2'000'000'000);

// No storage required for the bound when it's of integer literal type.
struct Span(Type:$$ T, Type:$$ BoundT) {
  var Ptr(T): begin;
  var BoundT: bound;
}
```

## Alternatives considered

We could decide on a type based on the form of the literal.

Advantages:

-   This follows what C++ does.

Disadvantages:

-   Surprising results when the result of applying an operator to a literal
    would result in overflow.
-   Whatever types we pick are privileged.

We could give literals a single, arbitrary-precision type (say, `Integer` and
`Rational`) that is usable only at compile time.

Advantages:

-   Only introduces two new types, not an unbounded parameterized family of
    types.

Disadvantages:

-   If we introduce an arbitrary-precision integer type, it would be
    inconsistent to support it only during compilation.
-   Such a type would be expensive, and programs may use it accidentally. For
    example, `var auto: x = 123;` would result in `x` having an
    infinite-precision type, possibly involving invisible dynamic allocation.
    Under this proposal, the type of `x` is a type that can only represent the
    value `123`; as such, `x` is effectively immutable. The arbitrary-precision
    integer type introduced in this proposal can only be used explicitly by
    programs naming it.
-   Our mechanism for specifying the behavior of operations such as arithmetic
    is based on interface implementations, which are looked up by type.
    Supporting `impl` selection based on values would introduce substantial
    complexity.

We could treat a leading `-` as part of a literal.

Advantages:

-   This would narrowly solve the problem that `INT_MIN` cannot be written
    directly, without any of the other implications of this proposal.

Disadvantages:

-   Makes the behavior of unary `-` less uniform.
-   Prevents the introduction of infix or postfix operators that bind more
    tightly than unary `-`, such as an infix exponentiation operator: `-2**2`
    may be expected to evaluate to -4, not to +4.

We could reject constant expressions that overflow.

Advantages:

-   This would diagnose most of the problematic cases, rather than allowing them
    to result in runtime failures.

Disadvantages:

-   This would not make naturally-expressed constants actually work.
