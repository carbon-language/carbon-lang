# Constraints must use `Self`

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/2376)

<!-- toc -->

## Table of contents

-   [Abstract](#abstract)
-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Details](#details)
-   [Rationale](#rationale)
-   [Alternatives considered](#alternatives-considered)

<!-- tocstop -->

## Abstract

Require `impl as` constraints in an `interface` or `constraint` definition to
mention `Self` implicitly or explicitly. Require `where` clauses to refer to
`.Self` directly, or through a designator like `.Foo`.

## Problem

When trying to implement constraints in Carbon Explorer, we
[came up with an example](https://discord.com/channels/655572317891461132/941071822756143115/986054308179103765)
that raised questions:

```carbon
interface A {}
interface B {}
external impl forall [T:! Type] T as A where T is B {}
```

There were multiple possible interpretations for what the meaning of that
`where` clause was. We thought users would expect it to mean:

```carbon
external impl forall [T:! Type where .Self is B] T as A {}
```

Other cases suggested that constraints that were modifying other types were in
general surprising,
[for example](https://discord.com/channels/655572317891461132/941071822756143115/986061766226214932):

```carbon
fn F[A:! Type, B:! Type, C:! Type where A == B](a: A, b: B, c: C);
```

Ultimately, we ended up with a number of reasons to say a `where` clause should
be a constraint on the type being modified. We found similar restrictions are
valuable for `impl as` constraints in an `interface` or `constraint` definition.

FIXME

-   Prefer only [one way](/docs/project/principles/one_way.md) to write
    constraints.
-   Confusing semantics (example from 06-13)
-   Like the constraints on a type to be complete when the types declaration is
    complete.
-   Allow incomplete constraints
-   Know where to find relevant constraints

This is related to the question: When do we require a constraint to be complete?
See proposal [#2347](https://github.com/carbon-language/carbon-lang/pull/2347).
The logic goes like this:

-   we want to limit when information from a constraint is found
-   to increase the cases where we don't need to look in a constraint,
-   so constraints are allowed to be incomplete in those cases.

## Background

TODO: Is there any background that readers should consider to fully understand
this problem and your approach to solving it?

## Proposal

`where` clauses must use a designator, either `.Self` or `.Foo` for some member
`Foo`. The designator may be used directly, or supplied as an argument to a
type, interface, or named constraint used in the `where` clause, as in these
examples:

-   `Container where .ElementType = i32`
-   `Type where Vector(.Self) is Sortable`
-   `Addable where i32 is AddableWith(.Result)`

`impl as` declarations in interfaces and named constraints must always involve
`Self`:

-   Can be the implicit `Self` when no type is specified, as in `impl as ...`,
    or the equivalent declarations with `Self` declared explicitly, as in
    `impl Self as ...`
-   Can be an argument a type. The type can be what is to the left of the `as`,
    as in `impl Vector(Self) as ...`, or a type argument to the interface or
    constraint, as in `impl Vector(i32) as AddWith(Vector(Self))`.
-   Can be a parameter to the interface or constraint to the right of the `as`,
    as in `impl T as Bar(Self)`.

When the compiler looks to see if any constraints imply that an impl exists, the
only place it needs to look are the places that involve the type the impl is for
(`Self`). This means the compiler never needs to look in forward-declared (or
otherwise incomplete) constraints that don't involve that type. This applies
recursively. This allows incomplete interfaces and named constraints as
described in proposal
[#2347](https://github.com/carbon-language/carbon-lang/pull/2347).

This solves a problem: when doing impl lookup, what is the set of imlps that you
can look up? There may be an infinite set of constraints reachable through
interfaces, but with this rule, you only need to consider a finite subset.

## Details

TODO: Fully explain the details of the proposed solution.

## Rationale

TODO: How does this proposal effectively advance Carbon's goals? Rather than
re-stating the full motivation, this should connect that motivation back to
Carbon's stated goals and principles. This may evolve during review. Use links
to appropriate sections of [`/docs/project/goals.md`](/docs/project/goals.md),
and/or to documents in [`/docs/project/principles`](/docs/project/principles).
For example:

-   [Community and culture](/docs/project/goals.md#community-and-culture)
-   [Language tools and ecosystem](/docs/project/goals.md#language-tools-and-ecosystem)
-   [Performance-critical software](/docs/project/goals.md#performance-critical-software)
-   [Software and language evolution](/docs/project/goals.md#software-and-language-evolution)
-   [Code that is easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write)
-   [Practical safety and testing mechanisms](/docs/project/goals.md#practical-safety-and-testing-mechanisms)
-   [Fast and scalable development](/docs/project/goals.md#fast-and-scalable-development)
-   [Modern OS platforms, hardware architectures, and environments](/docs/project/goals.md#modern-os-platforms-hardware-architectures-and-environments)
-   [Interoperability with and migration from existing C++ code](/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code)

## Alternatives considered

TODO: What alternative solutions have you considered?

[#generics-and-templates on 2022-06-13](https://discord.com/channels/655572317891461132/941071822756143115/986061509815844864)

[Open discussion on 2022-10-12](https://docs.google.com/document/d/1tEt4iM6vfcY0O0DG0uOEMIbaXcZXlNREc2ChNiEtn_w/edit#heading=h.q7afaawbc5k)

[#generics-and-templates 2022-10-24](https://discord.com/channels/655572317891461132/941071822756143115/1034198851059466292)

[2022-10-24 open discussion](https://docs.google.com/document/d/1tEt4iM6vfcY0O0DG0uOEMIbaXcZXlNREc2ChNiEtn_w/edit#heading=h.hb5qukkw7d3l)
