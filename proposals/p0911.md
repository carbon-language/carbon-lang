# Conditional expressions

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/911)

<!-- toc -->

## Table of contents

-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Details](#details)
    -   [Chaining](#chaining)
    -   [Precedence and ambiguity](#precedence-and-ambiguity)
-   [Rationale based on Carbon's goals](#rationale-based-on-carbons-goals)
-   [Alternatives considered](#alternatives-considered)
    -   [No conditional expression](#no-conditional-expression)
    -   [Use C syntax](#use-c-syntax)
    -   [No `then`](#no-then)
    -   [Require parentheses](#require-parentheses)
    -   [Implicit conversions in both directions](#implicit-conversions-in-both-directions)

<!-- tocstop -->

## Problem

Programs need to be able to select between multiple different paths of execution
and multiple different values. In a rich expression language, developers expect
to be able to do this within a subexpression of some overall expression.

## Background

C-family languages provide a `cond ? value1 : value2` operator.

-   This operator has confusing syntax, because both `cond` and `value2` are
    undelimited, and it's often unclear to developers how much of the adjacent
    expressions are part of the conditional expression. For example:
    ```
    int n = has_thing1 && cond ? has_thing2 : has_thing3 && has_thing4;
    ```
    is parsed as
    ```
    int n = (has_thing1 && cond) ? has_thing2 : (has_thing3 && has_thing4);
    ```
    Also, `value1` and `value2` are parsed with different rules:
    ```
    cond ? f(), g() : h(), i();
    ```
    is parsed as
    ```
    (cond ? f(), g() : h()), i();
    ```
-   In C++, this operator has confusing semantics, due to having a complicated
    set of rules governing how the target type is determined.
-   Despite the complications of the rules, the result type of `?:` is not
    customizable. Instead, C++ invented a `std::common_type` trait that models
    what the result of `?:` should have been.

Rust allows most statements to be used as expressions, with `if` statements
being an important case of this: `Use(if cond { v1 } else { v2 })`.

-   This has a number of behaviors that would be surprising to developers coming
    from C++ and C, such as a final `;` in a `{...}` making a semantic
    difference.
-   The expression semantics leak into the statement semantics. For example,
    Rust rejects:

    ```
    fn f() {}
    fn g() -> i32 {}

    fn main() {
      if true { f() } else { g() };
      return;
    }
    ```

    ... because the two arms of the `if` don't have the same type.

-   We have already
    [decided](https://github.com/carbon-language/carbon-lang/issues/430) that we
    do not want Carbon to treat statements such as `if` as being expressions
    without some kind of syntactic distinction.

## Proposal

Provide a conditional expression with the syntax:

> ```
> if cond then value1 else value2
> ```

`then` is a new keyword introduced for this purpose.

## Details

### Chaining

This syntax can be chained like `if` statements:

```
Print(if guess < value
      then "Too low!"
      else if guess > value
      then "Too high!"
      else "Correct!")
```

Unlike with `if` statements, this doesn't require a special rule.

### Precedence and ambiguity

An `if` expression can be used anywhere a parenthesized expression can appear.
`value2` extends as far to the right as possible, even when an `if` expression
is used in a high-precedence context:

```
var v: i32 = 1 * if cond then 2 else 3 + 4;
```

is the same as

```
var v: i32 = 1 * if cond then 2 else (3 + 4);
```

not

```
var v: i32 = 1 * (if cond then 2 else 3) + 4;
```

The intent is that an `if` expression is used to produce a value, not only for
its side-effects. If only the side-effects are desired, an `if` statement should
be used instead. Because `value2` extends as far to the right as possible, if an
`if` expression appeared at the start of a statement, its value could never be
used:

```
if cond then value1 else value2;
```

For this reason and to avoid the need for lookahead or disambiguation, an `if`
keyword appearing at the start of a statement is always interpreted as beginning
an `if` statement and never as beginning an `if` expression.

## Rationale based on Carbon's goals

-   [Language tools and ecosystem](/docs/project/goals.md#language-tools-and-ecosystem)
    -   The `if ... then ... else` syntax should be easier to format
        automatically in an unsurprising way than a `?:` syntax because it is
        clear that the `then` and `else` keywords should be wrapped to the start
        of a new line when wrapping the overall conditional expression.
-   [Code that is easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write)
    -   Including such an expression is expected to improve ergonomics.
    -   An explicit delimiter for the start of the condition expression makes it
        easier to read, correctly write, and understand the precedence of
        conditional expressions.
    -   Making the `value2` portion as long as possible gives a simple rule that
        it seems feasible for every Carbon developer to remember. This rule is
        expected to be unsurprising both due to using the same rule for `value1`
        and `value2`, and due to the non-trivial distance between the `else`
        portion of the `if` expression and any operator to the left of the `if`.
    -   The use of an explicit `if` keyword for flow control makes the
        distinction between flow control and linear computation clearer.
    -   The readability of a multi-line `if` expression is improved by having a
        `then` and `else` keyword of the same length
-   [Interoperability with and migration from existing C++ code](/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code)
    -   Migration is improved by providing an operator set that largely matches
        the C++ operator set.

## Alternatives considered

### No conditional expression

We could provide no conditional expression, and instead ask people to use a
different mechanism to achieve this functionality. Some options include:

-   Use of an `if` statement:
    ```
    var v: Result;
    if (cond) {
      v = value1;
    } else {
      v = value2;
    }
    Use(v);
    ```
-   A function call syntax:
    ```
    Use(cond.Select(value1, value2));
    ```
    or, with short-circuiting and lambdas:
    ```
    Use(cond.LazySelect($(value1), $(value2)));
    ```
-   An `if` statement in a lambda:
    ```
    Use(${ if (cond) { return value1; } else { return value2; } });
    ```

The above assumes a placeholder `$(...)` syntax for a single-expression lambda,
and a `${...}` syntax for a lambda with statements as its body.

Advantages:

-   No new dedicated syntax.

Disadvantages:

-   Conditional expressions are commonly used, commonly desired, and Carbon
    developers -- especially those coming from C++ and C -- will be disappointed
    by their absence.
-   Readability and ergonomics will be harmed by making this common operation
    more verbose, even if an idiom is established.

### Use C syntax

We could use the C `cond ? value1 : value2` syntax.

Advantages:

-   Familiar to developers coming from C++ and C.

Disadvantages:

-   These operators have serious precedence problems in C++ and C. We could
    address those by making more cases ambiguous, at the cost of harming
    familiarity and requiring parentheses in more cases.
-   The `:` token is already in use in name binding; using it as part of a
    conditional expression would be confusing.
-   The `?` token is likely to be desirable for use in optional unwrapping and
    error handling.

### No `then`

We could use

> ```
> if (cond) value1 else value2
> ```

instead of

> ```
> if cond then value1 else value2
> ```

Note that we cannot avoid parentheses in this formulation without risking
syntactic ambiguities.

Advantages:

-   Looks more like an `if` statement, albeit one with unbraced operands.
-   Slightly shorter.
-   Better line-wrapping for chained `if` expressions:
    ```
    Print(if (guess < value)
            "Too low!"
          else if (guess > value)
            "Too high!"
          else
            "Correct!")
    ```
    may be more readable than
    ```
    Print(if guess < value
          then "Too low!"
          else if guess > value
          then "Too high!"
          else "Correct!")
    ```
    or
    ```
    Print(if guess < value
            then "Too low!"
            else if guess > value
              then "Too high!"
              else "Correct!")
    ```

Disadvantages:

-   Potentially worse line wrapping. The `else` would presumably be wrapped onto
    a line by itself, wasting vertical space, whereas `then` and `else` when
    paired can both comfortably precede their values on the same line; consider
    ```
    F(if (cond)
        value1
      else
        value2)
    ```
    occupies more space than
    ```
    F(if cond
      then value1
      else value2)
    ```
-   May create confusion between `if` statements and `if` expressions by
    resembling an `if` statement but not matching the semantics.
-   May cause evolutionary problems due to syntactic conflict if we ever make
    the braces or parentheses in `if` statements optional.
-   Requires parentheses, and hence additional presses of "Shift" on US
    keyboards, making it slightly harder to type.

### Require parentheses

We could use:

> ```
> if (cond) then value1 else value2
> ```

However, it's not clear that there is value in requiring both parentheses and a
new keyword. It also seems jarring that this so closely resembles an `if`
statement but adds a `then` keyword that the `if` statement lacks.

### Implicit conversions in both directions

Suppose we have two types where implicit conversions in both directions are
possible:

```
class A {}
class B {}
impl A as ImplicitAs(B) { ... }
impl B as ImplicitAs(A) { ... }
```

By default, an expression `if cond then {} as A else {} as B` would be
ambiguous. If the author of `A` or `B` wishes to change this behavior:

-   If the common type should be `A`, then `impl A as CommonTypeWith(B)` must be
    provided specifying the common type is `A`.
-   If the common type should be `B`, then `impl B as CommonTypeWith(A)` must be
    provided specifying the common type is `B`.
-   If the common type should be something else, then both `impl`s need to be
    provided:
    ```
    impl A as CommonTypeWith(B) { let Result:! Type = C; }
    impl B as CommonTypeWith(A) { let Result:! Type = C; }
    ```

We could change the rules so instead, in any of the above cases, implementing
either `A as CommonTypeWith(B)` or `B as CommonTypeWith(A)` would suffice.

Advantages:

-   Simplifies the user experience in this case.

Disadvantages:

-   Introduces non-uniformity: the blanket `impl` of `CommonTypeWith` in terms
    of `ImplicitAs` would get this special treatment, but other blanket `impl`s
    would not.
-   Introduces complexity, which might not be fully hidden from users. At
    minimum, we would need to explain that `ImplicitAs` is treated specially
    here.
-   The case in which two `impl`s are required is a corner case. It's somewhat
    uncommon for implicit conversions to be possible in both directions between
    two types. In those cases, it's more uncommon for there to be a clear best
    "common type". And even then, most of the time the common type will be one
    of the two types being unified.

From a more abstract perspective: the process of finding a common type involves
asking each type to implicitly convert to the destination type that it thinks is
best, and then failing if both sides didn't convert to the same type. If `A`
implicitly converts to `B` and the other way around, then both sides of this
process should be overridden in order to get both types to implicitly convert to
`C` instead.
