# Associated constant assignment versus equality

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/2173)

<!-- toc -->

## Table of contents

-   [Abstract](#abstract)
-   [Problem](#problem)
    -   [Equal types with different interfaces](#equal-types-with-different-interfaces)
    -   [Type canonicalization](#type-canonicalization)
    -   [Transitivity of equality](#transitivity-of-equality)
    -   [Coherence](#coherence)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Details](#details)
    -   [Rewrite constraints](#rewrite-constraints)
    -   [Combining constraints with `&`](#combining-constraints-with-)
    -   [Same type constraints](#same-type-constraints)
    -   [Observe declarations](#observe-declarations)
    -   [Implementing an interface](#implementing-an-interface)
    -   [Ergonomics](#ergonomics)
-   [Rationale](#rationale)
-   [Alternatives considered](#alternatives-considered)
    -   [Status quo](#status-quo)
    -   [Restrict constraints to allow computable type equality](#restrict-constraints-to-allow-computable-type-equality)
    -   [Find a fully transitive approach to type equality](#find-a-fully-transitive-approach-to-type-equality)
    -   [Use a different rule for "same rewrite"](#use-a-different-rule-for-same-rewrite)
    -   [Different names for same-type constraint](#different-names-for-same-type-constraint)

<!-- tocstop -->

## Abstract

Split the `where A == B` constraint in two: `where .A = B` produces a new
constraint from an old one, where the value of `.A` in the new constraint is
known and eagerly rewritten to `B`, and `where A == B`, which does not cause `A`
and `B` to be considered as identical by language rules but does permit implicit
(no-op) conversion between them.

This aims to provide an efficiently-computable and human-understandable type
equality rule, with type canonicalization and therefore transitive type
equality, without sacrificing too much in the way of ergonomics and without
sacrificing determinism, while still providing the full power of a general type
constraint system in a less ergonomic form.

## Problem

### Equal types with different interfaces

When an associated type is constrained to be a concrete type, it is desirable
for the associated type to behave like that concrete type:

```
interface Hashable {
  fn Hash[me: Self]() -> u128;
}
interface X {
  let R:! Hashable;
  fn Make() -> R;
}
fn F[T:! X where .R == i32]() -> i32 {
  return F.Make() + 1;
}
```

Here, we want to be able to use the result of `F.Make()` in all regards like an
`i32`. Assuming an `i32.Abs` function exists, and `i32` implements `Hashable`
externally, it is more desirable for `F.Make().Abs()` to work than it is for
`F.Make().Hash()` to work.

We are
[currently aiming to address this](https://github.com/carbon-language/carbon-lang/pull/2070)
by saying that when two type expressions are constrained to be equal, a value
whose type is either of those type expressions provides the (disjoint) union of
their interfaces. This leads to a surprise:

```
fn G[T:! X where .R == i32]() -> u128 {
  let n: i32 = 1;
  let m: i64 = 2;
  return n.Hash() ^ m.Hash();
}
```

Here, the call to `n.Hash()` is valid but the call to `m.Hash()` is invalid,
because the type `i32` of `n` is constrained to be equal to `T.R` which is of
type `Hashable`, but the type `i64` is not constrained in that way and does not
implement `Hashable` internally.

This suggests that there might be two different behaviors that we want when
adding a constraint: either we are changing the interface, or not. This is
analogous to internal versus external implementation of an interface.

### Type canonicalization

There are a variety of contexts in which types are compared for equality. In
some of those contexts, it might be acceptable to perform a search and a
computation, and it might be acceptable to have false negatives. For example,
when analyzing an argument being passed to a function in a generic, it might be
OK to say "we can't prove that the argument has a type that is equal to (or
convertible to) the type of the parameter", so long as the developer has some
way to demonstrate that the types are the same if that is indeed the case.

However, not all comparisons of generic types have that property. As an extreme
and hopefully avoidable example, suppose a C++-like linkage model is used, with
name mangling. We may need to determine whether two type expressions are equal
at link time, by reducing them both to strings that are guaranteed to be
identical if the types are equal and non-identical otherwise. This requires some
form of type canonicalization: reducing all equal type expressions to some
common representation where we can faithfully perform equality comparisons.

Even if the semantics of Carbon don't require canonicalization, it is still a
very useful property for implementation purposes. For example, if type
canonicalization is possible to perform efficiently, building a data structure
mapping from a type to some value becomes much simpler, and if the
representation of a type expression carries its canonical form then type
equality comparisons can be done in constant time.

### Transitivity of equality

For ergonomic purposes, it is valuable for the notion of type expression
equality to be transitive: if type A is known to be the same as type B, and type
B is known to be the same as type C, then shouldn't we be able to use an A where
a C is required? See
[#1369](https://github.com/carbon-language/carbon-lang/issues/1369) for an
explanation of why this is important.

However, if we permit arbitrary constraints and have a transitive equality rule,
then type equality is isomorphic to the
[word problem for finitely-presented monoids](https://en.wikipedia.org/wiki/Word_problem_for_groups),
which is undecidable, and certainly not computable, in general.

Therefore we must impose a restriction somewhere: either not all constraints are
permissible, or we do not have transitivity, or we impose some other constraint
on the language to avoid the hard cases. Some languages merely impose some kind
of depth limit on their search for a proof of equality.

Note that if we can perform type canonicalization, then type equality is
necessarily transitive: if all equal _pairs_ of types canonicalize to the same
representation, then _all_ equal types canonicalize to the same representation
transitively.

### Coherence

In order to avoid surprises in the language behavior, we want Carbon to have the
property that learning more about the type of a value should not cause the
behavior of an expression to change from one valid behavior to another valid
behavior.

It's important to distinguish here between learning more about a type, such as
learning that it implements a particular interface – for example, from an added
import – and changing the type, such as by writing a different expression after
a `:` or `:!`. Changing the type of a value is expected to be able to change the
behavior of an expression using that value.

## Background

There has been a lot of work in this space. Some previous relevant proposals:

-   [#731: generics details 2](https://github.com/carbon-language/carbon-lang/pull/731)
    introduced associated types, with the intent that a mechanism to constrain
    their value would be provided in a later proposal.
-   [#818: generics details 3](https://github.com/carbon-language/carbon-lang/pull/818)
    introduced `where` constraints for generics, with an open question for
    whether and how we might restrict constraints in order to give a decidable
    type equality rule.
    -   #818 represents the status quo of approved proposals. It has both `=`
        and `==` where constraints, which are similar to, but somewhat different
        from, those in this proposal.
    -   `=` constraints require a concrete type on their right-hand side. The
        left-hand side is not restricted. The type-of-type of the left-hand side
        is changed to match the right-hand side.
    -   `==` constraints do not affect the type-of-type of either operand.
    -   As an answer to the question of how to produce a decidable type equality
        rule, both kinds of constraints are applied automatically, but only at a
        depth of one constraint. Neither form is transitive but both can be
        transitively extended using `observe` declarations.
-   [#2070: always `==` not `=` in `where` clauses](https://github.com/carbon-language/carbon-lang/pull/2070)
    describes an attempt to unify the syntax and semantics of `=` and `==`
    constraints, under which we would always merge the type-of-types of the
    operands. That proposal has not yet been accepted, and this proposal intends
    to supersede it.

## Proposal

Replace the existing `where A == B` constraint with two different kinds of
constraint:

-   `where .A = T` specifies a _rewrite_ constraint. If the associated constant
    `.A` is named as a member of a type with this constraint, it is rewritten to
    `T`. This means that the interface of the type changes, and the behavior is
    in all respects as if `T` had been specified directly.
-   `where X == Y` specifies a _same-type_ constraint. This is treated much like
    `where X is SameAs(Y)`. Here, `SameAs` is a hypothetical constraint that is
    reflexive (`T is SameAs(T)` for all `T`), commutative (`T is SameAs(U)` if
    and only if `U is SameAs(T)`), and not implementable by the developer.
    Moreover, if `F` is any pure type function, `T is SameAs(U)` implies
    `F(T) is SameAs(F(U)`). `observe` statements can be used to form transitive
    `SameAs` relations. Same-type constraints are not used automatically by the
    language rules for any purpose, but there is an `ImplicitAs(T)` impl for
    types implementing `SameAs(T)`.

A type implements `C where .A = T` if and only if it implements
`C where .A == T`, assuming both constraints are valid – the inhabitants of
these two type-of-types are the same, but they are different type-of-types and
provide different interfaces for corresponding type values.

## Details

### Rewrite constraints

In a rewrite constraint, the left-hand operand of `=` must be a `.` followed by
the name of an associated constant. `.Self` is not permitted.

```
interface RewriteSelf {
  // ❌ Error: `.Self` is not the name of an associated constant.
  let Me:! Type where .Self = Self;
}
interface HasAssoc {
  let Assoc:! Type;
}
interface RewriteSingleLevel {
  // ✅ Uses of `A.Assoc` will be rewritten to `i32`.
  let A:! HasAssoc where .Assoc = i32;
}
interface RewriteMultiLevel {
  // ❌ Error: Only one level of associated constant is permitted.
  let B:! RewriteSingleLevel where .A.Assoc = i32;
}
```

This notation is permitted anywhere a constraint can be written, and results in
a new constraint with a different interface: the named member effectively no
longer names an associated constant of the constrained type, and is instead
treated as a rewrite rule the expands to the right-hand side of the constraint,
with any mentioned parameters substituted into that type.

```
interface Container {
  let Element:! Type;
  let Slice:! Container where .Element = Element;
  fn Add[addr me: Self*](x: Element);
}
// `T.Slice.Element` rewritten to `T.Element`
//     because type of `T.Slice` says `.Element = Element`.
// `T.Element` rewritten to `i32`
//     because type of `T` says `.Element = i32`.
fn Add[T:! Container where .Element = i32](p: T*, y: T.Slice.Element) {
  // ✅ Argument `y` has the same type `i32` as parameter `x` of
  // `T.(Container.Add)`, which is also rewritten to `i32`.
  p->Add(y);
}
```

Rewrites aren't performed on the left-hand side of such an `=`, so
`where .A = .B and .A = C` is not rewritten to `where .A = .B and .B = C`.
Instead, such a `where` clause is invalid unless each rule for `.A` specifies
the same rewrite.

When an `=` appears within an interface, it is possible to form a cycle where a
type becomes more complex with each iteration. In order to avoid this problem,
if, when substituting into the right-hand side of such an `=`, the same rewrite
is performed again, the program is invalid.

```
interface Container {
  let Element:! Type;
  let Slice:! Container where .Element = Element;
}
// ❌ Error: `.Slice.Element` rewritten to `.Element` by (1),
// resulting in `where .Element = .Element`.
// `T.Element` is then rewritten to `T.Element`,
// to which the same rewrite applies again.
fn Bad[T:! Container where .Element = .Slice.Element](x: T.Element) {}
```

```
interface Helper {
  let D:! Type;
}
interface Example {
  let B:! Type;
  let C:! Helper where .D = B;
}
// ✅ `where .D = ...` by itself is fine.
// `T.C.D` is rewritten to `T.B`.
fn Allowed(T:! Example, x: T.C.D);
// ❌ But combined with another rewrite, creates an infinite loop.
// `.C.D` is rewritten to `.B`, resulting in `where .B = .B`.
// Then `T.C.D` is rewritten to `T.B`, which is rewritten to itself repeatedly.
// Using `==` instead of `=` would make this constraint redundant,
// rather than it being an error.
fn Error(T:! Example where .B = .C.D, x: T.C.D);
```

To determine whether two rewrite constraints are the same, each such constraint
tracks the location of its `=` token and an optional location of a `:!` binding.
When a constraint is used in a `:!` binding, its rewrite constraints are
replaced with ones that track the location of that `:!` binding. Two rewrite
constraints are the same if they track the same `=` location and the same
optional `:!` location.

> TODO: Alternative rule: if the rewrite constraint would rewrite its own
> right-hand side, then reject. So far we have neither a proof that this is
> sufficient to ensure termination nor a counterexample.

It is valid for the same rewrite rule to be used multiple times within a type
expression, so long as it is not used during substitution into its own
right-hand side:

```
interface Allowed {
  let A:! Allowed where .A = .Self;
}
fn F(T:! Allowed, x: T.A.A.A);
// ✅ Allowed, since rewrite is only applied once per sub-expression
// In `(T.A.A).A`, the inner `T.A.A` is rewritten to `T.A`,
// resulting in `(T.A).A`, which is then rewritten to `T.A`.
```

This rule does disallow some cases which would terminate:

```
interface FalsePositive;
constraint ForwardDeclaredConstraint(X:! FalsePositive);
interface FalsePositive {
  let X:! FalsePositive;
  // Means `Y:! FalsePositive where .X = X.Y`
  let Y:! ForwardDeclaredConstraint(X);
}
constraint ForwardDeclaredConstraint(X:! FalsePositive) {
  extends FalsePositive where .X = X.Y;
}
// T.Y.Y.X -> T.Y.X.Y -> T.X.Y.Y
// ❌ Error: applies the same rewrite twice, even
// though there is no infinite loop.
fn F4(T:! FalsePositive, x: T.Y.Y.X);
```

Rewrite constraints thereby give us a deterministic, terminating type
canonicalization mechanism for associated constants: in `A.B`, if the type of
`A` specifies that `.B == C`, then `A.B` is replaced by `C`. Equality of types
constrained in this way is transitive.

Note that given `T:! C where .R = i32` can result in a type `T.R` whose behavior
is different from the behavior of `T.R` given `T:! C`. For example, member
lookup into `T.R` can find different results and operations can therefore have
different behavior. However, this does not violate coherence because `C` and
`C where .R = i32` don't differ by merely having more type information; rather,
they are different types that have an isomorphic set of values, somewhat like
`i32` and `u32`. An `=` constraint is not merely learning a new fact about a
type, it is requesting different behavior.

### Combining constraints with `&`

Suppose we have `X = C where .R = A` and `Y = C where .R = B`. What should
`C & X` produce? What should `X & Y` produce?

We could perhaps say that `X & Y` results in a constraint where the type of `R`
has the union of the interface of `A` and the interface of `B`, and that `C & X`
similarly results in a constraint where the type of `R` has the union of the
interface of `A` and the interface originally specified by `C`. However, this
proposal suggests a simpler rule:

-   Combining two rewrite rules with different rewrite targets results in a
    constraint where the associated constant is ambiguous. Given `T:! X & Y`,
    the type expression `T.R` is ambiguous between a rewrite to `A` and a
    rewrite to `B`. But given `T:! X & X`, `T.R` is unambiguously rewritten to
    `A`.
-   Combining a constraint with a rewrite rule with a constraint with no rewrite
    rule preserves the rewrite rule. For example, supposing that
    `interface Container` extends `interface Iterable`, and `Iterable` has an
    associated constant `Element`, the constraint
    `Container & (Iterable where .Element = i32)` is the same as the constraint
    `(Container & Iterable) where .Element = i32` which is the same as the
    constraint `Container where .Element = i32`.

### Same type constraints

A same-type constraint describes that two type expressions are known to evaluate
to the same value. Unlike a rewrite constraint, however, the two type
expressions are treated as distinct types when type-checking a generic that
refers to them.

Same-type constraints are brought into scope, looked up, and resolved exactly as
if there were a `SameAs(U:! Type)` interface and a `T == U` impl corresponded to
`T is SameAs(U)`, except that `==` is commutative. As such, it's not possible to
ask for a list of types that are the same as a given type, nor to ask whether
there exists a type that is the same as a given type and has some property. But
it is possible to ask whether two types are (non-transitively) the same.

In order for same-type constraints to be useful, they must allow the two types
to be treated as actually being the same in some context. This can be
accomplished by the use of `==` constraints in an `impl`, such as in the
built-in implementation of `ImplicitAs`:

```
final impl forall [T:! Type, U:! Type where .Self == T] T as ImplicitAs(U) {
  @Carbon.Builtin("implicit_as_same_type")
  fn Convert[me: Self](other: U) -> U;
}
```

It superficially seems like it would be convenient if such implementations were
made available implicitly – for example, by writing
`impl forall [T:! Type] T as ImplicitAs(T)` – but in more complex examples that
turns out to be problematic. Consider:

```
interface CommonTypeWith(U:! Type) {
  let Result:! Type;
}
final impl forall [T:! Type] T as CommonTypeWith(T) where .Result = T {}

fn F[T:! Potato, U:! Hashable where .Self == T](x: T, y: U) -> auto {
  // What is T.CommonTypeWith(U).Result? Is it T or U?
  return (if cond then x else y).Hash();
}
```

With this proposal, `impl` validation for `T as CommonTypeWith(U)` fails: we
cannot pick a common type when given two distinct type expressions, even if we
know they evaluate to the same type, because we would not know which API the
result should have.

### Observe declarations

Same-type constraints are non-transitive, just like other constraints such as
`ImplicitAs`. The developer can use an `observe` declaration to bring a new
same-type constraint into scope:

```
observe A == B == C;
```

notionally does much the same thing as

```
impl A as SameAs(C) { ... }
```

where the `impl` makes use of `A is SameAs(B)` and `B is SameAs(C)`.

### Implementing an interface

When implementing an interface, the `=` syntax must be used, and each associated
constant without a default must be explicitly assigned-to:

```
impl IntVec as Container where .Element = i32 { ... }
```

not

```
impl IntVec as Container where .Element == i32 { ... }
```

The latter would be treated as

```
impl IntVec as Container where IntVec.Element is SameAs(i32) { ... }
```

... which only checks the value of `Element` rather than specifying it.

As in other contexts, `Self.Element` is rewritten to `i32` within the context of
the `impl`.

### Ergonomics

This proposal can be viewed as dividing type constraints into two categories:

-   Ergonomic, but quite restricted, constraints using `=`.
-   Non-ergonomic, but fully general, constraints using `==`.

In order for this to be an effective and ergonomic strategy, we require both
that the difference between these two kinds of constraints are readily
understood by developers, and that the more-ergonomic `=` constraints cover
sufficiently many scenarios that the developer seldom needs to write code to
request a conversion between types that are known to be the same.

## Rationale

-   [Language tools and ecosystem](/docs/project/goals.md#language-tools-and-ecosystem)
    -   This rule is easy to implement, and even a naive implementation should
        be efficient.
-   [Software and language evolution](/docs/project/goals.md#software-and-language-evolution)
    -   The status quo causes coincidentally-equal types to have the same
        interface. Under this proposal, the interface of a type is not affected
        by coincidental equality, only by intentional assignment to an
        associated type.
-   [Code that is easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write)
    -   Using `=` rather than `==` in `impl`s is easier to read and write.
    -   The interface available on a type is more predictable in this proposal
        than in the status quo ante, making code easier to understand.

## Alternatives considered

### Status quo

The [Problem](#problem) section describes some concerns with the status quo
approach. This proposal aims to address those concerns.

### Restrict constraints to allow computable type equality

We could somehow restrict which constraints can be specified, in order to ensure
that our type equality rule is efficiently computable, perhaps even in a way
that permits a deterministic computation of a canonical type. The exact details
of how we would do this have not been worked out, but this might lead to a
coherent rule that has transitive type equality. However, this would not solve
the "equal types with different interfaces" problem.

### Find a fully transitive approach to type equality

This proposal makes type equality transitive, but still has non-transitive
"same-type" constraints describing types that are known to always eventual be
the same after substitution, but which are not treated as the same type value
while type-checking a generic. This proposal also imposes a directionality on
rewrites, a restriction to only rewrite at a depth of exactly one associated
constant, and a restriction that only one value can be specified as equal to a
given associated constant. We could seek a type equality rule that would avoid
having two different kinds of equality and would avoid some or all of the
restrictions placed on rewrite constraints.

One candidate approach is to accept that the full generality of the equality
problem is
[hard](https://link.springer.com/content/pdf/10.1007/3-540-17220-3_7.pdf), but
attempt to solve it anyway. Because of the close correspondence between Turing
machines and string rewriting systems, this results in a type system with no
upper bound on its runtime. We consider this unacceptable for Carbon, but it is
the approach taken by some other modern languages:

-   Swift has an
    [undecidable type system](https://forums.swift.org/t/swift-type-checking-is-undecidable/39024)
    due to this, and handles the problem by placing a limit on the complexity of
    cases they will accept, but that seems unsuited to Carbon's goals, as the
    rule cannot be readily understood by a developer nor effectively worked
    around.
-   Rust also has an
    [undecidable type system (content warning: swear words)](https://sdleffler.github.io/RustTypeSystemTuringComplete/)
    for the same reason, and similarly has a recursion limit.

See also [Typing is Hard](https://3fx.ch/typing-is-hard.html), which lists
similar information for a variety of other languages. Note that most languages
listed have an undecidable type system.

Another candidate approach is to find a way to reduce the inputs to the
type-checking step as a set of non-quantified equalities. The resulting system
of equalities can then be
[solved efficiently](https://dl.acm.org/doi/pdf/10.1145/322186.322198) to
determine whether two types are known to be the same. This approach appears
sufficient to cope with locally-declared constraints, but when constraints
appear within interfaces, they can give rise to an infinite family of
equalities, and picking any finite subset risks the result being non-transitive
in general, if a different subset of equalities might be considered in a
different type-checking context.

### Use a different rule for "same rewrite"

We considered various rules for determining if two rewrites are using the same
rule. The goal is to select a rule that ensures there are only finitely many
different rewrites in a program, so that any non-termination will always be
detected, and to minimize the occurrence of false-positives.

One candidate was to consider rewrites the same if they apply to the same
associated constant. However, it seems likely that the false positive rate for
such a rule would be unacceptably high.

Another rule would be to consider rewrites the same if they correspond to the
same `=` token. This has the disadvantage that factoring out a common
subexpression can result in two constraints that were previously considered
different to now be considered the same, potentially breaking users.

Connecting sameness to both the `=` token and the `:!` token is intended to
minimize the risk of refactorings introducing false positives, while retaining a
set of rewrite constraints that grows at most quadratically in the size of the
program, and in practice much slower than that.

### Different names for same-type constraint

We considered various options for the spelling of a same-type constraint:

-   `where A == B`
-   `where A ~ B`
-   some other operator symbol
-   `where A is SameType(B)`, or some other constraint name

The advantage of `==` is that it has a lot of desirable implications: it's
familiar, symmetric, and connotes the left and right operand being the same.
However, it also might be taken as suggesting that the `==` overloaded operator
is used to determine equality. A different spelling would also indicate that
this is an unusual constraint, and would be easier to search for. Concerns were
also raised that `==` might suggest transitivity if taken to mean "same value"
rather than something like the Carbon `==` binary operator, and the transitivity
of `==` constraints is not automatic.

The `~` operator is currently not in use as a binary operator. However, that
makes it quite valuable syntactic real estate, and it may see little use in this
context in practice. A longer operator could be used, but any choice other than
`==` will present an unfamiliarity barrier, and longer operators will be harder
to remember.

A named constraint is appealing, but this operator does not behave like a named
constraint in that it is automatically symmetrized, not implementable, and
especially in its interactions with `observe` declarations. It is unclear how
`observe` declarations would be written with a named `SameType` constraint:

```
// Maybe something like this special-case and verbose syntax?
observe A is SameType(B) and B is SameType(C) => A is SameType(C);
```

The fundamental connection between same-type constraints and `observe` suggests
that dedicated syntax is justified.

For now, we use `==`, despite it having a different meaning in the context of a
constraint than in expression contexts. This is analogous to how `=` and `and`
have different meanings in this context from in expressions, so the behavior
divergence is at least consistent. It's also not clear at this stage how much
usage same-type constraints will have, compared to rewrite constraints, so it's
hard to judge the other arguments in favor of and against other operators. It
would be reasonable to revisit this decision when we have more usage
information.
