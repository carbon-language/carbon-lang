# Associated constant assignment versus equality

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/2173)

<!-- toc -->

## Table of contents

-   [Abstract](#abstract)
-   [Problem](#problem)
    -   [Equal types with different interfaces](#equal-types-with-different-interfaces)
    -   [Type canonicalization](#type-canonicalization)
    -   [Transitivity of equality](#transitivity-of-equality)
    -   [Coherence](#coherence)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Details](#details)
    -   [Rewrite constraints](#rewrite-constraints)
    -   [Combining constraints with `&`](#combining-constraints-with-)
    -   [Same type constraints](#same-type-constraints)
    -   [Observe declarations](#observe-declarations)
    -   [Implementing an interface](#implementing-an-interface)
    -   [Ergonomics](#ergonomics)
-   [Rationale](#rationale)
-   [Alternatives considered](#alternatives-considered)
    -   [Status quo](#status-quo)
    -   [Restrict constraints to allow computable type equality](#restrict-constraints-to-allow-computable-type-equality)
    -   [Different names for same-type constraint](#different-names-for-same-type-constraint)

<!-- tocstop -->

## Abstract

Split the `where A == B` constraint in two: `where .A = B` produces a new
constraint from an old one, where the value of `.A` in the new constraint is
known and eagerly rewritten to `B`, and `where A == B`, which does not cause `A`
and `B` to be considered as identical by language rules but does permit implicit
(no-op) conversion between them.

This aims to provide an efficiently-computable and human-understandable type
equality rule, with type canonicalization and therefore transitive type
equality, without sacrificing too much in the way of ergonomics and without
sacrificing determinism, while still providing the full power of a general type
constraint system in a less ergonomic form.

## Problem

### Equal types with different interfaces

When an associated type is constrained to be a concrete type, it is desirable
for the associated type to behave like that concrete type:

```
interface Hashable {
  fn Hash[me: Self]() -> u128;
}
interface X {
  let R:! Hashable;
  fn Make() -> R;
}
fn F[T:! X where .R == i32]() -> i32 {
  return F.Make() + 1;
}
```

Here, we want to be able to use the result of `F.Make()` in all regards like an
`i32`. Assuming an `i32.Abs` function exists, and `i32` implements `Hashable`
externally, it is more desirable for `F.Make().Abs()` to work than it is for
`F.Make().Hash()` to work.

We are
[currently aiming to address this](https://github.com/carbon-language/carbon-lang/pull/2070)
by saying that when two type expressions are constrained to be equal, a value
whose type is either of those type expressions provides the (disjoint) union of
their interfaces. This leads to a surprise:

```
fn G[T:! X where .R == i32]() -> u128 {
  let n: i32 = 1;
  let m: i64 = 2;
  return n.Hash() ^ m.Hash();
}
```

Here, the call to `n.Hash()` is valid but the call to `m.Hash()` is invalid,
because the type `i32` of `n` is constrained to be equal to `T.R` which is of
type `Hashable`, but the type `i64` is not constrained in that way and does not
implement `Hashable` internally.

This suggests that there might be two different behaviors that we want when
adding a constraint: either we are changing the interface, or not. This is
analogous to internal versus external implementation of an interface.

### Type canonicalization

There are a variety of contexts in which types are compared for equality. In
some of those contexts, it might be acceptable to perform a search and a
computation, and it might be acceptable to have false negatives. For example,
when analyzing an argument being passed to a function in a generic, it might be
OK to say "we can't prove that the argument has a type that is equal to (or
convertible to) the type of the parameter", so long as the developer has some
way to demonstrate that the types are the same if that is indeed the case.

However, not all comparisons of generic types have that property. As an extreme
and hopefully avoidable example, suppose a C++-like linkage model is used, with
name mangling. We may need to determine whether two type expressions are equal
at link time, by reducing them both to strings that are guaranteed to be
identical if the types are equal and non-identical otherwise. This requires some
form of type canonicalization: reducing all equal type expressions to some
common representation where we can faithfully perform equality comparisons.

Even if the semantics of Carbon don't require canonicalization, it is still a
very useful property for implementation purposes. For example, if type
canonicalization is possible to perform efficiently, building a data structure
mapping from a type to some value becomes much simpler, and if the
representation of a type expression carries its canonical form then type
equality comparisons can be done in constant time.

### Transitivity of equality

For ergonomic purposes, it is valuable for the notion of type expression
equality to be transitive: if type A is known to be the same as type B, and type
B is known to be the same as type C, then shouldn't we be able to use an A where
a C is required? See
[#1369](https://github.com/carbon-language/carbon-lang/issues/1369) for an
explanation of why this is important.

However, if we permit arbitrary constraints and have a transitive equality rule,
then type equality is isomorphic to the
[word problem for finitely-presented monoids](https://en.wikipedia.org/wiki/Word_problem_for_groups),
which is undecidable, and certainly not computable, in general.

Therefore we must impose a restriction somewhere: either not all constraints are
permissible, or we do not have transitivity, or we impose some other constraint
on the language to avoid the hard cases. Some languages merely impose some kind
of depth limit on their search for a proof of equality.

Note that if we can perform type canonicalization, then type equality is
necessarily transitive: if all equal _pairs_ of types canonicalize to the same
representation, then _all_ equal types canonicalize to the same representation
transitively.

### Coherence

In order to avoid surprises in the language behavior, we want Carbon to have the
property that learning more about the type of a value should not cause the
behavior of an expression to change from one valid behavior to another valid
behavior.

It's important to distinguish here between learning more about a type, such as
learning that it implements a particular interface – for example, from an added
import – and changing the type, such as by writing a different expression after
a `:` or `:!`. Changing the type of a value is expected to be able to change the
behavior of an expression using that value.

## Background

There has been a lot of work in this space. Some previous relevant proposals:

-   [#731: generics details 2](https://github.com/carbon-language/carbon-lang/pull/731)
    introduced associated types, with the intent that a mechanism to constrain
    their value would be provided in a later proposal.
-   [#818: generics details 3](https://github.com/carbon-language/carbon-lang/pull/818)
    introduced `where` constraints for generics, with an open question for
    whether and how we might restrict constraints in order to give a decidable
    type equality rule. #818 addressed that question by using a non-transitive
    rule with `observe` declarations to close the transitivity gaps.
-   [#2070: always `==` not `=` in `where` clauses](https://github.com/carbon-language/carbon-lang/pull/2070)
    describes our previous approach to the "equal types with different
    interfaces" problem.

## Proposal

Replace the existing `where A == B` constraint with two different kinds of
constraint:

-   `where .A = T` specifies a _rewrite_ constraint. If the associated constant
    `.A` is named as a member of a type with this constraint, it is rewritten to
    `T`. This means that the interface of the type changes, and the behavior is
    in all respects as if `T` had been specified directly.
-   `where X == Y` specifies a _same-type_ constraint. This is treated much like
    `where X is SameAs(Y)`. Here, `SameAs` is a hypothetical constraint that is
    reflexive (`T is SameAs(T)` for all `T`), commutative (`T is SameAs(U)` if
    and only if `U is SameAs(T)`), and not implementable by the developer.
    Moreover, if `F` is any pure type function, `T is SameAs(U)` implies
    `F(T) is SameAs(F(U)`). `observe` statements can be used to form transitive
    `SameAs` relations. Same-type constraints are not used automatically by the
    language rules for any purpose, but there is an `ImplicitAs(T)` impl for
    types implementing `SameAs(T)`.

A type implements `C where .A = T` if and only if it implements
`C where .A == T` – the inhabitants of these two type-of-types are the same, but
they are different type-of-types and provide different interfaces for
corresponding type values.

## Details

### Rewrite constraints

In a rewrite constraint, the left-hand operand of `=` must be a `.` followed by
the name of an associated constant. `.Self` is not permitted.
This notation is permitted anywhere a constraint can be
written, and results in a new constraint with a different interface: the named
member effectively no longer names an associated constant of the constrained
type, and is instead treated as a rewrite rule that expands to the right-hand
side of the constraint, with any mentioned parameters substituted into that
type.

```
interface Container {
  let Element:! Type;
  let Slice:! Container where .Element = Element;
}
// `T.Slice.Element` rewritten to `T.Element`
//     because type of `T.Slice` says `.Element = Element`.
// `T.Element` rewritten to `i32`
//     because type of `T` says `.Element = i32`.
fn A[T:! Container where .Element = i32](x: T.Slice.Element) {}
```

Rewrites aren't performed on the left-hand side of such an `=`, so
`where .A = .B and .A = C` is not rewritten to `where .A = .B and .B = C`.
Instead, such a `where` clause is invalid unless each rule for `.A` specifies
the same rewrite.

When an `=` appears within an interface, it is possible to form a cycle where a
type becomes more complex with each iteration. In order to avoid this problem,
if, when substituting into the right-hand side of such an `=`, the same rewrite
is performed again, the program is invalid.

```
interface Container {
  let Element:! Type;
  // (1), bad constraint
  let Slice:! Container where .Element = .Slice.Element;
}
// Error, `T.Slice.Element` rewritten to
// `T.Slice.Slice.Element` by (1), then to
// `T.Slice.Slice.Slice.Element` by (1)
fn A[T:! Container](x: T.Slice.Element) {}
```

It is valid for the same rewrite rule to be used multiple times within a type
expression, so long as it is not used during substitution into its own
right-hand side:

```
interface BInterface {
  let C:! Type;
}
interface AInterface {
  let D:! AInterface;
  let B:! BInterface where .C = Self.D;
}
// `A.B.C` is rewritten to `Self.D`, because the type of `A.B` says `.C = Self.D`.
//     `Self`=`A` is substituted into this giving `A.D`.
//     During this substitution, the same rewrite rule is not used again,
//     so this is OK.
// Then `A.D.B.C` is rewritten to `Self.D`, because the type of `A.D.B` says
// `.C = Self.D`.
//     `Self`=`A.D` is substituted into this giving `A.D.D`.
//     During this substitution, the same rewrite rule is not used again,
//     so this is also OK, even though the same rule was used twice
//     in forming the overall type.
fn F(A:! AInterface, d: A.B.C.B.C) {}
```

Rewrite constraints thereby give us a deterministic, terminating type
canonicalization mechanism for associated constants: in `A.B`, if the type of
`A` specifies that `.B == C`, then `A.B` is replaced by `C`. Equality of types
constrained in this way is transitive.

Note that given `T:! C where .R = i32` can result in a type `T.R` whose behavior
is different from the behavior of `T.R` given `T:! C`. For example, member
lookup into `T.R` can find different results and operations can therefore have
different behavior. However, this does not violate coherence because `C` and
`C where .R = i32` don't differ by merely having more type information; rather,
they are different types that have an isomorphic set of values, somewhat like
`i32` and `u32`. An `=` constraint is not merely learning a new fact about a
type, it is requesting different behavior.

### Combining constraints with `&`

Suppose we have `X = C where .R = A` and `Y = C where .R = B`. What should
`C & X` produce? What should `X & Y` produce?

We could perhaps say that `X & Y` results in a constraint where the type of `R`
has the union of the interface of `A` and the interface of `B`, and that `C & X`
similarly results in a constraint where the type of `R` has the union of the
interface of `A` and the interface originally specified by `C`. However, this
proposal suggests a simpler rule:

-   Combining two rewrite rules with different rewrite targets results in a
    constraint where the associated constant is ambiguous. Given `T:! X & Y`,
    the type expression `T.R` is ambiguous between a rewrite to `A` and a
    rewrite to `B`. But given `T:! X & X`, `T.R` is unambiguously rewritten to
    `A`.
-   Combining a constraint with a rewrite rule with a constraint with no rewrite
    rule preserves the rewrite rule. For example, supposing that
    `interface Container` extends `interface Iterable`, and `Iterable` has an
    associated constant `Element`, the constraint
    `Container & (Iterable where .Element = i32)` is the same as the constraint
    `(Container & Iterable) where .Element = i32` which is the same as the
    constraint `Container where .Element = i32`.

### Same type constraints

A same-type constraint describes that two type expressions are known to evaluate
to the same value. Unlike a rewrite constraint, however, the two type
expressions are treated as distinct types when type-checking a generic that
refers to them.

Same-type constraints are brought into scope, looked up, and resolved exactly as
if there were a `SameAs(U:! Type)` interface and a `T == U` impl corresponded to
`T is SameAs(U)`, except that `==` is commutative. As such, it's not possible to
ask for a list of types that are the same as a given type, nor to ask whether
there exists a type that is the same as a given type and has some property. But
it is possible to ask whether two types are (non-transitively) the same.

In order for same-type constraints to be useful, they must allow the two types
to be treated as actually being the same in some context. This can be
accomplished by the use of `==` constraints in an `impl`, such as in the
built-in implementation of `ImplicitAs`:

```
final impl forall [T:! Type, U:! Type where .Self == T] T as ImplicitAs(U) {
  @Carbon.Builtin("implicit_as_same_type")
  fn Convert[me: Self](other: U) -> U;
}
```

It superficially seems like it would be convenient if such implementations were
made available implicitly – for example, by writing
`impl forall [T:! Type] T as ImplicitAs(T)` – but in more complex examples that
turns out to be problematic. Consider:

```
interface CommonTypeWith(U:! Type) {
  let Result:! Type;
}
final impl forall [T:! Type] T as CommonTypeWith(T) where .Result = T {}

fn F[T:! Potato, U:! Hashable where .Self == T](x: T, y: U) -> auto {
  // What is T.CommonTypeWith(U).Result? Is it T or U?
  return (if cond then x else y).Hash();
}
```

With this proposal, `impl` validation for `T as CommonTypeWith(U)` fails: we
cannot pick a common type when given two distinct type expressions, even if we
know they evaluate to the same type, because we would not know which API the
result should have.

### Observe declarations

Same-type constraints are non-transitive, just like other constraints such as
`ImplicitAs`. The developer can use an `observe` declaration to bring a new
same-type constraint into scope:

```
observe A == B == C;
```

notionally does much the same thing as

```
impl A as SameAs(C) { ... }
```

where the `impl` makes use of `A is SameAs(B)` and `B is SameAs(C)`.

### Implementing an interface

When implementing an interface, the `=` syntax must be used, and each associated
constant without a default must be explicitly assigned-to:

```
impl IntVec as Container where .Element = i32 { ... }
```

not

```
impl IntVec as Container where .Element == i32 { ... }
```

The latter would be treated as

```
impl IntVec as Container where IntVec.Element is SameAs(i32) { ... }
```

... which only checks the value of `Element` rather than specifying it.

As in other contexts, `Self.Element` is rewritten to `i32` within the context of
the `impl`.

### Ergonomics

This proposal can be viewed as dividing type constraints into two categories:

-   Ergonomic, but quite restricted, constraints using `=`.
-   Non-ergonomic, but fully general, constraints using `==`.

In order for this to be an effective and ergonomic strategy, we require both
that the difference between these two kinds of constraints are readily
understood by developers, and that the more-ergonomic `=` constraints cover
sufficiently many scenarios that the developer seldom needs to write code to
request a conversion between types that are known to be the same.

## Rationale

-   [Language tools and ecosystem](/docs/project/goals.md#language-tools-and-ecosystem)
    -   This rule is easy to implement, and even a naive implementation should
        be efficient.
-   [Software and language evolution](/docs/project/goals.md#software-and-language-evolution)
    -   The status quo causes coincidentally-equal types to have the same
        interface. Under this proposal, the interface of a type is not affected
        by coincidental equality, only by intentional assignment to an
        associated type.
-   [Code that is easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write)
    -   Using `=` rather than `==` in `impl`s is easier to read and write.
    -   The interface available on a type is more predictable in this proposal
        than in the status quo ante, making code easier to understand.

## Alternatives considered

### Status quo

The [Problem](#problem) section describes some concerns with the status quo
approach. This proposal aims to address those concerns.

### Restrict constraints to allow computable type equality

We could somehow restrict which constraints can be specified, in order to ensure
that our type equality rule is efficiently computable, perhaps even in a way
that permits a deterministic computation of a canonical type. The exact details
of how we would do this have not been worked out, but this might lead to a
coherent rule that has transitive type equality. However, this would not solve
the "equal types with different interfaces" problem.

### Different names for same-type constraint

We considered various options for the spelling of a same-type constraint:

-   `where A == B`
-   `where A ~ B`
-   some other operator symbol
-   `where A is SameType(B)`, or some other constraint name

The advantage of `==` is that it has a lot of desirable implications: it's
familiar, symmetric, and connotes the left and right operand being the same.
However, it also might be taken as suggesting that the `==` overloaded operator
is used to determine equality. A different spelling would also indicate that
this is an unusual constraint, and would be easier to search for. Concerns were
also raised that `==` might suggest transitivity if taken to mean "same value"
rather than something like the Carbon `==` binary operator, and the transitivity
of `==` constraints is not automatic.

The `~` operator is currently not in use as a binary operator. However, that
makes it quite valuable syntactic real estate, and it may see little use in this
context in practice. A longer operator could be used, but any choice other than
`==` will present an unfamiliarity barrier, and longer operators will be harder
to remember.

A named constraint is appealing, but this operator does not behave like a named
constraint in that it is automatically symmetrized, not implementable, and
especially in its interactions with `observe` declarations. It is unclear how
`observe` declarations would be written with a named `SameType` constraint:

```
// Maybe something like this special-case and verbose syntax?
observe A is SameType(B) and B is SameType(C) => A is SameType(C);
```

The fundamental connection between same-type constraints and `observe` suggests
that dedicated syntax is justified.

For now, we use `==`, despite it having a different meaning in the context of a
constraint than in expression contexts. This is analogous to how `=` and `and`
have different meanings in this context from in expressions, so the behavior
divergence is at least consistent. It's also not clear at this stage how much
usage same-type constraints will have, compared to rewrite constraints, so it's
hard to judge the other arguments in favor of and against other operators. It
would be reasonable to revisit this decision when we have more usage
information.
