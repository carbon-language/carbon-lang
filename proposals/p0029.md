# Carbon: Linear, rebase, and pull-request GitHub workflow

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

- **[Tracking issue](https://github.com/carbon-language/carbon-lang/issues/TODO)**
- **Status:** RFC
- **Created:** 2020-05-27

**_PLEASE_ DO NOT SHARE OUTSIDE CARBON FORUMS**

## Problem

There are a variety of workflows that can be effectively used with both Git
version control and GitHub. We should have a common and consistent workflow
across as much of Carbon as possible. While some specific areas may end up
needing specialized flows to suit their needs, these should be the exceptions
and can be handled on a case-by-case basis when they arise.

## Background

- Chapter 16 "Version Control and Branch Management" in the SWE book
  (_[Software Engineering at Google](https://www.amazon.com/Software-Engineering-Google-Lessons-Programming/dp/1492082791)_)
- GitHub documentation on
  "[pull requests](https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/about-pull-requests)"
  - [Configuration of their merges](https://help.github.com/en/github/administering-a-repository/configuring-pull-request-merges)
  - [Protected branches](https://help.github.com/en/github/administering-a-repository/about-protected-branches)

## Proposal

Carbon repositories follow three basic principles:

- Linear history through
  [rebasing](https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/about-pull-request-merges#rebase-and-merge-your-pull-request-commits)
  or
  [squashing](https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/about-pull-request-merges#squash-and-merge-your-pull-request-commits),
  rather than merge commits from branches or forks
- Commit small, incremental changes to optimize for review, continuous
  integration, and bisection
- Always use pull requests (rather than directly pushing to the main branch)

These principles optimize for several different uses or activities with version
control:

- Continuous integration and bisection to identify failures and revert to green
- Code review both at the time of commit and follow-up review after commit
- Understanding how things evolve over time, which can manifest in different
  ways
  - When were things introduced?
  - How does the main branch and project evolve over time?
  - How was a bug or surprising thing introduced?

## Details

### Linear history

While Git can effectively bisect through complex history graphs, this is
significantly harder than bisecting across linear history. Especially for any
part of Carbon involving code, we expect bisection to be a pervasive tool and we
can make it simpler and more effective by forcing a linear history.

A linear history also makes it much easier to ask questions about whether a
particular change has landed yet, or when a bug was introduced. For some people,
releases are more simply understood as branching from a specific snapshot of the
linear history. While tools like `git log` can provide similar functionality, it
is less trivially understood.

Continuous integration is simplified for many of the same reasons as bisection:
the set of potential deltas is reduced to a linear sequence. Reverting to green
becomes easier to understand, and testing each incremental commit has a single
obvious interpretation.

Requiring linear history also incentivises incremental development that is
committed early to the main branch. This, in essence, ensures a single source of
truth model even with the distributed version control system. Because
works-in-progress are required to be rebased, they tend to merge early and often
rather than forming long-lived development branches. This helps reduce the total
merge resolution and testing costs as a project scales. For more details about
the advantages of using a single source of truth, see the full text of the
"Version Control and Branch Management" chapter in the SWE book.

One concern with linear history when rebasing a sequence of changes and merging
them is that the pull request associated with that sequence might not be obvious
from the main branch commit log. However, there is enough information in the
repository to establish the relationship, and GitHub's UI surfaces the pull
request on each commit in the series.

### Always use pull requests rather than pushing directly

We want to ensure that changes to Carbon are always reviewed, and the simplest
way to do this is to consistently follow a pull request workflow. Even if the
change seems trivial, still go through a pull request -- it'll likely be trivial
to review.

Always wait for someone else to review your pull request rather than just
merging it, even if you have permission to do so. We have set up automation on
GitHub to require pull requests.

### Small, incremental changes

Developing in small, incremental changes improves code review time, continuous
integration, and bisection. This means we typically squash pull requests into a
single commit when landing. We use two fundamental guides for deciding how to
split up pull requests:

1. Ensure that each pull request builds and passes any tests cleanly when you
   request review and when it lands. This will ensure bisection and continuous
   integration can effectively process them.

2. Without violating the first point, try to get each pull request to be "just
   right": not too big, not too small. You don't want to separate a pattern of
   tightly related changes into separate requests when they're easier to review
   as a set or batch. And you don't want to bundle unrelated changes together.
   Typically you should try to keep the pull request as small as you can without
   breaking apart tightly coupled changes. However, listen to your code reviewer
   if they ask to split things up or combine them.

While the default is to squash pull requests into a single commit, _during_ the
review you typically want to leave the development history undisturbed until the
end so that comments on any particular increment aren't lost. We typically use
the GitHub squash-and-merge functionality to land things.

#### Managing pull requests with multiple commits

Sometimes, it will make sense to _land_ a sereies of separate commits for a
single pull request through rebasing. This can happen when there is important
overarching context that should feed into the review, but the changes can be
usefully decomposed when landing them. When following this model, each commit
you intend to _land_ needs to follow the same fundamental rules as the pull
request above: they should each build and pass tests when landed in order, and
they should have well written, cohesive commit messages.

It may also make sense to rewrite history by interactive or non-interactive
rebasing to arrive at this final commit sequence. Be mindful of on-going code
review in choosing when to do this. Rewriting history in this way can make it
hard to track the resolution of comments. Typically, only do this as a cleanup
step when the review has finished, or when it won't otherwise disrupt code
review. Adding "addressing review comments" commits during the review, and then
rebasing them away before the pull request is merged is an expected and healthy
pattern.

This isn't intended to be full or complete guidance on how to manage code
reviews, just a basic indication of how to end up with a clean linear history on
the main branch. TODO: Add an explicit link to more detailed guidance on
managing pull request based code reviews when it is developed.

## Alternatives considered

### LLVM model

LLVM allows directly pushing to the main branch, but tries to enforce linear
history.

Pros:

- Still has linear history
- Incentivizes squashing for continuous integration and bisection
- Very low overhead for fixing trivial mistakes

Cons:

- Creates extremely bad incentives around code review
  - Lots of patches don't get pre-commit review, even if they would benefit from
    it
  - Very experienced contributors are much better at avoiding pre-commit review,
    so are rarely blocked waiting on review
  - Leads to the most experienced members of the community not doing enough code
    reviews, or being timely enough in code reviews
- UI and basic support for code reviews entirely focused on pull requests

### Fork and merge model

Classically, Git and GitHub support merging entire complex graphs of
development.

Pros:

- Mostly supported by pull requests, so still able to use much of that
  functionality.
- Supports a model in which contributors do not communicate and can each develop
  a local, decentralized fork while still achieving overall reconciliation.
- Can model much more complex history of code evolution faithfully in the
  tooling
  - Most of the time these aren't so complex as they create problems for humans

Cons:

- History is harder for humans to understand and reason about in complex cases
- Bisection and continuous integration are more complex
  - Especially difficult to have continuous integration check that each commit
    passes build/tests, because unclear what "order" they should be applied /
    explored.
  - Even if mitigated by simply choosing an ordering, removes incentive
    structure to land small, incremental changes to maximize the linear history
    which remains precise.
- Makes review of the main branch's history significantly harder due to
  non-linearity

### Fork and merge, but branches can only have linear history

Imagine a fork and merge model, but PRs can only have linear history. That is,
branching and merging within a PR, or merging `master` into PR is not allowed.
In this model, the only merge commits are merges of PRs into `master`. PRs
themselves donâ€™t contain merge commits.

Pros:

- Mostly supported by GitHub pull requests, so still able to use much of that
  functionality.
- Restricts non-linearity of history. The only non-linearity that is left is
  merge commits on the master branch. PRs themselves canâ€™t contain merge
  commits.

Cons:

- Requires a custom presubmit on GitHub that checks linearity of a PR.
- The cons of the fork and merge strategy regarding the complexity of history
  remain, but to a smaller degree, since non-linearity is restricted.
