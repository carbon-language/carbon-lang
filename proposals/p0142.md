# Unicode source files

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/142)

## Table of contents

<!-- toc -->

-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Details](#details)
    -   [Character encoding](#character-encoding)
    -   [Source files](#source-files)
    -   [Normalization](#normalization)
    -   [Characters in identifiers and whitespace](#characters-in-identifiers-and-whitespace)
-   [Alternatives considered](#alternatives-considered)
    -   [Character encoding](#character-encoding-1)
    -   [Byte order marks](#byte-order-marks)
    -   [Normalization forms](#normalization-forms)

<!-- tocstop -->

## Problem

Portable use and maintenance of Carbon source files requires a common
understanding of how they are encoded on disk. Further, the decision as to what
characters are valid in names and what constitutes whitespace are a complex area
in which we do not expect to have local expertise.

## Background

[Unicode](https://www.unicode.org/versions/latest/) is a universal character
encoding, maintained by the
[Unicode Consortium](https://home.unicode.org/basic-info/overview/). It is the
canonical encoding used for textual information interchange across all modern
technology.

The [Unicode Standard Annex 31](https://www.unicode.org/reports/tr31/), "Unicode
Identifier and Pattern Syntax", provides recommendations for the use of Unicode
in the definitions of general-purpose identifiers.

## Proposal

Carbon programs are represented as a sequence of Unicode code points. Carbon
source files are encoded in UTF-8.

Carbon will follow lexical conventions for identifiers and whitespace based on
Unicode Annex 31.

## Details

### Character encoding

Before being divided into tokens, a program starts as a sequence of characters.
Those characters are a sequence of Unicode code units -- integer values between
0 and 10FFFF<sub>16</sub> -- whose meaning as characters or non-characters is
defined by the Unicode standard.

Carbon is based on Unicode 13.0, which is currently the latest version of the
Unicode standard. Newer versions should be considered for adoption as they are
released.

### Source files

Program text can come from a variety of sources, such as an interactive
programming environment (a so-called "Read-Evaluate-Print-Loop" or REPL), a
database, or a command-line argument. However, the typical representation for
Carbon programs is in source files stored on disk, and such files are expected
to be encoded in UTF-8.

Carbon source files may begin with an optional UTF-8 BOM, that is, the byte
sequence EF<sub>16</sub>,BB<sub>16</sub>,BF<sub>16</sub>. This prefix, if
present, is ignored.

### Normalization

Carbon source files, outside comments and string literals, are required to be in
Unicode Normalization Form C ("NFC"). The Carbon source formatting tool will
convert source files to NFC as necessary to satisfy this constraint.

### Characters in identifiers and whitespace

We will largely follow Unicode Annex 31 in our selection of identifier and
whitespace characters. This Annex does not provide specific rules on lexical
syntax, instead providing a framework that permits a selection of choices of
concrete rules.

This proposal does not specify concrete choices, nor that we will not deviate
from Annex 31 in any concrete area. We may find cases where we wish to take a
different direction than that of the Annex. However, we should use Annex 31 as a
basis for our decisions, and should expect strong justification for deviations
from it.

## Alternatives considered

### Character encoding

We could restrict programs to ASCII.

Pro:

-   Reduced implementation complexity.
-   Avoids all problems relating to normalization, homoglyphs, text
    directionality, and so on.
-   We have no intention of using non-ASCII symbols outside Carbon programs.
-   Provides assurance that all names in libraries can reliably be typed by all
    developers -- we already require that keywords, and thus all ASCII letters,
    can be typed.

Con:

-   An overarching goal of the Carbon project is to provide a language that is
    inclusive and welcoming. A language that does not permit names in programs
    to be expressed in the developer's native language will not meet that goal
    for at least some of our developers.

### Byte order marks

We could disallow byte order marks.

Pro:

-   Marginal implementation simplicity.

Con:

-   Several major editors, particularly on the Windows platform, insert UTF-8
    BOMs and use them to identify file encoding.

### Normalization forms

We could require a different normalization form.

Pro:

-   Some environments might more naturally produce a different normalization
    form.
-   Normalization Form D is more uniform, in that characters are always
    maximally decomposed into combining characters; in NFC, characters may or
    may not be decomposed depending on whether a composed form is available.

Con:

-   The C++ standard and community is moving towards using NFC:
    -   WG21 is in the process of adopting a NFC requirement for C++
        identifiers.
    -   GCC warns on C++ identifiers that aren't in NFC.

We could require no normalization form, and normalize identifiers ourselves.

Pro:

-   We could treat source text identically regardless of the normalization form.

Con:

-   There is substantially more implementation cost involved in normalizing
    identifiers than in detecting whether they are in normal form.
    -   This proposal would require the implementation complexity of converting
        into NFC in the formatting tool, but would not require the conversion
        cost to be paid during compilation.

We could require no normalization form and compare identifiers by code point
sequence.

Pro:

-   This is the rule currently in use in C++.

Con:

-   This is not the rule planned for the near future of C++.
-   Different representations of the same character may result in different
    identifiers, in a way that is likely to be invisible in most programming
    environments.
