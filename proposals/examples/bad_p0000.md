# Introduce `train`

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

<!-- toc -->

## Table of contents

-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Details](#details)
-   [Rationale](#rationale)
-   [Alternatives considered](#alternatives-considered)
-   [Unresolved questions](#unresolved-questions)

<!-- tocstop -->

## Problem

Our symbols are so lack: we need to add more symbols to the lonely family. It
adds more textual elements to be recognized by Explorer. It helps to improve the
size of our codebase. I especially have seen this functionality in
[Swift](https://en.wikipedia.org/wiki/SWIFT). It actually has no problem, but it
is very cool.

## Background

Fast forward to 1942, Brian Kernighan was born and he said:
> Do what you think is interesting, do something that you think is fun and
> worthwhile, because otherwise you won't do it well anyway.

Therefore, we use `Boolean` value and it is the application of low-level. If the
value is `true`, then the condition is `true`, likewise `train` is executed.
This means we transfer the value maybe after **passing-by-reference**. If the
object was created dynamically it has to be destroyed. However, if it's `false`
then `train` is _not_ executed. In this case, we say _anti-train_. I will write
more about the case in 'Detail' section.

## Proposal
Look at
[here](https://doc.rust-lang.org/stable/reference/items/traits.html#generic-traits).
As we can see, `trait` is in the clause and `fn` is in the following expression.
This grammar is very concrete. It is little very similar to this concept. In
conclusion, this is **agile** and it can be **cloud** application that is indeed
very good practice:

```rust
train Seq<T> {   // Here
    fn len(&self) -> u32;
    fn elt_at(&self, n: u32) -> T;
    fn iter<F>(&self, f: F) where F: Fn(T);
}
```

This `train` runs at run-time and it was compiled at **compile-time**. The value
is returned(because it will use RAII) after previous instructions. It means it
was a successful execution. Therefore, there is **no error** unless newly
spawned thread was not cleaned. This means It improves like SFINAE concurrently.
Note it was assumed that we had some configuration time or build time in order
to deploy them during the development.

## Details

I will write in the future when I gain many many comments that you guys
basically teach me everything, so I only need to write accordingly.

## Rationale

It is more popular. It looks better. I heard somewhere It is also good for some
other features. It improves code. It is good so you can code more and more. This
is from Rust, so it is guaranteed. It is similar to the idea of `trait` but
better and It's all because it has better readability. See this convincing
[link](https://doc.rust-lang.org/stable/reference).

## Alternatives considered

1. `sself` : it is self but stronger:

-   `&SSelf (i.e. &self)`
-   `&mut SSelf (i.e &mut self)`

2. Instead, We can use [Kubernetes](https://kubernetes.io/):
-   for example hypervisor, operating system, hardware, etc.

3. Supervised Learning Algorithm on Embedded System(IOT) with Encryption

## Unresolved questions

-   What else can be more readable?
-   Is this object-oriented?
