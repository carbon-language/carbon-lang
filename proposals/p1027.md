# Generic details 9: weak impls

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/1027)

<!-- toc -->

## Table of contents

-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Rationale based on Carbon's goals](#rationale-based-on-carbons-goals)
-   [Alternatives considered](#alternatives-considered)
    -   [Status quo](#status-quo)
    -   [Broadly allowing `strong` constraints](#broadly-allowing-strong-constraints)

<!-- tocstop -->

## Problem

Requiring that users of an interface implement a different interface than they
use as a constraint, in order to satisfy the
[acyclic rule](/docs/design/generics/details.md#acyclic-rule) for blanket impls,
is a bad user experience. These problems arise in our plans for interfaces used
in operator overloading, such as equality and ordering comparisons and the
common type for the conditional operator.

## Background

The [acyclic rule](/docs/design/generics/details.md#acyclic-rule) was introduced
with parameterized impls in
[proposal #920](https://github.com/carbon-language/carbon-lang/pull/920).

## Proposal

The library that defines an interface is allowed to mark some blanket impls as
_weak_, and distinguish in constraints whether a particular impl is weak. This
proposal adds a
[weak impls section to the generics detailed design document](/docs/design/generics/details.md#weak-impls)
in addition to the
[`weak` and `strong` keywords](/docs/design/lexical_conventions/words.md).

## Rationale based on Carbon's goals

-   [Software and language evolution](/docs/project/goals.md#software-and-language-evolution):
    This feature allows an interface author to add new blanket impls without
    triggering compilation failures with existing impls due to the
    [acyclic rule](/docs/design/generics/details.md#acyclic-rule).
-   [Code that is easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write):
    It is much easier for developers to understand a single interface name than
    some connection between two different interface names.

## Alternatives considered

### Status quo

The main alternative considered was the status quo that cycles would be broken
by splitting an interface in two. This proposal has some advantages over the
status quo:

-   Avoids mistakes where the user picks the wrong name for the interface for a
    particular use.
-   Clearer connection between the name used in a constraint and what a type has
    to implement to satisfy that constraint.
-   More natural for the user. When you implement the same interface as you use
    in constraints, it feels like you are implementing a interface instead of
    opting into some arbitrary customization point that eventually causes an
    interface to be implemented.
-   This proposal also gives a tool for evolving the set of blanket impls for an
    interface without introducing compilation failures due to the
    [acyclic rule](/docs/design/generics/details.md#acyclic-rule).

### Broadly allowing `strong` constraints

We considered allowing a constraints to be strong outside of the library
defining the interface. The thinking was, though, that which implementations are
weak or strong is an implementation detail and should not be something
observable. The current proposal allows the interface's library provides a way
to let other libraries use a strong constraint on that interface by exporting a
named constraint.

This is something we would consider changing in the future if some use case that
would benefit was found.
