# Raw identifier syntax

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/3797)

<!-- toc -->

## Table of contents

-   [Abstract](#abstract)
-   [Problem](#problem)
-   [Background](#background)
    -   [Prior discussion](#prior-discussion)
    -   [Other languages](#other-languages)
-   [Proposal](#proposal)
    -   [Diagnostics](#diagnostics)
-   [Rationale](#rationale)
-   [Alternatives considered](#alternatives-considered)
    -   [Other raw identifier syntaxes](#other-raw-identifier-syntaxes)
    -   [Restrict `r#` to current and future keywords](#restrict-r-to-current-and-future-keywords)
    -   [Don't require `r#` for references to raw identifiers](#dont-require-r-for-references-to-raw-identifiers)
    -   [Don't provide raw identifier syntax](#dont-provide-raw-identifier-syntax)

<!-- tocstop -->

## Abstract

We want to support legacy identifiers that overlap with new keywords (for
example, `base`). This is being called "raw identifier syntax" using
`r#<identifier>`, and is based on
[Rust](https://doc.rust-lang.org/reference/identifiers.html).

## Problem

One of Carbon's most important goals is to support program and language
evolution. We know that the set of keywords in Carbon will grow over time, and
the easiest kind of language change from an evolutionary perspective is one that
is known to break no programs, that lets programs migrate incrementally to the
new language rule, and that either has no migration cost or only imposes
automatable migration cost on the code that intends to use the new feature.

## Background

### Prior discussion

We have proposals that discussed using `r#` but did not make a decision in favor
of it:

-   [Proposal #17: Lexical conventions](https://github.com/carbon-language/carbon-lang/pull/17)
    originally proposed it, but when it was split into multiple proposals, raw
    identifiers were not retained.
    -   This proposal copies substantial parts of its text from here.
-   [Proposal #2107: Clarify rules around `Self` and `.Self`](https://github.com/carbon-language/carbon-lang/pull/2107)
    mentions `r#` syntax as proposed but not in use.

### Other languages

[Rust](https://doc.rust-lang.org/reference/identifiers.html) provides this as
"Raw identifiers", using `r#` as a prefix (`r#self`). The documented syntax is:

```
RAW_IDENTIFIER : r# IDENTIFIER_OR_KEYWORD Except crate, self, super, Self
```

[C#](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/verbatim)
provides this as "vebatim identifiers", using `@` as a prefix (`@self`). The
[documented syntax](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#643-identifiers)
is:

```
fragment Escaped_Identifier
    // Includes keywords and contextual keywords prefixed by '@'.
    // See note below.
    : '@' Basic_Identifier
    ;
```

[Swift](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/lexicalstructure/#Identifiers)
provides this as part of the identifier grammar, using backticks (\`self\`). The
documented syntax is:

```
identifier â†’ `identifier-head identifier-characters?`
```

## Proposal

A _raw identifier_ can be specified by prefixing a word with `r#`, such as
`r#requires`. Raw identifiers can be used to introduce and use names that are
lexically identical to keywords. The declaration of a raw identifier does not
prevent the base word from being interpreted as a keyword; otherwise, they
behave identically to the word formed by removing the `r#` prefix.

### Diagnostics

In diagnostics, if there is a keyword `r#<identifier>`, then raw identifiers
should be expected to print with the `r#` prefix. Otherwise, they will typically
use the non-prefixed identifier name for consistency.

## Rationale

-   [Software and language evolution](/docs/project/goals.md#software-and-language-evolution)
    -   Raw identifier syntax provides a way to add keywords to the language
        while still offering code a reasonable upgrade path, which can also be
        automated.
-   [Code that is easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write)
    -   The `r#` syntax is consistent with raw string literals, and should be
        representative to readers that something unusual is being done.
-   [Interoperability with and migration from existing C++ code](/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code)
    -   C++ code using identifiers that are keywords in Carbon can use raw
        identifier syntax.
    -   The converse does not work: if Carbon code has an identifier that is a
        C++ keyword, it needs to be renamed for use from C++ code.

## Alternatives considered

### Other raw identifier syntaxes

Advantages to `r#` are:

-   We use `#` prefixes for
    [string literals](/docs/design/lexical_conventions/string_literals.md), and
    it's likely we'll support syntax similar to `f#` for formatted string
    literals. The `r#` syntax offers consistency with this, and will hopefully
    be recognizable to users.
-   Consistency with Rust.
-   Avoids reserving an otherwise unused character for a syntax that should have
    narrow usage.

Disadvantages are that any `r`-prefixed identifier parses substantially slower,
as noted in [PR #3044](https://github.com/carbon-language/carbon-lang/pull/3344)
which implemented `r#` syntax.

Other syntaxes we considered are:

-   `#` without `r`.
    -   Would be more consistent with string literals, and avoid the lexing
        overhead.
    -   We are considering using a `#` prefix for metaprogramming, so the `r`
        offers a way to keep the `#` prefix available for other purposes.
    -   `#if` may look to C++ developers like a compiler directive, rather than
        a raw identifier.
-   Backticks, as in Swift.
    -   We prefer not to use backticks for Carbon syntax so that it is easy to
        write in Markdown, which uses backticks for inline code.
-   `@` prefix, as in C#.
    -   We've also discussed using `@` for attributes, similar to Python.
-   Other currently unused characters, such as `~` or `%`.
    -   Reserves a character for a feature with limited usage.
    -   Misses an opportunity to provide cross-language consistency.

### Restrict `r#` to current and future keywords

We had discussed maintaining a list of current and future keywords, and only
allowing `r#` in those cases. We aren't doing that because it creates an
additional burden for software evolution, that the language must release a
version that "declares" future keywords without turning them into actual
keywords.

### Don't require `r#` for references to raw identifiers

We could say that, in a scope where a raw identifier has been declared, the
token without `r#` now refers to the identifier instead of the keyword. If the
user actually needs the keyword, they could instead use `k#` or something
similar.

A particularly complex example of this can be seen with the `base` keyword:

```
class C {
    extend base: T;
    var r#base: i32;
}

fn MakeC() -> C {
  return {.base = 0, .k#base = { ... }};
}
```

At present we are deciding this is unnecessary complexity, and it's better to
require `r#` in all references to the identifier.

### Don't provide raw identifier syntax

We could omit raw identifier syntax. It introduces a novel risk of underhanded
code that appears to mean one thing but means a different thing, by shadowing a
keyword with an identifier. This risk is discussed in
[Initial Analysis of Underhanded Source Code (Wheeler 2020)](https://www.ida.org/-/media/feature/publications/i/in/initial-analysis-of-underhanded-source-code/d-13166.ashx)
(page 4-2).

This concern is considered non-blocking.
