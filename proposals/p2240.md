# Variadics

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/2240)

<!-- toc -->

## Table of contents

-   [Abstract](#abstract)
-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
    -   [Examples](#examples)
    -   [Comparisons](#comparisons)
-   [Rationale](#rationale)
-   [Alternatives considered](#alternatives-considered)
    -   [Member packs](#member-packs)
    -   [First-class packs](#first-class-packs)
    -   [Generalize `expand`](#generalize-expand)
    -   [Omit `expand`](#omit-expand)
    -   [Support expanding arrays](#support-expanding-arrays)
    -   [Omit pack bindings](#omit-pack-bindings)
        -   [Disallow pack-type bindings](#disallow-pack-type-bindings)
    -   [Fold expressions](#fold-expressions)
    -   [Allow multiple pack expansions in a tuple pattern](#allow-multiple-pack-expansions-in-a-tuple-pattern)
    -   [Allow nested pack expansions](#allow-nested-pack-expansions)
    -   [Use postfix instead of prefix `...`](#use-postfix-instead-of-prefix-)
    -   [Avoid context-sensitity in pack expansions](#avoid-context-sensitity-in-pack-expansions)
        -   [Fold-like syntax](#fold-like-syntax)
        -   [Variadic blocks](#variadic-blocks)
        -   [Keyword syntax](#keyword-syntax)
    -   [Require parentheses around `each`](#require-parentheses-around-each)
    -   [Fused expansion tokens](#fused-expansion-tokens)
    -   [Support merging parameters](#support-merging-parameters)

<!-- tocstop -->

> **FIXME:** Revise proposal to match state of variadics.md.

## Abstract

Proposes a set of core features for declaring and implementing generic variadic
functions.

A "pack expansion" is a syntactic unit beginning with `...`, which is a kind of
compile-time loop over sequences called "packs". Packs are initialized and
referred to using "pack bindings", which are marked with the `each` keyword at
the point of declaration and the point of use.

The syntax and behavior of a pack expansion depends on its context, and in some
cases by a keyword following the `...`:

-   In a tuple literal expression (such as a function call argument list), `...`
    iteratively evaluates its operand expression, and treats the values as
    successive elements of the tuple.
-   `...and` and `...or` iteratively evaluate a boolean expression, combining
    the values using `and` and `or`, and ending the loop early if the underlying
    operator short-circuits.
-   In a statement context, `...` iteratively executes a statement.
-   In a tuple literal pattern (such as a function parameter list), `...`
    iteratively matches the elements of the scrutinee tuple. In conjunction with
    pack bindings, this enables functions to take an arbitrary number of
    arguments.

## Problem

Carbon needs a way to define functions and parameterized types that are
_variadic_, meaning they can take a variable number of arguments.

## Background

C has long supported variadic functions through the "varargs" mechanism, but
that's heavily disfavored in C++ because it isn't type-safe. Instead, C++
provides a separate feature for defining variadic _templates_, which can be
functions, classes, or even variables. However, variadic templates currently
suffer from several shortcomings. Most notably:

-   They must be templates, which means they cannot be definition-checked, and
    suffer from a variety of other costs such as needing to be defined in header
    files, and code bloat due to template instantiation.
-   It is inordinately difficult to define a variadic function whose parameters
    have a fixed type, and the signature of such a function does not clearly
    communicate that fixed type to readers.
-   There is no procedural mechanism for iterating through a variadic parameter
    list. Although features like
    [fold expressions](https://en.cppreference.com/w/cpp/language/fold) cover
    some special cases, the only fully general way to express iteration is with
    recursion, which is often awkward, results in more template instantiations,
    and typically has at least quadratic overhead in the size of the pack (at
    compile time, and sometimes at run time).

There have been a number of C++ standard proposals to address some of these
issues, and improve variadic templates in other ways, such as
[P1219R2: Homogeneous variadic function parameters](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1219r2.html),
[P1306R1: Expansion Statements](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1306r1.pdf),
[P1858R2: Generalized Pack Declaration and Usage](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1858r2.html),
and
[P2277R0: Packs Outside of Templates](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2277r0.html).
However, C++ has chosen not to pursue definition-checking even for non-variadic
functions, so definition-checked variadics seem out of reach, and the most
recent proposals to directly address the other two issues are (respectively)
[inactive](https://github.com/cplusplus/papers/issues/156) and outright
[rejected](https://github.com/cplusplus/papers/issues/297).

Swift supports
[variadic parameters](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/functions/#Variadic-Parameters)
so long as all elements have the same type, and has recently approved
[SE-0393: Value and Type Parameter Packs](https://github.com/apple/swift-evolution/blob/main/proposals/0393-parameter-packs.md),
which adds support for definition-checked, heterogeneous variadic parameters
(with a disjoint syntax).
[SE-0404: Pack Iteration](https://github.com/simanerush/swift-evolution/blob/se-0404-pack-iteration/proposals/0404-pack-iteration.md),
which extends that to support iterating through a variadic parameter list, has
been positively received, but hasn't yet been approved.

There have been several attempts to add such a feature to Rust, but that work is
[currently inactive](https://github.com/rust-lang/rfcs/issues/376#issuecomment-830034029).

## Proposal

See `/docs/design/variadics.md` in this pull request.

### Examples

```carbon
// Computes the sum of its arguments, which are i64s
fn SumInts(... each param: i64) -> i64 {
  var sum: i64 = 0;
  ... sum += each param;
  return sum;
}
```

```carbon
// Concatenates its arguments, which are all convertible to String
fn StrCat(... each param: some ConvertibleToString) -> String {
  var len: i64 = 0;
  ... len += each param.Length();
  var result: String = "";
  result.Reserve(len);
  ... result.Append(each param.ToString());
  return result;
}
```

```carbon
// Returns the minimum of its arguments, which must all have the same type T.
fn Min[T:! Comparable & Value](... each(>=1) param: T) -> T {
  let (var result: T, ... each next: T) = (... each param);
  ... if (each next < result) {
    result = each next;
  }
  return result;
}
```

```carbon
// Invokes f, with the tuple `args` as its arguments.
fn Apply[... each T:! type, F:! CallableWith(... each T)]
    (f: F, args: (... each T)) -> auto {
  return f(...expand args);
}
```

```carbon
// Takes an arbitrary number of vectors with arbitrary element types, and
// returns a vector of tuples where the i'th element of the vector is
// a tuple of the i'th elements of the input vectors.
fn Zip[... each ElementType:! type]
      (... each vector: Vector(each ElementType))
      -> Vector((... each ElementType)) {
  ... var each iter: auto = each vector.Begin();
  var result: Vector((... each ElementType));
  while (...and each iter != each vector.End()) {
    result.push_back((... each iter));
    ... each iter++;
  }
  return result;
}
```

```carbon
// Toy example of mixing variadic and non-variadic parameters.
// Takes an i64, any number of f64s, and then another i64.
fn MiddleVariadic(first: i64, ... each middle: f64, last: i64);
```

```carbon
// Toy example of using the result of variadic type deduction.
fn TupleConcat[... each T1: type, ... each T2: type](
    t1: (... each T1), t2: (... each T2)) -> (... each T1, ... each T2) {
  return (...expand t1, ...expand t2);
}
```

### Comparisons

The following table compares selected examples of Carbon variadics against
equivalent code written in C++20 (with and without the extensions discussed
[earlier](#background)) and Swift.

<table>
<tr>
<th>Carbon</th>
<th>C++20</th>
<th>C++20 with extensions</th>
<th>Swift with extensions</th>
</tr>

<tr>
<td>

```carbon
// Computes the sum of its arguments, which are i64s
fn SumInts(... each param: i64) -> i64 {
  var sum: i64 = 0;
  ... sum += each param;
  return sum;
}
```

</td>
<td>

```C++
template <typename... Params>
    requires (std::convertible_to<Params, int64_t> && ...)
int64_t SumInts(const Params&... params) {
  return (static_cast<int64_t>(params) + ... + 0);
}
```

</td>
<td>

With P1219R2:

```C++
int64_t SumInts(int64... params) {
  return (static_cast<int64_t>(params) + ... + 0);
}
```

</td>
<td>

(No extensions)

```swift
func SumInts(_ params: Int64...) {
  var sum: Int64 = 0
  for param in params {
    sum += param
  }
  return sum
}
```

</td>
</tr>
<tr>
<td>

```carbon
fn Min[T:! Comparable & Value](... each(>=1) param: T) -> T {
  let (var result: T, ... each next: T) = (... each param);
  ... if (each next < result) {
    result = each next;
  }
  return result;
}
```

</td>
<td>

```c++
template <typename T>
    requires std::totally_ordered<T> && std::copyable<T>
T Min(const T& t) {
  return t;
}

template <typename T, typename... Params>
    requires std::totally_ordered<T> && std::copyable<T> &&
             (std::same_as<T, Params> && ...)
T Min(T first, Params... rest) {
  T min_rest = Min(rest...);
  if (min_rest < first) {
    return min_rest;
  } else {
    return first;
  }
}
```

</td>
<td>

With P1219R2 and P1306R1

```c++
template <typename T>
    requires std::totally_ordered<T> && std::copyable<T>
T Min(const T& first, const T&... rest) {
  T result = first;
  for... (const T& t: rest) {
    if (t < result) {
      result = t;
    }
  }
  return result;
}
```

</td>
<td>

(No extensions)

```swift
func Min<T: Comparable>(_ first: T, _ rest: T...) -> T {
  var result: T = first;
  for t in rest {
    if (t < result) {
      result = t
    }
  }
  return result
}
```

</td>
</tr>
<tr>
<td>

```carbon
fn StrCat[... each T:! ConvertibleToString](... each param: each T) -> String {
  var len: i64 = 0;
  ... len += each param.Length();
  var result: String = "";
  result.Reserve(len);
  ... result.Append(each param.ToString());
  return result;
}
```

</td>
<td>

```c++
template <ConvertibleToString... Ts>
std::string StrCat(const Ts&... params) {
  std::string result;
  result.reserve((params.Length() + ... + 0));
  StrCatImpl(&result, params...);
  return result;
}

void StrCatImpl(std::string* out) { return; }

template <ConvertibleToString T, ConvertibleToString... Ts>
void StrCatImpl(std::string* out, const T& first, const Ts&... rest) {
  out->append(first.ToString());
  StrCatImpl(out, rest...);
}
```

</td>
<td>

With P1306R1

```c++
template <ConvertibleToString... Ts>
std::string StrCat(const Ts&... params) {
  std::string result;
  result.reserve((params.Length() + ... + 0));
  for... (auto param: params) {
    result.append(param.ToString());
  }
  return result;
}
```

</td>
<td>

With SE-0393 and SE-404

```swift
func StrCat<each T: ConvertibleToString>(_ param: repeat each T) -> String {
  var len: Int64 = 0;
  for param in repeat each param {
    len += param.Length()
  }
  var result: String = ""
  result.reserveCapacity(len)
  for param in repeat each param {
    result.append(param.ToString())
  }
  return result
}
```

</td>
</tr>
</table>

## Rationale

Carbon needs variadics to effectively support
[interoperation with and migration from C++](/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code),
where variadic templates are fairly common. Variadics also make code
[easier to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write),
because some APIs (such as `printf`) can't be naturally expressed in terms of a
fixed number of parameters.

Furthermore, Carbon needs to support _generic_ variadics for the same reasons it
needs to support generic non-variadic functions: for example,
definition-checking makes APIs
[easier to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write),
and [easier to evolve](/docs/project/goals.md#software-and-language-evolution).
Furthermore, the language as a whole is easier to understand and write code in
if separate features like variadics and generics compose in natural ways, rather
than being mutually exclusive.

Variadics are also important for supporting
[performance-critical software](/docs/project/goals.md#performance-critical-software),
because variadic APIs can be more efficient than their non-variadic
counterparts. For example, `StrCat` is fundamentally more efficient than
something like a chain of `operator+` calls on `std::string`, because it does
not need to materialize a series of partial results, and it can pre-allocate a
buffer large enough for the final result.

This proposal deviates somewhat from the principle that
[all APIs are library APIs](/docs/project/principles/library_apis_only.md)
because it treats tuples and packs as effectively built-in. As the document for
this principle notes, tuples may be an exception to the principle because it is
very hard to see how we could define them as library types without circularity.
Packs have much the same problem, since a type representing a pack would itself
have to be a variadic type. The need for both types to deeply support symbolic
computation adds some major challenges here as well. However, if tuples could
ever be library types, they would certainly need to be defined variadically, so
in that sense this proposal may actually support that principle.

## Alternatives considered

### Member packs

We could potentially support declaring `each` bindings as class members.
However, this raises some novel design issues. In particular, pack bindings
currently rely exclusively on type deduction for information like the arity of
the pack, but for class members, there usually isn't an initializer available to
drive type deduction.

In addition, it's usually if not always possible to work around the lack of
member packs by using members with tuple or array types instead. Consequently,
this feature is deferred to future work.

### First-class packs

The current proposal's approach to packs is awkward and potentially confusing in
several ways:

-   A type pack is composed of segments (like a tuple type), but is not a type.
-   A pack is a sequence of values (like a tuple), but is not a value.
-   An expression in a pack expansion does not have a type, but instead has a
    type pack.

We could resolve that awkwardness by instead saying:

-   A _pack type_ is composed of segments (like a tuple type).
-   A pack is a value, and its type is a pack type.
-   An expression in a pack expansion has a pack type.

However, that's confusing in a more fundamental way: it violates the basic
type-system property that the value of an expression is an instance of the type
of the expression.

It's tempting to try to resolve that problem by saying that the value of an
expression in a pack expansion is itself a pack. In effect, this treats pack
expansions like SIMD code, with expressions operating on "vectors" of data in
parallel, rather than iteratively executing the code on a series of scalar
values. And unfortunately, this model has the same limitation for variadics as
it does for SIMD: it can't model branching control flow.

For example, consider
`(... if (expand cond) then F(expand param) else G(expand param))`: if
`expand param` truly evaluated to a pack value, then evaluating this expression
would require N calls to _both_ `F` and `G`, rather than N calls to _either_ `F`
or `G`. Even for expressions that don't contain control flow, the same problem
applies when they occur within a statement pack expansion that does. We can't
even statically detect these problems, because a branch could be hidden inside a
function call. And this isn't just a performance problem -- if `F` or `G` have
side effects, it can also be a correctness problem.

### Generalize `expand`

The syntax "`...expand` _expression_" behaves like syntactic sugar for
`... each x`, where `x` is an invented pack binding in the same scope, defined
as if by "`let (... each x: auto) =` _expression_". We could generalize that by
saying that `expand` is a prefix operator with the same precedence as `*` that
can be used anywhere in a pack expansion, where "`expand` _expression_" is
syntactic sugar for `each x` (with `x` defined as before, in the scope
containing the pack expansion). This would make `expand` more useful, and also
resolve the anomaly where `...expand` is the only syntax that begins with `...`
but is not a pack expansion. It is also a precondition for several of the
alternatives discussed below.

However, those semantics could be very surprising in practice. For example:

```carbon
...if (Condition()) {
  var x: auto = expand F(y);
}
```

In this code, `F(y)` is evaluated before the pack expansion is entered, which
means that it is evaluated unconditionally, and it cannot refer to names
declared inside the `if` block.

We can avoid the name-resolution issue by disallowing `expand` in statement pack
expansions, but the sequencing of evaluation could still be surprising,
particularly with `if` expressions.

### Omit `expand`

As noted above, `...expand` is fundamentally syntactic sugar, so we could omit
it altogether. This would somewhat simplify the design, and avoid the anomaly of
having one syntax that starts with `...` but isn't a pack expansion. However,
that would make it substantially less ergonomic to do things like expand a tuple
into an argument list, which we expect to be relatively common.

### Support expanding arrays

Statically-sized arrays are very close to being a special case of tuple types:
the only difference between an array type `[i32; 2]` (using Rust syntax) and a
tuple type `(i32, i32)` is that the array type can be indexed with a run-time
subscript. Consequently, it would be fairly natural to allow `expand` to operate
on arrays as well as tuples, and even to allow arrays of types to be treated as
tuple types (in the same way that tuples of types can be treated as tuple
types).

This functionality is omitted from the current proposal because we have no
motivating use cases, but it could be added as an extension. Note that there are
important motivating use cases under some of the alternatives considered below.

### Omit pack bindings

Rather than introducing a special kind of binding pattern to enable variadics,
we could rely on the type to provide that information. For example, under the
current proposal, the signature of `Zip` is:

```carbon
fn Zip[... each ElementType:! type]
      (... each vector: Vector(each ElementType))
      -> Vector((... each ElementType));
```

With this alternative, it could instead be written:

```carbon
fn Zip[ElementTypes:! [type;]]
      (... vectors: Vector(expand ElementTypes))
      -> Vector((... expand ElementTypes));
```

This employs several features not in the primary proposal:

-   In cases where the declared type of the pack binding does not vary across
    iterations (like `ElementType`), we can re-express it as an array binding if
    [`expand` supports arrays](#support-expanding-arrays), and if
    [`expand` is a stand-alone operator](#generalize-expand). Note that we only
    need this in type position of a binding pattern, where we could more easily
    restrict `expand` to avoid the problems discussed earlier.
-   In cases where the declared type of the binding does vary, that fact alone
    implies that the binding is a pack binding, so we can effectively infer the
    presence of `each` from the type, rather than make the user spell it out
    explicitly.
-   Pack types and pack values are supported, and expressions can have pack
    values. However, run-time pack values can only occur in the type position of
    a binding pattern, where we can easily disallow branching and function calls
    in order to avoid the problems with first-class packs discussed
    [earlier](#first-class-packs).

This slight change in syntax belies a much larger shift in the underlying
semantics: since these are ordinary bindings, a given call to `Zip` must bind
each of them to a single value that represents the whole sequence of arguments
(which is why their names are now plural). In the case of `ElementTypes`, that
follows straightforwardly from its type: it represents the argument types as an
array of `type`s. The situation with `vectors` is more subtle: we have to
interpret `Vector(expand ElementTypes)` as the type of the whole sequence of
argument values, rather than as a generic description of the type of a single
argument. In other words, we have to interpret it as a pack type, and that means
`vectors` notionally binds to a run-time pack value.

Consequently, when `vectors` is used in the function body, it doesn't need an
`each` prefix: we've chosen to express variadicity in terms of types, and it
already has a pack type, so it can be directly used as an expansion site.

This approach has a few advantages:

-   We don't have to introduce the potentially-confusing concept of a binding
    that binds to multiple values simultaneously.
-   It avoids the anomaly where we have pack types in the type system, but no
    actual values of those types.
-   Removing the `each` keyword makes it more natural to spell `expand` as a
    symbolic token (earlier versions of this proposal used `[:]`), which is more
    concise and doesn't need surrounding whitespace.
-   For fully homogeneous variadics (such as `SumInts` and `Min`) it's actually
    possible to write the function body as an ordinary loop with no variadics,
    by expressing the signature in terms of a non-pack binding with an array
    type.

However, it also has some major disadvantages:

-   The implicit expansion of pack-type bindings hurts readability. For example,
    it's easy to overlook the fact that the loop condition
    `while (...and expand iters != vectors.End())` in `Zip` has two expansion
    sites, not just one. This problem is especially acute in cases where a
    non-local name has a pack type.
-   We have to forbid template-dependent names from having pack types (see
    [leads issue #1162](https://github.com/carbon-language/carbon-lang/issues/1162)),
    because the possibility that an expression might be an expansion site in
    some instantiations but not others would cause serious readability and
    implementability issues.
-   A given _use_ of such a binding really represents a single value at a time,
    in the same way that the iteration variable of a for-each loop does, so
    giving the binding a plural name and a pack type creates confusion in that
    context rather than alleviating it.
-   It may be confusing that a given expression might have either a pack type or
    a type pack, depending on whether it occurs in the type position of a
    binding pattern.

It's also worth noting that we may eventually want to introduce operations that
treat the sequence of bound values as a unit, such as to determine the length of
the sequence (like `sizeof...` in C++), or even to index into it. This approach
might seem more amenable to that, because it conceptually treats the sequence of
values as a value in itself, which could have its own operations. However, this
approach leaves no "room" in the syntax to spell those operations, because any
mention of a pack-type binding implicitly refers to one of its elements.

Conversely, the status quo proposal seems to leave a clear syntactic opening for
those operations: you can refer to the sequence as a whole by omitting `each`,
so `each vector.Size()` refers to the size of the current iteration's `vector`,
whereas `vector.Size()` could refer to the size of the sequence of bound values.
However, this could easily turn out to be a "wrong default": omitting `each`
seems easy to do by accident, and easy to misread during code review.

There are other solutions to this problem that work equally well with the status
quo or this alternative. In particular, it's already possible to express these
operations outside of a pack expansion by converting to a tuple, as in
`(... each vector).Size()` (status quo) or `(... vectors).Size()` (this
alternative). That may be sufficient to address those use cases, especially if
we relax the restrictions on nesting pack expansions. Failing that,
variadic-only spellings for these operations (like `sizeof...` in C++) would
also work with both approaches. So this issue does not seem like an important
differentiator between the two approaches.

#### Disallow pack-type bindings

As a variant of the above approach, it's possible to omit both `each` bindings
and pack-type bindings, and instead rely on variadic tuple-type bindings. For
example, the signature of `Zip` could instead be:

```carbon
fn Zip[ElementTypes:! [type;]]
      (... expand vectors: (... Vector(expand ElementTypes)))
      -> Vector((... expand ElementTypes));
```

This signature doesn't change the callsite semantics, but within the function
body `vectors` will be a tuple rather than a pack. This avoids or mitigates all
of the major disadvantages of pack-type bindings, but it comes at a substantial
cost: the function signature is substantially more complex and opaque. That
seems likely to be a bad tradeoff -- the disadvantages of pack-type bindings
mostly concern the function body, but readability of variadic function
signatures seems much more important than readability of variadic function
bodies, because the signatures will be read far more often, and by programmers
who have less familiarity with variadics.

This approach requires us to relax the ban on nested pack expansions, to allow
pack expansions within expansion sites. This does create some risk of confusion
about which pack expansion an expansion site belongs to, but probably much less
than if we allowed unrestricted nesting.

The leads chose not to pursue this approach in
[leads issue #1162](https://github.com/carbon-language/carbon-lang/issues/1162).

### Fold expressions

We could generalize the `...and`, and `...or` syntax to support a wider variety
of binary operators, and to permit specifying an initial value for the chain of
binary operators, as with C++'s
[fold expressions](https://en.cppreference.com/w/cpp/language/fold). This would
be more consistent with C++, and would give users more control over
associativity and over the behavior of the arity-zero case.

However, fold expressions are arguably too general in some respects: folding
over a non-commutative operator like `-` is more likely to be confusing than to
be useful. Similarly, there are few if any plausible use cases for customizing
the arity-zero behavior of `and` or `or`. Conversely, fold expressions are
arguably not general enough in other respects, because they only support folding
over a fixed set of operators, not over functions or compound expressions.

Furthermore, in order to support folds over operator tokens that can be either
binary or prefix-unary (such as `*`), we would need to choose a different syntax
for tuple element lists. Otherwise, `...*each foo` would be ambiguous between
`*foo[:0:], *foo[:1:],` etc. and `foo[:0:] * foo[:1:] *` etc.

Note that even if Carbon supported more general C++-like fold expressions, we
would still probably have to give `and` and `or` special-case treatment, because
they are short-circuiting.

As a point of comparison, C++ fold expressions give special-case treatment to
the same two operators, along with `,`: they are the only ones where the initial
value can be omitted (such as `... && args` rather than `true && ... && args`)
even if the pack may be empty. Furthermore, folding over `&&` appears to have
been the original motivation for adding fold expressions to C++; it's not clear
if there are important motivating use cases for the other operators.

Given that we are only supporting a minimal set of operators, allowing `...` to
occur in ordinary binary syntax has few advantages and several drawbacks:

-   It might conflict with a future general fold facility.
-   It would invite users to try other operators, and would probably give less
    clear errors if they do.
-   It would substantially complicate parsing and the AST.
-   It would force users to make a meaningless choice between `x or ...` and
    `... or x`, and likewise for `and`.

See also the discussion [below](#fold-like-syntax) of using `...,` and `...;` in
place of the tuple and statement forms of `...`. This is inspired by fold
expressions, but distinct from them, because `,` and `;` are not truly binary
operators, and it's targeting a different problem.

### Allow multiple pack expansions in a tuple pattern

As currently proposed, we allow multiple `...` expressions within a tuple
literal expression, but only allow one `...` pattern within a tuple pattern. It
is superficially tempting to relax this restriction, but fundamentally
infeasible.

Allowing multiple `...` patterns would create a potential for ambiguity about
where their scrutinees begin and end. For example, given a signature like
`fn F(... each xs: each i32, ... each ys: each i32)`, there is no way to tell
where `xs` ends and `ys` begins in the argument list; every choice is equally
valid. That ambiguity can be avoided if the types are different, but that would
make type _non_-equality a load-bearing part of the pattern. That's a very
unusual thing to need to reason about in the type system, so it's liable to be a
source of surprise and confusion for programmers, and in particular it looks
difficult if not impossible to usefully express with generic types, which would
greatly limit the usefulness of such a feature.

Function authors can straightforwardly work around this restriction by adding
delimiters. For example, the current design disallows
`fn F(... each xs: each i32, ... each ys: each i32)`, but it allows
`fn F((... each xs: each i32), (... each ys: each i32))`, which is not only
easier to support, but makes the callsite safer and more readable, since the
boundary between the `xs` and `ys` arguments is explicitly marked. By contrast,
if we disallowed multiple `...` expressions in a function argument list,
function callers who ran into that restriction would often find it difficult or
impossible to work around. Note, however, that this workaround presupposes that
function signatures can have bindings below top-level, which is
[currently undecided](https://github.com/carbon-language/carbon-lang/issues/1229).

To take a more abstract view of this situation: when we reuse expression syntax
as pattern syntax, we are effectively inverting expression evaluation, by asking
the language to find the operands that would cause an expression to evaluate to
a given value. That's only possible if the operations involved are invertible,
meaning that they do not lose information. When a tuple literal contains
multiple `...` expressions, evaluating it effectively discards structural
information about for example where `xs` ends and `ys` begins. The operation of
forming a tuple from multiple packs is not invertible, and consequently we
cannot use it as a pattern operation. Our rule effectively says that if the
function needs that structural information, it must ask the caller to provide
it, rather than asking the compiler to infer it.

### Allow nested pack expansions

Earlier versions of this design allowed pack expansions to contain other pack
expansions. This is in some ways a natural generalization, but it added
nontrivial complexity to the design. In particular, when an expansion site is
lexically within two or more pack expansions, we need a rule for determining
which pack expansion it's an expansion site of, in a way that is unsurprising
and supports the intended use cases. However, we have few if any motivating use
cases for it, which made it difficult to evaluate that aspect of the design.
Consequently, this proposal does not support nested pack expansions, although it
tries to avoid ruling them out as a future extension.

### Use postfix instead of prefix `...`

`...` is a postfix operator in C++, which aligns with the natural-language use
of "â€¦", so it would be more consistent with both if `...`, `...and`, and `...or`
were postfix operators spelled `...`, `and...`, and `or...`, and likewise if
statement pack expansions were marked by a `...` at the end rather than the
beginning.

However, prefix syntaxes are usually easier to parse (particularly for humans),
because they ensure that by the time you start parsing an utterance, you already
know the context in which it is used. This is clearest in the case of
statements: the reader might have to read an arbitrary amount of code in the
block before realizing that the code they've been reading will be executed
variadically, so that seems out of the question. The cases of `and`, `or`, and
`,` are less clear-cut, but we have chosen to make them all prefix operators for
consistency with statements.

### Avoid context-sensitity in pack expansions

This proposal "overloads" the `...` token with multiple different meanings
(including different precedences), and the meaning depends in part on the
surrounding context, despite Carbon's principle of
[avoiding context-sensitivity](/docs/project/principles/low_context_sensitivity.md).
We could instead represent the different meanings using separate syntaxes.

There are several variants of this approach, but they all have substantial
drawbacks (see the following subsections). Furthermore, the problems associated
with context-sensitivity appear to be fairly mild in this case: the difference
between a tuple literal context and a statement context is usually quite local,
and is usually so fundamental that confusion seems unlikely.

#### Fold-like syntax

We could use a modifier after `...` to select the expansion's meaning (as we
already do with `and` and `or`). In particular, we could write `...,` to
iteratively form elements of a tuple, and write `...;` to iteratively execute a
statement. This avoids context-sensitivity (apart from `...,` having a dual role
in expressions and patterns, like many other syntaxes), and has an underlying
unity: `...,`, `...;` `...and`, and `...or` represent "folds" over the `,`, `;`,
`and`, and `or` tokens, respectively. As a side benefit, this would preserve the
property that a tuple literal always contains a `,` character (unlike the
current proposal).

However, this approach has major readability problems. Using `...;` as a prefix
operator is completely at odds with the fact that `;` marks the end of a
statement, not the beginning. Furthermore, it would probably be surprising to
use `...;` in contexts where `;` is not needed, because the end of the statement
is marked with `}`.

The problems with `...,` are less severe, but still substantial. In this syntax
`,` does not behave like a separator, but our eyes are trained to read it as
one, and that habit is difficult to unlearn. For example, most readers have
found that they can't help automatically reading `(..., each x)` as having two
sub-expressions, `...` and `each x`. This effect is particularly disruptive when
skimming a larger body of code, such as:

```carbon
fn TupleConcat[..., each T1: type, ..., each T2: type](
    t1: (..., each T1), t2: (..., each T2)) -> (..., each T1, ..., each T2) {
  return (..., expand t1, ..., expand t2);
}
```

#### Variadic blocks

We could replace the statement form of `...` with a variadic block syntax such
as `...{ }`. However, this doesn't give us an alternative for the tuple form of
`...`, and yet heightens the problems with it: `...{` could read as as applying
the `...` operator to a struct literal.

Furthermore, it gives us no way to variadically declare a variable that's
visible outside the expansion (such as `each iter` in the `Zip` example). This
can be worked around by declaring those variables as tuples, but this adds
unnecessary complexity to the code.

#### Keyword syntax

We could drop `...` altogether, and use a separate keyword for each kind of pack
expansion. For example, we could use `repeat` for variadic lists of tuple
elements, `do_repeat` for variadic statements, and `all_of` and `any_of` in
place of `...and` and `...or`. This leads to code like:

```carbon
// Takes an arbitrary number of vectors with arbitrary element types, and
// returns a vector of tuples where the i'th element of the vector is
// a tuple of the i'th elements of the input vectors.
fn Zip[repeat each ElementType:! type]
      (repeat each vector: Vector(each ElementType))
      -> Vector((repeat each ElementType)) {
  do_repeat var each iter: auto = each vector.Begin();
  var result: Vector((repeat each ElementType));
  while (all_of each iter != each vector.End()) {
    result.push_back((repeat each iter));
    repeat each iter++;
  }
  return result;
}
```

This approach has some major advantages: the keywords are more consistent with
`each` (and `expand` to some extent), substantially less visually noisy than
`...`, and they may also be more self-explanatory. However, it does have some
substantial drawbacks.

Most notably, there is no longer any syntactic commonality between the different
tokens that mark the root of an expansion. That makes it harder to visually
identify expansions, and could also make variadics harder to learn, because the
spelling does not act as a mnemonic cue. And while it's already not ideal that
under the primary proposal a tuple literal is identified by the presence of
either `,` or `...`, it seems even worse if one of those two tokens is instead a
keyword.

Relatedly, the keywords have less clear precedence relationships, because
`all_of` and `any_of` can't as easily "borrow" their precedence from their
non-variadic counterparts. For example, consider this line from `Zip`:

```carbon
while (...and each iter != each vector.End()) {
```

Under this alternative, that becomes:

```carbon
while (all_of each iter != each vector.End()) {
```

I find the precedence relationships in the initial `all_of expand iters !=` more
opaque than in `...and expand iters !=`, to the extent that we might need to
require additional parentheses:

```carbon
  while (all_of (expand iters != each vectors.End())) {
```

That avoids outright ambiguity, but obliging readers to maintain a mental stack
of parentheses in order to parse the expression creates its own readability
problems.

It's appealing that the `repeat` keyword combines with `each` to produce code
that's almost readable as English, but it creates a temptation to read `expand`
the same way, which will usually be misleading. For example, `repeat expand foo`
sounds like it is repeatedly expanding `foo`, but in fact it expands it only
once. It's possible that a different spelling of `expand` could avoid that
problem, but I haven't been able to find one that does so while also avoiding
the potential for confusion with `each`. This is somewhat mitigated by the fact
that `expand` expressions are likely to be rare.

It's somewhat awkward, and potentially even confusing, to use an imperative word
like `repeat` in a pattern context. By design, the pattern language is
descriptive rather than imperative: it describes the values that match rather
than giving instructions for how to match them. As a result, in a pattern like
`(repeat each param: i64)`, it's not clear what action is being repeated.

Finally, it bears mentioning that the keywords occupy lexical space that could
otherwise be used for identifiers. Notably, `all_of`, `any_of`, and `repeat` are
all names of functions in the C++ standard library. This is not a fundamental
problem, because we expect Carbon to have some way of "quoting" a keyword for
use as an identifier (such as Rust's
[raw identifiers](https://doc.rust-lang.org/rust-by-example/compatibility/raw_identifiers.html)),
but it is likely to be a source of friction.

### Require parentheses around `each`

We could give `each` a lower precedence, so that expressions such as
`each vector.End()` would need to be written as `(each vector).End()`. This
could make the code clearer for readers, especially if they are new to Carbon
variadics. However, this would make the code visually busier, and might give the
misleading impression that `each` can be applied to anything other than an
identifier. I propose that we wait and see whether the unparenthesized syntax
has readability problems in practice, before attempting to solve those problems.

We have discussed a more general solution to this kind of problem, where a
prefix operator could be embedded in a `->` token, in order to apply the prefix
operator to the left-hand operand without needing parentheses. However, this
approach is much more appealing when the prefix operator is a symbolic token:
`x-?>y` may be a plausible alternative to `(?x).y`, but `x-each>y` seems much
harder to visually parse.

### Fused expansion tokens

Instead of treating `...and` and `...or` as two tokens with whitespace
discouraged between them, we could treat them as single tokens. This might more
accurately reflect the fact that they are semantically different operations than
`...`, and reduce the potential for readability problems in code that doesn't
follow our recommended whitespace conventions. However, that could lead to a
worse user experience if users accidentally insert a space after the `...`.

### Support merging parameters

This proposal adopts a rule that when matching a tuple value with a tuple
pattern, it must be possible to make the two have the same shape purely by
splitting variadic segments. This can have the effect of disallowing certain
generic function calls even though any possible monomorphization would be valid,
such as the call to `F` in this code:

```carbon
fn F[A:! I, ... each B:! I](a: A, ... each b: each B);

fn G[... each X:! I, Y:! I](... each x: each X, y: Y) {
  F(... each x, y);
}
```

Here the shapes are incompatible, and we cannot split any of the variadic
segments because they may all be empty. We could support such cases by
implicitly rewriting`F` to be:

```carbon
fn F[... each __Param:! I](... each(>=1) __param: each __Param) {
  let [A:! I, ... each B:! I](a: A, ... each b: each B) = (... each __param);
  // Body of F goes here
```

The general rule would be that we merge a singular parameter into an adjacent
variadic parameter in two cases:

-   The variadic parameter has a non-variadic declared type that is the same as
    the singular parameter's declared type.
-   The variadic parameter has a deduced variadic declared type, the singular
    parameter has a deduced declared type, both types have the same constraints,
    and the singular parameter's type is not used anywhere else in the function
    signature.

Such an approach would more closely approximate the ideal that definition
checking succeeds whenever all possible monomorphizations are valid. It would
also avoid the need for a minimum-arity constraint syntax, because such a
constraint could always be expressed by adding a suitable number of singular
parameters. Finally, it would simplify the function body by allowing the
function signature to express the destructuring that is very often needed in
such cases. For example, it would allow us to write `Min` like so:

```carbon
// Returns the minimum of its arguments, which must all have the same type T.
fn Min[T:! Comparable & Value](first: T, ... each next: T) -> T {
  var result: T = first;
  ... if (each next < result) {
    result = each next;
  }
  return result;
}
```

However, this approach would also have at least two major drawbacks. First of
all, by disallowing the size-constraint syntax, it forces all functions that
have a nonzero minimum arity to destructure the parameter list, even if
destructuring is unnecessary or even counterproductive. For example, consider a
function for computing the arithmetic mean. Under the current proposal it could
be written like this:

```carbon
fn Mean(... each(>=1) param: f32) -> f32 {
  return Sum(... each param)/(... each param).Size();
}
```

But with this alternative it would instead need to be:

```carbon
fn Mean(first: f32, ... each next: f32) -> f32 {
  return Sum(first, ... each next)/(1 + (... each param).Size());
}
```

Not only is this more awkward to read and write, the round-trip through the
destructured form could impose an unnecessary performance overhead.

The more important drawback of this approach is that it makes Carbon code harder
to understand (and predict), because the complex conditions governing the
rewrite mean that subtle differences in the code can cause dramatic differences
in the semantics. For example:

```carbon
fn F[A:! I, ... each B:! I](a: A, ... each b: each B);
fn G[A:! I, ... each B:! I](a: A, ... each b: each B) -> A;
```

Under this approach, `F` requires the caller to provide at least one singular
argument, whereas `G` requires the _first_ argument to be singular. It seems
likely to be hard to teach programmers that the function's return type sometimes
affects whether a given argument list is valid. Relatedly, it's hard to see how
a diagnostic could concisely explain why a given call to `G` is invalid, in a
way that doesn't seem to also apply to `F`.

By contrast, under the current proposal, both of those functions require the
first argument to be singular. If the author of `F` wants it to accept any
argument list that has at least one element, they must express that intent
explicitly in the signature:

```carbon
fn F[... each B:! I](... each(>=1) b: each B);
```

Neither approach allows the author to write `G` so that it has return type `A`
without requiring the first argument expression to be singular, but the current
approach makes that constraint self-evident: there's just no way to write code
that expresses both intents at the same time.
