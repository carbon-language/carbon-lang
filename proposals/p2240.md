# Variadics

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/2240)

<!-- toc -->

## Table of contents

-   [Abstract](#abstract)
-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
    -   [Examples](#examples)
-   [Details](#details)
-   [Rationale](#rationale)
-   [Alternatives considered](#alternatives-considered)
    -   [Decouple variadics from arrays](#decouple-variadics-from-arrays)
    -   [Other array type syntaxes](#other-array-type-syntaxes)
    -   [Fold expressions](#fold-expressions)
    -   [Allow multiple `...,` patterns in a tuple pattern](#allow-multiple--patterns-in-a-tuple-pattern)
    -   [Allow nested pack expansions](#allow-nested-pack-expansions)
    -   [Disallow named packs](#disallow-named-packs)
    -   [Use postfix instead of prefix operators](#use-postfix-instead-of-prefix-operators)

<!-- tocstop -->

## Abstract

Proposes a set of core features for declaring and implementing generic variadic
functions. The central concept is a "pack", which is a value that consists of a
sequence of other values. Almost all operations that can apply to single values
are generalized to apply to packs as well, by applying the operation to each
element of the pack. Packs are created from tuples or statically-sized arrays
using the `[:]` operator, and can be converted back to tuples with the `...,`
operator. Variadic blocks, delimited with `...{ }`, enable iterative computation
on packs. `[:]` and `...,` can also be used in patterns, which enables functions
to take an arbitrary number of arguments.

## Problem

Carbon needs a way to define functions and parameterized types that are
_variadic_, meaning they can take a variable number of arguments.

## Background

C has long supported variadic functions (such as `printf`), but that mechanism
is heavily disfavored in C++ because it isn't type-safe. Instead, C++ provides a
separate feature for defining variadic _templates_, which can be functions,
classes, or even variables. However, variadic templates currently suffer from
several shortcomings. Most notably:

-   They must be templates, which mean they typically must be defined in header
    files, are susceptible to code bloat due to template instantiation, and
    generally carry all the other costs associated with templating.
-   It is inordinately difficult to define a variadic function whose parameters
    have a fixed type, and the signature of such a function does not clearly
    communicate that fixed type to readers.
-   There is no procedural mechanism for iterating through a variadic parameter
    list. Although features like
    [fold expressions](https://en.cppreference.com/w/cpp/language/fold) cover
    some special cases, the only fully general way to express iteration is with
    recursion, which is often awkward, and results in more template
    instantiations.

There are a number of pending C++ standard proposals to address these issues,
and improve variadic templates in other ways, such as
[P1306R1: Expansion Statements](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1306r1.pdf),
[P1858R2: Generalized Pack Declaration and Usage](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1858r2.html),
and
[P2277R0: Packs Outside of Templates](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2277r0.html).
P1858R2 has been especially influential for this proposal.

## Proposal

`[T; N]` is the type of a statically-sized array of N objects of type `T`.
`[T;]` is a shorthand for the type of an array of objects of type `T`, whose
size is static but deduced. We will use `SizeType` as a placeholder name for the
type of the size of an array.

`...,`, `...and`, and `...or` are prefix unary expression operators with the
same precedence as the corresponding non-pack operators. `...{` is an opening
delimiter that forms a balanced pair with `}`, and can contain any number of
statements. An AST rooted at any of these operations is called a _pack
expansion_.

A pack expansion must contain one or more _expansion arguments_. The most common
form of expansion argument consists of the `[:]` operator followed by a tuple or
statically sized array, but an identifier expression that names a binding with a
pack type is also an expansion argument.

The value of each expansion argument is a _pack_, which is a sequence of values
much like a tuple. The _arity_ of an expansion argument is a compile-time value
representing the number of elements it evaluates to. All arguments of a given
pack expansion must have the same arity.

A pack expansion whose arguments have arity N is rewritten to N copies of the
pack expansion, where in the Kth copy, each expansion argument evaluates to the
Kth element of the pack. Each copy is followed by a separator, and the entire
sequence is followed by a terminator, as determined by the pack operator:

| Pack operator | Separator | Terminator |
| ------------- | --------- | ---------- |
| `...,`        | `,`       | (none)     |
| `...and`      | `and`     | `true`     |
| `...or`       | `or`      | `false`    |

As a consequence, a `...,` pack expansion can only occur where a tuple literal
element is expected, or directly inside parentheses, and in the latter case, the
parentheses form a tuple, even if the pack argument has only one element.

`...,` and `[:]` can also be used in patterns, with semantics chosen to follow
the general principle that pattern matching is the inverse of expression
evaluation.

> **Open question:** how should the pack argument operator be spelled? `[:]` is
> taken from the C++ proposal [P1858R2](http://wg21.link/P1858R2), but there is
> was motivated by a syntactic analogy with array indexing, which doesn't carry
> over to Carbon because it
> [needs to be a prefix operator](#use-postfix-instead-of-prefix-operators).
> `[:]` is also uncomfortably close to the `[T; N]` array type syntax, given
> that they will often be used in close proximity.

### Examples

```carbon
// Computes the sum of its arguments, which are i64s
fn SumInts(..., [:]params: [i64;]) -> i64 {
  var sum: i64 = 0;
  for (var i: i64 in params) {
    sum += i;
  }
  return sum;
}
```

```carbon
// Concatenates its arguments, which are all convertible to String
fn StrCat[T:! [ConvertibleToString;]](..., [:]params: T) -> String {
  var len: i64 = 0;
  ...{ len += ([:]params).Length(); }
  var result: String = "";
  result.Reserve(len);
  ...{ result.Append(([:]params).ToString()); }
  return result;
}
```

```carbon
// Returns the minimum of its arguments, which must all have the same type T.
//
// Note that this implementation is not recursive. We split the parameters into
// first and rest in order to forbid calling `Min` with no arguments.
fn Min[T:! Comparable & Value](first: T, ..., [:]rest: [T;]) -> T {
  var result: T = first;
  for (var x: T in rest) {
    if (x < result) {
      result = x;
    }
  }
  return result;
}
```

```carbon
// Invokes f, with the tuple `args` as its arguments.
fn Apply[T:! [type;], F:! CallableWith(..., [:]T)](f: F, args: (..., [:]T)) -> auto {
  return f(..., [:]args);
}
```

```carbon
fn Zip[ElementTypes:! [type;]]
      (..., vectors: Vector([:]ElementTypes))
      -> Vector((..., [:]ElementTypes)) {
  var iters: auto = (..., vectors.Begin());
  var result: Vector((..., [:]ElementTypes));
  while (...and [:]iters != vectors.End()) {
    result.push_back((..., *[:]iters));
    ...{ ([:]iters)++; }
  }
  return result;
}
```

```carbon
// Toy example of mixing packs and values in a single parameter list.
// Takes an i64, any number of f64s, and then another i64.
fn MiddleVariadic(first: i64, ..., [:]middles: [f64;], last: i64);
```

```carbon
// Toy example of using the result of variadic type deduction.
fn TupleConcat[T1s: [type;], T2s: [type;]](
    t1: (..., [:]T1s), t2: (..., [:]T2s)) -> (..., [:]T1s, ..., [:]T2s) {
  return (..., [:]t1, ..., [:]t2);
}
```

## Details

For full details, see `/docs/design/variadics.md` in this pull request.

## Rationale

Carbon needs variadics to effectively support
[interoperation with and migration from C++](/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code),
where variadic templates are fairly common. Variadics also make code
[easier to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write),
because some APIs (such as `printf`) can't be naturally expressed in terms of a
fixed number of parameters.

Furthermore, Carbon needs to support _generic_ variadics for the same reasons it
needs to support generic non-variadic functions: for example,
definition-checking makes APIs
[easier to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write),
and [easier to evolve](/docs/project/goals.md#software-and-language-evolution).
Furthermore, the language as a whole is easier to understand and write code in
if separate features like variadics and generics compose in natural ways, rather
than being mutually exclusive.

Variadics are also important for supporting
[performance-critical software](/docs/project/goals.md#performance-critical-software),
because variadic APIs can be more efficient than their non-variadic
counterparts. For example, `StrCat` is fundamentally more efficient than
something like a chain of `operator+` calls on `std::string`, because it does
not need to materialize a series of partial results, and it can pre-allocate a
buffer large enough for the final result.

This proposal deviates somewhat from the principle that
[all APIs are library APIs](/docs/project/principles/library_apis_only.md)
because it treats arrays, tuples, and packs as effectively built-in types. For
arrays, that's simply a matter of keeping this proposal focused; we expect
future proposals to give a library definition of array types.

Providing a library definition of tuples and packs is much more challenging. As
the document for this principle notes, tuples may be an exception to the
principle because it is very hard to see how we could define them as library
types without circularity. Packs have much the same problem, since a pack type
would itself have to be a variadic type. The need for both types to deeply
support symbolic computation adds some major challenges here as well. However,
if tuples could ever be a library type, it would certainly need to be defined
variadically, so in that sense this proposal may actually support that
principle.

## Alternatives considered

### Decouple variadics from arrays

Rather than support deduced parameters whose types are arrays of types, we could
introduce a custom syntax for deducing a tuple or pack type. For example,
instead of

```
fn StrCat[T:! [ConvertibleToString;]](..., [:]params: T) -> String
```

perhaps we could support

```
fn StrCat[T:...! ConvertibleToString](..., [:]params: T) -> String
```

This is more consistent with C++, somewhat less syntactically noisy, and avoids
constraining the design of arrays to support the needs of variadics. However, it
is less orthogonal, because it ties variadicity to one specific form of type
deduction. In particular, that means that it would not support _homogeneous_
variadics, such as the `SumInts()` and `Min()` examples, where all variadic
parameters have the same type.

### Other array type syntaxes

A number of alternatives to the `[T; N]` array type literal syntax were
considered:

`Array(T, N)` would avoid the need for new syntax, and more explicitly
consistent with the principle that
[all APIs are library APIs](/docs/project/principles/library_apis_only.md). It
would also be somewhat familiar to C++ programmers, because it parallels
`std::array<T, N>`. However, this proposal gives special treatment to this type
at the language level, so using ordinary parameterized-type syntax could be
confusing, and could give the incorrect impression that other user-defined
parameterized types could be used in this way.

`T[N]` would be more familiar to C++ programmers, but it doesn't work in Carbon
because that syntax already has another meaning: it indexes into the object
named `T`, with the subscript `N`. If `T` is a tuple type, that meaning might
even be valid. Even in C++, this syntax is only allowed in restricted contexts
(such as `typedef`) where the ordinary `[]` operator is not permitted.

`T[N]` is also very problematic under composition. For example, if we have
`a: T[100][2]`, the type would parse as `(T[100])[2]`, so `a` is a size-2 array
whose elements are size-100 arrays. This means that when indexing, the
subscripts are in the reverse of their declaration order: `x[1][50]` is valid,
but `x[50][1]` is an out of bounds error. C++ avoids this problem by giving
special treatment to contiguous sequences of square brackets in the type syntax,
which doesn't work in Carbon because we don't have separate syntaxes for types
and expressions.

`[T; N]` (our proposed syntax) is familiar to Rust programmers, but arguably has
the same problem: in a nested array declaration, the array bounds are in the
reverse of subscripting order, so given `x: [[T; 100]; 2]`, `x[1][50]` is valid,
but `x[50][1]` is out of bounds.

`[N]T` (as in Go) would avoid that problem, but would create ambiguity in
conjunction with postfix `*`: is `[N]T*` an array of pointers, or a pointer to
an array?

`[N; T]` avoids the subscript-order problem without that ambiguity, but it risks
being unfamiliar to nearly everyone: at least in C++-adjacent languages, there
is very little precedent for putting the array size before the element type.

We are proposing `[T; N]` because of its familiarity to Rust programmers, and
because the risk of subscript-order confusion is mitigated in several ways:

-   It does not present the dimensions as syntactically parallel to the indices
    in the way that `T[N]` does.
-   The syntactic nesting makes the semantic nesting explicit, which in turn
    gives a strong intuition about why subscripts have the order they do.

In addition, we expect Carbon to eventually support multidimensional arrays
natively, rather than as an accidental byproduct of nesting, using a syntax such
as `[T; M, N, O]`, with an indexing syntax like `x[i, j, k]` where the order of
the subscript tuple matches the order of the dimension tuple. This will further
mitigate the subscript order issue by discouraging use of nested arrays, except
in cases where nesting is a salient part of the design (in which case the
outside-in order of subscripts is substantially more intuitive).

### Fold expressions

Rather than special `...,`, `...and`, and `...or` tokens, we could support
something like C++'s
[fold expressions](https://en.cppreference.com/w/cpp/language/fold), where `...`
is a stand-alone token that can impart a variadic meaning to a variety of
expressions, including usages of most unary and binary operators. This would be
more consistent with C++, and would give users more control over associativity
and over the behavior of the arity-0 case.

However, fold expressions are arguably too general in some respects: folding
over a non-commutative operator like `-` is more likely to be confusing than to
be useful. Similarly, there are few if any plausible use cases for customizing
the arity-zero behavior of `and` or `or`. Conversely, fold expressions are
arguably not general enough in other respects, because they only support folding
over a fixed set of operators, not over functions or compound expressions.

All of that being the case, it seems preferable to start with a minimal set of
variadic operators, both to keep this proposal simple and to leave room for a
more general fold-like facility in the future. Our minimal set consists of
`...,` for variadic parameter lists, `...and` for variadic composition of
constraints (as well as use cases like in the body of `Zip`), and `...or` for
symmetry with `...and`.

Note that even if Carbon supported more general C++-like fold expressions, we
would still probably have to give these three operators special-case treatment,
because `,` is a component of the tuple syntax rather than a freestanding binary
operator, and `and` and `or` are short-circuiting.

As a point of comparison, C++ gives special-case treatment to the same three
operators in fold expressions: they are the only ones where the initial value
can be omitted (such as `... && args` rather than `true && ... && args`) even if
the pack may be empty. Furthermore, folding over `&&` appears to have been the
original motivation for adding fold expressions to C++, and of course folding
over `,` was the central use case for C++ variadics.

Given that we are only supporting a minimal set of operators, allowing `...` to
occur in ordinary binary syntax has few advantages and several drawbacks:

-   It might conflict with a future general fold facility.
-   It would invite users to try other operators, and would probably give less
    clear errors if they do.
-   It would substantially complicate parsing and the AST.
-   It would force users to make a meaningless choice between `... or x` and
    `... or y`, and likewise for `and`.

### Allow multiple `...,` patterns in a tuple pattern

As currently proposed, we allow multiple `...,` expressions within a tuple
literal expression, but only allow one `...,` pattern within a tuple pattern. It
is superficially tempting to relax this restriction, but fundamentally
infeasible.

Allowing multiple `...,` patterns would create a potential for ambiguity about
where their scrutinees begin and end. For example, given a signature like
`fn F(..., [:]xs: [i32;], ..., [:]ys: [i32;])`, there is no way to tell where
`xs` ends and `ys` begins in the argument list; every choice is equally valid.
That ambiguity can be avoided if the types are different, but that would make
type _non_-equality a load-bearing part of the pattern. That's a very unusual
thing to need to reason about in the type system, so it's liable to be a source
of surprise and confusion for programmers, and in particular it looks difficult
if not impossible to usefully express with generic types, which would greatly
limit the usefulness of such a feature.

Furthermore, our solution to the problem of combinatorial explosion in tuple
pattern matching deeply relies on the fact that there is at most one `...,`
subpattern in the tuple pattern. Without that constraint, it's not at all clear
if we could type-check variadic pattern matches in polynomial time.

Finally, function authors can straightforwardly work around this restriction by
adding delimiters. For example, the current design disallows
`fn F(..., [:]xs: [i32;], ..., [:]ys: [i32;])`, but it allows
`fn F((..., [:]xs: [i32;]), (..., [:]ys: [i32;]))`, which is not only easier to
support, but makes the callsite safer and more readable, since the boundary
between the `xs` and `ys` arguments is explicitly marked. By contrast, if we
disallowed multiple `...,` expressions in a function argument list, function
callers who ran into that restriction would often find it difficult or
impossible to work around.

To take a more abstract view of this situation: when we reuse expression syntax
as pattern syntax, we are effectively inverting expression evaluation, by asking
the language to find the operands that would cause an expression to evaluate to
a given value. That's only possible if the operations involved are invertible,
meaning that they do not lose information. When a tuple literal contains
multiple `...,` expressions, evaluating it effectively discards structural
information about for example where `xs` ends and `ys` begins. The operation of
forming a tuple from multiple packs is not invertible, and consequently we
cannot use it as a pattern operation. Our rule effectively says that if the
function needs that structural information, it must ask the caller to provide
it, rather than asking the compiler to infer it.

### Allow nested pack expansions

Earlier versions of this design allowed pack expansions to contain other pack
expansions. This is in some ways a natural generalization, but it added
nontrivial complexity to the design. More importantly, we have few if any
motivating use cases for it, which made it difficult to evaluate that aspect of
the design. Consequently, this proposal does not support nested pack expansions,
although it tries to avoid ruling them out as a future extension.

### Disallow named packs

This proposal allows user code to declare bindings that have pack types, but
only if they are function-local. That restriction can be loosened somewhat, but
probably not removed altogether. In particular, it seems critical for both
readability and implementability that it is locally syntactically obvious
whether a given name refers to a pack, which rules out things like pack-type
data members.

Even with the existing restrictions, named packs may create readability
problems. Consider this example from earlier:

```carbon
fn Zip[ElementTypes:! [type;]]
      (..., vectors: Vector([:]ElementTypes))
      -> Vector((..., [:]ElementTypes)) {
  var iters: auto = (..., vectors.Begin());
  var result: Vector((..., [:]ElementTypes));
  while (...and [:]iters != vectors.End()) {
    result.push_back((..., *[:]iters));
    ...{ ([:]iters)++; }
  }
  return result;
}
```

It may not be obvious to the reader that the `...and` expression has two
expansion arguments, because only one of them is syntactically marked within the
expression.

One solution to these problems would be to disallow named packs, requiring user
code to convert packs to/from tuples when they need to be given names. For
example, with this approach, the signature of `Zip` would instead have to be:

```carbon
fn Zip[ElementTypes:! [Type;]]
      (..., [:]vectors: (..., Vector([:]ElementTypes)))
      -> Vector((..., [:]ElementTypes))
```

With this signature, `vectors` is bound to a tuple rather than a pack, but in
order to do that we need to create a tuple for it to bind to, which makes the
signature more complex.

This approach would probably make variadic function bodies more readable, at the
cost of making variadic function signatures more complex, both to read and to
write. That seems likely to be a bad tradeoff -- readability of variadic
function signatures seems much more important than readability of variadic
function bodies, because the signatures will be read far more often, and by
programmers who have less familiarity with variadics.

This decision was made in
[leads issue #1162](https://github.com/carbon-language/carbon-lang/issues/1162).

### Use postfix instead of prefix operators

`...` is a postfix operator in C++, and `[:]` is a postfix operator in C++
proposal P1858R2. Furthermore, in both cases postfix position is arguably more
natural: postfix `...` aligns with the natural-language usage of "â€¦", and
postfix `[:]` aligns with C++'s (and Carbon's) subscripting syntax. So in some
ways it would be very desirable to make their Carbon counterparts postfix as
well. Notably, it would let us describe variadic evaluation very cleanly in
terms of replacing `[:]` with `[$I]`. However, this turns out to be an awkward
fit for Carbon. Consider this example:

```
fn SumInts(..., [:]params: [i64;]) -> i64
```

If `[:]` and `...,` were suffix operators, this would instead be:

```
fn SumInts(params: [i64;][:] ...,) -> i64
```

But this is ambiguous about whether the `[:]` operator applies to
`params: [i64;]` or just `[i64;]`, so we need to add a set of parentheses:

```
fn SumInts((params: [i64;])[:] ...,) -> i64
```

To state the point more generally: when an expression mixes prefix and suffix
operators, their order is determined by precedence and parentheses, which is
usually less readable than relying on the linear order of operators with the
same fixity. The binding operator `:` is effectively a prefix operator (because
its left-hand side is a single token), so if `[:]` is a suffix operator, code
that mixes the two will be somewhat harder to read. That's a particular problem
because, as our motivating examples illustrate, variadic function signatures
will often have those two operators in close conjunction, and readability is at
a premium in function signatures.

C solved a very similar problem with mixing prefix `*` and postfix `.` by
introducing a separate `->` operator. We could in principle solve this issue the
same way, introducing a separate "variadic binding operator" `$`, such that
`params$ [i64;]` is equivalent to `(params: [i64;])[:]`. However, this would
trade a readability problem for a teachability problem, by introducing more
syntax that programmers need to learn before they can even read variadic
function signatures.
