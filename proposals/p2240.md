# Variadics

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/2240)

<!-- toc -->

## Table of contents

-   [Abstract](#abstract)
-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
    -   [Examples](#examples)
-   [Details](#details)
-   [Rationale](#rationale)
-   [Alternatives considered](#alternatives-considered)
    -   [Decouple variadics from arrays](#decouple-variadics-from-arrays)
    -   [Other array type syntaxes](#other-array-type-syntaxes)
    -   [Fold expressions](#fold-expressions)
    -   [Allow multiple `...,` patterns in a tuple pattern](#allow-multiple--patterns-in-a-tuple-pattern)
    -   [Allow nested pack expansions](#allow-nested-pack-expansions)
    -   [Disallow named packs](#disallow-named-packs)
    -   [Use postfix instead of prefix operators](#use-postfix-instead-of-prefix-operators)
    -   [Run-time pack values](#run-time-pack-values)
    -   [Keyword syntax](#keyword-syntax)
        -   [Rationale](#rationale-1)
        -   [Discussion](#discussion)

<!-- tocstop -->

FIXME update this doc to reflect new `each` model.

FIXME alternate syntaxes for `[:]`, `...,`, etc.

FIXME: make it easier to declare `iters` as an `each` binding?

FIXME: should we allow `each foo.bar` instead of `(each foo).bar`?

## Abstract

Proposes a set of core features for declaring and implementing generic variadic
functions. The central concept is a "pack", which is a value that consists of a
sequence of other values. Almost all operations that can apply to single values
are generalized to apply to packs as well, by applying the operation to each
element of the pack. Packs are created from tuples or statically-sized arrays
using the `[:]` operator, and can be converted back to tuples with the `...,`
operator. Variadic blocks, delimited with `...{ }`, enable iterative computation
on packs. `[:]` and `...,` can also be used in patterns, which enables functions
to take an arbitrary number of arguments.

## Problem

Carbon needs a way to define functions and parameterized types that are
_variadic_, meaning they can take a variable number of arguments.

## Background

C has long supported variadic functions (such as `printf`), but that mechanism
is heavily disfavored in C++ because it isn't type-safe. Instead, C++ provides a
separate feature for defining variadic _templates_, which can be functions,
classes, or even variables. However, variadic templates currently suffer from
several shortcomings. Most notably:

-   They must be templates, which mean they typically must be defined in header
    files, are susceptible to code bloat due to template instantiation, and
    generally carry all the other costs associated with templating.
-   It is inordinately difficult to define a variadic function whose parameters
    have a fixed type, and the signature of such a function does not clearly
    communicate that fixed type to readers.
-   There is no procedural mechanism for iterating through a variadic parameter
    list. Although features like
    [fold expressions](https://en.cppreference.com/w/cpp/language/fold) cover
    some special cases, the only fully general way to express iteration is with
    recursion, which is often awkward, results in more template instantiations,
    and typically has at least quadratic overhead in the size of the pack (at
    compile time, and sometimes at run time).

There are a number of pending C++ standard proposals to address these issues,
and improve variadic templates in other ways, such as
[P1306R1: Expansion Statements](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1306r1.pdf),
[P1858R2: Generalized Pack Declaration and Usage](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1858r2.html),
and
[P2277R0: Packs Outside of Templates](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2277r0.html).
P1858R2 has been especially influential for this proposal.

Swift has very recently adopted a
[proposal](https://github.com/apple/swift-evolution/blob/main/proposals/0393-parameter-packs.md)
to support _definition-checked_ generic variadics. There have been several
attempts to add such a feature to Rust, but that work is
[currently inactive](https://github.com/rust-lang/rfcs/issues/376#issuecomment-830034029).

## Proposal

`[T; N]` is the type of a statically-sized array of N objects of type `T`.
`[T;]` is a shorthand for the type of an array of objects of type `T`, whose
size is static but deduced. We will use `SizeType` as a placeholder name for the
type of the size of an array. Values of type `[T; N]` are implicitly convertible
to and from a tuple type consisting of `N` repetitions of `T`.

`...,`, `...and`, and `...or` are prefix unary expression operators with the
same precedence as the corresponding non-pack operators. `...{` is an opening
delimiter that forms a balanced pair with `}`, and can contain any number of
statements. An AST rooted at any of these operations is called a _pack
expansion_.

A pack expansion must contain one or more _expansion arguments_. The most common
form of expansion argument consists of the `[:]` operator followed by a tuple or
statically sized array, but an identifier expression that names a binding with a
pack type is also an expansion argument.

The value of each expansion argument is a _pack_, which is a sequence of values
much like a tuple. The _arity_ of an expansion argument is a compile-time value
representing the number of elements it evaluates to. All arguments of a given
pack expansion must have the same arity.

A pack expansion whose arguments have arity N is rewritten to N copies of the
pack expansion, where in the Kth copy, each expansion argument evaluates to the
Kth element of the pack. Each copy is followed by a separator, and the entire
sequence is followed by a terminator, as determined by the pack operator:

| Pack operator | Separator | Terminator |
| ------------- | --------- | ---------- |
| `...,`        | `,`       | (none)     |
| `...and`      | `and`     | `true`     |
| `...or`       | `or`      | `false`    |

As a consequence, a `...,` pack expansion can only occur where a tuple literal
element is expected, or directly inside parentheses, and in the latter case, the
parentheses form a tuple, even if the pack argument has only one element.

`...,` and `[:]` can also be used in patterns, with semantics chosen to follow
the general principle that pattern matching is the inverse of expression
evaluation.

> **Open question:** how should the pack argument operator be spelled? `[:]` is
> taken from the C++ proposal [P1858R2](http://wg21.link/P1858R2), but there it
> was motivated by a syntactic analogy with array indexing, which doesn't carry
> over to Carbon because it
> [needs to be a prefix operator](#use-postfix-instead-of-prefix-operators).
> `[:]` is also uncomfortably close to the `[T; N]` array type syntax, given
> that they will often be used in close proximity.

### Examples

```carbon
// Computes the sum of its arguments, which are i64s
fn SumInts(..., each param: i64) -> i64 {
  var sum: i64 = 0;
  ...{
    sum += each param;
  }
  return sum;
}
```

```carbon
// Concatenates its arguments, which are all convertible to String
fn StrCat[each T:! ConvertibleToString](..., each param: each T) -> String {
  var len: i64 = 0;
  ...{ len += each param.Length(); }
  var result: String = "";
  result.Reserve(len);
  ...{ result.Append(each param.ToString()); }
  return result;
}
```

```carbon
// Returns the minimum of its arguments, which must all have the same type T.
//
// Note that this implementation is not recursive. We split the parameters into
// first and rest in order to forbid calling `Min` with no arguments.
fn Min[T:! Comparable & Value](first: T, ..., each next: T) -> T {
  var result: T = first;
  ...{
    if (each next < result) {
      result = next;
    }
  }
  return result;
}
```

```carbon
// Invokes f, with the tuple `args` as its arguments.
fn Apply[each T:! type, F:! CallableWith(..., each T)](f: F, args: (..., each T)) -> auto {
  return f(..., [:]args);
}
```

```carbon
// Takes an arbitrary number of vectors with arbitrary element types, and
// returns a vector of tuples where the i'th element of the vector is
// a tuple of the i'th elements of the input vectors.
fn Zip[each ElementType:! type]
      (..., each vector: Vector(each ElementType))
      -> Vector((..., each ElementType)) {
  var iters: auto = (..., (each vector).Begin());
  var result: Vector((..., each ElementType));
  while (...and [:]iters != (each vector).End()) {
    result.push_back((..., *[:]iters));
    ...{ ([:]iters)++; }
  }
  return result;
}
```

```carbon
// Toy example of mixing packs and values in a single parameter list.
// Takes an i64, any number of f64s, and then another i64.
fn MiddleVariadic(first: i64, ..., each middle: f64, last: i64);
```

```carbon
// Toy example of using the result of variadic type deduction.
fn TupleConcat[each T1: type, each T2: type](
    t1: (..., each T1), t2: (..., each T2)) -> (..., each T1, ..., each T2) {
  return (..., [:]t1, ..., [:]t2);
}
```

## Details

For full details, see `/docs/design/variadics.md` in this pull request.

## Rationale

Carbon needs variadics to effectively support
[interoperation with and migration from C++](/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code),
where variadic templates are fairly common. Variadics also make code
[easier to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write),
because some APIs (such as `printf`) can't be naturally expressed in terms of a
fixed number of parameters.

Furthermore, Carbon needs to support _generic_ variadics for the same reasons it
needs to support generic non-variadic functions: for example,
definition-checking makes APIs
[easier to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write),
and [easier to evolve](/docs/project/goals.md#software-and-language-evolution).
Furthermore, the language as a whole is easier to understand and write code in
if separate features like variadics and generics compose in natural ways, rather
than being mutually exclusive.

Variadics are also important for supporting
[performance-critical software](/docs/project/goals.md#performance-critical-software),
because variadic APIs can be more efficient than their non-variadic
counterparts. For example, `StrCat` is fundamentally more efficient than
something like a chain of `operator+` calls on `std::string`, because it does
not need to materialize a series of partial results, and it can pre-allocate a
buffer large enough for the final result.

This proposal deviates somewhat from the principle that
[all APIs are library APIs](/docs/project/principles/library_apis_only.md)
because it treats arrays, tuples, and packs as effectively built-in types. For
arrays, that's simply a matter of keeping this proposal focused; we expect
future proposals to give a library definition of array types.

Providing a library definition of tuples and packs is much more challenging. As
the document for this principle notes, tuples may be an exception to the
principle because it is very hard to see how we could define them as library
types without circularity. Packs have much the same problem, since a pack type
would itself have to be a variadic type. The need for both types to deeply
support symbolic computation adds some major challenges here as well. However,
if tuples could ever be a library type, it would certainly need to be defined
variadically, so in that sense this proposal may actually support that
principle.

## Alternatives considered

### Decouple variadics from arrays

Rather than support deduced parameters whose types are arrays of types, we could
introduce a custom syntax for deducing a tuple or pack type. For example,
instead of

```
fn StrCat[T:! [ConvertibleToString;]](..., [:]params: T) -> String
```

perhaps we could support

```
fn StrCat[T:...! ConvertibleToString](..., [:]params: T) -> String
```

This is more consistent with C++, somewhat less syntactically noisy, and avoids
constraining the design of arrays to support the needs of variadics. However, it
is less orthogonal, because it ties variadicity to one specific form of type
deduction. In particular, that means that it would not support _homogeneous_
variadics, such as the `SumInts()` and `Min()` examples, where all variadic
parameters have the same type.

### Other array type syntaxes

A number of alternatives to the `[T; N]` array type literal syntax were
considered:

`Array(T, N)` would avoid the need for new syntax, and more explicitly
consistent with the principle that
[all APIs are library APIs](/docs/project/principles/library_apis_only.md). It
would also be somewhat familiar to C++ programmers, because it parallels
`std::array<T, N>`. However, this proposal gives special treatment to this type
at the language level, so using ordinary parameterized-type syntax could be
confusing, and could give the incorrect impression that other user-defined
parameterized types could be used in this way.

`T[N]` would be more familiar to C++ programmers, but it doesn't work in Carbon
because that syntax already has another meaning: it indexes into the object
named `T`, with the subscript `N`. If `T` is a tuple type, that meaning might
even be valid. Even in C++, this syntax is only allowed in restricted contexts
(such as `typedef`) where the ordinary `[]` operator is not permitted.

`T[N]` is also very problematic under composition. For example, if we have
`a: T[100][2]`, the type would parse as `(T[100])[2]`, so `a` is a size-2 array
whose elements are size-100 arrays. This means that when indexing, the
subscripts are in the reverse of their declaration order: `x[1][50]` is valid,
but `x[50][1]` is an out of bounds error. C++ avoids this problem by giving
special treatment to contiguous sequences of square brackets in the type syntax,
which doesn't work in Carbon because we don't have separate syntaxes for types
and expressions.

`[T; N]` (our proposed syntax) is familiar to Rust programmers, but arguably has
the same problem: in a nested array declaration, the array bounds are in the
reverse of subscripting order, so given `x: [[T; 100]; 2]`, `x[1][50]` is valid,
but `x[50][1]` is out of bounds.

`[N]T` (as in Go) would avoid that problem, but would create ambiguity in
conjunction with postfix `*`: is `[N]T*` an array of pointers, or a pointer to
an array?

`[N; T]` avoids the subscript-order problem without that ambiguity, but it risks
being unfamiliar to nearly everyone: at least in C++-adjacent languages, there
is very little precedent for putting the array size before the element type.

We are proposing `[T; N]` because of its familiarity to Rust programmers, and
because the risk of subscript-order confusion is mitigated in several ways:

-   It does not present the dimensions as syntactically parallel to the indices
    in the way that `T[N]` does.
-   The syntactic nesting makes the semantic nesting explicit, which in turn
    gives a strong intuition about why subscripts have the order they do.

In addition, we expect Carbon to eventually support multidimensional arrays
natively, rather than as an accidental byproduct of nesting, using a syntax such
as `[T; M, N, O]`, with an indexing syntax like `x[i, j, k]` where the order of
the subscript tuple matches the order of the dimension tuple. This will further
mitigate the subscript order issue by discouraging use of nested arrays, except
in cases where nesting is a salient part of the design (in which case the
outside-in order of subscripts is substantially more intuitive).

### Fold expressions

Rather than special `...,`, `...and`, and `...or` tokens, we could support
something like C++'s
[fold expressions](https://en.cppreference.com/w/cpp/language/fold), where `...`
is a stand-alone token that can impart a variadic meaning to a variety of
expressions, including usages of most unary and binary operators. This would be
more consistent with C++, and would give users more control over associativity
and over the behavior of the arity-0 case.

However, fold expressions are arguably too general in some respects: folding
over a non-commutative operator like `-` is more likely to be confusing than to
be useful. Similarly, there are few if any plausible use cases for customizing
the arity-zero behavior of `and` or `or`. Conversely, fold expressions are
arguably not general enough in other respects, because they only support folding
over a fixed set of operators, not over functions or compound expressions.

All of that being the case, it seems preferable to start with a minimal set of
variadic operators, both to keep this proposal simple and to leave room for a
more general fold-like facility in the future. Our minimal set consists of
`...,` for variadic parameter lists, `...and` for variadic composition of
constraints (as well as use cases like in the body of `Zip`), and `...or` for
symmetry with `...and`.

Note that even if Carbon supported more general C++-like fold expressions, we
would still probably have to give these three operators special-case treatment,
because `,` is a component of the tuple syntax rather than a freestanding binary
operator, and `and` and `or` are short-circuiting.

As a point of comparison, C++ gives special-case treatment to the same three
operators in fold expressions: they are the only ones where the initial value
can be omitted (such as `... && args` rather than `true && ... && args`) even if
the pack may be empty. Furthermore, folding over `&&` appears to have been the
original motivation for adding fold expressions to C++, and of course folding
over `,` was the central use case for C++ variadics.

Given that we are only supporting a minimal set of operators, allowing `...` to
occur in ordinary binary syntax has few advantages and several drawbacks:

-   It might conflict with a future general fold facility.
-   It would invite users to try other operators, and would probably give less
    clear errors if they do.
-   It would substantially complicate parsing and the AST.
-   It would force users to make a meaningless choice between `x or ...` and
    `... or x`, and likewise for `and`.

### Allow multiple `...,` patterns in a tuple pattern

As currently proposed, we allow multiple `...,` expressions within a tuple
literal expression, but only allow one `...,` pattern within a tuple pattern. It
is superficially tempting to relax this restriction, but fundamentally
infeasible.

Allowing multiple `...,` patterns would create a potential for ambiguity about
where their scrutinees begin and end. For example, given a signature like
`fn F(..., [:]xs: [i32;], ..., [:]ys: [i32;])`, there is no way to tell where
`xs` ends and `ys` begins in the argument list; every choice is equally valid.
That ambiguity can be avoided if the types are different, but that would make
type _non_-equality a load-bearing part of the pattern. That's a very unusual
thing to need to reason about in the type system, so it's liable to be a source
of surprise and confusion for programmers, and in particular it looks difficult
if not impossible to usefully express with generic types, which would greatly
limit the usefulness of such a feature.

Furthermore, our solution to the problem of combinatorial explosion in tuple
pattern matching deeply relies on the fact that there is at most one `...,`
subpattern in the tuple pattern. Without that constraint, it's not at all clear
if we could type-check variadic pattern matches in polynomial time.

Finally, function authors can straightforwardly work around this restriction by
adding delimiters. For example, the current design disallows
`fn F(..., [:]xs: [i32;], ..., [:]ys: [i32;])`, but it allows
`fn F((..., [:]xs: [i32;]), (..., [:]ys: [i32;]))`, which is not only easier to
support, but makes the callsite safer and more readable, since the boundary
between the `xs` and `ys` arguments is explicitly marked. By contrast, if we
disallowed multiple `...,` expressions in a function argument list, function
callers who ran into that restriction would often find it difficult or
impossible to work around.

To take a more abstract view of this situation: when we reuse expression syntax
as pattern syntax, we are effectively inverting expression evaluation, by asking
the language to find the operands that would cause an expression to evaluate to
a given value. That's only possible if the operations involved are invertible,
meaning that they do not lose information. When a tuple literal contains
multiple `...,` expressions, evaluating it effectively discards structural
information about for example where `xs` ends and `ys` begins. The operation of
forming a tuple from multiple packs is not invertible, and consequently we
cannot use it as a pattern operation. Our rule effectively says that if the
function needs that structural information, it must ask the caller to provide
it, rather than asking the compiler to infer it.

### Allow nested pack expansions

Earlier versions of this design allowed pack expansions to contain other pack
expansions. This is in some ways a natural generalization, but it added
nontrivial complexity to the design. More importantly, we have few if any
motivating use cases for it, which made it difficult to evaluate that aspect of
the design. Consequently, this proposal does not support nested pack expansions,
although it tries to avoid ruling them out as a future extension.

### Disallow named packs

This proposal allows user code to declare bindings that have pack types, but
only if they are function-local. That restriction can be loosened somewhat, but
probably not removed altogether. In particular, it seems critical for both
readability and implementability that it is locally syntactically obvious
whether a given name refers to a pack, which rules out things like pack-type
data members.

Even with the existing restrictions, named packs may create readability
problems. Consider this example from earlier:

```carbon
fn Zip[ElementTypes:! [type;]]
      (..., vectors: Vector([:]ElementTypes))
      -> Vector((..., [:]ElementTypes)) {
  var iters: auto = (..., vectors.Begin());
  var result: Vector((..., [:]ElementTypes));
  while (...and [:]iters != vectors.End()) {
    result.push_back((..., *[:]iters));
    ...{ ([:]iters)++; }
  }
  return result;
}
```

It may not be obvious to the reader that the `...and` expression has two
expansion arguments, because only one of them is syntactically marked within the
expression.

One solution to these problems would be to disallow named packs, requiring user
code to convert packs to/from tuples when they need to be given names. For
example, with this approach, the signature of `Zip` would instead have to be:

```carbon
fn Zip[ElementTypes:! [Type;]]
      (..., [:]vectors: (..., Vector([:]ElementTypes)))
      -> Vector((..., [:]ElementTypes))
```

With this signature, `vectors` is bound to a tuple rather than a pack, but in
order to do that we need to create a tuple for it to bind to, which makes the
signature more complex.

This approach would probably make variadic function bodies more readable, at the
cost of making variadic function signatures more complex, both to read and to
write. That seems likely to be a bad tradeoff -- readability of variadic
function signatures seems much more important than readability of variadic
function bodies, because the signatures will be read far more often, and by
programmers who have less familiarity with variadics.

This decision was made in
[leads issue #1162](https://github.com/carbon-language/carbon-lang/issues/1162).

### Use postfix instead of prefix operators

`...` is a postfix operator in C++, and `[:]` is a postfix operator in C++
proposal P1858R2. Furthermore, in both cases postfix position is arguably more
natural: postfix `...` aligns with the natural-language usage of "â€¦", and
postfix `[:]` aligns with C++'s (and Carbon's) subscripting syntax. So in some
ways it would be very desirable to make their Carbon counterparts postfix as
well. Notably, it would let us describe variadic evaluation very cleanly in
terms of replacing `[:]` with `[$I]`. However, this turns out to be an awkward
fit for Carbon. Consider this example:

```
fn SumInts(..., [:]params: [i64;]) -> i64
```

If `[:]` and `...,` were suffix operators, this would instead be:

```
fn SumInts(params: [i64;][:] ...,) -> i64
```

But this is ambiguous about whether the `[:]` operator applies to
`params: [i64;]` or just `[i64;]`, so we need to add a set of parentheses:

```
fn SumInts((params: [i64;])[:] ...,) -> i64
```

To state the point more generally: when an expression mixes prefix and suffix
operators, their order is determined by precedence and parentheses, which is
usually less readable than relying on the linear order of operators with the
same fixity. The binding operator `:` is effectively a prefix operator (because
its left-hand side is a single token), so if `[:]` is a suffix operator, code
that mixes the two will be somewhat harder to read. That's a particular problem
because, as our motivating examples illustrate, variadic function signatures
will often have those two operators in close conjunction, and readability is at
a premium in function signatures.

C solved a very similar problem with mixing prefix `*` and postfix `.` by
introducing a separate `->` operator. We could in principle solve this issue the
same way, introducing a separate "variadic binding operator" `$`, such that
`params$ [i64;]` is equivalent to `(params: [i64;])[:]`. However, this would
trade a readability problem for a teachability problem, by introducing more
syntax that programmers need to learn before they can even read variadic
function signatures.

### Run-time pack values

An earlier version of this proposal modeled the run-time semantics of expansions
in terms of run-time pack values, rather than in terms of a notional iteration
over the expansion arguments. This approach makes the run-time semantics more
obviously consistent with the type-checking rules, since pack types are just the
types of pack values. However, this model has unwelcome consequences when
expressions can include control flow. For example, consider this tuple
expression:

```carbon
(..., if ([:]cond) then F([:]param) else G([:]param))
```

This model would imply that `F` and `G` are each called N times, in order to
form the pack values of the expressions `F([:]param)` and `G([:]param)`, and
then the results of half of those calls are discarded when the `if` is
evaluated. By contrast, the iterative model implies that each of the N
iterations calls `F` or `G` but not both: the calls whose results would be
discarded are never evaluated in the first place. Thus, the iterative model is
both more efficient and more consistent with the corresponding non-variadic
semantics.

### Keyword syntax

> **TODO:** Decide whether to make this the primary proposal, and restructure
> the discussion as appropriate.

We could build the syntax around keywords rather than symbolic tokens, much like
the
[Swift proposal](https://github.com/apple/swift-evolution/blob/main/proposals/0393-parameter-packs.md).
For concreteness, the keywords I will discuss here are as follows:

| Symbolic token | Keyword replacement               |
| -------------- | --------------------------------- |
| `[:]`          | `expand`                          |
| `...,`         | `repeat` and `unpack` (see below) |
| `...and`       | `all_of`                          |
| `...or`        | `any_of`                          |
| `...{`         | `repeat {`                        |

This approach seems to work best in combination with some other nominally
independent changes:

-   Forbid `expand` in pattern contexts.
-   Allow `repeat` only in expression contexts and `unpack` only in pattern
    contexts.
-   Require any usage of a pack-type variable to be prefixed with a new keyword
    `each`.

With these changes, the examples given earlier would read as follows:

```carbon
// Computes the sum of its arguments, which are i64s
fn SumInts(unpack params: expand [i64;]) -> i64 {
  var sum: i64 = 0;
  repeat {
    sum += each params;
  }
  return sum;
}
```

```carbon
// Concatenates its arguments, which are all convertible to String
fn StrCat[T:! [ConvertibleToString;]](unpack params: expand T) -> String {
  var len: i64 = 0;
  repeat { len += (each params).Length(); }
  var result: String = "";
  result.Reserve(len);
  repeat { result.Append((each params).ToString()); }
  return result;
}
```

```carbon
// Returns the minimum of its arguments, which must all have the same type T.
//
// Note that this implementation is not recursive. We split the parameters into
// first and rest in order to forbid calling `Min` with no arguments.
fn Min[T:! Comparable & Value](first: T, unpack rest: expand [T;]) -> T {
  var result: T = first;
  repeat {
    if (each rest < result) {
      result = each rest;
    }
  }
  return result;
}
```

```carbon
// Invokes f, with the tuple `args` as its arguments.
fn Apply[T:! [type;], F:! CallableWith(repeat expand T)]
        (f: F, args: (repeat expand T)) -> auto {
  return f(repeat expand args);
}
```

```carbon
// Takes an arbitrary number of vectors with arbitrary element types, and
// returns a vector of tuples where the i'th element of the vector is
// a tuple of the i'th elements of the input vectors.
fn Zip[ElementTypes:! [type;]]
      (unpack vectors: Vector(expand ElementTypes))
      -> Vector((repeat expand ElementTypes)) {
  var iters: auto = (repeat (each vectors).Begin());
  var result: Vector((repeat expand ElementTypes));
  while (all_of expand iters != (each vectors).End()) {
    result.push_back((repeat *expand iters));
    repeat { (expand iters)++; }
  }
  return result;
}
```

```carbon
// Toy example of mixing packs and values in a single parameter list.
// Takes an i64, any number of f64s, and then another i64.
fn MiddleVariadic(first: i64, unpack middles: expand [f64;], last: i64);
```

```carbon
// Toy example of using the result of variadic type deduction.
fn TupleConcat[T1s: [type;], T2s: [type;]]
              (t1: (repeat expand T1s), t2: (repeat expand T2s))
              -> (repeat expand T1s, repeat expand T2s) {
  return (repeat expand t1, repeat expand t2);
}
```

#### Rationale

One key tradeoff of the keyword-based approach is that it seems to be
incompatible with having patterns and expressions use the same syntax. Consider
an expression like `(x, y, z)`, and a pattern like `(x: i32, y:i32, z:i32)`:
both use the same tuple literal syntax, but with opposite meanings: the
expression takes a collection of elements and forms a tuple from them, whereas
the pattern decomposes a tuple into a collection of elements. We can use the
same syntax for both because the syntax is declarative -- it doesn't refer to a
process of creating or decomposing a tuple, but to the tuple itself as a
timeless entity. The symbolic tokens for variadics are intended to have the same
quality.

By contrast, in many cases the only plausible keywords that we've found for
variadics are verbs, and so they implicitly have a direction in time:
"repeating", "expanding", and "unpacking" are all actions that change something
from one state to another. As a result, they typically only work in one context.

The `...,` operation is critical to both expressions and patterns, so we've
split it into `unpack` for patterns and `repeat` for expressions. For `[:]`, it
appears to be possible to limit it to expression contexts with no significant
loss of expressivity: the only pattern use cases we've found involve applying it
directly to a function parameter, in which case we can instead apply it to the
parameter's type. Consequently, we limit it to expression contexts, and replace
it with the single keyword `expand`.

One consequence of that choice is that variadic function arguments now always
have pack types. This makes it more problematic that named packs tend to have
readability problems because they aren't marked as expansion arguments at the
point of use. To mitigate that problem, we introduce the `each` keyword, which
has no semantic effect, but is required as a syntactic marker.

#### Discussion

This approach has some major advantages: the keywords are substantially less
visually noisy than the symbolic tokens (especially `...,`), and they may also
be more self-explanatory. However, it does have some substantial drawbacks.

Most notably, there is no longer any syntactic commonality between the different
tokens that mark the root of an expansion. That makes it harder to visually
identify expansions, and could also make variadics harder to learn: `repeat`,
`all_of`, and `any_of` have to be learned as three separate keywords, whereas
the spellings of `...,`, `...and`, and `...or` act as a strong mnemonic cue that
they represent a single concept, instantiated for three different binary
operators (admittedly, `...{` somewhat undermines that unity).

Relatedly, the keywords have less clear precedence relationships. This is both
because the expansion operators can't as easily "borrow" their precedence from
their non-variadic counterparts, and because the expansion-argument keywords
more often need to be separated from their operand by whitespace. For example,
consider this line from `Zip`:

```carbon
  while (...and [:]iters != vectors.End()) {
```

Under this alternative, that becomes:

```carbon
  while (all_of expand iters != (each vectors).End()) {
```

I find the precedence relationships in the initial `all_of expand iters !=` much
more opaque than in `...and [:]iters !=`, to the extent that we might need to
require additional parentheses:

```carbon
  while (all_of ((expand iters) != (each vectors).End())) {
```

That avoids outright ambiguity, but obliging readers to maintain a mental stack
of parentheses in order to parse the expression creates its own readability
problems.

That example also illustrates another issue: prefix operators like `each` and
`expand` tend to be ambiguous when mixed with postfix syntaxes like member
access, so we need to use parentheses in expressions like
`(each vectors).End()`. `[:]` has the same problem, of course, but there have
been informal discussions of solving this class of problems by generalizing the
`->` operator to support other prefix operators besides `*`, so perhaps we could
write `foo-[:]>bar` instead of `([:]foo).bar`. This approach seems less
promising when the prefix operator is a keyword: it's much harder to visually
parse something like `-each>` as a single operator, especially in a composite
expression like `foo-each>bar`.

Breaking the symmetry between expressions and patterns is also not ideal. In
addition to the loss of conceptual elegance and the need for an extra keyword, I
found that having to choose between `unpack` and `repeat` was a noticeable
source of friction when rewriting the examples above (of course, my experience
may not be representative).

One interesting property of the symbolic-token-based design is that homogeneous
variadic functions can be implemented entirely in terms of conventional
procedural loops, with no variadic syntax or semantics anywhere other than the
signature (see `SumInts` and `Min`, for example). However, this relies on the
ability to use `[:]` in a pattern context, which the keyword approach doesn't
allow unless we can invent a new keyword for it.

Finally, it bears mentioning that the keywords occupy lexical space that could
otherwise be used for identifiers. Notably, `all_of`, `any_of`, and `repeat` are
all names of functions in the C++ standard library. This is not a fundamental
problem, because we expect Carbon to have some way of "quoting" a keyword for
use as an identifier (such as Rust's
[raw identifiers](https://doc.rust-lang.org/rust-by-example/compatibility/raw_identifiers.html)),
but it is likely to be a source of friction.
