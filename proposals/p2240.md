# Variadics

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/2240)

<!-- toc -->

## Table of contents

-   [Abstract](#abstract)
-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
    -   [Examples](#examples)
-   [Details](#details)
-   [Rationale](#rationale)
-   [Alternatives considered](#alternatives-considered)
    -   [Support variadic variable declaration statements](#support-variadic-variable-declaration-statements)
    -   [Support array expansion arguments](#support-array-expansion-arguments)
    -   [Omit variadic bindings](#omit-variadic-bindings)
        -   [Disallow pack-type bindings](#disallow-pack-type-bindings)
    -   [Fold expressions](#fold-expressions)
    -   [Allow multiple `...,` patterns in a tuple pattern](#allow-multiple--patterns-in-a-tuple-pattern)
    -   [Allow nested pack expansions](#allow-nested-pack-expansions)
    -   [Use postfix instead of prefix `...`](#use-postfix-instead-of-prefix-)
    -   [Require parentheses around `each`](#require-parentheses-around-each)
    -   [Keyword syntax](#keyword-syntax)

<!-- tocstop -->

## Abstract

Proposes a set of core features for declaring and implementing generic variadic
functions. The central concept is a _pack expansion_, which is a kind of
compile-time loop over sequences called _expansion arguments_. Expansion
arguments can be formed from tuples with the `expand` operator, or from a
_variadic binding_, which is marked with the `each` keyword at the point of
declaration and the point of use. Pack expansions come in several forms, with
slightly different iteration semantics:

-   `...,` iteratively evaluates an expression, and treats the values as
    successive elements of an enclosing tuple.
-   `...and` and `...or` iteratively evaluates a boolean expression, combining
    the values using `and` and `or`, and ending the loop early if the underlying
    operator short-circuits.
-   `...{}` iteratively executes a block of statements.

`...,` can also be used in patterns, where it iteratively matches the elements
of a scrutinee tuple. In conjunction with variadic bindings, this enables
functions to take an arbitrary number of arguments.

## Problem

Carbon needs a way to define functions and parameterized types that are
_variadic_, meaning they can take a variable number of arguments.

## Background

C has long supported variadic functions (such as `printf`), but that mechanism
is heavily disfavored in C++ because it isn't type-safe. Instead, C++ provides a
separate feature for defining variadic _templates_, which can be functions,
classes, or even variables. However, variadic templates currently suffer from
several shortcomings. Most notably:

-   They must be templates, which means they cannot be definition-checked, and
    suffer from a variety of other costs such as needing to be defined in header
    files, and code bloat due to template instantiation.
-   It is inordinately difficult to define a variadic function whose parameters
    have a fixed type, and the signature of such a function does not clearly
    communicate that fixed type to readers.
-   There is no procedural mechanism for iterating through a variadic parameter
    list. Although features like
    [fold expressions](https://en.cppreference.com/w/cpp/language/fold) cover
    some special cases, the only fully general way to express iteration is with
    recursion, which is often awkward, results in more template instantiations,
    and typically has at least quadratic overhead in the size of the pack (at
    compile time, and sometimes at run time).

There are a number of pending C++ standard proposals to address these issues,
and improve variadic templates in other ways, such as
[P1306R1: Expansion Statements](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1306r1.pdf),
[P1858R2: Generalized Pack Declaration and Usage](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1858r2.html),
and
[P2277R0: Packs Outside of Templates](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2277r0.html).
P1858R2 has been especially influential for this proposal.

Swift has very recently adopted a
[proposal](https://github.com/apple/swift-evolution/blob/main/proposals/0393-parameter-packs.md)
to support definition-checked generic variadics. There have been several
attempts to add such a feature to Rust, but that work is
[currently inactive](https://github.com/rust-lang/rfcs/issues/376#issuecomment-830034029).

## Proposal

`...,`, `...and`, and `...or` are prefix unary expression operators with the
same precedence as the corresponding non-pack operators. `...{` is an opening
delimiter that forms a balanced pair with `}`, and can contain any number of
statements. The `...,` operator can also be used in patterns. An AST rooted at
any of these operations is called a _pack expansion_.

A pack expansion must contain one or more _expansion arguments_, which represent
sequences of types or values, and the pack expansion behaves like a compile-time
loop over those sequences. The semantics of the loop are determined by the token
that introduces the expansion: `...{}` is a traditional loop that executes
statements, `...,` turns the values of the iterations into a sequence of tuple
elements, and `...and` and `...or` combine the values of the iterations using
`and` and `or`.

A _variadic binding pattern_ is a binding pattern that is prefixed with the
`each` keyword. Inside a `...,` pattern, it can match an arbitrary number of
tuple elements. It can then be used as an expansion argument, by applying `each`
to the bound name. An expansion argument can also be formed by applying the
`expand` operator to a tuple.

### Examples

```carbon
// Computes the sum of its arguments, which are i64s
fn SumInts(..., each param: i64) -> i64 {
  var sum: i64 = 0;
  ...{
    sum += each param;
  }
  return sum;
}
```

```carbon
// Concatenates its arguments, which are all convertible to String
fn StrCat[each T:! ConvertibleToString](..., each param: each T) -> String {
  var len: i64 = 0;
  ...{ len += each param.Length(); }
  var result: String = "";
  result.Reserve(len);
  ...{ result.Append(each param.ToString()); }
  return result;
}
```

```carbon
// Returns the minimum of its arguments, which must all have the same type T.
//
// Note that this implementation is not recursive. We split the parameters into
// first and rest in order to forbid calling `Min` with no arguments.
fn Min[T:! Comparable & Value](first: T, ..., each next: T) -> T {
  var result: T = first;
  ...{
    if (each next < result) {
      result = next;
    }
  }
  return result;
}
```

```carbon
// Invokes f, with the tuple `args` as its arguments.
fn Apply[each T:! type, F:! CallableWith(..., each T)](f: F, args: (..., each T)) -> auto {
  return f(..., expand args);
}
```

```carbon
// Takes an arbitrary number of vectors with arbitrary element types, and
// returns a vector of tuples where the i'th element of the vector is
// a tuple of the i'th elements of the input vectors.
fn Zip[each ElementType:! type]
      (..., each vector: Vector(each ElementType))
      -> Vector((..., each ElementType)) {
  var iters: auto = (..., each vector.Begin());
  var result: Vector((..., each ElementType));
  while (...and expand iters != each vector.End()) {
    result.push_back((..., *expand iters));
    ...{ (expand iters)++; }
  }
  return result;
}
```

```carbon
// Toy example of mixing packs and values in a single parameter list.
// Takes an i64, any number of f64s, and then another i64.
fn MiddleVariadic(first: i64, ..., each middle: f64, last: i64);
```

```carbon
// Toy example of using the result of variadic type deduction.
fn TupleConcat[each T1: type, each T2: type](
    t1: (..., each T1), t2: (..., each T2)) -> (..., each T1, ..., each T2) {
  return (..., expand t1, ..., expand t2);
}
```

## Details

For full details, see `/docs/design/variadics.md` in this pull request.

## Rationale

Carbon needs variadics to effectively support
[interoperation with and migration from C++](/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code),
where variadic templates are fairly common. Variadics also make code
[easier to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write),
because some APIs (such as `printf`) can't be naturally expressed in terms of a
fixed number of parameters.

Furthermore, Carbon needs to support _generic_ variadics for the same reasons it
needs to support generic non-variadic functions: for example,
definition-checking makes APIs
[easier to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write),
and [easier to evolve](/docs/project/goals.md#software-and-language-evolution).
Furthermore, the language as a whole is easier to understand and write code in
if separate features like variadics and generics compose in natural ways, rather
than being mutually exclusive.

Variadics are also important for supporting
[performance-critical software](/docs/project/goals.md#performance-critical-software),
because variadic APIs can be more efficient than their non-variadic
counterparts. For example, `StrCat` is fundamentally more efficient than
something like a chain of `operator+` calls on `std::string`, because it does
not need to materialize a series of partial results, and it can pre-allocate a
buffer large enough for the final result.

This proposal deviates somewhat from the principle that
[all APIs are library APIs](/docs/project/principles/library_apis_only.md)
because it treats tuples and packs as effectively built-in types. As the
document for this principle notes, tuples may be an exception to the principle
because it is very hard to see how we could define them as library types without
circularity. Packs have much the same problem, since a pack type would itself
have to be a variadic type. The need for both types to deeply support symbolic
computation adds some major challenges here as well. However, if tuples could
ever be library types, they would certainly need to be defined variadically, so
in that sense this proposal may actually support that principle.

## Alternatives considered

### Support variadic variable declaration statements

It is possible to rewrite `Zip` to make `iters` a variadic binding rather than a
tuple:

```carbon
// Takes an arbitrary number of vectors with arbitrary element types, and
// returns a vector of tuples where the i'th element of the vector is
// a tuple of the i'th elements of the input vectors.
fn Zip[each ElementType:! type]
      (..., each vector: Vector(each ElementType))
      -> Vector((..., each ElementType)) {
  var (..., each iter: auto) = (..., each vector.Begin());
  var result: Vector((..., each ElementType));
  while (...and each iter != each vector.End()) {
    result.push_back((..., *each iter));
    ...{ each iter++; }
  }
  return result;
}
```

That seems conceptually more natural, and makes usages of the binding more
readable, but requires somewhat more boilerplate in the declaration. We could
avoid that by introducing a syntax for variadic variable declaration statements,
so that the declaration of `iter` could instead be written:

```carbon
  ...var each iter: auto = each vector.Begin();
```

We could get the same result from an even broader generalization, where we allow
prefixing an arbitrary statement with `...`, which would have the same effect as
wrapping the statement in `...{}`, except that it does not introduce a new
scope. This would also let us write the last line of the `Zip` loop more
concisely, as `... each iter++;`.

These extensions seem plausible, but they are left as future work because they
are not necessary to the core proposal.

### Support array expansion arguments

Statically-sized arrays are very close to being a special case of tuple types:
the only difference between an array type `[i32; 2]` (using Rust syntax) and a
tuple type `(i32, i32)` is that the array type can be indexed with a run-time
subscript. Consequently, it would be fairly natural to allow `expand` to operate
on arrays as well as tuples, and even to allow arrays of types to be treated as
tuple types (in the same way that tuples of types can be treated as tuple
types).

This functionality is omitted from the current proposal because we have no
motivating use cases, but it could be added as an extension. Note that there are
important motivating use cases under some of the alternatives considered below.

### Omit variadic bindings

Rather than introducing a special kind of binding pattern to enable variadics,
we could rely on the type to provide that information. For example, under the
current proposal, the signature of `Zip` is:

```carbon
fn Zip[each ElementType:! type]
      (..., each vector: Vector(each ElementType))
      -> Vector((..., each ElementType));
```

With this alternative, it could instead be written:

```carbon
fn Zip[ElementTypes:! [type;]]
      (..., vectors: Vector(expand ElementTypes))
      -> Vector((..., expand ElementTypes));
```

This employs two separate features: in cases where the declared type of the
variadic binding does not vary across iterations (like `ElementType`), we can
re-express it as an array binding if we have support for array expansion
arguments (discussed above). In cases where the declared type of the binding
does vary, that fact alone implies that the binding is variadic, so we can
effectively infer the presence of `each` from the type, rather than make the
user spell it out explicitly.

This slight change in syntax belies a much larger shift in the underlying
semantics: since these are ordinary bindings, a given call to `Zip` must bind
each of them to a single value that represents the whole sequence of arguments
(which is why their names are now plural). In the case of `ElementTypes`, that
follows straightforwardly from its type: it represents the argument types as an
array of `type`s. The situation with `vectors` is more subtle: we have to
interpret `Vector(expand ElementTypes)` as the type of the whole sequence of
argument values, rather than as a generic description of the type of a single
argument. In other words, we have to interpret it as a pack type, and that means
`vectors` notionally binds to a run-time pack value.

Consequently, when `vectors` is used in the function body, it doesn't need an
`each` or `expand` prefix: we've chosen to express variadicity in terms of
types, and it already has a pack type, so it can be directly used as an
expansion argument.

This approach has a few advantages:

-   It's simpler in some respects, because we treat variadic sequences of values
    as values in their own right, and so we don't have to introduce the
    potentially-confusing concept of a binding that binds to multiple values
    simultaneously.
-   It avoids the anomaly where we have pack types in the type system, but no
    actual values of those types.
-   Removing the `each` keyword makes it more natural to spell `expand` as a
    symbolic token (earlier versions of this proposal used `[:]`), which is more
    concise and doesn't need surrounding whitespace.
-   For fully homogeneous variadics (such as `SumInts` and `Min`) it's actually
    possible to write the function body as an ordinary loop with no variadics,
    by expressing the signature in terms of a non-variadic binding with an array
    type.

However, it also has some major disadvantages:

-   The implicit expansion of pack-type bindings hurts readability. For example,
    it's easy to overlook the fact that the loop condition
    `while (...and expand iters != vectors.End())` in `Zip` has two expansion
    arguments, not just one.
-   A given _use_ of such a binding really represents a single value at a time,
    in the same way that the iteration variable of a for-each loop does, so
    treating it as a sequence (and giving it a plural name) in that context
    creates confusion rather than alleviating it.
-   Even if the value of a run-time _binding_ can be a pack, the value of a
    run-time _expression_ cannot. This is easiest to see with an expression like
    `(..., if (expand cond) then F(expand param) else G(expand param))`: if
    `expand param` truly evaluated to a pack value, then evaluating this
    expression would require N calls to _both_ `F` and `G`, rather than N calls
    to _either_ `F` or `G`. This would create a confusing situation where pack
    types have pack values, and expressions can have pack types, but expressions
    with pack types don't evaluate to pack values. This is probably worse than
    saying that pack types are a bookkeeping contrivance, and do not have
    run-time values.

It's also worth noting that we may eventually want to introduce operations that
treat the sequence of bound values as a unit, such as to determine the length of
the sequence (like `sizeof...` in C++), or even to index into it. This approach
might seem more amenable to that, because it conceptually treats the sequence of
values as a value in itself, which could have its own operations. However, this
approach leaves no "room" in the syntax to spell those operations, because any
mention of a pack-type binding implicitly expands it.

Conversely, the status quo proposal seems to leave a clear syntactic opening for
those operations: you can refer to the sequence as a whole by omitting `each`,
so `each vector.Size()` refers to the size of the current iteration's `vector`,
whereas `vector.Size()` could refer to the size of the sequence of bound values.
However, this could easily turn out to be a "wrong default": omitting `each`
seems easy to do by accident, and easy to misread during code review.

There are other solutions to this problem that work equally well with the status
quo or this alternative. In particular, it's already possible to express these
operations outside of a pack expansion by converting to a tuple, as in
`(..., each vector).Size()` (status quo) or `(..., vectors).Size()` (this
alternative). That may be sufficient to address those use cases, especially if
we relax the restrictions on nesting pack expansions. Failing that,
variadic-only spellings for these operations (like `sizeof...` in C++) would
also work with both approaches. So this issue does not seem like an important
differentiator between the two approaches.

#### Disallow pack-type bindings

As a variant of the above approach, it's possible to omit both variadic bindings
and pack-type bindings, and instead rely on variadic tuple-type bindings. For
example, the signature of `Zip` could instead be:

```carbon
fn Zip[ElementTypes:! [type;]]
      (..., expand vectors: (..., Vector(expand ElementTypes)))
      -> Vector((..., expand ElementTypes));
```

This signature doesn't change the callsite semantics, but within the function
body `vectors` will be a tuple rather than a pack. This avoids or mitigates all
of the major disadvantages of pack-type bindings, but it comes at a substantial
cost: the function signature is substantially more complex and opaque. That
seems likely to be a bad tradeoff -- the disadvantages of pack-type bindings
mostly concern the function body, but readability of variadic function
signatures seems much more important than readability of variadic function
bodies, because the signatures will be read far more often, and by programmers
who have less familiarity with variadics.

The leads chose not to pursue this approach in
[leads issue #1162](https://github.com/carbon-language/carbon-lang/issues/1162).

### Fold expressions

Rather than special `...,`, `...and`, and `...or` tokens, we could support
something like C++'s
[fold expressions](https://en.cppreference.com/w/cpp/language/fold), where `...`
is a stand-alone token that can impart a variadic meaning to a variety of
expressions, including usages of most unary and binary operators. This would be
more consistent with C++, and would give users more control over associativity
and over the behavior of the arity-0 case.

However, fold expressions are arguably too general in some respects: folding
over a non-commutative operator like `-` is more likely to be confusing than to
be useful. Similarly, there are few if any plausible use cases for customizing
the arity-zero behavior of `and` or `or`. Conversely, fold expressions are
arguably not general enough in other respects, because they only support folding
over a fixed set of operators, not over functions or compound expressions.

All of that being the case, it seems preferable to start with a minimal set of
variadic operators, both to keep this proposal simple and to leave room for a
more general fold-like facility in the future. Our minimal set consists of
`...,` for variadic parameter lists, `...and` for variadic composition of
constraints (as well as use cases like in the body of `Zip`), and `...or` for
symmetry with `...and`.

Note that even if Carbon supported more general C++-like fold expressions, we
would still probably have to give these three operators special-case treatment,
because `,` is a component of the tuple syntax rather than a freestanding binary
operator, and `and` and `or` are short-circuiting.

As a point of comparison, C++ gives special-case treatment to the same three
operators in fold expressions: they are the only ones where the initial value
can be omitted (such as `... && args` rather than `true && ... && args`) even if
the pack may be empty. Furthermore, folding over `&&` appears to have been the
original motivation for adding fold expressions to C++, and of course folding
over `,` was the central use case for C++ variadics.

Given that we are only supporting a minimal set of operators, allowing `...` to
occur in ordinary binary syntax has few advantages and several drawbacks:

-   It might conflict with a future general fold facility.
-   It would invite users to try other operators, and would probably give less
    clear errors if they do.
-   It would substantially complicate parsing and the AST.
-   It would force users to make a meaningless choice between `x or ...` and
    `... or x`, and likewise for `and`.

### Allow multiple `...,` patterns in a tuple pattern

As currently proposed, we allow multiple `...,` expressions within a tuple
literal expression, but only allow one `...,` pattern within a tuple pattern. It
is superficially tempting to relax this restriction, but fundamentally
infeasible.

Allowing multiple `...,` patterns would create a potential for ambiguity about
where their scrutinees begin and end. For example, given a signature like
`fn F(..., each xs: each i32, ..., each ys: each i32)`, there is no way to tell
where `xs` ends and `ys` begins in the argument list; every choice is equally
valid. That ambiguity can be avoided if the types are different, but that would
make type _non_-equality a load-bearing part of the pattern. That's a very
unusual thing to need to reason about in the type system, so it's liable to be a
source of surprise and confusion for programmers, and in particular it looks
difficult if not impossible to usefully express with generic types, which would
greatly limit the usefulness of such a feature.

Furthermore, our solution to the problem of combinatorial explosion in tuple
pattern matching deeply relies on the fact that there is at most one `...,`
subpattern in the tuple pattern. Without that constraint, it's not at all clear
if we could type-check variadic pattern matches in polynomial time.

Finally, function authors can straightforwardly work around this restriction by
adding delimiters. For example, the current design disallows
`fn F(..., each xs: each i32, ..., each ys: each i32)`, but it allows
`fn F((..., each xs: each i32), (..., each ys: each i32))`, which is not only
easier to support, but makes the callsite safer and more readable, since the
boundary between the `xs` and `ys` arguments is explicitly marked. By contrast,
if we disallowed multiple `...,` expressions in a function argument list,
function callers who ran into that restriction would often find it difficult or
impossible to work around.

To take a more abstract view of this situation: when we reuse expression syntax
as pattern syntax, we are effectively inverting expression evaluation, by asking
the language to find the operands that would cause an expression to evaluate to
a given value. That's only possible if the operations involved are invertible,
meaning that they do not lose information. When a tuple literal contains
multiple `...,` expressions, evaluating it effectively discards structural
information about for example where `xs` ends and `ys` begins. The operation of
forming a tuple from multiple packs is not invertible, and consequently we
cannot use it as a pattern operation. Our rule effectively says that if the
function needs that structural information, it must ask the caller to provide
it, rather than asking the compiler to infer it.

### Allow nested pack expansions

Earlier versions of this design allowed pack expansions to contain other pack
expansions. This is in some ways a natural generalization, but it added
nontrivial complexity to the design. More importantly, we have few if any
motivating use cases for it, which made it difficult to evaluate that aspect of
the design. Consequently, this proposal does not support nested pack expansions,
although it tries to avoid ruling them out as a future extension.

### Use postfix instead of prefix `...`

`...` is a postfix operator in C++, which aligns with the natural-language use
of "â€¦", so it would be more consistent with both if `...,`, `...and`, and
`...or` were postfix operators spelled `,...`, `and...`, and `or...`, and
likewise if `...{}` were instead spelled `{}...`.

However, prefixes syntaxes are usually easier to parse (particularly for
humans), because they ensure that by the time you start parsing an utterance,
you already know the context in which it is used. This is clearest in the case
of `{}...`: the reader might have to read an arbitrary amount of code in the
block before realizing that the code they've been reading will be executed
variadically, so that seems out of the question. The cases of `and`, `or`, and
`,` are less clear-cut, but we have chosen to make them all prefix operators for
consistency with `...{}`.

### Require parentheses around `each`

We could give `each` a lower precedence, so that expressions such as
`each vector.End()` would need to be written as `(each vector).End()`. This
could make the code clearer for readers, especially if they are new to Carbon
variadics. However, this would make the code visually busier, and might give the
misleading impression that `each` can be applied to anything other than an
identifier. I propose that we wait and see whether the unparenthesized syntax
has readability problems in practice, before attempting to solve those problems.

We have discussed a more general solution to this kind of problem, where a
prefix operator could be embedded in a `->` token, in order to apply the prefix
operator to the left-hand operand without needing parentheses. However, this
approach is much more appealing when the prefix operator is a symbolic token:
`x-?>y` may be a plausible alternative to `(?x).y`, but `x-each>y` seems much
harder to visually parse.

### Keyword syntax

> **TODO:** Decide whether to make this the primary proposal, and restructure
> the discussion as appropriate.

We could make the pack expansion root tokens be keywords rather than symbolic
tokens. For concreteness, the keywords I will discuss here are as follows:

| Symbolic token | Keyword replacement |
| -------------- | ------------------- |
| `...,`         | `repeat`            |
| `...and`       | `all_of`            |
| `...or`        | `any_of`            |
| `...{`         | `repeat {`          |

With these changes, the examples given earlier would read as follows:

```carbon
// Computes the sum of its arguments, which are i64s
fn SumInts(repeat each param: i64) -> i64 {
  var sum: i64 = 0;
  repeat {
    sum += each param;
  }
  return sum;
}
```

```carbon
// Concatenates its arguments, which are all convertible to String
fn StrCat[each T:! ConvertibleToString](repeat each param: each T) -> String {
  var len: i64 = 0;
  repeat { len += each param.Length(); }
  var result: String = "";
  result.Reserve(len);
  repeat { result.Append(each param.ToString()); }
  return result;
}
```

```carbon
// Returns the minimum of its arguments, which must all have the same type T.
//
// Note that this implementation is not recursive. We split the parameters into
// first and rest in order to forbid calling `Min` with no arguments.
fn Min[T:! Comparable & Value](first: T, repeat each next: T) -> T {
  var result: T = first;
  repeat {
    if (each next < result) {
      result = next;
    }
  }
  return result;
}
```

```carbon
// Invokes f, with the tuple `args` as its arguments.
fn Apply[each T:! type, F:! CallableWith(repeat each T)]
    (f: F, args: (repeat each T)) -> auto {
  return f(repeat expand args);
}
```

```carbon
// Takes an arbitrary number of vectors with arbitrary element types, and
// returns a vector of tuples where the i'th element of the vector is
// a tuple of the i'th elements of the input vectors.
fn Zip[each ElementType:! type]
      (repeat each vector: Vector(each ElementType))
      -> Vector((repeat each ElementType)) {
  var iters: auto = (repeat each vector.Begin());
  var result: Vector((repeat each ElementType));
  while (all_of expand iters != each vector.End()) {
    result.push_back((repeat *expand iters));
    repeat { (expand iters)++; }
  }
  return result;
}
```

```carbon
// Toy example of mixing packs and values in a single parameter list.
// Takes an i64, any number of f64s, and then another i64.
fn MiddleVariadic(first: i64, repeat each middle: f64, last: i64);
```

```carbon
// Toy example of using the result of variadic type deduction.
fn TupleConcat[each T1: type, each T2: type](
    t1: (repeat each T1), t2: (repeat each T2)) -> (repeat each T1, repeat each T2) {
  return (repeat expand t1, repeat expand t2);
}
```

This approach has some major advantages: the keywords are more consistent with
the expansion argument keywords (especially `each`), substantially less visually
noisy than the symbolic tokens (especially `...,`), and they may also be more
self-explanatory. However, it does have some substantial drawbacks.

Most notably, there is no longer any syntactic commonality between the different
tokens that mark the root of an expansion. That makes it harder to visually
identify expansions, and could also make variadics harder to learn: `repeat`,
`all_of`, and `any_of` have to be learned as three separate keywords, whereas
the spellings of `...,`, `...and`, and `...or` act as a strong mnemonic cue that
they represent a single concept, instantiated for three different binary
operators (admittedly, `...{` somewhat undermines that unity). In the case of
`repeat`, it also makes it harder to visually identify tuples, because now we
can have tuple literals and tuple patterns that do not contain the `,`
character.

Relatedly, the keywords have less clear precedence relationships, because the
expansion operators can't as easily "borrow" their precedence from their
non-variadic counterparts. For example, consider this line from `Zip`:

```carbon
while (...and expand iters != each vector.End()) {
```

Under this alternative, that becomes:

```carbon
  while (all_of expand iters != each vector.End()) {
```

I find the precedence relationships in the initial `all_of expand iters !=` more
opaque than in `...and expand iters !=`, to the extent that we might need to
require additional parentheses:

```carbon
  while (all_of (expand iters != each vectors.End())) {
```

That avoids outright ambiguity, but obliging readers to maintain a mental stack
of parentheses in order to parse the expression creates its own readability
problems.

It's appealing that the `repeat` keyword combines with `each` to produce code
that's almost readable as English, but it creates a temptation to read `expand`
the same way, which will usually be misleading. For example, `repeat expand foo`
sounds like it is repeatedly expanding `foo`, but in fact it expands it only
once. It's possible that a different spelling of `expand` could avoid that
problem, but I haven't been able to find one that does so while also avoiding
the potential for confusion with `each`. Support for
[variadic variable declaration statements](#support-variadic-variable-declaration-statements)
could mitigate this problem, by making `expand` much rarer.

It's somewhat awkward, and potentially even confusing, to use an imperative word
like `repeat` in a pattern context. By design, the pattern language is
descriptive rather than imperative: it describes the values that match rather
than giving instructions for how to match them. As a result, in a pattern like
`(repeat each param: i64)`, it's not clear what action is being repeated.

Finally, it bears mentioning that the keywords occupy lexical space that could
otherwise be used for identifiers. Notably, `all_of`, `any_of`, and `repeat` are
all names of functions in the C++ standard library. This is not a fundamental
problem, because we expect Carbon to have some way of "quoting" a keyword for
use as an identifier (such as Rust's
[raw identifiers](https://doc.rust-lang.org/rust-by-example/compatibility/raw_identifiers.html)),
but it is likely to be a source of friction.
