# Variadics

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/2240)

<!-- toc -->

## Table of contents

-   [Abstract](#abstract)
-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
    -   [Examples](#examples)
-   [Details](#details)
    -   [Statically sized arrays](#statically-sized-arrays)
    -   [Pack expansions](#pack-expansions)
    -   [Packs](#packs)
    -   [Expression and statement semantics](#expression-and-statement-semantics)
    -   [Pattern semantics](#pattern-semantics)
        -   [Example](#example)
    -   [Typechecking](#typechecking)
        -   [Variadic types](#variadic-types)
        -   [Expressions](#expressions)
        -   [Patterns](#patterns)
            -   [Tuple type](#tuple-type)
                -   [Identifying potential matchings](#identifying-potential-matchings)
                -   [The type-checking algorithm](#the-type-checking-algorithm)
            -   [Parameterized class type](#parameterized-class-type)
            -   [Identifier that names a deduced parameter](#identifier-that-names-a-deduced-parameter)
            -   [Name binding pattern](#name-binding-pattern)
            -   [`[:]` pattern](#-pattern)
        -   [Statements](#statements)
-   [Rationale](#rationale)
-   [Alternatives considered](#alternatives-considered)
    -   [Use postfix instead of prefix operators](#use-postfix-instead-of-prefix-operators)

<!-- tocstop -->

**NOTE TO READER:** This is a very rough draft, because I'm still trying to pin
down the ideas it's describing. As a result, it's not well-structured for
reading, and it's probably not even internally consistent. I have inserted some
notes like this one to try to provide some guidance.

## Abstract

TODO

## Problem

Carbon needs a way to define functions and parameterized types that are
_variadic_, meaning they can take a variable number of arguments.

## Background

C has long supported variadic functions (such as `printf`), but that mechanism
is heavily disfavored in C++ because it isn't type-safe. Instead, C++ provides a
separate feature for defining variadic _templates_, which can be functions,
classes, or even variables. However, variadic templates currently suffer from
several shortcomings. Most notably:

-   They must be templates, which mean they typically must be defined in header
    files, are susceptible to code bloat due to template instantiation, and
    generally carry all the other costs associated with templating.
-   It is inordinately difficult to define a variadic function whose parameters
    have a fixed type, and the signature of such a function does not clearly
    communicate that fixed type to readers.
-   There is no procedural mechanism for iterating through a variadic parameter
    list. Although features like
    [fold expressions](https://en.cppreference.com/w/cpp/language/fold) cover
    some special cases, the only fully general way to express iteration is with
    recursion, which is often awkward, and results in more template
    instantiations.

There are a number of pending C++ standard proposals to address these issues,
and improve variadic templates in other ways, such as
[P1306R1: Expansion Statements](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1306r1.pdf),
[P1858R2: Generalized Pack Declaration and Usage](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1858r2.html),
and
[P2277R0: Packs Outside of Templates](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2277r0.html).
P1858R2 has been especially influential for this proposal.

## Proposal

**NOTE TO READER:** This section is the oldest part of this document. I've made
some cursory attempts to bring it up to date, but if there's a conflict between
this and the Details section, the version in Details is probably closer to my
current thinking.

`[T; N]` is the type of a statically-sized array of N objects of type `T`. Other
syntaxes like `[N; T]` would also work; it just needs to be concise, and feel
core-language enough that we can use it in patterns. `[T;]` is a shorthand for
`[T; _ :! BigInt]`.

The pack operators `...,`, `...and`, and `...or` are prefix unary operators with
the same precedence as the corresponding non-pack operators. They are single
tokens, and may not contain internal whitespace. A _pack expansion_ consists of
a pack operator together with its operand, which is called the _pack template_.
A pack template must contain at least one usage of the prefix unary operator
`[:]`, whose operand, called a _pack argument_, must be a tuple or
statically-sized array. All arguments of a given pack expansion must have the
same arity. A pack expansion whose arguments have arity N is rewritten to N
copies of the pack template, where in the Kth copy, each use of the `[:]`
operator evaluates to the Kth element of its operand. Each copy is followed by a
separator, and the entire sequence is followed by a terminator, as determined by
the pack operator:

| Pack operator | Separator | Terminator |
| ------------- | --------- | ---------- |
| `...,`        | `,`       | (none)     |
| `...and`      | `and`     | `true`     |
| `...or`       | `or`      | `false`    |

As a consequence, a `...,` pack expansion can only occur where a tuple literal
element is expected, or directly inside parentheses, and in the latter case, the
parentheses form a tuple, even if the pack argument has only one element.

A pack expansion block has the form `...{` _statements_ `}`, and is rewritten to
N copies of the pack template `{` statements `}`, with pack arguments
substituted as above. `...{` is a single token, and may not contain internal
whitespace.

Pack expansions currently cannot be nested.

The spelling of `[:]` is taken from the C++ proposal
[P1858R2](http://wg21.link/P1858R2), but I'm very open to alternatives.

### Examples

```carbon
// Computes the sum of its arguments, which are i64s
fn SumInts(..., [:]params: [i64;]) -> i64 {
  var sum: i64 = 0;
  for (var i: i64 in params) {
    sum += i;
  }
  return sum;
}
```

```carbon
// Concatenates its arguments, which are all convertible to String
fn StrCat[T:! [ConvertibleToString;]](..., [:]params: T) -> String {
  var len: i64 = 0;
  ...{ len += ([:]params).Length(); }
  var result: String = "";
  result.Reserve(len);
  ...{ result.Append(([:]params).ToString()); }
  return result;
}
```

```carbon
// Returns the minimum of its arguments, which must all have the same type T.
//
// Note that this implementation is not recursive. We split the parameters into
// first and rest in order to forbid calling `Min` with no arguments.
fn Min[T:! Comparable & Value](first: T, ..., [:]rest: [T; N]) -> T {
  var result: T = first;
  for (var x: T in rest) {
    if (x < result) {
      result = x;
    }
  }
  return result;
}
```

```carbon
// Invokes f, with the tuple `args` as its arguments.
fn Apply[T:! [Type;], F:! CallableWith(..., [:]T)](f: F, args: (..., [:]T)) -> auto {
  return f(..., [:]args);
}
```

```carbon
fn Zip[ElementTypes:! [Type;]]
      (..., vectors: Vector([:]ElementTypes))
      -> Vector((..., [:]ElementTypes)) {
  var iters: auto = (..., vectors.Begin());
  var result: Vector((..., [:]ElementTypes));
  while (...and [:]iters != vectors.End()) {
    result.push_back((..., *[:]iters));
    ...{ ([:]iters)++; }
  }
  return result;
}
```

```carbon
// Toy example of mixing packs and values in a single parameter list.
// Takes an i64, any number of f64s, and then another i64.
fn MiddleVariadic(first: i64, ..., [:]middles: [f64;], last: i64);
```

```carbon
// Toy example of using the result of variadic type deduction.
fn TupleConcat[T1s: [Type;], T2s: [Type;]](
    t1: (..., [:]T1s), t2: (..., [:]T2s)) -> (..., [:]T1s, ..., [:]T2s) {
  return (..., [:]t1, ..., [:]t2);
}
```

## Details

FIXME throughout the following, clarify what parts apply to patterns.

### Statically sized arrays

`[T; N]` is the type of a statically-sized array of `N` objects of type `T`, and
`[T;]` is a pattern that matches the type `[T; N]` for any `N`. In other words,
it's a shorthand for `[T; _:! BigInt]`.

FIXME Or maybe we should treat it as an interface/constraint? See
https://discord.com/channels/655572317891461132/969001583088123905/973681495891910716
Or maybe it's `[T; template _:! BigInt]` so that we can validly refactor it to
`[template N:! BigInt]([T; N])`? `auto` seems like it might be ambivalent in a
similar way, between `_:! Type` and `template _:! Type`.

The rest of the design for statically-sized arrays is deferred to a separate
proposal, because it's not relevant to variadics.

### Pack expansions

`...,`, `...and`, and `...or` are prefix unary expression operators with the
same precedence as the corresponding non-pack operators. They are single tokens,
and may not contain internal whitespace. `...{` is an opening delimiter that
forms a balanced pair with `}`, and can contain any number of `;`-delimited
statements. An AST rooted at any of these operations is called a _pack
expansion_. A pack expansion cannot occur within another pack expansion,
although we may relax this restriction in the future.

### Packs

**NOTE TO READER:** I was initially trying to specify variadics in the same kind
of way we specify other features, in terms of recursive expression evaluation,
statement execution, etc. I subsequently shifted to specifying the runtime
semantics of variadic expression and statement semantics in terms of textual
rewriting, while still trying to specify more traditional semantics for
typechecking (because that happens before the rewriting would take place) and
pattern matching (because rewriting just doesn't work there). This section
mostly reflects that earlier approach, and I'm not sure how much of it is still
relevant.

FIXME reassess if we still need pack values, once we have description of pattern
matching. Discussion of pack-type variables may be another reason we need it.
Even if we need them for that, we may not need them to be a separate category of
values; they could be tuple values, with different semantics imposed by the
type.

A _pack type_ is a kind of product type, like a tuple, and a value of a pack
type is called a _pack_. A pack type is itself a pack whose elements are types,
in the same way that a tuple type is itself a tuple whose elements are types. A
pack cannot be a sub-value of any other kind of value, although we intend to
support nested packs in the future. A name can be bound to a pack value, but
only if the name is local to a function.

Pack values are created using the `[:]` operator, which is a prefix unary
operator with the same precedence as unary `*`. If its operand is a tuple or
statically-sized array, its result is a pack containing the same elements, with
the same element types. For example,
`[:]("a" as String, "b" as String, "c" as String)` is a pack whose type is
`[:](String, String, String)`, and whose elements are `"a"`, `"b"`, and `"c"`.
`[:]` can also be applied to a statically-sized array type: `[:][T; N]` is a
pack type with `N` elements that are all `T`. Thus, the type of
`[:]("a", "b", "c")` could also be written `[:][String; 3]`. A pack type which
can be written this way is called a _homogeneous_ pack type.

There is no Carbon syntax for indexing into a pack. When we need to refer to
pack elements as part of specifying their semantics, we will use the notation
P<sub>k</sub> to refer to the kth element of the pack P.

In a pattern context, the `[:]` operator can also be applied to a name binding
pattern that has a tuple or statically-sized array type. FIXME find better home
for this?

The operand of `[:]` cannot contain a `[:]` operator, although we intend to
support this in the future as part of supporting nested packs. FIXME better home
for this too?

FIXME can nesting restrictions be evaded using deduced parameters, which are
semantically but not syntactically nested within the pattern?

FIXME I think we need to allow packs within other types in patterns, to support
cases like `vectors: Vector([:]ElementTypes)`, where `ElementTypes` is a deduced
parameter with type `[Type;]`.

### Expression and statement semantics

The expression and statement semantics of packs and pack expansions will be
specified in terms of a procedure for rewriting ASTs containing those tokens to
equivalent ASTs that do not. These rewrites take place at the same time as
monomorphization of generic functions, which means they take place after name
resolution and typechecking. The rules for typechecking these operations will be
explained in a subsequent section.

A usage of a `[:]` operator, or of a name that is bound to a variable with a
pack type, is called an _expansion argument_. It can only occur inside a pack
expansion, and it acts as an argument to the nearest enclosing pack expansion.
Every pack expansion must have at least one argument, and all arguments of a
given pack expansion must have the same number of elements, which we will call
the _arity_ of the pack expansion. An expansion argument is _unbound_ in a given
context if its pack expansion is outside that context. For example, in the
statement `...{ result.Append(([:]params).ToString()); }`, the argument
`[:]params` is unbound within `result.Append(([:]params).ToString());` or any
subexpression of it.

A pack expansion with arity N is rewritten to N instances of the expansion,
where in the Kth instance, every expansion argument is replaced by the Kth
element of that argument. The details of the rewrite vary slightly depending on
the root node of the expansion:

-   In a `...{` expansion, each instance uses a `{` in place of the opening
    `...{`.
-   In a `...,`, `...and`, or `...or` expansion, each instance has the expansion
    operator removed, and the instances are joined using the corresponding
    non-expansion operator.

An `...and` expansion with arity 0 is rewritten to `true` and an `...or`
expansion with arity 0 is rewritten to `false` (the identities of the respective
logical operations). A `...,` expansion with arity 0 is rewritten to `,`, and
any `,` immediately before or after the expansion is removed.

Even though an `[:]` operator can only appear within a pack expansion, it is
possible to apply these rewrite semantics to an isolated subexpression that
contains a `[:]` operator but not the enclosing pack operator. In those cases,
the result of the rewrite is an expression headed by a `[:]` operator, which
means that its value is a pack. Thus, we can say that
`([:]("a", "b", "c"), [:](1, 2, 3))` rewrites to
`[:](("a", 1), ("b", 2), ("c", 3))`.

### Pattern semantics

Pack expansions can also appear in patterns. The semantics are chosen to follow
the general principle that pattern matching is the inverse of expression
evaluation, so for example if the pattern `(..., [:]x: String)` matches some
scrutinee value `s`, the expression `(..., [:]x)` should be equal to `s`.

These are run-time semantics, so the scrutinee expression is fully evaluated
(doesn't contain pack expansions).

**NOTE TO READER:** This section is specifying run-time semantics, but I'm
paying special attention to the conditions for pattern irrefutability because
that's going to be an important property when typechecking variadic patterns.

_Tuple pattern:_

There can be no more than one `...,` pattern in a tuple pattern.

The N elements of the pattern before the `...,` expansion are matched with the
first N elements of the scrutinee, and the M elements of the pattern after the
`...,` expansion are matched with the last M elements of the scrutinee. If the
scrutinee does not have at least N + M elements, the pattern does not match. The
operand of the `...,` pattern is iteratively matched with each of the remaining
K scrutinee elements, if any. The iterations are numbered sequentially from 1 to
K, and the number of the current iteration is called the _pack index_.

Observe that the pattern is irrefutable for a given scrutinee type if:

-   At most one `...,` pattern
-   Scrutinee type is a tuple type with at least N + M elements
-   First N and last M pattern elements are irrefutable given the corresponding
    scrutinee element types
-   For all I from 1 to K, the `...,` operand pattern with pack index I is
    irrefutable given the type of the Ith scrutinee element. (Note that the
    typechecker doesn't know K)

_Identifier that names a deduced parameter_

The deduced parameter is unified with the scrutinee value.

Pattern is irrefutable for a given scrutinee type if:

-   Unification does not reach a contradiction.

The typechecker must also ensure that the deduced value is a valid value of the
deduced parameter type.

_Name binding pattern:_

If the type subpattern contains a use of the `[:]` operator that is unbound
within the name binding pattern (as in `vectors: Vector([:]ElementTypes)`, the
name binding pattern behaves as if it were prefixed with `[:]` (see the rules
for `[:]` patterns below).

Otherwise, if the pattern is inside a pack expansion, but not inside a pack
argument pattern, the program is ill-formed, because the name would be bound
multiple times. For example, in `(..., (foo: i32, bar: [:]Ts))`, `foo: i32` is
ill-formed because it would match a value like
`((1, "foo"), (2, "bar"), (3, "baz"))`, and bind the name `foo` to `1`, `2`, and
`3` simultaneously, which is nonsensical.

Name binding patterns are always irrefutable at run-time. However, typechecker
must also ensure the bound value is a valid value of the binding type.

_`[:]` pattern:_

A `[:]` pattern consists of a `[:]` token and a single operand expression.

FIXME maybe distribute these to the sections above?

Let I be the current pack index.

-   If the operand is a tuple pattern, as with `[:](x: i32, y: String)`, it
    cannot contain a `...,` pattern, so all elements are explicit. The Ith
    element of the tuple pattern is matched with the scrutinee.
-   If the operand is an identifier that names a deduced parameter, as with
    `[:]ElementTypes` in
    `fn Zip[ElementTypes:! [Type;]] (..., vectors: Vector([:]ElementTypes))`,
    the parameter must be bound to a K-tuple value (although it may have array
    or pack _type_), and its Ith element is unified with the scrutinee.
-   If the operand is a name binding pattern, as with `[:]params: T`, the name
    must be bound to a K-tuple value, and its Ith element is bound to the
    scrutinee.
-   If the operand is an expression pattern, as with `[:]x` where `x` is not a
    deduced parameter, match the Ith element of its value against the scrutinee.

Pattern is irrefutable for a given scrutinee type if:

-   (tuple pattern) the Ith element of the tuple pattern is irrefutable for the
    scrutinee type
-   (identifier that names a deduced parameter) unification does not reach a
    contradiction
-   (name binding pattern) true
-   (expression pattern) false

Typechecker must also ensure the bound value (if any) is a valid value of the
binding type.

#### Example

Suppose we are evaluating a function call `Zip(x, y, z)`, with `Zip` declared as
above:

```carbon
fn Zip[ElementTypes:! [Type;]](..., vectors: Vector([:]ElementTypes))
```

This requires matching the scrutinee `(x, y, z)` against the pattern
`[ElementTypes:! [Type;]](..., vectors: Vector([:]ElementTypes))`. This is a
tuple pattern, so the subpattern `vectors: Vector([:]ElementTypes)` is
iteratively matched against each element of `(x, y, z)`. That subpattern is a
name binding with an unbound `[:]` in the type subpattern, so we apply the rule
for name bindings prefixed with `[:]`. That dictates that `vectors` is bound to
a 3-tuple, whose Ith element is bound to the value of the Ith iteration's
scrutinee. Thus, the elements of `vectors` are bound to `x`, `y`, and `z`.

### Typechecking

Typechecking takes place prior to the rewrites specified above, so we need to
specify how the non-rewritten code is typechecked.

FIXME: need to match up each argument with its expansion, and check that all
arguments have the same arity. Could be tricky if arity is symbolic.

#### Variadic types

A _variadic type_ is a pattern that matches types, and that contains at least
one expansion argument whose value is unknown. For example, `[:](_:! [Type;])`
and `(..., [:](_:! [Type;]))` are variadic types. Once the expansion argument
values are known, a variadic type can be evaluated, producing a non-variadic
type. Evaluating a variadic type yields a pack type if and only if the variadic
type contains an unbound argument.

Consequently, the most specific type of a value is never variadic. Variadic
types are necessary only prior to monomorphization, as the types of certain
patterns and expressions that depend on generic parameters. In this respect,
variadic types are much like types that depend on generic parameters, such as
`[T:! Type](Optional(T))`. In particular, variadic types are typically not
types-of-types, but are more like the union of an infinite family of
types-of-values.

A variadic type is _homogeneous_ if every unknown expansion argument has a type
that is either:

-   an array type,
-   a non-variadic tuple type whose elements are all equal,
-   a variadic tuple type of the form `(..., T)` where `T` is homogeneous, or
-   a non-tuple homogeneous variadic type.

FUTURE WORK: relax the typechecking rules below to cover non-homogeneous
variadic types.

For any homogeneous variadic type, we can construct a corresponding
_representative type_ which is not variadic, for use in typechecking. A
representative for a type `T` is constructed as follows:

-   If `T` is a homogeneous variadic type, the representative behaves like a
    type formed by replacing each unknown expansion argument with a
    representative of its type.
-   If `T` is an array type, the representative behaves like a representative of
    its element type.
-   If `T` is a non-variadic type-of-types, the representative is a unique
    archetype for `T` (as discussed in the generics design).
-   Otherwise, if `T` is not variadic, the representative is `T` itself.

A representative that "behaves like" another type is still distinct from that
type. This permits us to perform the reverse transformation, from a type that
contains representatives back to a variadic type.

#### Expressions

**`[:]` expressions:**

If the type of its operand is a tuple or statically-sized array type `T`, the
expression has type `[:]T`. If its operand _is_ a statically-sized array type
`[T; N]`, the expression has type `[:][U; N]`, where `U` is the type of `T`
(FIXME do we need this?).

**`...and` and `...or` expressions:**

An `...and` or `...or` expression has type `bool`. Its operand must have type
`[:][bool;]` or `[:][bool; N]` for some constant `N`.

**Tuple literals and the `...,` operator:**

A tuple literal consists of some nonnegative number of leading elements,
optionally followed by a single use of the `...,` operator, whose operand is
called the _expansion element_, and then some nonnegative number of trailing
elements. The type of a tuple literal `L` is another tuple literal, whose
leading and trailing elements are the types of the leading and trailing elements
of `L`, and whose expansion element is the type of the expansion element of `L`
(if any).

**Other expressions with variadic operands:**

Any other expression that has at least one operand with a variadic type is
typechecked as follows: first, we replace each variadic type with a
corresponding non-variadic representative type, and perform name resolution and
typechecking in terms of those types. Then, if the resulting type for the whole
expression contains any representative types, they are replaced with the
original types they represented. Finally, if any of the variadic types were
unbound, and the type of the whole expression would be a non-variadic type `T`,
it is instead given the type `[:][T;]`.

FIXME: That last step feels super ad-hoc, but without it, cases like
`(..., vectors.Size())` don't come out right. But _with_ it, cases like
`...{ len += vectors.Size(); }` don't come out right. Maybe we need to
distinguish expression from statement expansions? Maybe allow expansion with no
arguments once we've determined the (symbolic) arity? Maybe we give up on
assigning a type to subexpressions inside an expansion? (Ick)

#### Patterns

Typechecking for a pattern matching operation proceeds in three phases:

1. The pattern is typechecked, and assigned a type.
2. The scrutinee expression is typechecked, and assigned a type.
3. The scrutinee type is checked against the pattern type.

If the pattern appears in a context that requires it to be irrefutable, such as
the parameter list of a function declaration, phase 3 ensures that the pattern
can match _any_ possible value of the scrutinee expression. Otherwise, it
ensures that the pattern can match _some_ possible value of the scrutinee
expression. For simplicity, this proposal will focus on the rules for the first
case, since it's by far the most important for variadics.

FUTURE WORK: specify rules for refutable matching of variadics, for example to
support C++-style recursive variadics.

This section will focus on phase 3. Phase 2 was described above, and phase 1 is
generally quite mechanical, even when the pattern is variadic, so I will not
describe it in detail here. By way of illustration, the type of
`(..., [:]params: [i64;])` is `(..., [:][i64;])`, and the type of
`[ElementTypes:! [Type;]](..., vectors: Vector([:]ElementTypes))` is
`[ElementTypes:! [Type;]](..., Vector([:]ElementTypes))`.

If the pattern type has any deduced parameters, phase 3 is responsible for
deducing them. However, when the scrutinee occurs in a generic context, the
results of this deduction may not be concrete values, but rather symbolic
expressions in terms of the unknown parameters of the scrutinee. For example:

```
fn F[T:! Type](T: arg);

fn G[U:! Type](Optional(U): arg) {
  F(arg);
}
```

When typechecking the expression `F(arg)`, phase 3 deduces that at that
callsite, `T` is equal to `Optional(U)`, even though it cannot yet deduce the
value of `U`.

A variadic pattern will usually have one or more deduced parameters whose type
is an array of unknown size. The size can be deduced, but if the scrutinee
occurs in a generic context, that deduced size may itself be a symbolic
expression rather than a concrete number. As a result, the deduced "value" of
such an array can be fairly complex. In the most general case, it consists of
some number of leading elements, some number of trailing elements, and an
"expansion element" representing all of the other elements. Each of these
elements can be a symbolic expression in terms of the unknown parameters of the
scrutinee, and also in terms of a special "expansion index" symbolic variable,
which represents the position of the current element in the symbolic array.

If the pattern type is not a variadic type, pattern matching follows the usual
non-variadic rules (which usually means that a variadic scrutinee type would be
rejected), so we will focus on the semantics of phase 3 when the pattern type is
a variadic type. Variadic types are themselves patterns, so we will break this
down into cases based on the possible forms of a pattern.

##### Tuple type

FIXME too much nesting

At type checking time, we don't necessarily know which parameters each argument
will match with, or the other way around. For example, consider the following
code:

```carbon
fn F(a: i32, ..., [:]b: [i32;], c: i32);

fn G(..., [:]x: [i32;]) {
  F(1, 2, ..., [:]x);
}
```

If `x` is empty, the `2` will match with `c`, and otherwise the `2` will match
with an element of `b`. Similarly, if `x` is not empty, its last element will
match `c`, and the remaining elements (if any) will match elements of `b`.
However, at type-checking time we don't know the size of `x` yet, so we don't
know which will occur. On the other hand, the `1` will always match `a`.

In general, we want type checking to fail if any possible monomorphization of
the generic code would fail to typecheck. In this case that means we want type
checking to fail if any of the potential argument-parameter mappings could fail
to typecheck after monomorphization. Furthermore, for reasons of readability as
well as efficiency, we want type checking to fail if any two potential mappings
would deduce inconsistent values for any deduced parameter. However, in general
this is intractable, because the number of distinct ways to map argument
expressions to parameters is exponential in the number of variadic arguments.

Introducing type deduction further complicates the situation. For example:

```carbon
fn H[Ts:! [type;]](a: i32, ..., [:]b: Ts, c: String) -> (..., [:]Ts);

external impl P as ImplicitAs(i32);
external impl Q as ImplicitAs(String);

fn I(x: [i32;], y: [f32;], z: [String;]) {
  var result: auto = H(..., [:]x, {} as P, ..., [:]y, {} as Q, ..., [:]z);
}
```

Here, the deduced type of `result` can have one of four different forms. The
most general case is
`(..., [:][i32;], P, ..., [:][f32;], Q, ..., [:][String;])`, and the other three
cases are formed by omitting the prefix ending with `P` and/or the suffix
starting with `Q` (corresponding to the cases where `x` and/or `z` are empty).
Extending the type system to support deduction that splits into multiple cases
would add a fearsome amount of complexity to the type system.

###### Identifying potential matchings

Our solution will rely on being able to identify which parameters can
potentially match which arguments. We can do so as follows:

We will refer to the elements of the tuple pattern as "parameters", and the
elements of the scrutinee expression as "argument expressions". We will reserve
the term "arguments" for the elements of the scrutinee after monomorphization,
so a single argument expression may correspond to any number of arguments,
including zero (but only if the expression is variadic). If any variadic
argument expressions have sizes that are known at typechecking time, we will
treat them as a sequence of that many non-variadic argument expressions.

A tuple pattern consists of N leading parameters, optionally followed by a
variadic parameter headed by the `...,` operator, and then M trailing
parameters. The scrutinee type must be a tuple type, and can have any number of
variadic elements.

There must be at least N+M non-variadic argument expressions, because otherwise
if all variadic argument expressions are empty, there will not be enough
arguments to match all the non-variadic parameters. We will refer to the Nth
non-variadic argument expression and the argument expressions before it as
"leading argument expressions". Similarly, we will refer to the Mth-from-last
non-variadic argument expression and the argument expressions after it as
"trailing argument expressions", and any remaining argument expressions as
"central argument expressions". A "leading argument" is an argument that was
produced by rewriting a leading argument expression, and likewise for "central
argument" and "trailing argument".

By construction, there will always be at least N leading arguments, because
there are N non-variadic leading argument expressions. Likewise, there will
always be at least M trailing arguments. As a result, a leading parameter can
only match a leading argument, and so it can only match a leading argument
expression, and likewise for trailing parameters. Consequently, a leading
argument expression cannot match a trailing parameter, a trailing argument
expression cannot match a leading parameter, and a central argument expression
can only match the variadic parameter.

Consider the i'th non-variadic leading argument expression E. If all the
variadic argument expressions before it are empty, E will match the i'th leading
parameter, so E cannot match any earlier parameter. If there are any earlier
variadic argument expressions, E can be made to match any later leading
parameter or the variadic parameter, by making one of those earlier variadic
arguments large enough, but as observed above, E cannot match a trailing
parameter. If there are no earlier variadic argument expressions, E cannot be
made to match any later parameter, so it can only match the i'th leading
parameter.

Next, consider a variadic leading argument expression E that comes before the
i'th non-variadic leading argument expression, but not before any earlier
non-variadic argument expression. If E's rewritten size is sufficiently large,
and all earlier variadic argument expressions are empty, it will simultaneously
match the i'th leading parameter, all leading parameters after it, and the
variadic parameter, but as before, it cannot match a trailing parameter.

The same reasoning can be applied to trailing argument expressions, but with
"before" and "after" reversed. And as noted earlier, central argument
expressions can only match the variadic parameter. In summary, we can identify
the possible matches for an argument expression E as follows:

-   If E is leading, let i be one more than the number of earlier non-variadic
    argument expressions:
    -   If E is non-variadic, and there are no earlier variadic argument
        expressions, then E can only match the i'th leading parameter.
    -   Otherwise, E can match the i'th leading parameter, any later leading
        parameters, and the variadic parameter.
-   If E is trailing, let i be one more than the number of later non-variadic
    argument expressions:
    -   If E is non-variadic, and there are no later variadic argument
        expressions, then E can only match the i'th trailing parameter from the
        end.
    -   Otherwise, E can match the i'th trailing parameter from the end, any
        earlier trailing parameters, and the variadic parameter.
-   Otherwise, E can only match the variadic parameter.

###### The type-checking algorithm

In order to avoid type deduction that splits into multiple cases, we require
that if the variadic parameter has a deduced type that is used in more than one
place (as `Ts` is in the earlier example of this problem), all variadic
arguments must have a known size (which means, as noted earlier, that we will
expand them into a sequence of non-variadic arguments for type-checking
purposes). This ensures that we can deduce the value of the array
element-by-element in the cases where we will need to use that deduced value.

> **Open question:** Is that restriction too strict? If so, it may be possible
> to forbid only situations that would actually cause type deduction to split
> into multiple cases. As well as being much less restrictive, that would avoid
> the need to give special treatment to deduced arrays that are used only once.
> It would still disallow cases like the call to `H` above, but that call seems
> unnatural for reasons that seem closely related to the fact that its type
> splits into cases.

To avoid the potential for exponential blow-up, we will use a much more
tractable conservative approximation of the precise algorithm. We type-check each
parameter as follows:

-   If the parameter is variadic, we check it against the concatenated types of
    all argument expressions that it could potentially match. The rule stated
    above ensures that this is safe: the concatenated type can only become
    visible outside this local type-check if all variadic arguments have a known
    size, in which case those concatenated types are known to be exactly
    correct.
-   Otherwise:
    -   If there is only one argument it can match, which is also not variadic,
        we type-check the argument against the parameter in the ordinary way.
    -   Otherwise:
        -   If the parameter has a non-deduced type, we check each potential
            argument against that type.
        -   Otherwise, we check that all potential arguments have the same type,
            and then check that type against the parameter.

> **Open question:** When deducing a single type from a sequence of types, can
> and should we relax the requirement that all types in the sequence are the
> same? We can identify the common type of a pair of types using
> `CommonTypeWith`, but it is not clear whether or how we can generalize that to
> a sequence of types, since it might not be associative.

We believe that if the code type checks successfully under this algorithm, any
possible monomorphization can type check using the types deduced here, because
the restrictions imposed here are a superset of the restrictions that any
monomorphization needs to satisfy, and the information available to type
deduction here is a subset of the information that would be available after
monomorphization.

##### Parameterized class type

If the pattern and scrutinee types name the same parameterized class, the
scrutinee type argument list is checked against the pattern type argument list.
Otherwise, typechecking fails.

##### Identifier that names a deduced parameter

FIXME

##### Name binding pattern

FIXME

##### `[:]` pattern

FIXME

#### Statements

FIXME

## Rationale

TODO: How does this proposal effectively advance Carbon's goals? Rather than
re-stating the full motivation, this should connect that motivation back to
Carbon's stated goals and principles. This may evolve during review. Use links
to appropriate sections of [`/docs/project/goals.md`](/docs/project/goals.md),
and/or to documents in [`/docs/project/principles`](/docs/project/principles).
For example:

-   [Community and culture](/docs/project/goals.md#community-and-culture)
-   [Language tools and ecosystem](/docs/project/goals.md#language-tools-and-ecosystem)
-   [Performance-critical software](/docs/project/goals.md#performance-critical-software)
-   [Software and language evolution](/docs/project/goals.md#software-and-language-evolution)
-   [Code that is easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write)
-   [Practical safety and testing mechanisms](/docs/project/goals.md#practical-safety-and-testing-mechanisms)
-   [Fast and scalable development](/docs/project/goals.md#fast-and-scalable-development)
-   [Modern OS platforms, hardware architectures, and environments](/docs/project/goals.md#modern-os-platforms-hardware-architectures-and-environments)
-   [Interoperability with and migration from existing C++ code](/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code)

## Alternatives considered

TODO: What alternative solutions have you considered?

-   FIXME multiple `...,` patterns in a tuple
-   FIXME
    [disallow named packs](https://github.com/carbon-language/carbon-lang/issues/1162)

### Use postfix instead of prefix operators

`...` is a postfix operator in C++, and `[:]` is a postfix operator in C++
proposal P1858R2. Furthermore, in both cases postfix position is arguably more
natural: postfix `...` aligns with the natural-language usage of "…", and
postfix `[:]` aligns with C++ and Carbon's subscripting syntax. So it would
probably be less surprising to make their Carbon counterparts postfix as well.
However, this turns out to be an awkward fit for Carbon. Consider this example:

```
fn SumInts(..., [:]params: [i64;]) -> i64
```

If `[:]` and `...,` were suffix operators, this would instead be:

```
fn SumInts(params: [i64;][:] ...,) -> i64
```

But this is ambiguous about whether the `[:]` operator applies to
`params: [i64;]` or just `[i64;]`, so we need to add a set of parentheses:

```
fn SumInts((params: [i64;])[:] ...,) -> i64
```

To state the point more generally: when an expression mixes prefix and suffix
operators, their order is determined by precedence and parentheses, which is
usually less readable than relying on the linear order of operators with the
same fixity. The binding operator `:` is effectively a prefix operator (because
its left-hand side is a single token), so if `[:]` is a suffix operator, code
that mixes the two will be somewhat harder to read. That's a particular problem
because, as our motivating examples illustrate, variadic function signatures
will often have those two operators in close conjunction, and readability is at
a premium in function signatures.

C solved a very similar problem with mixing prefix `*` and postfix `.` by
introducing a separate `->` operator. We could in principle solve this issue the
same way, introducing a separate "variadic binding operator" `$`, such that
`params$ [i64;]` is equivalent to `(params: [i64;])[:]`. However, this would
trade a readability problem for a teachability problem, by introducing more
syntax that programmers need to learn before they can even read variadic
function signatures.
