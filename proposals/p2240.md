# Variadics

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/2240)

<!-- toc -->

## Table of contents

-   [Abstract](#abstract)
-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
    -   [Examples](#examples)
-   [Details](#details)
    -   [Statically sized arrays](#statically-sized-arrays)
    -   [Pack expansions](#pack-expansions)
    -   [Expression and statement semantics](#expression-and-statement-semantics)
    -   [Symbolic expression semantics and pack values](#symbolic-expression-semantics-and-pack-values)
    -   [Pattern semantics](#pattern-semantics)
        -   [Example](#example)
    -   [Typechecking](#typechecking)
        -   [Pattern matching](#pattern-matching)
            -   [Identifying potential matchings](#identifying-potential-matchings)
            -   [The type-checking algorithm](#the-type-checking-algorithm)
-   [Rationale](#rationale)
-   [Alternatives considered](#alternatives-considered)
    -   [Use postfix instead of prefix operators](#use-postfix-instead-of-prefix-operators)

<!-- tocstop -->

**NOTE TO READER:** This is a very rough draft, because I'm still trying to pin
down the ideas it's describing. As a result, it's not well-structured for
reading, and it's probably not even internally consistent. I have inserted some
notes like this one to try to provide some guidance.

## Abstract

TODO

## Problem

Carbon needs a way to define functions and parameterized types that are
_variadic_, meaning they can take a variable number of arguments.

## Background

C has long supported variadic functions (such as `printf`), but that mechanism
is heavily disfavored in C++ because it isn't type-safe. Instead, C++ provides a
separate feature for defining variadic _templates_, which can be functions,
classes, or even variables. However, variadic templates currently suffer from
several shortcomings. Most notably:

-   They must be templates, which mean they typically must be defined in header
    files, are susceptible to code bloat due to template instantiation, and
    generally carry all the other costs associated with templating.
-   It is inordinately difficult to define a variadic function whose parameters
    have a fixed type, and the signature of such a function does not clearly
    communicate that fixed type to readers.
-   There is no procedural mechanism for iterating through a variadic parameter
    list. Although features like
    [fold expressions](https://en.cppreference.com/w/cpp/language/fold) cover
    some special cases, the only fully general way to express iteration is with
    recursion, which is often awkward, and results in more template
    instantiations.

There are a number of pending C++ standard proposals to address these issues,
and improve variadic templates in other ways, such as
[P1306R1: Expansion Statements](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1306r1.pdf),
[P1858R2: Generalized Pack Declaration and Usage](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1858r2.html),
and
[P2277R0: Packs Outside of Templates](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2277r0.html).
P1858R2 has been especially influential for this proposal.

## Proposal

**NOTE TO READER:** This section is the oldest part of this document. I've made
some cursory attempts to bring it up to date, but if there's a conflict between
this and the Details section, the version in Details is probably closer to my
current thinking.

`[T; N]` is the type of a statically-sized array of N objects of type `T`. Other
syntaxes like `[N; T]` would also work; it just needs to be concise, and feel
core-language enough that we can use it in patterns. `[T;]` is a shorthand for
`[T; _ :! BigInt]`.

The pack operators `...,`, `...and`, and `...or` are prefix unary operators with
the same precedence as the corresponding non-pack operators. They are single
tokens, and may not contain internal whitespace. A _pack expansion_ consists of
a pack operator together with its operand, which is called the _pack template_.
A pack template must contain at least one usage of the prefix unary operator
`[:]`, whose operand, called a _pack argument_, must be a tuple or
statically-sized array. All arguments of a given pack expansion must have the
same arity. A pack expansion whose arguments have arity N is rewritten to N
copies of the pack template, where in the Kth copy, each use of the `[:]`
operator evaluates to the Kth element of its operand. Each copy is followed by a
separator, and the entire sequence is followed by a terminator, as determined by
the pack operator:

| Pack operator | Separator | Terminator |
| ------------- | --------- | ---------- |
| `...,`        | `,`       | (none)     |
| `...and`      | `and`     | `true`     |
| `...or`       | `or`      | `false`    |

As a consequence, a `...,` pack expansion can only occur where a tuple literal
element is expected, or directly inside parentheses, and in the latter case, the
parentheses form a tuple, even if the pack argument has only one element.

A pack expansion block has the form `...{` _statements_ `}`, and is rewritten to
N copies of the pack template `{` statements `}`, with pack arguments
substituted as above. `...{` is a single token, and may not contain internal
whitespace.

Pack expansions currently cannot be nested.

The spelling of `[:]` is taken from the C++ proposal
[P1858R2](http://wg21.link/P1858R2), but I'm very open to alternatives.

### Examples

```carbon
// Computes the sum of its arguments, which are i64s
fn SumInts(..., [:]params: [i64;]) -> i64 {
  var sum: i64 = 0;
  for (var i: i64 in params) {
    sum += i;
  }
  return sum;
}
```

```carbon
// Concatenates its arguments, which are all convertible to String
fn StrCat[T:! [ConvertibleToString;]](..., [:]params: T) -> String {
  var len: i64 = 0;
  ...{ len += ([:]params).Length(); }
  var result: String = "";
  result.Reserve(len);
  ...{ result.Append(([:]params).ToString()); }
  return result;
}
```

```carbon
// Returns the minimum of its arguments, which must all have the same type T.
//
// Note that this implementation is not recursive. We split the parameters into
// first and rest in order to forbid calling `Min` with no arguments.
fn Min[T:! Comparable & Value](first: T, ..., [:]rest: [T; N]) -> T {
  var result: T = first;
  for (var x: T in rest) {
    if (x < result) {
      result = x;
    }
  }
  return result;
}
```

```carbon
// Invokes f, with the tuple `args` as its arguments.
fn Apply[T:! [Type;], F:! CallableWith(..., [:]T)](f: F, args: (..., [:]T)) -> auto {
  return f(..., [:]args);
}
```

```carbon
fn Zip[ElementTypes:! [Type;]]
      (..., vectors: Vector([:]ElementTypes))
      -> Vector((..., [:]ElementTypes)) {
  var iters: auto = (..., vectors.Begin());
  var result: Vector((..., [:]ElementTypes));
  while (...and [:]iters != vectors.End()) {
    result.push_back((..., *[:]iters));
    ...{ ([:]iters)++; }
  }
  return result;
}
```

```carbon
// Toy example of mixing packs and values in a single parameter list.
// Takes an i64, any number of f64s, and then another i64.
fn MiddleVariadic(first: i64, ..., [:]middles: [f64;], last: i64);
```

```carbon
// Toy example of using the result of variadic type deduction.
fn TupleConcat[T1s: [Type;], T2s: [Type;]](
    t1: (..., [:]T1s), t2: (..., [:]T2s)) -> (..., [:]T1s, ..., [:]T2s) {
  return (..., [:]t1, ..., [:]t2);
}
```

## Details

### Statically sized arrays

`[T; N]` is the type of a statically-sized array of `N` objects of type `T`, and
`[T;]` is a pattern that matches the type `[T; N]` for any `N`. In other words,
it's a shorthand for `[T; _:! BigInt]`. Consequently, for purposes of symbolic
evaluation and typechecking, we will assume that all statically-sized array
types have a size, although that size may be a symbolic value rather than a
constant.

FIXME Or maybe we should treat it as an interface/constraint? See
https://discord.com/channels/655572317891461132/969001583088123905/973681495891910716
Or maybe it's `[T; template _:! BigInt]` so that we can validly refactor it to
`[template N:! BigInt]([T; N])`? `auto` seems like it might be ambivalent in a
similar way, between `_:! Type` and `template _:! Type`.

An array can be initialized from a tuple, so long as the tuple has the right
number of elements, and all element types are convertible to the array element
type. We do not support deducing the element type of an array, as in
`fn F[T:! Type](array: [T;]);`, for the same reason that we do not support
`fn F[T:! Type](x: T, y: T)`. This limitation may be addressed in future work.

The rest of the design for statically-sized arrays is deferred to a separate
proposal, because it's not relevant to variadics.

### Pack expansions

`...,`, `...and`, and `...or` are prefix unary expression operators with the
same precedence as the corresponding non-pack operators. They are single tokens,
and may not contain internal whitespace. `...{` is an opening delimiter that
forms a balanced pair with `}`, and can contain any number of `;`-delimited
statements. An AST rooted at any of these operations is called a _pack
expansion_. A pack expansion cannot occur within another pack expansion,
although we may relax this restriction in the future.

### Expression and statement semantics

FIXME do we still need this for expressions, given that we need a different
formulation for symbolic evaluation?

The expression and statement semantics of packs and pack expansions will be
specified in terms of a procedure for rewriting ASTs containing those tokens to
equivalent ASTs that do not. These rewrites take place at the same time as
monomorphization of generic functions, which means they take place after name
resolution and typechecking. The rules for typechecking these operations will be
explained in a subsequent section.

A usage of a `[:]` operator, or of a name that is bound to a variable with a
pack type, is called an _expansion argument_. It can only occur inside a pack
expansion, and it acts as an argument to the nearest enclosing pack expansion.
Every pack expansion must have at least one argument, and all arguments of a
given pack expansion must have the same number of elements, which we will call
the _arity_ of the pack expansion. An expansion argument is _unbound_ in a given
context if its pack expansion is outside that context. For example, in the
statement `...{ result.Append(([:]params).ToString()); }`, the argument
`[:]params` is unbound within `result.Append(([:]params).ToString());` or any
subexpression of it.

A pack expansion with arity N is rewritten to N instances of the expansion,
where in the Kth instance, every expansion argument is replaced by the Kth
element of that argument. The details of the rewrite vary slightly depending on
the root node of the expansion:

-   In a `...{` expansion, each instance uses a `{` in place of the opening
    `...{`.
-   In a `...,`, `...and`, or `...or` expansion, each instance has the expansion
    operator removed, and the instances are joined using the corresponding
    non-expansion operator.

An `...and` expansion with arity 0 is rewritten to `true` and an `...or`
expansion with arity 0 is rewritten to `false` (the identities of the respective
logical operations). A `...,` expansion with arity 0 is rewritten to `,`, and
any `,` immediately before or after the expansion is removed.

Even though an `[:]` operator can only appear within a pack expansion, it is
possible to apply these rewrite semantics to an isolated subexpression that
contains a `[:]` operator but not the enclosing pack operator. In those cases,
the result of the rewrite is an expression headed by a `[:]` operator, which
means that its value is a pack. Thus, we can say that
`([:]("a", "b", "c"), [:](1, 2, 3))` rewrites to
`[:](("a", 1), ("b", 2), ("c", 3))`.

### Symbolic expression semantics and pack values

Under some circumstances, a variadic expression must be evaluated symbolically,
because the values of one or more of its expansion arguments is not yet known.
For example, this is often needed when variadic operations are used in a type
position. To support that, we need to introduce some new kinds of values to
represent the inputs and outputs of indefinite variadic operations.

A _pack element_ represents a sequence of an indefinite number of values that
all match a single pattern. The pattern and the size of the sequence are
represented as
[symbolic values](/docs/design/README.md#value-categories-and-value-phases) (or
constants). (FIXME: The term "pattern" can be kind of confusing in actual usage.
It's also arguably a category error: these things relate to patterns in roughly
the same way that values relate to expressions.) The symbolic value representing
the pattern may use special variables called _representatives_, which represent
the components of the pattern that can vary across values in the sequence.
Consequently, the scope of a representative is the pack element it appears in,
rather than some lexical scope. As their name suggests, pack elements cannot
occur on their own, but only as an element of an enclosing pack.

A _pack_ is a value consisting of a sequence of pack elements. Pack values are
always assumed to be normalized, meaning that every element's size is either a
symbolic value that names a single variable, or a constant 1 (FIXME explain how
we can ensure this is the case). The _shape_ of a pack is another pack, which is
found by replacing each element's pattern with `()`. A _pack type_ is the type
of a pack, and can be represented as a pack value whose element patterns match
types. The type of a pack is found by replacing each of its element's patterns
with the type of that element's pattern. Thus, the relationship between packs
and pack types is much the same as between tuples and tuple types.

During symbolic evaluation, a tuple value consists of a sequence of pack
elements, just like a pack. In other words, tuple types and pack types have the
same sets of values, and differ only in the operations they support. Name
bindings can have pack types, but only if they are local to a single function.

Most operations that are defined on scalar values are defined on packs as well,
with the following semantics: all operands that are packs must have the same
shape, and the result of the operation will itself have the same shape as the
operands. The element patterns are computed by iterating through the input packs
and applying the non-pack version of the operation: the pattern of the k'th
output element is the result of replacing each input pack with the pattern of
its k'th element, and evaluating the resulting operation using the ordinary
non-pack rules.

If a tuple literal does not contain `...,`, its evaluation follows the rules for
arbitrary operations described earlier. If it does contain `...,`, the result is
a tuple value formed by iterating through the literal elements:

-   If the element is headed by `...,`, we evaluate its operand to produce a
    pack, and append its elements to the result tuple.
-   Otherwise, we evaluate the element expression to produce a value `V`, and
    append a pack element with pattern `V` and size 1 to the result tuple.

The `[:]` operator transforms a tuple into a pack, or an unknown tuple value
into a pack of unknown values:

-   When the operand is a tuple value, the result is a pack value that's
    identical to the tuple value.
-   When the operand is a symbolic variable whose type is a tuple, the result is
    a pack with the same shape as the tuple. Each element's pattern is a
    representative whose type is the pattern of the corresponding element of the
    tuple.

For these purposes, an array type `[T; N]` is treated as a tuple type
`(..., [:][T; N])`, so:

-   When the operand is an array type `[T; N]`, the result is a pack consisting
    of a single pack element `..., [:][T; N]`
-   When the operand is a symbolic variable with type `[T; N]`, the result is a
    pack consisting of a single pack element whose pattern is a representative
    whose type is `T`.

An identifier expression that names a variable of pack type behaves like a `[:]`
expression whose operand is a variable of the corresponding tuple type. No other
leaf AST node can evaluate to a pack value.

A tuple cannot be indexed unless all of its pack elements have size 1. There is
no syntax for indexing into a pack.

### Pattern semantics

Pack expansions can also appear in patterns. The semantics are chosen to follow
the general principle that pattern matching is the inverse of expression
evaluation, so for example if the pattern `(..., [:]x: String)` matches some
scrutinee value `s`, the expression `(..., [:]x)` should be equal to `s`.

These are run-time semantics, so the scrutinee expression is fully evaluated
(doesn't contain pack expansions), and the values of any deduced parameters are
known. We will assume that the values of all deduced parameters have been
substituted back into the pattern.

FIXME make this driven by the pattern type rather than the pattern syntax?

**NOTE TO READER:** This section is specifying run-time semantics, but I'm
paying special attention to the conditions for pattern irrefutability because
that's going to be an important property when typechecking variadic patterns.

_Tuple pattern:_

There can be no more than one `...,` pattern in a tuple pattern.

The N elements of the pattern before the `...,` expansion are matched with the
first N elements of the scrutinee, and the M elements of the pattern after the
`...,` expansion are matched with the last M elements of the scrutinee. If the
scrutinee does not have at least N + M elements, the pattern does not match. The
operand of the `...,` pattern is iteratively matched with each of the remaining
K scrutinee elements, if any. The iterations are numbered sequentially from 1 to
K, and the number of the current iteration is called the _pack index_.

Observe that the pattern is irrefutable for a given scrutinee type if:

-   At most one `...,` pattern
-   Scrutinee type is a tuple type with at least N + M elements
-   First N and last M pattern elements are irrefutable given the corresponding
    scrutinee element types
-   For all I from 1 to K, the `...,` operand pattern with pack index I is
    irrefutable given the type of the Ith scrutinee element. (Note that the
    typechecker doesn't know K)

_Name binding pattern:_

If the type subpattern contains a use of the `[:]` operator that is unbound
within the name binding pattern (as in `vectors: Vector([:]ElementTypes)`, the
name binding pattern behaves as if it were prefixed with `[:]` (see the rules
for `[:]` patterns below).

FIXME: rephrase in terms of the _evaluated_ type value rather than the syntax?

Otherwise, if the pattern is inside a pack expansion, but not inside a pack
argument pattern, the program is ill-formed, because the name would be bound
multiple times. For example, in `(..., (foo: i32, bar: [:]Ts))`, `foo: i32` is
ill-formed because it would match a value like
`((1, "foo"), (2, "bar"), (3, "baz"))`, and bind the name `foo` to `1`, `2`, and
`3` simultaneously, which is nonsensical.

Name binding patterns are always irrefutable at run-time. However, typechecker
must also ensure the bound value is a valid value of the binding type.

_`[:]` pattern:_

A `[:]` pattern consists of a `[:]` token and a single operand expression.

FIXME maybe distribute these to the sections above?

Let I be the current pack index.

-   If the operand is a tuple pattern, as with `[:](x: i32, y: String)`, it
    cannot contain a `...,` pattern, so all elements are explicit. The Ith
    element of the tuple pattern is matched with the scrutinee.
-   If the operand is an identifier that names a deduced parameter, as with
    `[:]ElementTypes` in
    `fn Zip[ElementTypes:! [Type;]] (..., vectors: Vector([:]ElementTypes))`,
    the parameter must be bound to a K-tuple value (although it may have array
    or pack _type_), and its Ith element is unified with the scrutinee. FIXME as
    above, this isn't really a pattern.
-   If the operand is a name binding pattern, as with `[:]params: T`, the name
    must be bound to a K-tuple value, and its Ith element is bound to the
    scrutinee.
-   If the operand is an expression pattern, as with `[:]x` where `x` is not a
    deduced parameter, match the Ith element of its value against the scrutinee.

Pattern is irrefutable for a given scrutinee type if:

-   (tuple pattern) the Ith element of the tuple pattern is irrefutable for the
    scrutinee type
-   (identifier that names a deduced parameter) unification does not reach a
    contradiction
-   (name binding pattern) true
-   (expression pattern) false

Typechecker must also ensure the bound value (if any) is a valid value of the
binding type.

#### Example

Suppose we are evaluating a function call `Zip(x, y, z)`, with `Zip` declared as
above:

```carbon
fn Zip[ElementTypes:! [Type;]](..., vectors: Vector([:]ElementTypes))
```

This requires matching the scrutinee `(x, y, z)` against the pattern
`[ElementTypes:! [Type;]](..., vectors: Vector([:]ElementTypes))`. This is a
tuple pattern, so the subpattern `vectors: Vector([:]ElementTypes)` is
iteratively matched against each element of `(x, y, z)`. That subpattern is a
name binding with an unbound `[:]` in the type subpattern, so we apply the rule
for name bindings prefixed with `[:]`. That dictates that `vectors` is bound to
a 3-tuple, whose Ith element is bound to the value of the Ith iteration's
scrutinee. Thus, the elements of `vectors` are bound to `x`, `y`, and `z`.

### Typechecking

Typechecking takes place prior to the rewrites specified above, so we need to
specify how the non-rewritten code is typechecked.

The rules of variadic typechecking for expressions are the same as the rules of
variadic symbolic evaluation described earlier, but applied to the types of
expressions instead of the values of expressions. For example, for most
operations, if any of the operands have a pack type, all pack-type operands must
have the same shape, the type of the whole operation will have the same shape,
and the element types are found by iterating through the input pack types
element-wise, performing ordinary scalar type-checking for the operation.

Typechecking a variadic pattern is much like typechecking a variadic expression:
we proceed bottom-up, generalizing the scalar typechecking rules to apply
element-wise to variadics, and so forth. The most notable difference is that
patterns can contain name bindings, whose types are determined by symbolically
evaluating the type portion of the binding.

We can generalize the expression rules to support statements as well, by
treating statements as having types, in a restricted way: the type of a
statement is either `()` or a pack where all element patterns are `()`. In other
words, statement types only carry information about pack shape.

With that in place, we can apply essentially the same rule: if any of the child
AST nodes has a pack type, all child nodes with pack type must have the same
shape. If the parent statement is a `...{}` block, it will have type `()` (and
there must be at least one child with a pack type), and otherwise its type will
be the shape of the pack-type children (or `()` if there are none).

#### Pattern matching

Typechecking for a pattern matching operation proceeds in three phases:

1. The pattern is typechecked, and assigned a type.
2. The scrutinee expression is typechecked, and assigned a type.
3. The scrutinee type is checked against the pattern type.

If the pattern appears in a context that requires it to be irrefutable, such as
the parameter list of a function declaration, phase 3 ensures that the pattern
can match _any_ possible value of the scrutinee expression. Otherwise, it
ensures that the pattern can match _some_ possible value of the scrutinee
expression. For simplicity, this proposal will focus on the rules for the first
case, since it's by far the most important for variadics.

FUTURE WORK: specify rules for refutable matching of variadics, for example to
support C++-style recursive variadics.

Phases 1 and 2 were described earlier, so we only need to describe phase 3. We
will focus on the forms of symbolic type that are introduced or modified in this
proposal: array types, tuple types, and pack types.

An array type pattern `[T; N]` matches an array type scrutinee `[U; M]` if `T`
matches `U` and `N` matches `M`. It can also match a tuple scrutinee type if the
tuple's pack element patterns all match `T`, and the sum of the tuple's pack
element sizes matches `N`.

A tuple type pattern matches an array type scrutinee `[T; N]` if it matches the
corresponding tuple type `(..., [:][T; N])`. A tuple type pattern matches a
tuple type scrutinee if the corresponding pack types match.

Pack types only match with other pack types, but doing so correctly is
difficult, because the packs may not have the same shape. As a consequence, we
don't necessarily know which pattern pack elements each scrutinee pack element
will match with, or the other way around. For example, consider the following
code:

```carbon
fn F(a: i32, ..., [:]b: [i32;], c: i32);

fn G(..., [:]x: [i32;]) {
  F(1, 2, ..., [:]x);
}
```

If `x` is empty, the `2` will match with `c`, and otherwise the `2` will match
with an element of `b`. Similarly, if `x` is not empty, its last element will
match `c`, and the remaining elements (if any) will match elements of `b`.
However, at type-checking time we don't know the size of `x` yet, so we don't
know which will occur. On the other hand, the `1` will always match `a`.

In general, we want type checking to fail if any possible monomorphization of
the generic code would fail to typecheck. In this case that means we want type
checking to fail if any of the potential argument-parameter mappings could fail
to typecheck after monomorphization. Furthermore, for reasons of readability as
well as efficiency, we want type checking to fail if any two potential mappings
would deduce inconsistent values for any deduced parameter. However, in general
this is intractable, because in the worst case the number of distinct ways to
map symbolic arguments to parameters is ${2n \choose n}$ for n variadic
arguments, which only a factor of $\sqrt{n}$ away from exponential.

Introducing type deduction further complicates the situation. For example:

```carbon
fn H[Ts:! [type;]](a: i32, ..., [:]b: Ts, c: String) -> (..., [:]Ts);

external impl P as ImplicitAs(i32);
external impl Q as ImplicitAs(String);

fn I(x: [i32;], y: [f32;], z: [String;]) {
  var result: auto = H(..., [:]x, {} as P, ..., [:]y, {} as Q, ..., [:]z);
}
```

Here, the deduced type of `result` can have one of four different forms. The
most general case is
`(..., [:][i32;], P, ..., [:][f32;], Q, ..., [:][String;])`, and the other three
cases are formed by omitting the prefix ending with `P` and/or the suffix
starting with `Q` (corresponding to the cases where `x` and/or `z` are empty).
Extending the type system to support deduction that splits into multiple cases
would add a fearsome amount of complexity to the type system.

##### Identifying potential matchings

Our solution will rely on being able to identify which pattern pack elements can
potentially match which scrutinee pack elements. We can do so as follows:

We will refer to the elements of the pack pattern as "parameters", and the
elements of the scrutinee expression as "symbolic arguments". We will use the
term "actual arguments" to refer to the elements of the scrutinee after
monomorphization, so a single symbolic argument may correspond to any number of
actual arguments, including zero (but only if the expression is variadic). Note
that throughout this discussion, "parameters" and "arguments" are always types;
we will sometimes say "parameter type" or "argument type" when there is a risk
of confusion (FIXME there might still be too much risk of confusion, especially
because we shift to more conventional meanings for "argument" and "parameter" in
the next section). We will refer to arguments and parameters as "scalar" if they
have size 1, and "variadic" if they have indeterminate size (these are the only
possibilities, because packs are normalized).

A pack pattern consists of N leading scalar parameters, optionally followed by a
variadic parameter headed by the `...,` operator, and then M trailing scalar
parameters. The scrutinee type must be a pack type, and can have any number of
scalar and variadic elements, in any order.

There must be at least N+M scalar symbolic arguments, because otherwise if all
variadic symbolic arguments are empty, there will not be enough arguments to
match all the scalar parameters. We will refer to the Nth scalar symbolic
argument and the symbolic arguments before it as "leading symbolic arguments".
Similarly, we will refer to the Mth-from-last scalar symbolic argument and the
symbolic arguments after it as "trailing symbolic arguments", and any remaining
symbolic arguments as "central symbolic arguments". A "leading argument" is an
argument that was produced by rewriting a leading symbolic argument, and
likewise for "central argument" and "trailing argument".

By construction, there will always be at least N leading actual arguments,
because there are N scalar leading symbolic arguments. Likewise, there will
always be at least M trailing actual arguments. As a result, a leading parameter
can only match a leading actual argument, and so it can only match a leading
symbolic argument, and likewise for trailing parameters. Consequently, a leading
symbolic argument cannot match a trailing parameter, a trailing symbolic
argument cannot match a leading parameter, and a central symbolic argument can
only match the variadic parameter.

Consider the i'th scalar leading symbolic argument E. If all the variadic
symbolic arguments before it are empty, E will match the i'th leading parameter,
so E cannot match any earlier parameter. If there are any earlier variadic
symbolic arguments, E can be made to match any later leading parameter or the
variadic parameter, by making one of those earlier variadic arguments large
enough, but as observed above, E cannot match a trailing parameter. If there are
no earlier variadic symbolic arguments, E cannot be made to match any later
parameter, so it can only match the i'th leading parameter.

Next, consider a variadic leading symbolic argument E that comes before the i'th
scalar leading symbolic argument, but not before any earlier scalar symbolic
argument. If E's rewritten size is sufficiently large, and all earlier variadic
symbolic arguments are empty, it will simultaneously match the i'th leading
parameter, all leading parameters after it, and the variadic parameter, but as
before, it cannot match a trailing parameter.

The same reasoning can be applied to trailing symbolic arguments, but with
"before" and "after" reversed. And as noted earlier, central symbolic arguments
can only match the variadic parameter. In summary, we can identify the possible
matches for a symbolic argument E as follows:

-   If E is leading, let i be one more than the number of earlier scalar
    symbolic arguments:
    -   If E is scalar, and there are no earlier variadic argument expressions,
        then E can only match the i'th leading parameter.
    -   Otherwise, E can match the i'th leading parameter, any later leading
        parameters, and the variadic parameter.
-   If E is trailing, let i be one more than the number of later scalar symbolic
    arguments:
    -   If E is scalar, and there are no later variadic symbolic arguments, then
        E can only match the i'th trailing parameter from the end.
    -   Otherwise, E can match the i'th trailing parameter from the end, any
        earlier trailing parameters, and the variadic parameter.
-   Otherwise, E can only match the variadic parameter.

##### The type-checking algorithm

In order to avoid type deduction that splits into multiple cases, we require
that if the variadic parameter type's pattern names a deduced parameter with an
array type that is used in more than one place (as `Ts` is in the earlier
example of this problem), all variadic arguments must have a known size (which
means, as noted earlier, that we will expand them into a sequence of scalar
arguments for type-checking purposes). This ensures that we can deduce the value
of the array element-by-element in the cases where we will need to use that
deduced value.

FIXME the above paragraph is one place where the nonstandard definition of
parameter could make trouble.

> **Open question:** Is that restriction too strict? If so, it may be possible
> to forbid only situations that would actually cause type deduction to split
> into multiple cases. As well as being much less restrictive, that would avoid
> the need to give special treatment to deduced arrays that are used only once.
> It would still disallow cases like the call to `H` above, but that call seems
> unnatural for reasons that seem closely related to the fact that its type
> splits into cases.

To avoid a combinatorial explosion, we will use a much more tractable
conservative approximation of the precise algorithm. We type-check each
parameter as follows:

-   If the parameter is variadic, we check it against the sub-pack consisting of
    all symbolic arguments that it could potentially match. The rule stated
    above ensures that this is safe: the concatenated type can only become
    visible outside this local type-check if all variadic arguments have a known
    size, in which case that sub-pack is known to be exactly correct.
-   Otherwise:
    -   If there is only one argument it can match, which is also not variadic,
        we type-check the argument against the parameter in the ordinary way.
    -   Otherwise:
        -   If the parameter has a non-deduced type, we check each potential
            argument against that type.
        -   Otherwise, we check that all potential arguments have the same type,
            and then check that type against the parameter.

> **Open question:** When deducing a single type from a sequence of types, can
> and should we relax the requirement that all types in the sequence are the
> same? We can identify the common type of a pair of types using
> `CommonTypeWith`, but it is not clear whether or how we can generalize that to
> a sequence of types, since it might not be associative.

We believe that if the code type checks successfully under this algorithm, any
possible monomorphization can type check using the types deduced here, because
the restrictions imposed here are a superset of the restrictions that any
monomorphization needs to satisfy, and the information available to type
deduction here is a subset of the information that would be available after
monomorphization.

## Rationale

TODO: How does this proposal effectively advance Carbon's goals? Rather than
re-stating the full motivation, this should connect that motivation back to
Carbon's stated goals and principles. This may evolve during review. Use links
to appropriate sections of [`/docs/project/goals.md`](/docs/project/goals.md),
and/or to documents in [`/docs/project/principles`](/docs/project/principles).
For example:

-   [Community and culture](/docs/project/goals.md#community-and-culture)
-   [Language tools and ecosystem](/docs/project/goals.md#language-tools-and-ecosystem)
-   [Performance-critical software](/docs/project/goals.md#performance-critical-software)
-   [Software and language evolution](/docs/project/goals.md#software-and-language-evolution)
-   [Code that is easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write)
-   [Practical safety and testing mechanisms](/docs/project/goals.md#practical-safety-and-testing-mechanisms)
-   [Fast and scalable development](/docs/project/goals.md#fast-and-scalable-development)
-   [Modern OS platforms, hardware architectures, and environments](/docs/project/goals.md#modern-os-platforms-hardware-architectures-and-environments)
-   [Interoperability with and migration from existing C++ code](/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code)

## Alternatives considered

TODO: What alternative solutions have you considered?

-   FIXME multiple `...,` patterns in a tuple
-   FIXME
    [disallow named packs](https://github.com/carbon-language/carbon-lang/issues/1162)

### Use postfix instead of prefix operators

`...` is a postfix operator in C++, and `[:]` is a postfix operator in C++
proposal P1858R2. Furthermore, in both cases postfix position is arguably more
natural: postfix `...` aligns with the natural-language usage of "…", and
postfix `[:]` aligns with C++ and Carbon's subscripting syntax. So it would
probably be less surprising to make their Carbon counterparts postfix as well.
However, this turns out to be an awkward fit for Carbon. Consider this example:

```
fn SumInts(..., [:]params: [i64;]) -> i64
```

If `[:]` and `...,` were suffix operators, this would instead be:

```
fn SumInts(params: [i64;][:] ...,) -> i64
```

But this is ambiguous about whether the `[:]` operator applies to
`params: [i64;]` or just `[i64;]`, so we need to add a set of parentheses:

```
fn SumInts((params: [i64;])[:] ...,) -> i64
```

To state the point more generally: when an expression mixes prefix and suffix
operators, their order is determined by precedence and parentheses, which is
usually less readable than relying on the linear order of operators with the
same fixity. The binding operator `:` is effectively a prefix operator (because
its left-hand side is a single token), so if `[:]` is a suffix operator, code
that mixes the two will be somewhat harder to read. That's a particular problem
because, as our motivating examples illustrate, variadic function signatures
will often have those two operators in close conjunction, and readability is at
a premium in function signatures.

C solved a very similar problem with mixing prefix `*` and postfix `.` by
introducing a separate `->` operator. We could in principle solve this issue the
same way, introducing a separate "variadic binding operator" `$`, such that
`params$ [i64;]` is equivalent to `(params: [i64;])[:]`. However, this would
trade a readability problem for a teachability problem, by introducing more
syntax that programmers need to learn before they can even read variadic
function signatures.
