# Bitwise and shift operators

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/1191)

<!-- toc -->

## Table of contents

-   [Problem](#problem)
-   [Background](#background)
    -   [Overflow in shift operators](#overflow-in-shift-operators)
-   [Proposal](#proposal)
-   [Details](#details)
-   [Rationale](#rationale)
-   [Alternatives considered](#alternatives-considered)
    -   [Don't provide an xor operator](#dont-provide-an-xor-operator)
    -   [Use `~` for complement](#use--for-complement)
    -   [Provide different operators for arithmetic and logical shifts](#provide-different-operators-for-arithmetic-and-logical-shifts)
    -   [Provide rotate operators](#provide-rotate-operators)

<!-- tocstop -->

## Problem

Carbon needs operations for working with bit representations of values.

## Background

C++ provides four bitwise operations for Boolean algebra: complement (`~`), and
(`&`), or (`|`), and xor (`^`). These are all useful in bit-maipulation code
(although `^` is used substantially less than the others). In addition, C++
provides two bit-shift operators `<<` and `>>` that can perform three different
operations: left shift, arithmetic right shift, and logical right shift. The
meaning of `>>` is determined by the signedness of the first operand.

C and Swift use the same set of operators as C++. Rust uses most of the same
operators, but uses `!` instead of `~` for complement, unifying it with the
logical not operator, which is spelled `not` in Carbon and as `!` in Rust and
C++.

In addition to the operators provided by C and C++, bit-rotate operators are
present in some languages, and a short notation for them may be convenient.
Finally, there are other non-degenerate binary Boolean operations with no common
operator symbol:

-   The "implies" operator (equivalent to `~a | b`).
-   The "implied by" operator (equivalent to `a | ~b`).
-   The complement of each of the other operators (NAND, NOR, XNOR, "does not
    imply", "is not implied by").

### Overflow in shift operators

The behavior of shift operators in C++ had a turbulent past. The behavior of
shift operators has always been undefined if the right operand is out of range
-- not between zero inclusive and the bit-width of the left operator exclusive
-- but other restrictions have varied:

-   Unsigned left shift has never had any restrictions on the first operand.
-   For signed left shift:
    -   In C++98, the result was fully unspecified.
    -   In C++11, the result was specified only if the first operand was
        non-negative and the result fit into the destination type -- that is, if
        no 1 bit is shifted into the sign bit.
    -   In C++14, the result was specified only if the first operand was
        non-negative and the result fit into the unsigned type corresponding to
        the destination type -- that is, if no 1 bit is shifted out of the sign
        bit.
    -   In C++20 onwards, there are no restrictions beyond a range restriction
        on the right operand, and the result is otherwise always specified, even
        if the left operand is negative.
-   Unsigned right shift has never had any restrictions on the first operand.
-   For signed right shift:
    -   In C++17 and earlier, if the left operand is negative, the result is
        implementation-defined.
    -   In C++20 onwards, the result is always specified, even if the left
        operand is negative.

There is a clear trend towards defining more cases, following two's complement
rules.

## Proposal

Use the same operator set as C++, but replace `~` with unary prefix `^`.

Define the behavior for all cases of `<<` and `>>` except where the right
operand is either negative or is greater than or equal to the bit-width of the
left operand.

## Details

See changes to the design, and in particular
[the new section on bitwise and shift operators](/docs/design/expressions/bitwise.md).

## Rationale

-   [Performance-critical software](/docs/project/goals.md#performance-critical-software)
    -   Bit operations are important low-level primitives. Providing operators
        for them is important in order to allow low-level high-performance code
        to be written elegantly in Carbon.
    -   By not defining semantics for `<<` and `>>` when the right-hand operand
        is out of range, we can directly use hardware instructions for these
        operations whose behavior in these cases vary between architectures.
-   [Code that is easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write)
    -   Using operator notation rather than function call notation for bitwise
        operators improves readability in code making heavy use of these
        operations.
-   [Practical safety and testing mechanisms](/docs/project/goals.md#practical-safety-and-testing-mechanisms)
    -   Carbon follows C++ in treating `<<` and `>>` as programming errors when
        the right hand operand is out of range, but Carbon guarantees that such
        errors will not directly result in unbounded misbehavior in hardened
        builds.
-   [Modern OS platforms, hardware architectures, and environments](/docs/project/goals.md#modern-os-platforms-hardware-architectures-and-environments)
    -   All hardware architectures we care to support are natively two's
        complement architectures, and that assumption allows us to define the
        semantics of shift operators in the way that makes the most sense for
        such architectures.
    -   Our bitwise operations make no assumptions about the endianness of the
        hardware architecture, although the shift operators make the most sense
        on a little-endian or big-endian architecture, which are the only
        endiannesses we expect to see in modern hardware platforms.
-   [Interoperability with and migration from existing C++ code](/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code)
    -   The same set of operators is provided as in C++, making it easy for
        programmers and programs to migrate, with the exception that the `~`
        operator is mechanically replaced with `^`. This change is expected to
        be easy for programmers to accommodate, especially given that Rust's
        choice to replace `~` with `!` does not seem to be a source of sustained
        complaints.
    -   The extensiblity support reflects the full scope of operator overloading
        in C++, permitting separate overloading of each of the bitwise operators
        with custom return types. This should allow smooth interoperability with
        C++ overloaded operators.

## Alternatives considered

### Don't provide an xor operator

We considered omitting the `^` operator, providing this functionality in some
other way, such as a named function or an `xor` keyword. The primary motivation
was avoiding spending a precious operator character on a relatively uncommon
operation. However, we did not want to apply the same change to `&` and `|`, and
it seemed important to maintain consistency between the three binary bitwise
operators from C++.

In addition, we decided to use `^` for complement, so if we avoided using `^`
for xor we would need to find a different solution for `^`.

### Use `~` for complement

We could follow C++ and use `~` as the complement operator. However, using `~`
for this purpose spends a precious operator character on a relatively uncommon
operation, and `~` is often visually confusible with `-`, creating the potential
for readability problems.

We found `^` to be a satisfying alternative with a good rationale and mnemonic:
`^` is a bit-flipping operator -- `a ^ b` flips the bits in `a` that are
specified in `b` -- and complement is an operator that flips _all_ the bits.
`^a` is equivalent to `a ^ n`, where `n` is the all-one-bits value in the type
of `a`.

### Provide different operators for arithmetic and logical shifts

We could provide different operators for arithmetic right shift and logical
right shift. This might allow programmers to better express their intent.
However, it seems unnecessary, as using the type of the left operand is a
strategy that doesn't appear to have caused significant problems in practice in
the languages that have followed it.

Basing the kind of shift on the signedness of the left operand also follows from
viewing a negative number as having an infinite number of leading 1 bits, which
is the underlying mathematical model behind the two's complement representation.

### Provide rotate operators

We could provide bitwise rotation operators. However, there doesn't seem to be a
sufficient need to justify adding another operator symbol for this purpose.
