# C++ Interop: Reserved identifiers

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/2029)

<!-- toc -->

## Table of contents

-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Details](#details)
-   [Rationale](#rationale)
-   [Alternatives considered](#alternatives-considered)

<!-- tocstop -->

## Problem

C++ reserves certain sets of identifiers for implementation-specific use. Carbon
must ensure it respects these reserved identifiers to enable seamless and
error-free interoperability with C++. Equally, it would be prudent to define a
set of identifiers which are reserved for internal Carbon implementation usage.

## Background

The full set of C++ reserved identifiers is listed
[here](https://en.cppreference.com/w/cpp/language/identifiers). This proposal is
solely considering the set of user-definable identifiers which are considered
names in C++:

-   Identifiers with a double underscore anywhere are reserved;
-   Identifiers that begin with an underscore followed by an uppercase letter
    are reserved;
-   Identifiers that begin with an underscore are reserved in the global
    namespace.

Considerations for reserved keywords are discussed in
[p0093](https://github.com/carbon-language/carbon-lang/pull/93).

## Proposal

Carbon reserves the following identifiers in the specified contexts:

-   Identifiers with a double underscore anywhere are reserved;
-   Identifiers that begin with an underscore followed by an uppercase letter
    are reserved.

Carbon toolchains are expected to emit an error when a reserved identifier is
encountered. This will remove the risk of undefined / unexpected runtime
behaviour, or name resolution clashes when linking with C++ libraries.

## Details

This proposal makes use of three assumptions:

1. A Carbon package exporting a C++ header will be scoped in a C++ namespace
   following the package name;
2. All C++ imports to Carbon will exist within the package `Cpp` which
   represents the root of the C++ global namespace.
3. The default Carbon package can not be exported to C++, following the
   [no other library can import this library even from within the default package](/docs/design/README.md#files-libraries-packages)
   rule.

The stated reserved identifiers for Carbon ensure that there will be no
user-defined identifier clashes between Carbon and C++ in either
interoperability direction. As Carbon does not have a global namespace, and
assumption 2 above explicitly gives the C++ global namespace a named scope
within Carbon, there is no need to consider a Carbon equivalent of the C++
_Identifiers that begin with an underscore are reserved in the global namespace_
reservation.

## Rationale

This proposal supports the
[Interoperability with and migration from existing C++ code](/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code)
goal. It also provides a reserved identifier space for Carbon internal
implementation specifics.

## Alternatives considered

It was considered to not place any user-visible restrictions on identifiers, and
handle conflict resolution or avoidance at interop boundaries. This was
dismissed as this would require automatic re-writing of reserved-in-C++
identifiers, deferring identification of name resolution issues to link time, or
allowing undefined behaviour to occur.

Re-writing identifiers raises a number of issues: This would need strong
guarantees to be deterministic across compilation units; it would result in
unexpected-to-the-user identifiers being present when using binary inspection
tools; it would need programmers to track re-written names manually in C++ code
importing Carbon export headers; and would add complication to tooling to
provide user-friendly interpretation of the re-written identfiers (especially
for debugging).

Undefined behaviour due to unrecognised identifier clashes would be counter to
the seamless C++ interoperability goal.
