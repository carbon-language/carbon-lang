# Generics details 7: final impls

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/983)

<!-- toc -->

## Table of contents

-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Details](#details)
-   [Rationale based on Carbon's goals](#rationale-based-on-carbons-goals)
-   [Alternatives considered](#alternatives-considered)

<!-- tocstop -->

## Problem

Allowing an impl to be specialized can lead to higher performance if there are
parameter values for which a more optimized version can be written. However, not
all impls will be specialized and there are some benefits when that is known:

-   The values of associated types can be assumed to come from the impl. In many
    cases this means leaking fewer implementation details into the signature of
    a function using generics.
-   The bodies of functions from the impl could be inlined into the caller.

However, not all impls can opt-out of specialization, since this can create
incompatibilities between unrelated libraries. For example, consider two
libraries that both import parameterized type `TA` and interface `I`:

-   Library `LB` that defines type `TB` can define an impl with type structure
    `impl TA(TB, ?) as I`.
-   Library `LC` that defines type `TC` can define an impl with type structure
    `impl TA(?, TC) as I`.

Both of these are allowed under
[Carbon's current orphan rules](/docs/design/generics/details.md#orphan-rule). A
query for the implementation of `I` by `TA(TB, TC)` would use the definition
from library `LB`, which would be a conflict if library `LC` marked its impl
definition as not specializable.

## Background

Rust currently does not support specialization, so for backwards compatibility
impls are final by default in Rust's specialization proposal.

## Proposal

We propose that impls can be declared `final`, but only in libraries that must
be imported by any file that would otherwise be able to define a higher-priority
impl.

## Details

Details are in
[the added `final` impl section to the generics details design document](/docs/design/generics/details.md#final-impls).

## Rationale based on Carbon's goals

This proposal supports the following of Carbon's goals:

-   [Performance-critical software](/docs/project/goals.md#performance-critical-software) -
    the ability to inline functions defined in `final` impls will in some cases
    improve performance
-   [Software and language evolution](/docs/project/goals.md#software-and-language-evolution) -
    reducing the implementation details exposed in a generic function's
    signature allows that function to evolve
-   [Code that is easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write) -
    reducing the list of requirements in a generic function signature is an
    improvement to both readability and writability.

## Alternatives considered

TODO: What alternative solutions have you considered?
