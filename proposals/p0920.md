# Generic blanket impls (details 5)

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/920)

<!-- toc -->

## Table of contents

-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Details](#details)
-   [Rationale based on Carbon's goals](#rationale-based-on-carbons-goals)
-   [Alternatives considered](#alternatives-considered)
    -   [Orphan rule could consider interface requirements in blanket impls](#orphan-rule-could-consider-interface-requirements-in-blanket-impls)

<!-- tocstop -->

## Problem

TODO: What problem are you trying to solve? How important is that problem? Who
is impacted by it?

## Background

TODO: Is there any background that readers should consider to fully understand
this problem and your approach to solving it?

## Proposal

TODO: Briefly and at a high level, how do you propose to solve the problem? Why
will that in fact solve it?

## Details

TODO: Fully explain the details of the proposed solution.

## Rationale based on Carbon's goals

TODO: How does this proposal effectively advance Carbon's goals? Rather than
re-stating the full motivation, this should connect that motivation back to
Carbon's stated goals for the project or language. This may evolve during
review. Use links to appropriate goals, for example:

-   [Community and culture](/docs/project/goals.md#community-and-culture)
-   [Language tools and ecosystem](/docs/project/goals.md#language-tools-and-ecosystem)
-   [Performance-critical software](/docs/project/goals.md#performance-critical-software)
-   [Software and language evolution](/docs/project/goals.md#software-and-language-evolution)
-   [Code that is easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write)
-   [Practical safety and testing mechanisms](/docs/project/goals.md#practical-safety-and-testing-mechanisms)
-   [Fast and scalable development](/docs/project/goals.md#fast-and-scalable-development)
-   [Modern OS platforms, hardware architectures, and environments](/docs/project/goals.md#modern-os-platforms-hardware-architectures-and-environments)
-   [Interoperability with and migration from existing C++ code](/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code)

## Alternatives considered

TODO: What alternative solutions have you considered?

This conditional interface implementation syntax was decided in
[issue #575](https://github.com/carbon-language/carbon-lang/issues/575).
Additional context for alternatives considered are in
[an appendix](appendix-impl-syntax.md).

### Orphan rule could consider interface requirements in blanket impls

The orphan rule states that a rule like

```
impl [T:! Interface1] T as Interface2 { ... }
```

can only live in the library that defines `Interface2`, not the library that
defines `Interface1`. To see that the alternative is not coherent, consider this
example where we have three libraries, with one a common library imported by the
other two:

-   Library `Common`

    ```
    interface ICommon { ... }
    struct S { ... }
    ```

-   Library `A`:

    ```
    import Common
    interface IA { ... }
    // Local interface only used as a constraint
    impl [T:! IA] T as ICommon { ... }
    // Fine: implementation of a local interface
    impl S as IA { ... }
    ```

-   Library `B`:

    ```
    import Common
    interface IB { ... }
    // Local interface only used as a constraint
    impl [T:! IB] T as ICommon { ... }
    // Fine: implementation of a local interface
    impl S as IB { ... }
    ```

Insid another library imports the `Common` library:

-   Does `S` implement `ICommon`? If you just import `ICommon`, no
    implementations are visible
-   Does the answer change if you import libraries `A` or `B`?
-   Which implementation of `ICommon` should `S` use if you import both?

We avoid these problems by requiring the use of a local type or interface
outside of constraints.
