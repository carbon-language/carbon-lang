# Generic blanket impls (details 5)

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/920)

<!-- toc -->

## Table of contents

-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Details](#details)
-   [Rationale based on Carbon's goals](#rationale-based-on-carbons-goals)
-   [Alternatives considered](#alternatives-considered)
    -   [Different syntax](#different-syntax)
    -   [Orphan rule could consider interface requirements in blanket impls](#orphan-rule-could-consider-interface-requirements-in-blanket-impls)
    -   [Child trumps parent rule](#child-trumps-parent-rule)
    -   [Impls could limit specialization](#impls-could-limit-specialization)
    -   [Libraries for orphan impls](#libraries-for-orphan-impls)

<!-- tocstop -->

## Problem

FIXME: What problem are you trying to solve? How important is that problem? Who
is impacted by it?

## Background

FIXME: Is there any background that readers should consider to fully understand
this problem and your approach to solving it?

## Proposal

FIXME: Briefly and at a high level, how do you propose to solve the problem? Why
will that in fact solve it?

## Details

FIXME: Fully explain the details of the proposed solution.

## Rationale based on Carbon's goals

FIXME: How does this proposal effectively advance Carbon's goals? Rather than
re-stating the full motivation, this should connect that motivation back to
Carbon's stated goals for the project or language. This may evolve during
review. Use links to appropriate goals, for example:

-   [Community and culture](/docs/project/goals.md#community-and-culture)
-   [Language tools and ecosystem](/docs/project/goals.md#language-tools-and-ecosystem)
-   [Performance-critical software](/docs/project/goals.md#performance-critical-software)
-   [Software and language evolution](/docs/project/goals.md#software-and-language-evolution)
-   [Code that is easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write)
-   [Practical safety and testing mechanisms](/docs/project/goals.md#practical-safety-and-testing-mechanisms)
-   [Fast and scalable development](/docs/project/goals.md#fast-and-scalable-development)
-   [Modern OS platforms, hardware architectures, and environments](/docs/project/goals.md#modern-os-platforms-hardware-architectures-and-environments)
-   [Interoperability with and migration from existing C++ code](/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code)

## Alternatives considered

### Different syntax

FIXME

This conditional interface implementation syntax was decided in
[issue #575](https://github.com/carbon-language/carbon-lang/issues/575).
Additional context for alternatives considered are in
[an appendix](appendix-impl-syntax.md).

### Orphan rule could consider interface requirements in blanket impls

The orphan rule states that a rule like

```
impl [T:! Interface1] T as Interface2 { ... }
```

can only live in the library that defines `Interface2`, not the library that
defines `Interface1`. To see that the alternative is not coherent, consider this
example where we have three libraries, with one a common library imported by the
other two:

-   Library `Common`

    ```
    interface ICommon { ... }
    struct S { ... }
    ```

-   Library `A`:

    ```
    import Common
    interface IA { ... }
    // Local interface only used as a constraint
    impl [T:! IA] T as ICommon { ... }
    // Fine: implementation of a local interface
    impl S as IA { ... }
    ```

-   Library `B`:

    ```
    import Common
    interface IB { ... }
    // Local interface only used as a constraint
    impl [T:! IB] T as ICommon { ... }
    // Fine: implementation of a local interface
    impl S as IB { ... }
    ```

Insid another library imports the `Common` library:

-   Does `S` implement `ICommon`? If you just import `ICommon`, no
    implementations are visible
-   Does the answer change if you import libraries `A` or `B`?
-   Which implementation of `ICommon` should `S` use if you import both?

We avoid these problems by requiring the use of a local type or interface
outside of constraints.

### Child trumps parent rule

[Rust has considered a "child trumps parent" rule](http://aturon.github.io/tech/2017/02/06/specialization-and-coherence/).
This rule would say that a library `Child` importing library `Parent` is enough
to prioritize `impl` definitions in `Child` over `Parent` when they would
otherwise overlap without one matching a strict subset of the other. The goal
would be to resolve overlaps in a way that is both easy to understand and more
often matches what implementations users actually want prioritized.

One caveat of this rule is that a simple interpretation is not transitive. If we
define three impls in three different libraries, with these type structures:

-   `impl (A, ?, ?) as I`
-   `impl (?, B, ?) as I`
-   `impl (?, ?, C) as I`

then the type structure rule would prioritize `A` over `B` over `C`. If the
library with `C` had a dependency on the one with `A`, though, then `C` would
have priority over `A`, and we would not be able to decide which impl to use for
`(A, B, C)`.

The fix is to change the rule to be "Child trumps parent on their intersection".
With that rule, it would be as if there was another implementation defined on
the intersection of `(A, ?, ?)` and `(?, ?, C)`, that is it would match
`(A, ?, C)`, that had the highest priority and delegated to the `(?, ?, C)` impl
for the definition of the body.

Without some child trumps parent rule: If I define a new type, then all impl
lookup for interfaces implemented by that type as `Self` will consider impl from
my library first, at the time I define it until some other library adds an impl
of that type as `Self`. However, adding the "child trumps parent on their
intersection" rule removes this property.

This is something we would consider in the future once we have more experience.
Note that this rule has not yet been implemented in Rust, so we don't know how
it works out in practice.

### Impls could limit specialization

This would allow greater reasoning in generic functions, requiring less
specification. For example, there may be a blanket implementation of
`PartiallyOrdered` provided for types that implement `Ordered`. If that blanket
implementation could not be specialized, a generic function could rely on the
implementations of the two interfaces being consistent with each other.

This feature would be incompatible with our prioritization approach, however,
which does not result in a strict hierarchy of implementations.

### Libraries for orphan impls

The [orphan rule](docs/design/generics/details.md#orphan-rule) means that there
may be no library that can define an impl with a particular type structure. Rust
has encountered this problem already, see
[Rust RFC #1856: "Orphan rules are stricter than we would like"](https://github.com/rust-lang/rfcs/issues/1856).
Carbon does not currently address this problem, but we would consider future
changes that do as long as coherence was maintained. For example, we'd consider
a mechanism that allowed libraries to be defined that must be imported, either
implicitly or explicitly, depending on whether specific other libraries are
imported or linked into the project.
