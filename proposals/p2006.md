# Values, variables, pointers, and references

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/2006)

<!-- toc -->

## Table of contents

-   [Abstract](#abstract)
-   [Problem](#problem)
    -   [Conceptual integrity between local variables and parameters](#conceptual-integrity-between-local-variables-and-parameters)
-   [Background](#background)
-   [Proposal](#proposal)
    -   [Values, objects, and expressions](#values-objects-and-expressions)
    -   [Patterns, `var`, `let`, and local variables](#patterns-var-let-and-local-variables)
    -   [Pointers, dereferencing, and references](#pointers-dereferencing-and-references)
    -   [Indexing](#indexing)
    -   [`const`-qualified types](#const-qualified-types)
    -   [Interop with `const &`](#interop-with-const-)
    -   [Customization](#customization)
-   [Rationale](#rationale)
-   [Alternatives considered](#alternatives-considered)
    -   [Immutable value escape hatch](#immutable-value-escape-hatch)
    -   [References in addition to pointers](#references-in-addition-to-pointers)
    -   [Automatic dereferencing](#automatic-dereferencing)
    -   [Exclusively using references](#exclusively-using-references)
    -   [Alternative syntaxes for locals](#alternative-syntaxes-for-locals)
-   [Appendix: background, context, and use cases from C++](#appendix-background-context-and-use-cases-from-c)
    -   [`const` references versus `const` itself](#const-references-versus-const-itself)
    -   [Pointers](#pointers)
    -   [References](#references)
        -   [Special but critical case of `const T&`](#special-but-critical-case-of-const-t)
        -   [R-value references and forwarding references](#r-value-references-and-forwarding-references)
        -   [Mutable operands to user-defined operators](#mutable-operands-to-user-defined-operators)
        -   [User-defined dereference and indexed access syntax](#user-defined-dereference-and-indexed-access-syntax)
        -   [Member and subobject accessors](#member-and-subobject-accessors)
        -   [Non-null pointers](#non-null-pointers)
        -   [Syntax-free dereference](#syntax-free-dereference)

<!-- tocstop -->

## Abstract

Introduce a concrete design for how Carbon values, objects, storage, variables,
and pointers will work. This includes fleshing out the design for:

-   The expression categories used in Carbon to represent values and objects,
    how they interact, and terminology that anchors on their expression nature.
-   An expression category model for readonly, abstract values that can
    efficiently support function inputs.
-   A customization system for value expression representations, especially as
    seen on function boundaries in the calling convention.
-   An expression category model for references instead of a type system model.
-   How patterns match different expression categories.
-   How initialization works in conjunction with function returns.
-   Specific pointer syntax, semantics, and library customization mechanisms.
-   A `const` type qualifier for use when the value expression category system
    is too abstracted from the underlying objects in storage.

## Problem

Carbon needs a design for how values, variables, objects, pointers, and
references work within the language. These designs are heavily interdependent
and so they are presented together here. The design also needs to provide a
compelling solution for a wide range of use cases in the language:

-   Easy to use, and use correctly, function input and in/out parameters.
-   Clearly separating read-only use cases like function inputs from mutable use
    cases.
-   Support for binding local names to both fixed values and mutable variables.
-   Indirect (and mutable) access to objects (by way of pointers or references).
-   Extensible models for dereferencing and indexing.
-   Subsetting method type APIs for read-only input objects.
-   Subsetting method type APIs for indirect access to shared objects in
    thread-compatible ways.
-   Interoperability between function input parameters and C++ `const &`
    parameters.
-   Complex type designs which expose both interior pointers and exterior
    pointers transparently for extended dereferencing or indexing.

### Conceptual integrity between local variables and parameters

An additional challenge that this design attempts to address is retaining the
conceptual integrity between local variables and parameters. Two of the most
fundamental refactorings in software engineering are _inlining_ and _outlining_
of regions of code. These operations introduce or collapse one of the most basic
abstraction boundaries in the language: functions. These refactorings translate
between local variables and parameters
in both directions. In order to ensure these translations are unsurprising and
don't face significant expressive gaps or behavioral differences, it is
important to have strong semantic consistency between local variables and
function parameters. While there are some places that these need to differ,
there should be a strong overlap of the core facilities, design, and behavior.

## Background

Much of this is informed by the experience of working with increasingly complex
"value categories" (actually categorizing expressions) and parameter passing in
C++ and how the language arrived there. Some background references on this area
of C++:

-   https://en.cppreference.com/w/cpp/language/value_category
-   http://wg21.link/basic.lval
-   https://www.scs.stanford.edu/~dm/blog/decltype.html
-   https://medium.com/@barryrevzin/value-categories-in-c-17-f56ae54bccbe
-   http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-conventional

I've also written up a detailed walk-through of the different use cases and
considerations that touch on the space of values, references, function inputs,
and more across C++ in an
[appendix](#appendix-background-context-and-use-cases-from-c).

## Proposal

This section provides a condensed overview of the proposal. The details are
covered in the updated content in the design, and each section links into the
relevant content there. While this overview both duplicates and summarizes
content, it isn't intending anything different from the updates to the design
content, and the design content should be considered authoritative as it will
also continue to be maintained going forward.

### Values, objects, and expressions

Carbon has both abstract _values_ and concrete _objects_. Carbon _values_ are
things like `42`, `true`, and `i32` (a type value). Carbon _objects_ have
_storage_ where values can be read and written. Storage also allows taking the
address of an object in memory in Carbon.

Both objects and values can be nested within each other. For example
`(true, true)` is both a value and also contains two sub-values. When a
two-tuple is stored somewhere, it is both a tuple-typed object and contains two
subobjects.

> Details:
> [Values, objects, and expressions](/docs/design/values.md#values-objects-and-expressions)

Expressions are categorized in a way that explains how they produce values or
refer to objects:

-   [_Value expressions_](/docs/design/values.md#value-expressions) produce
    abstract, read-only _values_ that cannot be modified or have its address
    taken.
-   [_Reference expressions_](/docs/design/values.md#reference-expressions)
    refer to _objects_ with _storage_ where a value may be read or written and
    the object's address can be taken.
    -   [_Durable reference expressions_](/docs/design/values.md#durable-reference-expressions)
        are reference expressions which cannot refer to _temporary_ storage, but
        must refer to some storage that outlives the full expression.
    -   [_Ephemeral reference expressions_](/docs/design/values.md#ephemeral-reference-expressions)
        are reference expressions which _can_ refer to temporary storage.
-   [_Initializing expressions_](/docs/design/values.md#initializing-expressions)
    which require storage to be provided implicitly when evaluating the
    expression. The expression then initializes an object in that storage. These
    are used to model function returns, which can construct the returned value
    directly in the caller's storage.

> Details: [Expression categories](/docs/design/values.md#expression-categories)

### Patterns, `var`, `let`, and local variables

Patterns are by default _value patterns_ and match _value expressions_, but can
be introduced with the `var` keyword to create a _variable pattern_ that has
_storage_ and matches _initializing expressions_. Names bound in value patterns
become value expressions, and names bound in a variable pattern become _durable
reference expressions_ referring to an object in that pattern's storage.

Local patterns can be introduced with `let` to get the default behavior of a
readonly pattern, or they can be directly introduced with `var` to form a
variable pattern and declare mutable local variables.

> Details:
> [Binding patterns and local variables with `let` and `var`](/docs/design/values.md#binding-patterns-and-local-variables-with-let-and-var)

### Pointers, dereferencing, and references

Pointers in Carbon are the primary mechanism for _indirect access_ to storage
containing some object. Dereferencing a pointer forms a
[_reference expression_](/docs/design/values.md#reference-expressions) to the
object.

Carbon pointers are heavily restricted compared to C++ pointers -- they cannot
be null and they cannot be indexed or have pointer arithmetic performed on them.
Carbon will have dedicated mechanisms that still provide this functionality, but
those are future work.

> Details: [Pointers](/docs/design/values.md#pointers)

The syntax for working with pointers is similar to C++:

```carbon
var i: i32 = 42;
var p: i32* = &i;

// Form a reference expression `*p` and assign `13` to the referenced storage.
*p = 13;
```

> Details:
>
> -   [Pointer syntax](/docs/design/values.md#pointer-syntax)
> -   [Pointer operators](/docs/design/expressions/pointer_operators.md)

Carbon doesn't have reference types, just reference expressions. API designs in
C++ that use references (outside of a few common cases like `const &` function
parameters) will typically use pointers in Carbon. The goal is to simplify and
focus the type system on a primary model of indirect access to an object.

> Details: [Reference types](/docs/design/values.md#reference-types)

### Indexing

Carbon supports indexing that both accesses directly contained storage like an
array and indirect storage like C++'s `std::span`. As a result, the exact
interfaces used for indexing reflect the expression category of the indexed
operand and the specific interface its type implements. This proposal just
updates and refines this design with the new terminology.

> Details: [Indexing](/docs/design/expressions/indexing.md)

### `const`-qualified types

Carbon provides the ability to qualify a type `T` with the keyword `const` to
get a `const`-qualified type: `const T`. This is exclusively an API-subsetting
feature in Carbon -- for more fundamentally "immutable" use cases, value
expressions and bindings should be used instead. Pointers to `const`-qualified
types in Carbon provide a way to reference an object with an API subset that can
help model important requirements like ensuring usage is exclusively by way of a
_thread-safe_ interface subset of an otherwise _thread-compatible_ type.

> Details:
> [`const`-qualified types](/docs/design/values.md#const-qualified-types)

### Interop with `const &`

> TODO

### Customization

> TODO

## Rationale

-   Pointers are a fundamental components of all modern computer hardware --
    they are abstractly random-access machines -- and being able to directly
    model and manipulate this is necessary for
    [performance-critical software](/docs/project/goals.md#performance-critical-software).
-   Simplifying the type system by avoiding both pointers and references is
    expected to make
    [code easier to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write).
-   Creating space in both the syntax and type system to introduce ownership and
    lifetime information is important to be able to address long term
    [safety](/docs/project/goals.md#practical-safety-and-testing-mechanisms)
    needs.
-   Pointers are expected to be deeply familiar to C++ programmers and easily
    [interoperate with C++ code](/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code).

## Alternatives considered

> TODO - this remains very incomplete

### Immutable value escape hatch

We could provide the escape hatch of a syntax to unsafely take the
address and perform mutations to an immutable value view in Carbon. This would
more easily match patterns like `const_cast` in C++. However, there seem to be
effective ways of rewriting the code to avoid this need so this proposal
suggests not adding that escape hatch now. We can added it later if experience
proves this is an important pattern to support without the contortions of
manually creating a local copy (or changing to pointers).

### References in addition to pointers

The primary and most obvious alternative to the design proposed here is the one
used by C++: have _references_ in addition to pointers in the type system. This
initially allows zero-syntax modeling of L-values, which can in turn address
many use cases here much as they do in C++. Similarly, adding different kinds of
references can allow modeling more complex situations such as different lifetime
semantics.

However, this approach has two fundamental downsides. First, it would add
overall complexity to the language as references don't form a superset of the
functionality provided by pointers -- there is still no way to distinguish
between the reference and the referenced object. This results in confusion where
references are understood to be syntactic sugar over a pointer, but cannot be
treated as such in several contexts.

Second, this added complexity would reside exactly in the position of the type
system where additional safety complexity may be needed. We would like to leave
this area (pointers and references to non-local objects) as simple and minimal
as possible to ease the introduction of important safety features going forward
in Carbon.

### Automatic dereferencing

One way to make pointers behave very nearly the same as references without
adding complexity to the type system is to automatically dereference them in the
relevant contexts. This can, if done carefully, preserve the ability to
distinguish between the pointer and the pointed-to object while still enabling
pointers to be seamlessly used without syntactic overhead as L-values.

However, this makes code dereferencing a pointer and performing a non-local and
potentially mutating operation visually indistinct. Having visual markers for
this arguably provides some readability improvement for some people, but is
noise and a distraction for others. Reasonable judgement calls about which
direction to prefer may differ, but Carbon's principle of preferring lower
context sensitivity leans (slightly) toward explicit dereferencing instead.

It is worth noting that there are existing languages that use exactly this or an
extremely similar pattern such as Rust. It is also relatively easy to imagine
moving from this proposal toward automatic dereferencing in the future as it
builds on the same core type system primitives.

### Exclusively using references

While framed differently, this is essentially equivalent to automatic
dereferencing of pointers. The key is that it does not add both options to the
type system but addresses the syntactic differences separately and uses
different operations to distinguish between the reference and the referenced
object when necessary.

### Alternative syntaxes for locals

> TODO: needs to be rewritten

**Syntactic alternatives not currently proposed:**

-   It is appealing to consider the `val` introducer instead of `let` given that
    these are expected to be called "values". However, there is some concern
    over the visual similarity of `val` and `var`, and if pronounced as written
    instead of as "value" ar "variable", the difference relies on a subtle
    consonant distinction not present in some widely used spoken languages. That
    said, it is worth investigating whether there is a real user preference
    between these introducers. Kotlin even has both `val` and `var` with a
    similar distinction and so might serve as the basis for investigating this.
    For now, using the less controversial spelling is proposed as this is an
    easy thing to change later.
-   Another potential introducer would be `const`. However the semantics would
    be subtly different even if the use cases would be similar, which might make
    reuse of the keyword more confusing than helpful. Also, it is longer and
    expected to be extremely common.
-   Rust uses the keyword `mut` for a similar distinction, and does not make
    `let` optional. Carbon could adopt either aspect of those -- the keyword or
    the requirement for `let` in every case. However, requiring two introducers
    seems to force unnecessary ceremony into the language. The introducer `mut`
    seems significantly less obvious to programmers familiar with any other
    language, and isn't as obvious of an abbreviation as `var` is for
    "variable". These issues are less pronounced when always following `let`,
    but still present, especially nested within a pattern.

## Appendix: background, context, and use cases from C++

This appendix provides an examination of C++'s fundamental facilities in the
space involving `const` qualification, references (including R-value
references), and pointers. Beyond the expression categorization needed to
provide a complete model for the language, these use cases help inform the space
that should be covered by the proposed design.

### `const` references versus `const` itself

C++ provides overlapping but importantly separable semantic models which
interact with `const` references.

1. An _immutable view_ of a value
2. A _thread-safe interface_ of a
   [thread-compatible type](https://abseil.io/blog/20180531-regular-types#:~:text=restrictions%20or%20both.-,Thread-compatible,-%3A%20No%20concurrent%20call)

Some examples of the immutable view use case are provided below. These include
`const` reference parameters and locals, as well as `const` declared local and
static objects.

```
void SomeFunction(const int &id) {
  // Here `id` is an immutable view of some value provided by the caller.
}

void OtherFunction(...) {
  // ...

  const int &other_id = <some-runtime-expression>;

  // Cannot mutate `other_id` here either, it is just a view of the result of
  // `<some-runtime-expression>` above. But we can pass it along to another
  // function accepting an immutable view:
  SomeFunction(other_id);

  // We can also pass ephemeral values:
  SomeFunction(other_id + 2);

  // Or values that may be backed by read-only memory:
  static const int fixed_id = 42;
  SomeFunction(fixed_id);
}
```

The _immutable view_ `id` in `SomeFunction` can be thought of as requiring that
the semantics of the program be exactly the same whether it is implemented in
terms of a view of the initializing expression or a copy of that value, perhaps
in a register.

The implications of the semantic equivalence help illustrate the requirements:

-   The input value must not change while the view is visible, or else a copy
    would hide those changes.
-   The view must not be used to mutate the value, or those mutations would be
    lost if made to a copy.
-   The identity of the object must not be relevant, or else inspection of its
    address would reveal whether a copy was used.

Put differently, these restrictions makes a copy valid under the
[as-if rule](https://en.cppreference.com/w/cpp/language/as_if).

The _thread-safe interface_ use case is the more prevalent use of `const` in
APIs. It is most commonly seen with code that looks like:

```
class MyThreadCompatibleType {
 public:
  // ...

  int Size() const { return size; }

private:
  int size;

  // ...
};

void SomeFunction(const MyThreadCompatibleType *thing) {
  // ....

  // Users can expect calls to `Size` here to be correct even if running
  // on multiple threads with a shared `thing`.
  int thing_size = thing->Size();

  // ...
}
```

The first can seem like a subset of the second, but this isn't really true.
There are cases where `const` works for the first use case but doesn't work well
for thread-safety:

```
void SomeFunction(...) {
  // ...

  const std::unique_ptr<BigData> data = ComputeBigData();

  // We never want to release or re-allocate `data` and `const`
  // makes sure that doesn't happen. But the actual data is
  // completely mutable!
  // ...
}
```

These two use cases can also lead to tension between shallow const and deep
const:

-   Immutability use cases will tend towards shallow(-er) const, like pointers.
-   Thread safety use cases will tend towards deep(-er) const.

### Pointers

The core of C++'s indirect access to an object stored somewhere else comes from
C and its lineage of explicit pointer types. These create an unambiguous
separate layer between the pointer object and the pointee object, and introduce
dereference syntax (both the unary `*` operator and the `->` operator).

C++ makes an important extension to this model to represent _smart pointers_ by
allowing the dereference operators to be overloaded. This can be seen across a
wide range of APIs such as `std::unique_ptr`, `std::shared_ptr`,
`std::weak_ptr`, etc. These user-defined types preserve a fundamental property
of C++ pointers: the separation between the pointer object and the pointee
object.

The distinction between pointer and pointee is made syntactically explicit in
C++ both when _dereferencing_ a pointer, and when _forming_ the pointer or
taking an object's address. These two sides can be best illustrated when
pointers are used for function parameters. The caller code must explicitly take
the address of an object to pass it to the function, and the callee code must
explicitly dereference the pointer to access the caller-provided object.

### References

C++ provides for indirection _without_ the syntactic separation of pointers:
references. Because a reference provides no syntactic distinction between the
reference and the referenced object--that is their point!--it is impossible to
refer to the reference itself in C++. This creates a number of restrictions on
their design:

-   They _must_ be initialized when declared
-   They cannot be rebound or unbound.
-   Their address cannot be taken.

References were introduced originally to enable operator overloading, but have
been extended repeatedly and as a consequence fill a wide range of use cases.
Separating these and understanding them is essential to forming a cohesive
proposal for Carbon -- that is the focus of the rest of our analysis of
references here.

#### Special but critical case of `const T&`

As mentioned above, one form of reference in C++ has unique properties:
`const T&` for some type `T`, or a _`const` reference_. The primary use for
these is also the one that motivates its unique properties: a zero-copy way to
provide an input function parameter without requiring the syntactic distinction
in the caller and callee needed when using a pointer. The intent is to safely
emulate passing by-value without the cost of copying. Provided the usage is
immutable, this emulation can safely be done with a reference and so a `const`
reference fits the bill here.

However, to make zero-copy, pass-by-value to work in practice, it must be
possible to pass a _temporary_ object. That works well with by-value parameters
after all. To make this work, C++ allows a `const` reference to bind to a
temporary. However, the rules for parameters and locals are the same in C++ and
so this would create serious lifetime bugs. This is fixed in C++ by applying
_lifetime extension_ to the temporary. The result is that `const` references are
quite different from other references, but they are also quite useful: they are
the primary tool used to fill the _immutable view_ use case of `const`.

One significant disadvantage of `const` references is that they are observably
still references. When used in function parameters, they cannot be implemented
with in-register parameters, etc. This complicates the selection of readonly
input parameter type for functions, as both using a `const` reference and a
by-value parameter force a particular form of overhead. Similarly, range based
`for` loops in C++ have to choose between a reference or value type when each
would be preferable in different situations.

#### R-value references and forwarding references

Another special set of use cases for references are R-value and forwarding
references. These are used to capture _lifetime_ information in the type system
in addition to binding a reference. By doing so, they can allow overload
resolution to select C++'s _move semantics_ when appropriate for operations.

The primary use case for move semantics in function boundaries was to model
_consuming input_ parameters. Because move semantics were being added to an
existing language and ecosystem that had evolved exclusively using copies,
modeling consumption by moving into a by-value parameter would have forced an
eager and potentially expensive copy in many cases. Adding R-value reference
parameters and overloading on them allowed code to gracefully degrade in the
absence of move semantics -- their internal implementation could minimally copy
anything non-movable. These overloads also helped reduce the total number of
moves by avoiding moving first into the parameter and then out of the parameter.
This kind of micro-optimization of moves was seen as important because some
interesting data structures, especially in the face of exception safety
guarantees, either implemented moves as copies or in ways that required
non-trivial work like memory allocation.

Using R-value references and overloading also provided a minor benefit to C++:
the lowest-level mechanics of move semantics such as move construction and
assignment easily fit into the function overloading model that already existed
for these special member functions.

These special member functions are just a special case of a more general pattern
enabled by R-value references: designing interfaces that use _lifetime
overloading_ to _detect_ whether a move would be possible and change
implementation strategy based on how they are called. Both the move constructor
and the move-assignment operator in C++ work on this principle. However, other
use cases for this design pattern are so far rare. For example, Google's C++
style
[forbids](https://google.github.io/styleguide/cppguide.html#Rvalue_references)
R-value references outside of an enumerated set of use cases, which has been
extended incrementally based on demonstrated need, and has now been stable for
some time. While overloading on lifetime is one of the allowed use cases, that
exemption was added almost four years after the initial exemption of move
constructors and move assignment operators.

#### Mutable operands to user-defined operators

C++ user-defined operators have their operands directly passed as parameters.
When these operators require _mutable operands_, references are used to avoid
the syntactic overhead and potential semantic confusion of taking their address
explicitly. This use case stems from the combined design decisions of having
operators that mutate their operands in-place and requiring the operand
expression to be directly passed as a normal function parameter.

#### User-defined dereference and indexed access syntax

C++ also allows user-defined operators that model dereference (or indirecting in
the C++ standard) and indexed access (`*` and `[]`). Because these operators
specifically model forming an L-value and because the return of the operator
definition is directly used as the expression, it is necessary to return a
reference to the already-dereferenced object. Returning a pointer would break
genericity with builtin pointers and arrays in addition to adding a very
significant syntactic overhead.

#### Member and subobject accessors

Another common use of references is in returns from member functions to provide
access to a member or subobject, whether const or mutable. This particular use
case is worth calling out specially as it has an interesting property: this is
often not a fully indirect access. Instead, it is often simply selecting a
particular member, field, or other subobject of the data structure. As a
consequence, making subsequent access transparent seems especially desirable.

However, it is worth noting that this particular use case is also an especially
common source of lifetime bugs. A classic and pervasive example can be seen when
calling such a method on a temporary object. The returned reference is almost
immediately invalid.

#### Non-null pointers

A common reason for using mutable references outside of what has already been
described is to represent _non-null pointers_ with enforcement in the type
system. Because the canonical pointer types in C++ are allowed to be null,
systems that forbid a null in the type system use references to induce any null
checks to be as early as possible. This causes a
"[shift left](https://en.wikipedia.org/wiki/Shift-left_testing)" of handling
null pointers, both moving the error closer to its cause logically and
increasing the chance of moving earlier in the development process by making it
a static property enforced at compile time.

References are imperfectly suited to modeling non-null pointers because they are
missing many of the fundamental properties of pointers such as being able to
rebind them, being able to take their address, etc. Also, references cannot be
safely made `const` in the same places that pointers can because that might
unintentionally change their semantics by allowing temporaries or extending
lifetimes.

#### Syntax-free dereference

Beyond serving as a non-null pointer, the other broad use case for references is
to remove the syntactic overhead of taking an address and dereferencing
pointers. In other words, they provide a way to have _syntax-free dereferences_.
Outside of function parameters, removing this distinction may provide a
genericity benefit, as it allows using the same syntax as would be used with
non-references. In theory code could simply use pointers everywhere, but this
would add syntactic overhead compared to local variables and references. For
immutable accesses, the syntactic overhead seems unnecessary and unhelpful.
However, having distinct syntax for _mutable_ iteration, container access, and
so on often makes code more readable.

There are several cases that have come up in the design of common data
structures where the use of distinct syntaxes immutable and mutable operations
provides clear benefit: copy-on-write containers where the costs are
dramatically different, and associative containers which need to distinguish
between looking up an element and inserting an element. This tension should be
reflected in how we design _indexed access syntax_.

Using mutable references for parameters to reduce syntactic overhead also
doesn't seem particularly compelling. For passing parameters, the caller syntax
seems to provide significant benefit to readability. When using _non-local_
objects in expressions, the fact that there is a genuine indirection into memory
seems to also have high value to readability. These syntactic differences do
make inline code and outlined code look different, but that reflects a behavior
difference in this case.
