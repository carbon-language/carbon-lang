# Character literals

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/1964)

<!-- toc -->

## Table of contents

-   [Abstract](#abstract)
-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Details](#details)
    -   [Types](#types)
    -   [Operations](#operations)
    -   [Encoding](#encoding)
-   [Rationale](#rationale)
-   [Alternatives considered](#alternatives-considered)
    -   [No Distinct Character Literal](#no-distinct-character-literal)
    -   [Supporting Prefix Declarations](#supporting-prefix-declarations)
    -   [Disallowing Numeric Escape Sequences](#disallowing-numeric-escape-sequences)

<!-- tocstop -->

## Abstract

This proposal specifies lexical rules for constant characters in Carbon:

Put character literals in single quotes, like `'a'`. Character literals work
like numeric literals:

Every different literal value has its own type. The bit width is determined by
the type of the variable the literal is assigned to, not the literal itself.
Follows the plan from Open design idea:
[Character Literals](https://github.com/carbon-language/carbon-lang/issues/1934).

## Problem

Carbon currently has no lexical syntax for character literals, and only provides
string literals and numeric literals. We wish to provide a distinct lexical
syntax for character literals versus string literals.

The advantage of having an explicit character type fundamentally comes down to
characters being represented as integers whereas strings are represented as
buffers. This will allow characters to have different operations, and be more
familiar to use. For example:

```
if (c >= 'A' and c <= 'Z') {
    c += 'a' - 'A';
}
```

The example above shows how we would be able to use operations similar to
integers. Being able to use the comparison operations and supporting arithmetic
operations provides an intuitive approach to using characters. This allows us to
remove unnecessary logic of type conversion and other control flow logic, that
is needed to work with a single element string. See [Rationale](#rationale) for
more examples showing more appropriate use of characters over using strings.

## Background

Character Literals by definition is a type of literal in programming for the
representation of a single character's value within the source code of a
computer program. Character literals between languages have some minor nuances
but are fundamentally designed for the same purpose. Languages that have a
dedicated character data type generally include character literals, for example
C++, Java, Swift to name a few. Whereas other languages that lack distinct
character type, like Python use strings of length one to serve the same purpose
a character data type. For more information see
[Character Literals Wiki](https://en.wikipedia.org/wiki/Character_literal),
[Character Literals DBpedia](https://dbpedia.org/page/Character_literal)

## Proposal

Put character literals in single quotes, like `'a'`. Character literals work
like numeric literals:

-   Every different literal value has its own type.
-   The bit width is determined by the type of the variable the literal is
    assigned to, not the literal itself. Follows the plan from #1934.

We will not support:

-   Multi-line literals
-   "raw" literals (using #'x'#)
-   Empty character literals (`''`)
-   ASCII Control codes (0...31), except when specified with an escape sequence.
-   Whitespace characters other than word space: tab, line feed, carriage
    return, form feed, and vertical tab. See
    [String Literals: Escaping Sequence](https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p0199.md#escape-sequences-1)

## Details

A character literal is a sequence enclosed with single quotes delimiter ('),
excluding:

-   New line
-   Single quote (`'`), but can write `'` character as `'\''`
-   Back-slash (`\`), except when used to form an escape sequence. See
    [String Literals: Escaping Sequence](https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p0199.md#escape-sequences-1)

### Types

We will represent a character literal as a sequence consisting of elements that
are each either a unicode code-point or a hex-encoded byte value.

We can see whether the particular literal is represented in the variable's type
by only looking at the types:

```
let allowed: u8 = 'a';
```

The above is allowed because the type of 'a' indicates that it can be converted
to `u8`.

```
let error1: u8 = 'ðŸ˜ƒ';
let error2: u8 = 'AB';
```

However these should produce errors, the types of 'ðŸ˜ƒ' and 'AB' indicate that
they cannot be converted to the declared type `u8`. It is important to point out
that any `'\n'` and `'\u{A}'` would be of the same type, as they are the same
unicode entities `%0A`. It is worth noting that `'\x0A'` will be slightly
different as any character following the `\x...` sequence representation is not
the same as a Unicode character. For example:

```
var c1: EBCDICChar = '\x0A';
var c2: EBCDICChar = '\n';
```

Here we assume that `c1` will be the EBCDIC RPT character (0xA) and for `c2` to
be the EBCDIC NL character (0x15)

### Operations

From the previous examples, we should be able to use the following operators:

-   Comparison: `<`, `>`, `<=`, `>=` `==`
    -   If any of the comparison operators are used between a code point and a
        code unit, this will produce an error.
-   Plus: `+`. However the behaviour of this operator is distinct compared to
    its use with Strings. Rather than a concatenation, this will add the value
    of the two characters:
    -   If the `+` is used between a character literal and an integer literal,
        this should produce a character literal if the result fits into a
        Unicode code point or for a unicode hex code like `'\xAB'`, a single
        byte.
    -   If the `+` is used between a character literal and an integer
        non-literal this will produce an error.
    -   If the `+` is used between two character literals this will produce an
        error.
    -   If the `+` operator is used between a code point and a code unit, this
        will produce an error.
-   Subtract: `-` Similar to the plus operator, this will subtract the value of
    the two characters.

    -   If the `-` is used between a character literal and an integer literal,
        this should produce a character literal.
    -   If the `-` is used between two character literals, which are either both
        a single code point or both a single code unit, this should produce and
        integer literal representing the difference between the code points or
        code units.
    -   If the `-` is used between a character literal and an integer
        non-literal this will produce an error.
    -   If the `-` operator is used between a code point and a code unit, this
        will produce and error.

    In other use cases where the `+` and `-` operators are used, in theory we
    should convert the character literal to some other type first. For example
    if we want to call `w - 'a'`, where `w` is of type `char` we would want to
    convert the `'a'` literal to a `char`.

### Encoding

Character literals written will be UTF-8 encoded, as all of Carbon source code
is UTF-8 encoded. See
[Unicode source files](https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p0142.md#character-encoding)

## Rationale

This proposal supports the goal of making Carbon code
[easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write).
Adding support for a specific character literal supports clean, readable,
concise use and is a much more familiar concept that will make it easier to
adopt Carbon coming from other languages. Have a distinct character literally
will also allow us support useful operations designed to manipulate the literals
value. When working with `String`, we use the `+` operator to concatenate
multiple `String`s, but say we wanted to advance a character to the next
literal. Using a `String` will produce a type error, as we are misusing the `+`
operator: `"a" + 1`. However with a character literal, we can support operations
for these use cases:

```
var b: u8;

b = 'a' + 1;
b + 1 == 'c';

```

See [Operations](#operations) and
[No Distinct Character Literal](#no-distinct-character-literal) for more
information.

Further, this design follows other standards set in place by previous proposals.
For example following the
[String Literals: Escaping Sequence](https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p0199.md#escape-sequences-1)
and representing characters as integers with the behaviour inline with
[Integer Literals](https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p0143.md).
This also supports our goal for
[Interoperability with and migration from existing C++ code](/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code)
by ensuring that every kind of character literal that exists in C++ can be
represented in a Carbon character literal. This is done in a way that is natural
to adopt, understand, easy to read by having explicit character types mapped to
the C++ character types and the correct associated encoding.

## Alternatives considered

### No Distinct Character Literal

In principle a character literal can be represented by reusing string literals
similar to how Python handles character literals, however this would lead to
some disadvatages. There are situations where using operations can be given more
practical use. When using `Strings` the `+` operator, is used for concatenating
two `String` objects, essentially rendering it useless when working with
characters. With a distinct character literal we can support more useful
operations, for example by using the `+` operator to advance the character
literal to the next representable literal:

```
    var a: u8 = 'a';
    var b: u8 = 'b';

    if (a < b) {
        a += 1;
    }
```

Another example of this would be looking at the `==` and other comparison
operators when working with characters represented with code points. Below is an
example of representing the character `Ã©` with code points. `acute1` is using
the single code point representation and `acute2` is combining the `e` and
`acute accent mark` code points to represent the character. However when they
are evaluated with the `==` operator the result is `false`.

```
  var acute1: String = "\u{E9}";
  var acute2: String = "\u{301}\u{65}";
  var matching: auto = if acute1 == acute2 then true else false; //output false
```

When working with code points, there is an advantage to having a distinct
character literal. Primarily when discussing the readablity of the design
choice, and working with code points similar to the example above. When looking
at the two variables it is clear that `acute2` contains two code points, but
when using a `String` there is no way to evaluate if it is a single valid
character of multiple code points or two characters. `\u{301}\u{65}` is a valid
single character comprised of multiple code points resulting in `Ã©`, however
this could easily be mistaken as a `String` comprised of two code points, for
example `\u{400}\u{65}` which is two characters resulting in `Ð€e`.

### Supporting Prefix Declarations

No support is proposed for prefix declarations like `u`, `U`, or `L`. In
practice they are used to specify the character literal types and their encoding
in languages like C and C++. There are a several benefits to omitting prefix
declarations; improved readablitly, simplifying how a character's type is
determened, and how we are encoding character literals. When declaring a
character literal, the type is based on the contents of the character so that
`var c: u8 = 'a'` is a valid character that can be converted to `u8`, in order
to support prefix declarations we would need to extend our type system to have
other exlpicit type checks like in C++; a UTF-16 `u'`, UTF-32 `U'`, and wide
characters `L'`. This would be more familiar for individuals coming to Carbon
from a C++ background, and simplify our approach for C++ Interoperability. At
the cost of diverge from existing standards, for example
[Proposal 142](https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p0142.md#character-encoding)
states all of Carbon source code should be UTF-8 encoded. Prefix declarations
would detract the readability of the character literals and increase the
complexity of character literal [Types](#types).

### Disallowing Numeric Escape Sequences

`//TODO: pro-con descriptions + examples` Not support escaping numeric
sequences. This would simplify some of the design choices seen above by making
types, the restrictions and behavior of character literals simpler. Specifically
[Types](#types) of `EBCDIC`, by disallowing the `\x...` pattern. This would
restrict users by having to use the specific hex value, and when to use
operations between character literals and benefiting the readability of Carbon
in some use cases.
