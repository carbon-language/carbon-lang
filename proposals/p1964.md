# Character literals

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/1964)

<!-- toc -->

## Table of contents

-   [Abstract](#abstract)
-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Details](#details)
    -   [Types](#types)
    -   [Operations](#operations)
    -   [Encoding](#encoding)
-   [Rationale](#rationale)
-   [Alternatives considered](#alternatives-considered)
    -   [No distinct Character literal](#no-distinct-character-literal)
    -   [Supporting Prefix Declarations](#supporting-prefix-declarations)

<!-- tocstop -->

## Abstract

This proposal specifies lexical rules for constant characters in Carbon.

## Problem

Carbon currently has no lexical syntax for character literals, and only provides
string literals and numeric literals. We wish to provide a distinct lexical syntax
for character literals versus string literals.

The advantage of having an explicit character type fundamentally comes down to
characters being represented as integers whereas strings are represented as
buffers. This will allow characters to have different operations, and be more
familiar to use. For example:

\```
if (c >= 'A' and c <= 'Z') {
  c += 'a' - 'A';
}
\```

The example above shows how we would be able to use operations similar to
integers. Being able to use the comparison operations and supporting arithmetic
operations provides an intuitive approach to using characters. This allows us to
remove unnecessary logic of type conversion and other control flow logic, that
is needed to work with a single element string.

## Background

TODO: Briefly describe character literals in other languages (particularly C++, but it's often also useful to compare to Rust, Swift, Java, Python, and any other common languages that have made interesting choices in this area) and/or provide a link to an external description.

## Proposal

Put character literals in single quotes, like `'a'`. Character literals work
like numeric literals:

-   Every different literal value has its own type.
-   The bit width is determined by the type of the variable the literal is
    assigned to, not the literal itself. Follows the plan from #1934.


We will not support:

-   Multi-line literals
-   "raw" literals (using #'x'#)
-   Empty character literals (`''`)
-   ASCII Control codes (0...31), except for `\` when used for an escape
    sequence. See
    [String Literals: Escaping Sequence](https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p0199.md#escape-sequences-1)

## Details

A character literal is a sequence enclosed with single quotes delimiter ('),
excluding:

-   New line
-   Single quote (`'`), but can write `'` character as `'\''`
-   Back-slash (`\`), except when used to form an escape sequence. See
    [String Literals: Escaping Sequence](https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p0199.md#escape-sequences-1)

### Types

The different character literal types are based on the value of the character.
Meaning the type depends on the the contents, so that `'c'` and `'b'`. However
any `'\n'` and `'\u{A}'` would be of the same type, as they are the same unicode
entities `%0A`. It is worth noting that `'\x0A'` will be slightly different as
any character following the `\x...` sequence representation are not the same as
a Unicode character. For example:

```
var c1: EBCDICChar = '\x0A';
var c2: EBCDICChar = '\n';
```

Here we assume that `c1` will be the EBCDIC RPT character (0xA) and for `c2` to
be the EBCDIC NL character (0x15)

### Operations

From the previous examples, we should be able to use the following operators:

-   Comparison: `<`, `>`, `<=`, `>=` `==`
-   Plus: `+`. However the behaviour of this operator is distinctly compared to
    its use with Strings. Rather then a concatenation, this will add the value
    of the two characters.
-   Subtract: `-` Similar to the plus operator, this will subtract the value of
    the two characters.

### Encoding

Character literals written will be UTF-8 encoded, as all of Carbon source code
is UTF-8 encoded. See
[Unicode source files](https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p0142.md#character-encoding)

## Rationale

This proposal supports the goal of making Carbon code
[easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write).
Adding support for a specific character literal supports clean, readable,
concises use and is a much more familiar concept that will make it easier to
adopt Carbon coming from other languages. As well as following other standards
set in place by previous proposals. For example following the
[String Literals: Escaping Sequence](https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p0199.md#escape-sequences-1)
and representing characters as integers with the behaviour inline with
[Integer Literals](https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p0143.md).
This also supports our goal for
[Interoperability with and migration from existing C++ code](/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code)
by ensuring that every kind of character literal that exists in C++ can be
represented in a Carbon character literal. This is done in a way that is natural
to adopt, understand, easy to read by having explicit character types mapped to
the C++ character types and the correct associated encoding.

## Alternatives considered

### No distinct character literal

-   In principle a character literal can be represented by reusing string
    literals. For example:
    ```
    var s: String = "c"
    ```
    We would simply this as a single element string. However it terms of
    readablility, if we had a distinct lexical syntax for character literals
    versus string literals, this would be more inline with Carbon's language
    design goals related to self documenting code, easy to read, understand,
    write and C++ interopability.

### Supporting Prefix Declarations

-   No support is proposed for prefix declarations like `u`, `U`, or `L`. In
    practice they are used to specify the character literal types in languages
    like C and C++, supporting these could help with interoperability. However the
    proposal above supports the ideas that when a character is declared, its
    type is dependent on the value of the character itself, see [Types](#types).
    Supporting this will help support a much cleaner and readable syntax that
    is more inline with Carbon's goals, i.e [Rationale](#rationale).
