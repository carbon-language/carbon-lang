# Character literals

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/1964)

<!-- toc -->

## Table of contents

-   [Abstract](#abstract)
-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Details](#details)
    -   [Types](#types)
    -   [Operations](#operations)
-   [Rationale](#rationale)
-   [Alternatives considered](#alternatives-considered)
    -   [No distinct character types](#no-distinct-character-types)
    -   [No Distinct Character Literal](#no-distinct-character-literal)
    -   [Supporting Prefix Declarations](#supporting-prefix-declarations)
    -   [Disallowing Numeric Escape Sequences](#disallowing-numeric-escape-sequences)

<!-- tocstop -->

## Abstract

This proposal specifies lexical rules for constant characters in Carbon:

Put character literals in single quotes, like `'a'`. Character literals work
like numeric literals:

-   Every different literal value has its own type.
-   The bit width is determined by the type of the variable the literal is
    assigned to, not the literal itself.

Follows the plan from open design idea
[#1934: Character Literals](https://github.com/carbon-language/carbon-lang/issues/1934).

## Problem

Carbon currently has no lexical syntax for character literals, and only provides
string literals and numeric literals. We wish to provide a distinct lexical
syntax for character literals versus string literals.

The advantage of having an explicit character type fundamentally comes down to
characters being represented as integers whereas strings are represented as
buffers. This will allow characters to have different operations, and be more
familiar to use. For example:

```
if (c >= 'A' and c <= 'Z') {
    c += 'a' - 'A';
}
```

The example above shows how we would be able to use operations similar to
integers. Being able to use the comparison operations and supporting arithmetic
operations provides an intuitive approach to using characters. This allows us to
remove unnecessary logic of type conversion and other control flow logic, that
is needed to work with a single element string. See [Rationale](#rationale) for
more examples showing more appropriate use of characters over using strings.

## Background

Character Literals by definition is a type of literal in programming for the
representation of a single character's value within the source code of a
computer program. Character literals between languages have some minor nuances
but are fundamentally designed for the same purpose. Languages that have a
dedicated character data type generally include character literals, for example
C++, Java, Swift to name a few. Whereas other languages that lack distinct
character type, like Python use strings of length one to serve the same purpose
a character data type. For more information see
[Character Literals Wiki](https://en.wikipedia.org/wiki/Character_literal),
[Character Literals DBpedia](https://dbpedia.org/page/Character_literal)

## Proposal

Put character literals in single quotes, like `'a'`. Character literals work
like numeric literals:

-   Every different literal value has its own type.
-   The bit width is determined by the type of the variable the literal is
    assigned to, not the literal itself. Follows the plan from #1934.

We will not support:

-   Multi-line literals
-   "raw" literals (using #'x'#)
-   Empty character literals (`''`)
-   ASCII Control codes (0...31), except when specified with an escape sequence.
-   Whitespace characters other than word space: tab, line feed, carriage
    return, form feed, and vertical tab. See
    [String Literals: Escaping Sequence](https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p0199.md#escape-sequences-1)

## Details

-   A character literal is a sequence enclosed with single quotes delimiter ('),
    of UTF-8 code units that may or may not be a valid encoding. This matches
    [the UTF-8 encoding of Carbon source files](https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p0142.md#character-encoding).
-   If a character literal encodes exactly one code point, then it supports
    addition and subtraction. These operations produce another code point
    literal, if the value can be determined at compile time, or a runtime
    `Char32` code point value.
-   For most purposes a character should be viewed as representing a grapheme
    cluster.
-   Value-preserving implicit conversions from character literals to code point
    or code unit types are permitted. In particular, a character literal
    converts to a UTF-8 code unit if it is less than or equal to 0x7F, and
    UTF-16 code unit if it is less than or equal to 0xFFFF.
-   `\x` escape sequences produce the given code unit. Character literals are
    assumed to use a UTF-8 encoding. So `'\xC3\x89'` is the same thing as `'Ã‰'`,
    a valid encoding of a single code point, and so allows addition and
    subtraction.
-   Conversions from string literals to Unicode strings are implicit, even
    though the numeric values of the encoding may change.

Character literals cannot be written with these characters:

-   New line
-   Single quote (`'`), but can write `'` character as `'\''`
-   Back-slash (`\`), except when used to form an escape sequence. See
    [String Literals: Escaping Sequence](https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p0199.md#escape-sequences-1)
-   Whitespace characters other than space (` `).
-   ASCII control codes (0...31).

### Types

We will have the types `Char8`, `Char16`, and `Char32` representing code units
in UTF-8, UTF-16, and UTF-32. `Char32` will also represent a valid code point.
However, character literals will use their own types distinct from these:

-   We will support value preserving implicit conversions from character
    literals to code point or code unit types. In particular, a character
    literal converts to a `Char8` UTF-8 code unit if it is less than or equal to
    0x7F, and `Char16` UTF-16 code unit if it is less than or equal to 0xFFFF.
-   Conversions from string or character literals to a non-value-preserving
    encoding must be explicit.
-   Conversions from string literals to Unicode strings are implicit, even
    though the numeric values of the encoding may change.

We can see whether the particular literal is represented in the variable's type
by only looking at the types.

```
let allowed: Char8 = 'a';
```

The above is allowed because the type of `'a'` is the character literal
consisting of the single Unicode code point 97, which can be converted to
`Char8` since 97 is less than or equal to 0x7F.

```
let error1: Char8 = 'ðŸ˜ƒ';
let error2: Char8 = 'AB';
```

However these should produce errors. The type of `'ðŸ˜ƒ'` is the character literal
consisting of the single Unicode code point `0x1F603`, which is greater than
0x7F. The type of `'AB'` is a character literal that is a sequence of two
Unicode code points, which has no conversion to a type that only handles a
single UTF-8 code unit.

All of `'\n'`, `'\u{A}'`, and `'\x0A'` represent the same character and so have
the same type. However, explicitly converting this character literal to another
character set might result in a character with a different value, but that still
represents the newline character.

```
// 0x15 is the new line character in EBCDIC.
Assert('\n' as EBCDICChar == EBCDICChar.Make(0x15));
Assert('\x0A' as EBCDICChar != EBCDICChar.Make(0x0A));
```

### Operations

Character literals representing a single code point support the following
operators:

-   Comparison: `<`, `>`, `<=`, `>=` `==`
-   Plus: `+`. However the behavior of this operator is different from its use
    with strings. Rather than a concatenation, this will add the value of the
    two characters:
    -   If the `+` is used between a character literal representing a single
        Unicode code point and an integer literal, this should produce a
        character literal if the result fits in a Unicode code point.
    -   If the `+` is used between two character literals this will produce an
        error.
-   Subtract: `-` Similar to the plus operator, this will subtract the value of
    the two characters.

    -   If the `-` is used between a character literal representing a single
        code point or code unit and an integer literal, this should produce a
        character literal as long as the result of the difference is in range.
    -   If the `-` is used between two character literals, which are both a
        single code point, this should produce an integer literal representing
        the difference between the code points.

    In cases where the `+` and `-` operators are used with a character literal
    and a non-integer non-literal, the character literal should be converted to
    the type of the other operand if possible. For example, in the expression
    `w - 'a'`, where `w` is of type `Char8`, the `'a'` literal will be converted
    to type `Char8`.

There is intentionally no conversion from character literals to integer types.
Carbon will separate the integer types from character types entirely.

## Rationale

This proposal supports the goal of making Carbon code
[easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write).
Adding support for a specific character literal supports clean, readable,
concise use and is a much more familiar concept that will make it easier to
adopt Carbon coming from other languages. Have a distinct character literal will
also allow us support useful operations designed to manipulate the literal's
value. When working with `String`, we use the `+` operator to concatenate
multiple `String`s, but say we wanted to advance a character to the next
literal. Using a `String` will produce a type error, as we are misusing the `+`
operator: `"a" + 1`. However with a character literal, we can support operations
for these use cases:

```
var b: u8;

b = 'a' + 1;
b + 1 == 'c';

```

See [Operations](#operations) and
[No Distinct Character Literal](#no-distinct-character-literal) for more
information.

Further, this design follows other standards set in place by previous proposals.
For example following the
[String Literals: Escaping Sequence](https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p0199.md#escape-sequences-1)
and representing characters as integers with the behaviour inline with
[Integer Literals](https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p0143.md).

This also supports our goal for
[Interoperability with and migration from existing C++ code](/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code)
by ensuring that every kind of character literal that exists in C++ can be
represented in a Carbon character literal. This is done in a way that is natural
to adopt, understand, easy to read by having explicit character types mapped to
the C++ character types and the correct associated encoding.

Finally, the choice to use Unicode and UTF-8 by default reflects the Carbon goal
to prioritize
[modern OS platforms, hardware architectures, and environments](/docs/project/goals.md#modern-os-platforms-hardware-architectures-and-environments).
This reflects the
[growing adoption of UTF-8](https://en.wikipedia.org/wiki/UTF-8#Adoption).

## Alternatives considered

### No distinct character types

Unlike C++, Carbon will separate the integer and the character types. We
considered using `u8`, `u16`, and `u32` instead of `Char8`, `Char16`, and
`Char32`to reduce the number of different types users needed to be aware of and
convert between. We decided against it because it came with a number of
disadvantages:

-   `u8`, `u16`, and `u32` have the wrong arithmetic semantics: we don't want
    wrapping, and many `uN` operations, like multiplication, division, and
    shift, are not meaningful on code units. There may be rare cases where you
    want to use those operations, such as if you're implementing a conversion to
    or from code units. But in those rare cases it would be reasonable for the
    user to convert to an integer type to perform that operation and convert
    back when done.
-   Some operations want to be able to tell the difference between values that
    are intended to be UTF-8 instead of having no specified encoding.
-   Some operations want to be able to know that they've been given text rather
    than random bytes of data. For example, `Print(0x41 as u8)` would be
    expected to print `"65"` while `Print('\x41')` and `Print(0x41 as Char8)`
    would be expected to print `"A"`.
-   It's useful for developers to document the intended meaning of a value, and
    using a distinct type is one way to do that.

### No Distinct Character Literal

In principle, a character literal can be represented by reusing string literals
similar to how Python handles character literals, however this would prevent
performing operations on characters as integers. For example, the `+` operator
on strings is used for concatenation, but `+` on a character would change its
value.

```
// `digit` must be in the range 0..9.
fn DigitToChar(digit: i32) -> Char8 {
  return '0' + digit;
}
```

Furthermore, many properties of Unicode characters are defined on ranges of code
points, motivating supporting comparison operators on code points.

```
fn IsDingBatCodePoint(c: Char32) -> bool {
  return c >= '\u{2700}' and c <= '\u{27BF}';
}
```

### Supporting Prefix Declarations

No support is proposed for prefix declarations like `u`, `U`, or `L`. In
practice they are used to specify the character literal types and their encoding
in languages like C and C++. There are a several benefits to omitting prefix
declarations; improved readablitly, simplifying how a character's type is
determined, and how we are encoding character literals. When declaring a
character literal, the type is based on the contents of the character so that
`var c: u8 = 'a'` is a valid character that can be converted to `u8`, in order
to support prefix declarations we would need to extend our type system to have
other exlpicit type checks like in C++; a UTF-16 `u'`, UTF-32 `U'`, and wide
characters `L'`. This would be more familiar for individuals coming to Carbon
from a C++ background, and simplify our approach for C++ Interoperability. At
the cost of diverge from existing standards, for example
[Proposal 142](https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p0142.md#character-encoding)
states all of Carbon source code should be UTF-8 encoded. Prefix declarations
would detract the readability of the character literals and increase the
complexity of character literal [Types](#types).

### Disallowing Numeric Escape Sequences

Not support escaping numeric sequences. This would simplify some of the design
choices seen above by making types, the restrictions and behavior of character
literals simpler. Specifically [Types](#types) of `EBCDIC`, by disallowing the
`\x...` pattern. However this would affect the readability, type-safety and
consistency of character literals. If we were to disallow numeric escape
sequences for character literals, that diverges from the `String` type which
does allow for numeric escape sequences so we would essentially have the
functionality to declare character literals but within a string literal.
Additiaonlly, we could remove numeric escape sequences from string liteals, but
there are other draw backs to discuss in that arena. In terms of type-safety and
readability, if we take a look at `var first_digit: char = 0;` it's hard to see
the intention, is this supposed to be a `NUL` character or is it supposed to be
the character zero `'0'`? Whereas supporting numeric escape sequences, we can
write `var first_digit: char = '0'` or `var first_digit: char = '\0'` where the
intention is clear and defined. Further, if we use integer literals instead of
code unit escape sequences a user would assume we support initializing character
types from integer literals `first_digit: char = 0;`, leading to assumptions
surrounding how we'll permit implicit conversion from non-constant
integer-valued expressions to character types. This would essentially diminish
our ability to distinguish between numbers and characters in our type system.
