# Character literals

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/1964)

<!-- toc -->

## Table of contents

-   [Abstract](#abstract)
-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Details](#details)
    -   [Types](#types)
    -   [Operations](#operations)
    -   [Encoding](#encoding)
-   [Rationale](#rationale)
-   [Alternatives considered](#alternatives-considered)
    -   [No distinct character literal](#no-distinct-character-literal)
    -   [Supporting Prefix Declarations](#supporting-prefix-declarations)
    -   [Disallowing numeric escape sequences](#disallowing-numeric-escape-sequences)

<!-- tocstop -->

## Abstract

This proposal specifies lexical rules for constant characters in Carbon:

Put character literals in single quotes, like 'a'. Character literals work like
numeric literals:

Every different literal value has its own type. The bit width is determined by
the type of the variable the literal is assigned to, not the literal itself.
Follows the plan from Open design idea: character literals #1934.

## Problem

Carbon currently has no lexical syntax for character literals, and only provides
string literals and numeric literals. We wish to provide a distinct lexical
syntax for character literals versus string literals.

The advantage of having an explicit character type fundamentally comes down to
characters being represented as integers whereas strings are represented as
buffers. This will allow characters to have different operations, and be more
familiar to use. For example:

```
if (c >= 'A' and c <= 'Z') {
    c += 'a' - 'A';
}
```

The example above shows how we would be able to use operations similar to
integers. Being able to use the comparison operations and supporting arithmetic
operations provides an intuitive approach to using characters. This allows us to
remove unnecessary logic of type conversion and other control flow logic, that
is needed to work with a single element string. See [Rationale](#rationale) for
more examples showing more appropriate use of characters over using strings.

## Background

Character Literals by definition is a type of literal in programming for the
representation of a single character's value within the source code of a
computer program. Character literals between languages have some minor nuances
but are fundamentally designed for the same purpose. Languages that have a
dedicated character data type generally include character literals, for example
C++, Java, Swift to name a few. Whereas other languages that lack distinct
character type, like Python use strings of length one to serve the same purpose
a character data type. For more information see
[Character Literals Wiki](https://en.wikipedia.org/wiki/Character_literal),
[Character Literals DBpedia](https://dbpedia.org/page/Character_literal)

## Proposal

Put character literals in single quotes, like `'a'`. Character literals work
like numeric literals:

-   Every different literal value has its own type.
-   The bit width is determined by the type of the variable the literal is
    assigned to, not the literal itself. Follows the plan from #1934.

We will not support:

-   Multi-line literals
-   "raw" literals (using #'x'#)
-   Empty character literals (`''`)
-   ASCII Control codes (0...31), except for `\` when used for an escape
    sequence. See
    [String Literals: Escaping Sequence](https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p0199.md#escape-sequences-1)

## Details

A character literal is a sequence enclosed with single quotes delimiter ('),
excluding:

-   New line
-   Single quote (`'`), but can write `'` character as `'\''`
-   Back-slash (`\`), except when used to form an escape sequence. See
    [String Literals: Escaping Sequence](https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p0199.md#escape-sequences-1)

### Types

Since we will be representing the character literal as a sequence consisting of
elements that are each either a unicode code-point or a hex-encoded byte value.

We can see whether the particular literal is represented in the variable's type
by only looking at the types:

```
let allowed: u8 = 'a';
```

The above is allowed because the type of 'a' indicates that it can be converted
to `u8`.

```
let error1: u8 = 'ðŸ˜ƒ';
let error2: u8 = 'AB';
```

However these should produce errors, the types of 'ðŸ˜ƒ' and 'AB' indicate that
they cannot be converted to the declared type `u8`. However any `'\n'` and
`'\u{A}'` would be of the same type, as they are the same unicode entities
`%0A`. It is worth noting that `'\x0A'` will be slightly different as any
character following the `\x...` sequence representation are not the same as a
Unicode character. For example:

```
var c1: EBCDICChar = '\x0A';
var c2: EBCDICChar = '\n';
```

Here we assume that `c1` will be the EBCDIC RPT character (0xA) and for `c2` to
be the EBCDIC NL character (0x15)

### Operations

From the previous examples, we should be able to use the following operators:

-   Comparison: `<`, `>`, `<=`, `>=` `==`
-   Plus: `+`. However the behaviour of this operator is distinctly compared to
    its use with Strings. Rather then a concatenation, this will add the value
    of the two characters:
    -   If the `+` is used between a character literal and an integer literal,
        this should produce a character literal if the result fits into a
        Unicode code point or for a unicode hex code like `'\xAB'`, a single
        byte.
    -   If the `+` is used between a character literal and an integer
        non-literal this will produce and error.
    -   If the `+` is used between two character literals this will produce and
        error.
-   Subtract: `-` Similar to the plus operator, this will subtract the value of
    the two characters.

    -   If the `-` is used between a character literal and an integer literal,
        this should produce a character literal.
    -   If the `-` is used between two character literals this should produce
        and integer literal.
    -   If the `-` is used between a character literal and an integer
        non-literal this will produce and error.

    In other use cases where the `+` and `-` operators are used, in theory we
    should convert the character literal to some other type first. For example
    if we want to call `x - 'a'`, where `w` is of type `char` we would want to
    convert the `'a'` literal to a `char`.

### Encoding

Character literals written will be UTF-8 encoded, as all of Carbon source code
is UTF-8 encoded. See
[Unicode source files](https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p0142.md#character-encoding)

## Rationale

This proposal supports the goal of making Carbon code
[easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write).
Adding support for a specific character literal supports clean, readable,
concises use and is a much more familiar concept that will make it easier to
adopt Carbon coming from other languages. For Example when working with literals
represented as hex, having a distinct character literal type makes this much
simpler to work:

```
fn getSingleEAcuteHex(var combinedAcute: EBCDICChar) -> EBCDICChar {
    var eAcute: EBCDICChar = '\u{E0}';

    while (eAcute != combinedAcute) {
        eAcute += 1;
    }
    return eAcute;
}

    var combinedEAcute: EBCDICChar = '\u{65}\u{300}';
    var a: auto = getSingleEAcuteHex(combinedEAcute);
```

This allows us to use specific operations designed to manipulate the literals
value. Whereas with a String, we would need to have additional logic to store,
check and assign the specific value:

```
fn getSingleEAcuteHex(var combinedAcute: String) -> String {
    var eAcute: String = "\u{E0}";
    var accentValue: i32 = 0;

    while (eAcute != combinedAcute) {
        accentValue = accentValue + 1;
        eAcute = "\u{E{accentValue}}";
    }
    return eAcute;
}

    var combinedEAcute: String = "\u{65}\u{300}";
    var a: auto = getSingleEAcuteHex(combinedEAcute);
```

Using a `String` also leads to further issues regarding familiarty with other
languages and and leaves the logic generally open to errors, needing further
logic to check for a valid input.

Further, this design follows other standards set in place by previous proposals.
For example following the
[String Literals: Escaping Sequence](https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p0199.md#escape-sequences-1)
and representing characters as integers with the behaviour inline with
[Integer Literals](https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p0143.md).
This also supports our goal for
[Interoperability with and migration from existing C++ code](/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code)
by ensuring that every kind of character literal that exists in C++ can be
represented in a Carbon character literal. This is done in a way that is natural
to adopt, understand, easy to read by having explicit character types mapped to
the C++ character types and the correct associated encoding.

## Alternatives considered

### No distinct character literal

In principle a character literal can be represented by reusing string literals.
//TODO: Add Description

```
    var b: String = "b";
    var c: String = "c";
    if (c > b) {
        b = c + b;
    }
```

We would simply this as a single element string. However it terms of
readablility, if we had a distinct lexical syntax for character literals versus
string literals, this would be more inline with Carbon's language design goals
related to self documenting code, easy to read, understand, write and C++
interopability.

### Supporting Prefix Declarations

No support is proposed for prefix declarations like `u`, `U`, or `L`. In
practice they are used to specify the character literal types in languages like
C and C++, supporting these could help with the familiarity of coming to Carbon
with a more C++ or C background. Supporting this will help support a much
cleaner and readable syntax that is more inline with Carbon's goals, i.e
[Rationale](#rationale).

### Disallowing numeric escape sequences

Not support escaping numeric sequences. This would simplify some of the design
choices seen above, specifically how we manage [Types](#types) and of the
`EBCDIC` type, disallowing the `\x...` pattern. This would restrict users by
having to use the specific hex value, restrict when to use operations between
character literals and impact the readablilty of Carbon in some use cases.
