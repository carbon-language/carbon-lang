# Character literals

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/1964)

<!-- toc -->

## Table of contents

-   [Abstract](#abstract)
-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Details](#details)
    -   [Types](#types)
    -   [Operations](#operations)
    -   [Encoding](#encoding)
-   [Rationale](#rationale)
-   [Alternatives considered](#alternatives-considered)
    -   [Separate character and integer types](#separate-character-and-integer-types)
    -   [No Distinct Character Literal](#no-distinct-character-literal)
    -   [Supporting Prefix Declarations](#supporting-prefix-declarations)
    -   [Disallowing Numeric Escape Sequences](#disallowing-numeric-escape-sequences)

<!-- tocstop -->

## Abstract

This proposal specifies lexical rules for constant characters in Carbon:

Put character literals in single quotes, like `'a'`. Character literals work
like numeric literals:

Every different literal value has its own type. The bit width is determined by
the type of the variable the literal is assigned to, not the literal itself.
Follows the plan from Open design idea:
[#1934: Character Literals](https://github.com/carbon-language/carbon-lang/issues/1934).

## Problem

Carbon currently has no lexical syntax for character literals, and only provides
string literals and numeric literals. We wish to provide a distinct lexical
syntax for character literals versus string literals.

The advantage of having an explicit character type fundamentally comes down to
characters being represented as integers whereas strings are represented as
buffers. This will allow characters to have different operations, and be more
familiar to use. For example:

```
if (c >= 'A' and c <= 'Z') {
    c += 'a' - 'A';
}
```

The example above shows how we would be able to use operations similar to
integers. Being able to use the comparison operations and supporting arithmetic
operations provides an intuitive approach to using characters. This allows us to
remove unnecessary logic of type conversion and other control flow logic, that
is needed to work with a single element string. See [Rationale](#rationale) for
more examples showing more appropriate use of characters over using strings.

## Background

Character Literals by definition is a type of literal in programming for the
representation of a single character's value within the source code of a
computer program. Character literals between languages have some minor nuances
but are fundamentally designed for the same purpose. Languages that have a
dedicated character data type generally include character literals, for example
C++, Java, Swift to name a few. Whereas other languages that lack distinct
character type, like Python use strings of length one to serve the same purpose
a character data type. For more information see
[Character Literals Wiki](https://en.wikipedia.org/wiki/Character_literal),
[Character Literals DBpedia](https://dbpedia.org/page/Character_literal)

## Proposal

Put character literals in single quotes, like `'a'`. Character literals work
like numeric literals:

-   Every different literal value has its own type.
-   The bit width is determined by the type of the variable the literal is
    assigned to, not the literal itself. Follows the plan from #1934.

We will not support:

-   Multi-line literals
-   "raw" literals (using #'x'#)
-   Empty character literals (`''`)
-   ASCII Control codes (0...31), except when specified with an escape sequence.
-   Whitespace characters other than word space: tab, line feed, carriage
    return, form feed, and vertical tab. See
    [String Literals: Escaping Sequence](https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p0199.md#escape-sequences-1)

## Details

A character literal is a sequence enclosed with single quotes delimiter ('),
excluding:

-   New line
-   Single quote (`'`), but can write `'` character as `'\''`
-   Back-slash (`\`), except when used to form an escape sequence. See
    [String Literals: Escaping Sequence](https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p0199.md#escape-sequences-1)
-   Whitespace characters other than space (` `).
-   ASCII control codes (0...31).

### Types

We will represent a character literal as a sequence consisting of elements that
are each either a unicode code-point or a hex-encoded byte value.

We can see whether the particular literal is represented in the variable's type
by only looking at the types:

```
let allowed: Char8 = 'a';
```

The above is allowed because the type of `'a'` is the character literal
consisting of the single Unicode code point 97, which can be converted to
`Char8` since 97 fits in 8 bits. Here, `Char8` is a type that can represent a
single 8-bit character, like C++'s `char8_t`. `Char8` is used for exposition and
is not part of this proposal.

```
let error1: Char8 = 'ðŸ˜ƒ';
let error2: Char8 = 'AB';
```

However these should produce errors. The type of `'ðŸ˜ƒ'` is the character literal
consisting of the single Unicode code point `0x1F603`, which is too big to fit
in 8 bits. The type of `'AB'` is a character literal that is a sequence of two
Unicode code points, which has no conversion to a type that only handles one.

It is important to point out that any `'\n'` and `'\u{A}'` would be of the same
type, as they are the same unicode entities `%0A`. However, `'\x0A'` will be
slightly different as any character following the `\x...` sequence
representation is not the same as a Unicode character. For example:

```
var c1: EBCDICChar = '\x0A';
var c2: EBCDICChar = '\n';
```

Here we assume that `c1` will be the EBCDIC RPT character (0xA) and for `c2` to
be the EBCDIC NL character (0x15)

### Operations

From the previous examples, we should be able to use the following operators:

-   Comparison: `<`, `>`, `<=`, `>=` `==`
    -   If any of the comparison operators are used between a code point and a
        code unit, this will produce an error.
-   Plus: `+`. However the behaviour of this operator is distinct compared to
    its use with Strings. Rather than a concatenation, this will add the value
    of the two characters:
    -   If the `+` is used between a character literal representing a single
        Unicode code point and an integer literal, this should produce a
        character literal if the result fits in a Unicode code point. Similarly,
        `+` between a hex code like `'\xAB'` and an integer literal results in a
        character literal if the result fits in a single byte.
    -   If the `+` is used between a character literal and an integer
        non-literal this will produce an error.
    -   If the `+` is used between two character literals this will produce an
        error.
-   Subtract: `-` Similar to the plus operator, this will subtract the value of
    the two characters.

    -   If the `-` is used between a character literal representing a single
        code point or code unit and an integer literal, this should produce a
        character literal as long as the result of the difference is in range.
    -   If the `-` is used between two character literals, which are either both
        a single code point or both a single code unit, this should produce an
        integer literal representing the difference between the code points or
        code units.
    -   If the `-` is used between a character literal and an integer
        non-literal this will produce an error.
    -   If the `-` operator is used between a code point and a code unit, this
        will produce an error.

    In cases where the `+` and `-` operators are used with a character literal
    and a non-integer non-literal, the character literal should be converted to
    the type of the other operand if possible. For example, in the expression
    `w - 'a'`, where `w` is of type `Char`, the `'a'` literal will be converted
    to type `Char`.

There is intentionally no conversion from character literals to integer types.
Carbon will separate the integer types from character types entirely.

### Encoding

Character literals written will be UTF-8 encoded, as all of Carbon source code
is UTF-8 encoded. See
[Unicode source files](https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p0142.md#character-encoding)

## Rationale

This proposal supports the goal of making Carbon code
[easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write).
Adding support for a specific character literal supports clean, readable,
concise use and is a much more familiar concept that will make it easier to
adopt Carbon coming from other languages. Have a distinct character literal will
also allow us support useful operations designed to manipulate the literal's
value. When working with `String`, we use the `+` operator to concatenate
multiple `String`s, but say we wanted to advance a character to the next
literal. Using a `String` will produce a type error, as we are misusing the `+`
operator: `"a" + 1`. However with a character literal, we can support operations
for these use cases:

```
var b: u8;

b = 'a' + 1;
b + 1 == 'c';

```

See [Operations](#operations) and
[No Distinct Character Literal](#no-distinct-character-literal) for more
information.

Further, this design follows other standards set in place by previous proposals.
For example following the
[String Literals: Escaping Sequence](https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p0199.md#escape-sequences-1)
and representing characters as integers with the behaviour inline with
[Integer Literals](https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p0143.md).

This also supports our goal for
[Interoperability with and migration from existing C++ code](/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code)
by ensuring that every kind of character literal that exists in C++ can be
represented in a Carbon character literal. This is done in a way that is natural
to adopt, understand, easy to read by having explicit character types mapped to
the C++ character types and the correct associated encoding.

Finally, the choice to use Unicode and UTF-8 by default reflects the Carbon goal
to prioritize
[modern OS platforms, hardware architectures, and environments](/docs/project/goals.md#modern-os-platforms-hardware-architectures-and-environments).
This reflects the
[growing adoption of UTF-8](https://en.wikipedia.org/wiki/UTF-8#Adoption).

## Alternatives considered

### Separate character and integer types

Unlike C++, Carbon will separate the integer and the character types. Carbon
character types add the information that the represented integer is a code unit
of some particular encoding. Without knowing the encoding, it is ambiguous how
to interpret an integer value.

### No Distinct Character Literal

In principle, a character literal can be represented by reusing string literals
similar to how Python handles character literals, however this would prevent
performing operations on characters as integers. For example, the `+` operator
on strings is used for concatenation, but `+` on a character would change its
value.

```
    var a: Char8 = 'a';
    var b: Char8 = 'b';

    if (a < b) {
        a += 1;
    }
```

When working with code points, there is an advantage to having a distinct
character literal. Primarily when discussing the readablity of the design
choice, and working with code points similar to the example above. When looking
at the two variables it is clear that `acute2` contains two code points, but
when using a `String` there is no way to evaluate if it is a single valid
character of multiple code points or two characters. `\u{301}\u{65}` is a valid
single character comprised of multiple code points resulting in `Ã©`, however
this could easily be mistaken as a `String` comprised of two code points, for
example `\u{400}\u{65}` which is two characters resulting in `Ð€e`.

### Supporting Prefix Declarations

No support is proposed for prefix declarations like `u`, `U`, or `L`. In
practice they are used to specify the character literal types and their encoding
in languages like C and C++. There are a several benefits to omitting prefix
declarations; improved readablitly, simplifying how a character's type is
determined, and how we are encoding character literals. When declaring a
character literal, the type is based on the contents of the character so that
`var c: u8 = 'a'` is a valid character that can be converted to `u8`, in order
to support prefix declarations we would need to extend our type system to have
other exlpicit type checks like in C++; a UTF-16 `u'`, UTF-32 `U'`, and wide
characters `L'`. This would be more familiar for individuals coming to Carbon
from a C++ background, and simplify our approach for C++ Interoperability. At
the cost of diverge from existing standards, for example
[Proposal 142](https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p0142.md#character-encoding)
states all of Carbon source code should be UTF-8 encoded. Prefix declarations
would detract the readability of the character literals and increase the
complexity of character literal [Types](#types).

### Disallowing Numeric Escape Sequences

Not support escaping numeric sequences. This would simplify some of the design
choices seen above by making types, the restrictions and behavior of character
literals simpler. Specifically [Types](#types) of `EBCDIC`, by disallowing the
`\x...` pattern. However this would affect the readability, type-safety and
consistency of character literals. If we were to disallow numeric escape
sequences for character literals, that diverges from the `String` type which
does allow for numeric escape sequences so we would essentially have the
functionality to declare character literals but within a string literal.
Additiaonlly, we could remove numeric escape sequences from string liteals, but
there are other draw backs to discuss in that arena. In terms of type-safety and
readability, if we take a look at `var first_digit: char = 0;` it's hard to see
the intention, is this supposed to be a `NUL` character or is it supposed to be
the character zero `'0'`? Whereas supporting numeric escape sequences, we can
write `var first_digit: char = '0'` or `var first_digit: char = '\0'` where the
intention is clear and defined. Further, if we use integer literals instead of
code unit escape sequences a user would assume we support initializing character
types from integer literals `first_digit: char = 0;`, leading to assumptions
surrounding how we'll permit implicit conversion from non-constant
integer-valued expressions to character types. This would essentially diminish
our ability to distinguish between numbers and characters in our type system.
