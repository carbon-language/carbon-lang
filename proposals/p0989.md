# Member access expressions

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/989)

<!-- toc -->

## Table of contents

-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Details](#details)
-   [Rationale based on Carbon's goals](#rationale-based-on-carbons-goals)
-   [Alternatives considered](#alternatives-considered)

<!-- tocstop -->

## Problem

We need syntaxes for a number of closely-related operations:

-   Given an expression denoting a package, namespace, class, interface, or
    similar, and the name of one of its members, form an expression denoting the
    member. In C++ and Rust, this is spelled `Container::MemberName`. In many
    other languages, it is spelled `Container.MemberName`.

-   Given an expression denoting an object and a name of one of its fields, form
    an expression denoting the corresponding subobject. This is commonly written
    as `object.field`, with very little deviation across languages.

-   Given an expression denoting an object and a name of one of its methods,
    form an expression that calls the function on the object. This is commonly
    written as `object.function(args)`.

-   Given an expression denoting a type, and an expression denoting a member of
    an interface, form an expression denoting the corresponding member in the
    `impl` of that interface for that type.

Further, we need rules describing how the lookup for the member name is
performed, and how this lookup behaves in generics and in templates in cases
where the member name depends on the type or value of the first operand.

## Background

C++ and Rust distinguish between the first use case and the rest. Other
languages, such as Swift and C#, do not, and model all of these use cases as
some generalized form of member access, where the member might be a namespace
member, an interface member, an instance member, or similar.

See also:

-   [Exploration of member lookup in generic and non-generic contexts](https://docs.google.com/document/d/1-vw39x5YARpUZ0uD2xmKepLEKG7_u122CUJ67hNz3hk/edit)
-   [Question for leads: constrained template name lookup](https://github.com/carbon-language/carbon-lang/issues/949)

## Proposal

All these operations are performed using `.`:

```carbon
fn F() {
  // Can perform lookup inside the package or namespace.
  var x: Package.Namespace.Class;
  // Can perform lookup inside the type of the value.
  x.some_field = x.SomeFunction(1, 2, 3);
}
```

When the type of the left-hand operand is a generic type parameter, lookup is
performed in its type-of-type instead. Effectively, a generic type parameter
behaves as an archetype:

```carbon
interface Hashable {
  let HashValue:! Type;
  fn Hash[me: Self]() -> HashValue;
  fn HashInto[me: Self](s: HashState);
}
fn G[T:! Hashable](x: T) {
  // Can perform lookup inside the type-of-type if the type is
  // a generic type parameter.
  x.Hash();
}
```

When the type of the left-hand operand is a template parameter, the lookup is
performed both in the actual type corresponding to that template parameter and
in the archetype, as described above. If a result is found in only one lookup,
or the same result is found in both lookups, that result is used. Otherwise, the
member access is invalid.

```carbon
class Potato {
  fn Mash[me: Self]();
  fn Hash[me: Self]();
  alias HashValue = Hashable.HashValue;
}
extern impl Potato as Hashable where .HashValue = u32 {
  // ...
}
fn H[template T:! Hashable](x: T, s: HashState) {
  // When called with T == Potato:
  // ❌ Ambiguous, could be `Potato.Hash` or `Hashable.Hash`.
  x.Hash();
  // ✅ OK, found only in `Potato`.
  x.Mash();
  // ✅ OK, found only in `Hashable`.
  x.HashInto(s);

  // ✅ OK, same `HashValue` found in both `Potato` and `Hashable`;
  // `Hashable.Hash` unambiguously names the interface member.
  var v: T.HashValue = x.(Hashable.Hash)();

  // ✅ OK, unambiguously names the type member.
  x.(Potato.Hash)();
}
```

## Details

See
[the changes to the design](https://github.com/carbon-language/carbon-lang/pull/989/files).

## Rationale based on Carbon's goals

-   [Software and language evolution](/docs/project/goals.md#software-and-language-evolution)
    -   Rejecting cases in a template where a generic interpretation and an
        interpretation with specific types would lead to different meanings
        supports incremental migration towards generics by way of a template,
        where the compiler will help you find places that would change meaning.
-   [Code that is easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write)
    -   Using a single, familiar `container.member` notation for all the member
        access use cases minimizes the complexity of this portion of the
        language syntax.
-   [Interoperability with and migration from existing C++ code](/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code)
    -   The behavior of templates is aligned with that in C++, simplifying both
        comprehension for C++ developers and migration of C++ code.

## Alternatives considered

-   [Question for leads: constrained template name lookup](https://github.com/carbon-language/carbon-lang/issues/949)
