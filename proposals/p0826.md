# Function return type inference

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/826)

<!-- toc -->

## Table of contents

-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Details](#details)
    -   [No separate declaration and definition](#no-separate-declaration-and-definition)
    -   [Restricting to generic use](#restricting-to-generic-use)
-   [Rationale based on Carbon's goals](#rationale-based-on-carbons-goals)
-   [Alternatives considered](#alternatives-considered)
    -   [Only allow `auto` return types if parameters are generic](#only-allow-auto-return-types-if-parameters-are-generic)

<!-- tocstop -->

## Problem

Should there be a shorter way of declaring a function? This embodies two
questions:

-   Should there be a way for a declarer to ask that the return type of a
    function be inferred from returned values?
-   Should there be an alternate function syntax that provides briefer function
    declarations for simple cases?

## Background

Under
[Proposal #438: Add statement syntax for function declarations](https://github.com/carbon-language/carbon-lang/pull/438),
the syntax approved was:

> `fn` _identifier_ `(` _args_ `)` _[_ `->` _expression ]_ `{` _statements_ `}`

Executable semantics currently supports the syntax:

> `fn` _identifier_ `(` _args_ `) =>` _expression_

In C++, there is similar automatic type inference for return types, although the
use of `=>` reflects syntax tentatively discussed for matching use.

Lambdas are also under discussion for Carbon: however, a different syntax is
likely to arise. It's not guaranteed that the syntax will match.

## Proposal

Support automatic type inference in Carbon, but do it with `auto`, as in:

> `fn` _identifier_ `(` _args_ `)` _[_ `-> auto {` _statements_ `}`

Executable semantics will remove the `=>` function syntax.

For now, only one return statement is allowed: we will avoid defining rules for
handling differing return types.

In practice, this means the syntax:

```
fn Add(x: i32, y: i32) => x + y;
```

Becomes:

```
fn Add[Size:! i32](x: Int(Size), y: Int(Size)) -> auto { return x + y; }
```

## Details

### No separate declaration and definition

The return type must be possible to determine from the declaration. As a
consequence, the declaration and definition of a function returning `auto`
cannot be separated: if they were, even within the same file, a caller could not
be guaranteed to see the definition in name lookup in a way that would allow
determining the return type.

### Restricting to generic use

The use of `auto` as a return type is likely to reduce readability if overused,
as it will require reading the function body to determine the return type. As a
consequence, this proposal suggests restrictions on use.

`auto` should only be allowed when a parameter in determining the return type is
generic. For example, `fn Add(x: i32, y: i32) -> auto { return x + y; }` is
invalid because the return type should be `i32`.

This should hold true if there are generic parameters which aren't needed to
determine the return type. For example, consider
`fn ReturnX(x: i32, y:! Type) -> auto { return x; }`. While `y` is a generic
parameter, it is not used when determining the return type of the function, and
as a consequence `auto` is not valid.

This still holds true when a function with non-generic parameters returns a
generic function with an `auto` return. Although the generic function may
validly use `auto`, the function with non-generic parameters can have only one
return type. There is no need to use `auto` in this case.

## Rationale based on Carbon's goals

-   [Performance-critical software](/docs/project/goals.md#performance-critical-software)
-   [Software and language evolution](/docs/project/goals.md#software-and-language-evolution)
-   [Code that is easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write)

    -   We are avoiding providing an alternative function syntax in order to
        provide users less syntax they'll need to understand.
    -   As a practical measure, there are likely to be cases in generic code
        that are more feasible to write
    -   As a downside of this proposal, the use of `auto` as a return type is
        likely to reduce readability if overused, as it will require reading the
        function body to determine the return type.

-   [Practical safety and testing mechanisms](/docs/project/goals.md#practical-safety-and-testing-mechanisms)
-   [Fast and scalable development](/docs/project/goals.md#fast-and-scalable-development)
-   [Modern OS platforms, hardware architectures, and environments](/docs/project/goals.md#modern-os-platforms-hardware-architectures-and-environments)
-   [Interoperability with and migration from existing C++ code](/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code)

## Alternatives considered

### Only allow `auto` return types if parameters are generic

We could detect whether parameters used in determining an `auto` return type are
generic, and only allow `auto` to be used when they are.

Advantages:

-   Restricts use of `auto` to where it is more likely to be difficult to write
    code without it.

Disadvantages:

-   Increases the rule set around use of `auto` in return types.

This alternative may merit discussion on this proposal, and could easily be
added to the proposed text if strongly desired. I'm defaulting without it
because there may be
