# Function return type inference

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/826)

<!-- toc -->

## Table of contents

-   [Problem](#problem)
-   [Background](#background)
    -   [Lambdas](#lambdas)
-   [Proposal](#proposal)
-   [Details](#details)
    -   [Separate declaration and definition](#separate-declaration-and-definition)
    -   [Explicit return required](#explicit-return-required)
    -   [Executable semantics changes](#executable-semantics-changes)
-   [Rationale based on Carbon's goals](#rationale-based-on-carbons-goals)
-   [Open questions](#open-questions)
    -   [Multiple returns](#multiple-returns)
-   [Alternatives considered](#alternatives-considered)
    -   [Only allow `auto` return types if parameters are generic](#only-allow-auto-return-types-if-parameters-are-generic)
    -   [Provide alternate function syntax for concise return type inference](#provide-alternate-function-syntax-for-concise-return-type-inference)

<!-- tocstop -->

## Problem

Should there be a shorter way of declaring a function? This embodies two
questions:

-   Should there be a way for a declarer to ask that the return type of a
    function be inferred from returned values?
-   Should there be an alternate function syntax that provides briefer function
    declarations for simple cases of return type inference?

## Background

Under
[Proposal #438: Add statement syntax for function declarations](https://github.com/carbon-language/carbon-lang/pull/438),
the syntax approved was:

> `fn` _identifier_ `(` _args_ `)` _[_ `->` _expression ]_ `{` _statements_ `}`

Executable semantics currently supports the syntax:

> `fn` _identifier_ `(` _args_ `) =>` _expression_

In C++, there is similar automatic type inference for return types, although the
use of `=>` reflects syntax tentatively discussed for matching use.

### Lambdas

Lambdas are also under discussion for Carbon: however, a different syntax is
likely to arise. This proposal does not try to address lambda syntax, although
it is possible that a decision on lambda syntax may lead to an alternate syntax
for declaring functions in order to maintain syntax parity.

## Proposal

Support automatic type inference in Carbon with `auto`, as in:

> `fn` _identifier_ `(` _args_ `)` _[_ `-> auto {` _statements_ `}`

For now, only one return statement is allowed: we will avoid defining rules for
handling differing return types.

## Details

### Separate declaration and definition

The return type must be possible to determine from the declaration. As a
consequence, the declaration and definition of a function returning `auto`
cannot be significantly separated: a caller must be able to see the definition.

For example, this is valid because `CallAdd` can see the `Add` definition:

```
fn Add(x: i32, y: i32) -> auto;

fn Add(x: i32, y: i32) -> auto { return x + y; }

fn CallAdd() -> i32 { return Add(1, 2); }
```

However, this is invalid because `CallAdd` can only see the `Add` declaration
(even though the definition may be in the same file), and it would need the
definition to determine the return type:

```
fn Add(x: i32, y: i32) -> auto;

fn CallAdd() -> i32 { return Add(1, 2); }

fn Add(x: i32, y: i32) -> auto { return x + y; }
```

### Explicit return required

Functions using `-> auto` must return an expression; using the implicit return
or `return;` is invalid. This is consistent with the
[design for returning empty tuples](/docs/design/control_flow/return.md#returning-empty-tuples).

### Executable semantics changes

Executable semantics will remove the `=>` function syntax.

In practice, this means the current executable semantics syntax:

```
fn Add(x: i32, y: i32) => x + y;
```

Becomes:

```
fn Add(x: i32, y: i32) -> auto { return x + y; }
```

## Rationale based on Carbon's goals

-   [Code that is easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write)

    -   We are avoiding providing an alternative function syntax in order to
        provide users less syntax they'll need to understand.
    -   As a practical measure, there are likely to be cases in generic code
        that are more feasible to write.

-   [Interoperability with and migration from existing C++ code](/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code)

    -   The intent is to have `auto` as a return type work similarly to C++'s
        type inference, in order to ease migration.

## Open questions

### Multiple returns

It's likely that we should support `auto` on functions with multiple returns.
This proposal declines to address that use-case because of the complexities
which arise when return types may differ. Instead, the use-case is left for
future proposals to handle.

## Alternatives considered

### Only allow `auto` return types if parameters are generic

`auto` return types are likely to be a negative impact to readability, because a
reader must read the function body in order to determine the return type. We
could detect whether parameters used in determining an `auto` return type are
generic, and only allow `auto` to be used when they are.

Advantages:

-   Limits the readability impact of `auto`.
    -   `auto` could not be used where the return type is clearly deterministic,
        and thus easy to write. In these cases, readers would never need to look
        at the function body to determine the return.
    -   `auto` could be used where the return type may be difficult to easily
        write as a consequence of potential generic parameters.

Disadvantages:

-   Increases the rule set around use of `auto` in return types.
-   Breaks C++ compatibility.

The decision to allow `auto` in more cases is primarily for C++ compatibility.

### Provide alternate function syntax for concise return type inference

Executable semantics currently demonstrates an alternate function syntax with:

```
fn Add(x: i32, y: i32) => x + y;
```

This is a more concise syntax that builds upon return type inference. We could
keep that, or come up with some other syntax.

Advantages:

-   For short functions, provides a more succinct manner of defining the
    function.
-   `=>` use echoes tentative matching syntax.

Disadvantages:

-   Creates an additional syntax which can be used for equivalent behavior.
-   Overlaps with lambda use-cases, but lambdas will likely end up looking
    different; that is, we should not assume the syntax will converge.
    -   We may in particular take a more sharply divergent syntax for lambdas,
        in order to allow for significant brevity in typing, which may not make
        sense to support for function declarations.
-   Limits use of `=>` for other purposes.
    -   To the extent that `=>` might primarily be replacing `-> auto`, assuming
        Carbon adopted Rust-style
        [block expression returns](https://doc.rust-lang.org/reference/expressions/block-expr.html),
        this offers limited value for the additional token use.

This proposal suggests not adding an inference-focused alternate function syntax
at this time; while consistent with tentative matching syntax, the split from
function syntax is significant.

If an alternate function syntax is added, it should be done in tandem with a
lambda proposal in order to ensure consistency in syntax.
