# 2021 Roadmap

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/253)

## Main objective: ramp up investment

The main objective of the Carbon project in 2021 is to ramp up investment in the
project, even while it remains both an experiment and private. This needs to
manifest along two dimensions:

-   Increase the investment of specific individuals and organizations.
-   Increase the breadth of different individuals and organizations investing at
    a given level.

To help illustrate the kinds of work that should be prioritized as part of this
objective, here are some abstract but narrower objectives or efforts that are
well aligned and seem likely to be in the critical path:

-   Building various aspects of a compelling demo of Carbon.
-   Identifying the most important information (especially other than a demo)
    for participants to gain confidence in Carbon's value proposition and
    viability.
-   Identifying key missing participants and onboarding them.

## Main key results for Carbon in 2021

We suggest measuring our progress on this objective with both high level key
results that directly map to the objective, as well as with more concrete key
results that we feel are on the critical path.

### Increase active proposal authors to 8 people

We define "active" as making at least four proposals during 2021, with at least
two being accepted.

### Increase implementation active contributors to `8 people

We define "active" here as at least 10 pull requests with at least 5 merged.

### Broaden core team representation so no organization is >50%

Our goal is that no single organization makes up >50% of the core team to ensure
that we are including as broad and representative a set of perspectives in the
evolution of Carbon as possible.

## Concrete, intermediate key results on the critical path

There are several milestones that we believe are fundamentally on the critical
path to successfully achieving our main goal for the year. These milestones also
point to aspects of _how_ we should go about achieving the higher level results.
Because these are more specific and concrete, they also have a detailed
explanation of the nature of the result and what motivates it.

### Example ports of C++ libraries to Carbon (100% of [woff2](https://github.com/google/woff2), 99% of [RE2](https://github.com/google/re2))

The first part of this result is that all of the woff2 library is ported to
Carbon in a way that exports the same C++ API. There should be no gaps in this
port given that woff2 has a very simple C++ API and uses few C++ language
features.

RE is a larger library using significantly more language features. For that part
of the result, fewer than 1% of its C++ lines of code should be missing a
semantically meaningful port into Carbon code. This means the relevant syntax
and semantic proposals to explain what the resulting Carbon code means must
exist and be accepted. It doesn't necessarily require either formal
specification or implementation for these parts of Carbon code.

An important nuance of this goal is that it doesn't include building a Carbon
standard library. The intent is to exercise and show the interoperability layers
of Carbon by re-using the C++ standard library and exporting a compatible C++
API to both woff2 and RE2's current API.

While this key result isn't directly tied to the main objective, we believe it
represents a critical milestone for being able to achieve this objective. It
both measures our progress solidifying Carbon's design and demonstrating the
value proposition of Carbon.

Note that both woff2 and RE2 libraries are chosen somewhat arbitrarily and could
easily be replaced with a different, more effective libraries to achieve the
fundamental result of demonstrating a compelling body of cohesive design and the
overarching value proposition.

### Demo implementation of core features with working examples

A core set of Carbon features should be implemented sufficiently to build
working examples of those features and run them successfully. These features
could include:

-   User-defined types, functions, namespaces, packages, and importing.
-   Basic generic functions and types using interfaces.
-   Initial/simple implementation of safety checking including at least bounds
    checking, simple lifetime checking, and simple initialization checking.
-   Sum types sufficient for optional-types to model nullable pointers.
-   Pattern matching sufficient for basic function overloading on types and
    arity, as well as unwrapping of optional types for guard statements.

Stretch goals if we can hit the above:

-   Instantiating a basic C++ template through interop layer for use within
    Carbon.

The demo implementation should also provide demos outside of specific language
features including:

-   Basic benchmarking of the different phases of compilation (lexing, parsing,
    etc).
-   A basic REPL command line.

Stretch goals if we can hit the above:

-   Automatic code formatter on top of the implementation infrastructure.
-   A compiler explorer fork with REPL integrated.

Benchmarking at this stage isn't expected to include extensive optimization.
Instead, it should focus on letting us track large/high-level impact on
different phases as they are developed or features are added. They may also help
illustrate initial high-level performance characteristics of the implementation,
but the long term focus should be on end-to-end user metrics.

Automatic code formatting could be achieved many ways, but it seems useful to
ensure the language and implementation both support use cases like formatting.

### Executable semantic specification for core features with test cases

This should include both a human readable rendering of the formal semantics as
well as an execution environment to run test cases through those semantics. The
core features which should be covered by these semantics are:

-   User-defined types, functions, namespaces, packages, and importing.
-   Basic generic functions and types using interfaces.
-   Sum types sufficient for optional-types to model nullable pointers.

This is intentionally a subset of the features covered by the demo
implementation. The intent is to reflect that _completing_ coverage of the
features in the specification is a slightly lower priority, and instead we
should rapidly spike out as complete of a demo as possible and come back to the
semantics if possible.
