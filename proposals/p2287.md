# Allow unqualified name lookup for class members

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/####)

<!-- toc -->

## Table of contents

-   [Abstract](#abstract)
-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
    -   [Namespaces](#namespaces)
-   [Rationale](#rationale)
-   [Alternatives considered](#alternatives-considered)
    -   [No unqualified lookup when defining outside a scope](#no-unqualified-lookup-when-defining-outside-a-scope)

<!-- tocstop -->

## Abstract

Allow unqualified name lookup for class members, whether inside the class scope
or within an out-of-line function definition.

## Problem

[Member access](/docs/design/expressions/member_access.md) defines certain
member access behaviors. However, it doesn't cover what happens if an
unqualified name lookup occurs within a class, particularly for an out-of-line
member function definition.

## Background

The [member access design](/docs/design/expressions/member_access.md) and
[information accumulation principle](/docs/project/principles/information_accumulation.md)
affect this.

This will also work similarly to
[unqualified lookup within C++](https://en.cppreference.com/w/cpp/language/unqualified_lookup).

## Proposal

Allow unqualified name lookup for class members.

This proposal updates [the class design](/docs/design/classes.md) to address
this.

### Namespaces

More generally, this should also be true of other scopes used in declarations.
In particular, namespaces should also follow the same rule. However, since
[name lookup](/docs/design/name_lookup.md) has not been fleshed out, this won't
make much of an update to it.

An example for namespaces would be:

```carbon
namespace Foo;
var Foo.a: i32 = 0;

class Foo.B {}

// `b` and `a` are valid here because unqualified name lookup occurs within `Foo`.
fn Foo.C(B b) -> i32 {
  return a;
}
```

## Rationale

-   [Code that is easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write)
    -   Performing unqualified name lookup for class members should be fairly
        unsurprising to readers, and should allow for more concise code when
        working within a namespace.
-   [Interoperability with and migration from existing C++ code](/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code)
    -   This behavior will be similar to how C++ works.

## Alternatives considered

### No unqualified lookup when defining outside a scope

We could not support unqualified lookup when defining something that is
presented within the top-level scope of the file.

Note this has subtle implications. If `Foo.C` in the namespace example is
considered to be outside the `Foo` scope for this purpose, it means the function
would need to look like:

```
fn Foo.C(Foo.B b) -> i32 {
   return Foo.a;
}
```

It could also mean that, on a class, an inline declaration
`fn Foo() -> ClassMember` is valid, while an out-of-line definition
`fn Class.Foo() -> ClassMember` is not, requiring `Class.ClassMember`.

Advantages:

-   Explicit in access.
    -   For example, name lookup results could be mildly confusing if both
        `package.a` and `package.Foo.a` are defined but `package.Foo.a` is
        hidden in code while `package.a` is easy to find. It's likely that
        `package.Foo.a` would be considered unambiguous for unqualified name
        lookup.

Disadvantages:

-   Very verbose, and could prove un-ergonomic for developers.
