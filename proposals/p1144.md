# Generic details 11: operator overloading

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/1144)

<!-- toc -->

## Table of contents

-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Rationale based on Carbon's goals](#rationale-based-on-carbons-goals)
-   [Alternatives considered](#alternatives-considered)
    -   [Weak impls instead of adapters for reverse implementations](#weak-impls-instead-of-adapters-for-reverse-implementations)
    -   [Default impls instead of adapters for reverse implementations](#default-impls-instead-of-adapters-for-reverse-implementations)

<!-- tocstop -->

## Problem

C++ supports
[operator overloading](https://en.wikipedia.org/wiki/Operator_overloading), and
we would like Carbon to as well. This proposal is about the general problem, not
the specifics application to any particular operator.

This proposal does not attempt to define a mechanism by which we can ensure that
`a < b` has the same value as `b > a`.

## Background

The generics feature is the
[single static open extension mechanism](/docs/project/principles/static_open_extension.md)
in Carbon, and so will be what we use operator overloading. We have already
started specifying the ability to extend or customize the behavior of operators
by implementing interfaces, as in these proposals:

-   [#820: Implicit conversions](https://github.com/carbon-language/carbon-lang/pull/820)
-   [#845: as expressions](https://github.com/carbon-language/carbon-lang/pull/845)
-   [#911: Conditional expressions](https://github.com/carbon-language/carbon-lang/pull/911)
-   [#1083: Arithmetic expressions](https://github.com/carbon-language/carbon-lang/pull/1083)

Proposal
[#702: Comparison operators](https://github.com/carbon-language/carbon-lang/pull/702)
specified
[using interfaces for overloading the comparison operators](p0702.md#overloading),
but did not pin down specifically what those interfaces are.

## Proposal

This proposal adds a
["Operator overloading" section](/docs/design/generics/details.md#operator-overloading)
to the [detailed design of generics](/docs/design/generics/details.md).

## Rationale based on Carbon's goals

TODO: How does this proposal effectively advance Carbon's goals? Rather than
re-stating the full motivation, this should connect that motivation back to
Carbon's stated goals for the project or language. This may evolve during
review. Use links to appropriate goals, for example:

-   [Community and culture](/docs/project/goals.md#community-and-culture)
-   [Language tools and ecosystem](/docs/project/goals.md#language-tools-and-ecosystem)
-   [Performance-critical software](/docs/project/goals.md#performance-critical-software)
-   [Software and language evolution](/docs/project/goals.md#software-and-language-evolution)
-   [Code that is easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write)
-   [Practical safety and testing mechanisms](/docs/project/goals.md#practical-safety-and-testing-mechanisms)
-   [Fast and scalable development](/docs/project/goals.md#fast-and-scalable-development)
-   [Modern OS platforms, hardware architectures, and environments](/docs/project/goals.md#modern-os-platforms-hardware-architectures-and-environments)
-   [Interoperability with and migration from existing C++ code](/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code)

## Alternatives considered

The current proposal requires the user to define a reverse implementation, and
recommends using an adapter to do that more conveniently. We also considered
approaches that would provide the reverse implementation more automatically.

### Weak impls instead of adapters for reverse implementations

We proposed
[weak impls](https://github.com/carbon-language/carbon-lang/pull/1027) as a way
of defining blanket impls that did not introduce
[cycles](/docs/design/generics/details.md#acyclic-rule). We rejected that
approach due to giving the reverse implementation the wrong priority. This meant
that there were many situations where `a < b` and `b > a` would give different
answers.

### Default impls instead of adapters for reverse implementations

We then proposed
[default impls](https://github.com/carbon-language/carbon-lang/pull/1034) as a
way to define reverse implementations. These were rejected because they had a
lot of overlap with blanket impls, making it difficult to describe when to use
one over the other, and because they introduced a lot of complexity without
fully solving the priority problem. Most of the complexity was from the criteria
for determining whether the default implementation would be used. As
[noted](/docs/design/generics/details.md#binary-operators), the current proposal
still has some priority issues, but this way the relevant impls are visible in
the source which will hopefully make it clearer why it happens.

The capability to give implementations of other interfaces conveniently provided
by default impls may prove useful enough that we would reconsider this decision
in the future.
