# Binding operators

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/3720)

<!-- toc -->

## Table of contents

-   [Abstract](#abstract)
-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Details](#details)
    -   [Inheritance and other implicit conversions](#inheritance-and-other-implicit-conversions)
    -   [Data fields](#data-fields)
    -   [Generic type of a class member](#generic-type-of-a-class-member)
    -   [C++ pointer to member](#c-pointer-to-member)
    -   [Member forwarding](#member-forwarding)
    -   [Future: properties](#future-properties)
-   [Rationale](#rationale)
-   [Alternatives considered](#alternatives-considered)

<!-- tocstop -->

## Abstract

TODO: Describe, in a succinct paragraph, the gist of this document. This
paragraph should be reproduced verbatim in the PR summary.

## Problem

TODO: What problem are you trying to solve? How important is that problem? Who
is impacted by it?

## Background

-   [Qualified names and member access](/docs/design/expressions/member_access.md)
-   [Proposal #989: Member access expressions](https://github.com/carbon-language/carbon-lang/pull/989)
-   [Proposal #2360: Types are values of type `type`](https://github.com/carbon-language/carbon-lang/pull/2360)
-   [Proposal #2875: Functions, function types, and function calls](https://github.com/carbon-language/carbon-lang/pull/2875)

TODO: Is there any background that readers should consider to fully understand
this problem and your approach to solving it?

## Proposal

TODO: Briefly and at a high level, how do you propose to solve the problem? Why
will that in fact solve it?

## Details

TODO: Fully explain the details of the proposed solution.

To use instance members of a class, we need to go through the additional step of
_binding_. Consider a class `C`:

```carbon
class C {
  fn Value[self: Self]() -> i32 { return self.x + 5; }
  fn Mutate[addr self: Self*]() -> i32 { self.x += 1; return self.x; }
  fn Static() -> i32 { return 2; }
  var x: i32;
}
```

Each member of `C` with a distinct name will have a corresponding type (like
`__TypeOf_C_F`) and value of that type (like `__C_F`). There are two more types
for each member function (either static class function or method), though, that
[adapt](/docs/design/generics/terminology.md#adapting-a-type) `C` and represent
the type of binding that member with either a `C` value or variable.

```carbon
class __TypeOf_C_Value {}
let __C_Value:! __TypeOf_C_Value = {};
class __ValueBind_C_Value {
  adapt C;
}
class __RefBind_C_Value {
  adapt C;
}

// and similarly for Mutate and Static
```

These are the types that result from
[instance binding](/docs/design/expressions/member_access.md#instance-binding)
an instance of `C` with these member names. For example,

```carbon
let v: C = {.x = 3};
Assert(v.Value() == 8);
var r: C = {.x = 4};
Assert(r.Value() == 9);
Assert(r.Mutate() == 6);
```

is interpreted as:

```carbon
let v: C = {.x = 3};
Assert((v as __ValueBind_C_Value).(『value call()』.Op)() == 8);
var r: C = {.x = 4};
Assert((r as __RefBind_C_Value).(『mutable call()』.Op)() == 9);
Assert((r as __RefBind_C_Mutate).(『mutable call()』.Op)() == 9);
```

How does this arise?

1. First the simple member access is resolved using the type of the receiver: \
   `v.Value` -> `v.(C.Value)`, `r.Value` -> `r.(C.Value)`, `r.Mutate` -> `r.(C.Mutate)`.
   \
   Note that `C.Value` is `__C_Value` with type `__TypeOf_C_Value`.
2. If the left of the `.` is a value expression, the value binding operator is
   applied. Otherwise if it is a reference expression, the reference binding
   operator is applied.
3. The result of the binding has a type that implements one or both of the call
   interfaces.

The binding operators are defined using two dedicated interfaces:

```carbon
// For value `x` with type `T` and `y` of type `U`,
// `x.(y)` is `y.(U as ValueBind(T)).『Bind』(x)`
interface ValueBind(T:! type) {
  let Result:! type;
  fn 『Bind』[self: Self](x: T) -> Result;
}

// For reference expression `var x: T` and `y` of type `U`,
// `x.(y)` is `*y.(U as RefBind(T)).『Bind』(&x)`
interface RefBind(T:! type) {
  let Result:! type;
  fn 『Bind』[self: Self](p: T*) -> Result*;
}
```

The name `Bind` here is provisional -- it probably should actually be `Op` to be
consistent with other operator interfaces, but I'm using a different name in
this document for now to avoid confusion with the `Op` method of the call
interfaces.

**Question:** Should the `self` and `T` parameters to bind interfaces be
swapped?

These binding operations are how we get from `__C_Value` with type
`__TypeOf_C_Value` to `v as __ValueBind_C_Value` or `r as __RefBind_C_Value`:

```carbon
impl __TypeOf_C_Value as ValueBind(C)
    where .Result = __ValueBind_C_Value {
  fn 『Bind』[self: Self](x: C) -> __ValueBind_C_Value {
    return x as __ValueBind_C_Value;
  }
}

impl __TypeOf_C_Value as RefBind(C)
    where .Result = __RefBind_C_Value {
  fn 『Bind』[self: Self](p: C*) -> __RefBind_C_Value* {
    return p as __RefBind_C_Value*;
  }
}
```

The last ingredient is the implementation of the call interfaces for these bound
types.

```carbon
// Since `C.Value` takes `self: Self` it can be used with both
// value and reference expressions:
impl __ValueBind_C_Value as 『value call()』 with .Result = i32;
impl __RefBind_C_Value as 『value call()』 with .Result = i32;
impl __RefBind_C_Value as 『mutable call()』 with .Result = i32;

// `C.Static` works the same as `C.Value`, except it also
// implements the call interfaces on `__TypeOf_C_Static`.
// This allows `v.Static()` and `r.Static()` to work, in
// addition to `C.Static()`.
impl __ValueBind_C_Static as 『value call()』 with .Result = i32;
impl __RefBind_C_Static as 『value call()』 with .Result = i32;
impl __RefBind_C_Static as 『mutable call()』 with .Result = i32;
impl __TypeOf_C_Static as 『value call()』 where .Result = i32;
impl __TypeOf_C_Static as 『mutable call()』 where .Result = i32;

// Since `C.Mutate` takes `addr self: Self*`, it requires a
// reference expression.
// <no implementation of 『value call()』>
impl __RefBind_C_Mutate as 『mutable call()』 with .Result = i32;
```

**Note**: We could reduce the number of implementations required by making
`__RefBind_*` an
[extending adapter](/docs/design/generics/details.md#extending-adapter) of the
corresponding `__ValueBind_*` class.

### Inheritance and other implicit conversions

Now consider methods of a base class:

```carbon
base class B {
  fn F[self: Self]();
  virtual fn V[self: Self]();
}

class D {
  extend base: B;
  impl fn V[self: Self]();
}

var d: D = {}
d.(B.F)();
d.(B.V)();
```

To allow this to work, we need the implementation of the bind interfaces to
allow implicit conversions:

```carbon
impl [T:! ImplicitAs(B)] __TypeOf_B_F as ValueBind(T)
    where .Result = __ValueBind_B_F {
  fn 『Bind』[self: Self](x: T) -> __ValueBind_B_F {
    return (x as B) as __ValueBind_B_F;
  }
}

impl [T:! type where .Self* impls ImplicitAs(B*)]
    __TypeOf_B_F as RefBind(T)
    where .Result = __RefBind_B_F {
  fn 『Bind』[self: Self](p: T*) -> __RefBind_B_F* {
    return (p as B*) as __RefBind_B_F*;
  }
}
```

This matches the expected semantics method calls, even for methods of final
classes.

Note that the implementation of the bind interfaces is where the `Self` type of
a method is used. If that type is different from the class it is being defined
in, as considered in
[#1345](https://github.com/carbon-language/carbon-lang/issues/1345), that will
be reflected in the bind implementations.

```carbon
class C {
  // Note: not `self: Self` or `self: C`!
  fn G[self: Different]();
}

let c: C = {};
// `c.G()` is only allowed if there is an implicit
// conversion from `C` to `Different`.

let d: Different = {};
// Allowed:
d.(C.G)();
```

results in an implementation using `Different` instead of `C`:

```carbon
// `C.G` will only bind to values that can implicitly convert
// to type `Different`.
impl [T:! ImplicitAs(Different)] __TypeOf_C_G as ValueBind(T)
    where .Result = __ValueBind_C_G;
```

### Data fields

The same `ValueBind` and `RefBind` operations allow us to define access to the
data fields in an object, without any additional changes.

For example, given a class with a data member `m` with type `i32`:

```carbon
class C {
  var m: i32;
}
```

we want the usual operations to work, with `x.m` equivalent to `x.(C.m)`:

```carbon
let v: C = {.m = 4};
var x: C = {.m = 3};
x.m += 5;
Assert(x.(C.m) == v.m + v.(C.m));
```

To accomplish this we will, as before, associate an empty (stateless or
zero-sized) type with the `m` member of `C`, that just exists to support the
binding operation. However, this time the result type of binding is simply
`i32`, the type of the variable, instead of a new, dedicated type.

```carbon
class __TypeOf_C_m {}
let __C_m:! __TypeOf_C_m = {};

impl __TypeOf_C_m as ValueBind(C) where .Result = i32 {
  fn 『Bind』[self: Self](x: C) -> i32 {
    // Effectively performs `x.m`, but without triggering binding again.
    return value_compiler_intrinsic(v, __OffsetOf_C_m, i32)
  }
}

impl __TypeOf_C_Value as RefBind(C) where .Result = i32 {
  fn 『Bind』[self: Self](p: C*) -> i32* {
    // Effectively performs `&p->m`, but without triggering binding again,
    // by doing something like `((p as byte*) + __OffsetOf_C_m) as i32*`
    return offset_compiler_intrinsic(p, __OffsetOf_C_m, i32);
  }
}
```

These definitions give us the desired semantics:

```carbon
// For value `v` with type `T` and `y` of type `U`,
// `v.(y)` is `y.(U as ValueBind(T)).『Bind』(v)`
v.m == v.(C.m)
    == v.(__C_m)
    == __C_m.(__TypeOf_C_m as ValueBind(C)).『Bind』(v)
    == value_compiler_intrinsic(v, __OffsetOf_C_m, i32)


// For reference expression `var x: T` and `y` of type `U`,
// `x.(y)` is `*y.(U as RefBind(T)).『Bind』(&x)`
x.m == x.(C.m)
    == x.(__C_m)
    == *__C_m.(__TypeOf_C_m as RefBind(C)).『Bind』(&x)
    == *offset_compiler_intrinsic(&x, __OffsetOf_C_m, i32)
// Note that this requires `x` to be a reference expression,
// so `&x` is valid, and produces a reference expression,
// since it is the result of dereferencing a pointer.
```

### Generic type of a class member

Given the above, we can now write a constraint on a symbolic parameter to match
the names of an unbound class member. There are a few different cases:

**Mutating methods**

```carbon
// `m` can be any method object that implements 『mutable call()』 once bound.
fn CallMutatingMethod
    [T:! type, M:! RefBind(T) where .Result impls 『mutable call()』]
    (x: T*, m: M) -> auto {
  return x->(m)();
}

class D {
  // Any of these should work:
  fn K();
  fn K[self: Self]();
  fn K[addr self: Self*]();
}
var d: D;
CallMutatingMethod(&d, D.K);
```

FIXME: The above works even if `D.K` takes `self: Self` since even value methods
will implement 『mutable call()』.

This implementation of `CallMutatingMethod` will work with inheritance and
virtual methods, using
[the support for implicit conversions of self](#inheritance-and-other-implicit-conversions).

```carbon
base class X {
  virtual fn V[self: Self]() -> i32 { return 1; }
  fn B[addr self: Self*]();
}
class Y {
  extend base: X;
  impl fn V[self: Self]() -> i32 { return 2; }
}
class Z {
  extend base: X;
  impl fn V[self: Self]() -> i32 { return 3; }
}

var (x: X, y: Y, z: Z);

// Respects inheritance
CallMutatingMethod(&x, X.B);
CallMutatingMethod(&y, X.B);
CallMutatingMethod(&z, X.B);

// Respects method overriding
Assert(CallMutatingMethod(&x, X.V) == 1);
Assert(CallMutatingMethod(&y, X.V) == 2);
Assert(CallMutatingMethod(&z, X.V) == 3);
```

**Value methods**

Switching to `ValueBind` and `『value call』` means the receiver object can be
passed by value instead of by pointer:

```carbon
// `m` can be any method object that implements 『value call()』 once bound.
fn CallValueMethod
    [T:! type, M:! ValueBind(T) where .Result impls 『value call()』]
    (x: T, m: M) -> auto {
  return x.(m)();
}
```

This will work with any value method or static class function, but not with
`addr self` methods.

**Fields**

Fields can be accessed, given the type of the field

```carbon
fn SetField
    [T:! type, F:! RefBind(T) where .Result = i32]
    (x: T*, f: F, y: i32) {
  x->(f) = y;
}

fn GetField
    [T:! type, F:! ValueBind(T) where .Result = i32]
    (x: T, f: F) -> i32 {
  return x.(f);
}


class C {
  var m: i32;
  var n: i32;
}
var c: C = {.m = 5, .n = 6};
Assert(GetField(c, C.m) == 5);
Assert(GetField(c, C.n) == 6);
SetField(&c, C.m, 42);
SetField(&c, C.n, 12);
Assert(GetField(c, C.m) == 42);
Assert(GetField(c, C.n) == 12);
```

### C++ pointer to member

In [the generic type of member section](#generic-type-of-a-class-member), the
names of members, such as `D.K`, `X.B`, `X.V`, and `C.n`, refer to zero-sized /
stateless objects where all the offset information is encoded in the type.
However, the definitions of `CallMutatingMethod`, `CallValueMethod`, `SetField`,
and `GetField` do not depend on that fact and will be usable with objects, such
as C++ pointers-to-members, that include the offset information in the runtime
object state. So we can define binding implementations for them so that they may
be used with Carbon's `.(`**`)` and `->(`**`)` operators.

For example, this is how I would expect C++ code to call the above Carbon
functions:

```cpp
struct C {
  void F() { ++m; }
  int m;
};

int main() {
  // pointer to data member `m` of class C
  int C::* p = &C::m;
  C c = {2};
  assert(c.*p == 2);
  assert(Carbon::GetField(c, p) == 2);
  Carbon::SetField(&c, p, 4);
  assert(c.m == 4);
  // pointer to method `F` of class C
  void (C::* q)() = &C::F;
  Carbon::CallMutatingMethod(&c, q);
  assert(Carbon::GetField(c, &C::m) == 5);
}
```

### Member forwarding

Consider a class that we want to act like it has the members of another type.
For example, a type `Box(T)` that has a pointer to a `T` object allocated on the
heap:

```carbon
class Box(T:! type) {
  var ptr: T*;
  // ???
}
```

`Box(T)` should act like it has all the members of `T`:

```carbon
class String {
  fn Search[self: Self](c: u8) -> i32;
}
var b: Box(String) = ...;
var position: i32 = b.Search(32);
```

There are two ingredients to make this work:

-   We need some way to make `b.Search` be equivalent to `b.(String.Search)` not
    `b.(Box(String).Search)`.
-   We need the act of binding a method of `String` to a `Box(String)` value
    work by dereferencing the pointer `b.ptr`.

For the first ingredient, we need a way to customize
[simple member access](/docs/design/expressions/member_access.md) for the class
`Box(T)`. Normally simple member access on a value like `b`
[looks in the type of b](/docs/design/expressions/member_access.md#values).
However, types can designate other entities to also look up in using the
`extend` keyword (see [proposal #2760](/proposals/p2760.md#proposal)):

-   `extend impl as I` adds lookup into the implementation of an interface `I`.
-   `extend base: B` adds lookup into the base class `B`.
-   `extend adapt C` adds lookup into the adapted class `C`.
-   [mixins are also planning](/proposals/p2760.md#future-work-mixins) on using
    an `extend` syntax

The natural choice is to add another way of using `extend` with consistent
lookup rules as the other uses of `extend`, with conflicts handled as determined
by leads issues
[#2355](https://github.com/carbon-language/carbon-lang/issues/2355) and
[#2745](https://github.com/carbon-language/carbon-lang/issues/2745). I propose
`extend api T`:

```carbon
class Box(T:! type) {
  var : T*;
  extend api T;
}
```

This means that lookup into `Box(T)` also looks in the type `T` for members. In
this way, `b.Search` will find `b.(String.Search)`.

**Note:** This mechanism has some potential uses beyond member forwarding. For
example, a class could extend the api of a class it implicitly converts to, see
[inheritance and other implicit conversions](#inheritance-and-other-implicit-conversions).
Or a class could have members specifically intended for use by another class, as
[extension methods](https://github.com/carbon-language/carbon-lang/issues/1345)
-- effectively acting as mixin except it can't add member variables.

For the second ingredient, the binding interfaces already provide everything
needed, we just need to make a parameterized implementation of them:

```carbon
impl forall [T:! type, U:! ValueBind(T)]
    U as ValueBind(Box(T)) where .Result = U.Result {
  fn 『Bind』[self: Self](x: Box(T)) -> Result {
    // Uses `ValueBind(T).『Bind』` based on type of `U`.
    return self.『Bind』(*x.ptr);

    // NOT `return x.ptr->(self)` since that attempts
    // to do reference binding not value binding.
  }
}

impl forall [T:! type, U:! RefBind(T)]
    U as RefBind(Box(T)) where .Result = U.Result {
  fn 『Bind』[self: Self](p: Box(T)*) -> Result* {
    return self.『Bind』(p->ptr);
    // Or equivalently:
    // return p->ptr->(self);
  }
}
```

A few observations:

-   These declarations use `Box` to satisfy the orphan rule, and so this
    approach only works with `Box(T)` values, not types that can implicitly
    convert to `Box(T)`.
-   The implementation of the `『Bind』` method is where we follow the pointer
    member `ptr` of `Box(T)` to get a `T` value that is compatible with the
    member being bound. This resolves the type mismatch that is introduced by
    allowing
-   We have to be a little careful in the implementation of `ValueBind(Box(T))`
    to still use value binding even when we get a reference expression from
    dereferencing the pointer `ptr`.

With these two ingredients, `b.Search(32)` is equivalent to
`b.(String.Search)(32)`, which is then equivalent to
`b.ptr->(String.Search)(32)` or `b.ptr->Search(32)` (since `b.ptr` has type
`String*`).

### Future: properties

If there was a way to implement the binding operator to only produce values,
even when the expression to the left of the `.` was a reference expression, then
that could be used to implement read-only properties. This would support
something like:

```carbon
let Pi: f64 = 3.1415926535897932384626433832795;

class Circle {
  var radius: f64;
  read_property area -> f64 {
    return Pi * self.radius * self.radius;
  }
}

let c: Circle = {.radius = 2};
Assert(NearlyEqual(c.area, 4 * Pi));
```

In this example, the binding of `c` of type `Circle` to `Circle.area` would
perform the computation and return the result as an `f64`.

If there was some way to customize the result of binding, this could be extended
to support other kinds of properties, such as mutable properties that have both
`get` and `set` methods. The main obstacle to any support for properties with
binding is how the customization would be done. The most natural way to support
this customization would be to have multiple interfaces. The compiler would try
them in a specified order and use the one it found first. This has the downside
of the possibility of different behavior in a checked generic context where only
some of the implementations are visible.

## Rationale

TODO: How does this proposal effectively advance Carbon's goals? Rather than
re-stating the full motivation, this should connect that motivation back to
Carbon's stated goals and principles. This may evolve during review. Use links
to appropriate sections of [`/docs/project/goals.md`](/docs/project/goals.md),
and/or to documents in [`/docs/project/principles`](/docs/project/principles).
For example:

-   [Community and culture](/docs/project/goals.md#community-and-culture)
-   [Language tools and ecosystem](/docs/project/goals.md#language-tools-and-ecosystem)
-   [Performance-critical software](/docs/project/goals.md#performance-critical-software)
-   [Software and language evolution](/docs/project/goals.md#software-and-language-evolution)
-   [Code that is easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write)
-   [Practical safety and testing mechanisms](/docs/project/goals.md#practical-safety-and-testing-mechanisms)
-   [Fast and scalable development](/docs/project/goals.md#fast-and-scalable-development)
-   [Modern OS platforms, hardware architectures, and environments](/docs/project/goals.md#modern-os-platforms-hardware-architectures-and-environments)
-   [Interoperability with and migration from existing C++ code](/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code)

## Alternatives considered

TODO: What alternative solutions have you considered?
