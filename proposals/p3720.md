# Binding operators

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/3720)

<!-- toc -->

## Table of contents

-   [Abstract](#abstract)
-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Details](#details)
    -   [Inheritance and other implicit conversions](#inheritance-and-other-implicit-conversions)
    -   [Data fields](#data-fields)
    -   [Generic type of a class member](#generic-type-of-a-class-member)
    -   [C++ pointer to member](#c-pointer-to-member)
    -   [Member forwarding](#member-forwarding)
    -   [Future: properties](#future-properties)
-   [Rationale](#rationale)
-   [Alternatives considered](#alternatives-considered)
    -   [Swap the bind interface parameters](#swap-the-bind-interface-parameters)

<!-- tocstop -->

## Abstract

Define the binding operation used to compute the result of `x.y`, `p->y`,
`x.(C.y)`, and `p->(C.y)` as calling a method from user-implementable
interfaces. Also allow classes to `extend api` of other classes, for forwarding
use cases.

## Problem

What happens when binding is performed between an object instance and a member
of its type? We'd like to define the semantics in a way that is simple,
orthogonal, supports the use cases from C++, allows users to express their
intent in code in a natural and predictable way that is consistent with other
Carbon constructs, and is consistent with Carbon's goals.

Consider a class with a method and a field:

```carbon
class C {
  fn M[self: Self]();
  var f: i32;
}
var x: C = {.f = 2};
```

The expressions `C.M` and `C.f` correspond roughly to
[C++ pointers to members](https://en.cppreference.com/w/cpp/language/pointer#Pointers_to_members).
They may be used to access the members of `x` using Carbon's
[compound member syntax](/docs/design/expressions/member_access.md), as in
`x.(C.M)` or `x.(C.f)`. What is their type? Can they be passed to a function
separately from the instance of `C` to bind with it?

## Background

FIXME: Is there any background that readers should consider to fully understand
this problem and your approach to solving it?

-   [Qualified names and member access](/docs/design/expressions/member_access.md)
-   [Proposal #989: Member access expressions](https://github.com/carbon-language/carbon-lang/pull/989)
-   [Proposal #2360: Types are values of type `type`](https://github.com/carbon-language/carbon-lang/pull/2360)
-   [Proposal #2875: Functions, function types, and function calls](https://github.com/carbon-language/carbon-lang/pull/2875)

The currently accepted proposals for functions don't support all of the
different function signatures for the `Call` interface. For example, it does not
support `addr self` or explicit compile-time parameters. That is out of scope of
this proposal, and will be addressed separately, and means that `addr self`
methods won't be considered here. The difference between functions and methods,
however, is in scope.

## Proposal

FIXME: Briefly and at a high level, how do you propose to solve the problem? Why
will that in fact solve it?

```carbon
// For value `x` with type `T` and `y` of type `U`,
// `x.(y)` is `y.((U as ValueBind(T)).Op)(x)`
interface ValueBind(T:! type) {
  let Result:! type;
  fn Op[self: Self](x: T) -> Result;
}

// For reference expression `var x: T` and `y` of type `U`,
// `x.(y)` is `*y.((U as RefBind(T)).Op)(&x)`
interface RefBind(T:! type) {
  let Result:! type;
  fn Op[self: Self](p: T*) -> Result*;
}
```

`extend api T`:

```carbon
class Extended {
  fn F[self: Self]();
  fn G[self: Self]();
}

class Extending {
  fn G[self: Self]();
  extend api Extended;
}

var e: Extended
```

This means that lookup into `Extending` also looks in the type `Extended` for
members. In this way, `e.F` will find `e.(Extended.F)`. `extend api T` is
equivalent to defining an `alias` for every member of `T` that doesn't have a
conflicting name. This means `Extending` is equivalent to:

```carbon
class Extending {
  fn G[self: Self]();
  alias F = Extended.F;
}
```

## Details

FIXME: Fully explain the details of the proposed solution.

To use instance members of a class, we need to go through the additional step of
_binding_. Consider a class `C`:

```carbon
class C {
  fn F[self: Self]() -> i32 { return self.x + 5; }
  fn Static() -> i32 { return 2; }
  var x: i32;
}
```

Each member of `C` with a distinct name will have a corresponding type (like
`__TypeOf_C_F`) and value of that type (like `__C_F`). There are two more types
for each member function (either static class function or method), though, that
[adapt](/docs/design/generics/terminology.md#adapting-a-type) `C` and represent
the type of binding that member with either a `C` value or variable.

```carbon
class __TypeOf_C_F {}
let __C_F:! __TypeOf_C_F = {};
class __ValueBind_C_F {
  adapt C;
}
class __RefBind_C_F {
  adapt C;
}

// and similarly for Static
```

These are the types that result from
[instance binding](/docs/design/expressions/member_access.md#instance-binding)
an instance of `C` with these member names. For example,

```carbon
let v: C = {.x = 3};
Assert(v.F() == 8);
var r: C = {.x = 4};
Assert(r.F() == 9);
```

is interpreted as:

```carbon
let v: C = {.x = 3};
Assert((v as __ValueBind_C_F).(Call(()).Op)() == 8);
var r: C = {.x = 4};
Assert((r as __RefBind_C_F).(Call(()).Op)() == 9);
```

How does this arise?

1. First the simple member access is resolved using the type of the receiver: \
   `v.F` -> `v.(C.F)`, `r.F` -> `r.(C.F)`. \
   Note that `C.F` is `__C_F` with type `__TypeOf_C_F`.
2. If the left of the `.` is a value expression, the value binding operator is
   applied. Otherwise if it is a reference expression, the reference binding
   operator is applied.
3. The result of the binding has a type that implements one or both of the call
   interfaces.

The binding operators are defined using two dedicated interfaces:

```carbon
// For value `x` with type `T` and `y` of type `U`,
// `x.(y)` is `y.((U as ValueBind(T)).Op)(x)`
interface ValueBind(T:! type) {
  let Result:! type;
  fn Op[self: Self](x: T) -> Result;
}

// For reference expression `var x: T` and `y` of type `U`,
// `x.(y)` is `*y.((U as RefBind(T)).Op)(&x)`
interface RefBind(T:! type) {
  let Result:! type;
  fn Op[self: Self](p: T*) -> Result*;
}
```

The name `Bind` here is provisional -- it probably should actually be `Op` to be
consistent with other operator interfaces, but I'm using a different name in
this document for now to avoid confusion with the `Op` method of the call
interfaces.

These binding operations are how we get from `__C_F` with type `__TypeOf_C_F` to
`v as __ValueBind_C_F` or `r as __RefBind_C_F`:

```carbon
impl __TypeOf_C_F as ValueBind(C)
    where .Result = __ValueBind_C_F {
  fn Op[self: Self](x: C) -> __ValueBind_C_F {
    return x as __ValueBind_C_F;
  }
}

impl __TypeOf_C_F as RefBind(C)
    where .Result = __RefBind_C_F {
  fn Op[self: Self](p: C*) -> __RefBind_C_F* {
    return p as __RefBind_C_F*;
  }
}
```

The last ingredient is the implementation of the call interfaces for these bound
types.

```carbon
// Since `C.F` takes `self: Self` it can be used with both
// value and reference expressions:
impl __ValueBind_C_F as Call(()) with .Result = i32;
impl __RefBind_C_F as Call(()) with .Result = i32;

// `C.Static` works the same as `C.F`, except it also
// implements the call interfaces on `__TypeOf_C_Static`.
// This allows `v.Static()` and `r.Static()` to work, in
// addition to `C.Static()`.
impl __ValueBind_C_Static as Call(()) with .Result = i32;
impl __RefBind_C_Static as Call(()) with .Result = i32;
impl __TypeOf_C_Static as Call(()) where .Result = i32;
```

**Note**: We could reduce the number of implementations required by making
`__RefBind_*` an
[extending adapter](/docs/design/generics/details.md#extending-adapter) of the
corresponding `__ValueBind_*` class.

### Inheritance and other implicit conversions

Now consider methods of a base class:

```carbon
base class B {
  fn F[self: Self]();
  virtual fn V[self: Self]();
}

class D {
  extend base: B;
  impl fn V[self: Self]();
}

var d: D = {}
d.(B.F)();
d.(B.V)();
```

To allow this to work, we need the implementation of the bind interfaces to
allow implicit conversions:

```carbon
impl [T:! ImplicitAs(B)] __TypeOf_B_F as ValueBind(T)
    where .Result = __ValueBind_B_F {
  fn Op[self: Self](x: T) -> __ValueBind_B_F {
    return (x as B) as __ValueBind_B_F;
  }
}

impl [T:! type where .Self* impls ImplicitAs(B*)]
    __TypeOf_B_F as RefBind(T)
    where .Result = __RefBind_B_F {
  fn Op[self: Self](p: T*) -> __RefBind_B_F* {
    return (p as B*) as __RefBind_B_F*;
  }
}
```

This matches the expected semantics method calls, even for methods of final
classes.

Note that the implementation of the bind interfaces is where the `Self` type of
a method is used. If that type is different from the class it is being defined
in, as considered in
[#1345](https://github.com/carbon-language/carbon-lang/issues/1345), that will
be reflected in the bind implementations.

```carbon
class C {
  // Note: not `self: Self` or `self: C`!
  fn G[self: Different]();
}

let c: C = {};
// `c.G()` is only allowed if there is an implicit
// conversion from `C` to `Different`.

let d: Different = {};
// Allowed:
d.(C.G)();
```

results in an implementation using `Different` instead of `C`:

```carbon
// `C.G` will only bind to values that can implicitly convert
// to type `Different`.
impl [T:! ImplicitAs(Different)] __TypeOf_C_G as ValueBind(T)
    where .Result = __ValueBind_C_G;
```

### Data fields

The same `ValueBind` and `RefBind` operations allow us to define access to the
data fields in an object, without any additional changes.

For example, given a class with a data member `m` with type `i32`:

```carbon
class C {
  var m: i32;
}
```

we want the usual operations to work, with `x.m` equivalent to `x.(C.m)`:

```carbon
let v: C = {.m = 4};
var x: C = {.m = 3};
x.m += 5;
Assert(x.(C.m) == v.m + v.(C.m));
```

To accomplish this we will, as before, associate an empty (stateless or
zero-sized) type with the `m` member of `C`, that just exists to support the
binding operation. However, this time the result type of binding is simply
`i32`, the type of the variable, instead of a new, dedicated type.

```carbon
class __TypeOf_C_m {}
let __C_m:! __TypeOf_C_m = {};

impl __TypeOf_C_m as ValueBind(C) where .Result = i32 {
  fn Op[self: Self](x: C) -> i32 {
    // Effectively performs `x.m`, but without triggering binding again.
    return value_compiler_intrinsic(v, __OffsetOf_C_m, i32)
  }
}

impl __TypeOf_C_m as RefBind(C) where .Result = i32 {
  fn Op[self: Self](p: C*) -> i32* {
    // Effectively performs `&p->m`, but without triggering binding again,
    // by doing something like `((p as byte*) + __OffsetOf_C_m) as i32*`
    return offset_compiler_intrinsic(p, __OffsetOf_C_m, i32);
  }
}
```

These definitions give us the desired semantics:

```carbon
// For value `v` with type `T` and `y` of type `U`,
// `v.(y)` is `y.(U as ValueBind(T)).Op(v)`
v.m == v.(C.m)
    == v.(__C_m)
    == v.(__C_m as (__TypeOf_C_m as ValueBind(C)))
    == __C_m.(__TypeOf_C_m as ValueBind(C)).Op(v)
    == value_compiler_intrinsic(v, __OffsetOf_C_m, i32)

// For reference expression `var x: T` and `y` of type `U`,
// `x.(y)` is `*y.(U as RefBind(T)).Op(&x)`
x.m == x.(C.m)
    == x.(__C_m)
    == *__C_m.(__TypeOf_C_m as RefBind(C)).Op(&x)
    == *offset_compiler_intrinsic(&x, __OffsetOf_C_m, i32)
// Note that this requires `x` to be a reference expression,
// so `&x` is valid, and produces a reference expression,
// since it is the result of dereferencing a pointer.
```

### Generic type of a class member

Given the above, we can now write a constraint on a symbolic parameter to match
the names of an unbound class member. There are a couple of different cases:

**Methods**

Restricting to value methods, since mutating (`addr self`) methods are out of
scope for this proposal, the receiver object may be passed by value. To be able
to call the method, we must include a restriction that the result of `ValueBind`
implements `Call(())`:

```carbon
// `m` can be any method object that implements `Call(())` once bound.
fn CallValueMethod
    [T:! type, M:! ValueBind(T) where .Result impls Call(())]
    (x: T, m: M) -> auto {
  return x.(m)();
}
```

This will work with any value method or static class function.

**FIXME: Left off here.**

This implementation of `CallMutatingMethod` will work with inheritance and
virtual methods, using
[the support for implicit conversions of self](#inheritance-and-other-implicit-conversions).

```carbon
base class X {
  virtual fn V[self: Self]() -> i32 { return 1; }
  fn B[addr self: Self*]();
}
class Y {
  extend base: X;
  impl fn V[self: Self]() -> i32 { return 2; }
}
class Z {
  extend base: X;
  impl fn V[self: Self]() -> i32 { return 3; }
}

var (x: X, y: Y, z: Z);

// Respects inheritance
CallMutatingMethod(&x, X.B);
CallMutatingMethod(&y, X.B);
CallMutatingMethod(&z, X.B);

// Respects method overriding
Assert(CallMutatingMethod(&x, X.V) == 1);
Assert(CallMutatingMethod(&y, X.V) == 2);
Assert(CallMutatingMethod(&z, X.V) == 3);
```

**Fields**

Fields can be accessed, given the type of the field

```carbon
fn SetField
    [T:! type, F:! RefBind(T) where .Result = i32]
    (x: T*, f: F, y: i32) {
  x->(f) = y;
}

fn GetField
    [T:! type, F:! ValueBind(T) where .Result = i32]
    (x: T, f: F) -> i32 {
  return x.(f);
}

class C {
  var m: i32;
  var n: i32;
}
var c: C = {.m = 5, .n = 6};
Assert(GetField(c, C.m) == 5);
Assert(GetField(c, C.n) == 6);
SetField(&c, C.m, 42);
SetField(&c, C.n, 12);
Assert(GetField(c, C.m) == 42);
Assert(GetField(c, C.n) == 12);
```

### C++ pointer to member

In [the generic type of member section](#generic-type-of-a-class-member), the
names of members, such as `D.K`, `X.B`, `X.V`, and `C.n`, refer to zero-sized /
stateless objects where all the offset information is encoded in the type.
However, the definitions of `CallMutatingMethod`, `CallValueMethod`, `SetField`,
and `GetField` do not depend on that fact and will be usable with objects, such
as C++ pointers-to-members, that include the offset information in the runtime
object state. So we can define binding implementations for them so that they may
be used with Carbon's `.(`**`)` and `->(`**`)` operators.

For example, this is how I would expect C++ code to call the above Carbon
functions:

```cpp
struct C {
  void F() { ++m; }
  int m;
};

int main() {
  // pointer to data member `m` of class C
  int C::* p = &C::m;
  C c = {2};
  assert(c.*p == 2);
  assert(Carbon::GetField(c, p) == 2);
  Carbon::SetField(&c, p, 4);
  assert(c.m == 4);
  // pointer to method `F` of class C
  void (C::* q)() = &C::F;
  Carbon::CallMutatingMethod(&c, q);
  assert(Carbon::GetField(c, &C::m) == 5);
}
```

### Member forwarding

Consider a class that we want to act like it has the members of another type.
For example, a type `Box(T)` that has a pointer to a `T` object allocated on the
heap:

```carbon
class Box(T:! type) {
  var ptr: T*;
  // ???
}
```

`Box(T)` should act like it has all the members of `T`:

```carbon
class String {
  fn Search[self: Self](c: u8) -> i32;
}
var b: Box(String) = ...;
var position: i32 = b.Search(32);
```

There are two ingredients to make this work:

-   We need some way to make `b.Search` be equivalent to `b.(String.Search)` not
    `b.(Box(String).Search)`.
-   We need the act of binding a method of `String` to a `Box(String)` value
    work by dereferencing the pointer `b.ptr`.

For the first ingredient, we need a way to customize
[simple member access](/docs/design/expressions/member_access.md) for the class
`Box(T)`. Normally simple member access on a value like `b`
[looks in the type of b](/docs/design/expressions/member_access.md#values).
However, types can designate other entities to also look up in using the
`extend` keyword (see [proposal #2760](/proposals/p2760.md#proposal)):

-   `extend impl as I` adds lookup into the implementation of an interface `I`.
-   `extend base: B` adds lookup into the base class `B`.
-   `extend adapt C` adds lookup into the adapted class `C`.
-   [mixins are also planning](/proposals/p2760.md#future-work-mixins) on using
    an `extend` syntax

The natural choice is to add another way of using `extend` with consistent
lookup rules as the other uses of `extend`, with conflicts handled as determined
by leads issues
[#2355](https://github.com/carbon-language/carbon-lang/issues/2355) and
[#2745](https://github.com/carbon-language/carbon-lang/issues/2745). I propose
`extend api T`:

```carbon
class Box(T:! type) {
  var : T*;
  extend api T;
}
```

This means that lookup into `Box(T)` also looks in the type `T` for members. In
this way, `b.Search` will find `b.(String.Search)`.

**Note:** This is an alternative to defining an `alias` for each member of the
extended type. This avoids having to repeat them, which is both lengthy and
could get out of sync as the class evolves. The `extend api` approach works even
if, as in this example, we don't know the names of the members of the type being
extended.

**Note:** This mechanism has some potential uses beyond member forwarding. For
example, a class could extend the api of a class it implicitly converts to, see
[inheritance and other implicit conversions](#inheritance-and-other-implicit-conversions).
Or a class could have members specifically intended for use by another class, as
[extension methods](https://github.com/carbon-language/carbon-lang/issues/1345)
-- effectively acting as mixin except it can't add member variables.

For the second ingredient, the binding interfaces already provide everything
needed, we just need to make a parameterized implementation of them:

```carbon
impl forall [T:! type, U:! ValueBind(T)]
    U as ValueBind(Box(T)) where .Result = U.Result {
  fn Op[self: Self](x: Box(T)) -> Result {
    // Uses `ValueBind(T).Op` based on type of `U`.
    return self.Op(*x.ptr);

    // NOT `return x.ptr->(self)` since that attempts
    // to do reference binding not value binding.
  }
}

impl forall [T:! type, U:! RefBind(T)]
    U as RefBind(Box(T)) where .Result = U.Result {
  fn Op[self: Self](p: Box(T)*) -> Result* {
    return self.Op(p->ptr);
    // Or equivalently:
    // return p->ptr->(self);
  }
}
```

A few observations:

-   These declarations use `Box` to satisfy the orphan rule, and so this
    approach only works with `Box(T)` values, not types that can implicitly
    convert to `Box(T)`.
-   The implementation of the `Op` method is where we follow the pointer member
    `ptr` of `Box(T)` to get a `T` value that is compatible with the member
    being bound. This resolves the type mismatch that is introduced by allowing
    name resolution to find another type's members.
-   We have to be a little careful in the implementation of `ValueBind(Box(T))`
    to still use value binding even when we get a reference expression from
    dereferencing the pointer `ptr`.

With these two ingredients, `b.Search(32)` is equivalent to
`b.(String.Search)(32)`, which is then equivalent to
`b.ptr->(String.Search)(32)` or `b.ptr->Search(32)` (since `b.ptr` has type
`String*`).

### Future: properties

If there was a way to implement the binding operator to only produce values,
even when the expression to the left of the `.` was a reference expression, then
that could be used to implement read-only properties. This would support
something like:

```carbon
let Pi: f64 = 3.1415926535897932384626433832795;

class Circle {
  var radius: f64;
  read_property area -> f64 {
    return Pi * self.radius * self.radius;
  }
}

let c: Circle = {.radius = 2};
Assert(NearlyEqual(c.area, 4 * Pi));
```

In this example, the binding of `c` of type `Circle` to `Circle.area` would
perform the computation and return the result as an `f64`.

If there was some way to customize the result of binding, this could be extended
to support other kinds of properties, such as mutable properties that have both
`get` and `set` methods. The main obstacle to any support for properties with
binding is how the customization would be done. The most natural way to support
this customization would be to have multiple interfaces. The compiler would try
them in a specified order and use the one it found first. This has the downside
of the possibility of different behavior in a checked generic context where only
some of the implementations are visible.

## Rationale

TODO: How does this proposal effectively advance Carbon's goals? Rather than
re-stating the full motivation, this should connect that motivation back to
Carbon's stated goals and principles. This may evolve during review. Use links
to appropriate sections of [`/docs/project/goals.md`](/docs/project/goals.md),
and/or to documents in [`/docs/project/principles`](/docs/project/principles).
For example:

-   [Community and culture](/docs/project/goals.md#community-and-culture)
-   [Language tools and ecosystem](/docs/project/goals.md#language-tools-and-ecosystem)
-   [Performance-critical software](/docs/project/goals.md#performance-critical-software)
-   [Software and language evolution](/docs/project/goals.md#software-and-language-evolution)
-   [Code that is easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write)
-   [Practical safety and testing mechanisms](/docs/project/goals.md#practical-safety-and-testing-mechanisms)
-   [Fast and scalable development](/docs/project/goals.md#fast-and-scalable-development)
-   [Modern OS platforms, hardware architectures, and environments](/docs/project/goals.md#modern-os-platforms-hardware-architectures-and-environments)
-   [Interoperability with and migration from existing C++ code](/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code)

## Alternatives considered

### Swap the bind interface parameters

We considered instead making the receiver object the `Self` type of the
interface, and using the member type as the parameter to the interface. This
would have the advantage of matching the order that they appear in the source,
consistent with other operators.

> **Alternative:**
>
> ```carbon
> // For value `x` with type `T` and `y` of type `U`,
> // `x.(y)` is `x.((T as ValueBind(U)).Op)(y)`
> interface ValueBind(U:! type) {
>   let Result:! type;
>   fn Op[self: Self](x: U) -> Result;
> }
>
> // For reference expression `var x: T` and `y` of type `U`,
> // `x.(y)` is `*x.((T as RefBind(U)).Op)(y)`
> interface RefBind(U:! type) {
>   let Result:! type;
>   fn Op[addr self: Self*](x: U) -> Result*;
> }
> ```

This had some disadvantages however:

-   The binding property is more associated with the member than the receiver.
-   Some patterns are more awkward in the alternative syntax.

As an example of this last point, consider a function that takes multiple (or
even a variadic list) methods to call on a receiver object. With the proposed
approach, each method type is constrained:

```carbon
// `m1`, `m2`, and `m3` are methods on class `T`.
fn Call3Methods[T:! type,
                M1:! ValueBind(T) where .Result impls Call(()),
                M2:! ValueBind(T) where .Result impls Call(()),
                M3:! ValueBind(T) where .Result impls Call(())]
    (x: T, m1: M1, m2: M2, m3: M3) -> auto;
```

With the alternative, the type of the receiver would be constrained, and the
deduced types would be written in a different order:

> **Alternative:**
>
> ```carbon
> // `m1`, `m2`, and `m3` are methods on class `T`.
> fn Call3MethodsAlternative1
>     [M1:! type, M2:! type, M3:! type,
>      T:! ValueBind(M1) & ValueBind(M2) & ValueBind(M3)
>          where .(ValueBind(M1).Result) impls Call(())
>            and .(ValueBind(M2).Result) impls Call(())
>            and .(ValueBind(M3).Result) impls Call(())]
>     (x: T, m1: M1, m2: M2, m3: M3) -> auto;
> ```

Or, the constraints can be moved to the method types at the cost of additional
length:

> **Alternative:**
>
> ```carbon
> // `m1`, `m2`, and `m3` are methods on class `T`.
> fn Call3MethodsAlternative2
>     [T:! type,
>      M1:! type where T impls (ValueBind(.Self) where .Result impls Call(())),
>      M2:! type where T impls (ValueBind(.Self) where .Result impls Call(())),
>      M3:! type where T impls (ValueBind(.Self) where .Result impls Call(()))]
>     (x: T, m1: M1, m2: M2, m3: M3) -> auto;
> ```
