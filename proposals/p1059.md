# Subscript syntax and semantics

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/1059)

<!-- toc -->

## Table of contents

-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Details](#details)
-   [Rationale based on Carbon's goals](#rationale-based-on-carbons-goals)
-   [Alternatives considered](#alternatives-considered)
    -   [Different subscripting syntaxes](#different-subscripting-syntaxes)
    -   [Multiple indices](#multiple-indices)
    -   [Read-only subscripting](#read-only-subscripting)
    -   [Rvalue-only subscripting](#rvalue-only-subscripting)
    -   [Map-like subscripting](#map-like-subscripting)

<!-- tocstop -->

## Problem

Carbon needs a convenient way of indexing into objects like arrays and slices.

## Background

For purposes of this proposal, a "slice" is an object that refers to some region
of an array, and provides access to it, such as a `std::string_view` or
`std::span` in C++. Slices have subtly different indexing API semantics than
arrays: indexing into an array can produce an lvalue only if the array itself is
an lvalue, but indexing into a slice can produce an lvalue regardless of the
slice's value category.

Interfaces are Carbon's
[only static open extension mechanism](/docs/project/principles/static_open_extension.md),
so user-defined indexing must be defined in terms of interfaces. In order to
support
[definition checking of generic functions](/docs/design/generics/goals.md#generics-will-be-checked-when-defined),
it must be possible to fully typecheck indexing operations using only the
information exposed by those interfaces. And in order to provide
[coherence](/docs/design/generics/goals.md#coherence), a given indexing
expression must execute the same code regardless of how much type information we
have about it, so long as we have enough type information to establish that the
expression is valid.

The primary problem this proposal needs to solve is how to support both
array-like and slice-like indexing semantics while satisfying those
requirements.

## Proposal

Carbon will support indexing using the conventional `a[i]` subscript syntax.
When `a` is an lvalue, the result of subscripting will always be an lvalue, but
when `a` is an rvalue, the result can be an lvalue or an rvalue, depending on
which interface the type implements:

-   If subscripting an rvalue produces an rvalue result, as with an array, the
    type should implement `Subscriptable`.
-   If subscripting an rvalue produces an lvalue result, as with a slice, the
    type should implement `SubscriptableAsRValue`.

`SubscriptableAsRValue` is a subtype of `Subscriptable`, and subscript
expressions are rewritten to method calls on `SubscriptableAsRValue` if the type
is known to implement that interface, or to method calls on `Subscriptable`
otherwise. `SubscriptableAsRValue` provides a final blanket `impl` of
`Subscriptable`, which ensures coherence.

## Details

A subscript expression has the form "_lhs_ `[` _index_ `]`". As in C++, this
syntax has the same precedence as `.`, `->`, and function calls, and associates
left-to-right with all of them.

Its semantics are defined in terms of the following interfaces:

```
interface Subscriptable(IndexType:! Type) {
  let ElementType:! Type;
  fn Subscript[me: Self](index: IndexType) -> ElementType;
  fn SubscriptAsLValue[addr me: Self*](index: IndexType) -> ElementType*;
}

interface SubscriptableAsRValue(IndexType:! Type) {
  extends Subscriptable(IndexType);
  fn SubscriptAsRvalue[me: Self](index: IndexType) -> ElementType*;
}
```

**Open question:** The spelling of these interface and method names may be
affected by the resolution of #1058.

A subscript expression where _lhs_ has type `T` and _index_ has type `I` is
rewritten based on the value category of _lhs_ and whether `T` implements
`SubscriptableAsRValue(I)`:

-   If `T` implements `SubscriptableAsRValue(I)`, the expression is rewritten to
    "`*((` _lhs_ `).(SubscriptableAsRValue(I).SubscriptAsRValue)(` _index_
    `))`".
-   Otherwise, if _lhs_ is an lvalue, the expression is rewritten to "`*((`
    _lhs_ `).(Subscriptable(I).SubscriptAsLValue)(` _index_ `))`".
-   Otherwise, the expression is rewritten to "`(` _lhs_
    `).(Subscriptable(I).Subscript)(` _index_ `)`".

On their own, these rules would oblige `SubscriptableAsRValue` types to define
three methods to support a single syntax. Worse, they would permit those types
to define those methods in inconsistent ways, which would violate coherence. To
avoid those problems, `SubscriptableAsRValue` provides a blanket `final impl`
for `Subscriptable`:

```
final external impl [IndexType:! Type, T:! SubscriptableAsRValue(IndexType)]
    T as Subscriptable(IndexType) {
  let ElementType:! Type = T.(SubscriptableAsRValue(IndexType)).ElementType;
  fn Subscript[me: Self](index: IndexType) -> ElementType {
    return *(me.SubscriptAsRValue(index));
  }
  fn SubscriptAsLValue[addr me: Self*](index: IndexType) -> ElementType* {
    return me->SubscriptAsRValue(index);
  }
}
```

Thus, a type that implements `SubscriptableAsRValue` need not, and cannot,
provide its own definitions of `Subscript` and `SubscriptAsLValue`.

## Rationale based on Carbon's goals

Indexing is a fundamental operation in procedural programming, and is especially
common in performance-critical code, so supporting it with a concise, familiar
syntax helps us make
[code easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write),
and support
[performance-critical software](/docs/project/goals.md#performance-critical-software).
Using the same syntax as C++, even for slice-like types, supports
[interoperability with and migration from existing C++ code](/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code).

## Alternatives considered

### Different subscripting syntaxes

The reason that slices have different semantics from arrays is that a slice
represents an indirection, like a pointer. Indexing behaves the same for slice
lvalues and rvalues for the same reason that dereferencing behaves the same for
pointer lvalues and rvalues. Thus, our attempts to make a single subscripting
syntax work for both arrays and slices are arguably analogous to trying to make
the same method-call syntax work for both pointers and objects. Or, to put it
another way, the difficulty with slices is that they behave like _references_.

From that point of view, it would be more consistent to have different
subscripting syntaxes for the two cases. The most naive version of that would be
to say that only array-like types support subscripting, and slice-like types
should instead support dereferencing, so indexing into a slice would look like
`(*s)[i]`. However, that would be syntactically onerous, and it's not clear how
to define the type of `*s` in a way that doesn't beg the question.

Instead, we could define a distinct syntax for slice subscripting, such as
`s*[i]`, and define separate interfaces for the two subscript syntax. The two
interfaces would be very similar to `Subscriptable` and `SubscriptableAsRValue`,
but neither would extend the other, and the rewrite from subscript syntax to
method calls would not depend on type information (although it would depend on
value category). However, any such syntax would be quite novel and unfamiliar,
and there seem to be few good choices for how to spell it. `s*[i]` is almost the
only syntax that seems both viable and somewhat mnemonic, but it would add
further complexity to the already-fraught parsing of `*` (for humans as well as
tools).

### Multiple indices

This proposal does not support multiple comma-separated indices (such as
`a[i, j]`), which is desirable for types like multidimensional arrays. We do
support syntax like `a[(i, j)]`, which is a single index whose type is a tuple,
but the extra parens are syntactically noisy. We could add those parens
implicitly, but that would effectively move the syntactic noise to the
implementation, even for the single-index case (for example
`impl Foo as Subscriptable((i64))`). It should be much cleaner to make the
interfaces and their methods variadic, once we have a design for variadics.

### Read-only subscripting

This proposal does not provide an obvious path for supporting types like C++'s
`std::string_view` or `std::span<const T>`, whose subscripting operations expose
read-only access to their contents. It is tempting to try to extend this
proposal to support those use cases, both because of their inherent importance
and because it already has to deal with read-only versus read-write access in
order to support array rvalues.

However, there's a fundamental difference between the true immutability of
something like an array rvalue, and the contextual lack of mutable _access_
provided by something like `string_view`. While value categories can express the
former, they are not well-suited to expressing the latter. To address these use
cases, Carbon will probably need something like C++'s `const` type system, but
that should be largely orthogonal to this proposal.

### Rvalue-only subscripting

This proposal does not support subscripting operations that can't produce
lvalues. In particular, this means it does not support using subscript syntax to
form slices, as in Python's `a[i:j]` or Swift's `a[i...j]`. To support this, we
would need a separate pair of interfaces that return by value:

```
interface RValueSubscriptable(IndexType:! Type) {
  let ElementType:! Type;
  fn SubscriptAsLValue[addr me: Self*](index: IndexType) -> ElementType;
}

interface RValueSubscriptableAsRValue(IndexType:! Type) {
  extends RValueSubscriptable(IndexType);
  let ElementType:! Type;
  fn SubscriptAsRValue[me: Self](index: IndexType) -> ElementType;
}

final external impl [IndexType:! Type,
                     T:! RValueSubscriptableAsRValue(IndexType)]
    T as Subscriptable(IndexType) {
  let ElementType:! Type =
      T.(RValueSubscriptableAsRValue(IndexType)).ElementType;
  fn SubscriptAsLValue[addr me: Self*](subscript: Subscript) -> ElementType {
    return me->SubscriptAsRValue(subscript);
  }
}
```

Note that we still need a pair of interfaces, and a blanket final `impl` to
enforce consistency, because arrays and slices have different semantics in this
context as well: taking a slice of an rvalue array is invalid, because taking a
slice is equivalent to (and presumably implemented in terms of) taking an
address. On the other hand, taking a slice of an rvalue slice is valid and
should be supported.

We would likewise need to extend the rewrite rules for subscript syntax to
detect and use implementations of these interfaces. This should not lead to a
combinatorial explosion of cases, though; if `T` implements both
`Subscriptable(I)` and `RValueSubscriptable(I)`, the program should be
ill-formed due to ambiguity.

However, it's not clear if this would provide enough benefit to justify the
added complexity.

### Map-like subscripting

This proposal does not support subscripting operations that insert new elements
into a collection, as in C++'s `std::map` and `std::unordered_map`, because it
requires subscriptable types to support subscripting of rvalues, which are
immutable. We could support this with an additional interface for types that are
subscriptable only as lvalues, and a corresponding extension to the rewrite
rules.

However, it's debatable whether such insertion behavior is desirable; it has not
been a clear-cut success in C++. Code like `x = m[i];` looks like it reads from
`m`, and the fact that it can write to `m` is surprising, and easy for even
experienced programmers to overlook. Even for wary readers, it doesn't convey
the author's intent, because it's not clear whether the author assumed `i` is
present, or is relying on the implicit insertion. Furthermore, the implicit
insertion means that `x = m[i];` won't compile when `m` is const. On the other
hand, while it's relatively unsurprising that `m[i] = x;` might insert, that
insertion is also potentially inefficient, since it must default-construct a new
value before assigning `x` to it.

We could fix most of these problems by giving special treatment to syntax of the
form `m[i] = x;`, and defining separate methods for it:

```
interface Subscriptable(IndexType:! Type) {
  let ElementType:! Type;
  fn Subscript[me: Self](index: IndexType) -> ElementType;
  fn SubscriptAsLValue[addr me: Self*](index: IndexType) -> ElementType*;
  fn SubscriptAssignAsLValue[addr me: Self*](index: IndexType,
                                           element: ElementType) {
    (*me->SubscriptAsLValue(index)) = element;
  }
}

interface SubscriptableAsRValue(IndexType:! Type) {
  extends Subscriptable(IndexType);
  let ElementType:! Type;
  fn SubscriptAsRValue[me: Self](index: IndexType) -> ElementType*;
  fn SubscriptAssignAsRValue[me: Self](index: IndexType, element: ElementType) {
    me->SubscriptAsRValue(subscript) = element;
  }
}

final external impl [IndexType:! Type, T:! SubscriptableAsRValue(IndexType)]
    T as Subscriptable(IndexType) {
  ...
  fn SubscriptAssignAsLValue[addr me: Self*](index: IndexType,
                                           element: ElementType) {
    me->SubscriptAssignAsRValue(subscript, element);
  }
}
```

With this approach, expressions of the form `m[i] = x` would be rewritten to
call the appropriate `SubscriptAssign` method, while all other subscript
expressions are rewritten as in the primary proposal. However, this does add
some complexity to both the interfaces and the rewrite rules (for example, we
presumably want `(m[i]) = x` to be treated the same as `m[i] = x`), so I'm
leaving this as a potential future extension.

Alternatively, we could rewrite subscript expressions to use different
interfaces depending on whether the usage expects an lvalue, in much the same
way that Rust rewrites subscript expressions depending on whether the usage
expects the result to be mutable. This would enable type authors to make
`m[i] = x;` potentially inserting while ensuring that `x = m[i];` is not.
However, it would also mean that `m[i].Method()` is potentially inserting if
`Method` takes `me` by pointer, and would have the same performance drawback as
in C++.
