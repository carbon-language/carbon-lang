# String literals

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/199)

<!-- toc -->

## Table of contents

-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Details](#details)
    -   [Non-raw string literals](#non-raw-string-literals)
        -   [Escape sequences](#escape-sequences)
    -   [Raw string literals](#raw-string-literals)
    -   [Encoding](#encoding)
-   [Alternatives considered](#alternatives-considered)
    -   [Block string literals](#block-string-literals)
        -   [Leading whitespace removal](#leading-whitespace-removal)
        -   [Terminating newline](#terminating-newline)
    -   [Escape sequences](#escape-sequences-1)
    -   [Raw string literals](#raw-string-literals-1)
        -   [Trailing whitespace](#trailing-whitespace)

<!-- tocstop -->

## Problem

This proposal specifies lexical rules for constant strings in Carbon.

## Background

We wish to provide a syntax for writing literals containing human-readable text.

Note that "human-readable text" here should be understood broadly: such text may
be subject to further processing, and may in some cases be intended to be
interpreted by a computer rather than by a human (such as a regular expression,
program source code, a C++ mangled name), but broadly represents a sequence of
characters rather than arbitrary binary data.

Such text is typically represented in an _encoding_, which is a bidirectional
mapping between a sequence of characters in text and a sequence of bounded
integer values known as _code units_, suitable for storage, transmission, and
processing. For example, the Russian word углерод (carbon) is encoded in the
UTF-8 encoding as D1<sub>16</sub>83<sub>16 </sub>D0<sub>16</sub>B3<sub>16
</sub>D0<sub>16</sub>BB<sub>16</sub> D0<sub>16</sub>B5<sub>16</sub>
D1<sub>16</sub>80<sub>16</sub> D0<sub>16</sub>BE<sub>16</sub>
D0<sub>16</sub>B4<sub>16</sub>.

Simple string literals are specified in most programming languages as text
delimited by double-quote characters, `"like this"`. Such string literals
usually are restricted to begin and end on the same source line. Three
additional features are commonly seen:

-   Escape sequences, which permit string literals to include characters that
    are difficult to type or that would be problematic in some way (such as
    whitespace characters, characters that are invisible, and characters that
    change how other characters are rendered), and also to include arbitrary
    code units. One common convention is to use `\` to introduce an escape
    sequence, where:

    -   `\n` represents a newline character,
    -   `\u1234` represents the Unicode character U+1234,
    -   `\xAB` represents the code unit AB<sub>16</sub>,
    -   `\"` represents a single `"` character and does not terminate the string
        literal,
    -   `\\` represents a single `\` character,

    and so on.

-   Raw string literals, in which escape sequences are not recognized. These are
    often used in situations where escape sequences are undesirable, but in
    which the escape character or regular string terminator is used frequently.
    Such literals are useful when embedding one machine-readable language in
    another, when those languages share some escaping conventions. Such
    functionality may also provide a way to customize the string delimiters.

    -   In Python, raw string literals have an `r` prefix: `r"li\ngo"` is a six
        character string whose third character is `\`.
    -   In C++, raw string literals have an `r` prefix, along with a custom
        delimiter (which may be empty): `r"DELIM(li\ngo)DELIM"` is a six
        character string (plus a nul terminator).

-   Multiline string literals provide a mechanism for a string to easily span
    more than one line of source text. In C++, raw string literals are used to
    represent multiline string literals. In Python, different delimiters (`"""`
    or `'''` instead of `"` or `'`) are used to represent multiline string
    literals.

## Proposal

-   Single-line string literals are delimited by `"`s: `"hello"`

-   Multi-line string literals are introduced by a `"""` followed by a newline
    and terminated by a line beginning with a `"""`. The indentation of the
    terminating line is removed from all preceding lines:

    ```
    var String: henry_vi = """
      The winds grow high; so do your stomachs, lords.
      How irksome is this music to my heart!
      When such strings jar, what hope of harmony?
      I pray, my lords, let me compound this strife.
          -- History of Henry VI, Part II, Act II, Scene 1, W. Shakespeare
      """;
    ```

    Only the final line of this string literal begins with whitespace. The first
    character is `T` and the last character is `e`.

-   The opening `"""` of a multi-line string literal can be followed by a _file
    type indicator_, to assist tooling in understanding the intent of the
    string. This indicator has no effect on the meaning of the program.

    ```
    var String: cpp_snippet = r"""c++
      #include <iostream>
      int main() { std::cout << "hello world" << std::endl; }

      """;
    ```

-   Escape sequences are introduced with a `\` character; most C and C++ escape
    sequences are supported, but not octal escapes (`\177`): `"hello\nworld"`

-   Raw string literals are supported, and introduced by prefixing the opening
    delimiter with `r` followed by zero or more `#`s, and suffixing the closing
    delimiter with a matching number of `#`s: `r"foo\s*bar"`

## Details

### Non-raw string literals

A _simple string literal_ is formed of a sequence of

-   characters other than backslashes, double quotation marks, and vertical
    whitespace
-   [escape sequences](#escape-sequences)

enclosed in double quotation marks (`"`). Each escape sequence is replaced with
the corresponding character sequence or code unit sequence.

```carbon
var String: lucius = "The strings, my lord, are false.";
```

A _block string literal_ starts with three double quotation marks, followed by
an optional file type indicator, followed by a newline, and ends at the next
instance of three double quotation marks. The closing `"""` shall be the first
non-whitespace characters on that line. The lines between the opening line and
the closing line (exclusive) are _content lines_. The content lines shall not
contain `\` characters that do not form part of an escape sequence. All trailing
whitespace is removed from content lines.

The _indentation_ of a block string literal is the sequence of horizontal
whitespace preceding the closing `"""`. Each non-empty content line shall begin
with the indentation of the string literal. The content of the literal is formed
by removing the indentation of the closing line from each (non-empty) content
line, replacing each escape sequence with the corresponding character sequence
or code unit sequence, and concatenating the results with a line feed character
(U+000A) added between each pair of lines.

```carbon
var String: w = """
  This is a string literal. Its first character is 'T' and its last character
  is '.'. It contains one embedded newline, between 'character' and 'is'.
  """;

// This string literal is invalid because the """ after 'closing' terminates //
the literal, but is not at the start of the line.
var String: invalid = """
  error: closing """ is not on its own line.
  """;
```

A _file type indicator_ is any sequence of non-whitespace characters other than
`"` or `#`. The file type indicator has no semantic meaning to the Carbon
compiler, but some file type indicators are understood by the code formatting
tool as indicating the structure of the string literal's content.

```carbon
// This is a block string literal. Its first two characters are spaces, and its
// last character is a line feed. It has a file type of 'c++'.
var String: starts_with_whitespace = """c++
    int x = 1; // This line starts with two spaces.
    int y = 2; // This line starts with two spaces.

  """;
```

**Open question:** This proposal does not suggest any concrete set of recognized
file type indicators. It would be useful to specify a set of well-known
indicators.

#### Escape sequences

Within a non-raw string literal, the following escape sequences are recognized:

| Escape         | Meaning                              |
| -------------- | ------------------------------------ |
| `\a`           | U+0007 BELL                          |
| `\b`           | U+0008 BACKSPACE                     |
| `\t`           | U+0009 CHARACTER TABULATION          |
| `\n`           | U+000A LINE FEED                     |
| `\v`           | U+000B LINE TABULATION               |
| `\f`           | U+000C FORM FEED                     |
| `\r`           | U+000D CARRIAGE RETURN               |
| `\"`           | U+0022 QUOTATION MARK (`"`)          |
| `\'`           | U+0027 APOSTROPHE (`'`)              |
| `\\`           | U+005C REVERSE SOLIDUS (`\`)         |
| `\0`           | Code unit with value 0               |
| `\xHHHH`       | Code unit with value HH<sub>16</sub> |
| `\uHHHH`       | Unicode code point U+HHHH            |
| `\` whitespace | No string contents produced          |

This includes all C++ escape sequences except:

-   `\?`, which was historically used to escape trigraphs in string literals,
    and no longer serves any purpose.
-   `\ooo` octal escapes, which are removed because Carbon does not support
    octal literals; `\0` is retained as a special case.

While this proposal takes a firm stance no not permitting octal escape
sequences, the decision to not allow `\1`..`\7`, and more generally to not treat
`\DDDD` as a decimal escape sequence, is _experimental_.

In the above table, `HHHH` represents an arbitrary non-empty sequence of
hexadecimal characters, `0`-`9` and `A`-`F` (case-sensitive). The longest
possible sequence is used, and the character immediately following that sequence
(if any) shall not be `a`-`f`.

The escape sequence `\0` shall not be followed by a decimal digit.

A backslash followed by a whitespace character is an escape sequence that
produces no string contents. This escape sequence is _experimental_. There are
several intended uses:

-   Separating a `\x` or `\u` escape sequence from a following character that
    would otherwise be treated as part of the hexadecimal number.

-   Wrapping a long string literal that should contain no embedded line breaks
    over multiple lines.

-   Replacing the implied `\n` at the end of each line in a multiline string
    literal with a different sequence of whitespace (including trailing
    whitespace).

A single-line string literal must remain on a single line, and cannot contain a
newline escaped with a `\` character. This escape sequence is processed after
trailing whitespace is removed from content lines, so a `\` followed by
whitespace followed by a newline removes the whitespace up to and including the
newline.

```carbon
var String: fret = "I would 'twere something that would fret the string,\n" +
                   "The master-cord on's \u2764\uFE0F!"

// This string contains two characters:
// U+1F3F9 (BOW AND ARROW) followed by U+0032 (DIGIT TWO)
// The string "\u1F3F92" would contain a single invalid character, U+1F3F92.
var String: password = "\u1F3F9\ 2";

// This string contains no newline characters.
var String: type_mismatch = """
  Shall I compare thee to a summer's day? Thou art \
  more lovely and more temperate.
  """

var String: trailing_whitespace = """
  This line ends in a space followed by a newline. \n\
      This line starts with four spaces.
  """;
```

### Raw string literals

A _raw string literal_ starts with an `r` followed by _N_ `#` characters
followed by a double quotation mark, and ends with the first following
occurrence of a double quotation mark followed by _N_ `#` characters on the same
line. The text in between is not interpreted in any way. _N_ can be zero.

A _raw block string literal_ is expressed analogously to a raw string literal,
but for a block string literal. Escape sequences are ignored, but indentation is
removed and each vertical whitespace character is replaced by a line feed as in
a non-raw block string literal.

For example:

```carbon
var String: x = r#"""
  This is the content of the string. The 'T' is the first character
  of the string.
  """ <-- This is not the end of the string.
  """#; // <-- But this is.
var String: y = r"Hello\"; // OK, final character is \
var String: z = r##"Raw strings r#"nesting"#"##;
```

Note that both a single-line raw string literal and a multi-line raw string
literal can begin with `r#"""`. These cases can be distinguished by the presence
or absence of additional `"`s later in the same line:

-   In a single-line raw string literal, there must be a `"` and/or `#` later in
    the same line terminating the string.
-   In a multi-line raw string literal, the rest of the line is a file type
    indicator, which can contain neither `"` nor `#`.

```carbon
// This string is a single-line raw string literal.
// The contents of this string start and end with exactly two "s.
var String: ambig1 = r#"""This is a raw string literal starting with """#;

// This string is a block raw string literal with file-type 'This',
// whose contents start with "is a ".
var String: ambig2 = r#"""This
  is a block string literal with file type 'This' and first character 'i'.
  """#;

// This is a single-line raw string literal, equivalent to "\"".
var String: ambig3 = r#"""#;
```

### Encoding

Like Carbon source files themselves, all string literals in Carbon are encoded
in UTF-8. There is no mechanism to request any other encoding be used. The
expectation is that if another encoding is needed, the string literal can be
transcoded from UTF-8 during compilation.

This decision is _experimental_, and should be revisited if we find sufficient
motivation for directly expressing string literals in other encodings.

## Alternatives considered

### Block string literals

We could avoid including a block string literal in general, and instead
construct multi-line strings by string concatenation. But doing so would be more
verbose and would make the expression of the source code be further from the
programmer's intent.

We could use raw string literals to provide block string literal syntax, as C++
does. However, this couples two orthogonal choices: whether escape sequences
should be recognized and whether the string is intended to span multiple lines.
In C++ code, the inability to use escape sequences in multi-line string literals
sometimes awkward. For example:

```c++
std::string make_rule = "%s: %s\n\t$(CC) -c -o $@ $< $(CFLAGS)\n\n"
                        "main:\n\t$(CC) %s -o %s";
```

can be written under this proposal as

```carbon
var String: make_rule = """make
  %s: %s
  \t\    $(CC) -c -o $@ $< $(CFLAGS)

  main:
  \t\    $(CC) %s -o %s
  """;
```

#### Leading whitespace removal

Block string literals could use explicit characters in the body to indicate the
amount of leading whitespace to be removed:

```carbon
var String: x = """
  |  starts with two spaces.
  """;
```

This would allow the correct indentation to be determined as soon as the first
line after the opening `"""` is seen. However, this adds lexical complexity, and
harms the ability to copy-paste string contents into other contexts.

#### Terminating newline

We could choose to include the newline before the terminating `"""` as part of
the literal contents. However, expectations for whether it should be included
vary, and appear to be somewhat evenly split between the two options. Excluding
the trailing newline is more flexible:

-   If we exclude a trailing newline, one can be explicitly requested by
    including a blank line prior to the closing `"""`.

-   If we include a trailing newline, we could permit a trailing `\` on the
    penultimate line to remove such a trailing newline, but that would be an
    incomplete solution, as it would be unavailable in raw block string
    literals. Another possibility would be to permit the terminating `"""` to
    not be preceded by a newline as a way to remove the newline, but doing so
    would remove the vehicle by which we determine the proper indentation to
    remove from each line.

Excluding the trailing newline from the string literal contents is symmetric
with how we treat the beginning of the string: the opening newline is not part
of the contents either.

### Escape sequences

We could support octal escape sequences, as many C family languages do. However,
they are considered antiquated in C++ code, and supporting them would be
inconsistent with our decision to not support octal numeric literals. A quick
informal poll suggests that many C++ programmers do not realize that `\123` is
an octal escape sequence, not a decimal one.

We could support `\123` as a decimal escape sequence. However, doing so may lead
to surprise when migrating old C++ code to Carbon. This possibility should be
revisited once Carbon matures and we have a better idea of how the migration
process is expected to proceed.

### Raw string literals

We could use a different mechanism other than a sequence of `#`s to support
nesting raw string literals. For example, we could adopt something like C++'s
semi-arbitrary delimiters `R"foo(string contents)foo"`. However, this level of
customizability seems unwarranted: raw string literals are unlikely to nest more
than one or two levels deep, so using `r"..."`, `r#"..."#`, `r##"..."##` for
successive nesting levels seems unproblematic, and removes the need for the
programmer to make an arbitrary choice.

We could disallow use of _N_ `#`s as a delimiter if a lower value of _N_ would
work. However, this would make the language brittle under maintenance: removing
the last nested string literal from a quoted block of code would require
changing the delimiters.

#### Trailing whitespace

We could preserve trailing whitespace in at least raw block string literals, and
perhaps in all block string literals. However, this would mean that visually
identical programs could have different meanings, and even that transformations
performed automatically on save by some editors (removing trailing whitespace)
could change the meaning of a program.

This proposal provides a mechanism to that supports including trailing
whitespace in a non-raw block string literal, but provides no mechanism to do so
for a raw block string literal other than converting it to a non-raw literal or
similar.
