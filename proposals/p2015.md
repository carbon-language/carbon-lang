# Numeric type literal syntax

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/2015)

<!-- toc -->

## Table of contents

-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
    -   [Non-goals](#non-goals)
-   [Details](#details)
    -   [Syntax](#syntax)
    -   [Usage](#usage)
    -   [Syntax examples and considerations](#syntax-examples-and-considerations)
        -   [Syntax use in common fixed-size numeric types](#syntax-use-in-common-fixed-size-numeric-types)
        -   [Syntax use in arbitrary fixed-size numeric types](#syntax-use-in-arbitrary-fixed-size-numeric-types)
-   [Rationale](#rationale)
-   [Alternatives considered](#alternatives-considered)
    -   [1. C++ LP64 convention](#1-c-lp64-convention)
        -   [1.a. Advantages:](#1a-advantages)
        -   [1.b. Disadvantages:](#1b-disadvantages)
    -   [2. Type name with length suffix](#2-type-name-with-length-suffix)
        -   [2.a. Advantages:](#2a-advantages)
        -   [2.b. Disadvantages:](#2b-disadvantages)
    -   [3. Uppercase suffixes](#3-uppercase-suffixes)
        -   [3.a. Advantages:](#3a-advantages)
        -   [3.b. Disadvantages:](#3b-disadvantages)

<!-- tocstop -->

## Problem

We want to establish a syntax for fixed-size scalar number types. These types
include the two’s complement signed integer, the unsigned integer, and the
floating-point number.

As these types are pervasive throughout the language, our goal here is to align
on a terse, convenient, yet understandable, and ergonomic syntax to the author.

## Background

For developer convenience, names are given to number types that map to native
machine register widths. These sizes typically include 8-bit, 16-bit, 32-bit,
64-bit, and, more recently, 128-bit widths.

For example, in [C++11+](https://en.cppreference.com/w/cpp/types/integer),
integer types such as `int8_t` (8-bit two’s complement signed integer type) and
`uint16_t` (16-bit unsigned integer type) exist, among similar types for 32- and
64-bit values. Correspondingly, you have the `i8` and `u16`
([among others](https://doc.rust-lang.org/book/ch03-02-data-types.html#scalar-types))
scalar integer types in Rust. And in Swift, the `Int8` and `UInt16`
([among others](https://developer.apple.com/documentation/swift/uint8)) integer
value types.

In each case, the intent is to provide a clear and pragmatic syntax.

Additional discussion around this proposal's background can be found in
[#543](https://github.com/carbon-language/carbon-lang/issues/543).

## Proposal

We introduce a simple keyword-like syntax of `iN`, `uN`, and `fN` for two’s
complement integers, unsigned integers, and floating-point numbers,
respectively. Where `N` can map to common power-of-two sizes (for example,
`N = 8, 16, 32`) or any other fixed-width value (for example, `N = 42`). This
structure follows the successful precedent set by Rust and LLVM development
communities and potentially saves 40% or more on characters required compared to
other options such as `IntN` (for example, `i16` versus `Int16`).

### Non-goals

-   This does not address any considerations around the `bool` type
-   This does not provide a formal plan for the shape or mapping of the
    underlying types
    ([#767 comments](https://github.com/carbon-language/carbon-lang/issues/767#issuecomment-1214153375))
-   This does not prescribe an official grammar for parsing of these types

## Details

### Syntax

The syntax for a two’s complement signed integer, the unsigned integer, and the
floating-point number corresponds to a lowercase ‘i’, ‘u’, or ‘f’ character,
respectively, indicating the type followed by a numeric value specifying the
width.

As a regular expression, this can be illustrated as:

```re
^([iuf])(\d+)$
```

Capture group 1 indicates either an ‘i’ for a two’s complement signed integer
type, a ‘u’ for an unsigned integer type, or a ‘f’ for a floating-point number
type. And capture group 2 specifies the width in bits.

Examples of this syntax include:

-   `i32` - A 32-bit two’s complement signed integer type
-   `u16` - A 16-bit unsigned integer type
-   `f128` - A 128-bit IEEE 754 floating-point number type

### Usage

```carbon
package sample api;

fn Sum(x: i32, y: i32) -> i32 {
  return x + y;
}

fn Main() -> i32 {
  return Sum(4, 2);
}
```

In the above example, `Sum` has parameters `x` and `y`, each of which is typed
as a 32-bit two’s complement signed integer. `Main` then returns the output of
`Sum` as a 32-bit two’s complement signed integer.

### Syntax examples and considerations

#### Syntax use in common fixed-size numeric types

These fixed-width sizes will naturally cover the common register widths of 8-,
16-, 32-, 64-, and 128-bits, as seen in other languages.

Which expand to:

-   `i8`, `i16`, `i32`, `i64`, and `i128` keyword aliases for
    `Carbon.Int(N={8,16,32,64,128})`
-   `u8`, `u16`, `u32`, `u64`, and `u128` keyword aliases for
    `Carbon.UInt(N={8,16,32,64,128})`
-   `f16`, `f32`, `f64`, and `f128` keyword aliases for
    `Carbon.Float(N={16,32,64,128})`

#### Syntax use in arbitrary fixed-size numeric types

[As proposed by @chandlerc](https://github.com/carbon-language/carbon-lang/issues/543#issuecomment-845620894)
, our heuristic for type qualification here will be "Any truly pervasive
non-aggregate/composite/compound type that is also fundamentally
size-parameterized."

This adds keywords that alias the following numeric types:

-   `iN` for `Carbon.Int(N)`, An N-width two’s complement signed integer type
-   `uN` for `Carbon.UInt(N)`, An N-width unsigned integer type
-   `fN` for `Carbon.Float(N)`, An N-width IEEE 754 floating-point number type

## Rationale

Following Carbon’s goal to facilitate
["Code that is easy to read, understand, and write"](https://github.com/carbon-language/carbon-lang/blob/trunk/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write),
an explicit goal is to provide excellent ergonomics.

Highlighting relevant aspects of this from the project goals:

-   _Carbon should not use symbols that are difficult to type, see, or
    differentiate from similar symbols in commonly used contexts._
-   _Syntax should be easily parsed and scanned by any human in any development
    environment, not just a machine or a human aided by semantic hints from an
    IDE._
-   _Explicitness must be balanced against conciseness, as verbosity and
    ceremony add cognitive overhead for the reader, while explicitness reduces
    the amount of outside context the reader must have or assume._

## Alternatives considered

As discussed in
[#543](https://github.com/carbon-language/carbon-lang/issues/543), three other
options were considered:

### 1. C++ LP64 convention

Where `char` is the 8-bit type, `short` is the 16-bit type, `int` is the 32-bit
type, `long` is the 64-bit type.

#### 1.a. Advantages:

-   The type name indicates its use to the reader
-   There is an existing precedent of this pattern in many programming
    languages, including C++

#### 1.b. Disadvantages:

-   The type names themselves, as compared to the actual width and potentially
    use, often can be arbitrary and confusing
-   The names themselves can be longer than the other syntax options

### 2. Type name with length suffix

Complete type name with a length-specifying suffix - `int8`, `int16`, `int32`,
`int64`, `uint32`, `float64`.

#### 2.a. Advantages:

-   Are more explicit than an abbreviated version
-   Stand out against similar variable names, for example, `i8` versus `i = 8`)

#### 2.b. Disadvantages:

-   Contain additional verbosity for potentially a non-significant amount of
    clarity
-   There are precedents from other communities (for example, Rust) that
    indicate authors enjoy a more compact syntax

### 3. Uppercase suffixes

The suffix can be upper - `Int8`, `UInt8`, `Float16`; `I8`, `U8`, `F16`.

#### 3.a. Advantages:

-   May help screen readers distinguish the type

#### 3.b. Disadvantages:

-   Can be visually similar to other values, for example, `I8` versus `l8`
    (second is a lowercase L)
