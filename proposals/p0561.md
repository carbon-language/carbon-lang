# Basic structs (v2)

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/561)

<!-- toc -->

## Table of contents

-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Rationale based on Carbon's goals](#rationale-based-on-carbons-goals)
-   [Alternatives considered](#alternatives-considered)
    -   [Earlier proposal](#earlier-proposal)
    -   [Interfaces implemented for anonymous data classes](#interfaces-implemented-for-anonymous-data-classes)
    -   [Default access control](#default-access-control)

<!-- tocstop -->

## Problem

We need to say how you define new types in Carbon. This proposal is specifically
about [record types](<https://en.wikipedia.org/wiki/Record_(computer_science)>).
The proposal is not intended to be a complete story for record types, but enough
to get agreement on direction. It primarily focuses on:

-   use cases including: data types, non-virtual object types, abstract base
    classes that support multiple inheritance, single-inheritance polymorphic
    types, and mixins for code reuse;
-   anonymous data types for struct literals used to initialize struct values
    and ad-hoc parameter and return types with named components; and
-   future work, including the provisional syntax in use for features that have
    not been decided.

## Background

This is a replacement for earlier proposal
[#98](https://github.com/carbon-language/carbon-lang/pull/98).

## Proposal

This proposal adds an initial design for record types called "structs",
including anonymous structs and anonymous struct literals. The design is
replacing the skeletal design present in
[this document](/docs/design/structs.md).

## Rationale based on Carbon's goals

This particular proposal is focusing on
[the Carbon goal](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write)
that code is "easy to read, understand, and write." Future proposals will
address other aspects of the `struct` design such as performance.

## Alternatives considered

### Earlier proposal

There was an earlier proposal
[#98](https://github.com/carbon-language/carbon-lang/pull/98), that made a
number of different choices, including:

-   Tuples were given named components instead of having separate struct
    literals.
-   No form of multiple inheritance was proposed.
-   Operators were define using methods like C++ instead of by implementing
    interfaces like Rust.
-   Constructors had a special form like C++ instead of being regular functions
    like Rust.
-   Tuples and structs were both considered example of record types.
-   Members of structs could be individually left uninitialized.
-   Coverage of nominal types, inheritance, etc. were considered in much more
    detail.

### Interfaces implemented for anonymous data classes

Whether we would support implementing interfaces for specific anonymous data
classes was
[discussed on Discord](https://discord.com/channels/655572317891461132/709488742942900284/867471671089561643).
[The conclusion](https://discord.com/channels/655572317891461132/709488742942900284/867516894029938710)
was "yes", reasoning that we would support that for the same reason as a number
of other cases such as tuple and pointer types.
[A specific use case](https://discord.com/channels/655572317891461132/709488742942900284/867517209026756630)
would be implementing interface

```
interface ConstructWidgetFrom { fn Construct(Self) -> Widget; }
```

for type `{.kind: WidgetKind, .size: Int}`.

### Default access control

[Issue #665](https://github.com/carbon-language/carbon-lang/issues/665) decided
that by default members of a struct would be publicly accessible. There were a
few reasons:

-   The readability of public members is the most important, since we expect
    most readers to be concerned with the public API of a type.
-   The members that are most commonly private are the data fields, which have
    relatively less complicated definitions that suffer less from the extra
    annotation.

Additionally, there is precedent for this approach in modern object-oriented
languages such as
[Kotlin](https://kotlinlang.org/docs/visibility-modifiers.html) and
[Python](https://docs.python.org/3/tutorial/classes.html), both of which are
well regarded for their usability.

It further decided that members would be given more restricted access using a
local annotation on the declaration itself rather than a block or region
approach such as used in C++. This is primarily motivated by a desire to reduce
context sensitivity, following the principle in
[#646](https://github.com/carbon-language/carbon-lang/pull/646). It helps
readers to more easily determine the accessibility of a member in large classes,
say when they have jumped to a specific definition in their IDE.
