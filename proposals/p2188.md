# Pattern matching syntax and semantics

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/2188)

<!-- toc -->

## Table of contents

-   [Abstract](#abstract)
-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Details](#details)
    -   [Expressions versus proper patterns](#expressions-versus-proper-patterns)
    -   [Expression patterns](#expression-patterns)
    -   [Bindings](#bindings)
        -   [Name bindings](#name-bindings)
        -   [Wildcard](#wildcard)
        -   [Generic bindings](#generic-bindings)
        -   [`auto` and type deduction](#auto-and-type-deduction)
    -   [`var`](#var)
    -   [Tuple patterns](#tuple-patterns)
    -   [Struct patterns](#struct-patterns)
    -   [Alternative patterns](#alternative-patterns)
    -   [Templates](#templates)
    -   [Guards](#guards)
    -   [Refutability, overlap, usefulness, and exhaustiveness](#refutability-overlap-usefulness-and-exhaustiveness)
-   [Rationale](#rationale)
-   [Alternatives considered](#alternatives-considered)
    -   [Shorthand for `auto`](#shorthand-for-auto)
    -   [Struct pattern syntax](#struct-pattern-syntax)
    -   [Type pattern matching](#type-pattern-matching)
    -   [Introducer syntax for expression patterns](#introducer-syntax-for-expression-patterns)
    -   [Allow guards on arbitrary patterns](#allow-guards-on-arbitrary-patterns)
    -   [Treat expression patterns as exhaustive if they cover all possible values](#treat-expression-patterns-as-exhaustive-if-they-cover-all-possible-values)
-   [Future work](#future-work)
    -   [Or patterns](#or-patterns)
    -   [Matching classes by dynamic type](#matching-classes-by-dynamic-type)
    -   [User-defined pattern matching](#user-defined-pattern-matching)
    -   [Matching classes with struct patterns](#matching-classes-with-struct-patterns)
    -   [Type deduction](#type-deduction)

<!-- tocstop -->

## Abstract

This paper proposes concrete syntax and semantic choices for Carbon patterns.

## Problem

Carbon uses patterns wherever a value should be given a name, decomposed, or
matched against: in function parameters, variable declarations, `match`
statement `case`s, `for` statement loop variables, and so on. Simplified forms
of patterns, required to be just a simple name binding, appear in additional
contexts, such as fields in classes and implicit parameter lists. While we have
syntax specified for some of these constructs, we do not have an approved
proposal describing the syntax or semantics of patterns.

## Background

See [pattern matching](https://en.wikipedia.org/wiki/Pattern_matching) on
wikipedia for a broad overview of the subject.

We refer to the value being matched by a pattern as the _scrutinee_.

## Proposal

Patterns in Carbon are a generalization of the expression grammar. Compared to
expressions, patterns add:

-   Bindings, of the form `name: type`, which give a name for the scrutinee.
-   `var` _pattern_, which creates a separate object to hold the value of the
    scrutinee, and causes any nested bindings to be mutable lvalues instead of
    immutable rvalues.
-   Additional syntax to make matching against structs more convenient.

## Details

### Expressions versus proper patterns

Expressions are patterns, as described below. A pattern that is not an
expression, because it contains pattern-specific syntax such as a binding, is a
_proper pattern_. Many expression forms, such as arbitrary function calls, are
not permitted as proper patterns, so cannot contain bindings.

-   _pattern_ ::= _proper-pattern_

```
fn F(n: i32) -> i32 { return n; }

match (F(42)) {
  // ❌ Error: binding can't appear in a function call.
  case (F(n: i32)) => {}
}
```

### Expression patterns

An expression is a pattern.

-   _pattern_ ::= _expression_

The pattern is compared with the expression using the `==` operator: _pattern_
`==` _scrutinee_.

```
fn F(n: i32) {
  match (n) {
    // ✅ Results in an `n == 5` comparison.
    // OK despite `n` and `5` having different types.
    case 5 => {}
  }
}
```

Any `==` operations performed by a pattern match occur in lexical order, but for
repeated matches against the same _pattern_, later comparisons may be skipped by
reusing the result from an earlier comparison:

```
class ChattyIntMatcher {
  external impl as EqWith(i32) {
    fn Eq[me: ChattyIntMatcher](other: i32) {
      Print("Matching {0}", other);
      return other == 1;
    }
  }
}

fn F() {
  // Prints `Matching 1` then `Matching 2`,
  // may or may not then print `Matching 1` again.
  match ((1, 2)) {
    case ({} as ChattyIntMatcher, 0) => {}
    case (1, {} as ChattyIntMatcher) => {}
    case ({} as ChattyIntMatcher, 2) => {}
  }
}
```

### Bindings

#### Name bindings

A name binding is a pattern.

-   _binding-pattern_ ::= `unused`? _identifier_ `:` _expression_
-   _proper-pattern_ ::= _binding-pattern_

The type of the _identifier_ is specified by the _expression_. The scrutinee is
implicitly converted to that type if necessary.

```
fn F() -> i32 {
  match (5) (
    // ✅ `5` is implicitly converted to `i32`.
    // Returns `5 as i32`.
    case n: i32 => { return n; }
  }
}
```

When a new object needs to be created for the binding, the lifetime of the bound
value matches the scope of the binding.

```
class NoisyDestructor {
  fn Make() -> Self { return {}; }
  external impl i32 as ImplicitAs(NoisyDestructor) {
    fn Convert[me: i32]() -> Self { return Make(); }
  }
  destructor {
    Print("Destroyed!");
  }
}

fn G() {
  // Does not print "Destroyed!".
  let n: NoisyDestructor = NoisyDestructor.Make();
  Print("Body of G");
  // Prints "Destroyed!" here.
}

fn H(n: i32) {
  // Does not print "Destroyed!".
  let (v: NoisyDestructor, w: i32) = (n, n);
  Print("Body of H");
  // Prints "Destroyed!" here.
}
```

As specified in
[#2022](/proposals/p2022.md#the-behavior-of-unused-name-bindings), the `unused`
keyword indicates that the binding is intended to not be used.

#### Wildcard

A syntax like a binding but with `_` in place of an identifier can be used to
ignore part of a value.

-   _binding-pattern_ ::= `_` `:` _expression_

See [#2022](/proposals/p2022.md) for details.

The behavior is similar to that of an `unused` binding with a unique name.

```
fn F(n: i32) {
  match (n) {
    // ✅ Matches and discards the value of `n`.
    case _: i32 => {}
    // ❌ Error: unreachable.
    default => {}
  }
}
```

As specified in [#1084](/proposals/p1084.md), function redeclarations may
replace named bindings with wildcards but may not use different names.

```
fn G(n: i32);
fn H(n: i32);
fn J(n: i32);

// ✅ Does not use `n`.
fn G(_: i32) {}
// ❌ Error: name of parameter does not match declaration.
fn H(m: i32) {}
// ✅ Does not use `n`.
fn J(unused n: i32);
```

#### Generic bindings

A `:!` can be used in place of `:` for a binding that is usable at compile time.

-   _generic-pattern_ ::= `unused`? `template`? _identifier_ `:!` _expression_
-   _generic-pattern_ ::= `template`? `_` `:!` _expression_
-   _proper-pattern_ ::= _generic-pattern_

```
// ✅ `F` takes a generic type parameter `T` and a parameter `x` of type `T`.
fn F(T:! Type, x: T) {
  var v: T = x;
}
```

The `template` keyword indicates the binding is introducing a template
parameter, so name lookups into the parameter should be deferred until its value
is known.

#### `auto` and type deduction

The `auto` keyword is a placeholder for a unique deduced type.

-   _expression_ ::= `auto`

```
fn F(n: i32) {
  var v: auto = SomeComplicatedExpression(n);
  // Equivalent to:
  var w: T = SomeComplicatedExpression(n);
  // ... where `T` is the type of the initializer.
}
```

The `auto` keyword is only permitted in specific contexts. Currently these are:

-   As the return type of a function.
-   As the type of a binding.

It is anticipated that `auto` may be permitted in more contexts in the future,
for example as a generic argument in a parameterized type that appears in a
context where `auto` is allowed, such as `Vector(auto)` or `auto*`.

When the type of a binding requires type deduction, the type is deduced against
the type of the scrutinee and deduced values are substituted back into the type
before pattern matching is performed.

```
fn G[T:! Type](p: T*);
class X { external impl as ImplicitAs(i32*); }
// ✅ Deduces `T = i32` then implicitly and
// trivially converts `p` to `i32*`.
fn H1(p: i32*) { G(p); }
// ❌ Error, can't deduce `T*` from `X`.
fn H2(p: X) { G(p); }
```

The above is only an illustration; the behavior of type deduction is not
specified in this proposal.

### `var`

A `var` prefix indicates that a pattern provides mutable storage for the
scrutinee.

-   _proper-pattern_ ::= `var` _proper-pattern_

A `var` pattern matches when its nested pattern matches. The type of the storage
is the resolved type of the nested _pattern_. Any bindings within the nested
pattern refer to portions of the corresponding storage rather than to the
scrutinee.

```
fn F(p: i32*);
fn G() {
  match ((1, 2)) {
    // `n` is a mutable `i32`.
    case (var n: i32, 1) => { F(&n); }
    // `n` and `m` are the elements of a mutable `(i32, i32)`.
    case var (n: i32, m: i32) => { F(if n then &n else &m); }
  }
}
```

Pattern matching precedes the initialization of the storage for any `var`
patterns. An introduced variable is only initialized if the complete pattern
matches.

```
class X {
  destructor { Print("Destroyed!"); }
}
fn F(x: X) {
  match ((x, 1 as i32)) {
    case (var y: X, 0) => {}
    case (var z: X, 1) => {}
    // Prints "Destroyed!" only once, when `z` is destroyed.
  }
}
```

A `var` pattern cannot be nested within another `var` pattern. The declaration
syntax `var` _pattern_ `=` _expresson_ `;` is equivalent to `let` `var`
_pattern_ `=` _expression_ `;`.

### Tuple patterns

A tuple of patterns can be used as a pattern.

-   _tuple-pattern_ ::= `(` [_expression_ `,`]\* _proper-pattern_ [`,`
    _pattern_]\* `,`? `)`
-   _proper-pattern_ ::= _tuple-pattern_

A _tuple-pattern_ containing no commas is treated as grouping parens: the
contained _proper-pattern_ is matched directly against the scrutinee. Otherwise,
the behavior is as follows.

A tuple pattern is matched left-to-right. The scrutinee is required to be of
tuple type.

Note that a tuple pattern must contain at least one _proper-pattern_. Otherwise,
it is a tuple-valued expression. However, a tuple pattern and a corresponding
tuple-valued expression are matched in the same way because `==` for a tuple
compares fields left-to-right.

### Struct patterns

A struct can be matched with a struct pattern.

-   _proper-pattern_ ::= `{` [_field-init_ `,`]\* _proper-field-pattern_ [`,`
    _field-pattern_]\* `}`
-   _proper-pattern_ ::= `{` [_field-pattern_ `,`]+ `_` `}`
-   _field-init_ ::= _designator_ `=` _expression_
-   _proper-field-pattern_ ::= _designator_ `=` _proper-pattern_
-   _proper-field-pattern_ ::= _binding-pattern_
-   _field-pattern_ ::= _field-init_
-   _field-pattern_ ::= _proper-field-pattern_

A struct pattern resembles a struct literal, with at least one field initialized
with a proper pattern:

```
match ({.a = 1, .b = 2}) {
  // Struct literal as an expression pattern.
  case {.b = 2, .a = 1} => {}
  // Struct pattern.
  case {.b = n: i32, .a = m: i32} => {}
}
```

The scrutinee is required to be of struct type, and to have the same set of
field names as the pattern. The pattern is matched left-to-right, meaning that
matching is performed in the field order specified in the pattern, not in the
field order of the scrutinee. This is consistent with the behavior of matching
against a struct-valued expression, where the expression pattern becomes the
left operand of the `==` and so determines the order in which `==` comparisons
for fields are performed.

In the case where a field will be bound to an identifier with the same name, a
shorthand syntax is available: `a: T` is synonymous with `.a = a: T`.

```
match ({.a = 1, .b = 2}) {
  case {a: i32, b: i32} => { return a + b; }
}
```

If some fields should be ignored when matching, a trailing `, _` can be added to
specify this:

```
match ({.a = 1, .b = 2}) {
  case {.a = 1, _} => { return 1; }
  case {b: i32, _} => { return b; }
}
```

This is valid even if all fields are actually named in the pattern.

### Alternative patterns

An alternative pattern is used to match one alternative of a choice type.

-   _proper-pattern_ ::= _callee-expression_ _tuple-pattern_
-   _proper-pattern_ ::= _designator_ _tuple-pattern_?

Here, _callee-expression_ is syntactically an expression that is valid as the
callee in a function call expression, and an alternative pattern is
syntactically a function call expression whose argument list contains at least
one _proper-pattern_.

If a _callee-expression_ is provided, it is required to name a choice type
alternative that has a parameter list, and the scrutinee is implicitly converted
to that choice type. Otherwise, the scrutinee is required to be of some choice
type, and the designator is looked up in that type and is required to name an
alternative with a parameter list if and only if a _tuple-pattern_ is specified.

The pattern matches if the active alternative in the scrutinee is the specified
alternative, and the arguments of the alternative match the given tuple pattern
(if any).

```
choice Optional(T:! Type) {
  None,
  Some(T)
}

match (Optional(i32).None) {
  // ✅ `.None` resolved to `Optional(i32).None`.
  case .None => {}
  // ✅ `.Some` resolved to `Optional(i32).Some`.
  case .Some(n: i32) => { Print("{0}", n); }
  // ❌ Error, no such alternative exists.
  case .Other => {}
}

class X {
  external impl as ImplicitAs(Optional(i32));
}

match ({} as X) {
  // ✅ OK, but expression pattern.
  case Optional(i32).None => {}
  // ✅ OK, implicitly converts to `Optional(i32)`.
  case Optional(i32).Some(n: i32) => { Print("{0}", n); }
}
```

Note that a pattern of the form `Optional(T).None` is an expression pattern and
is compared using `==`.

### Templates

If the type of the scrutinee of a pattern involves a template parameter, any
checking of the type of the scrutinee against the type of the pattern is
deferred until the template parameter's value is known. During instantiation,
patterns that are not meaningful due to a type error are instead treated as not
matching. This includes cases where an `==` fails because of a missing `EqWith`
implementation.

```
fn TypeName[template T:! Type](x: T) -> String {
  match (x) {
    // ✅ OK, the type of `x` is a template parameter.
    case _: i32 => { return "int"; }
    case _: bool => { return "bool"; }
    case _: auto* => { return "pointer"; }
    default => { return "unknown"; }
  }
}
```

### Guards

We allow `case`s within a `match` statement to have _guards_. These are not part
of pattern syntax, but instead are specific to `case` syntax:

-   _case_ ::= `case` _pattern_ [`if` _expression_]? `=>` _block_

A guard indicates that a `case` only matches if some predicate holds. The
bindings in the pattern are in scope in the guard:

```
match (x) {
  case (m: i32, n: i32) if m + n < 5 => { return m - n; }
}
```

For consistency, this facility is also available for `default` clauses, so that
`default` remains equivalent to `case _: auto`.

### Refutability, overlap, usefulness, and exhaustiveness

Some definitions:

-   A pattern _P_ is _useful_ in the context of a set of patterns _C_ if _P_ can
    match any value that no pattern in _C_ matches.
-   A set of patterns _C_ is _exhaustive_ if it matches all possible values.
    Equivalently, _C_ is exhaustive if the pattern `_: auto` is not useful in
    the context of _C_.
-   A pattern _P_ is _refutable_ if there are values that it does not match,
    that is, if the pattern `_` is useful in the context of {_P_}.
-   A set of patterns _C_ is _overlapping_ if there exists any value that is
    matched by more than one pattern in _C_.

For the purpose of these terms, expression patterns that match a constant tuple,
struct, or choice value are treated as if they were tuple, struct, or
alternative patterns, respectively, and `bool` is treated like a choice type.
Any expression patterns that remain after applying this rule are considered to
match a single value from an infinite set of values so that a set of expression
patterns is never exhaustive:

```
fn IsEven(n: u8) -> bool {
  // Not considered exhaustive.
  match (n) {
    case 0 => { return true; }
    case 1 => { return false; }
    ...
    case 255 => { return false; }
  }
  // Code here is considered to be reachable.
}
```

```
fn IsTrue(b: bool) -> bool {
  match (b) {
    case false => { return false; }
    case true => { return true; }
  }
  // Code here is considered to be unreachable.
}
```

When determining whether a pattern is useful, no attempt is made to determine
the value of any guards, and instead a worst-case assumption is made: a guard on
that pattern is assumed to evaluate to true and a guard on any pattern in the
context set is assumed to evaluate to false.

We will diagnose the following situations:

-   A pattern is not useful in the context of prior patterns. In a `match`
    statement, this happens if a pattern or `default` cannot match because all
    cases it could cover are handled by prior cases or a prior `default`. For
    example:

    ```
    choice Optional(T:! Type) {
      None,
      Some(T)
    }
    fn F(a: Optional(i32), b: Optional(i32)) {
      match ((a, b)) {
        case (.Some(a: i32), _: auto) => {}
        // ✅ OK, but only matches values of the form `(None, Some)`,
        // because `(Some, Some)` is matched by the previous pattern.
        case (_: auto, .Some(b: i32)) => {}
        // ✅ OK, matches all remaining values.
        case (.None, .None) => {}
        // ❌ Error, this pattern never matches.
        case (_: auto, _: auto) => {}
      }
    }
    ```

-   A pattern match is not exhaustive and some other language rule requires
    exhaustiveness. For example:

    -   If control flow from the end of a `match` can reach the end of a
        value-returning function, the `match` is required to be exhaustive.

        ```
        fn F(n: i32) -> i32 {
          // ❌ Error, control flow can reach end of value-returning function
          // because this `match` is not exhaustive.
          match (n) {
            case 0 => { return 2; }
            case 1 => { return 3; }
            case 2 => { return 5; }
            case 3 => { return 7; }
            case 4 => { return 11; }
          }
        }
        ```

    -   If a variable could potentially be used while in an unformed state if no
        case in a `match` statement matches.

        ```
        fn F(n: i32) -> i32 {
          var m: i32;
          // ❌ Error, `m` used in an unformed state if the `default` case of
          // this `match` is chosen.
          match (n) {
            case 0 => { m = 2; }
            case 1 => { m = 3; }
            case 2 => { m = 5; }
            case 3 => { m = 7; }
            case 4 => { m = 11; }
          }
          return m;
        }
        ```

-   A pattern is refutable and is used in a context that requires an irrefutable
    pattern. This currently includes all pattern matching contexts other than
    `match` statements, but the `var`/`let`-`else` feature in
    [#1871](https://github.com/carbon-language/carbon-lang/pull/1871) would
    introduce a second context permitting refutable matches, and overloaded
    functions might introduce a third context.

    ```
    fn F(n: i32) {
      // ❌ Error, refutable expression pattern `5` used in context
      // requiring an irrefutable pattern.
      var 5 = n;
    }
    // ❌ Error, refutable expression pattern `5` used in context
    // requiring an irrefutable pattern.
    fn G(n: i32, 5);
    ```

-   When a set of patterns have no ordering or tie-breaker, it is an error for
    them to overlap unless there is a unique best match for any value that
    matches more than one pattern. However, this situation does not apply to any
    current language rule:

    -   For `match` statements, patterns are matched top-down, so overlap is
        permitted.
    -   We do not yet have an approved design for overloaded functions, but it
        is anticipated that declaration order will be used in that case too.
    -   For a set of `impl`s that match a given `impl` lookup, argument
        deduction is used rather than pattern matching, but overlapping `impl`s
        with the same type structure are an error unless either an `impl` is
        provided to cover the overlap or a `match_first` declaration is used to
        order the `impl`s. (This is a pre-existing rule and is unchanged by this
        proposal.)

## Rationale

-   [Software and language evolution](/docs/project/goals.md#software-and-language-evolution)
    -   The `, _` syntax for struct patterns enables a style where adding a
        struct member is not a breaking change.
-   [Code that is easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write)
    -   Pattern syntax makes it easier to match complex values.
    -   Modeling pattern syntax after expressions eases the burden of learning a
        new sub-language for pattern-matching: patterns are an extension of
        expressions, and expressions are a special case of patterns.
-   [Interoperability with and migration from existing C++ code](/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code)
    -   The rules for matching a templated value can be used to replace
        `if constexpr` in many cases.

## Alternatives considered

### Shorthand for `auto`

We could provide a shorter syntax for `name: auto`.
[Proposal #851](https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p0851.md#elide-the-type-instead-of-using-auto)
considered the following shorthands and decided against using them:

```
var n: _ = init;
var n = init;
```

A novel suggestion that avoids some of the disadvantages of those syntaxes would
be to use:

```
var n:= init;
```

Advantages:

-   Shorter syntax for variables with a deduced type.
-   Potentially allows removal of the `auto` keyword.

Disadvantages:

-   Appears to introduce a `:=` syntax, but that only arises in cases where an
    initializer immediately follows the name.
    -   Cases such as `var (a:, b:) = my_pair;` would either be invalid or would
        not use the `:=` syntax.
    -   If we accept such cases, there is a risk of grammar ambiguities.
    -   If we reject such cases, we may still want to keep `auto` around for
        them, creating inconsistency.
-   Not a complete replacement for `auto` if we want to also allow things like
    `v: Vector(auto)`. C++ doesn't allow the equivalent syntax currently, but it
    was part of the Concepts TS and seems likely to return at some point.
-   No syntactic difference between accidentally omitting a type entirely and
    requesting type deduction. However, the mistake of omitting a type but
    retaining the `:` seems unlikely, and the `:` followed by the absence of a
    type is a signal that something is happening, so this seems to be less of a
    concern than for the `var n = init;` syntax.

See discussion topics
[1](https://github.com/carbon-language/carbon-lang/discussions/1495) and
[2](https://github.com/carbon-language/carbon-lang/discussions/1988).

### Struct pattern syntax

We could omit the `, _` syntax. This would simplify struct patterns, but at the
cost of removing a feature that can be useful for reducing verbosity and making
library evolution easier.

We could always allow a struct pattern to match a struct with more fields,
without requiring a `, _` suffix. This would aid evolution by reducing the cases
where adding a field to a struct can be a breaking change, but such cases would
still exist. Further, this would make matches against a struct-valued expression
inconsistent with matches against a struct pattern.

We could use a different syntax instead of `, _`. Other options that were
explicitly considered:

-   `, ...` seems visually evocative of "and more stuff", but risks conflicting
    with variadic syntax or at least being confusing when used in a variadic
    context, given that variadics are expected to claim `...` for pack
    expansion.
-   `, ._` suggests matching a field without specifying a name, but might create
    an impression of matching just one field, and three low punctuation
    characters in a row seems to be pushing the limits of readability.

On balance, `, _` harmonizes well with the use of `_` to introduce a wildcard,
without being too visually confusing given that the other use of `_` has a
following `:`.

We could remove the `{field: type}` shorthand and require
`{.field = field: type}`. This may avoid encouraging reusing the field name even
when it is not appropriate, and would remove some syntactic sugar that's not
formally necessary. However, we expect this to be a common case whose ergonomics
are important.

We could use a different syntax for `{field: type}` that is less divergent from
other struct syntaxes:

-   `{.field: type}` seems like a contender, but doesn't work because that is
    already recognized as a struct type literal. Also, the use of normal binding
    syntax means that every locally-introduced name is always introduced by
    `name: type` where `name` is not preceded by `.`.
-   `{.=field: type}` might be a reasonable mnemonic shorthand for
    `{.field = field: type}`, but looks a little surprising. This is probably
    the best choice if concerns are found with `{field: type}` syntax.

### Type pattern matching

We could treat type deduction as a form of pattern matching. For example, we
could allow

```
fn F(a: Vector(T:! Type)) -> T { return a[0]; }
fn G() -> i32 {
  let v: Vector(i32) = (1, 2, 3);
  // Deduces `T = i32`.
  return F(v);
}
```

where the value of `T` is determined by pattern-matching `Vector(T:! Type)`
against the supplied type `Vector(i32)` of `v`. And symmetrically:

```
fn H[m: i32, n: i32](k: i32, (m, n)) { return m + n; }
fn I() {
  // Deduces `m = 2`, `n = 3`.
  H(1, (2, 3));
}
```

This would ensure consistency between pattern matching and deduction,
potentially reducing the number of rules that Carbon developers need to learn.

We find that use of pattern-matching in type position can harm readability. For
example, the first of these two examples may be easier to read due to having
less nesting:

```
fn F[T:! Type](x: T);
fn F(x: (T:! Type));
```

Having distinct syntax for type-level matching and value-level matching helps
guide the reader to the correct interpretation, even though the underlying
matching process is expected to be similar or identical. As a result, we keep
type deduction syntax and pattern matching syntax separate for now:

-   In pattern matching, bindings and wildcards are introduced by nested `:` /
    `:!` patterns, and the right-hand side of a binding pattern is never a
    proper pattern.
-   In type deduction, deduced values are specified separately and an expression
    written in terms of those bindings describes the type.

### Introducer syntax for expression patterns

We could have some separate introducer syntax to distinguish expression patterns
from other kinds of patterns:

```
match ((a, b)) {
  case is (1, 2) => {}
  case (is 3, n: i32) => {}
  case (m: i32, is 4) => {}
}
```

This would reduce the chance of confusion in cases where an expression and a
similar-looking pattern are treated differently:

```
class TupleLike {
  external impl as (i32, i32);
}
fn MatchTupleLike(t: TupleLike) {
  match (t) {
    // ✅ OK, expression pattern;
    // `t` implicitly converted to `(i32, i32)` by
    // built-in `impl EqWith` for tuples.
    case (1, 2) => {}
    // ❌ Error, `t` is not a tuple.
    case (n: i32, 3) => {}
  }
}
```

However, this would also introduce additional ceremony for the common case where
part of a pattern is a specific value. This could be mitigated by permitting
certain kinds of value as patterns without an introducer, such as numeric
literals and `true` and `false`, at the cost of introducing more complexity and
more confusion over which cases require `is` and which do not.

We have also not identified a good choice for the introducer syntax, should we
pursue this direction. `is` is not an ideal choice, because elsewhere in Carbon
syntax, it is a relation between a value and its type, so `is T` may be misread
as matching values whose type is `T`. `==` _expression_ has been suggested, but
that would imply the opposite operand order of that in this proposal --
_scrutinee_ `==` _expression_ rather than _expression_ `==` _scrutinee_ -- which
would compare struct fields in a surprising order that diverges from the order
of comparison for a struct pattern.

### Allow guards on arbitrary patterns

We could treat guards as part of pattern syntax instead of as part of `case`
syntax. However, since guards make a pattern refutable, this wouldn't allow them
anywhere other than in `case`s in the current language design. It would allow
them to be nested within cases:

```
match (x) {
  case (n: i32 if n > 5, "some string") => { ... }
}
```

Such nesting might allow an expensive later check to be avoided. For example, in
the above case we can avoid an `==` comparison on a string if a cheaper
comparison of `n > 5` fails. However, this would introduce complexity into the
grammar, and it's not clear that this feature would add sufficient value to
justify that complexity.

An additional concern is that if we add `let`...`else` syntax, this would
presumably permit things like:

```
let n: i32 if n > 5 = 20 else { return 0; };
```

... where it would be easy to misparse the `if ... else` as being a single
construct, where the intended parse would be:

```
let ((n: i32) if n > 5) = 20 else { return 0; };
```

### Treat expression patterns as exhaustive if they cover all possible values

We could do more work to treat a set of expression patterns as being exhaustive,
if each pattern has a constant value and between those constant values, all
possible values of the type are covered. The advantage of this would be that we
improve the precision of our language rules.

This change in rules has some disadvantages and problems:

-   It would add some complexity to the rules and to implementations in order to
    track whether all possible values have been created.
-   For even the simplest types where this would apply, such as `i8`, it seems
    unlikely that a `match` covering all possible values would be written, due
    to the large number of patterns required.
-   In many cases, the value being matched will carry an invariant so that
    matching a subset of the representable values would match all meaningful
    values. We would still have imprecise rules in those cases.
-   Expression patterns are matched with `==`, and for an arbitrary `==` it is
    not computable in general to tell whether a given set of values is
    exhaustive, so we would only be able to apply this in some subset of cases.
-   This restriction is straightforward to work around by replacing the final
    value match with a `default` or `_`.

## Future work

### Or patterns

We could provide "or patterns", allowing matching of one pattern or another with
the same handler:

```
match (x) {
  case (m: i32, 0) | (0, m: i32) => { return m; }
}
```

### Matching classes by dynamic type

We could provide a way to match polymorphic class objects based on their dynamic
type. This might be the default when matching a polymorphic class, or might
require opt-in. The behavior in this proposal is that only the static type of
the operand is considered.

For example, we could default to matching the static type, and allow a `dyn`
_pattern_ syntax for matching a pointer to a polymorphic class type, meaning
that we match the dynamic type rather than the static type of the pointer:

```
abstract class Base { virtual fn F[me: Self](); }
class Derived1 extends Base {}
class Derived2 extends Base {}

fn PrintType(b: Base*) {
  match (b) {
    // `case d1: Derived*` would be invalid here,
    // because it could never match.
    case dyn d1: Derived1* => { Print("Derived1"); }
    case dyn d2: Derived2* => { Print("Derived2"); }
    default => { Print("Unknown derived class"); }
  }
}

fn PrintTemplateType[template T:! Type](p: T*) {
  match (p) {
    // OK, dispatch is based on the static type.
    case b: Base* => { Print("Base"); }
    case d1: Derived1* => { Print("Derived1"); }
    case d2: Derived2* => { Print("Derived2"); }
    default => { Print("Unknown class"); }
  }
}
```

However, at this time we do not have a design for a checked down-cast, so it's
not clear how this matching operation would fit into the design of classes,
either syntactically or semantically.

### User-defined pattern matching

We plan to provide a mechanism for allowing a user-defined type to specify how
it can be matched by patterns. See [proposal #157](/proposals/p0157.md) for
details.

### Matching classes with struct patterns

We could allow a class to be matched by a struct pattern that matches its
fields. This would make sense especially for data classes, and would be
consistent with the behavior of `==` in the case where a struct is implicitly
convertible to the class type. However, without a design for user-defined
pattern matching and matching on dynamic type, there is a significant risk that
this would conflict with the rules there, so it is deferred for now.

### Type deduction

This proposal does not cover type deduction, instead considering it to be a
separate topic from pattern matching syntax, even though the semantic behavior
of the two may be quite similar or identical.

We will need a proposal to explore type deduction and describe its functioning.
