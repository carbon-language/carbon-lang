# Pattern matching syntax and semantics

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/2188)

<!-- toc -->

## Table of contents

-   [TODO: Initial proposal setup](#todo-initial-proposal-setup)
-   [Abstract](#abstract)
-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Details](#details)
-   [Rationale](#rationale)
-   [Alternatives considered](#alternatives-considered)

<!-- tocstop -->

## Abstract

This paper proposes concrete syntax and semantic choices for Carbon patterns.

## Problem

Carbon uses patterns wherever a value should be given a name, decomposed, or
matched against: in function parameters, variable declarations, `match`
statement `case`s, `for` statement loop variables, and so on. Simplified forms
of patterns, required to be just a simple name binding, appear in additional
contexts, such as fields in classes and implicit parameter lists. While we have
syntax specified for some of these constructs, we do not have an approved
proposal describing the syntax or semantics of patterns.

## Background

See [pattern matching](https://en.wikipedia.org/wiki/Pattern_matching) on
wikipedia for a broad overview of the subject.

We refer to the value being matched by a pattern as the _scrutinee_.

## Proposal

Patterns in Carbon are a generalization of the expression grammar. Compared to
expressions, patterns add:

-   Bindings, of the form `name: type`, which give a name for the scrutinee.
-   `var` _pattern_, which requests mutable storage be provided for the
    scrutinee.
-   Additional syntax to make matching against structs more convenient.

## Details

### Expressions versus proper patterns

A pattern that contains within it any pattern-specific syntax, such as a
binding, is a _proper pattern_. Any other pattern must necessarily be an
expression. Many expression forms, such as arbitrary function calls, are not
permitted as proper patterns, so cannot contain bindings.

-   _pattern_ ::= _proper-pattern_

```
fn F(n: i32) -> i32 { return n; }

match (F(42)) {
  // ❌ Error: binding can't appear in a function call.
  case (F(n: i32)) =>
```

### Expression patterns

An expression is a pattern.

-   _pattern_ ::= _expression_

The pattern is compared with the expression using the `==` operator: _pattern_ `==` _scrutinee_.

```
fn F(n: i32) {
  match (n) {
    // ✅ Results in an `n == 5` comparison.
    // OK despite `n` and `5` having different types.
    case 5 =>
```

### Bindings

A name binding is a pattern.

-   _binding-pattern_ ::= `unused`? _identifier_ `:` _expression_
-   _binding-pattern_ ::= `unused`? _identifier_ `:` _proper-pattern_
-   _proper-pattern_ ::= _binding-pattern_

In the first form, the type of the _identifier_ is specified by the
_expression_. In the second form, the _proper-pattern_ is matched against the
type of the scrutinee, and the result is the type of the _identifier_. In
either case, the scrutinee is implicitly converted to the type of the
_identifier_.

```
fn F(p: i32*) {
  match (p) {
    // ✅ Matches `(T:! Type)` against `i32*`.
    // `T` is bound to `i32`, `m` is bound to `p`, and the type of `m` is `i32*`.
    case m: (T:! Type)* =>
```

The `unused` keyword indicates that the binding is intended to not be used.

### Wildcard

A syntax like a binding but with `_` in place of an identifier can be used to
ignore part of a value.

-   _binding-pattern_ ::= `_` `:` _expression_
-   _binding-pattern_ ::= `_` `:` _proper-pattern_

The behavior is equivalent to that of an `unused` binding with a unique name.

```
fn F(n: i32) {
  match (n) {
    // ✅ Matches and discards the value of `n`.
    case _: i32 => {}
    // ❌ Error: unreachable.
    default => {}
  }
}
```

### Generic bindings

A `:!` can be used in place of `:` for a binding that is usable at compile time.

-   _generic-pattern_ ::= `unused`? `template`? _identifier_ `:!` _expression_
-   _generic-pattern_ ::= `template`? `_` `:!` _expression_
-   _proper-pattern_ ::= _generic-pattern_

Note that, unlike in a _binding-pattern_, the type of a generic binding cannot
be a pattern.

```
// ✅ `F` takes a generic type parameter `T` and a parameter `x` of type `T`.
fn F(T:! Type, x: T) {
  var v: T = x;
}
```

The `template` keyword indicates the binding is introducing a template
parameter, so name lookups into the parameter should be deferred until its
value is known.

### `auto`

The pattern `auto` is shorthand for `_:! Type`.

-   _proper-pattern_ ::= `auto`

```
fn F(n: i32) {
  var v: auto = SomeComplicatedExpression(n);
}
```

### `var`

A `var` prefix indicates that a pattern provides mutable storage for the
scrutinee.

-   _proper-pattern_ ::= `var` _proper-pattern_

A `var` pattern matches when its nested pattern matches. The type of the
storage is the resolved type of the nested _pattern_. Any bindings within the
nested pattern refer to portions of the corresponding storage rather than to
the scrutinee, somewhat as if the mutable storage is first initialized from the
scrutinee and then the nested pattern is matched against the mutable storage,
but the variable is not actually initialized unless the complete pattern
matches.

```
fn F(p: i32*);
fn G() {
  match ((1, 2)) {
    // `n` is a mutable `i32`.
    case (var n: i32, 1) => { F(&n); }
    // `n` and `m` are the elements of a mutable `(i32, i32)`.
    case var (n: i32, m: i32) => { F(if n then &n else &m); }
  }
}
```

A `var` pattern cannot be nested within another `var` pattern. The declaration
syntax `var` _pattern_ `=` _expresson_ `;` is equivalent to `let` `var`
_pattern_ `=` _expression_ `;`.

### Tuple patterns

A tuple of patterns can be used as a pattern.

-   _tuple-pattern_ ::= `(` [_expression_ `,`]\* _proper-pattern_ [`,` _pattern_]\* `)`
-   _proper-pattern_ ::= _tuple-pattern_

A tuple pattern is matched left-to-right. The scrutinee is required to be of
tuple type.

Note that a tuple pattern must contain at least one _proper-pattern_.
Otherwise, it is a tuple-valued expression. However, a tuple pattern and a
corresponding tuple-valued expression are matched in the same way because `==`
for a tuple compares fields left-to-right.

### Struct patterns

A struct can be matched with a struct pattern.

-   _proper-pattern_ ::= `{` [_field-init_ `,`]\* _proper-field-pattern_ [`,`
    _field-pattern_]\* [, `...`]? `}`
-   _field-init_ ::= _designator_ `=` _expression_
-   _proper-field-pattern_ ::= _designator_ `=` _proper-pattern_
-   _proper-field-pattern_ ::= _binding-pattern_
-   _field-pattern_ ::= _field-init_
-   _field-pattern_ ::= _proper-field-pattern_

A struct pattern resembles a struct literal, with at least one field
initialized with a proper pattern:

```
match ({.a = 1, .b = 2}) {
  case {.b = n: i32, .a = m: i32} =>
```

The scrutinee is required to be of struct type, and to have the same set of
field names as the pattern. The pattern is matched left-to-right, meaning that
matching is performed in the field order specified in the pattern, not in the
field order of the scrutinee. This is consistent with the behavior of matching
against a tuple-valued expression, where the left operand determines the order
in which `==` comparisons are performed.

In the case where a field will be bound to an identifier with the same name, a
shorthand syntax is available: `a: T` is synonymous with `.a = a: T`.

```
match ({.a = 1, .b = 2}) {
  case {a: i32, b: i32} => { return a + b; }
```

If some fields should be ignored when matching, a trailing `, ...` can be added
to specify this:

```
match ({.a = 1, .b = 2}) {
  case {.a = 1, ...} => { return 1; }
  case {b: i32, ...} => { return b; }
```

This is valid even if all fields are actually named in the pattern.

### Choice patterns

A choice pattern is used to match one alternative of a choice type.

_proper-pattern_ ::= _callee-expression_ _tuple-pattern_
_proper-pattern_ ::= _designator_ _tuple-pattern_?

Here, _callee-expression_ is syntactically an expression that is valid as the
callee in a function call expression, and a choice pattern is syntactically a
function call expression whose argument list contains at least one
_proper-pattern_.

If a _callee-expression_ is provided, it is required to name a choice type
alternative that has a parameter list, and the scrutinee is implicitly
converted to that choice type. Otherwise, the scrutinee is required to be of
some choice type, and the designator is looked up in that type and is required
to name an alternative with a parameter list if and only if a _tuple-pattern_
is specified.

The pattern matches if the active alternative in the scrutinee is the specified
alternative, and the arguments of the alternative match the given tuple
pattern (if any).

```
choice Optional(T:! Type) {
  None,
  Some(T)
}

match (Optional(i32).None) {
  // ✅ `.None` resolved to `Optional(i32).None`.
  case .None => {}
  // ✅ `.Some` resolved to `Optional(i32).Some`.
  case .Some(n: i32) => { Print("{0}", n); }
  // ❌ Error, no such alternative exists.
  case .Other => {}
}

class X {
  external impl as ImplicitAs(Optional(i32));
}

match ({} as X) {
  // ✅ OK, but expression pattern.
  case Optional(i32).None => {}
  // ✅ OK, implicitly converts to `Optional(i32)`.
  case Optional(i32).Some(n: i32) => { Print("{0}", n); }
}
```

Note that a pattern of the form `Optional(T).None` is an expression pattern and
is compared using `==`.

### Templates

If the type of the scrutinee of a pattern is either a template parameter or is
an associated type that depends on a template parameter, any checking of the
type of the scrutinee against the type of the pattern is deferred until the
template parameter's value is known. During instantiation, patterns that are
not meaningful due to a type error are instead treated as not matching. This
includes cases where an `==` fails because of a missing `EqWith`
implementation.

```
fn TypeName[template T:! Type](x: T) -> String {
  match (x) {
    // ✅ OK, the type of `x` is a template parameter.
    case _: i32 => { return "int"; }
    case _: bool => { return "bool"; }
    case _: auto* => { return "pointer"; }
    default => { return "unknown"; }
  }
}
```

```
fn NeverWorks[template T:! Type](triple: (T, T, T)) {
  match (triple) {
    // ❌ Error: type mismatch matching struct against (T, T, T)
    case {.a: i32, .b: i32} =>
}
```

## Rationale

-   [Software and language evolution](/docs/project/goals.md#software-and-language-evolution)
    -   The `, ...` syntax for struct patterns enables a style where adding a
        struct member is not a breaking change.
-   [Code that is easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write)
    -   Pattern syntax makes it easier to match complex values.
    -   Modeling pattern syntax after expressions eases the burden of learning
        a new sub-language for pattern-matching: patterns are an extension of
        expressions, and expressions are a special case of patterns.
-   [Interoperability with and migration from existing C++ code](/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code)
    -   The rules for matching a templated value can be used to replace `if
        constexpr` in many cases.

## Alternatives considered

### Struct pattern syntax

We could omit the `, ...` syntax. This would simplify struct patterns, but at
the cost of removing a feature that can be useful for reducing verbosity and
making library evolution easier.

We could always allow a struct pattern to match a struct with more fields,
without requiring a `, ...` suffix. This would aid evolution by reducing the
cases where adding a field to a struct can be a breaking change, but such cases
would still exist. Further, this would make matches against a struct-valued
expression inconsistent with matches against a struct pattern.

We could remove the `{field: type}` shorthand and require `{.field = field:
type}`. This may avoid encouraging reusing the field name even when it is not
appropriate, and would remove some syntactic sugar that's not formally
necessary. However, we expect this to be a common case whose ergonomics are
important.

We could use a different syntax for `{field: type}` that is less divergent from
other struct syntaxes:

-   `{.field: type}` seems like a contender, but doesn't work because that is
    already recognized as a tuple type literal. Also, the use of normal binding
    syntax means that every locally-introduced name is always introduced by
    `name: type` where `name` is not preceded by `.`.
-   `{.=field: type}` might be a reasonable mnemonic shorthand for `{.field =
    field: type}`, but looks a little surprising. This is probably the best
    choice if concerns are found with `{field: type}` syntax.

## Future work

### Or patterns

We could provide "or patterns", allowing matching of one pattern or another
with the same handler:

```
match (x) {
  case (m: i32, 0) | (0, m: i32) => { return m; }
}
```

### Guards

We could provide guards for patterns, allowing a pattern to match only if some
predicate involving the bindings holds:

```
match (x) {
  case (m: i32, n: i32) if m + n < 5 => { return m - n; }
}
```

### User-defined pattern matching

We could provide some mechanism for allowing a user-defined type to specify how
it can be matched by patterns.

### Matching classes with struct patterns

We could allow a class to be matched by a struct patttern that matches its
fields. This would make sense especially for data classes, and would be
consistent with the behavior of `==` in the case where a struct is implicitly
convertible to the class type. However, without a design for user-defined
pattern matching, there is a significant risk that this would conflict with the
rules there, so it is deferred for now.
