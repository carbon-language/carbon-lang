# Pattern matching syntax and semantics

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/2188)

<!-- toc -->

## Table of contents

-   [Abstract](#abstract)
-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Details](#details)
    -   [Expressions versus proper patterns](#expressions-versus-proper-patterns)
    -   [Expression patterns](#expression-patterns)
    -   [Bindings](#bindings)
        -   [Name bindings](#name-bindings)
        -   [Wildcard](#wildcard)
        -   [Generic bindings](#generic-bindings)
        -   [`auto` and type deduction](#auto-and-type-deduction)
    -   [`var`](#var)
    -   [Tuple patterns](#tuple-patterns)
    -   [Struct patterns](#struct-patterns)
    -   [Alternative patterns](#alternative-patterns)
    -   [Templates](#templates)
-   [Rationale](#rationale)
-   [Alternatives considered](#alternatives-considered)
    -   [Struct pattern syntax](#struct-pattern-syntax)
    -   [Type pattern matching](#type-pattern-matching)
    -   [Introducer syntax for expression patterns](#introducer-syntax-for-expression-patterns)
-   [Future work](#future-work)
    -   [Or patterns](#or-patterns)
    -   [Guards](#guards)
    -   [Matching classes by dynamic type](#matching-classes-by-dynamic-type)
    -   [User-defined pattern matching](#user-defined-pattern-matching)
    -   [Matching classes with struct patterns](#matching-classes-with-struct-patterns)
    -   [Type deduction](#type-deduction)

<!-- tocstop -->

## Abstract

This paper proposes concrete syntax and semantic choices for Carbon patterns.

## Problem

Carbon uses patterns wherever a value should be given a name, decomposed, or
matched against: in function parameters, variable declarations, `match`
statement `case`s, `for` statement loop variables, and so on. Simplified forms
of patterns, required to be just a simple name binding, appear in additional
contexts, such as fields in classes and implicit parameter lists. While we have
syntax specified for some of these constructs, we do not have an approved
proposal describing the syntax or semantics of patterns.

## Background

See [pattern matching](https://en.wikipedia.org/wiki/Pattern_matching) on
wikipedia for a broad overview of the subject.

We refer to the value being matched by a pattern as the _scrutinee_.

## Proposal

Patterns in Carbon are a generalization of the expression grammar. Compared to
expressions, patterns add:

-   Bindings, of the form `name: type`, which give a name for the scrutinee.
-   `var` _pattern_, which requests mutable storage be provided for the
    scrutinee.
-   Additional syntax to make matching against structs more convenient.

## Details

### Expressions versus proper patterns

Expressions are patterns, as described below. A pattern that is not an
expression, because it contains pattern-specific syntax such as a binding, is a
_proper pattern_. Many expression forms, such as arbitrary function calls, are
not permitted as proper patterns, so cannot contain bindings.

-   _pattern_ ::= _proper-pattern_

```
fn F(n: i32) -> i32 { return n; }

match (F(42)) {
  // ❌ Error: binding can't appear in a function call.
  case (F(n: i32)) => {}
}
```

### Expression patterns

An expression is a pattern.

-   _pattern_ ::= _expression_

The pattern is compared with the expression using the `==` operator: _pattern_
`==` _scrutinee_.

```
fn F(n: i32) {
  match (n) {
    // ✅ Results in an `n == 5` comparison.
    // OK despite `n` and `5` having different types.
    case 5 => {}
  }
}
```

Any `==` operations performed by a pattern match occur in lexical order, but for
repeated matches against the same _pattern_, later comparisons may be skipped by
reusing the result from an earlier comparison:

```
class ChattyIntMatcher {
  external impl as EqWith(i32) {
    fn Eq[me: ChattyIntMatcher](other: i32) {
      Print("Matching {0}", other);
      return other == 1;
    }
  }
}

fn F() {
  // Prints `Matching 1` then `Matching 2`,
  // may or may not then print `Matching 1` again.
  match ((1, 2)) {
    case ({} as ChattyIntMatcher, 0) => {}
    case (1, {} as ChattyIntMatcher) => {}
    case ({} as ChattyIntMatcher, 2) => {}
  }
}
```

### Bindings

#### Name bindings

A name binding is a pattern.

-   _binding-pattern_ ::= `unused`? _identifier_ `:` _expression_
-   _proper-pattern_ ::= _binding-pattern_

The type of the _identifier_ is specified by the _expression_. The scrutinee is
implicitly converted to that type.

```
fn F() -> i32 {
  match (5) (
    // ✅ `5` is implicitly converted to `i32`.
    // Returns `5 as i32`.
    case n: i32 => { return n; }
  }
}
```

As specified in [#2022](p2022.md#the-behavior-of-unused-name-bindings), the
`unused` keyword indicates that the binding is intended to not be used.

#### Wildcard

A syntax like a binding but with `_` in place of an identifier can be used to
ignore part of a value.

-   _binding-pattern_ ::= `_` `:` _expression_

See [#2022](p2022.md) for details.

The behavior is similar to that of an `unused` binding with a unique name.

```
fn F(n: i32) {
  match (n) {
    // ✅ Matches and discards the value of `n`.
    case _: i32 => {}
    // ❌ Error: unreachable.
    default => {}
  }
}
```

As specified in [#1084](p1084.md), function redeclarations may replace named
bindings with wildcards but may not use different names.

```
fn G(n: i32);
fn H(n: i32);
fn J(n: i32);

// ✅ Does not use `n`.
fn G(_: i32) {}
// ❌ Error: name of parameter does not match declaration.
fn H(m: i32) {}
// ✅ Does not use `n`.
fn J(unused n: i32);
```

#### Generic bindings

A `:!` can be used in place of `:` for a binding that is usable at compile time.

-   _generic-pattern_ ::= `unused`? `template`? _identifier_ `:!` _expression_
-   _generic-pattern_ ::= `template`? `_` `:!` _expression_
-   _proper-pattern_ ::= _generic-pattern_

```
// ✅ `F` takes a generic type parameter `T` and a parameter `x` of type `T`.
fn F(T:! Type, x: T) {
  var v: T = x;
}
```

The `template` keyword indicates the binding is introducing a template
parameter, so name lookups into the parameter should be deferred until its value
is known.

#### `auto` and type deduction

The `auto` keyword is a placeholder for a unique deduced type.

-   _expression_ ::= `auto`

```
fn F(n: i32) {
  var v: auto = SomeComplicatedExpression(n);
  // Equivalent to:
  var w: T = SomeComplicatedExpression(n);
  // ... where `T` is the type of the initializer.
}
```

The `auto` keyword is only permitted in specific contexts. Currently these are:

-   As the return type of a function.
-   As the type of a binding.

It is anticipated that `auto` may be permitted in more contexts in the future,
for example as a generic argument in a parameterized type that appears in a
context where `auto` is allowed, such as `Vector(auto)` or `auto*`.

When the type of a binding requires type deduction, the type is deduced against
the type of the scrutinee and deduced values are substituted back into the type
before pattern matching is performed.

```
fn G[T:! Type](p: T*);
class X { external impl as ImplicitAs(i32*); }
// ✅ Deduces `T = i32` then implicitly and
// trivially converts `p` to `i32*`.
fn H1(p: i32*) { G(p); }
// ❌ Error, can't deduce `T*` from `X`.
fn H2(p: X) { G(p); }
```

The above is only an illustration; the behavior of type deduction is not
specified in this proposal.

### `var`

A `var` prefix indicates that a pattern provides mutable storage for the
scrutinee.

-   _proper-pattern_ ::= `var` _proper-pattern_

A `var` pattern matches when its nested pattern matches. The type of the storage
is the resolved type of the nested _pattern_. Any bindings within the nested
pattern refer to portions of the corresponding storage rather than to the
scrutinee.

```
fn F(p: i32*);
fn G() {
  match ((1, 2)) {
    // `n` is a mutable `i32`.
    case (var n: i32, 1) => { F(&n); }
    // `n` and `m` are the elements of a mutable `(i32, i32)`.
    case var (n: i32, m: i32) => { F(if n then &n else &m); }
  }
}
```

Pattern matching precedes the initialization of the storage for any `var`
patterns. An introduced variable is only initialized if the complete pattern
matches.

```
class X {
  destructor { Print("Destroyed!"); }
}
fn F(x: X) {
  match ((x, 1 as i32)) {
    case (var y: X, 0) => {}
    case (var z: X, 1) => {}
    // Prints "Destroyed!" only once, when `z` is destroyed.
  }
}
```

A `var` pattern cannot be nested within another `var` pattern. The declaration
syntax `var` _pattern_ `=` _expresson_ `;` is equivalent to `let` `var`
_pattern_ `=` _expression_ `;`.

### Tuple patterns

A tuple of patterns can be used as a pattern.

-   _tuple-pattern_ ::= `(` [_expression_ `,`]\* _proper-pattern_ [`,`
    _pattern_]\* `,`? `)`
-   _proper-pattern_ ::= _tuple-pattern_

A _tuple-pattern_ containing no commas is treated as grouping parens: the
contained _proper-pattern_ is matched directly against the scrutinee. Otherwise,
the behavior is as follows.

A tuple pattern is matched left-to-right. The scrutinee is required to be of
tuple type.

Note that a tuple pattern must contain at least one _proper-pattern_. Otherwise,
it is a tuple-valued expression. However, a tuple pattern and a corresponding
tuple-valued expression are matched in the same way because `==` for a tuple
compares fields left-to-right.

### Struct patterns

A struct can be matched with a struct pattern.

-   _proper-pattern_ ::= `{` [_field-init_ `,`]\* _proper-field-pattern_ [`,`
    _field-pattern_]\* `}`
-   _proper-pattern_ ::= `{` [_field-pattern_ `,`]+ `_` `}`
-   _field-init_ ::= _designator_ `=` _expression_
-   _proper-field-pattern_ ::= _designator_ `=` _proper-pattern_
-   _proper-field-pattern_ ::= _binding-pattern_
-   _field-pattern_ ::= _field-init_
-   _field-pattern_ ::= _proper-field-pattern_

A struct pattern resembles a struct literal, with at least one field initialized
with a proper pattern:

```
match ({.a = 1, .b = 2}) {
  // Struct literal as an expression pattern.
  case {.b = 2, .a = 1} => {}
  // Struct pattern.
  case {.b = n: i32, .a = m: i32} => {}
}
```

The scrutinee is required to be of struct type, and to have the same set of
field names as the pattern. The pattern is matched left-to-right, meaning that
matching is performed in the field order specified in the pattern, not in the
field order of the scrutinee. This is consistent with the behavior of matching
against a struct-valued expression, where the expression pattern becomes the
left operand of the `==` and so determines the order in which `==` comparisons
for fields are performed.

In the case where a field will be bound to an identifier with the same name, a
shorthand syntax is available: `a: T` is synonymous with `.a = a: T`.

```
match ({.a = 1, .b = 2}) {
  case {a: i32, b: i32} => { return a + b; }
}
```

If some fields should be ignored when matching, a trailing `, _` can be added to
specify this:

```
match ({.a = 1, .b = 2}) {
  case {.a = 1, _} => { return 1; }
  case {b: i32, _} => { return b; }
}
```

This is valid even if all fields are actually named in the pattern.

### Alternative patterns

An alternative pattern is used to match one alternative of a choice type.

-   _proper-pattern_ ::= _callee-expression_ _tuple-pattern_
-   _proper-pattern_ ::= _designator_ _tuple-pattern_?

Here, _callee-expression_ is syntactically an expression that is valid as the
callee in a function call expression, and an alternative pattern is
syntactically a function call expression whose argument list contains at least
one _proper-pattern_.

If a _callee-expression_ is provided, it is required to name a choice type
alternative that has a parameter list, and the scrutinee is implicitly converted
to that choice type. Otherwise, the scrutinee is required to be of some choice
type, and the designator is looked up in that type and is required to name an
alternative with a parameter list if and only if a _tuple-pattern_ is specified.

The pattern matches if the active alternative in the scrutinee is the specified
alternative, and the arguments of the alternative match the given tuple pattern
(if any).

```
choice Optional(T:! Type) {
  None,
  Some(T)
}

match (Optional(i32).None) {
  // ✅ `.None` resolved to `Optional(i32).None`.
  case .None => {}
  // ✅ `.Some` resolved to `Optional(i32).Some`.
  case .Some(n: i32) => { Print("{0}", n); }
  // ❌ Error, no such alternative exists.
  case .Other => {}
}

class X {
  external impl as ImplicitAs(Optional(i32));
}

match ({} as X) {
  // ✅ OK, but expression pattern.
  case Optional(i32).None => {}
  // ✅ OK, implicitly converts to `Optional(i32)`.
  case Optional(i32).Some(n: i32) => { Print("{0}", n); }
}
```

Note that a pattern of the form `Optional(T).None` is an expression pattern and
is compared using `==`.

### Templates

If the type of the scrutinee of a pattern is either a template parameter or is
an associated type that depends on a template parameter, any checking of the
type of the scrutinee against the type of the pattern is deferred until the
template parameter's value is known. During instantiation, patterns that are not
meaningful due to a type error are instead treated as not matching. This
includes cases where an `==` fails because of a missing `EqWith` implementation.

```
fn TypeName[template T:! Type](x: T) -> String {
  match (x) {
    // ✅ OK, the type of `x` is a template parameter.
    case _: i32 => { return "int"; }
    case _: bool => { return "bool"; }
    case _: auto* => { return "pointer"; }
    default => { return "unknown"; }
  }
}
```

```
fn NeverWorks[template T:! Type](triple: (T, T, T)) {
  match (triple) {
    // ❌ Error: type mismatch matching struct against (T, T, T)
    case {.a: i32, .b: i32} => {}
  }
}
```

## Rationale

-   [Software and language evolution](/docs/project/goals.md#software-and-language-evolution)
    -   The `, _` syntax for struct patterns enables a style where adding a
        struct member is not a breaking change.
-   [Code that is easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write)
    -   Pattern syntax makes it easier to match complex values.
    -   Modeling pattern syntax after expressions eases the burden of learning a
        new sub-language for pattern-matching: patterns are an extension of
        expressions, and expressions are a special case of patterns.
-   [Interoperability with and migration from existing C++ code](/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code)
    -   The rules for matching a templated value can be used to replace
        `if constexpr` in many cases.

## Alternatives considered

### Struct pattern syntax

We could omit the `, _` syntax. This would simplify struct patterns, but at the
cost of removing a feature that can be useful for reducing verbosity and making
library evolution easier.

We could always allow a struct pattern to match a struct with more fields,
without requiring a `, _` suffix. This would aid evolution by reducing the cases
where adding a field to a struct can be a breaking change, but such cases would
still exist. Further, this would make matches against a struct-valued expression
inconsistent with matches against a struct pattern.

We could use a different syntax instead of `, _`. Other options that were
explicitly considered:

-   `, ...` seems visually evocative of "and more stuff", but risks conflicting
    with variadic syntax or at least being confusing when used in a variadic
    context, given that variadics are expected to claim `...` for pack
    expansion.
-   `, ._` suggests matching a field without specifying a name, but might create
    an impression of matching just one field, and three low punctuation
    characters in a row seems to be pushing the limits of readability.

On balance, `, _` harmonizes well with the use of `_` to introduce a wildcard,
without being too visually confusing given that the other use of `_` has a
following `:`.

We could remove the `{field: type}` shorthand and require
`{.field = field: type}`. This may avoid encouraging reusing the field name even
when it is not appropriate, and would remove some syntactic sugar that's not
formally necessary. However, we expect this to be a common case whose ergonomics
are important.

We could use a different syntax for `{field: type}` that is less divergent from
other struct syntaxes:

-   `{.field: type}` seems like a contender, but doesn't work because that is
    already recognized as a struct type literal. Also, the use of normal binding
    syntax means that every locally-introduced name is always introduced by
    `name: type` where `name` is not preceded by `.`.
-   `{.=field: type}` might be a reasonable mnemonic shorthand for
    `{.field = field: type}`, but looks a little surprising. This is probably
    the best choice if concerns are found with `{field: type}` syntax.

### Type pattern matching

We could treat type deduction as a form of pattern matching. For example, we
could allow

```
fn F(a: Vector(T:! Type)) -> T { return a[0]; }
fn G() -> i32 {
  let v: Vector(i32) = (1, 2, 3);
  // Deduces `T = i32`.
  return F(v);
}
```

where the value of `T` is determined by pattern-matching `Vector(T:! Type)`
against the supplied type `Vector(i32)` of `v`. And symmetrically:

```
fn H[m: i32, n: i32](k: i32, (m, n)) { return m + n; }
fn I() {
  // Deduces `m = 2`, `n = 3`.
  H(1, (2, 3));
}
```

This would ensure consistency between pattern matching and deduction,
potentially reducing the number of rules that Carbon developers need to learn.

We find that attempting to unify pattern-matching and type deduction in this way
harms readability. Having distinct syntax for type-level matching and
value-level matching helps guide the reader to the correct interpretation, even
though the underlying matching process is expected to be similar or identical.
As a result, we keep type deduction syntax and pattern matching syntax separate
for now:

-   In pattern matching, bindings and wildcards are introduced by nested `:` /
    `:!` patterns, and the right-hand side of a binding pattern is never a
    proper pattern.
-   In type deduction, deduced values are specified separately and an expression
    written in terms of those bindings describes the type.

### Introducer syntax for expression patterns

We could have some separate introducer syntax to distinguish expression patterns
from other kinds of patterns:

```
match ((a, b)) {
  case is (1, 2) => {}
  case (is 3, n: i32) => {}
  case (m: i32, is 4) => {}
}
```

This would reduce the chance of confusion in cases where an expression and a
similar-looking pattern are treated differently:

```
class TupleLike {
  external impl as (i32, i32);
}
fn MatchTupleLike(t: TupleLike) {
  match (t) {
    // ✅ OK, expression pattern;
    // `t` implicitly converted to `(i32, i32)` by
    // built-in `impl EqWith` for tuples.
    case (1, 2) => {}
    // ❌ Error, `t` is not a tuple.
    case (n: i32, 3) => {}
  }
}
```

However, this would also introduce additional ceremony for the common case where
part of a pattern is a specific value. This could be mitigated by permitting
certain kinds of value as patterns without an introducer, such as numeric
literals and `true` and `false`, at the cost of introducing more complexity and
more confusion over which cases require `is` and which do not.

We have also not identified a good choice for the introducer syntax, should we
pursue this direction. `is` is not an ideal choice, because elsewhere in Carbon
syntax, it is a relation between a value and its type, so `is T` may be misread
as matching values whose type is `T`. `==` _expression_ has been suggested, but
that would imply the opposite operand order of that in this proposal --
_scrutinee_ `==` _expression_ rather than _expression_ `==` _scrutinee_ -- which
would compare struct fields in a surprising order that diverges from the order
of comparison for a struct pattern.

## Future work

### Or patterns

We could provide "or patterns", allowing matching of one pattern or another with
the same handler:

```
match (x) {
  case (m: i32, 0) | (0, m: i32) => { return m; }
}
```

### Guards

We could provide guards for patterns, allowing a pattern to match only if some
predicate involving the bindings holds:

```
match (x) {
  case (m: i32, n: i32) if m + n < 5 => { return m - n; }
}
```

### Matching classes by dynamic type

We could provide a way to match polymorphic class objects based on their dynamic
type. This might be the default when matching a polymorphic class, or might
require opt-in.

### User-defined pattern matching

We plan to provide a mechanism for allowing a user-defined type to specify how
it can be matched by patterns. See [proposal #157](p0157.md) for details.

### Matching classes with struct patterns

We could allow a class to be matched by a struct patttern that matches its
fields. This would make sense especially for data classes, and would be
consistent with the behavior of `==` in the case where a struct is implicitly
convertible to the class type. However, without a design for user-defined
pattern matching and matching on dynamic type, there is a significant risk that
this would conflict with the rules there, so it is deferred for now.

### Type deduction

This proposal does not cover type deduction, instead considering it to be a
separate topic from pattern matching syntax, even though the semantic behavior
of the two may be quite similar or identical.

We will need a proposal to explore type deduction and describe its functioning.
