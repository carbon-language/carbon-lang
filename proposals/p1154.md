# Destructors

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/1154)

<!-- toc -->

## Table of contents

-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Rationale based on Carbon's goals](#rationale-based-on-carbons-goals)
-   [Alternatives considered](#alternatives-considered)
    -   [Types implement destructor interface](#types-implement-destructor-interface)
    -   [Don't distinguish safe and unsafe delete operations](#dont-distinguish-safe-and-unsafe-delete-operations)

<!-- tocstop -->

## Problem

C++ code supports defining custom
[destructors](<https://en.wikipedia.org/wiki/Destructor_(computer_programming)>)
for user-defined types, and C++ developers will expect to use that tool. Carbon
should support destructors, but should make some changes to protect against
deleting a value with a derived type through a pointer to the base class when
the base class destructor is not virtual. We also need some mechanism to allow
generic code to identify types that are safe to destroy, or have trivial
destructors and don't need to be explicitly destroyed.

## Background

Destructors may only be customized for nominal classes, which were introduced in
proposal [#722](https://github.com/carbon-language/carbon-lang/pull/722).
Destructors interact with inheritance, which was introduced in proposal
[#777](https://github.com/carbon-language/carbon-lang/pull/777).

Destructors were discussed in open discussion on these dates:

-   [2022-03-24](https://docs.google.com/document/d/1cRrhRrmaUf2hVi2lFcHsYo2j0jI6t9RGZoYjWhRxp14/edit?resourcekey=0-xWHBEZ8zIqnJiB4yfBSLfA#heading=h.w4zgqvarhnbn)
-   [2021-10-18](https://docs.google.com/document/d/105GsfmxOwcZ_iHkCXFnALB7e-_R3IgMpGKfeT84h1mc/edit?resourcekey=0-h3uVHObsJwChVg1MdaWfKQ#heading=h.uz59mgk5ezch)
-   [2021-08-30](https://docs.google.com/document/d/105GsfmxOwcZ_iHkCXFnALB7e-_R3IgMpGKfeT84h1mc/edit?resourcekey=0-h3uVHObsJwChVg1MdaWfKQ#heading=h.4dobu6v1cdam)

["Extensible classes" Google doc](https://docs.google.com/document/d/1gbQJN_IMJBnquOUUd2orbHLlAIqZ4pL0Vt7h34DkQjg/edit?resourcekey=0-0lkEvh0umUU206ASFlWc7A#)
considered options for making deleting extensible classes safer.

## Proposal

This proposal adds two sections to the design:

-   ["Destructors"](/docs/design/classes.md#destructors) to the
    [classes design](/docs/design/classes.md), and
-   ["Destructor constraint"](/docs/design/generics/details.md#destructor-constraints)
    to the [detailed generics design](/docs/design/generics/details.md).

## Rationale based on Carbon's goals

TODO: How does this proposal effectively advance Carbon's goals? Rather than
re-stating the full motivation, this should connect that motivation back to
Carbon's stated goals for the project or language. This may evolve during
review. Use links to appropriate goals, for example:

-   [Community and culture](/docs/project/goals.md#community-and-culture)
-   [Language tools and ecosystem](/docs/project/goals.md#language-tools-and-ecosystem)
-   [Performance-critical software](/docs/project/goals.md#performance-critical-software)
-   [Software and language evolution](/docs/project/goals.md#software-and-language-evolution)
-   [Code that is easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write)
-   [Practical safety and testing mechanisms](/docs/project/goals.md#practical-safety-and-testing-mechanisms)
-   [Fast and scalable development](/docs/project/goals.md#fast-and-scalable-development)
-   [Modern OS platforms, hardware architectures, and environments](/docs/project/goals.md#modern-os-platforms-hardware-architectures-and-environments)
-   [Interoperability with and migration from existing C++ code](/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code)

## Alternatives considered

TODO: What alternative solutions have you considered?

### Types implement destructor interface

We considered letting developers implement a destructor interface, as is done in
[Rust](https://doc.rust-lang.org/std/ops/trait.Drop.html). This would be more
consistent with the other customization points for classes, but had some
downsides that we ultimately decided were too large:

-   Destructors are relatively common, and implementing an interface involves
    more boilerplate than writing a destructor in C++, so we wanted a concise
    syntax.
-   Destructors need access to the private members of a class, so generally
    would have to be part of the class.
-   We didn't have any use cases where an author of a type used as a type
    argument to a class should be able to override the destructor for the class,
    so users would have to mark destructors as `final` or risk surprises.
-   Abstract classes without virtual destructors may have code that should run
    when the type is destroyed, but don't implement any destructor
    type-of-types.
-   More generally, we wanted the compiler to enforce that the correct
    type-of-types were implemented.

### Don't distinguish safe and unsafe delete operations

We could, like C++, have a single operation that includes both the safe and
unsafe cases. We decided we would like to try the safer option to see if it is
viable or if it causes problems with interoperation with C++. We expect that
migrated C++ code can fall-back to using `UnsafeDelete` if using `Delete` is too
burdensome.
