# Destructors

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/1154)

<!-- toc -->

## Table of contents

-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Rationale based on Carbon's goals](#rationale-based-on-carbons-goals)
-   [Alternatives considered](#alternatives-considered)
    -   [Types implement destructor interface](#types-implement-destructor-interface)
    -   [Don't distinguish safe and unsafe delete operations](#dont-distinguish-safe-and-unsafe-delete-operations)
    -   [Don't allow unsafe delete](#dont-allow-unsafe-delete)
    -   [Prevent virtual function calls in destructors](#prevent-virtual-function-calls-in-destructors)
    -   [Allow destructors to specify a return type](#allow-destructors-to-specify-a-return-type)
    -   [Allow private destructors](#allow-private-destructors)
    -   [Allow final destructors](#allow-final-destructors)

<!-- tocstop -->

## Problem

C++ code supports defining custom
[destructors](<https://en.wikipedia.org/wiki/Destructor_(computer_programming)>)
for user-defined types, and C++ developers will expect to use that tool. Carbon
should support destructors, but should make some changes to protect against
deleting a value with a derived type through a pointer to the base class when
the base class destructor is not virtual. We also need some mechanism to allow
generic code to identify types that are safe to destroy, or have trivial
destructors and don't need to be explicitly destroyed.

## Background

Destructors may only be customized for nominal classes, which were introduced in
proposal [#722](https://github.com/carbon-language/carbon-lang/pull/722).
Destructors interact with inheritance, which was introduced in proposal
[#777](https://github.com/carbon-language/carbon-lang/pull/777).

Destructors were discussed in open discussion on these dates:

-   [2022-03-24](https://docs.google.com/document/d/1cRrhRrmaUf2hVi2lFcHsYo2j0jI6t9RGZoYjWhRxp14/edit?resourcekey=0-xWHBEZ8zIqnJiB4yfBSLfA#heading=h.w4zgqvarhnbn)
-   [2021-10-18](https://docs.google.com/document/d/105GsfmxOwcZ_iHkCXFnALB7e-_R3IgMpGKfeT84h1mc/edit?resourcekey=0-h3uVHObsJwChVg1MdaWfKQ#heading=h.uz59mgk5ezch)
-   [2021-10-04](https://docs.google.com/document/d/105GsfmxOwcZ_iHkCXFnALB7e-_R3IgMpGKfeT84h1mc/edit?resourcekey=0-h3uVHObsJwChVg1MdaWfKQ#heading=h.a0rffns9r10n)
    discussed not all types being destructible, and that some types are
    `TriviallyDestructible`
-   [2021-08-30](https://docs.google.com/document/d/105GsfmxOwcZ_iHkCXFnALB7e-_R3IgMpGKfeT84h1mc/edit?resourcekey=0-h3uVHObsJwChVg1MdaWfKQ#heading=h.4dobu6v1cdam)
-   [2021-07-12](https://docs.google.com/document/d/1QCdKQ33rki-kCDrxi8UHy3a36dtW0WdMqpUzluGSrz4/edit?resourcekey=0-bZmNUiueOiH_sysJNqnT9A#heading=h.40jlsrcgp8mr)

As part of
[proposal 777: Inheritance](https://github.com/carbon-language/carbon-lang/pull/777),
we decided to support extensible classes, that is non-abstract base classes,
[including with non-virtual destructors](p0777.md#no-extensible-objects-with-non-virtual-destructors).
["Extensible classes" Google doc](https://docs.google.com/document/d/1gbQJN_IMJBnquOUUd2orbHLlAIqZ4pL0Vt7h34DkQjg/edit?resourcekey=0-0lkEvh0umUU206ASFlWc7A#)
from that time considered options for making deleting extensible classes safer.

## Proposal

This proposal adds two sections to the design:

-   ["Destructors"](/docs/design/classes.md#destructors) to the
    [classes design](/docs/design/classes.md), and
-   ["Destructor constraint"](/docs/design/generics/details.md#destructor-constraints)
    to the [detailed generics design](/docs/design/generics/details.md).

## Rationale based on Carbon's goals

TODO: How does this proposal effectively advance Carbon's goals? Rather than
re-stating the full motivation, this should connect that motivation back to
Carbon's stated goals for the project or language. This may evolve during
review. Use links to appropriate goals, for example:

-   [Community and culture](/docs/project/goals.md#community-and-culture)
-   [Language tools and ecosystem](/docs/project/goals.md#language-tools-and-ecosystem)
-   [Performance-critical software](/docs/project/goals.md#performance-critical-software)
-   [Software and language evolution](/docs/project/goals.md#software-and-language-evolution)
-   [Code that is easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write)
-   [Practical safety and testing mechanisms](/docs/project/goals.md#practical-safety-and-testing-mechanisms)
-   [Fast and scalable development](/docs/project/goals.md#fast-and-scalable-development)
-   [Modern OS platforms, hardware architectures, and environments](/docs/project/goals.md#modern-os-platforms-hardware-architectures-and-environments)
-   [Interoperability with and migration from existing C++ code](/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code)

## Alternatives considered

TODO: What alternative solutions have you considered?

### Types implement destructor interface

We considered letting developers implement a destructor interface, as is done in
[Rust](https://doc.rust-lang.org/std/ops/trait.Drop.html). This would be more
consistent with the other customization points for classes, but had some
downsides that we ultimately decided were too large:

-   Destructors are relatively common, and implementing an interface involves
    more boilerplate than writing a destructor in C++, so we wanted a concise
    syntax.
-   Destructors need access to the private members of a class, so generally
    would have to be part of the class.
-   We didn't have any use cases where an author of a type used as a type
    argument to a class should be able to override the destructor for the class,
    so users would have to mark destructors as `final` or risk surprises.
-   Abstract classes without virtual destructors may have code that should run
    when the type is destroyed, but don't implement any destructor
    type-of-types.
-   More generally, we wanted the compiler to enforce that the correct
    type-of-types were implemented.

### Don't distinguish safe and unsafe delete operations

We could, like C++, have a single operation that includes both the safe and
unsafe cases. We decided we would like to try the safer option to see if it is
viable or if it causes problems with interoperation with C++. We expect that
migrated C++ code can fall-back to using `UnsafeDelete` if using `Delete` is too
burdensome.

FIXME:
["Option: C++ DWIM model" section of "Extensible classes" doc](https://docs.google.com/document/d/1gbQJN_IMJBnquOUUd2orbHLlAIqZ4pL0Vt7h34DkQjg/edit?resourcekey=0-0lkEvh0umUU206ASFlWc7A#heading=h.d2ybn2szry11)

### Don't allow unsafe delete

FIXME:
["Option: Like C++ but forbid unsafe" section of "Extensible classes" doc](https://docs.google.com/document/d/1gbQJN_IMJBnquOUUd2orbHLlAIqZ4pL0Vt7h34DkQjg/edit?resourcekey=0-0lkEvh0umUU206ASFlWc7A#heading=h.718ogac3yb9l)

FIXME: Extensible classes without virtual destructors were not that rare in C++
code we examined.

### Prevent virtual function calls in destructors

FIXME

This is a potential future extension, as noted in the design this could be
achieved by using the `partial` type, but seems like it may be burdensome to
prevent calling member functions without extra work.

This was considered in the
[open discussion on 2021-08-30](https://docs.google.com/document/d/105GsfmxOwcZ_iHkCXFnALB7e-_R3IgMpGKfeT84h1mc/edit?resourcekey=0-h3uVHObsJwChVg1MdaWfKQ#heading=h.4dobu6v1cdam).

### Allow destructors to specify a return type

FIXME

This was considered in the
[open discussion on 2021-08-30](https://docs.google.com/document/d/105GsfmxOwcZ_iHkCXFnALB7e-_R3IgMpGKfeT84h1mc/edit?resourcekey=0-h3uVHObsJwChVg1MdaWfKQ#heading=h.4dobu6v1cdam).

### Allow private destructors

C++ allows destructors to be marked `private`, which has some use cases such as
controlling deletes of a reference-counted value. This introduces
[context-sensitivity](/docs/project/principles/low_context_sensitivity.md). It
is particularly concerning if whether a type implements a constraint depends on
which function is the enclosing scope.

This was considered in the
[open discussion on 2021-08-30](https://docs.google.com/document/d/105GsfmxOwcZ_iHkCXFnALB7e-_R3IgMpGKfeT84h1mc/edit?resourcekey=0-h3uVHObsJwChVg1MdaWfKQ#heading=h.4dobu6v1cdam).

### Allow final destructors

One option we
[considered early on](https://docs.google.com/document/d/1QCdKQ33rki-kCDrxi8UHy3a36dtW0WdMqpUzluGSrz4/edit?resourcekey=0-bZmNUiueOiH_sysJNqnT9A#heading=h.40jlsrcgp8mr)
for extensible classes with non-virtual destructors, was to require the same
thing we do from non-virtual methods. That is, require that the implementation
in the base class is appropriate for derived classes. We ultimately decided on a
different approach, but we could still provide that as an option. You would
declare the destructor as `final`, and that would impose the necessary
restrictions on any derived class:

-   No custom destructor code.
-   Either no added data members, or, if we are willing to support unsized
    deletes, no added data members with non-trivial destructors.

Base classes with `final` destructors would be `Deletable`, like base classes
with `virtual` destructors. This would be a safe option without the overhead of
including a vtable in your object, but fairly restrictive in its applicability.

[We decided](https://discord.com/channels/655572317891461132/708431657849585705/958595054707023964)
is viable but not pressing since this isn't a feature present in C++, and we
would wait and see if this would fill a common need.
