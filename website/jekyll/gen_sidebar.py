"""Prints the sidebar structure to stdout.

Also provides get_top() and crawl() as module functions for other, custom
sidebars. This may be reused when publishing docs outside of the jekyll site,
although the API may change without notice.
"""

__copyright__ = """
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
"""

import io
import os
import sys

from carbon.proposals.scripts import proposals


# The top directory for the crawl.
_TOP_DIR = "./"
# Directories which will be completely ignored, including children.
_IGNORE_DIRS = ["github", "third_party", "website"]
# Directories which will be ignored, but children will be crawled.
_IGNORE_DIR_STEPS = ["docs"]
# Files which will be completely ignored.
_IGNORE_FILES = ["404.md"]

# All md files are included, with the LICENSE file special-cased for inclusion.
_MD_EXT = ".md"
_HTML_EXT = ".html"
_LICENSE = "LICENSE"
_LICENSE_TITLE = "Licenses"
_LICENSE_HTML = "licenses.html"

# The proposals directory is special-cased due to its special filenames.
_PROPOSALS = "proposals"

# Readme files are special-cased to use as directory names.
_README_TITLE = "About"
_README = "README.md"

# A brief header for the output.
_HEADER = "<!-- Generated by gen_sidebar.py -->"

# Boilerplate for checking if a page is active.
_LINK_TEMPLATE = """
%(indent)s<li{%% if page.url == "%(url)s" %%} class="active"{%% endif %%}>
%(indent)s  <a href="%(url)s">%(title)s</a>
%(indent)s</li>"""


class _Dir(object):
    """A basic struct for tracking information about a directory."""

    def __init__(self, title, rel_dir, files):
        self.title = title
        self.rel_dir = rel_dir
        self.files = files
        self.subdirs = []

    def __lt__(self, other):
        """Put the root files first and proposals last. Use titles otherwise."""
        if self.rel_dir == ".":
            return True
        if other.rel_dir == ".":
            return False

        if self.rel_dir == "proposals":
            return False
        if other.rel_dir == "proposals":
            return True

        return self.title < other.title

    def __repr__(self):
        return "_Dir(%r, %s, %r, %r)" % (
            self.title,
            self.rel_dir,
            self.files,
            self.subdirs,
        )


def _get_title(parent_dir, entry):
    """Returns the title from the requested file."""
    path = os.path.join(parent_dir, entry)
    assert path.endswith(_MD_EXT), path
    with open(path) as md:
        titles = [t for t in md.readlines() if t.startswith("# ")]
        if not titles:
            sys.exit("%r is missing a title." % path)
        return titles[0][2:-1]


def _should_ignore_dir(ignore_dirs, ignore_dir_steps, parent_dir):
    """Returns true if the directory should be omitted from the sidebar."""
    if "/." in parent_dir:
        # Hidden dir.
        return True
    for d in ignore_dir_steps:
        if parent_dir == d:
            return True
    for d in ignore_dirs:
        if parent_dir.startswith(d):
            return True
    return False


def _file_entry(parent_dir, rel_dir, f):
    """Constructs a file entry."""
    if rel_dir == ".":
        doc_path = "/%s" % f
    else:
        doc_path = "/%s/%s" % (rel_dir, f)
    if f == _README:
        return (_README_TITLE, doc_path)
    elif f == _LICENSE:
        return (_LICENSE_TITLE, doc_path)
    else:
        return (_get_title(parent_dir, f), doc_path)


def _filter_files(parent_dir, rel_dir, raw_files):
    """Returns a tuple of the readme and files for the sidebar."""
    readme = None
    files = []
    for f in raw_files:
        if (
            f.endswith(_MD_EXT) or os.path.basename(f) == _LICENSE
        ) and f not in _IGNORE_FILES:
            entry = _file_entry(parent_dir, rel_dir, f)
            if f == _README:
                readme = entry
            else:
                files.append(entry)
    return readme, files


def _fold_subdirs(subdirs):
    """Recursively nest subdirectories and sort."""
    index = 0
    while index < len(subdirs):
        maybe_move = subdirs[index]
        dirname = os.path.dirname(maybe_move.rel_dir)
        if dirname:
            for d in subdirs:
                if d.rel_dir == dirname:
                    d.subdirs.append(maybe_move)
                    del subdirs[index]
                    # Adjust the index to account for the removed item.
                    index -= 1
                    break
        index += 1
    subdirs.sort()

    for d in subdirs:
        _fold_subdirs(d.subdirs)


def crawl(top):
    """Crawls the repo directory for files to put in the sidebar.

    Returns a list of Dir objects, which will contain the overall hierarchy.
    Everything will be pre-sorted for use.
    """
    # Do everything but proposals in a walk.
    ignore_dirs = [os.path.join(top, d) for d in [_PROPOSALS] + _IGNORE_DIRS]
    ignore_dir_steps = [os.path.join(top, d) for d in _IGNORE_DIR_STEPS]
    dirs = []
    for parent_dir, unused_subdirs, raw_files in sorted(
        os.walk(top, topdown=True)
    ):
        if _should_ignore_dir(ignore_dirs, ignore_dir_steps, parent_dir):
            continue

        rel_dir = os.path.relpath(parent_dir, top)
        readme, files = list(_filter_files(parent_dir, rel_dir, raw_files))
        if readme is None:
            assert not files, "Every directory under docs/ needs a README.md."
            continue

        # Sort and put the README first when setting up the dir.
        files.sort()
        files.insert(0, readme)
        dirs.append(_Dir(_get_title(parent_dir, _README), rel_dir, files))

    # Do proposals, special-casing its file format.
    proposals_path = os.path.join(top, _PROPOSALS)
    proposal_files = [
        (title, "/%s/%s" % (_PROPOSALS, filename))
        for title, filename in proposals.get_list(proposals_path)
    ]
    dirs.append(
        _Dir(
            _get_title(proposals_path, _README),
            _PROPOSALS,
            [_file_entry(proposals_path, _PROPOSALS, _README)] + proposal_files,
        )
    )

    _fold_subdirs(dirs)
    return dirs


def _format_helper(dirs, indent, out):
    """Does recursive formatting of directory entries."""
    for d in dirs:
        out.write(
            "\n%(indent)s<li>"
            '\n%(indent)s  <a href="#">%(title)s</a>'
            "\n%(indent)s  <ul>" % {"indent": indent, "title": d.title}
        )
        child_indent = indent + "    "
        for title, doc_path in d.files:
            if os.path.basename(doc_path) == _README:
                url = os.path.dirname(doc_path)
                # The root readme will be "/" already.
                if url != "/":
                    url += "/"
            elif doc_path.endswith(_LICENSE):
                url = doc_path[: -len(_LICENSE)] + _LICENSE_HTML
            elif doc_path.endswith(_MD_EXT):
                url = doc_path[: -len(_MD_EXT)] + _HTML_EXT
            out.write(
                _LINK_TEMPLATE
                % {"indent": child_indent, "url": url, "title": title}
            )
        _format_helper(d.subdirs, child_indent, out)
        out.write(
            "\n%(indent)s  </ul>\n" "%(indent)s</li>" % {"indent": indent}
        )


def _format(dirs):
    """Wrapper for recursive formatting of directory entries."""
    with io.StringIO() as out:
        out.write(_HEADER)
        _format_helper(dirs, "  ", out)
        return out.getvalue()


def main():
    """Crawl all files, then generate the sidebar to stdout."""
    dirs = crawl(_TOP_DIR)
    out = _format(dirs)
    print(out)


if __name__ == "__main__":
    main()
