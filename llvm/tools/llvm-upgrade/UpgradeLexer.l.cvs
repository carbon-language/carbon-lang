/*===-- UpgradeLexer.l - Scanner for 1.9 assembly files --------*- C++ -*--===//
//
//                     The LLVM Compiler Infrastructure
//
// This file was developed by Reid Spencer and is distributed under the 
// University of Illinois Open Source License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
//  This file implements the flex scanner for LLVM 1.9 assembly languages files.
//
//===----------------------------------------------------------------------===*/

%option prefix="Upgrade"
%option yylineno
%option nostdinit
%option never-interactive
%option batch
%option noyywrap
%option nodefault
%option 8bit
%option outfile="UpgradeLexer.cpp"
%option ecs
%option noreject
%option noyymore

%{

#include "UpgradeInternals.h"
#include "UpgradeParser.h"
#include <cctype>
#include <cstdlib>

#define YY_INPUT(buf,result,max_size) \
{ \
  if (LexInput->good() && !LexInput->eof()) { \
    LexInput->read(buf,max_size); \
    result = LexInput->gcount(); \
  } else {\
    result = YY_NULL; \
  } \
}


// Construct a token value for a non-obsolete token
#define RET_TOK(sym) \
  Upgradelval.String = new std::string(yytext); \
  return sym

#define RET_TY(sym,OldTY,NewTY,sign) \
  Upgradelval.Type = TypeInfo::get(NewTY, OldTY); \
  return sym

#define YY_NEVER_INTERACTIVE 1
%}



/* Comments start with a ; and go till end of line */
Comment    ;.*

/* Variable(Value) identifiers start with a % sign */
VarID       %[-a-zA-Z$._][-a-zA-Z$._0-9]*

/* Label identifiers end with a colon */
Label       [-a-zA-Z$._0-9]+:
QuoteLabel \"[^\"]+\":

/* Quoted names can contain any character except " and \ */
StringConstant \"[^\"]*\"


/* [PN]Integer: match positive and negative literal integer values that
 * are preceeded by a '%' character.  These represent unnamed variable slots.
 */
EPInteger     %[0-9]+
ENInteger    %-[0-9]+


/* E[PN]Integer: match positive and negative literal integer values */
PInteger   [0-9]+
NInteger  -[0-9]+

/* FPConstant - A Floating point constant.
 */
FPConstant [-+]?[0-9]+[.][0-9]*([eE][-+]?[0-9]+)?

/* HexFPConstant - Floating point constant represented in IEEE format as a
 *  hexadecimal number for when exponential notation is not precise enough.
 */
HexFPConstant 0x[0-9A-Fa-f]+

/* HexIntConstant - Hexadecimal constant generated by the CFE to avoid forcing
 * it to deal with 64 bit numbers.
 */
HexIntConstant [us]0x[0-9A-Fa-f]+
%%

{Comment}       { /* Ignore comments for now */ }

begin           { RET_TOK( BEGINTOK); }
end             { RET_TOK( ENDTOK); }
true            { RET_TOK( TRUETOK);  }
false           { RET_TOK( FALSETOK); }
declare         { RET_TOK( DECLARE); }
global          { RET_TOK( GLOBAL); }
constant        { RET_TOK( CONSTANT); }
internal        { RET_TOK( INTERNAL); }
linkonce        { RET_TOK( LINKONCE); }
weak            { RET_TOK( WEAK); }
appending       { RET_TOK( APPENDING); }
dllimport       { RET_TOK( DLLIMPORT); }
dllexport       { RET_TOK( DLLEXPORT); }
extern_weak     { RET_TOK( EXTERN_WEAK); }
external        { RET_TOK( EXTERNAL); }
uninitialized   { RET_TOK( UNINITIALIZED); }  // alias for external
implementation  { RET_TOK( IMPLEMENTATION); }
zeroinitializer { RET_TOK( ZEROINITIALIZER); }
\.\.\.          { RET_TOK( DOTDOTDOT); }
undef           { RET_TOK( UNDEF); }
null            { RET_TOK( NULL_TOK); }
to              { RET_TOK( TO); }
tail            { RET_TOK( TAIL); }
target          { RET_TOK( TARGET); }
triple          { RET_TOK( TRIPLE); }
deplibs         { RET_TOK( DEPLIBS); }
endian          { RET_TOK( ENDIAN); }
pointersize     { RET_TOK( POINTERSIZE); }
datalayout      { RET_TOK( DATALAYOUT); }
little          { RET_TOK( LITTLE); }
big             { RET_TOK( BIG); }
volatile        { RET_TOK( VOLATILE); }
align           { RET_TOK( ALIGN);  }
section         { RET_TOK( SECTION); }
module          { RET_TOK( MODULE); }
asm             { RET_TOK( ASM_TOK); }
sideeffect      { RET_TOK( SIDEEFFECT); }

cc              { RET_TOK( CC_TOK); }
ccc             { RET_TOK( CCC_TOK); }
csretcc         { RET_TOK( CSRETCC_TOK); }
fastcc          { RET_TOK( FASTCC_TOK); }
coldcc          { RET_TOK( COLDCC_TOK); }
x86_stdcallcc   { RET_TOK( X86_STDCALLCC_TOK); }
x86_fastcallcc  { RET_TOK( X86_FASTCALLCC_TOK); }

void            { RET_TY(VOID,VoidTy,"void",false); }
bool            { RET_TY(BOOL,BoolTy,"bool",false); }
sbyte           { RET_TY(SBYTE,SByteTy,"i8",true); }
ubyte           { RET_TY(UBYTE,UByteTy,"i8",false); }
short           { RET_TY(SHORT,ShortTy,"i16",true); }
ushort          { RET_TY(USHORT,UShortTy,"i16",false); }
int             { RET_TY(INT,IntTy,"i32",true);   }
uint            { RET_TY(UINT,UIntTy,"i32",false);  }
long            { RET_TY(LONG,LongTy,"i64",true);  }
ulong           { RET_TY(ULONG,ULongTy,"i64",false); }
i8              { RET_TY(UBYTE,UByteTy,"i8",false); }
i16             { RET_TY(USHORT,UShortTy,"i16",false); }
i32             { RET_TY(UINT,UIntTy,"i32",false); }
i64             { RET_TY(ULONG,ULongTy,"i64",false); }
float           { RET_TY(FLOAT,FloatTy,"float",false); }
double          { RET_TY(DOUBLE,DoubleTy,"double",false); }
label           { RET_TY(LABEL,LabelTy,"label",false); }
opaque          { RET_TOK(OPAQUE); }
type            { RET_TOK(TYPE);   }

add             { RET_TOK( ADD); }
sub             { RET_TOK( SUB); }
mul             { RET_TOK( MUL); }
div             { RET_TOK( DIV); }
udiv            { RET_TOK( UDIV); }
sdiv            { RET_TOK( SDIV); }
fdiv            { RET_TOK( FDIV); }
rem             { RET_TOK( REM);  }
urem            { RET_TOK( UREM); }
srem            { RET_TOK( SREM); }
frem            { RET_TOK( FREM); }
and             { RET_TOK( AND); }
or              { RET_TOK( OR); }
xor             { RET_TOK( XOR); }
setne           { RET_TOK( SETNE); }
seteq           { RET_TOK( SETEQ); }
setlt           { RET_TOK( SETLT); }
setgt           { RET_TOK( SETGT); }
setle           { RET_TOK( SETLE); }
setge           { RET_TOK( SETGE); }
icmp            { RET_TOK(ICMP); }
fcmp            { RET_TOK(FCMP); }
eq              { RET_TOK(EQ); }
ne              { RET_TOK(NE); }
slt             { RET_TOK(SLT); }
sgt             { RET_TOK(SGT); }
sle             { RET_TOK(SLE); }
sge             { RET_TOK(SGE); }
oeq             { RET_TOK(OEQ); }
one             { RET_TOK(ONE); }
olt             { RET_TOK(OLT); }
ogt             { RET_TOK(OGT); }
ole             { RET_TOK(OLE); }
oge             { RET_TOK(OGE); }
ord             { RET_TOK(ORD); }
uno             { RET_TOK(UNO); }
ueq             { RET_TOK(UEQ); }
une             { RET_TOK(UNE); }
ult             { RET_TOK(ULT); }
ugt             { RET_TOK(UGT); }
ule             { RET_TOK(ULE); }
uge             { RET_TOK(UGE); }

phi             { RET_TOK( PHI_TOK); }
call            { RET_TOK( CALL); }
cast            { RET_TOK( CAST); }
trunc           { RET_TOK( TRUNC); }
zext            { RET_TOK( ZEXT); }
sext            { RET_TOK( SEXT); }
fptrunc         { RET_TOK( FPTRUNC); }
fpext           { RET_TOK( FPEXT); }
fptoui          { RET_TOK( FPTOUI); }
fptosi          { RET_TOK( FPTOSI); }
uitofp          { RET_TOK( UITOFP); }
sitofp          { RET_TOK( SITOFP); }
ptrtoint        { RET_TOK( PTRTOINT); }
inttoptr        { RET_TOK( INTTOPTR); }
bitcast         { RET_TOK( BITCAST); }
select          { RET_TOK( SELECT); }
shl             { RET_TOK( SHL); }
shr             { RET_TOK( SHR); }
ashr            { RET_TOK( ASHR); }
lshr            { RET_TOK( LSHR); }
va_arg          { RET_TOK( VAARG); }
ret             { RET_TOK( RET); }
br              { RET_TOK( BR); }
switch          { RET_TOK( SWITCH); }
invoke          { RET_TOK( INVOKE); }
unwind          { RET_TOK( UNWIND); }
except          { RET_TOK( EXCEPT); } // alias for unwind
unreachable     { RET_TOK( UNREACHABLE); }

malloc          { RET_TOK( MALLOC); }
alloca          { RET_TOK( ALLOCA); }
free            { RET_TOK( FREE); }
load            { RET_TOK( LOAD); }
store           { RET_TOK( STORE); }
getelementptr   { RET_TOK( GETELEMENTPTR); }

extractelement  { RET_TOK( EXTRACTELEMENT); }
insertelement   { RET_TOK( INSERTELEMENT); }
shufflevector   { RET_TOK( SHUFFLEVECTOR); }


{VarID}          { RET_TOK( VAR_ID); }
{Label}          { RET_TOK( LABELSTR); }
{QuoteLabel}     { RET_TOK( LABELSTR); }
{StringConstant} { RET_TOK( STRINGCONSTANT ); }
{PInteger}       { RET_TOK( EUINT64VAL ); }
{NInteger}       { RET_TOK( ESINT64VAL ); }
{HexIntConstant} { RET_TOK( yytext[0] == 's' ? ESINT64VAL : EUINT64VAL ); }
{EPInteger}      { RET_TOK( UINTVAL); }
{ENInteger}      { RET_TOK( SINTVAL); }
{FPConstant}     { RET_TOK( FPVAL); }
{HexFPConstant}  { RET_TOK( FPVAL); }
<<EOF>>          {
                  /* Make sure to free the internal buffers for flex when we are
                   * done reading our input!
                   */
                  yy_delete_buffer(YY_CURRENT_BUFFER);
                  return EOF;
                }

[ \r\t\n]       { /* Ignore whitespace */ }
.               { return yytext[0]; }

%%
