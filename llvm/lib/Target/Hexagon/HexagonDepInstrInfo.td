//===--- HexagonDepInstrInfo.td -------------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

def A2_abs : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = abs($Rs32)",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_4075554 {
let Inst{13-5} = 0b000000100;
let Inst{31-21} = 0b10001100100;
let hasNewValue = 1;
let opNewValue = 0;
}
def A2_absp : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32),
"$Rdd32 = abs($Rss32)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_13133231 {
let Inst{13-5} = 0b000000110;
let Inst{31-21} = 0b10000000100;
}
def A2_abssat : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = abs($Rs32):sat",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_4075554 {
let Inst{13-5} = 0b000000101;
let Inst{31-21} = 0b10001100100;
let hasNewValue = 1;
let opNewValue = 0;
let Defs = [USR_OVF];
}
def A2_add : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = add($Rs32,$Rt32)",
ALU32_3op_tc_1_SLOT0123, TypeALU32_3op>, Enc_14071773, PredNewRel, ImmRegRel {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110011000;
let hasNewValue = 1;
let opNewValue = 0;
let CextOpcode = "A2_add";
let InputType = "reg";
let BaseOpcode = "A2_add";
let isCommutable = 1;
let isPredicable = 1;
}
def A2_addh_h16_hh : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = add($Rt32.h,$Rs32.h):<<16",
ALU64_tc_1_SLOT23, TypeALU64>, Enc_8605375 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101010;
let hasNewValue = 1;
let opNewValue = 0;
}
def A2_addh_h16_hl : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = add($Rt32.h,$Rs32.l):<<16",
ALU64_tc_1_SLOT23, TypeALU64>, Enc_8605375 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101010;
let hasNewValue = 1;
let opNewValue = 0;
}
def A2_addh_h16_lh : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = add($Rt32.l,$Rs32.h):<<16",
ALU64_tc_1_SLOT23, TypeALU64>, Enc_8605375 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101010;
let hasNewValue = 1;
let opNewValue = 0;
}
def A2_addh_h16_ll : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = add($Rt32.l,$Rs32.l):<<16",
ALU64_tc_1_SLOT23, TypeALU64>, Enc_8605375 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101010;
let hasNewValue = 1;
let opNewValue = 0;
}
def A2_addh_h16_sat_hh : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = add($Rt32.h,$Rs32.h):sat:<<16",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_8605375 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101010;
let hasNewValue = 1;
let opNewValue = 0;
let Defs = [USR_OVF];
}
def A2_addh_h16_sat_hl : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = add($Rt32.h,$Rs32.l):sat:<<16",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_8605375 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101010;
let hasNewValue = 1;
let opNewValue = 0;
let Defs = [USR_OVF];
}
def A2_addh_h16_sat_lh : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = add($Rt32.l,$Rs32.h):sat:<<16",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_8605375 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101010;
let hasNewValue = 1;
let opNewValue = 0;
let Defs = [USR_OVF];
}
def A2_addh_h16_sat_ll : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = add($Rt32.l,$Rs32.l):sat:<<16",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_8605375 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101010;
let hasNewValue = 1;
let opNewValue = 0;
let Defs = [USR_OVF];
}
def A2_addh_l16_hl : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = add($Rt32.l,$Rs32.h)",
ALU64_tc_1_SLOT23, TypeALU64>, Enc_8605375 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101000;
let hasNewValue = 1;
let opNewValue = 0;
}
def A2_addh_l16_ll : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = add($Rt32.l,$Rs32.l)",
ALU64_tc_1_SLOT23, TypeALU64>, Enc_8605375 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101000;
let hasNewValue = 1;
let opNewValue = 0;
}
def A2_addh_l16_sat_hl : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = add($Rt32.l,$Rs32.h):sat",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_8605375 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101000;
let hasNewValue = 1;
let opNewValue = 0;
let Defs = [USR_OVF];
}
def A2_addh_l16_sat_ll : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = add($Rt32.l,$Rs32.l):sat",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_8605375 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101000;
let hasNewValue = 1;
let opNewValue = 0;
let Defs = [USR_OVF];
}
def A2_addi : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, s32_0Imm:$Ii),
"$Rd32 = add($Rs32,#$Ii)",
ALU32_ADDI_tc_1_SLOT0123, TypeALU32_ADDI>, Enc_11542684, PredNewRel, ImmRegRel {
let Inst{31-28} = 0b1011;
let hasNewValue = 1;
let opNewValue = 0;
let CextOpcode = "A2_add";
let InputType = "imm";
let BaseOpcode = "A2_addi";
let isPredicable = 1;
let isAdd = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 16;
let opExtentAlign = 0;
}
def A2_addp : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = add($Rss32,$Rtt32)",
ALU64_tc_1_SLOT23, TypeALU64>, Enc_8333157 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011000;
let isCommutable = 1;
let isAdd = 1;
}
def A2_addpsat : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = add($Rss32,$Rtt32):sat",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_8333157 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011011;
let Defs = [USR_OVF];
let isCommutable = 1;
}
def A2_addsat : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = add($Rs32,$Rt32):sat",
ALU32_3op_tc_2_SLOT0123, TypeALU32_3op>, Enc_14071773 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110110010;
let hasNewValue = 1;
let opNewValue = 0;
let Defs = [USR_OVF];
let InputType = "reg";
let isCommutable = 1;
}
def A2_addsp : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, DoubleRegs:$Rtt32),
"$Rdd32 = add($Rs32,$Rtt32)",
ALU64_tc_1_SLOT23, TypeALU64> {
let isPseudo = 1;
}
def A2_addsph : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = add($Rss32,$Rtt32):raw:hi",
ALU64_tc_1_SLOT23, TypeALU64>, Enc_8333157 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011011;
}
def A2_addspl : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = add($Rss32,$Rtt32):raw:lo",
ALU64_tc_1_SLOT23, TypeALU64>, Enc_8333157 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011011;
}
def A2_and : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = and($Rs32,$Rt32)",
ALU32_3op_tc_1_SLOT0123, TypeALU32_3op>, Enc_14071773, PredNewRel, ImmRegRel {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110001000;
let hasNewValue = 1;
let opNewValue = 0;
let CextOpcode = "A2_and";
let InputType = "reg";
let BaseOpcode = "A2_and";
let isCommutable = 1;
let isPredicable = 1;
}
def A2_andir : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, s32_0Imm:$Ii),
"$Rd32 = and($Rs32,#$Ii)",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_13472494, ImmRegRel {
let Inst{31-22} = 0b0111011000;
let hasNewValue = 1;
let opNewValue = 0;
let CextOpcode = "A2_and";
let InputType = "imm";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 10;
let opExtentAlign = 0;
}
def A2_andp : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = and($Rss32,$Rtt32)",
ALU64_tc_1_SLOT23, TypeALU64>, Enc_8333157 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011111;
let isCommutable = 1;
}
def A2_aslh : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = aslh($Rs32)",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_4075554, PredNewRel {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b01110000000;
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_aslh";
let isPredicable = 1;
}
def A2_asrh : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = asrh($Rs32)",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_4075554, PredNewRel {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b01110000001;
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_asrh";
let isPredicable = 1;
}
def A2_combine_hh : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = combine($Rt32.h,$Rs32.h)",
ALU32_3op_tc_1_SLOT0123, TypeALU32_3op>, Enc_8605375 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110011100;
let hasNewValue = 1;
let opNewValue = 0;
let InputType = "reg";
}
def A2_combine_hl : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = combine($Rt32.h,$Rs32.l)",
ALU32_3op_tc_1_SLOT0123, TypeALU32_3op>, Enc_8605375 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110011101;
let hasNewValue = 1;
let opNewValue = 0;
let InputType = "reg";
}
def A2_combine_lh : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = combine($Rt32.l,$Rs32.h)",
ALU32_3op_tc_1_SLOT0123, TypeALU32_3op>, Enc_8605375 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110011110;
let hasNewValue = 1;
let opNewValue = 0;
let InputType = "reg";
}
def A2_combine_ll : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = combine($Rt32.l,$Rs32.l)",
ALU32_3op_tc_1_SLOT0123, TypeALU32_3op>, Enc_8605375 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110011111;
let hasNewValue = 1;
let opNewValue = 0;
let InputType = "reg";
}
def A2_combineii : HInst<
(outs DoubleRegs:$Rdd32),
(ins s32_0Imm:$Ii, s8_0Imm:$II),
"$Rdd32 = combine(#$Ii,#$II)",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_14007201 {
let Inst{31-23} = 0b011111000;
let isReMaterializable = 1;
let isAsCheapAsAMove = 1;
let isMoveImm = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 8;
let opExtentAlign = 0;
}
def A2_combinew : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = combine($Rs32,$Rt32)",
ALU32_3op_tc_1_SLOT0123, TypeALU32_3op>, Enc_1997594, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110101000;
let InputType = "reg";
let BaseOpcode = "A2_combinew";
let isPredicable = 1;
}
def A2_max : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = max($Rs32,$Rt32)",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_14071773 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101110;
let hasNewValue = 1;
let opNewValue = 0;
}
def A2_maxp : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = max($Rss32,$Rtt32)",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_8333157 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011110;
}
def A2_maxu : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = maxu($Rs32,$Rt32)",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_14071773 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101110;
let hasNewValue = 1;
let opNewValue = 0;
}
def A2_maxup : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = maxu($Rss32,$Rtt32)",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_8333157 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011110;
}
def A2_min : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = min($Rt32,$Rs32)",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_8605375 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101101;
let hasNewValue = 1;
let opNewValue = 0;
}
def A2_minp : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = min($Rtt32,$Rss32)",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_11687333 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011101;
}
def A2_minu : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = minu($Rt32,$Rs32)",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_8605375 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101101;
let hasNewValue = 1;
let opNewValue = 0;
}
def A2_minup : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = minu($Rtt32,$Rss32)",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_11687333 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011101;
}
def A2_neg : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = neg($Rs32)",
PSEUDO, TypeALU32_2op> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def A2_negp : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32),
"$Rdd32 = neg($Rss32)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_13133231 {
let Inst{13-5} = 0b000000101;
let Inst{31-21} = 0b10000000100;
}
def A2_negsat : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = neg($Rs32):sat",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_4075554 {
let Inst{13-5} = 0b000000110;
let Inst{31-21} = 0b10001100100;
let hasNewValue = 1;
let opNewValue = 0;
let Defs = [USR_OVF];
}
def A2_nop : HInst<
(outs),
(ins),
"nop",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_0 {
let Inst{13-0} = 0b00000000000000;
let Inst{31-16} = 0b0111111100000000;
}
def A2_not : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = not($Rs32)",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def A2_notp : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32),
"$Rdd32 = not($Rss32)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_13133231 {
let Inst{13-5} = 0b000000100;
let Inst{31-21} = 0b10000000100;
}
def A2_or : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = or($Rs32,$Rt32)",
ALU32_3op_tc_1_SLOT0123, TypeALU32_3op>, Enc_14071773, PredNewRel, ImmRegRel {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110001001;
let hasNewValue = 1;
let opNewValue = 0;
let CextOpcode = "A2_or";
let InputType = "reg";
let BaseOpcode = "A2_or";
let isCommutable = 1;
let isPredicable = 1;
}
def A2_orir : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, s32_0Imm:$Ii),
"$Rd32 = or($Rs32,#$Ii)",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_13472494, ImmRegRel {
let Inst{31-22} = 0b0111011010;
let hasNewValue = 1;
let opNewValue = 0;
let CextOpcode = "A2_or";
let InputType = "imm";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 10;
let opExtentAlign = 0;
}
def A2_orp : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = or($Rss32,$Rtt32)",
ALU64_tc_1_SLOT23, TypeALU64>, Enc_8333157 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011111;
let isCommutable = 1;
}
def A2_paddf : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, IntRegs:$Rt32),
"if (!$Pu4) $Rd32 = add($Rs32,$Rt32)",
ALU32_3op_tc_1_SLOT0123, TypeALU32_3op>, Enc_9626139, PredNewRel, ImmRegRel {
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11111011000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let CextOpcode = "A2_add";
let InputType = "reg";
let BaseOpcode = "A2_add";
}
def A2_paddfnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, IntRegs:$Rt32),
"if (!$Pu4.new) $Rd32 = add($Rs32,$Rt32)",
ALU32_3op_tc_1_SLOT0123, TypeALU32_3op>, Enc_9626139, PredNewRel, ImmRegRel {
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b11111011000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let CextOpcode = "A2_add";
let InputType = "reg";
let BaseOpcode = "A2_add";
}
def A2_paddif : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, s32_0Imm:$Ii),
"if (!$Pu4) $Rd32 = add($Rs32,#$Ii)",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_10568534, PredNewRel, ImmRegRel {
let Inst{13-13} = 0b0;
let Inst{31-23} = 0b011101001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let CextOpcode = "A2_add";
let InputType = "imm";
let BaseOpcode = "A2_addi";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 1;
let opExtentBits = 8;
let opExtentAlign = 0;
}
def A2_paddifnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, s32_0Imm:$Ii),
"if (!$Pu4.new) $Rd32 = add($Rs32,#$Ii)",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_10568534, PredNewRel, ImmRegRel {
let Inst{13-13} = 0b1;
let Inst{31-23} = 0b011101001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let CextOpcode = "A2_add";
let InputType = "imm";
let BaseOpcode = "A2_addi";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 1;
let opExtentBits = 8;
let opExtentAlign = 0;
}
def A2_paddit : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, s32_0Imm:$Ii),
"if ($Pu4) $Rd32 = add($Rs32,#$Ii)",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_10568534, PredNewRel, ImmRegRel {
let Inst{13-13} = 0b0;
let Inst{31-23} = 0b011101000;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let CextOpcode = "A2_add";
let InputType = "imm";
let BaseOpcode = "A2_addi";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 1;
let opExtentBits = 8;
let opExtentAlign = 0;
}
def A2_padditnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, s32_0Imm:$Ii),
"if ($Pu4.new) $Rd32 = add($Rs32,#$Ii)",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_10568534, PredNewRel, ImmRegRel {
let Inst{13-13} = 0b1;
let Inst{31-23} = 0b011101000;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let CextOpcode = "A2_add";
let InputType = "imm";
let BaseOpcode = "A2_addi";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 1;
let opExtentBits = 8;
let opExtentAlign = 0;
}
def A2_paddt : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, IntRegs:$Rt32),
"if ($Pu4) $Rd32 = add($Rs32,$Rt32)",
ALU32_3op_tc_1_SLOT0123, TypeALU32_3op>, Enc_9626139, PredNewRel, ImmRegRel {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11111011000;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let CextOpcode = "A2_add";
let InputType = "reg";
let BaseOpcode = "A2_add";
}
def A2_paddtnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, IntRegs:$Rt32),
"if ($Pu4.new) $Rd32 = add($Rs32,$Rt32)",
ALU32_3op_tc_1_SLOT0123, TypeALU32_3op>, Enc_9626139, PredNewRel, ImmRegRel {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b11111011000;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let CextOpcode = "A2_add";
let InputType = "reg";
let BaseOpcode = "A2_add";
}
def A2_pandf : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, IntRegs:$Rt32),
"if (!$Pu4) $Rd32 = and($Rs32,$Rt32)",
ALU32_3op_tc_1_SLOT0123, TypeALU32_3op>, Enc_9626139, PredNewRel {
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11111001000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_and";
}
def A2_pandfnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, IntRegs:$Rt32),
"if (!$Pu4.new) $Rd32 = and($Rs32,$Rt32)",
ALU32_3op_tc_1_SLOT0123, TypeALU32_3op>, Enc_9626139, PredNewRel {
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b11111001000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let BaseOpcode = "A2_and";
}
def A2_pandt : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, IntRegs:$Rt32),
"if ($Pu4) $Rd32 = and($Rs32,$Rt32)",
ALU32_3op_tc_1_SLOT0123, TypeALU32_3op>, Enc_9626139, PredNewRel {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11111001000;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_and";
}
def A2_pandtnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, IntRegs:$Rt32),
"if ($Pu4.new) $Rd32 = and($Rs32,$Rt32)",
ALU32_3op_tc_1_SLOT0123, TypeALU32_3op>, Enc_9626139, PredNewRel {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b11111001000;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let BaseOpcode = "A2_and";
}
def A2_porf : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, IntRegs:$Rt32),
"if (!$Pu4) $Rd32 = or($Rs32,$Rt32)",
ALU32_3op_tc_1_SLOT0123, TypeALU32_3op>, Enc_9626139, PredNewRel {
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11111001001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_or";
}
def A2_porfnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, IntRegs:$Rt32),
"if (!$Pu4.new) $Rd32 = or($Rs32,$Rt32)",
ALU32_3op_tc_1_SLOT0123, TypeALU32_3op>, Enc_9626139, PredNewRel {
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b11111001001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let BaseOpcode = "A2_or";
}
def A2_port : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, IntRegs:$Rt32),
"if ($Pu4) $Rd32 = or($Rs32,$Rt32)",
ALU32_3op_tc_1_SLOT0123, TypeALU32_3op>, Enc_9626139, PredNewRel {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11111001001;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_or";
}
def A2_portnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, IntRegs:$Rt32),
"if ($Pu4.new) $Rd32 = or($Rs32,$Rt32)",
ALU32_3op_tc_1_SLOT0123, TypeALU32_3op>, Enc_9626139, PredNewRel {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b11111001001;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let BaseOpcode = "A2_or";
}
def A2_psubf : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rt32, IntRegs:$Rs32),
"if (!$Pu4) $Rd32 = sub($Rt32,$Rs32)",
ALU32_3op_tc_1_SLOT0123, TypeALU32_3op>, Enc_1332717, PredNewRel {
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11111011001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_sub";
}
def A2_psubfnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rt32, IntRegs:$Rs32),
"if (!$Pu4.new) $Rd32 = sub($Rt32,$Rs32)",
ALU32_3op_tc_1_SLOT0123, TypeALU32_3op>, Enc_1332717, PredNewRel {
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b11111011001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let BaseOpcode = "A2_sub";
}
def A2_psubt : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rt32, IntRegs:$Rs32),
"if ($Pu4) $Rd32 = sub($Rt32,$Rs32)",
ALU32_3op_tc_1_SLOT0123, TypeALU32_3op>, Enc_1332717, PredNewRel {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11111011001;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_sub";
}
def A2_psubtnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rt32, IntRegs:$Rs32),
"if ($Pu4.new) $Rd32 = sub($Rt32,$Rs32)",
ALU32_3op_tc_1_SLOT0123, TypeALU32_3op>, Enc_1332717, PredNewRel {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b11111011001;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let BaseOpcode = "A2_sub";
}
def A2_pxorf : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, IntRegs:$Rt32),
"if (!$Pu4) $Rd32 = xor($Rs32,$Rt32)",
ALU32_3op_tc_1_SLOT0123, TypeALU32_3op>, Enc_9626139, PredNewRel {
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11111001011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_xor";
}
def A2_pxorfnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, IntRegs:$Rt32),
"if (!$Pu4.new) $Rd32 = xor($Rs32,$Rt32)",
ALU32_3op_tc_1_SLOT0123, TypeALU32_3op>, Enc_9626139, PredNewRel {
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b11111001011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let BaseOpcode = "A2_xor";
}
def A2_pxort : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, IntRegs:$Rt32),
"if ($Pu4) $Rd32 = xor($Rs32,$Rt32)",
ALU32_3op_tc_1_SLOT0123, TypeALU32_3op>, Enc_9626139, PredNewRel {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11111001011;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_xor";
}
def A2_pxortnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, IntRegs:$Rt32),
"if ($Pu4.new) $Rd32 = xor($Rs32,$Rt32)",
ALU32_3op_tc_1_SLOT0123, TypeALU32_3op>, Enc_9626139, PredNewRel {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b11111001011;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let BaseOpcode = "A2_xor";
}
def A2_roundsat : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32),
"$Rd32 = round($Rss32):sat",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_3742184, Requires<[HasV5T]> {
let Inst{13-5} = 0b000000001;
let Inst{31-21} = 0b10001000110;
let hasNewValue = 1;
let opNewValue = 0;
let Defs = [USR_OVF];
}
def A2_sat : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32),
"$Rd32 = sat($Rss32)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_3742184 {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b10001000110;
let hasNewValue = 1;
let opNewValue = 0;
let Defs = [USR_OVF];
}
def A2_satb : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = satb($Rs32)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_4075554 {
let Inst{13-5} = 0b000000111;
let Inst{31-21} = 0b10001100110;
let hasNewValue = 1;
let opNewValue = 0;
let Defs = [USR_OVF];
}
def A2_sath : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = sath($Rs32)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_4075554 {
let Inst{13-5} = 0b000000100;
let Inst{31-21} = 0b10001100110;
let hasNewValue = 1;
let opNewValue = 0;
let Defs = [USR_OVF];
}
def A2_satub : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = satub($Rs32)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_4075554 {
let Inst{13-5} = 0b000000110;
let Inst{31-21} = 0b10001100110;
let hasNewValue = 1;
let opNewValue = 0;
let Defs = [USR_OVF];
}
def A2_satuh : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = satuh($Rs32)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_4075554 {
let Inst{13-5} = 0b000000101;
let Inst{31-21} = 0b10001100110;
let hasNewValue = 1;
let opNewValue = 0;
let Defs = [USR_OVF];
}
def A2_sub : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = sub($Rt32,$Rs32)",
ALU32_3op_tc_1_SLOT0123, TypeALU32_3op>, Enc_8605375, PredNewRel, ImmRegRel {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110011001;
let hasNewValue = 1;
let opNewValue = 0;
let CextOpcode = "A2_sub";
let InputType = "reg";
let BaseOpcode = "A2_sub";
let isPredicable = 1;
}
def A2_subh_h16_hh : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = sub($Rt32.h,$Rs32.h):<<16",
ALU64_tc_1_SLOT23, TypeALU64>, Enc_8605375 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101011;
let hasNewValue = 1;
let opNewValue = 0;
}
def A2_subh_h16_hl : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = sub($Rt32.h,$Rs32.l):<<16",
ALU64_tc_1_SLOT23, TypeALU64>, Enc_8605375 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101011;
let hasNewValue = 1;
let opNewValue = 0;
}
def A2_subh_h16_lh : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = sub($Rt32.l,$Rs32.h):<<16",
ALU64_tc_1_SLOT23, TypeALU64>, Enc_8605375 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101011;
let hasNewValue = 1;
let opNewValue = 0;
}
def A2_subh_h16_ll : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = sub($Rt32.l,$Rs32.l):<<16",
ALU64_tc_1_SLOT23, TypeALU64>, Enc_8605375 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101011;
let hasNewValue = 1;
let opNewValue = 0;
}
def A2_subh_h16_sat_hh : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = sub($Rt32.h,$Rs32.h):sat:<<16",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_8605375 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101011;
let hasNewValue = 1;
let opNewValue = 0;
let Defs = [USR_OVF];
}
def A2_subh_h16_sat_hl : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = sub($Rt32.h,$Rs32.l):sat:<<16",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_8605375 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101011;
let hasNewValue = 1;
let opNewValue = 0;
let Defs = [USR_OVF];
}
def A2_subh_h16_sat_lh : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = sub($Rt32.l,$Rs32.h):sat:<<16",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_8605375 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101011;
let hasNewValue = 1;
let opNewValue = 0;
let Defs = [USR_OVF];
}
def A2_subh_h16_sat_ll : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = sub($Rt32.l,$Rs32.l):sat:<<16",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_8605375 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101011;
let hasNewValue = 1;
let opNewValue = 0;
let Defs = [USR_OVF];
}
def A2_subh_l16_hl : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = sub($Rt32.l,$Rs32.h)",
ALU64_tc_1_SLOT23, TypeALU64>, Enc_8605375 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101001;
let hasNewValue = 1;
let opNewValue = 0;
}
def A2_subh_l16_ll : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = sub($Rt32.l,$Rs32.l)",
ALU64_tc_1_SLOT23, TypeALU64>, Enc_8605375 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101001;
let hasNewValue = 1;
let opNewValue = 0;
}
def A2_subh_l16_sat_hl : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = sub($Rt32.l,$Rs32.h):sat",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_8605375 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101001;
let hasNewValue = 1;
let opNewValue = 0;
let Defs = [USR_OVF];
}
def A2_subh_l16_sat_ll : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = sub($Rt32.l,$Rs32.l):sat",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_8605375 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101001;
let hasNewValue = 1;
let opNewValue = 0;
let Defs = [USR_OVF];
}
def A2_subp : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = sub($Rtt32,$Rss32)",
ALU64_tc_1_SLOT23, TypeALU64>, Enc_11687333 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011001;
}
def A2_subri : HInst<
(outs IntRegs:$Rd32),
(ins s32_0Imm:$Ii, IntRegs:$Rs32),
"$Rd32 = sub(#$Ii,$Rs32)",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_13472494, PredNewRel, ImmRegRel {
let Inst{31-22} = 0b0111011001;
let hasNewValue = 1;
let opNewValue = 0;
let CextOpcode = "A2_sub";
let InputType = "imm";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 10;
let opExtentAlign = 0;
}
def A2_subsat : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = sub($Rt32,$Rs32):sat",
ALU32_3op_tc_2_SLOT0123, TypeALU32_3op>, Enc_8605375 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110110110;
let hasNewValue = 1;
let opNewValue = 0;
let Defs = [USR_OVF];
let InputType = "reg";
}
def A2_svaddh : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = vaddh($Rs32,$Rt32)",
ALU32_3op_tc_1_SLOT0123, TypeALU32_3op>, Enc_14071773 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110110000;
let hasNewValue = 1;
let opNewValue = 0;
let InputType = "reg";
let isCommutable = 1;
}
def A2_svaddhs : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = vaddh($Rs32,$Rt32):sat",
ALU32_3op_tc_2_SLOT0123, TypeALU32_3op>, Enc_14071773 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110110001;
let hasNewValue = 1;
let opNewValue = 0;
let Defs = [USR_OVF];
let InputType = "reg";
let isCommutable = 1;
}
def A2_svadduhs : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = vadduh($Rs32,$Rt32):sat",
ALU32_3op_tc_2_SLOT0123, TypeALU32_3op>, Enc_14071773 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110110011;
let hasNewValue = 1;
let opNewValue = 0;
let Defs = [USR_OVF];
let InputType = "reg";
let isCommutable = 1;
}
def A2_svavgh : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = vavgh($Rs32,$Rt32)",
ALU32_3op_tc_1_SLOT0123, TypeALU32_3op>, Enc_14071773 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110111000;
let hasNewValue = 1;
let opNewValue = 0;
let InputType = "reg";
let isCommutable = 1;
}
def A2_svavghs : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = vavgh($Rs32,$Rt32):rnd",
ALU32_3op_tc_2_SLOT0123, TypeALU32_3op>, Enc_14071773 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110111001;
let hasNewValue = 1;
let opNewValue = 0;
let InputType = "reg";
let isCommutable = 1;
}
def A2_svnavgh : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = vnavgh($Rt32,$Rs32)",
ALU32_3op_tc_1_SLOT0123, TypeALU32_3op>, Enc_8605375 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110111011;
let hasNewValue = 1;
let opNewValue = 0;
let InputType = "reg";
}
def A2_svsubh : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = vsubh($Rt32,$Rs32)",
ALU32_3op_tc_1_SLOT0123, TypeALU32_3op>, Enc_8605375 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110110100;
let hasNewValue = 1;
let opNewValue = 0;
let InputType = "reg";
}
def A2_svsubhs : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = vsubh($Rt32,$Rs32):sat",
ALU32_3op_tc_2_SLOT0123, TypeALU32_3op>, Enc_8605375 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110110101;
let hasNewValue = 1;
let opNewValue = 0;
let Defs = [USR_OVF];
let InputType = "reg";
}
def A2_svsubuhs : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = vsubuh($Rt32,$Rs32):sat",
ALU32_3op_tc_2_SLOT0123, TypeALU32_3op>, Enc_8605375 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110110111;
let hasNewValue = 1;
let opNewValue = 0;
let Defs = [USR_OVF];
let InputType = "reg";
}
def A2_swiz : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = swiz($Rs32)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_4075554 {
let Inst{13-5} = 0b000000111;
let Inst{31-21} = 0b10001100100;
let hasNewValue = 1;
let opNewValue = 0;
}
def A2_sxtb : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = sxtb($Rs32)",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_4075554, PredNewRel {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b01110000101;
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_sxtb";
let isPredicable = 1;
}
def A2_sxth : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = sxth($Rs32)",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_4075554, PredNewRel {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b01110000111;
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_sxth";
let isPredicable = 1;
}
def A2_sxtw : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32),
"$Rdd32 = sxtw($Rs32)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_4030179 {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b10000100010;
}
def A2_tfr : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = $Rs32",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_4075554, PredNewRel {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b01110000011;
let hasNewValue = 1;
let opNewValue = 0;
let InputType = "reg";
let BaseOpcode = "A2_tfr";
let isPredicable = 1;
}
def A2_tfrcrr : HInst<
(outs IntRegs:$Rd32),
(ins CtrRegs:$Cs32),
"$Rd32 = $Cs32",
CR_tc_3x_SLOT3, TypeCR>, Enc_1539665 {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b01101010000;
let hasNewValue = 1;
let opNewValue = 0;
}
def A2_tfrf : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if (!$Pu4) $Rd32 = $Rs32",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, PredNewRel, ImmRegRel {
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let CextOpcode = "A2_tfr";
let InputType = "reg";
let BaseOpcode = "A2_tfr";
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def A2_tfrfnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if (!$Pu4.new) $Rd32 = $Rs32",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, PredNewRel, ImmRegRel {
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let CextOpcode = "A2_tfr";
let InputType = "reg";
let BaseOpcode = "A2_tfr";
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def A2_tfrih : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, u16_0Imm:$Ii),
"$Rx32.h = #$Ii",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_6130414 {
let Inst{21-21} = 0b1;
let Inst{31-24} = 0b01110010;
let hasNewValue = 1;
let opNewValue = 0;
let Constraints = "$Rx32 = $Rx32in";
}
def A2_tfril : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, u16_0Imm:$Ii),
"$Rx32.l = #$Ii",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_6130414 {
let Inst{21-21} = 0b1;
let Inst{31-24} = 0b01110001;
let hasNewValue = 1;
let opNewValue = 0;
let Constraints = "$Rx32 = $Rx32in";
}
def A2_tfrp : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32),
"$Rdd32 = $Rss32",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, PredNewRel {
let BaseOpcode = "A2_tfrp";
let isPredicable = 1;
let isPseudo = 1;
}
def A2_tfrpf : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pu4, DoubleRegs:$Rss32),
"if (!$Pu4) $Rdd32 = $Rss32",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, PredNewRel {
let isPredicated = 1;
let isPredicatedFalse = 1;
let BaseOpcode = "A2_tfrp";
let isPseudo = 1;
}
def A2_tfrpfnew : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pu4, DoubleRegs:$Rss32),
"if (!$Pu4.new) $Rdd32 = $Rss32",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, PredNewRel {
let isPredicated = 1;
let isPredicatedFalse = 1;
let isPredicatedNew = 1;
let BaseOpcode = "A2_tfrp";
let isPseudo = 1;
}
def A2_tfrpi : HInst<
(outs DoubleRegs:$Rdd32),
(ins s8_0Imm:$Ii),
"$Rdd32 = #$Ii",
ALU64_tc_1_SLOT23, TypeALU64> {
let isReMaterializable = 1;
let isAsCheapAsAMove = 1;
let isMoveImm = 1;
let isPseudo = 1;
}
def A2_tfrpt : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pu4, DoubleRegs:$Rss32),
"if ($Pu4) $Rdd32 = $Rss32",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, PredNewRel {
let isPredicated = 1;
let BaseOpcode = "A2_tfrp";
let isPseudo = 1;
}
def A2_tfrptnew : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pu4, DoubleRegs:$Rss32),
"if ($Pu4.new) $Rdd32 = $Rss32",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, PredNewRel {
let isPredicated = 1;
let isPredicatedNew = 1;
let BaseOpcode = "A2_tfrp";
let isPseudo = 1;
}
def A2_tfrrcr : HInst<
(outs CtrRegs:$Cd32),
(ins IntRegs:$Rs32),
"$Cd32 = $Rs32",
CR_tc_3x_SLOT3, TypeCR>, Enc_9018141 {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b01100010001;
let hasNewValue = 1;
let opNewValue = 0;
}
def A2_tfrsi : HInst<
(outs IntRegs:$Rd32),
(ins s32_0Imm:$Ii),
"$Rd32 = #$Ii",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_7971062, PredNewRel, ImmRegRel {
let Inst{21-21} = 0b0;
let Inst{31-24} = 0b01111000;
let hasNewValue = 1;
let opNewValue = 0;
let CextOpcode = "A2_tfr";
let InputType = "imm";
let BaseOpcode = "A2_tfrsi";
let isPredicable = 1;
let isReMaterializable = 1;
let isAsCheapAsAMove = 1;
let isMoveImm = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 16;
let opExtentAlign = 0;
}
def A2_tfrt : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if ($Pu4) $Rd32 = $Rs32",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, PredNewRel, ImmRegRel {
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let CextOpcode = "A2_tfr";
let InputType = "reg";
let BaseOpcode = "A2_tfr";
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def A2_tfrtnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if ($Pu4.new) $Rd32 = $Rs32",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, PredNewRel, ImmRegRel {
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let CextOpcode = "A2_tfr";
let InputType = "reg";
let BaseOpcode = "A2_tfr";
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def A2_vabsh : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32),
"$Rdd32 = vabsh($Rss32)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_13133231 {
let Inst{13-5} = 0b000000100;
let Inst{31-21} = 0b10000000010;
}
def A2_vabshsat : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32),
"$Rdd32 = vabsh($Rss32):sat",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_13133231 {
let Inst{13-5} = 0b000000101;
let Inst{31-21} = 0b10000000010;
let Defs = [USR_OVF];
}
def A2_vabsw : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32),
"$Rdd32 = vabsw($Rss32)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_13133231 {
let Inst{13-5} = 0b000000110;
let Inst{31-21} = 0b10000000010;
}
def A2_vabswsat : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32),
"$Rdd32 = vabsw($Rss32):sat",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_13133231 {
let Inst{13-5} = 0b000000111;
let Inst{31-21} = 0b10000000010;
let Defs = [USR_OVF];
}
def A2_vaddb_map : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vaddb($Rss32,$Rtt32)",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def A2_vaddh : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vaddh($Rss32,$Rtt32)",
ALU64_tc_1_SLOT23, TypeALU64>, Enc_8333157 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011000;
}
def A2_vaddhs : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vaddh($Rss32,$Rtt32):sat",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_8333157 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011000;
let Defs = [USR_OVF];
}
def A2_vaddub : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vaddub($Rss32,$Rtt32)",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_8333157 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011000;
}
def A2_vaddubs : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vaddub($Rss32,$Rtt32):sat",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_8333157 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011000;
let Defs = [USR_OVF];
}
def A2_vadduhs : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vadduh($Rss32,$Rtt32):sat",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_8333157 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011000;
let Defs = [USR_OVF];
}
def A2_vaddw : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vaddw($Rss32,$Rtt32)",
ALU64_tc_1_SLOT23, TypeALU64>, Enc_8333157 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011000;
}
def A2_vaddws : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vaddw($Rss32,$Rtt32):sat",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_8333157 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011000;
let Defs = [USR_OVF];
}
def A2_vavgh : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vavgh($Rss32,$Rtt32)",
ALU64_tc_1_SLOT23, TypeALU64>, Enc_8333157 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011010;
}
def A2_vavghcr : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vavgh($Rss32,$Rtt32):crnd",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_8333157 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011010;
let prefersSlot3 = 1;
}
def A2_vavghr : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vavgh($Rss32,$Rtt32):rnd",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_8333157 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011010;
}
def A2_vavgub : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vavgub($Rss32,$Rtt32)",
ALU64_tc_1_SLOT23, TypeALU64>, Enc_8333157 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011010;
}
def A2_vavgubr : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vavgub($Rss32,$Rtt32):rnd",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_8333157 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011010;
}
def A2_vavguh : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vavguh($Rss32,$Rtt32)",
ALU64_tc_1_SLOT23, TypeALU64>, Enc_8333157 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011010;
}
def A2_vavguhr : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vavguh($Rss32,$Rtt32):rnd",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_8333157 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011010;
}
def A2_vavguw : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vavguw($Rss32,$Rtt32)",
ALU64_tc_1_SLOT23, TypeALU64>, Enc_8333157 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011011;
}
def A2_vavguwr : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vavguw($Rss32,$Rtt32):rnd",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_8333157 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011011;
}
def A2_vavgw : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vavgw($Rss32,$Rtt32)",
ALU64_tc_1_SLOT23, TypeALU64>, Enc_8333157 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011011;
}
def A2_vavgwcr : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vavgw($Rss32,$Rtt32):crnd",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_8333157 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011011;
let prefersSlot3 = 1;
}
def A2_vavgwr : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vavgw($Rss32,$Rtt32):rnd",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_8333157 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011011;
}
def A2_vcmpbeq : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Pd4 = vcmpb.eq($Rss32,$Rtt32)",
ALU64_tc_2early_SLOT23, TypeALU64>, Enc_3831744 {
let Inst{7-2} = 0b110000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010010000;
}
def A2_vcmpbgtu : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Pd4 = vcmpb.gtu($Rss32,$Rtt32)",
ALU64_tc_2early_SLOT23, TypeALU64>, Enc_3831744 {
let Inst{7-2} = 0b111000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010010000;
}
def A2_vcmpheq : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Pd4 = vcmph.eq($Rss32,$Rtt32)",
ALU64_tc_2early_SLOT23, TypeALU64>, Enc_3831744 {
let Inst{7-2} = 0b011000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010010000;
}
def A2_vcmphgt : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Pd4 = vcmph.gt($Rss32,$Rtt32)",
ALU64_tc_2early_SLOT23, TypeALU64>, Enc_3831744 {
let Inst{7-2} = 0b100000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010010000;
}
def A2_vcmphgtu : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Pd4 = vcmph.gtu($Rss32,$Rtt32)",
ALU64_tc_2early_SLOT23, TypeALU64>, Enc_3831744 {
let Inst{7-2} = 0b101000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010010000;
}
def A2_vcmpweq : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Pd4 = vcmpw.eq($Rss32,$Rtt32)",
ALU64_tc_2early_SLOT23, TypeALU64>, Enc_3831744 {
let Inst{7-2} = 0b000000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010010000;
}
def A2_vcmpwgt : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Pd4 = vcmpw.gt($Rss32,$Rtt32)",
ALU64_tc_2early_SLOT23, TypeALU64>, Enc_3831744 {
let Inst{7-2} = 0b001000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010010000;
}
def A2_vcmpwgtu : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Pd4 = vcmpw.gtu($Rss32,$Rtt32)",
ALU64_tc_2early_SLOT23, TypeALU64>, Enc_3831744 {
let Inst{7-2} = 0b010000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010010000;
}
def A2_vconj : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32),
"$Rdd32 = vconj($Rss32):sat",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_13133231 {
let Inst{13-5} = 0b000000111;
let Inst{31-21} = 0b10000000100;
let Defs = [USR_OVF];
}
def A2_vmaxb : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vmaxb($Rtt32,$Rss32)",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_11687333 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011110;
}
def A2_vmaxh : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vmaxh($Rtt32,$Rss32)",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_11687333 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011110;
}
def A2_vmaxub : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vmaxub($Rtt32,$Rss32)",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_11687333 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011110;
}
def A2_vmaxuh : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vmaxuh($Rtt32,$Rss32)",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_11687333 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011110;
}
def A2_vmaxuw : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vmaxuw($Rtt32,$Rss32)",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_11687333 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011101;
}
def A2_vmaxw : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vmaxw($Rtt32,$Rss32)",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_11687333 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011110;
}
def A2_vminb : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vminb($Rtt32,$Rss32)",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_11687333 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011110;
}
def A2_vminh : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vminh($Rtt32,$Rss32)",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_11687333 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011101;
}
def A2_vminub : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vminub($Rtt32,$Rss32)",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_11687333 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011101;
}
def A2_vminuh : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vminuh($Rtt32,$Rss32)",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_11687333 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011101;
}
def A2_vminuw : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vminuw($Rtt32,$Rss32)",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_11687333 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011101;
}
def A2_vminw : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vminw($Rtt32,$Rss32)",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_11687333 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011101;
}
def A2_vnavgh : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vnavgh($Rtt32,$Rss32)",
ALU64_tc_1_SLOT23, TypeALU64>, Enc_11687333 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011100;
}
def A2_vnavghcr : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vnavgh($Rtt32,$Rss32):crnd:sat",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_11687333 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011100;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def A2_vnavghr : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vnavgh($Rtt32,$Rss32):rnd:sat",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_11687333 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011100;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def A2_vnavgw : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vnavgw($Rtt32,$Rss32)",
ALU64_tc_1_SLOT23, TypeALU64>, Enc_11687333 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011100;
}
def A2_vnavgwcr : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vnavgw($Rtt32,$Rss32):crnd:sat",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_11687333 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011100;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def A2_vnavgwr : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vnavgw($Rtt32,$Rss32):rnd:sat",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_11687333 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011100;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def A2_vraddub : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vraddub($Rss32,$Rtt32)",
M_tc_3x_SLOT23, TypeM>, Enc_8333157 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000010;
let prefersSlot3 = 1;
}
def A2_vraddub_acc : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vraddub($Rss32,$Rtt32)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_12702821 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010010;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def A2_vrsadub : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vrsadub($Rss32,$Rtt32)",
M_tc_3x_SLOT23, TypeM>, Enc_8333157 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000010;
let prefersSlot3 = 1;
}
def A2_vrsadub_acc : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vrsadub($Rss32,$Rtt32)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_12702821 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010010;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def A2_vsubb_map : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vsubb($Rss32,$Rtt32)",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def A2_vsubh : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vsubh($Rtt32,$Rss32)",
ALU64_tc_1_SLOT23, TypeALU64>, Enc_11687333 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011001;
}
def A2_vsubhs : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vsubh($Rtt32,$Rss32):sat",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_11687333 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011001;
let Defs = [USR_OVF];
}
def A2_vsubub : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vsubub($Rtt32,$Rss32)",
ALU64_tc_1_SLOT23, TypeALU64>, Enc_11687333 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011001;
}
def A2_vsububs : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vsubub($Rtt32,$Rss32):sat",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_11687333 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011001;
let Defs = [USR_OVF];
}
def A2_vsubuhs : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vsubuh($Rtt32,$Rss32):sat",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_11687333 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011001;
let Defs = [USR_OVF];
}
def A2_vsubw : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vsubw($Rtt32,$Rss32)",
ALU64_tc_1_SLOT23, TypeALU64>, Enc_11687333 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011001;
}
def A2_vsubws : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vsubw($Rtt32,$Rss32):sat",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_11687333 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011001;
let Defs = [USR_OVF];
}
def A2_xor : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = xor($Rs32,$Rt32)",
ALU32_3op_tc_1_SLOT0123, TypeALU32_3op>, Enc_14071773, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110001011;
let hasNewValue = 1;
let opNewValue = 0;
let InputType = "reg";
let BaseOpcode = "A2_xor";
let isCommutable = 1;
let isPredicable = 1;
}
def A2_xorp : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = xor($Rss32,$Rtt32)",
ALU64_tc_1_SLOT23, TypeALU64>, Enc_8333157 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011111;
let isCommutable = 1;
}
def A2_zxtb : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = zxtb($Rs32)",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, PredNewRel {
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_zxtb";
let isPredicable = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def A2_zxth : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = zxth($Rs32)",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_4075554, PredNewRel {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b01110000110;
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_zxth";
let isPredicable = 1;
}
def A4_addp_c : HInst<
(outs DoubleRegs:$Rdd32, PredRegs:$Px4),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32, PredRegs:$Px4in),
"$Rdd32 = add($Rss32,$Rtt32,$Px4):carry",
S_3op_tc_1_SLOT23, TypeS_3op>, Enc_151014 {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000010110;
let isPredicateLate = 1;
let Constraints = "$Px4 = $Px4in";
}
def A4_andn : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = and($Rt32,~$Rs32)",
ALU32_3op_tc_1_SLOT0123, TypeALU32_3op>, Enc_8605375 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110001100;
let hasNewValue = 1;
let opNewValue = 0;
let InputType = "reg";
}
def A4_andnp : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = and($Rtt32,~$Rss32)",
ALU64_tc_1_SLOT23, TypeALU64>, Enc_11687333 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011111;
}
def A4_bitsplit : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = bitsplit($Rs32,$Rt32)",
ALU64_tc_1_SLOT23, TypeALU64>, Enc_1997594 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010100001;
}
def A4_bitspliti : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rdd32 = bitsplit($Rs32,#$Ii)",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_5654851 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001000110;
}
def A4_boundscheck : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, DoubleRegs:$Rtt32),
"$Pd4 = boundscheck($Rs32,$Rtt32)",
M_tc_3x_SLOT23, TypeALU64> {
let isPseudo = 1;
}
def A4_boundscheck_hi : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Pd4 = boundscheck($Rss32,$Rtt32):raw:hi",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_3831744 {
let Inst{7-2} = 0b101000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b11010010000;
}
def A4_boundscheck_lo : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Pd4 = boundscheck($Rss32,$Rtt32):raw:lo",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_3831744 {
let Inst{7-2} = 0b100000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b11010010000;
}
def A4_cmpbeq : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Pd4 = cmpb.eq($Rs32,$Rt32)",
S_3op_tc_2early_SLOT23, TypeS_3op>, Enc_10157519, ImmRegRel {
let Inst{7-2} = 0b110000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000111110;
let CextOpcode = "A4_cmpbeq";
let InputType = "reg";
let isCommutable = 1;
let isCompare = 1;
}
def A4_cmpbeqi : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, u8_0Imm:$Ii),
"$Pd4 = cmpb.eq($Rs32,#$Ii)",
ALU64_tc_2early_SLOT23, TypeALU64>, Enc_6736678, ImmRegRel {
let Inst{4-2} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11011101000;
let CextOpcode = "A4_cmpbeq";
let InputType = "imm";
let isCommutable = 1;
let isCompare = 1;
}
def A4_cmpbgt : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Pd4 = cmpb.gt($Rs32,$Rt32)",
S_3op_tc_2early_SLOT23, TypeS_3op>, Enc_10157519, ImmRegRel {
let Inst{7-2} = 0b010000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000111110;
let CextOpcode = "A4_cmpbgt";
let InputType = "reg";
let isCompare = 1;
}
def A4_cmpbgti : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, s8_0Imm:$Ii),
"$Pd4 = cmpb.gt($Rs32,#$Ii)",
ALU64_tc_2early_SLOT23, TypeALU64>, Enc_6736678, ImmRegRel {
let Inst{4-2} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11011101001;
let CextOpcode = "A4_cmpbgt";
let InputType = "imm";
let isCompare = 1;
}
def A4_cmpbgtu : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Pd4 = cmpb.gtu($Rs32,$Rt32)",
S_3op_tc_2early_SLOT23, TypeS_3op>, Enc_10157519, ImmRegRel {
let Inst{7-2} = 0b111000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000111110;
let CextOpcode = "A4_cmpbgtu";
let InputType = "reg";
let isCompare = 1;
}
def A4_cmpbgtui : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, u32_0Imm:$Ii),
"$Pd4 = cmpb.gtu($Rs32,#$Ii)",
ALU64_tc_2early_SLOT23, TypeALU64>, Enc_3531000, ImmRegRel {
let Inst{4-2} = 0b000;
let Inst{13-12} = 0b00;
let Inst{31-21} = 0b11011101010;
let CextOpcode = "A4_cmpbgtu";
let InputType = "imm";
let isCompare = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 0;
}
def A4_cmpheq : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Pd4 = cmph.eq($Rs32,$Rt32)",
S_3op_tc_2early_SLOT23, TypeS_3op>, Enc_10157519, ImmRegRel {
let Inst{7-2} = 0b011000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000111110;
let CextOpcode = "A4_cmpheq";
let InputType = "reg";
let isCommutable = 1;
let isCompare = 1;
}
def A4_cmpheqi : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, s32_0Imm:$Ii),
"$Pd4 = cmph.eq($Rs32,#$Ii)",
ALU64_tc_2early_SLOT23, TypeALU64>, Enc_6736678, ImmRegRel {
let Inst{4-2} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11011101000;
let CextOpcode = "A4_cmpheq";
let InputType = "imm";
let isCommutable = 1;
let isCompare = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 8;
let opExtentAlign = 0;
}
def A4_cmphgt : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Pd4 = cmph.gt($Rs32,$Rt32)",
S_3op_tc_2early_SLOT23, TypeS_3op>, Enc_10157519, ImmRegRel {
let Inst{7-2} = 0b100000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000111110;
let CextOpcode = "A4_cmphgt";
let InputType = "reg";
let isCompare = 1;
}
def A4_cmphgti : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, s32_0Imm:$Ii),
"$Pd4 = cmph.gt($Rs32,#$Ii)",
ALU64_tc_2early_SLOT23, TypeALU64>, Enc_6736678, ImmRegRel {
let Inst{4-2} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11011101001;
let CextOpcode = "A4_cmphgt";
let InputType = "imm";
let isCompare = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 8;
let opExtentAlign = 0;
}
def A4_cmphgtu : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Pd4 = cmph.gtu($Rs32,$Rt32)",
S_3op_tc_2early_SLOT23, TypeS_3op>, Enc_10157519, ImmRegRel {
let Inst{7-2} = 0b101000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000111110;
let CextOpcode = "A4_cmphgtu";
let InputType = "reg";
let isCompare = 1;
}
def A4_cmphgtui : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, u32_0Imm:$Ii),
"$Pd4 = cmph.gtu($Rs32,#$Ii)",
ALU64_tc_2early_SLOT23, TypeALU64>, Enc_3531000, ImmRegRel {
let Inst{4-2} = 0b010;
let Inst{13-12} = 0b00;
let Inst{31-21} = 0b11011101010;
let CextOpcode = "A4_cmphgtu";
let InputType = "imm";
let isCompare = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 0;
}
def A4_combineii : HInst<
(outs DoubleRegs:$Rdd32),
(ins s8_0Imm:$Ii, u32_0Imm:$II),
"$Rdd32 = combine(#$Ii,#$II)",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_9864697 {
let Inst{31-21} = 0b01111100100;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def A4_combineir : HInst<
(outs DoubleRegs:$Rdd32),
(ins s32_0Imm:$Ii, IntRegs:$Rs32),
"$Rdd32 = combine(#$Ii,$Rs32)",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_2462143 {
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b01110011001;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 8;
let opExtentAlign = 0;
}
def A4_combineri : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, s32_0Imm:$Ii),
"$Rdd32 = combine($Rs32,#$Ii)",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_2462143 {
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b01110011000;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 8;
let opExtentAlign = 0;
}
def A4_cround_ri : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rd32 = cround($Rs32,#$Ii)",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_2771456 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001100111;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def A4_cround_rr : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = cround($Rs32,$Rt32)",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_14071773 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000110110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def A4_ext : HInst<
(outs),
(ins u26_6Imm:$Ii),
"immext(#$Ii)",
EXTENDER_tc_1_SLOT0123, TypeEXTENDER>, Enc_2082956 {
let Inst{31-28} = 0b0000;
}
def A4_modwrapu : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = modwrap($Rs32,$Rt32)",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_14071773 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011111;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def A4_orn : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = or($Rt32,~$Rs32)",
ALU32_3op_tc_1_SLOT0123, TypeALU32_3op>, Enc_8605375 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110001101;
let hasNewValue = 1;
let opNewValue = 0;
let InputType = "reg";
}
def A4_ornp : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = or($Rtt32,~$Rss32)",
ALU64_tc_1_SLOT23, TypeALU64>, Enc_11687333 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011111;
}
def A4_paslhf : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if (!$Pu4) $Rd32 = aslh($Rs32)",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_9422954, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1010;
let Inst{31-21} = 0b01110000000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_aslh";
}
def A4_paslhfnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if (!$Pu4.new) $Rd32 = aslh($Rs32)",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_9422954, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1011;
let Inst{31-21} = 0b01110000000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let BaseOpcode = "A2_aslh";
}
def A4_paslht : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if ($Pu4) $Rd32 = aslh($Rs32)",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_9422954, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1000;
let Inst{31-21} = 0b01110000000;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_aslh";
}
def A4_paslhtnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if ($Pu4.new) $Rd32 = aslh($Rs32)",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_9422954, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1001;
let Inst{31-21} = 0b01110000000;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let BaseOpcode = "A2_aslh";
}
def A4_pasrhf : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if (!$Pu4) $Rd32 = asrh($Rs32)",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_9422954, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1010;
let Inst{31-21} = 0b01110000001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_asrh";
}
def A4_pasrhfnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if (!$Pu4.new) $Rd32 = asrh($Rs32)",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_9422954, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1011;
let Inst{31-21} = 0b01110000001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let BaseOpcode = "A2_asrh";
}
def A4_pasrht : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if ($Pu4) $Rd32 = asrh($Rs32)",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_9422954, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1000;
let Inst{31-21} = 0b01110000001;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_asrh";
}
def A4_pasrhtnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if ($Pu4.new) $Rd32 = asrh($Rs32)",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_9422954, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1001;
let Inst{31-21} = 0b01110000001;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let BaseOpcode = "A2_asrh";
}
def A4_psxtbf : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if (!$Pu4) $Rd32 = sxtb($Rs32)",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_9422954, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1010;
let Inst{31-21} = 0b01110000101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_sxtb";
}
def A4_psxtbfnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if (!$Pu4.new) $Rd32 = sxtb($Rs32)",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_9422954, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1011;
let Inst{31-21} = 0b01110000101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let BaseOpcode = "A2_sxtb";
}
def A4_psxtbt : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if ($Pu4) $Rd32 = sxtb($Rs32)",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_9422954, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1000;
let Inst{31-21} = 0b01110000101;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_sxtb";
}
def A4_psxtbtnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if ($Pu4.new) $Rd32 = sxtb($Rs32)",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_9422954, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1001;
let Inst{31-21} = 0b01110000101;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let BaseOpcode = "A2_sxtb";
}
def A4_psxthf : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if (!$Pu4) $Rd32 = sxth($Rs32)",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_9422954, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1010;
let Inst{31-21} = 0b01110000111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_sxth";
}
def A4_psxthfnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if (!$Pu4.new) $Rd32 = sxth($Rs32)",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_9422954, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1011;
let Inst{31-21} = 0b01110000111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let BaseOpcode = "A2_sxth";
}
def A4_psxtht : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if ($Pu4) $Rd32 = sxth($Rs32)",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_9422954, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1000;
let Inst{31-21} = 0b01110000111;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_sxth";
}
def A4_psxthtnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if ($Pu4.new) $Rd32 = sxth($Rs32)",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_9422954, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1001;
let Inst{31-21} = 0b01110000111;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let BaseOpcode = "A2_sxth";
}
def A4_pzxtbf : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if (!$Pu4) $Rd32 = zxtb($Rs32)",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_9422954, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1010;
let Inst{31-21} = 0b01110000100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_zxtb";
}
def A4_pzxtbfnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if (!$Pu4.new) $Rd32 = zxtb($Rs32)",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_9422954, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1011;
let Inst{31-21} = 0b01110000100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let BaseOpcode = "A2_zxtb";
}
def A4_pzxtbt : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if ($Pu4) $Rd32 = zxtb($Rs32)",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_9422954, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1000;
let Inst{31-21} = 0b01110000100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_zxtb";
}
def A4_pzxtbtnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if ($Pu4.new) $Rd32 = zxtb($Rs32)",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_9422954, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1001;
let Inst{31-21} = 0b01110000100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let BaseOpcode = "A2_zxtb";
}
def A4_pzxthf : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if (!$Pu4) $Rd32 = zxth($Rs32)",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_9422954, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1010;
let Inst{31-21} = 0b01110000110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_zxth";
}
def A4_pzxthfnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if (!$Pu4.new) $Rd32 = zxth($Rs32)",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_9422954, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1011;
let Inst{31-21} = 0b01110000110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let BaseOpcode = "A2_zxth";
}
def A4_pzxtht : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if ($Pu4) $Rd32 = zxth($Rs32)",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_9422954, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1000;
let Inst{31-21} = 0b01110000110;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_zxth";
}
def A4_pzxthtnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if ($Pu4.new) $Rd32 = zxth($Rs32)",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_9422954, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1001;
let Inst{31-21} = 0b01110000110;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let BaseOpcode = "A2_zxth";
}
def A4_rcmpeq : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = cmp.eq($Rs32,$Rt32)",
ALU32_3op_tc_1_SLOT0123, TypeALU32_3op>, Enc_14071773, ImmRegRel {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110011010;
let hasNewValue = 1;
let opNewValue = 0;
let CextOpcode = "A4_rcmpeq";
let InputType = "reg";
let isCommutable = 1;
}
def A4_rcmpeqi : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, s32_0Imm:$Ii),
"$Rd32 = cmp.eq($Rs32,#$Ii)",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_16355964, ImmRegRel {
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b01110011010;
let hasNewValue = 1;
let opNewValue = 0;
let CextOpcode = "A4_rcmpeqi";
let InputType = "imm";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 8;
let opExtentAlign = 0;
}
def A4_rcmpneq : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = !cmp.eq($Rs32,$Rt32)",
ALU32_3op_tc_1_SLOT0123, TypeALU32_3op>, Enc_14071773, ImmRegRel {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110011011;
let hasNewValue = 1;
let opNewValue = 0;
let CextOpcode = "A4_rcmpneq";
let InputType = "reg";
let isCommutable = 1;
}
def A4_rcmpneqi : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, s32_0Imm:$Ii),
"$Rd32 = !cmp.eq($Rs32,#$Ii)",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_16355964, ImmRegRel {
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b01110011011;
let hasNewValue = 1;
let opNewValue = 0;
let CextOpcode = "A4_rcmpeqi";
let InputType = "imm";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 8;
let opExtentAlign = 0;
}
def A4_round_ri : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rd32 = round($Rs32,#$Ii)",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_2771456 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001100111;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def A4_round_ri_sat : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rd32 = round($Rs32,#$Ii):sat",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_2771456 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001100111;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def A4_round_rr : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = round($Rs32,$Rt32)",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_14071773 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000110110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def A4_round_rr_sat : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = round($Rs32,$Rt32):sat",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_14071773 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000110110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def A4_subp_c : HInst<
(outs DoubleRegs:$Rdd32, PredRegs:$Px4),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32, PredRegs:$Px4in),
"$Rdd32 = sub($Rss32,$Rtt32,$Px4):carry",
S_3op_tc_1_SLOT23, TypeS_3op>, Enc_151014 {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000010111;
let isPredicateLate = 1;
let Constraints = "$Px4 = $Px4in";
}
def A4_tfrcpp : HInst<
(outs DoubleRegs:$Rdd32),
(ins CtrRegs64:$Css32),
"$Rdd32 = $Css32",
CR_tc_3x_SLOT3, TypeCR>, Enc_13094118 {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b01101000000;
}
def A4_tfrpcp : HInst<
(outs CtrRegs64:$Cdd32),
(ins DoubleRegs:$Rss32),
"$Cdd32 = $Rss32",
CR_tc_3x_SLOT3, TypeCR>, Enc_1329520 {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b01100011001;
}
def A4_tlbmatch : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Pd4 = tlbmatch($Rss32,$Rt32)",
ALU64_tc_2early_SLOT23, TypeALU64>, Enc_2492727 {
let Inst{7-2} = 0b011000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b11010010000;
let isPredicateLate = 1;
}
def A4_vcmpbeq_any : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Pd4 = any8(vcmpb.eq($Rss32,$Rtt32))",
ALU64_tc_2early_SLOT23, TypeALU64>, Enc_3831744 {
let Inst{7-2} = 0b000000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b11010010000;
}
def A4_vcmpbeqi : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, u8_0Imm:$Ii),
"$Pd4 = vcmpb.eq($Rss32,#$Ii)",
ALU64_tc_2early_SLOT23, TypeALU64>, Enc_13455308 {
let Inst{4-2} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11011100000;
}
def A4_vcmpbgt : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Pd4 = vcmpb.gt($Rss32,$Rtt32)",
ALU64_tc_2early_SLOT23, TypeALU64>, Enc_3831744 {
let Inst{7-2} = 0b010000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b11010010000;
}
def A4_vcmpbgti : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, s8_0Imm:$Ii),
"$Pd4 = vcmpb.gt($Rss32,#$Ii)",
ALU64_tc_2early_SLOT23, TypeALU64>, Enc_13455308 {
let Inst{4-2} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11011100001;
}
def A4_vcmpbgtui : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, u7_0Imm:$Ii),
"$Pd4 = vcmpb.gtu($Rss32,#$Ii)",
ALU64_tc_2early_SLOT23, TypeALU64>, Enc_2968094 {
let Inst{4-2} = 0b000;
let Inst{13-12} = 0b00;
let Inst{31-21} = 0b11011100010;
}
def A4_vcmpheqi : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, s8_0Imm:$Ii),
"$Pd4 = vcmph.eq($Rss32,#$Ii)",
ALU64_tc_2early_SLOT23, TypeALU64>, Enc_13455308 {
let Inst{4-2} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11011100000;
}
def A4_vcmphgti : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, s8_0Imm:$Ii),
"$Pd4 = vcmph.gt($Rss32,#$Ii)",
ALU64_tc_2early_SLOT23, TypeALU64>, Enc_13455308 {
let Inst{4-2} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11011100001;
}
def A4_vcmphgtui : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, u7_0Imm:$Ii),
"$Pd4 = vcmph.gtu($Rss32,#$Ii)",
ALU64_tc_2early_SLOT23, TypeALU64>, Enc_2968094 {
let Inst{4-2} = 0b010;
let Inst{13-12} = 0b00;
let Inst{31-21} = 0b11011100010;
}
def A4_vcmpweqi : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, s8_0Imm:$Ii),
"$Pd4 = vcmpw.eq($Rss32,#$Ii)",
ALU64_tc_2early_SLOT23, TypeALU64>, Enc_13455308 {
let Inst{4-2} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11011100000;
}
def A4_vcmpwgti : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, s8_0Imm:$Ii),
"$Pd4 = vcmpw.gt($Rss32,#$Ii)",
ALU64_tc_2early_SLOT23, TypeALU64>, Enc_13455308 {
let Inst{4-2} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11011100001;
}
def A4_vcmpwgtui : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, u7_0Imm:$Ii),
"$Pd4 = vcmpw.gtu($Rss32,#$Ii)",
ALU64_tc_2early_SLOT23, TypeALU64>, Enc_2968094 {
let Inst{4-2} = 0b100;
let Inst{13-12} = 0b00;
let Inst{31-21} = 0b11011100010;
}
def A4_vrmaxh : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Ru32),
"$Rxx32 = vrmaxh($Rss32,$Ru32)",
S_3op_tc_3_SLOT23, TypeS_3op>, Enc_9773189 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001011001;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def A4_vrmaxuh : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Ru32),
"$Rxx32 = vrmaxuh($Rss32,$Ru32)",
S_3op_tc_3_SLOT23, TypeS_3op>, Enc_9773189 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b11001011001;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def A4_vrmaxuw : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Ru32),
"$Rxx32 = vrmaxuw($Rss32,$Ru32)",
S_3op_tc_3_SLOT23, TypeS_3op>, Enc_9773189 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b11001011001;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def A4_vrmaxw : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Ru32),
"$Rxx32 = vrmaxw($Rss32,$Ru32)",
S_3op_tc_3_SLOT23, TypeS_3op>, Enc_9773189 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001011001;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def A4_vrminh : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Ru32),
"$Rxx32 = vrminh($Rss32,$Ru32)",
S_3op_tc_3_SLOT23, TypeS_3op>, Enc_9773189 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001011001;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def A4_vrminuh : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Ru32),
"$Rxx32 = vrminuh($Rss32,$Ru32)",
S_3op_tc_3_SLOT23, TypeS_3op>, Enc_9773189 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b11001011001;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def A4_vrminuw : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Ru32),
"$Rxx32 = vrminuw($Rss32,$Ru32)",
S_3op_tc_3_SLOT23, TypeS_3op>, Enc_9773189 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b11001011001;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def A4_vrminw : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Ru32),
"$Rxx32 = vrminw($Rss32,$Ru32)",
S_3op_tc_3_SLOT23, TypeS_3op>, Enc_9773189 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001011001;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def A5_ACS : HInst<
(outs DoubleRegs:$Rxx32, PredRegs:$Pe4),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32,$Pe4 = vacsh($Rss32,$Rtt32)",
M_tc_3stall_SLOT23, TypeM>, Enc_12822813, Requires<[HasV55T]> {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010101;
let isPredicateLate = 1;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def A5_vaddhubs : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rd32 = vaddhub($Rss32,$Rtt32):sat",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_9277990, Requires<[HasV5T]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000001010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def A6_vminub_RdP : HInst<
(outs DoubleRegs:$Rdd32, PredRegs:$Pe4),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32,$Pe4 = vminub($Rtt32,$Rss32)",
M_tc_2_SLOT23, TypeM>, Enc_766909, Requires<[HasV62T]> {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010111;
let isPredicateLate = 1;
let prefersSlot3 = 1;
}
def C2_all8 : HInst<
(outs PredRegs:$Pd4),
(ins PredRegs:$Ps4),
"$Pd4 = all8($Ps4)",
CR_tc_2early_SLOT23, TypeCR>, Enc_6975103 {
let Inst{13-2} = 0b000000000000;
let Inst{31-18} = 0b01101011101000;
}
def C2_and : HInst<
(outs PredRegs:$Pd4),
(ins PredRegs:$Pt4, PredRegs:$Ps4),
"$Pd4 = and($Pt4,$Ps4)",
CR_tc_2early_SLOT23, TypeCR>, Enc_8891794 {
let Inst{7-2} = 0b000000;
let Inst{13-10} = 0b0000;
let Inst{31-18} = 0b01101011000000;
}
def C2_andn : HInst<
(outs PredRegs:$Pd4),
(ins PredRegs:$Pt4, PredRegs:$Ps4),
"$Pd4 = and($Pt4,!$Ps4)",
CR_tc_2early_SLOT23, TypeCR>, Enc_8891794 {
let Inst{7-2} = 0b000000;
let Inst{13-10} = 0b0000;
let Inst{31-18} = 0b01101011011000;
}
def C2_any8 : HInst<
(outs PredRegs:$Pd4),
(ins PredRegs:$Ps4),
"$Pd4 = any8($Ps4)",
CR_tc_2early_SLOT23, TypeCR>, Enc_6975103 {
let Inst{13-2} = 0b000000000000;
let Inst{31-18} = 0b01101011100000;
}
def C2_bitsclr : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Pd4 = bitsclr($Rs32,$Rt32)",
S_3op_tc_2early_SLOT23, TypeS_3op>, Enc_10157519 {
let Inst{7-2} = 0b000000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000111100;
}
def C2_bitsclri : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, u6_0Imm:$Ii),
"$Pd4 = bitsclr($Rs32,#$Ii)",
S_2op_tc_2early_SLOT23, TypeS_2op>, Enc_14574598 {
let Inst{7-2} = 0b000000;
let Inst{31-21} = 0b10000101100;
}
def C2_bitsset : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Pd4 = bitsset($Rs32,$Rt32)",
S_3op_tc_2early_SLOT23, TypeS_3op>, Enc_10157519 {
let Inst{7-2} = 0b000000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000111010;
}
def C2_ccombinewf : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, IntRegs:$Rt32),
"if (!$Pu4) $Rdd32 = combine($Rs32,$Rt32)",
ALU32_3op_tc_1_SLOT0123, TypeALU32_3op>, Enc_8202458, PredNewRel {
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11111101000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let BaseOpcode = "A2_combinew";
}
def C2_ccombinewnewf : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, IntRegs:$Rt32),
"if (!$Pu4.new) $Rdd32 = combine($Rs32,$Rt32)",
ALU32_3op_tc_1_SLOT0123, TypeALU32_3op>, Enc_8202458, PredNewRel {
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b11111101000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isPredicatedNew = 1;
let BaseOpcode = "A2_combinew";
}
def C2_ccombinewnewt : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, IntRegs:$Rt32),
"if ($Pu4.new) $Rdd32 = combine($Rs32,$Rt32)",
ALU32_3op_tc_1_SLOT0123, TypeALU32_3op>, Enc_8202458, PredNewRel {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b11111101000;
let isPredicated = 1;
let isPredicatedNew = 1;
let BaseOpcode = "A2_combinew";
}
def C2_ccombinewt : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, IntRegs:$Rt32),
"if ($Pu4) $Rdd32 = combine($Rs32,$Rt32)",
ALU32_3op_tc_1_SLOT0123, TypeALU32_3op>, Enc_8202458, PredNewRel {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11111101000;
let isPredicated = 1;
let BaseOpcode = "A2_combinew";
}
def C2_cmoveif : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, s32_0Imm:$Ii),
"if (!$Pu4) $Rd32 = #$Ii",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_9487067, PredNewRel, ImmRegRel {
let Inst{13-13} = 0b0;
let Inst{20-20} = 0b0;
let Inst{31-23} = 0b011111101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let CextOpcode = "A2_tfr";
let InputType = "imm";
let BaseOpcode = "A2_tfrsi";
let isMoveImm = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 12;
let opExtentAlign = 0;
}
def C2_cmoveit : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, s32_0Imm:$Ii),
"if ($Pu4) $Rd32 = #$Ii",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_9487067, PredNewRel, ImmRegRel {
let Inst{13-13} = 0b0;
let Inst{20-20} = 0b0;
let Inst{31-23} = 0b011111100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let CextOpcode = "A2_tfr";
let InputType = "imm";
let BaseOpcode = "A2_tfrsi";
let isMoveImm = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 12;
let opExtentAlign = 0;
}
def C2_cmovenewif : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, s32_0Imm:$Ii),
"if (!$Pu4.new) $Rd32 = #$Ii",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_9487067, PredNewRel, ImmRegRel {
let Inst{13-13} = 0b1;
let Inst{20-20} = 0b0;
let Inst{31-23} = 0b011111101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let CextOpcode = "A2_tfr";
let InputType = "imm";
let BaseOpcode = "A2_tfrsi";
let isMoveImm = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 12;
let opExtentAlign = 0;
}
def C2_cmovenewit : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, s32_0Imm:$Ii),
"if ($Pu4.new) $Rd32 = #$Ii",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_9487067, PredNewRel, ImmRegRel {
let Inst{13-13} = 0b1;
let Inst{20-20} = 0b0;
let Inst{31-23} = 0b011111100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let CextOpcode = "A2_tfr";
let InputType = "imm";
let BaseOpcode = "A2_tfrsi";
let isMoveImm = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 12;
let opExtentAlign = 0;
}
def C2_cmpeq : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Pd4 = cmp.eq($Rs32,$Rt32)",
ALU32_3op_tc_2early_SLOT0123, TypeALU32_3op>, Enc_10157519, ImmRegRel {
let Inst{7-2} = 0b000000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110010000;
let CextOpcode = "C2_cmpeq";
let InputType = "reg";
let isCommutable = 1;
let isCompare = 1;
}
def C2_cmpeqi : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, s32_0Imm:$Ii),
"$Pd4 = cmp.eq($Rs32,#$Ii)",
ALU32_2op_tc_2early_SLOT0123, TypeALU32_2op>, Enc_16014536, ImmRegRel {
let Inst{4-2} = 0b000;
let Inst{31-22} = 0b0111010100;
let CextOpcode = "C2_cmpeq";
let InputType = "imm";
let isCompare = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 10;
let opExtentAlign = 0;
}
def C2_cmpeqp : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Pd4 = cmp.eq($Rss32,$Rtt32)",
ALU64_tc_2early_SLOT23, TypeALU64>, Enc_3831744 {
let Inst{7-2} = 0b000000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010010100;
let isCommutable = 1;
let isCompare = 1;
}
def C2_cmpgei : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, s8_0Imm:$Ii),
"$Pd4 = cmp.ge($Rs32,#$Ii)",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op> {
let isCompare = 1;
let isPseudo = 1;
}
def C2_cmpgeui : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, u8_0Imm:$Ii),
"$Pd4 = cmp.geu($Rs32,#$Ii)",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op> {
let isCompare = 1;
let isPseudo = 1;
}
def C2_cmpgt : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Pd4 = cmp.gt($Rs32,$Rt32)",
ALU32_3op_tc_2early_SLOT0123, TypeALU32_3op>, Enc_10157519, ImmRegRel {
let Inst{7-2} = 0b000000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110010010;
let CextOpcode = "C2_cmpgt";
let InputType = "reg";
let isCompare = 1;
}
def C2_cmpgti : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, s32_0Imm:$Ii),
"$Pd4 = cmp.gt($Rs32,#$Ii)",
ALU32_2op_tc_2early_SLOT0123, TypeALU32_2op>, Enc_16014536, ImmRegRel {
let Inst{4-2} = 0b000;
let Inst{31-22} = 0b0111010101;
let CextOpcode = "C2_cmpgt";
let InputType = "imm";
let isCompare = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 10;
let opExtentAlign = 0;
}
def C2_cmpgtp : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Pd4 = cmp.gt($Rss32,$Rtt32)",
ALU64_tc_2early_SLOT23, TypeALU64>, Enc_3831744 {
let Inst{7-2} = 0b010000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010010100;
let isCompare = 1;
}
def C2_cmpgtu : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Pd4 = cmp.gtu($Rs32,$Rt32)",
ALU32_3op_tc_2early_SLOT0123, TypeALU32_3op>, Enc_10157519, ImmRegRel {
let Inst{7-2} = 0b000000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110010011;
let CextOpcode = "C2_cmpgtu";
let InputType = "reg";
let isCompare = 1;
}
def C2_cmpgtui : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, u32_0Imm:$Ii),
"$Pd4 = cmp.gtu($Rs32,#$Ii)",
ALU32_2op_tc_2early_SLOT0123, TypeALU32_2op>, Enc_13249928, ImmRegRel {
let Inst{4-2} = 0b000;
let Inst{31-21} = 0b01110101100;
let CextOpcode = "C2_cmpgtu";
let InputType = "imm";
let isCompare = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 9;
let opExtentAlign = 0;
}
def C2_cmpgtup : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Pd4 = cmp.gtu($Rss32,$Rtt32)",
ALU64_tc_2early_SLOT23, TypeALU64>, Enc_3831744 {
let Inst{7-2} = 0b100000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010010100;
let isCompare = 1;
}
def C2_cmplt : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Pd4 = cmp.lt($Rs32,$Rt32)",
PSEUDO, TypeALU32_3op> {
let isCompare = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def C2_cmpltu : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Pd4 = cmp.ltu($Rs32,$Rt32)",
PSEUDO, TypeALU32_3op> {
let isCompare = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def C2_mask : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pt4),
"$Rdd32 = mask($Pt4)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_10328975 {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b0000;
let Inst{31-16} = 0b1000011000000000;
}
def C2_mux : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mux($Pu4,$Rs32,$Rt32)",
ALU32_3op_tc_1_SLOT0123, TypeALU32_3op>, Enc_9626139 {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110100000;
let hasNewValue = 1;
let opNewValue = 0;
let InputType = "reg";
}
def C2_muxii : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, s32_0Imm:$Ii, s8_0Imm:$II),
"$Rd32 = mux($Pu4,#$Ii,#$II)",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_9093094 {
let Inst{31-25} = 0b0111101;
let hasNewValue = 1;
let opNewValue = 0;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 8;
let opExtentAlign = 0;
}
def C2_muxir : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, s32_0Imm:$Ii),
"$Rd32 = mux($Pu4,$Rs32,#$Ii)",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_10568534 {
let Inst{13-13} = 0b0;
let Inst{31-23} = 0b011100110;
let hasNewValue = 1;
let opNewValue = 0;
let InputType = "imm";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 1;
let opExtentBits = 8;
let opExtentAlign = 0;
}
def C2_muxri : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, s32_0Imm:$Ii, IntRegs:$Rs32),
"$Rd32 = mux($Pu4,#$Ii,$Rs32)",
ALU32_2op_tc_1_SLOT0123, TypeALU32_2op>, Enc_10568534 {
let Inst{13-13} = 0b0;
let Inst{31-23} = 0b011100111;
let hasNewValue = 1;
let opNewValue = 0;
let InputType = "imm";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 8;
let opExtentAlign = 0;
}
def C2_not : HInst<
(outs PredRegs:$Pd4),
(ins PredRegs:$Ps4),
"$Pd4 = not($Ps4)",
CR_tc_2early_SLOT23, TypeCR>, Enc_6975103 {
let Inst{13-2} = 0b000000000000;
let Inst{31-18} = 0b01101011110000;
}
def C2_or : HInst<
(outs PredRegs:$Pd4),
(ins PredRegs:$Pt4, PredRegs:$Ps4),
"$Pd4 = or($Pt4,$Ps4)",
CR_tc_2early_SLOT23, TypeCR>, Enc_8891794 {
let Inst{7-2} = 0b000000;
let Inst{13-10} = 0b0000;
let Inst{31-18} = 0b01101011001000;
}
def C2_orn : HInst<
(outs PredRegs:$Pd4),
(ins PredRegs:$Pt4, PredRegs:$Ps4),
"$Pd4 = or($Pt4,!$Ps4)",
CR_tc_2early_SLOT23, TypeCR>, Enc_8891794 {
let Inst{7-2} = 0b000000;
let Inst{13-10} = 0b0000;
let Inst{31-18} = 0b01101011111000;
}
def C2_pxfer_map : HInst<
(outs PredRegs:$Pd4),
(ins PredRegs:$Ps4),
"$Pd4 = $Ps4",
S_2op_tc_1_SLOT23, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def C2_tfrpr : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Ps4),
"$Rd32 = $Ps4",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_11139981 {
let Inst{13-5} = 0b000000000;
let Inst{31-18} = 0b10001001010000;
let hasNewValue = 1;
let opNewValue = 0;
}
def C2_tfrrp : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32),
"$Pd4 = $Rs32",
S_2op_tc_2early_SLOT23, TypeS_2op>, Enc_4527648 {
let Inst{13-2} = 0b000000000000;
let Inst{31-21} = 0b10000101010;
}
def C2_vitpack : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Ps4, PredRegs:$Pt4),
"$Rd32 = vitpack($Ps4,$Pt4)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_6735062 {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b0000;
let Inst{31-18} = 0b10001001000000;
let hasNewValue = 1;
let opNewValue = 0;
}
def C2_vmux : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pu4, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vmux($Pu4,$Rss32,$Rtt32)",
ALU64_tc_1_SLOT23, TypeALU64>, Enc_7606379 {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010001000;
}
def C2_xor : HInst<
(outs PredRegs:$Pd4),
(ins PredRegs:$Ps4, PredRegs:$Pt4),
"$Pd4 = xor($Ps4,$Pt4)",
CR_tc_2early_SLOT23, TypeCR>, Enc_8324216 {
let Inst{7-2} = 0b000000;
let Inst{13-10} = 0b0000;
let Inst{31-18} = 0b01101011010000;
}
def C4_addipc : HInst<
(outs IntRegs:$Rd32),
(ins u32_0Imm:$Ii),
"$Rd32 = add(pc,#$Ii)",
CR_tc_2_SLOT3, TypeCR>, Enc_9554661 {
let Inst{6-5} = 0b00;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0110101001001001;
let hasNewValue = 1;
let opNewValue = 0;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def C4_and_and : HInst<
(outs PredRegs:$Pd4),
(ins PredRegs:$Ps4, PredRegs:$Pt4, PredRegs:$Pu4),
"$Pd4 = and($Ps4,and($Pt4,$Pu4))",
CR_tc_2early_SLOT23, TypeCR>, Enc_4631106 {
let Inst{5-2} = 0b0000;
let Inst{13-10} = 0b0000;
let Inst{31-18} = 0b01101011000100;
}
def C4_and_andn : HInst<
(outs PredRegs:$Pd4),
(ins PredRegs:$Ps4, PredRegs:$Pt4, PredRegs:$Pu4),
"$Pd4 = and($Ps4,and($Pt4,!$Pu4))",
CR_tc_2early_SLOT23, TypeCR>, Enc_4631106 {
let Inst{5-2} = 0b0000;
let Inst{13-10} = 0b0000;
let Inst{31-18} = 0b01101011100100;
}
def C4_and_or : HInst<
(outs PredRegs:$Pd4),
(ins PredRegs:$Ps4, PredRegs:$Pt4, PredRegs:$Pu4),
"$Pd4 = and($Ps4,or($Pt4,$Pu4))",
CR_tc_2early_SLOT23, TypeCR>, Enc_4631106 {
let Inst{5-2} = 0b0000;
let Inst{13-10} = 0b0000;
let Inst{31-18} = 0b01101011001100;
}
def C4_and_orn : HInst<
(outs PredRegs:$Pd4),
(ins PredRegs:$Ps4, PredRegs:$Pt4, PredRegs:$Pu4),
"$Pd4 = and($Ps4,or($Pt4,!$Pu4))",
CR_tc_2early_SLOT23, TypeCR>, Enc_4631106 {
let Inst{5-2} = 0b0000;
let Inst{13-10} = 0b0000;
let Inst{31-18} = 0b01101011101100;
}
def C4_cmplte : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Pd4 = !cmp.gt($Rs32,$Rt32)",
ALU32_3op_tc_1_SLOT0123, TypeALU32_3op>, Enc_10157519, ImmRegRel {
let Inst{7-2} = 0b000100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110010010;
let CextOpcode = "C4_cmplte";
let InputType = "reg";
let isCompare = 1;
}
def C4_cmpltei : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, s32_0Imm:$Ii),
"$Pd4 = !cmp.gt($Rs32,#$Ii)",
ALU32_2op_tc_2early_SLOT0123, TypeALU32_2op>, Enc_16014536, ImmRegRel {
let Inst{4-2} = 0b100;
let Inst{31-22} = 0b0111010101;
let CextOpcode = "C4_cmplte";
let InputType = "imm";
let isCompare = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 10;
let opExtentAlign = 0;
}
def C4_cmplteu : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Pd4 = !cmp.gtu($Rs32,$Rt32)",
ALU32_3op_tc_1_SLOT0123, TypeALU32_3op>, Enc_10157519, ImmRegRel {
let Inst{7-2} = 0b000100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110010011;
let CextOpcode = "C4_cmplteu";
let InputType = "reg";
let isCompare = 1;
}
def C4_cmplteui : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, u32_0Imm:$Ii),
"$Pd4 = !cmp.gtu($Rs32,#$Ii)",
ALU32_2op_tc_2early_SLOT0123, TypeALU32_2op>, Enc_13249928, ImmRegRel {
let Inst{4-2} = 0b100;
let Inst{31-21} = 0b01110101100;
let CextOpcode = "C4_cmplteu";
let InputType = "imm";
let isCompare = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 9;
let opExtentAlign = 0;
}
def C4_cmpneq : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Pd4 = !cmp.eq($Rs32,$Rt32)",
ALU32_3op_tc_1_SLOT0123, TypeALU32_3op>, Enc_10157519, ImmRegRel {
let Inst{7-2} = 0b000100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110010000;
let CextOpcode = "C4_cmpneq";
let InputType = "reg";
let isCommutable = 1;
let isCompare = 1;
}
def C4_cmpneqi : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, s32_0Imm:$Ii),
"$Pd4 = !cmp.eq($Rs32,#$Ii)",
ALU32_2op_tc_2early_SLOT0123, TypeALU32_2op>, Enc_16014536, ImmRegRel {
let Inst{4-2} = 0b100;
let Inst{31-22} = 0b0111010100;
let CextOpcode = "C4_cmpneq";
let InputType = "imm";
let isCompare = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 10;
let opExtentAlign = 0;
}
def C4_fastcorner9 : HInst<
(outs PredRegs:$Pd4),
(ins PredRegs:$Ps4, PredRegs:$Pt4),
"$Pd4 = fastcorner9($Ps4,$Pt4)",
CR_tc_2early_SLOT23, TypeCR>, Enc_8324216 {
let Inst{7-2} = 0b100100;
let Inst{13-10} = 0b1000;
let Inst{31-18} = 0b01101011000000;
}
def C4_fastcorner9_not : HInst<
(outs PredRegs:$Pd4),
(ins PredRegs:$Ps4, PredRegs:$Pt4),
"$Pd4 = !fastcorner9($Ps4,$Pt4)",
CR_tc_2early_SLOT23, TypeCR>, Enc_8324216 {
let Inst{7-2} = 0b100100;
let Inst{13-10} = 0b1000;
let Inst{31-18} = 0b01101011000100;
}
def C4_nbitsclr : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Pd4 = !bitsclr($Rs32,$Rt32)",
S_3op_tc_2early_SLOT23, TypeS_3op>, Enc_10157519 {
let Inst{7-2} = 0b000000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000111101;
}
def C4_nbitsclri : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, u6_0Imm:$Ii),
"$Pd4 = !bitsclr($Rs32,#$Ii)",
S_2op_tc_2early_SLOT23, TypeS_2op>, Enc_14574598 {
let Inst{7-2} = 0b000000;
let Inst{31-21} = 0b10000101101;
}
def C4_nbitsset : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Pd4 = !bitsset($Rs32,$Rt32)",
S_3op_tc_2early_SLOT23, TypeS_3op>, Enc_10157519 {
let Inst{7-2} = 0b000000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000111011;
}
def C4_or_and : HInst<
(outs PredRegs:$Pd4),
(ins PredRegs:$Ps4, PredRegs:$Pt4, PredRegs:$Pu4),
"$Pd4 = or($Ps4,and($Pt4,$Pu4))",
CR_tc_2early_SLOT23, TypeCR>, Enc_4631106 {
let Inst{5-2} = 0b0000;
let Inst{13-10} = 0b0000;
let Inst{31-18} = 0b01101011010100;
}
def C4_or_andn : HInst<
(outs PredRegs:$Pd4),
(ins PredRegs:$Ps4, PredRegs:$Pt4, PredRegs:$Pu4),
"$Pd4 = or($Ps4,and($Pt4,!$Pu4))",
CR_tc_2early_SLOT23, TypeCR>, Enc_4631106 {
let Inst{5-2} = 0b0000;
let Inst{13-10} = 0b0000;
let Inst{31-18} = 0b01101011110100;
}
def C4_or_or : HInst<
(outs PredRegs:$Pd4),
(ins PredRegs:$Ps4, PredRegs:$Pt4, PredRegs:$Pu4),
"$Pd4 = or($Ps4,or($Pt4,$Pu4))",
CR_tc_2early_SLOT23, TypeCR>, Enc_4631106 {
let Inst{5-2} = 0b0000;
let Inst{13-10} = 0b0000;
let Inst{31-18} = 0b01101011011100;
}
def C4_or_orn : HInst<
(outs PredRegs:$Pd4),
(ins PredRegs:$Ps4, PredRegs:$Pt4, PredRegs:$Pu4),
"$Pd4 = or($Ps4,or($Pt4,!$Pu4))",
CR_tc_2early_SLOT23, TypeCR>, Enc_4631106 {
let Inst{5-2} = 0b0000;
let Inst{13-10} = 0b0000;
let Inst{31-18} = 0b01101011111100;
}
def F2_conv_d2df : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32),
"$Rdd32 = convert_d2df($Rss32)",
S_2op_tc_3or4x_SLOT23, TypeS_2op>, Enc_13133231, Requires<[HasV5T]> {
let Inst{13-5} = 0b000000011;
let Inst{31-21} = 0b10000000111;
let isFP = 1;
let prefersSlot3 = 1;
let Uses = [USR];
}
def F2_conv_d2sf : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32),
"$Rd32 = convert_d2sf($Rss32)",
S_2op_tc_3or4x_SLOT23, TypeS_2op>, Enc_3742184, Requires<[HasV5T]> {
let Inst{13-5} = 0b000000001;
let Inst{31-21} = 0b10001000010;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let prefersSlot3 = 1;
let Uses = [USR];
}
def F2_conv_df2d : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32),
"$Rdd32 = convert_df2d($Rss32)",
S_2op_tc_3or4x_SLOT23, TypeS_2op>, Enc_13133231, Requires<[HasV5T]> {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b10000000111;
let isFP = 1;
let prefersSlot3 = 1;
let Uses = [USR];
}
def F2_conv_df2d_chop : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32),
"$Rdd32 = convert_df2d($Rss32):chop",
S_2op_tc_3or4x_SLOT23, TypeS_2op>, Enc_13133231, Requires<[HasV5T]> {
let Inst{13-5} = 0b000000110;
let Inst{31-21} = 0b10000000111;
let isFP = 1;
let prefersSlot3 = 1;
let Uses = [USR];
}
def F2_conv_df2sf : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32),
"$Rd32 = convert_df2sf($Rss32)",
S_2op_tc_3or4x_SLOT23, TypeS_2op>, Enc_3742184, Requires<[HasV5T]> {
let Inst{13-5} = 0b000000001;
let Inst{31-21} = 0b10001000000;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let prefersSlot3 = 1;
let Uses = [USR];
}
def F2_conv_df2ud : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32),
"$Rdd32 = convert_df2ud($Rss32)",
S_2op_tc_3or4x_SLOT23, TypeS_2op>, Enc_13133231, Requires<[HasV5T]> {
let Inst{13-5} = 0b000000001;
let Inst{31-21} = 0b10000000111;
let isFP = 1;
let prefersSlot3 = 1;
let Uses = [USR];
}
def F2_conv_df2ud_chop : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32),
"$Rdd32 = convert_df2ud($Rss32):chop",
S_2op_tc_3or4x_SLOT23, TypeS_2op>, Enc_13133231, Requires<[HasV5T]> {
let Inst{13-5} = 0b000000111;
let Inst{31-21} = 0b10000000111;
let isFP = 1;
let prefersSlot3 = 1;
let Uses = [USR];
}
def F2_conv_df2uw : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32),
"$Rd32 = convert_df2uw($Rss32)",
S_2op_tc_3or4x_SLOT23, TypeS_2op>, Enc_3742184, Requires<[HasV5T]> {
let Inst{13-5} = 0b000000001;
let Inst{31-21} = 0b10001000011;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let prefersSlot3 = 1;
let Uses = [USR];
}
def F2_conv_df2uw_chop : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32),
"$Rd32 = convert_df2uw($Rss32):chop",
S_2op_tc_3or4x_SLOT23, TypeS_2op>, Enc_3742184, Requires<[HasV5T]> {
let Inst{13-5} = 0b000000001;
let Inst{31-21} = 0b10001000101;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let prefersSlot3 = 1;
let Uses = [USR];
}
def F2_conv_df2w : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32),
"$Rd32 = convert_df2w($Rss32)",
S_2op_tc_3or4x_SLOT23, TypeS_2op>, Enc_3742184, Requires<[HasV5T]> {
let Inst{13-5} = 0b000000001;
let Inst{31-21} = 0b10001000100;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let prefersSlot3 = 1;
let Uses = [USR];
}
def F2_conv_df2w_chop : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32),
"$Rd32 = convert_df2w($Rss32):chop",
S_2op_tc_3or4x_SLOT23, TypeS_2op>, Enc_3742184, Requires<[HasV5T]> {
let Inst{13-5} = 0b000000001;
let Inst{31-21} = 0b10001000111;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let prefersSlot3 = 1;
let Uses = [USR];
}
def F2_conv_sf2d : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32),
"$Rdd32 = convert_sf2d($Rs32)",
S_2op_tc_3or4x_SLOT23, TypeS_2op>, Enc_4030179, Requires<[HasV5T]> {
let Inst{13-5} = 0b000000100;
let Inst{31-21} = 0b10000100100;
let isFP = 1;
let prefersSlot3 = 1;
let Uses = [USR];
}
def F2_conv_sf2d_chop : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32),
"$Rdd32 = convert_sf2d($Rs32):chop",
S_2op_tc_3or4x_SLOT23, TypeS_2op>, Enc_4030179, Requires<[HasV5T]> {
let Inst{13-5} = 0b000000110;
let Inst{31-21} = 0b10000100100;
let isFP = 1;
let prefersSlot3 = 1;
let Uses = [USR];
}
def F2_conv_sf2df : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32),
"$Rdd32 = convert_sf2df($Rs32)",
S_2op_tc_3or4x_SLOT23, TypeS_2op>, Enc_4030179, Requires<[HasV5T]> {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b10000100100;
let isFP = 1;
let prefersSlot3 = 1;
let Uses = [USR];
}
def F2_conv_sf2ud : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32),
"$Rdd32 = convert_sf2ud($Rs32)",
S_2op_tc_3or4x_SLOT23, TypeS_2op>, Enc_4030179, Requires<[HasV5T]> {
let Inst{13-5} = 0b000000011;
let Inst{31-21} = 0b10000100100;
let isFP = 1;
let prefersSlot3 = 1;
let Uses = [USR];
}
def F2_conv_sf2ud_chop : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32),
"$Rdd32 = convert_sf2ud($Rs32):chop",
S_2op_tc_3or4x_SLOT23, TypeS_2op>, Enc_4030179, Requires<[HasV5T]> {
let Inst{13-5} = 0b000000101;
let Inst{31-21} = 0b10000100100;
let isFP = 1;
let prefersSlot3 = 1;
let Uses = [USR];
}
def F2_conv_sf2uw : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = convert_sf2uw($Rs32)",
S_2op_tc_3or4x_SLOT23, TypeS_2op>, Enc_4075554, Requires<[HasV5T]> {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b10001011011;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let prefersSlot3 = 1;
let Uses = [USR];
}
def F2_conv_sf2uw_chop : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = convert_sf2uw($Rs32):chop",
S_2op_tc_3or4x_SLOT23, TypeS_2op>, Enc_4075554, Requires<[HasV5T]> {
let Inst{13-5} = 0b000000001;
let Inst{31-21} = 0b10001011011;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let prefersSlot3 = 1;
let Uses = [USR];
}
def F2_conv_sf2w : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = convert_sf2w($Rs32)",
S_2op_tc_3or4x_SLOT23, TypeS_2op>, Enc_4075554, Requires<[HasV5T]> {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b10001011100;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let prefersSlot3 = 1;
let Uses = [USR];
}
def F2_conv_sf2w_chop : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = convert_sf2w($Rs32):chop",
S_2op_tc_3or4x_SLOT23, TypeS_2op>, Enc_4075554, Requires<[HasV5T]> {
let Inst{13-5} = 0b000000001;
let Inst{31-21} = 0b10001011100;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let prefersSlot3 = 1;
let Uses = [USR];
}
def F2_conv_ud2df : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32),
"$Rdd32 = convert_ud2df($Rss32)",
S_2op_tc_3or4x_SLOT23, TypeS_2op>, Enc_13133231, Requires<[HasV5T]> {
let Inst{13-5} = 0b000000010;
let Inst{31-21} = 0b10000000111;
let isFP = 1;
let prefersSlot3 = 1;
let Uses = [USR];
}
def F2_conv_ud2sf : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32),
"$Rd32 = convert_ud2sf($Rss32)",
S_2op_tc_3or4x_SLOT23, TypeS_2op>, Enc_3742184, Requires<[HasV5T]> {
let Inst{13-5} = 0b000000001;
let Inst{31-21} = 0b10001000001;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let prefersSlot3 = 1;
let Uses = [USR];
}
def F2_conv_uw2df : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32),
"$Rdd32 = convert_uw2df($Rs32)",
S_2op_tc_3or4x_SLOT23, TypeS_2op>, Enc_4030179, Requires<[HasV5T]> {
let Inst{13-5} = 0b000000001;
let Inst{31-21} = 0b10000100100;
let isFP = 1;
let prefersSlot3 = 1;
let Uses = [USR];
}
def F2_conv_uw2sf : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = convert_uw2sf($Rs32)",
S_2op_tc_3or4x_SLOT23, TypeS_2op>, Enc_4075554, Requires<[HasV5T]> {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b10001011001;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let prefersSlot3 = 1;
let Uses = [USR];
}
def F2_conv_w2df : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32),
"$Rdd32 = convert_w2df($Rs32)",
S_2op_tc_3or4x_SLOT23, TypeS_2op>, Enc_4030179, Requires<[HasV5T]> {
let Inst{13-5} = 0b000000010;
let Inst{31-21} = 0b10000100100;
let isFP = 1;
let prefersSlot3 = 1;
let Uses = [USR];
}
def F2_conv_w2sf : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = convert_w2sf($Rs32)",
S_2op_tc_3or4x_SLOT23, TypeS_2op>, Enc_4075554, Requires<[HasV5T]> {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b10001011010;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let prefersSlot3 = 1;
let Uses = [USR];
}
def F2_dfclass : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, u5_0Imm:$Ii),
"$Pd4 = dfclass($Rss32,#$Ii)",
ALU64_tc_2early_SLOT23, TypeALU64>, Enc_14400220, Requires<[HasV5T]> {
let Inst{4-2} = 0b100;
let Inst{13-10} = 0b0000;
let Inst{31-21} = 0b11011100100;
let isFP = 1;
let Uses = [USR];
}
def F2_dfcmpeq : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Pd4 = dfcmp.eq($Rss32,$Rtt32)",
ALU64_tc_2early_SLOT23, TypeALU64>, Enc_3831744, Requires<[HasV5T]> {
let Inst{7-2} = 0b000000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010010111;
let isFP = 1;
let Uses = [USR];
let isCompare = 1;
}
def F2_dfcmpge : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Pd4 = dfcmp.ge($Rss32,$Rtt32)",
ALU64_tc_2early_SLOT23, TypeALU64>, Enc_3831744, Requires<[HasV5T]> {
let Inst{7-2} = 0b010000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010010111;
let isFP = 1;
let Uses = [USR];
let isCompare = 1;
}
def F2_dfcmpgt : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Pd4 = dfcmp.gt($Rss32,$Rtt32)",
ALU64_tc_2early_SLOT23, TypeALU64>, Enc_3831744, Requires<[HasV5T]> {
let Inst{7-2} = 0b001000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010010111;
let isFP = 1;
let Uses = [USR];
let isCompare = 1;
}
def F2_dfcmpuo : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Pd4 = dfcmp.uo($Rss32,$Rtt32)",
ALU64_tc_2early_SLOT23, TypeALU64>, Enc_3831744, Requires<[HasV5T]> {
let Inst{7-2} = 0b011000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010010111;
let isFP = 1;
let Uses = [USR];
let isCompare = 1;
}
def F2_dfimm_n : HInst<
(outs DoubleRegs:$Rdd32),
(ins u10_0Imm:$Ii),
"$Rdd32 = dfmake(#$Ii):neg",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_2702036, Requires<[HasV5T]> {
let Inst{20-16} = 0b00000;
let Inst{31-22} = 0b1101100101;
let prefersSlot3 = 1;
}
def F2_dfimm_p : HInst<
(outs DoubleRegs:$Rdd32),
(ins u10_0Imm:$Ii),
"$Rdd32 = dfmake(#$Ii):pos",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_2702036, Requires<[HasV5T]> {
let Inst{20-16} = 0b00000;
let Inst{31-22} = 0b1101100100;
let prefersSlot3 = 1;
}
def F2_sfadd : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = sfadd($Rs32,$Rt32)",
M_tc_3or4x_SLOT23, TypeM>, Enc_14071773, Requires<[HasV5T]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101011000;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let prefersSlot3 = 1;
let Uses = [USR];
let isCommutable = 1;
}
def F2_sfclass : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, u5_0Imm:$Ii),
"$Pd4 = sfclass($Rs32,#$Ii)",
S_2op_tc_2early_SLOT23, TypeS_2op>, Enc_2103742, Requires<[HasV5T]> {
let Inst{7-2} = 0b000000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10000101111;
let isFP = 1;
let Uses = [USR];
}
def F2_sfcmpeq : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Pd4 = sfcmp.eq($Rs32,$Rt32)",
ALU64_tc_2early_SLOT23, TypeS_3op>, Enc_10157519, Requires<[HasV5T]> {
let Inst{7-2} = 0b011000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000111111;
let isFP = 1;
let Uses = [USR];
let isCompare = 1;
}
def F2_sfcmpge : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Pd4 = sfcmp.ge($Rs32,$Rt32)",
ALU64_tc_2early_SLOT23, TypeS_3op>, Enc_10157519, Requires<[HasV5T]> {
let Inst{7-2} = 0b000000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000111111;
let isFP = 1;
let Uses = [USR];
let isCompare = 1;
}
def F2_sfcmpgt : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Pd4 = sfcmp.gt($Rs32,$Rt32)",
ALU64_tc_2early_SLOT23, TypeS_3op>, Enc_10157519, Requires<[HasV5T]> {
let Inst{7-2} = 0b100000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000111111;
let isFP = 1;
let Uses = [USR];
let isCompare = 1;
}
def F2_sfcmpuo : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Pd4 = sfcmp.uo($Rs32,$Rt32)",
ALU64_tc_2early_SLOT23, TypeS_3op>, Enc_10157519, Requires<[HasV5T]> {
let Inst{7-2} = 0b001000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000111111;
let isFP = 1;
let Uses = [USR];
let isCompare = 1;
}
def F2_sffixupd : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = sffixupd($Rs32,$Rt32)",
M_tc_3or4x_SLOT23, TypeM>, Enc_14071773, Requires<[HasV5T]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101011110;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let prefersSlot3 = 1;
}
def F2_sffixupn : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = sffixupn($Rs32,$Rt32)",
M_tc_3or4x_SLOT23, TypeM>, Enc_14071773, Requires<[HasV5T]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101011110;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let prefersSlot3 = 1;
}
def F2_sffixupr : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = sffixupr($Rs32)",
S_2op_tc_3or4x_SLOT23, TypeS_2op>, Enc_4075554, Requires<[HasV5T]> {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b10001011101;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let prefersSlot3 = 1;
}
def F2_sffma : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += sfmpy($Rs32,$Rt32)",
M_tc_3or4x_acc_SLOT23, TypeM>, Enc_9223889, Requires<[HasV5T]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101111000;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let prefersSlot3 = 1;
let Uses = [USR];
let Constraints = "$Rx32 = $Rx32in";
}
def F2_sffma_lib : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += sfmpy($Rs32,$Rt32):lib",
M_tc_3or4x_acc_SLOT23, TypeM>, Enc_9223889, Requires<[HasV5T]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101111000;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let prefersSlot3 = 1;
let Uses = [USR];
let Constraints = "$Rx32 = $Rx32in";
}
def F2_sffma_sc : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32, PredRegs:$Pu4),
"$Rx32 += sfmpy($Rs32,$Rt32,$Pu4):scale",
M_tc_3or4x_acc_SLOT23, TypeM>, Enc_15194851, Requires<[HasV5T]> {
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101111011;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let prefersSlot3 = 1;
let Uses = [USR];
let Constraints = "$Rx32 = $Rx32in";
}
def F2_sffms : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= sfmpy($Rs32,$Rt32)",
M_tc_3or4x_acc_SLOT23, TypeM>, Enc_9223889, Requires<[HasV5T]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101111000;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let prefersSlot3 = 1;
let Uses = [USR];
let Constraints = "$Rx32 = $Rx32in";
}
def F2_sffms_lib : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= sfmpy($Rs32,$Rt32):lib",
M_tc_3or4x_acc_SLOT23, TypeM>, Enc_9223889, Requires<[HasV5T]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101111000;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let prefersSlot3 = 1;
let Uses = [USR];
let Constraints = "$Rx32 = $Rx32in";
}
def F2_sfimm_n : HInst<
(outs IntRegs:$Rd32),
(ins u10_0Imm:$Ii),
"$Rd32 = sfmake(#$Ii):neg",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_9082775, Requires<[HasV5T]> {
let Inst{20-16} = 0b00000;
let Inst{31-22} = 0b1101011001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def F2_sfimm_p : HInst<
(outs IntRegs:$Rd32),
(ins u10_0Imm:$Ii),
"$Rd32 = sfmake(#$Ii):pos",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_9082775, Requires<[HasV5T]> {
let Inst{20-16} = 0b00000;
let Inst{31-22} = 0b1101011000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def F2_sfinvsqrta : HInst<
(outs IntRegs:$Rd32, PredRegs:$Pe4),
(ins IntRegs:$Rs32),
"$Rd32,$Pe4 = sfinvsqrta($Rs32)",
S_2op_tc_3or4x_SLOT23, TypeS_2op>, Enc_5718302, Requires<[HasV5T]> {
let Inst{13-7} = 0b0000000;
let Inst{31-21} = 0b10001011111;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let isPredicateLate = 1;
let prefersSlot3 = 1;
}
def F2_sfmax : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = sfmax($Rs32,$Rt32)",
M_tc_2_SLOT23, TypeM>, Enc_14071773, Requires<[HasV5T]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101011100;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let prefersSlot3 = 1;
let Uses = [USR];
}
def F2_sfmin : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = sfmin($Rs32,$Rt32)",
M_tc_2_SLOT23, TypeM>, Enc_14071773, Requires<[HasV5T]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101011100;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let prefersSlot3 = 1;
let Uses = [USR];
}
def F2_sfmpy : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = sfmpy($Rs32,$Rt32)",
M_tc_3or4x_SLOT23, TypeM>, Enc_14071773, Requires<[HasV5T]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101011010;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let prefersSlot3 = 1;
let Uses = [USR];
let isCommutable = 1;
}
def F2_sfrecipa : HInst<
(outs IntRegs:$Rd32, PredRegs:$Pe4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32,$Pe4 = sfrecipa($Rs32,$Rt32)",
M_tc_3or4x_SLOT23, TypeM>, Enc_5853469, Requires<[HasV5T]> {
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101011111;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let isPredicateLate = 1;
let prefersSlot3 = 1;
}
def F2_sfsub : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = sfsub($Rs32,$Rt32)",
M_tc_3or4x_SLOT23, TypeM>, Enc_14071773, Requires<[HasV5T]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101011000;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let prefersSlot3 = 1;
let Uses = [USR];
}
def J2_call : HInst<
(outs),
(ins a30_2Imm:$Ii),
"call $Ii",
J_tc_2early_SLOT23, TypeJ>, Enc_13453446, PredRel {
let Inst{0-0} = 0b0;
let Inst{31-25} = 0b0101101;
let isCall = 1;
let prefersSlot3 = 1;
let Uses = [R29];
let Defs = [PC, R31];
let BaseOpcode = "J2_call";
let isPredicable = 1;
let hasSideEffects = 1;
let isExtendable = 1;
let opExtendable = 0;
let isExtentSigned = 1;
let opExtentBits = 24;
let opExtentAlign = 2;
}
def J2_callf : HInst<
(outs),
(ins PredRegs:$Pu4, a30_2Imm:$Ii),
"if (!$Pu4) call $Ii",
J_tc_2early_SLOT23, TypeJ>, Enc_14868535, PredRel {
let Inst{0-0} = 0b0;
let Inst{12-10} = 0b000;
let Inst{21-21} = 0b1;
let Inst{31-24} = 0b01011101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isCall = 1;
let prefersSlot3 = 1;
let Uses = [R29];
let Defs = [PC, R31];
let BaseOpcode = "J2_call";
let hasSideEffects = 1;
let isTaken = Inst{12};
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 17;
let opExtentAlign = 2;
}
def J2_callr : HInst<
(outs),
(ins IntRegs:$Rs32),
"callr $Rs32",
J_tc_2early_SLOT2, TypeJ>, Enc_11704059 {
let Inst{13-0} = 0b00000000000000;
let Inst{31-21} = 0b01010000101;
let cofMax1 = 1;
let isCall = 1;
let prefersSlot3 = 1;
let Uses = [R29];
let Defs = [PC, R31];
let hasSideEffects = 1;
}
def J2_callrf : HInst<
(outs),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if (!$Pu4) callr $Rs32",
J_tc_2early_SLOT2, TypeJ>, Enc_1928953 {
let Inst{7-0} = 0b00000000;
let Inst{13-10} = 0b0000;
let Inst{31-21} = 0b01010001001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let cofMax1 = 1;
let isCall = 1;
let prefersSlot3 = 1;
let Uses = [R29];
let Defs = [PC, R31];
let hasSideEffects = 1;
let isTaken = Inst{12};
}
def J2_callrt : HInst<
(outs),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if ($Pu4) callr $Rs32",
J_tc_2early_SLOT2, TypeJ>, Enc_1928953 {
let Inst{7-0} = 0b00000000;
let Inst{13-10} = 0b0000;
let Inst{31-21} = 0b01010001000;
let isPredicated = 1;
let cofMax1 = 1;
let isCall = 1;
let prefersSlot3 = 1;
let Uses = [R29];
let Defs = [PC, R31];
let hasSideEffects = 1;
let isTaken = Inst{12};
}
def J2_callt : HInst<
(outs),
(ins PredRegs:$Pu4, a30_2Imm:$Ii),
"if ($Pu4) call $Ii",
J_tc_2early_SLOT23, TypeJ>, Enc_14868535, PredRel {
let Inst{0-0} = 0b0;
let Inst{12-10} = 0b000;
let Inst{21-21} = 0b0;
let Inst{31-24} = 0b01011101;
let isPredicated = 1;
let isCall = 1;
let prefersSlot3 = 1;
let Uses = [R29];
let Defs = [PC, R31];
let BaseOpcode = "J2_call";
let hasSideEffects = 1;
let isTaken = Inst{12};
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 17;
let opExtentAlign = 2;
}
def J2_endloop0 : HInst<
(outs),
(ins),
"endloop0",
PSEUDO, TypeJ> {
let Uses = [LC0, SA0];
let Defs = [LC0, P3, PC, USR];
let isPseudo = 1;
}
def J2_endloop01 : HInst<
(outs),
(ins),
"endloop01",
PSEUDO, TypeJ> {
let Uses = [LC0, LC1, SA0, SA1];
let Defs = [LC0, LC1, P3, PC, USR];
let isPseudo = 1;
}
def J2_endloop1 : HInst<
(outs),
(ins),
"endloop1",
PSEUDO, TypeJ> {
let Uses = [LC1, SA1];
let Defs = [LC1, PC];
let isPseudo = 1;
}
def J2_jump : HInst<
(outs),
(ins b30_2Imm:$Ii),
"jump $Ii",
J_tc_2early_CJUMP_UCJUMP_ARCHDEPSLOT, TypeJ>, Enc_13453446, PredNewRel {
let Inst{0-0} = 0b0;
let Inst{31-25} = 0b0101100;
let isTerminator = 1;
let isBranch = 1;
let Defs = [PC];
let InputType = "imm";
let BaseOpcode = "J2_jump";
let isBarrier = 1;
let isPredicable = 1;
let isExtendable = 1;
let opExtendable = 0;
let isExtentSigned = 1;
let opExtentBits = 24;
let opExtentAlign = 2;
}
def J2_jumpf : HInst<
(outs),
(ins PredRegs:$Pu4, b30_2Imm:$Ii),
"if (!$Pu4) jump:nt $Ii",
J_tc_2early_CJUMP_UCJUMP_ARCHDEPSLOT, TypeJ>, Enc_14868535, PredNewRel {
let Inst{0-0} = 0b0;
let Inst{12-10} = 0b000;
let Inst{21-21} = 0b1;
let Inst{31-24} = 0b01011100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let Defs = [PC];
let InputType = "imm";
let BaseOpcode = "J2_jump";
let isTaken = Inst{12};
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 17;
let opExtentAlign = 2;
}
def J2_jumpf_nopred_map : HInst<
(outs),
(ins PredRegs:$Pu4, b15_2Imm:$Ii),
"if (!$Pu4) jump $Ii",
PSEUDO, TypeMAPPING>, Requires<[HasV60T]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def J2_jumpfnew : HInst<
(outs),
(ins PredRegs:$Pu4, b30_2Imm:$Ii),
"if (!$Pu4.new) jump:nt $Ii",
J_tc_2early_CJUMP_UCJUMP_ARCHDEPSLOT, TypeJ>, Enc_14868535, PredNewRel {
let Inst{0-0} = 0b0;
let Inst{12-10} = 0b010;
let Inst{21-21} = 0b1;
let Inst{31-24} = 0b01011100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Defs = [PC];
let InputType = "imm";
let BaseOpcode = "J2_jump";
let isTaken = Inst{12};
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 17;
let opExtentAlign = 2;
}
def J2_jumpfnewpt : HInst<
(outs),
(ins PredRegs:$Pu4, b30_2Imm:$Ii),
"if (!$Pu4.new) jump:t $Ii",
J_tc_2early_CJUMP_UCJUMP_ARCHDEPSLOT, TypeJ>, Enc_14868535, PredNewRel {
let Inst{0-0} = 0b0;
let Inst{12-10} = 0b110;
let Inst{21-21} = 0b1;
let Inst{31-24} = 0b01011100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Defs = [PC];
let InputType = "imm";
let BaseOpcode = "J2_jump";
let isTaken = Inst{12};
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 17;
let opExtentAlign = 2;
}
def J2_jumpfpt : HInst<
(outs),
(ins PredRegs:$Pu4, b30_2Imm:$Ii),
"if (!$Pu4) jump:t $Ii",
J_tc_2early_CJUMP_UCJUMP_ARCHDEPSLOT, TypeJ>, Enc_14868535, Requires<[HasV60T]>, PredNewRel {
let Inst{0-0} = 0b0;
let Inst{12-10} = 0b100;
let Inst{21-21} = 0b1;
let Inst{31-24} = 0b01011100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let Defs = [PC];
let InputType = "imm";
let BaseOpcode = "J2_jump";
let isTaken = Inst{12};
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 17;
let opExtentAlign = 2;
}
def J2_jumpr : HInst<
(outs),
(ins IntRegs:$Rs32),
"jumpr $Rs32",
J_tc_2early_SLOT2, TypeJ>, Enc_11704059, PredNewRel {
let Inst{13-0} = 0b00000000000000;
let Inst{31-21} = 0b01010010100;
let isTerminator = 1;
let isIndirectBranch = 1;
let isBranch = 1;
let cofMax1 = 1;
let Defs = [PC];
let InputType = "reg";
let BaseOpcode = "J2_jumpr";
let isBarrier = 1;
let isPredicable = 1;
}
def J2_jumprf : HInst<
(outs),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if (!$Pu4) jumpr:nt $Rs32",
J_tc_2early_SLOT2, TypeJ>, Enc_1928953, PredNewRel {
let Inst{7-0} = 0b00000000;
let Inst{13-10} = 0b0000;
let Inst{31-21} = 0b01010011011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isIndirectBranch = 1;
let isBranch = 1;
let cofMax1 = 1;
let Defs = [PC];
let InputType = "reg";
let BaseOpcode = "J2_jumpr";
let isTaken = Inst{12};
}
def J2_jumprf_nopred_map : HInst<
(outs),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if (!$Pu4) jumpr $Rs32",
PSEUDO, TypeMAPPING>, Requires<[HasV60T]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def J2_jumprfnew : HInst<
(outs),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if (!$Pu4.new) jumpr:nt $Rs32",
J_tc_2early_SLOT2, TypeJ>, Enc_1928953, PredNewRel {
let Inst{7-0} = 0b00000000;
let Inst{13-10} = 0b0010;
let Inst{31-21} = 0b01010011011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isIndirectBranch = 1;
let isBranch = 1;
let cofMax1 = 1;
let isPredicatedNew = 1;
let Defs = [PC];
let InputType = "reg";
let BaseOpcode = "J2_jumpr";
let isTaken = Inst{12};
}
def J2_jumprfnewpt : HInst<
(outs),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if (!$Pu4.new) jumpr:t $Rs32",
J_tc_2early_SLOT2, TypeJ>, Enc_1928953, PredNewRel {
let Inst{7-0} = 0b00000000;
let Inst{13-10} = 0b0110;
let Inst{31-21} = 0b01010011011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isIndirectBranch = 1;
let isBranch = 1;
let cofMax1 = 1;
let isPredicatedNew = 1;
let Defs = [PC];
let InputType = "reg";
let BaseOpcode = "J2_jumpr";
let isTaken = Inst{12};
}
def J2_jumprfpt : HInst<
(outs),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if (!$Pu4) jumpr:t $Rs32",
J_tc_2early_SLOT2, TypeJ>, Enc_1928953, Requires<[HasV60T]>, PredNewRel {
let Inst{7-0} = 0b00000000;
let Inst{13-10} = 0b0100;
let Inst{31-21} = 0b01010011011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isIndirectBranch = 1;
let isBranch = 1;
let cofMax1 = 1;
let Defs = [PC];
let InputType = "reg";
let BaseOpcode = "J2_jumpr";
let isTaken = Inst{12};
}
def J2_jumprgtez : HInst<
(outs),
(ins IntRegs:$Rs32, b13_2Imm:$Ii),
"if ($Rs32>=#0) jump:nt $Ii",
CR_tc_2early_SLOT3, TypeCR>, Enc_12477789 {
let Inst{0-0} = 0b0;
let Inst{12-12} = 0b0;
let Inst{31-22} = 0b0110000101;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Defs = [PC];
let isTaken = Inst{12};
}
def J2_jumprgtezpt : HInst<
(outs),
(ins IntRegs:$Rs32, b13_2Imm:$Ii),
"if ($Rs32>=#0) jump:t $Ii",
CR_tc_2early_SLOT3, TypeCR>, Enc_12477789 {
let Inst{0-0} = 0b0;
let Inst{12-12} = 0b1;
let Inst{31-22} = 0b0110000101;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Defs = [PC];
let isTaken = Inst{12};
}
def J2_jumprltez : HInst<
(outs),
(ins IntRegs:$Rs32, b13_2Imm:$Ii),
"if ($Rs32<=#0) jump:nt $Ii",
CR_tc_2early_SLOT3, TypeCR>, Enc_12477789 {
let Inst{0-0} = 0b0;
let Inst{12-12} = 0b0;
let Inst{31-22} = 0b0110000111;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Defs = [PC];
let isTaken = Inst{12};
}
def J2_jumprltezpt : HInst<
(outs),
(ins IntRegs:$Rs32, b13_2Imm:$Ii),
"if ($Rs32<=#0) jump:t $Ii",
CR_tc_2early_SLOT3, TypeCR>, Enc_12477789 {
let Inst{0-0} = 0b0;
let Inst{12-12} = 0b1;
let Inst{31-22} = 0b0110000111;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Defs = [PC];
let isTaken = Inst{12};
}
def J2_jumprnz : HInst<
(outs),
(ins IntRegs:$Rs32, b13_2Imm:$Ii),
"if ($Rs32==#0) jump:nt $Ii",
CR_tc_2early_SLOT3, TypeCR>, Enc_12477789 {
let Inst{0-0} = 0b0;
let Inst{12-12} = 0b0;
let Inst{31-22} = 0b0110000110;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Defs = [PC];
let isTaken = Inst{12};
}
def J2_jumprnzpt : HInst<
(outs),
(ins IntRegs:$Rs32, b13_2Imm:$Ii),
"if ($Rs32==#0) jump:t $Ii",
CR_tc_2early_SLOT3, TypeCR>, Enc_12477789 {
let Inst{0-0} = 0b0;
let Inst{12-12} = 0b1;
let Inst{31-22} = 0b0110000110;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Defs = [PC];
let isTaken = Inst{12};
}
def J2_jumprt : HInst<
(outs),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if ($Pu4) jumpr:nt $Rs32",
J_tc_2early_SLOT2, TypeJ>, Enc_1928953, PredNewRel {
let Inst{7-0} = 0b00000000;
let Inst{13-10} = 0b0000;
let Inst{31-21} = 0b01010011010;
let isPredicated = 1;
let isTerminator = 1;
let isIndirectBranch = 1;
let isBranch = 1;
let cofMax1 = 1;
let Defs = [PC];
let InputType = "reg";
let BaseOpcode = "J2_jumpr";
let isTaken = Inst{12};
}
def J2_jumprt_nopred_map : HInst<
(outs),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if ($Pu4) jumpr $Rs32",
PSEUDO, TypeMAPPING>, Requires<[HasV60T]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def J2_jumprtnew : HInst<
(outs),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if ($Pu4.new) jumpr:nt $Rs32",
J_tc_2early_SLOT2, TypeJ>, Enc_1928953, PredNewRel {
let Inst{7-0} = 0b00000000;
let Inst{13-10} = 0b0010;
let Inst{31-21} = 0b01010011010;
let isPredicated = 1;
let isTerminator = 1;
let isIndirectBranch = 1;
let isBranch = 1;
let cofMax1 = 1;
let isPredicatedNew = 1;
let Defs = [PC];
let InputType = "reg";
let BaseOpcode = "J2_jumpr";
let isTaken = Inst{12};
}
def J2_jumprtnewpt : HInst<
(outs),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if ($Pu4.new) jumpr:t $Rs32",
J_tc_2early_SLOT2, TypeJ>, Enc_1928953, PredNewRel {
let Inst{7-0} = 0b00000000;
let Inst{13-10} = 0b0110;
let Inst{31-21} = 0b01010011010;
let isPredicated = 1;
let isTerminator = 1;
let isIndirectBranch = 1;
let isBranch = 1;
let cofMax1 = 1;
let isPredicatedNew = 1;
let Defs = [PC];
let InputType = "reg";
let BaseOpcode = "J2_jumpr";
let isTaken = Inst{12};
}
def J2_jumprtpt : HInst<
(outs),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if ($Pu4) jumpr:t $Rs32",
J_tc_2early_SLOT2, TypeJ>, Enc_1928953, Requires<[HasV60T]>, PredNewRel {
let Inst{7-0} = 0b00000000;
let Inst{13-10} = 0b0100;
let Inst{31-21} = 0b01010011010;
let isPredicated = 1;
let isTerminator = 1;
let isIndirectBranch = 1;
let isBranch = 1;
let cofMax1 = 1;
let Defs = [PC];
let InputType = "reg";
let BaseOpcode = "J2_jumpr";
let isTaken = Inst{12};
}
def J2_jumprz : HInst<
(outs),
(ins IntRegs:$Rs32, b13_2Imm:$Ii),
"if ($Rs32!=#0) jump:nt $Ii",
CR_tc_2early_SLOT3, TypeCR>, Enc_12477789 {
let Inst{0-0} = 0b0;
let Inst{12-12} = 0b0;
let Inst{31-22} = 0b0110000100;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Defs = [PC];
let isTaken = Inst{12};
}
def J2_jumprzpt : HInst<
(outs),
(ins IntRegs:$Rs32, b13_2Imm:$Ii),
"if ($Rs32!=#0) jump:t $Ii",
CR_tc_2early_SLOT3, TypeCR>, Enc_12477789 {
let Inst{0-0} = 0b0;
let Inst{12-12} = 0b1;
let Inst{31-22} = 0b0110000100;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Defs = [PC];
let isTaken = Inst{12};
}
def J2_jumpt : HInst<
(outs),
(ins PredRegs:$Pu4, b30_2Imm:$Ii),
"if ($Pu4) jump:nt $Ii",
J_tc_2early_CJUMP_UCJUMP_ARCHDEPSLOT, TypeJ>, Enc_14868535, PredNewRel {
let Inst{0-0} = 0b0;
let Inst{12-10} = 0b000;
let Inst{21-21} = 0b0;
let Inst{31-24} = 0b01011100;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let Defs = [PC];
let InputType = "imm";
let BaseOpcode = "J2_jump";
let isTaken = Inst{12};
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 17;
let opExtentAlign = 2;
}
def J2_jumpt_nopred_map : HInst<
(outs),
(ins PredRegs:$Pu4, b15_2Imm:$Ii),
"if ($Pu4) jump $Ii",
PSEUDO, TypeMAPPING>, Requires<[HasV60T]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def J2_jumptnew : HInst<
(outs),
(ins PredRegs:$Pu4, b30_2Imm:$Ii),
"if ($Pu4.new) jump:nt $Ii",
J_tc_2early_CJUMP_UCJUMP_ARCHDEPSLOT, TypeJ>, Enc_14868535, PredNewRel {
let Inst{0-0} = 0b0;
let Inst{12-10} = 0b010;
let Inst{21-21} = 0b0;
let Inst{31-24} = 0b01011100;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Defs = [PC];
let InputType = "imm";
let BaseOpcode = "J2_jump";
let isTaken = Inst{12};
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 17;
let opExtentAlign = 2;
}
def J2_jumptnewpt : HInst<
(outs),
(ins PredRegs:$Pu4, b30_2Imm:$Ii),
"if ($Pu4.new) jump:t $Ii",
J_tc_2early_CJUMP_UCJUMP_ARCHDEPSLOT, TypeJ>, Enc_14868535, PredNewRel {
let Inst{0-0} = 0b0;
let Inst{12-10} = 0b110;
let Inst{21-21} = 0b0;
let Inst{31-24} = 0b01011100;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Defs = [PC];
let InputType = "imm";
let BaseOpcode = "J2_jump";
let isTaken = Inst{12};
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 17;
let opExtentAlign = 2;
}
def J2_jumptpt : HInst<
(outs),
(ins PredRegs:$Pu4, b30_2Imm:$Ii),
"if ($Pu4) jump:t $Ii",
J_tc_2early_CJUMP_UCJUMP_ARCHDEPSLOT, TypeJ>, Enc_14868535, Requires<[HasV60T]>, PredNewRel {
let Inst{0-0} = 0b0;
let Inst{12-10} = 0b100;
let Inst{21-21} = 0b0;
let Inst{31-24} = 0b01011100;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let Defs = [PC];
let InputType = "imm";
let BaseOpcode = "J2_jump";
let isTaken = Inst{12};
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 17;
let opExtentAlign = 2;
}
def J2_loop0i : HInst<
(outs),
(ins b30_2Imm:$Ii, u10_0Imm:$II),
"loop0($Ii,#$II)",
CR_tc_3x_SLOT3, TypeCR>, Enc_9939385 {
let Inst{2-2} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01101001000;
let Defs = [LC0, SA0, USR];
let isExtendable = 1;
let opExtendable = 0;
let isExtentSigned = 1;
let opExtentBits = 9;
let opExtentAlign = 2;
}
def J2_loop0r : HInst<
(outs),
(ins b30_2Imm:$Ii, IntRegs:$Rs32),
"loop0($Ii,$Rs32)",
CR_tc_3x_SLOT3, TypeCR>, Enc_5790679 {
let Inst{2-0} = 0b000;
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01100000000;
let Defs = [LC0, SA0, USR];
let isExtendable = 1;
let opExtendable = 0;
let isExtentSigned = 1;
let opExtentBits = 9;
let opExtentAlign = 2;
}
def J2_loop1i : HInst<
(outs),
(ins b30_2Imm:$Ii, u10_0Imm:$II),
"loop1($Ii,#$II)",
CR_tc_3x_SLOT3, TypeCR>, Enc_9939385 {
let Inst{2-2} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01101001001;
let Defs = [LC1, SA1];
let isExtendable = 1;
let opExtendable = 0;
let isExtentSigned = 1;
let opExtentBits = 9;
let opExtentAlign = 2;
}
def J2_loop1r : HInst<
(outs),
(ins b30_2Imm:$Ii, IntRegs:$Rs32),
"loop1($Ii,$Rs32)",
CR_tc_3x_SLOT3, TypeCR>, Enc_5790679 {
let Inst{2-0} = 0b000;
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01100000001;
let Defs = [LC1, SA1];
let isExtendable = 1;
let opExtendable = 0;
let isExtentSigned = 1;
let opExtentBits = 9;
let opExtentAlign = 2;
}
def J2_pause : HInst<
(outs),
(ins u8_0Imm:$Ii),
"pause(#$Ii)",
J_tc_2early_SLOT2, TypeJ>, Enc_8732960 {
let Inst{1-0} = 0b00;
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0101010001000000;
let isSolo = 1;
}
def J2_ploop1si : HInst<
(outs),
(ins b30_2Imm:$Ii, u10_0Imm:$II),
"p3 = sp1loop0($Ii,#$II)",
CR_tc_2early_SLOT3, TypeCR>, Enc_9939385 {
let Inst{2-2} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01101001101;
let isPredicateLate = 1;
let Defs = [LC0, P3, SA0, USR];
let isExtendable = 1;
let opExtendable = 0;
let isExtentSigned = 1;
let opExtentBits = 9;
let opExtentAlign = 2;
}
def J2_ploop1sr : HInst<
(outs),
(ins b30_2Imm:$Ii, IntRegs:$Rs32),
"p3 = sp1loop0($Ii,$Rs32)",
CR_tc_2early_SLOT3, TypeCR>, Enc_5790679 {
let Inst{2-0} = 0b000;
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01100000101;
let isPredicateLate = 1;
let Defs = [LC0, P3, SA0, USR];
let isExtendable = 1;
let opExtendable = 0;
let isExtentSigned = 1;
let opExtentBits = 9;
let opExtentAlign = 2;
}
def J2_ploop2si : HInst<
(outs),
(ins b30_2Imm:$Ii, u10_0Imm:$II),
"p3 = sp2loop0($Ii,#$II)",
CR_tc_2early_SLOT3, TypeCR>, Enc_9939385 {
let Inst{2-2} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01101001110;
let isPredicateLate = 1;
let Defs = [LC0, P3, SA0, USR];
let isExtendable = 1;
let opExtendable = 0;
let isExtentSigned = 1;
let opExtentBits = 9;
let opExtentAlign = 2;
}
def J2_ploop2sr : HInst<
(outs),
(ins b30_2Imm:$Ii, IntRegs:$Rs32),
"p3 = sp2loop0($Ii,$Rs32)",
CR_tc_2early_SLOT3, TypeCR>, Enc_5790679 {
let Inst{2-0} = 0b000;
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01100000110;
let isPredicateLate = 1;
let Defs = [LC0, P3, SA0, USR];
let isExtendable = 1;
let opExtendable = 0;
let isExtentSigned = 1;
let opExtentBits = 9;
let opExtentAlign = 2;
}
def J2_ploop3si : HInst<
(outs),
(ins b30_2Imm:$Ii, u10_0Imm:$II),
"p3 = sp3loop0($Ii,#$II)",
CR_tc_2early_SLOT3, TypeCR>, Enc_9939385 {
let Inst{2-2} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01101001111;
let isPredicateLate = 1;
let Defs = [LC0, P3, SA0, USR];
let isExtendable = 1;
let opExtendable = 0;
let isExtentSigned = 1;
let opExtentBits = 9;
let opExtentAlign = 2;
}
def J2_ploop3sr : HInst<
(outs),
(ins b30_2Imm:$Ii, IntRegs:$Rs32),
"p3 = sp3loop0($Ii,$Rs32)",
CR_tc_2early_SLOT3, TypeCR>, Enc_5790679 {
let Inst{2-0} = 0b000;
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01100000111;
let isPredicateLate = 1;
let Defs = [LC0, P3, SA0, USR];
let isExtendable = 1;
let opExtendable = 0;
let isExtentSigned = 1;
let opExtentBits = 9;
let opExtentAlign = 2;
}
def J2_trap0 : HInst<
(outs),
(ins u8_0Imm:$Ii),
"trap0(#$Ii)",
J_tc_2early_SLOT2, TypeJ>, Enc_8732960 {
let Inst{1-0} = 0b00;
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0101010000000000;
let isSolo = 1;
}
def J4_cmpeq_f_jumpnv_nt : HInst<
(outs),
(ins IntRegs:$Ns8, IntRegs:$Rt32, b30_2Imm:$Ii),
"if (!cmp.eq($Ns8.new,$Rt32)) jump:nt $Ii",
NCJ_tc_3or4stall_SLOT0, TypeNCJ>, Enc_15140689, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010000001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let cofMax1 = 1;
let isNewValue = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpeqr";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpeq_f_jumpnv_t : HInst<
(outs),
(ins IntRegs:$Ns8, IntRegs:$Rt32, b30_2Imm:$Ii),
"if (!cmp.eq($Ns8.new,$Rt32)) jump:t $Ii",
NCJ_tc_3or4stall_SLOT0, TypeNCJ>, Enc_15140689, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010000001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let cofMax1 = 1;
let isNewValue = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpeqr";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpeq_fp0_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, GeneralSubRegs:$Rt16, b30_2Imm:$Ii),
"p0 = cmp.eq($Rs16,$Rt16); if (!p0.new) jump:nt $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_14264243, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-12} = 0b00;
let Inst{31-22} = 0b0001010001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpeqp0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpeq_fp0_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, GeneralSubRegs:$Rt16, b30_2Imm:$Ii),
"p0 = cmp.eq($Rs16,$Rt16); if (!p0.new) jump:t $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_14264243, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-12} = 0b10;
let Inst{31-22} = 0b0001010001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpeqp0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpeq_fp1_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, GeneralSubRegs:$Rt16, b30_2Imm:$Ii),
"p1 = cmp.eq($Rs16,$Rt16); if (!p1.new) jump:nt $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_14264243, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-12} = 0b01;
let Inst{31-22} = 0b0001010001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpeqp1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpeq_fp1_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, GeneralSubRegs:$Rt16, b30_2Imm:$Ii),
"p1 = cmp.eq($Rs16,$Rt16); if (!p1.new) jump:t $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_14264243, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-12} = 0b11;
let Inst{31-22} = 0b0001010001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpeqp1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpeq_t_jumpnv_nt : HInst<
(outs),
(ins IntRegs:$Ns8, IntRegs:$Rt32, b30_2Imm:$Ii),
"if (cmp.eq($Ns8.new,$Rt32)) jump:nt $Ii",
NCJ_tc_3or4stall_SLOT0, TypeNCJ>, Enc_15140689, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010000000;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let cofMax1 = 1;
let isNewValue = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpeqr";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpeq_t_jumpnv_t : HInst<
(outs),
(ins IntRegs:$Ns8, IntRegs:$Rt32, b30_2Imm:$Ii),
"if (cmp.eq($Ns8.new,$Rt32)) jump:t $Ii",
NCJ_tc_3or4stall_SLOT0, TypeNCJ>, Enc_15140689, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010000000;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let cofMax1 = 1;
let isNewValue = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpeqr";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpeq_tp0_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, GeneralSubRegs:$Rt16, b30_2Imm:$Ii),
"p0 = cmp.eq($Rs16,$Rt16); if (p0.new) jump:nt $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_14264243, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-12} = 0b00;
let Inst{31-22} = 0b0001010000;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpeqp0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpeq_tp0_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, GeneralSubRegs:$Rt16, b30_2Imm:$Ii),
"p0 = cmp.eq($Rs16,$Rt16); if (p0.new) jump:t $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_14264243, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-12} = 0b10;
let Inst{31-22} = 0b0001010000;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpeqp0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpeq_tp1_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, GeneralSubRegs:$Rt16, b30_2Imm:$Ii),
"p1 = cmp.eq($Rs16,$Rt16); if (p1.new) jump:nt $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_14264243, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-12} = 0b01;
let Inst{31-22} = 0b0001010000;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpeqp1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpeq_tp1_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, GeneralSubRegs:$Rt16, b30_2Imm:$Ii),
"p1 = cmp.eq($Rs16,$Rt16); if (p1.new) jump:t $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_14264243, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-12} = 0b11;
let Inst{31-22} = 0b0001010000;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpeqp1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpeqi_f_jumpnv_nt : HInst<
(outs),
(ins IntRegs:$Ns8, u5_0Imm:$II, b30_2Imm:$Ii),
"if (!cmp.eq($Ns8.new,#$II)) jump:nt $Ii",
NCJ_tc_3or4stall_SLOT0, TypeNCJ>, Enc_4397470, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010010001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let cofMax1 = 1;
let isNewValue = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpeqi";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpeqi_f_jumpnv_t : HInst<
(outs),
(ins IntRegs:$Ns8, u5_0Imm:$II, b30_2Imm:$Ii),
"if (!cmp.eq($Ns8.new,#$II)) jump:t $Ii",
NCJ_tc_3or4stall_SLOT0, TypeNCJ>, Enc_4397470, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010010001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let cofMax1 = 1;
let isNewValue = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpeqi";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpeqi_fp0_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u5_0Imm:$II, b30_2Imm:$Ii),
"p0 = cmp.eq($Rs16,#$II); if (!p0.new) jump:nt $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_7305764, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-22} = 0b0001000001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpeqip0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpeqi_fp0_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u5_0Imm:$II, b30_2Imm:$Ii),
"p0 = cmp.eq($Rs16,#$II); if (!p0.new) jump:t $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_7305764, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-22} = 0b0001000001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpeqip0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpeqi_fp1_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u5_0Imm:$II, b30_2Imm:$Ii),
"p1 = cmp.eq($Rs16,#$II); if (!p1.new) jump:nt $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_7305764, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-22} = 0b0001001001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpeqip1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpeqi_fp1_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u5_0Imm:$II, b30_2Imm:$Ii),
"p1 = cmp.eq($Rs16,#$II); if (!p1.new) jump:t $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_7305764, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-22} = 0b0001001001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpeqip1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpeqi_t_jumpnv_nt : HInst<
(outs),
(ins IntRegs:$Ns8, u5_0Imm:$II, b30_2Imm:$Ii),
"if (cmp.eq($Ns8.new,#$II)) jump:nt $Ii",
NCJ_tc_3or4stall_SLOT0, TypeNCJ>, Enc_4397470, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010010000;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let cofMax1 = 1;
let isNewValue = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpeqi";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpeqi_t_jumpnv_t : HInst<
(outs),
(ins IntRegs:$Ns8, u5_0Imm:$II, b30_2Imm:$Ii),
"if (cmp.eq($Ns8.new,#$II)) jump:t $Ii",
NCJ_tc_3or4stall_SLOT0, TypeNCJ>, Enc_4397470, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010010000;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let cofMax1 = 1;
let isNewValue = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpeqi";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpeqi_tp0_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u5_0Imm:$II, b30_2Imm:$Ii),
"p0 = cmp.eq($Rs16,#$II); if (p0.new) jump:nt $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_7305764, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-22} = 0b0001000000;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpeqip0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpeqi_tp0_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u5_0Imm:$II, b30_2Imm:$Ii),
"p0 = cmp.eq($Rs16,#$II); if (p0.new) jump:t $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_7305764, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-22} = 0b0001000000;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpeqip0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpeqi_tp1_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u5_0Imm:$II, b30_2Imm:$Ii),
"p1 = cmp.eq($Rs16,#$II); if (p1.new) jump:nt $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_7305764, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-22} = 0b0001001000;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpeqip1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpeqi_tp1_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u5_0Imm:$II, b30_2Imm:$Ii),
"p1 = cmp.eq($Rs16,#$II); if (p1.new) jump:t $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_7305764, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-22} = 0b0001001000;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpeqip1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpeqn1_f_jumpnv_nt : HInst<
(outs),
(ins IntRegs:$Ns8, n1Const:$n1, b30_2Imm:$Ii),
"if (!cmp.eq($Ns8.new,#$n1)) jump:nt $Ii",
NCJ_tc_3or4stall_SLOT0, TypeNCJ>, Enc_4359901, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b000000;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010011001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let cofMax1 = 1;
let isNewValue = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpeqn1r";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpeqn1_f_jumpnv_t : HInst<
(outs),
(ins IntRegs:$Ns8, n1Const:$n1, b30_2Imm:$Ii),
"if (!cmp.eq($Ns8.new,#$n1)) jump:t $Ii",
NCJ_tc_3or4stall_SLOT0, TypeNCJ>, Enc_8612939, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b100000;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010011001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let cofMax1 = 1;
let isNewValue = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpeqn1r";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpeqn1_fp0_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, n1Const:$n1, b30_2Imm:$Ii),
"p0 = cmp.eq($Rs16,#$n1); if (!p0.new) jump:nt $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_844699, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b000000;
let Inst{31-22} = 0b0001000111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpeqn1p0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpeqn1_fp0_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, n1Const:$n1, b30_2Imm:$Ii),
"p0 = cmp.eq($Rs16,#$n1); if (!p0.new) jump:t $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_5338033, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b100000;
let Inst{31-22} = 0b0001000111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpeqn1p0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpeqn1_fp1_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, n1Const:$n1, b30_2Imm:$Ii),
"p1 = cmp.eq($Rs16,#$n1); if (!p1.new) jump:nt $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_14150875, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b000000;
let Inst{31-22} = 0b0001001111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpeqn1p1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpeqn1_fp1_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, n1Const:$n1, b30_2Imm:$Ii),
"p1 = cmp.eq($Rs16,#$n1); if (!p1.new) jump:t $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_15450971, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b100000;
let Inst{31-22} = 0b0001001111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpeqn1p1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpeqn1_t_jumpnv_nt : HInst<
(outs),
(ins IntRegs:$Ns8, n1Const:$n1, b30_2Imm:$Ii),
"if (cmp.eq($Ns8.new,#$n1)) jump:nt $Ii",
NCJ_tc_3or4stall_SLOT0, TypeNCJ>, Enc_14998517, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b000000;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010011000;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let cofMax1 = 1;
let isNewValue = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpeqn1r";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpeqn1_t_jumpnv_t : HInst<
(outs),
(ins IntRegs:$Ns8, n1Const:$n1, b30_2Imm:$Ii),
"if (cmp.eq($Ns8.new,#$n1)) jump:t $Ii",
NCJ_tc_3or4stall_SLOT0, TypeNCJ>, Enc_11544269, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b100000;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010011000;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let cofMax1 = 1;
let isNewValue = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpeqn1r";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpeqn1_tp0_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, n1Const:$n1, b30_2Imm:$Ii),
"p0 = cmp.eq($Rs16,#$n1); if (p0.new) jump:nt $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_5401217, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b000000;
let Inst{31-22} = 0b0001000110;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpeqn1p0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpeqn1_tp0_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, n1Const:$n1, b30_2Imm:$Ii),
"p0 = cmp.eq($Rs16,#$n1); if (p0.new) jump:t $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_12419313, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b100000;
let Inst{31-22} = 0b0001000110;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpeqn1p0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpeqn1_tp1_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, n1Const:$n1, b30_2Imm:$Ii),
"p1 = cmp.eq($Rs16,#$n1); if (p1.new) jump:nt $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_4684887, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b000000;
let Inst{31-22} = 0b0001001110;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpeqn1p1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpeqn1_tp1_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, n1Const:$n1, b30_2Imm:$Ii),
"p1 = cmp.eq($Rs16,#$n1); if (p1.new) jump:t $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_220949, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b100000;
let Inst{31-22} = 0b0001001110;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpeqn1p1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgt_f_jumpnv_nt : HInst<
(outs),
(ins IntRegs:$Ns8, IntRegs:$Rt32, b30_2Imm:$Ii),
"if (!cmp.gt($Ns8.new,$Rt32)) jump:nt $Ii",
NCJ_tc_3or4stall_SLOT0, TypeNCJ>, Enc_15140689, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010000011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let cofMax1 = 1;
let isNewValue = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpgtr";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpgt_f_jumpnv_t : HInst<
(outs),
(ins IntRegs:$Ns8, IntRegs:$Rt32, b30_2Imm:$Ii),
"if (!cmp.gt($Ns8.new,$Rt32)) jump:t $Ii",
NCJ_tc_3or4stall_SLOT0, TypeNCJ>, Enc_15140689, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010000011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let cofMax1 = 1;
let isNewValue = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpgtr";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpgt_fp0_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, GeneralSubRegs:$Rt16, b30_2Imm:$Ii),
"p0 = cmp.gt($Rs16,$Rt16); if (!p0.new) jump:nt $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_14264243, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-12} = 0b00;
let Inst{31-22} = 0b0001010011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpgtp0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgt_fp0_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, GeneralSubRegs:$Rt16, b30_2Imm:$Ii),
"p0 = cmp.gt($Rs16,$Rt16); if (!p0.new) jump:t $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_14264243, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-12} = 0b10;
let Inst{31-22} = 0b0001010011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpgtp0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgt_fp1_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, GeneralSubRegs:$Rt16, b30_2Imm:$Ii),
"p1 = cmp.gt($Rs16,$Rt16); if (!p1.new) jump:nt $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_14264243, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-12} = 0b01;
let Inst{31-22} = 0b0001010011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpgtp1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgt_fp1_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, GeneralSubRegs:$Rt16, b30_2Imm:$Ii),
"p1 = cmp.gt($Rs16,$Rt16); if (!p1.new) jump:t $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_14264243, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-12} = 0b11;
let Inst{31-22} = 0b0001010011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpgtp1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgt_t_jumpnv_nt : HInst<
(outs),
(ins IntRegs:$Ns8, IntRegs:$Rt32, b30_2Imm:$Ii),
"if (cmp.gt($Ns8.new,$Rt32)) jump:nt $Ii",
NCJ_tc_3or4stall_SLOT0, TypeNCJ>, Enc_15140689, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010000010;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let cofMax1 = 1;
let isNewValue = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpgtr";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpgt_t_jumpnv_t : HInst<
(outs),
(ins IntRegs:$Ns8, IntRegs:$Rt32, b30_2Imm:$Ii),
"if (cmp.gt($Ns8.new,$Rt32)) jump:t $Ii",
NCJ_tc_3or4stall_SLOT0, TypeNCJ>, Enc_15140689, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010000010;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let cofMax1 = 1;
let isNewValue = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpgtr";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpgt_tp0_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, GeneralSubRegs:$Rt16, b30_2Imm:$Ii),
"p0 = cmp.gt($Rs16,$Rt16); if (p0.new) jump:nt $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_14264243, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-12} = 0b00;
let Inst{31-22} = 0b0001010010;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpgtp0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgt_tp0_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, GeneralSubRegs:$Rt16, b30_2Imm:$Ii),
"p0 = cmp.gt($Rs16,$Rt16); if (p0.new) jump:t $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_14264243, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-12} = 0b10;
let Inst{31-22} = 0b0001010010;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpgtp0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgt_tp1_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, GeneralSubRegs:$Rt16, b30_2Imm:$Ii),
"p1 = cmp.gt($Rs16,$Rt16); if (p1.new) jump:nt $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_14264243, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-12} = 0b01;
let Inst{31-22} = 0b0001010010;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpgtp1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgt_tp1_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, GeneralSubRegs:$Rt16, b30_2Imm:$Ii),
"p1 = cmp.gt($Rs16,$Rt16); if (p1.new) jump:t $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_14264243, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-12} = 0b11;
let Inst{31-22} = 0b0001010010;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpgtp1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgti_f_jumpnv_nt : HInst<
(outs),
(ins IntRegs:$Ns8, u5_0Imm:$II, b30_2Imm:$Ii),
"if (!cmp.gt($Ns8.new,#$II)) jump:nt $Ii",
NCJ_tc_3or4stall_SLOT0, TypeNCJ>, Enc_4397470, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010010011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let cofMax1 = 1;
let isNewValue = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpgtir";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpgti_f_jumpnv_t : HInst<
(outs),
(ins IntRegs:$Ns8, u5_0Imm:$II, b30_2Imm:$Ii),
"if (!cmp.gt($Ns8.new,#$II)) jump:t $Ii",
NCJ_tc_3or4stall_SLOT0, TypeNCJ>, Enc_4397470, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010010011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let cofMax1 = 1;
let isNewValue = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpgtir";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpgti_fp0_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u5_0Imm:$II, b30_2Imm:$Ii),
"p0 = cmp.gt($Rs16,#$II); if (!p0.new) jump:nt $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_7305764, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-22} = 0b0001000011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpgtip0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgti_fp0_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u5_0Imm:$II, b30_2Imm:$Ii),
"p0 = cmp.gt($Rs16,#$II); if (!p0.new) jump:t $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_7305764, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-22} = 0b0001000011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpgtip0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgti_fp1_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u5_0Imm:$II, b30_2Imm:$Ii),
"p1 = cmp.gt($Rs16,#$II); if (!p1.new) jump:nt $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_7305764, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-22} = 0b0001001011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpgtip1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgti_fp1_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u5_0Imm:$II, b30_2Imm:$Ii),
"p1 = cmp.gt($Rs16,#$II); if (!p1.new) jump:t $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_7305764, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-22} = 0b0001001011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpgtip1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgti_t_jumpnv_nt : HInst<
(outs),
(ins IntRegs:$Ns8, u5_0Imm:$II, b30_2Imm:$Ii),
"if (cmp.gt($Ns8.new,#$II)) jump:nt $Ii",
NCJ_tc_3or4stall_SLOT0, TypeNCJ>, Enc_4397470, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010010010;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let cofMax1 = 1;
let isNewValue = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpgtir";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpgti_t_jumpnv_t : HInst<
(outs),
(ins IntRegs:$Ns8, u5_0Imm:$II, b30_2Imm:$Ii),
"if (cmp.gt($Ns8.new,#$II)) jump:t $Ii",
NCJ_tc_3or4stall_SLOT0, TypeNCJ>, Enc_4397470, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010010010;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let cofMax1 = 1;
let isNewValue = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpgtir";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpgti_tp0_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u5_0Imm:$II, b30_2Imm:$Ii),
"p0 = cmp.gt($Rs16,#$II); if (p0.new) jump:nt $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_7305764, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-22} = 0b0001000010;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpgtip0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgti_tp0_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u5_0Imm:$II, b30_2Imm:$Ii),
"p0 = cmp.gt($Rs16,#$II); if (p0.new) jump:t $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_7305764, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-22} = 0b0001000010;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpgtip0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgti_tp1_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u5_0Imm:$II, b30_2Imm:$Ii),
"p1 = cmp.gt($Rs16,#$II); if (p1.new) jump:nt $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_7305764, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-22} = 0b0001001010;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpgtip1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgti_tp1_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u5_0Imm:$II, b30_2Imm:$Ii),
"p1 = cmp.gt($Rs16,#$II); if (p1.new) jump:t $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_7305764, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-22} = 0b0001001010;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpgtip1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgtn1_f_jumpnv_nt : HInst<
(outs),
(ins IntRegs:$Ns8, n1Const:$n1, b30_2Imm:$Ii),
"if (!cmp.gt($Ns8.new,#$n1)) jump:nt $Ii",
NCJ_tc_3or4stall_SLOT0, TypeNCJ>, Enc_8674673, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b000000;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010011011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let cofMax1 = 1;
let isNewValue = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpgtn1r";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpgtn1_f_jumpnv_t : HInst<
(outs),
(ins IntRegs:$Ns8, n1Const:$n1, b30_2Imm:$Ii),
"if (!cmp.gt($Ns8.new,#$n1)) jump:t $Ii",
NCJ_tc_3or4stall_SLOT0, TypeNCJ>, Enc_15763937, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b100000;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010011011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let cofMax1 = 1;
let isNewValue = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpgtn1r";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpgtn1_fp0_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, n1Const:$n1, b30_2Imm:$Ii),
"p0 = cmp.gt($Rs16,#$n1); if (!p0.new) jump:nt $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_5915771, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b000001;
let Inst{31-22} = 0b0001000111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpgtn1p0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgtn1_fp0_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, n1Const:$n1, b30_2Imm:$Ii),
"p0 = cmp.gt($Rs16,#$n1); if (!p0.new) jump:t $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_7315939, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b100001;
let Inst{31-22} = 0b0001000111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpgtn1p0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgtn1_fp1_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, n1Const:$n1, b30_2Imm:$Ii),
"p1 = cmp.gt($Rs16,#$n1); if (!p1.new) jump:nt $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_7785569, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b000001;
let Inst{31-22} = 0b0001001111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpgtn1p1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgtn1_fp1_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, n1Const:$n1, b30_2Imm:$Ii),
"p1 = cmp.gt($Rs16,#$n1); if (!p1.new) jump:t $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_10968391, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b100001;
let Inst{31-22} = 0b0001001111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpgtn1p1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgtn1_t_jumpnv_nt : HInst<
(outs),
(ins IntRegs:$Ns8, n1Const:$n1, b30_2Imm:$Ii),
"if (cmp.gt($Ns8.new,#$n1)) jump:nt $Ii",
NCJ_tc_3or4stall_SLOT0, TypeNCJ>, Enc_364753, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b000000;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010011010;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let cofMax1 = 1;
let isNewValue = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpgtn1r";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpgtn1_t_jumpnv_t : HInst<
(outs),
(ins IntRegs:$Ns8, n1Const:$n1, b30_2Imm:$Ii),
"if (cmp.gt($Ns8.new,#$n1)) jump:t $Ii",
NCJ_tc_3or4stall_SLOT0, TypeNCJ>, Enc_8479583, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b100000;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010011010;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let cofMax1 = 1;
let isNewValue = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpgtn1r";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpgtn1_tp0_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, n1Const:$n1, b30_2Imm:$Ii),
"p0 = cmp.gt($Rs16,#$n1); if (p0.new) jump:nt $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_2428539, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b000001;
let Inst{31-22} = 0b0001000110;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpgtn1p0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgtn1_tp0_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, n1Const:$n1, b30_2Imm:$Ii),
"p0 = cmp.gt($Rs16,#$n1); if (p0.new) jump:t $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_8919369, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b100001;
let Inst{31-22} = 0b0001000110;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpgtn1p0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgtn1_tp1_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, n1Const:$n1, b30_2Imm:$Ii),
"p1 = cmp.gt($Rs16,#$n1); if (p1.new) jump:nt $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_8577055, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b000001;
let Inst{31-22} = 0b0001001110;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpgtn1p1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgtn1_tp1_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, n1Const:$n1, b30_2Imm:$Ii),
"p1 = cmp.gt($Rs16,#$n1); if (p1.new) jump:t $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_14530015, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b100001;
let Inst{31-22} = 0b0001001110;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpgtn1p1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgtu_f_jumpnv_nt : HInst<
(outs),
(ins IntRegs:$Ns8, IntRegs:$Rt32, b30_2Imm:$Ii),
"if (!cmp.gtu($Ns8.new,$Rt32)) jump:nt $Ii",
NCJ_tc_3or4stall_SLOT0, TypeNCJ>, Enc_15140689, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010000101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let cofMax1 = 1;
let isNewValue = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpgtur";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpgtu_f_jumpnv_t : HInst<
(outs),
(ins IntRegs:$Ns8, IntRegs:$Rt32, b30_2Imm:$Ii),
"if (!cmp.gtu($Ns8.new,$Rt32)) jump:t $Ii",
NCJ_tc_3or4stall_SLOT0, TypeNCJ>, Enc_15140689, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010000101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let cofMax1 = 1;
let isNewValue = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpgtur";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpgtu_fp0_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, GeneralSubRegs:$Rt16, b30_2Imm:$Ii),
"p0 = cmp.gtu($Rs16,$Rt16); if (!p0.new) jump:nt $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_14264243, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-12} = 0b00;
let Inst{31-22} = 0b0001010101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpgtup0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgtu_fp0_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, GeneralSubRegs:$Rt16, b30_2Imm:$Ii),
"p0 = cmp.gtu($Rs16,$Rt16); if (!p0.new) jump:t $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_14264243, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-12} = 0b10;
let Inst{31-22} = 0b0001010101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpgtup0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgtu_fp1_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, GeneralSubRegs:$Rt16, b30_2Imm:$Ii),
"p1 = cmp.gtu($Rs16,$Rt16); if (!p1.new) jump:nt $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_14264243, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-12} = 0b01;
let Inst{31-22} = 0b0001010101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpgtup1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgtu_fp1_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, GeneralSubRegs:$Rt16, b30_2Imm:$Ii),
"p1 = cmp.gtu($Rs16,$Rt16); if (!p1.new) jump:t $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_14264243, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-12} = 0b11;
let Inst{31-22} = 0b0001010101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpgtup1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgtu_t_jumpnv_nt : HInst<
(outs),
(ins IntRegs:$Ns8, IntRegs:$Rt32, b30_2Imm:$Ii),
"if (cmp.gtu($Ns8.new,$Rt32)) jump:nt $Ii",
NCJ_tc_3or4stall_SLOT0, TypeNCJ>, Enc_15140689, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010000100;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let cofMax1 = 1;
let isNewValue = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpgtur";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpgtu_t_jumpnv_t : HInst<
(outs),
(ins IntRegs:$Ns8, IntRegs:$Rt32, b30_2Imm:$Ii),
"if (cmp.gtu($Ns8.new,$Rt32)) jump:t $Ii",
NCJ_tc_3or4stall_SLOT0, TypeNCJ>, Enc_15140689, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010000100;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let cofMax1 = 1;
let isNewValue = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpgtur";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpgtu_tp0_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, GeneralSubRegs:$Rt16, b30_2Imm:$Ii),
"p0 = cmp.gtu($Rs16,$Rt16); if (p0.new) jump:nt $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_14264243, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-12} = 0b00;
let Inst{31-22} = 0b0001010100;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpgtup0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgtu_tp0_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, GeneralSubRegs:$Rt16, b30_2Imm:$Ii),
"p0 = cmp.gtu($Rs16,$Rt16); if (p0.new) jump:t $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_14264243, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-12} = 0b10;
let Inst{31-22} = 0b0001010100;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpgtup0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgtu_tp1_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, GeneralSubRegs:$Rt16, b30_2Imm:$Ii),
"p1 = cmp.gtu($Rs16,$Rt16); if (p1.new) jump:nt $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_14264243, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-12} = 0b01;
let Inst{31-22} = 0b0001010100;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpgtup1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgtu_tp1_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, GeneralSubRegs:$Rt16, b30_2Imm:$Ii),
"p1 = cmp.gtu($Rs16,$Rt16); if (p1.new) jump:t $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_14264243, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-12} = 0b11;
let Inst{31-22} = 0b0001010100;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpgtup1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgtui_f_jumpnv_nt : HInst<
(outs),
(ins IntRegs:$Ns8, u5_0Imm:$II, b30_2Imm:$Ii),
"if (!cmp.gtu($Ns8.new,#$II)) jump:nt $Ii",
NCJ_tc_3or4stall_SLOT0, TypeNCJ>, Enc_4397470, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010010101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let cofMax1 = 1;
let isNewValue = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpgtuir";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpgtui_f_jumpnv_t : HInst<
(outs),
(ins IntRegs:$Ns8, u5_0Imm:$II, b30_2Imm:$Ii),
"if (!cmp.gtu($Ns8.new,#$II)) jump:t $Ii",
NCJ_tc_3or4stall_SLOT0, TypeNCJ>, Enc_4397470, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010010101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let cofMax1 = 1;
let isNewValue = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpgtuir";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpgtui_fp0_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u5_0Imm:$II, b30_2Imm:$Ii),
"p0 = cmp.gtu($Rs16,#$II); if (!p0.new) jump:nt $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_7305764, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-22} = 0b0001000101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpgtuip0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgtui_fp0_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u5_0Imm:$II, b30_2Imm:$Ii),
"p0 = cmp.gtu($Rs16,#$II); if (!p0.new) jump:t $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_7305764, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-22} = 0b0001000101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpgtuip0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgtui_fp1_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u5_0Imm:$II, b30_2Imm:$Ii),
"p1 = cmp.gtu($Rs16,#$II); if (!p1.new) jump:nt $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_7305764, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-22} = 0b0001001101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpgtuip1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgtui_fp1_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u5_0Imm:$II, b30_2Imm:$Ii),
"p1 = cmp.gtu($Rs16,#$II); if (!p1.new) jump:t $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_7305764, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-22} = 0b0001001101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpgtuip1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgtui_t_jumpnv_nt : HInst<
(outs),
(ins IntRegs:$Ns8, u5_0Imm:$II, b30_2Imm:$Ii),
"if (cmp.gtu($Ns8.new,#$II)) jump:nt $Ii",
NCJ_tc_3or4stall_SLOT0, TypeNCJ>, Enc_4397470, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010010100;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let cofMax1 = 1;
let isNewValue = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpgtuir";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpgtui_t_jumpnv_t : HInst<
(outs),
(ins IntRegs:$Ns8, u5_0Imm:$II, b30_2Imm:$Ii),
"if (cmp.gtu($Ns8.new,#$II)) jump:t $Ii",
NCJ_tc_3or4stall_SLOT0, TypeNCJ>, Enc_4397470, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010010100;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let cofMax1 = 1;
let isNewValue = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpgtuir";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpgtui_tp0_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u5_0Imm:$II, b30_2Imm:$Ii),
"p0 = cmp.gtu($Rs16,#$II); if (p0.new) jump:nt $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_7305764, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-22} = 0b0001000100;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpgtuip0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgtui_tp0_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u5_0Imm:$II, b30_2Imm:$Ii),
"p0 = cmp.gtu($Rs16,#$II); if (p0.new) jump:t $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_7305764, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-22} = 0b0001000100;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpgtuip0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgtui_tp1_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u5_0Imm:$II, b30_2Imm:$Ii),
"p1 = cmp.gtu($Rs16,#$II); if (p1.new) jump:nt $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_7305764, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-22} = 0b0001001100;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpgtuip1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgtui_tp1_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u5_0Imm:$II, b30_2Imm:$Ii),
"p1 = cmp.gtu($Rs16,#$II); if (p1.new) jump:t $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_7305764, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-22} = 0b0001001100;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpgtuip1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmplt_f_jumpnv_nt : HInst<
(outs),
(ins IntRegs:$Rt32, IntRegs:$Ns8, b30_2Imm:$Ii),
"if (!cmp.gt($Rt32,$Ns8.new)) jump:nt $Ii",
NCJ_tc_3or4stall_SLOT0, TypeNCJ>, Enc_6730375, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010000111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let cofMax1 = 1;
let isNewValue = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpltr";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 1;
}
def J4_cmplt_f_jumpnv_t : HInst<
(outs),
(ins IntRegs:$Rt32, IntRegs:$Ns8, b30_2Imm:$Ii),
"if (!cmp.gt($Rt32,$Ns8.new)) jump:t $Ii",
NCJ_tc_3or4stall_SLOT0, TypeNCJ>, Enc_6730375, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010000111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let cofMax1 = 1;
let isNewValue = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpltr";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 1;
}
def J4_cmplt_t_jumpnv_nt : HInst<
(outs),
(ins IntRegs:$Rt32, IntRegs:$Ns8, b30_2Imm:$Ii),
"if (cmp.gt($Rt32,$Ns8.new)) jump:nt $Ii",
NCJ_tc_3or4stall_SLOT0, TypeNCJ>, Enc_6730375, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010000110;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let cofMax1 = 1;
let isNewValue = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpltr";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 1;
}
def J4_cmplt_t_jumpnv_t : HInst<
(outs),
(ins IntRegs:$Rt32, IntRegs:$Ns8, b30_2Imm:$Ii),
"if (cmp.gt($Rt32,$Ns8.new)) jump:t $Ii",
NCJ_tc_3or4stall_SLOT0, TypeNCJ>, Enc_6730375, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010000110;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let cofMax1 = 1;
let isNewValue = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpltr";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 1;
}
def J4_cmpltu_f_jumpnv_nt : HInst<
(outs),
(ins IntRegs:$Rt32, IntRegs:$Ns8, b30_2Imm:$Ii),
"if (!cmp.gtu($Rt32,$Ns8.new)) jump:nt $Ii",
NCJ_tc_3or4stall_SLOT0, TypeNCJ>, Enc_6730375, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010001001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let cofMax1 = 1;
let isNewValue = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpltur";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 1;
}
def J4_cmpltu_f_jumpnv_t : HInst<
(outs),
(ins IntRegs:$Rt32, IntRegs:$Ns8, b30_2Imm:$Ii),
"if (!cmp.gtu($Rt32,$Ns8.new)) jump:t $Ii",
NCJ_tc_3or4stall_SLOT0, TypeNCJ>, Enc_6730375, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010001001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let cofMax1 = 1;
let isNewValue = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpltur";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 1;
}
def J4_cmpltu_t_jumpnv_nt : HInst<
(outs),
(ins IntRegs:$Rt32, IntRegs:$Ns8, b30_2Imm:$Ii),
"if (cmp.gtu($Rt32,$Ns8.new)) jump:nt $Ii",
NCJ_tc_3or4stall_SLOT0, TypeNCJ>, Enc_6730375, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010001000;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let cofMax1 = 1;
let isNewValue = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpltur";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 1;
}
def J4_cmpltu_t_jumpnv_t : HInst<
(outs),
(ins IntRegs:$Rt32, IntRegs:$Ns8, b30_2Imm:$Ii),
"if (cmp.gtu($Rt32,$Ns8.new)) jump:t $Ii",
NCJ_tc_3or4stall_SLOT0, TypeNCJ>, Enc_6730375, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010001000;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let cofMax1 = 1;
let isNewValue = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpltur";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 1;
}
def J4_hintjumpr : HInst<
(outs),
(ins IntRegs:$Rs32),
"hintjr($Rs32)",
J_tc_2early_SLOT2, TypeJ>, Enc_11704059 {
let Inst{13-0} = 0b00000000000000;
let Inst{31-21} = 0b01010010101;
let isTerminator = 1;
let isIndirectBranch = 1;
let isBranch = 1;
let cofMax1 = 1;
}
def J4_jumpseti : HInst<
(outs GeneralSubRegs:$Rd16),
(ins u6_0Imm:$II, b30_2Imm:$Ii),
"$Rd16 = #$II ; jump $Ii",
COMPOUND, TypeCJ>, Enc_4834775 {
let Inst{0-0} = 0b0;
let Inst{31-22} = 0b0001011000;
let hasNewValue = 1;
let opNewValue = 0;
let isTerminator = 1;
let isBranch = 1;
let Defs = [PC];
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_jumpsetr : HInst<
(outs GeneralSubRegs:$Rd16),
(ins GeneralSubRegs:$Rs16, b30_2Imm:$Ii),
"$Rd16 = $Rs16 ; jump $Ii",
COMPOUND, TypeCJ>, Enc_2639299 {
let Inst{0-0} = 0b0;
let Inst{13-12} = 0b00;
let Inst{31-22} = 0b0001011100;
let hasNewValue = 1;
let opNewValue = 0;
let isTerminator = 1;
let isBranch = 1;
let Defs = [PC];
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_tstbit0_f_jumpnv_nt : HInst<
(outs),
(ins IntRegs:$Ns8, b30_2Imm:$Ii),
"if (!tstbit($Ns8.new,#0)) jump:nt $Ii",
NCJ_tc_3or4stall_SLOT0, TypeNCJ>, Enc_1898420 {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b000000;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010010111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let cofMax1 = 1;
let isNewValue = 1;
let Defs = [PC];
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_tstbit0_f_jumpnv_t : HInst<
(outs),
(ins IntRegs:$Ns8, b30_2Imm:$Ii),
"if (!tstbit($Ns8.new,#0)) jump:t $Ii",
NCJ_tc_3or4stall_SLOT0, TypeNCJ>, Enc_1898420 {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b100000;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010010111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let cofMax1 = 1;
let isNewValue = 1;
let Defs = [PC];
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_tstbit0_fp0_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, b30_2Imm:$Ii),
"p0 = tstbit($Rs16,#0); if (!p0.new) jump:nt $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_12829314 {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b000011;
let Inst{31-22} = 0b0001000111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P0];
let Defs = [P0, PC];
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_tstbit0_fp0_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, b30_2Imm:$Ii),
"p0 = tstbit($Rs16,#0); if (!p0.new) jump:t $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_12829314 {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b100011;
let Inst{31-22} = 0b0001000111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P0];
let Defs = [P0, PC];
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_tstbit0_fp1_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, b30_2Imm:$Ii),
"p1 = tstbit($Rs16,#0); if (!p1.new) jump:nt $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_12829314 {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b000011;
let Inst{31-22} = 0b0001001111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P1];
let Defs = [P1, PC];
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_tstbit0_fp1_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, b30_2Imm:$Ii),
"p1 = tstbit($Rs16,#0); if (!p1.new) jump:t $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_12829314 {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b100011;
let Inst{31-22} = 0b0001001111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P1];
let Defs = [P1, PC];
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_tstbit0_t_jumpnv_nt : HInst<
(outs),
(ins IntRegs:$Ns8, b30_2Imm:$Ii),
"if (tstbit($Ns8.new,#0)) jump:nt $Ii",
NCJ_tc_3or4stall_SLOT0, TypeNCJ>, Enc_1898420 {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b000000;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010010110;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let cofMax1 = 1;
let isNewValue = 1;
let Defs = [PC];
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_tstbit0_t_jumpnv_t : HInst<
(outs),
(ins IntRegs:$Ns8, b30_2Imm:$Ii),
"if (tstbit($Ns8.new,#0)) jump:t $Ii",
NCJ_tc_3or4stall_SLOT0, TypeNCJ>, Enc_1898420 {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b100000;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010010110;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let cofMax1 = 1;
let isNewValue = 1;
let Defs = [PC];
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_tstbit0_tp0_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, b30_2Imm:$Ii),
"p0 = tstbit($Rs16,#0); if (p0.new) jump:nt $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_12829314 {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b000011;
let Inst{31-22} = 0b0001000110;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P0];
let Defs = [P0, PC];
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_tstbit0_tp0_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, b30_2Imm:$Ii),
"p0 = tstbit($Rs16,#0); if (p0.new) jump:t $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_12829314 {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b100011;
let Inst{31-22} = 0b0001000110;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P0];
let Defs = [P0, PC];
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_tstbit0_tp1_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, b30_2Imm:$Ii),
"p1 = tstbit($Rs16,#0); if (p1.new) jump:nt $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_12829314 {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b000011;
let Inst{31-22} = 0b0001001110;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P1];
let Defs = [P1, PC];
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_tstbit0_tp1_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, b30_2Imm:$Ii),
"p1 = tstbit($Rs16,#0); if (p1.new) jump:t $Ii",
COMPOUND_CJ_ARCHDEPSLOT, TypeCJ>, Enc_12829314 {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b100011;
let Inst{31-22} = 0b0001001110;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let Uses = [P1];
let Defs = [P1, PC];
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def L2_deallocframe : HInst<
(outs),
(ins),
"deallocframe",
LD_tc_ld_SLOT01, TypeLD>, Enc_0 {
let Inst{4-0} = 0b11110;
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b10010000000;
let Inst{20-16} = 0b11110;
let accessSize = DoubleWordAccess;
let mayLoad = 1;
let Uses = [R30];
let Defs = [R29, R30, R31];
}
def L2_loadalignb_io : HInst<
(outs DoubleRegs:$Ryy32),
(ins DoubleRegs:$Ryy32in, IntRegs:$Rs32, s32_0Imm:$Ii),
"$Ryy32 = memb_fifo($Rs32+#$Ii)",
LD_tc_ld_SLOT01, TypeLD>, Enc_449439 {
let Inst{24-21} = 0b0100;
let Inst{31-27} = 0b10010;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let mayLoad = 1;
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 0;
let Constraints = "$Ryy32 = $Ryy32in";
}
def L2_loadalignb_pbr : HInst<
(outs DoubleRegs:$Ryy32, IntRegs:$Rx32),
(ins DoubleRegs:$Ryy32in, IntRegs:$Rx32in, ModRegs:$Mu2),
"$Ryy32 = memb_fifo($Rx32++$Mu2:brev)",
LD_tc_ld_SLOT01, TypeLD>, Enc_12261611 {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b10011110100;
let accessSize = ByteAccess;
let mayLoad = 1;
let Constraints = "$Ryy32 = $Ryy32in, $Rx32 = $Rx32in";
}
def L2_loadalignb_pci : HInst<
(outs DoubleRegs:$Ryy32, IntRegs:$Rx32),
(ins DoubleRegs:$Ryy32in, IntRegs:$Rx32in, s4_0Imm:$Ii, ModRegs:$Mu2),
"$Ryy32 = memb_fifo($Rx32++#$Ii:circ($Mu2))",
LD_tc_ld_SLOT01, TypeLD>, Enc_971347 {
let Inst{12-9} = 0b0000;
let Inst{31-21} = 0b10011000100;
let addrMode = PostInc;
let accessSize = ByteAccess;
let mayLoad = 1;
let Uses = [CS];
let Constraints = "$Ryy32 = $Ryy32in, $Rx32 = $Rx32in";
}
def L2_loadalignb_pcr : HInst<
(outs DoubleRegs:$Ryy32, IntRegs:$Rx32),
(ins DoubleRegs:$Ryy32in, IntRegs:$Rx32in, ModRegs:$Mu2),
"$Ryy32 = memb_fifo($Rx32++I:circ($Mu2))",
LD_tc_ld_SLOT01, TypeLD>, Enc_12261611 {
let Inst{12-5} = 0b00010000;
let Inst{31-21} = 0b10011000100;
let addrMode = PostInc;
let accessSize = ByteAccess;
let mayLoad = 1;
let Uses = [CS];
let Constraints = "$Ryy32 = $Ryy32in, $Rx32 = $Rx32in";
}
def L2_loadalignb_pi : HInst<
(outs DoubleRegs:$Ryy32, IntRegs:$Rx32),
(ins DoubleRegs:$Ryy32in, IntRegs:$Rx32in, s4_0Imm:$Ii),
"$Ryy32 = memb_fifo($Rx32++#$Ii)",
LD_tc_ld_pi_SLOT01, TypeLD>, Enc_6372758 {
let Inst{13-9} = 0b00000;
let Inst{31-21} = 0b10011010100;
let addrMode = PostInc;
let accessSize = ByteAccess;
let mayLoad = 1;
let Constraints = "$Ryy32 = $Ryy32in, $Rx32 = $Rx32in";
}
def L2_loadalignb_pr : HInst<
(outs DoubleRegs:$Ryy32, IntRegs:$Rx32),
(ins DoubleRegs:$Ryy32in, IntRegs:$Rx32in, ModRegs:$Mu2),
"$Ryy32 = memb_fifo($Rx32++$Mu2)",
LD_tc_ld_SLOT01, TypeLD>, Enc_12261611 {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b10011100100;
let addrMode = PostInc;
let accessSize = ByteAccess;
let mayLoad = 1;
let Constraints = "$Ryy32 = $Ryy32in, $Rx32 = $Rx32in";
}
def L2_loadalignb_zomap : HInst<
(outs DoubleRegs:$Ryy32),
(ins DoubleRegs:$Ryy32in, IntRegs:$Rs32),
"$Ryy32 = memb_fifo($Rs32)",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let Constraints = "$Ryy32 = $Ryy32in";
}
def L2_loadalignh_io : HInst<
(outs DoubleRegs:$Ryy32),
(ins DoubleRegs:$Ryy32in, IntRegs:$Rs32, s31_1Imm:$Ii),
"$Ryy32 = memh_fifo($Rs32+#$Ii)",
LD_tc_ld_SLOT01, TypeLD>, Enc_11930027 {
let Inst{24-21} = 0b0010;
let Inst{31-27} = 0b10010;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 1;
let opExtentBits = 12;
let opExtentAlign = 1;
let Constraints = "$Ryy32 = $Ryy32in";
}
def L2_loadalignh_pbr : HInst<
(outs DoubleRegs:$Ryy32, IntRegs:$Rx32),
(ins DoubleRegs:$Ryy32in, IntRegs:$Rx32in, ModRegs:$Mu2),
"$Ryy32 = memh_fifo($Rx32++$Mu2:brev)",
LD_tc_ld_SLOT01, TypeLD>, Enc_12261611 {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b10011110010;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let Constraints = "$Ryy32 = $Ryy32in, $Rx32 = $Rx32in";
}
def L2_loadalignh_pci : HInst<
(outs DoubleRegs:$Ryy32, IntRegs:$Rx32),
(ins DoubleRegs:$Ryy32in, IntRegs:$Rx32in, s4_1Imm:$Ii, ModRegs:$Mu2),
"$Ryy32 = memh_fifo($Rx32++#$Ii:circ($Mu2))",
LD_tc_ld_SLOT01, TypeLD>, Enc_1971351 {
let Inst{12-9} = 0b0000;
let Inst{31-21} = 0b10011000010;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let Uses = [CS];
let Constraints = "$Ryy32 = $Ryy32in, $Rx32 = $Rx32in";
}
def L2_loadalignh_pcr : HInst<
(outs DoubleRegs:$Ryy32, IntRegs:$Rx32),
(ins DoubleRegs:$Ryy32in, IntRegs:$Rx32in, ModRegs:$Mu2),
"$Ryy32 = memh_fifo($Rx32++I:circ($Mu2))",
LD_tc_ld_SLOT01, TypeLD>, Enc_12261611 {
let Inst{12-5} = 0b00010000;
let Inst{31-21} = 0b10011000010;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let Uses = [CS];
let Constraints = "$Ryy32 = $Ryy32in, $Rx32 = $Rx32in";
}
def L2_loadalignh_pi : HInst<
(outs DoubleRegs:$Ryy32, IntRegs:$Rx32),
(ins DoubleRegs:$Ryy32in, IntRegs:$Rx32in, s4_1Imm:$Ii),
"$Ryy32 = memh_fifo($Rx32++#$Ii)",
LD_tc_ld_pi_SLOT01, TypeLD>, Enc_3372766 {
let Inst{13-9} = 0b00000;
let Inst{31-21} = 0b10011010010;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let Constraints = "$Ryy32 = $Ryy32in, $Rx32 = $Rx32in";
}
def L2_loadalignh_pr : HInst<
(outs DoubleRegs:$Ryy32, IntRegs:$Rx32),
(ins DoubleRegs:$Ryy32in, IntRegs:$Rx32in, ModRegs:$Mu2),
"$Ryy32 = memh_fifo($Rx32++$Mu2)",
LD_tc_ld_SLOT01, TypeLD>, Enc_12261611 {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b10011100010;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let Constraints = "$Ryy32 = $Ryy32in, $Rx32 = $Rx32in";
}
def L2_loadalignh_zomap : HInst<
(outs DoubleRegs:$Ryy32),
(ins DoubleRegs:$Ryy32in, IntRegs:$Rs32),
"$Ryy32 = memh_fifo($Rs32)",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let Constraints = "$Ryy32 = $Ryy32in";
}
def L2_loadbsw2_io : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, s31_1Imm:$Ii),
"$Rd32 = membh($Rs32+#$Ii)",
LD_tc_ld_SLOT01, TypeLD>, Enc_15275738 {
let Inst{24-21} = 0b0001;
let Inst{31-27} = 0b10010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 12;
let opExtentAlign = 1;
}
def L2_loadbsw2_pbr : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rd32 = membh($Rx32++$Mu2:brev)",
LD_tc_ld_SLOT01, TypeLD>, Enc_48594 {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b10011110001;
let hasNewValue = 1;
let opNewValue = 0;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadbsw2_pci : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_1Imm:$Ii, ModRegs:$Mu2),
"$Rd32 = membh($Rx32++#$Ii:circ($Mu2))",
LD_tc_ld_SLOT01, TypeLD>, Enc_13303422 {
let Inst{12-9} = 0b0000;
let Inst{31-21} = 0b10011000001;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let Uses = [CS];
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadbsw2_pcr : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rd32 = membh($Rx32++I:circ($Mu2))",
LD_tc_ld_SLOT01, TypeLD>, Enc_48594 {
let Inst{12-5} = 0b00010000;
let Inst{31-21} = 0b10011000001;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let Uses = [CS];
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadbsw2_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_1Imm:$Ii),
"$Rd32 = membh($Rx32++#$Ii)",
LD_tc_ld_pi_SLOT01, TypeLD>, Enc_15376009 {
let Inst{13-9} = 0b00000;
let Inst{31-21} = 0b10011010001;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadbsw2_pr : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rd32 = membh($Rx32++$Mu2)",
LD_tc_ld_SLOT01, TypeLD>, Enc_48594 {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b10011100001;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadbsw2_zomap : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = membh($Rs32)",
PSEUDO, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_loadbsw4_io : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, s30_2Imm:$Ii),
"$Rdd32 = membh($Rs32+#$Ii)",
LD_tc_ld_SLOT01, TypeLD>, Enc_9852473 {
let Inst{24-21} = 0b0111;
let Inst{31-27} = 0b10010;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let mayLoad = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 13;
let opExtentAlign = 2;
}
def L2_loadbsw4_pbr : HInst<
(outs DoubleRegs:$Rdd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rdd32 = membh($Rx32++$Mu2:brev)",
LD_tc_ld_SLOT01, TypeLD>, Enc_2901241 {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b10011110111;
let accessSize = WordAccess;
let mayLoad = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadbsw4_pci : HInst<
(outs DoubleRegs:$Rdd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_2Imm:$Ii, ModRegs:$Mu2),
"$Rdd32 = membh($Rx32++#$Ii:circ($Mu2))",
LD_tc_ld_SLOT01, TypeLD>, Enc_3931661 {
let Inst{12-9} = 0b0000;
let Inst{31-21} = 0b10011000111;
let addrMode = PostInc;
let accessSize = WordAccess;
let mayLoad = 1;
let Uses = [CS];
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadbsw4_pcr : HInst<
(outs DoubleRegs:$Rdd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rdd32 = membh($Rx32++I:circ($Mu2))",
LD_tc_ld_SLOT01, TypeLD>, Enc_2901241 {
let Inst{12-5} = 0b00010000;
let Inst{31-21} = 0b10011000111;
let addrMode = PostInc;
let accessSize = WordAccess;
let mayLoad = 1;
let Uses = [CS];
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadbsw4_pi : HInst<
(outs DoubleRegs:$Rdd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_2Imm:$Ii),
"$Rdd32 = membh($Rx32++#$Ii)",
LD_tc_ld_pi_SLOT01, TypeLD>, Enc_8752140 {
let Inst{13-9} = 0b00000;
let Inst{31-21} = 0b10011010111;
let addrMode = PostInc;
let accessSize = WordAccess;
let mayLoad = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadbsw4_pr : HInst<
(outs DoubleRegs:$Rdd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rdd32 = membh($Rx32++$Mu2)",
LD_tc_ld_SLOT01, TypeLD>, Enc_2901241 {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b10011100111;
let addrMode = PostInc;
let accessSize = WordAccess;
let mayLoad = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadbsw4_zomap : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32),
"$Rdd32 = membh($Rs32)",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_loadbzw2_io : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, s31_1Imm:$Ii),
"$Rd32 = memubh($Rs32+#$Ii)",
LD_tc_ld_SLOT01, TypeLD>, Enc_15275738 {
let Inst{24-21} = 0b0011;
let Inst{31-27} = 0b10010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 12;
let opExtentAlign = 1;
}
def L2_loadbzw2_pbr : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rd32 = memubh($Rx32++$Mu2:brev)",
LD_tc_ld_SLOT01, TypeLD>, Enc_48594 {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b10011110011;
let hasNewValue = 1;
let opNewValue = 0;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadbzw2_pci : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_1Imm:$Ii, ModRegs:$Mu2),
"$Rd32 = memubh($Rx32++#$Ii:circ($Mu2))",
LD_tc_ld_SLOT01, TypeLD>, Enc_13303422 {
let Inst{12-9} = 0b0000;
let Inst{31-21} = 0b10011000011;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let Uses = [CS];
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadbzw2_pcr : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rd32 = memubh($Rx32++I:circ($Mu2))",
LD_tc_ld_SLOT01, TypeLD>, Enc_48594 {
let Inst{12-5} = 0b00010000;
let Inst{31-21} = 0b10011000011;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let Uses = [CS];
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadbzw2_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_1Imm:$Ii),
"$Rd32 = memubh($Rx32++#$Ii)",
LD_tc_ld_pi_SLOT01, TypeLD>, Enc_15376009 {
let Inst{13-9} = 0b00000;
let Inst{31-21} = 0b10011010011;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadbzw2_pr : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rd32 = memubh($Rx32++$Mu2)",
LD_tc_ld_SLOT01, TypeLD>, Enc_48594 {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b10011100011;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadbzw2_zomap : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = memubh($Rs32)",
PSEUDO, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_loadbzw4_io : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, s30_2Imm:$Ii),
"$Rdd32 = memubh($Rs32+#$Ii)",
LD_tc_ld_SLOT01, TypeLD>, Enc_9852473 {
let Inst{24-21} = 0b0101;
let Inst{31-27} = 0b10010;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let mayLoad = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 13;
let opExtentAlign = 2;
}
def L2_loadbzw4_pbr : HInst<
(outs DoubleRegs:$Rdd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rdd32 = memubh($Rx32++$Mu2:brev)",
LD_tc_ld_SLOT01, TypeLD>, Enc_2901241 {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b10011110101;
let accessSize = WordAccess;
let mayLoad = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadbzw4_pci : HInst<
(outs DoubleRegs:$Rdd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_2Imm:$Ii, ModRegs:$Mu2),
"$Rdd32 = memubh($Rx32++#$Ii:circ($Mu2))",
LD_tc_ld_SLOT01, TypeLD>, Enc_3931661 {
let Inst{12-9} = 0b0000;
let Inst{31-21} = 0b10011000101;
let addrMode = PostInc;
let accessSize = WordAccess;
let mayLoad = 1;
let Uses = [CS];
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadbzw4_pcr : HInst<
(outs DoubleRegs:$Rdd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rdd32 = memubh($Rx32++I:circ($Mu2))",
LD_tc_ld_SLOT01, TypeLD>, Enc_2901241 {
let Inst{12-5} = 0b00010000;
let Inst{31-21} = 0b10011000101;
let addrMode = PostInc;
let accessSize = WordAccess;
let mayLoad = 1;
let Uses = [CS];
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadbzw4_pi : HInst<
(outs DoubleRegs:$Rdd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_2Imm:$Ii),
"$Rdd32 = memubh($Rx32++#$Ii)",
LD_tc_ld_pi_SLOT01, TypeLD>, Enc_8752140 {
let Inst{13-9} = 0b00000;
let Inst{31-21} = 0b10011010101;
let addrMode = PostInc;
let accessSize = WordAccess;
let mayLoad = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadbzw4_pr : HInst<
(outs DoubleRegs:$Rdd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rdd32 = memubh($Rx32++$Mu2)",
LD_tc_ld_SLOT01, TypeLD>, Enc_2901241 {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b10011100101;
let addrMode = PostInc;
let accessSize = WordAccess;
let mayLoad = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadbzw4_zomap : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32),
"$Rdd32 = memubh($Rs32)",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_loadrb_io : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, s32_0Imm:$Ii),
"$Rd32 = memb($Rs32+#$Ii)",
LD_tc_ld_SLOT01, TypeLD>, Enc_14461004, AddrModeRel {
let Inst{24-21} = 0b1000;
let Inst{31-27} = 0b10010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrb";
let BaseOpcode = "L2_loadrb_io";
let isPredicable = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 0;
}
def L2_loadrb_pbr : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rd32 = memb($Rx32++$Mu2:brev)",
LD_tc_ld_SLOT01, TypeLD>, Enc_48594 {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b10011111000;
let hasNewValue = 1;
let opNewValue = 0;
let accessSize = ByteAccess;
let mayLoad = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadrb_pci : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_0Imm:$Ii, ModRegs:$Mu2),
"$Rd32 = memb($Rx32++#$Ii:circ($Mu2))",
LD_tc_ld_SLOT01, TypeLD>, Enc_16303398 {
let Inst{12-9} = 0b0000;
let Inst{31-21} = 0b10011001000;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = ByteAccess;
let mayLoad = 1;
let Uses = [CS];
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadrb_pcr : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rd32 = memb($Rx32++I:circ($Mu2))",
LD_tc_ld_SLOT01, TypeLD>, Enc_48594 {
let Inst{12-5} = 0b00010000;
let Inst{31-21} = 0b10011001000;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = ByteAccess;
let mayLoad = 1;
let Uses = [CS];
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadrb_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_0Imm:$Ii),
"$Rd32 = memb($Rx32++#$Ii)",
LD_tc_ld_pi_SLOT01, TypeLD>, Enc_5598813, PredNewRel {
let Inst{13-9} = 0b00000;
let Inst{31-21} = 0b10011011000;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = ByteAccess;
let mayLoad = 1;
let BaseOpcode = "L2_loadrb_pi";
let isPredicable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadrb_pr : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rd32 = memb($Rx32++$Mu2)",
LD_tc_ld_SLOT01, TypeLD>, Enc_48594 {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b10011101000;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = ByteAccess;
let mayLoad = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadrb_zomap : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = memb($Rs32)",
PSEUDO, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_loadrbgp : HInst<
(outs IntRegs:$Rd32),
(ins u32_0Imm:$Ii),
"$Rd32 = memb(gp+#$Ii)",
V2LDST_tc_ld_SLOT01, TypeV2LDST>, Enc_1886960, AddrModeRel {
let Inst{24-21} = 0b1000;
let Inst{31-27} = 0b01001;
let hasNewValue = 1;
let opNewValue = 0;
let accessSize = ByteAccess;
let mayLoad = 1;
let Uses = [GP];
let BaseOpcode = "L4_loadrb_abs";
let isPredicable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 16;
let opExtentAlign = 0;
}
def L2_loadrd_io : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, s29_3Imm:$Ii),
"$Rdd32 = memd($Rs32+#$Ii)",
LD_tc_ld_SLOT01, TypeLD>, Enc_163381, AddrModeRel {
let Inst{24-21} = 0b1110;
let Inst{31-27} = 0b10010;
let addrMode = BaseImmOffset;
let accessSize = DoubleWordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrd";
let BaseOpcode = "L2_loadrd_io";
let isPredicable = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 14;
let opExtentAlign = 3;
}
def L2_loadrd_pbr : HInst<
(outs DoubleRegs:$Rdd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rdd32 = memd($Rx32++$Mu2:brev)",
LD_tc_ld_SLOT01, TypeLD>, Enc_2901241 {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b10011111110;
let accessSize = DoubleWordAccess;
let mayLoad = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadrd_pci : HInst<
(outs DoubleRegs:$Rdd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_3Imm:$Ii, ModRegs:$Mu2),
"$Rdd32 = memd($Rx32++#$Ii:circ($Mu2))",
LD_tc_ld_SLOT01, TypeLD>, Enc_931653 {
let Inst{12-9} = 0b0000;
let Inst{31-21} = 0b10011001110;
let addrMode = PostInc;
let accessSize = DoubleWordAccess;
let mayLoad = 1;
let Uses = [CS];
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadrd_pcr : HInst<
(outs DoubleRegs:$Rdd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rdd32 = memd($Rx32++I:circ($Mu2))",
LD_tc_ld_SLOT01, TypeLD>, Enc_2901241 {
let Inst{12-5} = 0b00010000;
let Inst{31-21} = 0b10011001110;
let addrMode = PostInc;
let accessSize = DoubleWordAccess;
let mayLoad = 1;
let Uses = [CS];
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadrd_pi : HInst<
(outs DoubleRegs:$Rdd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_3Imm:$Ii),
"$Rdd32 = memd($Rx32++#$Ii)",
LD_tc_ld_pi_SLOT01, TypeLD>, Enc_9752128, PredNewRel {
let Inst{13-9} = 0b00000;
let Inst{31-21} = 0b10011011110;
let addrMode = PostInc;
let accessSize = DoubleWordAccess;
let mayLoad = 1;
let BaseOpcode = "L2_loadrd_pi";
let isPredicable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadrd_pr : HInst<
(outs DoubleRegs:$Rdd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rdd32 = memd($Rx32++$Mu2)",
LD_tc_ld_SLOT01, TypeLD>, Enc_2901241 {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b10011101110;
let addrMode = PostInc;
let accessSize = DoubleWordAccess;
let mayLoad = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadrd_zomap : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32),
"$Rdd32 = memd($Rs32)",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_loadrdgp : HInst<
(outs DoubleRegs:$Rdd32),
(ins u29_3Imm:$Ii),
"$Rdd32 = memd(gp+#$Ii)",
V2LDST_tc_ld_SLOT01, TypeV2LDST>, Enc_4975051, AddrModeRel {
let Inst{24-21} = 0b1110;
let Inst{31-27} = 0b01001;
let accessSize = DoubleWordAccess;
let mayLoad = 1;
let Uses = [GP];
let BaseOpcode = "L4_loadrd_abs";
let isPredicable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 19;
let opExtentAlign = 3;
}
def L2_loadrh_io : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, s31_1Imm:$Ii),
"$Rd32 = memh($Rs32+#$Ii)",
LD_tc_ld_SLOT01, TypeLD>, Enc_15275738, AddrModeRel {
let Inst{24-21} = 0b1010;
let Inst{31-27} = 0b10010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrh";
let BaseOpcode = "L2_loadrh_io";
let isPredicable = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 12;
let opExtentAlign = 1;
}
def L2_loadrh_pbr : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rd32 = memh($Rx32++$Mu2:brev)",
LD_tc_ld_SLOT01, TypeLD>, Enc_48594 {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b10011111010;
let hasNewValue = 1;
let opNewValue = 0;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadrh_pci : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_1Imm:$Ii, ModRegs:$Mu2),
"$Rd32 = memh($Rx32++#$Ii:circ($Mu2))",
LD_tc_ld_SLOT01, TypeLD>, Enc_13303422 {
let Inst{12-9} = 0b0000;
let Inst{31-21} = 0b10011001010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let Uses = [CS];
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadrh_pcr : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rd32 = memh($Rx32++I:circ($Mu2))",
LD_tc_ld_SLOT01, TypeLD>, Enc_48594 {
let Inst{12-5} = 0b00010000;
let Inst{31-21} = 0b10011001010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let Uses = [CS];
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadrh_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_1Imm:$Ii),
"$Rd32 = memh($Rx32++#$Ii)",
LD_tc_ld_pi_SLOT01, TypeLD>, Enc_15376009, PredNewRel {
let Inst{13-9} = 0b00000;
let Inst{31-21} = 0b10011011010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let BaseOpcode = "L2_loadrh_pi";
let isPredicable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadrh_pr : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rd32 = memh($Rx32++$Mu2)",
LD_tc_ld_SLOT01, TypeLD>, Enc_48594 {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b10011101010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadrh_zomap : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = memh($Rs32)",
PSEUDO, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_loadrhgp : HInst<
(outs IntRegs:$Rd32),
(ins u31_1Imm:$Ii),
"$Rd32 = memh(gp+#$Ii)",
V2LDST_tc_ld_SLOT01, TypeV2LDST>, Enc_12608570, AddrModeRel {
let Inst{24-21} = 0b1010;
let Inst{31-27} = 0b01001;
let hasNewValue = 1;
let opNewValue = 0;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let Uses = [GP];
let BaseOpcode = "L4_loadrh_abs";
let isPredicable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 17;
let opExtentAlign = 1;
}
def L2_loadri_io : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, s30_2Imm:$Ii),
"$Rd32 = memw($Rs32+#$Ii)",
LD_tc_ld_SLOT01, TypeLD>, Enc_8990840, AddrModeRel {
let Inst{24-21} = 0b1100;
let Inst{31-27} = 0b10010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadri";
let BaseOpcode = "L2_loadri_io";
let isPredicable = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 13;
let opExtentAlign = 2;
}
def L2_loadri_pbr : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rd32 = memw($Rx32++$Mu2:brev)",
LD_tc_ld_SLOT01, TypeLD>, Enc_48594 {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b10011111100;
let hasNewValue = 1;
let opNewValue = 0;
let accessSize = WordAccess;
let mayLoad = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadri_pci : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_2Imm:$Ii, ModRegs:$Mu2),
"$Rd32 = memw($Rx32++#$Ii:circ($Mu2))",
LD_tc_ld_SLOT01, TypeLD>, Enc_14303394 {
let Inst{12-9} = 0b0000;
let Inst{31-21} = 0b10011001100;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = WordAccess;
let mayLoad = 1;
let Uses = [CS];
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadri_pcr : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rd32 = memw($Rx32++I:circ($Mu2))",
LD_tc_ld_SLOT01, TypeLD>, Enc_48594 {
let Inst{12-5} = 0b00010000;
let Inst{31-21} = 0b10011001100;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = WordAccess;
let mayLoad = 1;
let Uses = [CS];
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadri_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_2Imm:$Ii),
"$Rd32 = memw($Rx32++#$Ii)",
LD_tc_ld_pi_SLOT01, TypeLD>, Enc_16376009, PredNewRel {
let Inst{13-9} = 0b00000;
let Inst{31-21} = 0b10011011100;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = WordAccess;
let mayLoad = 1;
let BaseOpcode = "L2_loadri_pi";
let isPredicable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadri_pr : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rd32 = memw($Rx32++$Mu2)",
LD_tc_ld_SLOT01, TypeLD>, Enc_48594 {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b10011101100;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = WordAccess;
let mayLoad = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadri_zomap : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = memw($Rs32)",
PSEUDO, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_loadrigp : HInst<
(outs IntRegs:$Rd32),
(ins u30_2Imm:$Ii),
"$Rd32 = memw(gp+#$Ii)",
V2LDST_tc_ld_SLOT01, TypeV2LDST>, Enc_8814718, AddrModeRel {
let Inst{24-21} = 0b1100;
let Inst{31-27} = 0b01001;
let hasNewValue = 1;
let opNewValue = 0;
let accessSize = WordAccess;
let mayLoad = 1;
let Uses = [GP];
let BaseOpcode = "L4_loadri_abs";
let isPredicable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 18;
let opExtentAlign = 2;
}
def L2_loadrub_io : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, s32_0Imm:$Ii),
"$Rd32 = memub($Rs32+#$Ii)",
LD_tc_ld_SLOT01, TypeLD>, Enc_14461004, AddrModeRel {
let Inst{24-21} = 0b1001;
let Inst{31-27} = 0b10010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrub";
let BaseOpcode = "L2_loadrub_io";
let isPredicable = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 0;
}
def L2_loadrub_pbr : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rd32 = memub($Rx32++$Mu2:brev)",
LD_tc_ld_SLOT01, TypeLD>, Enc_48594 {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b10011111001;
let hasNewValue = 1;
let opNewValue = 0;
let accessSize = ByteAccess;
let mayLoad = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadrub_pci : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_0Imm:$Ii, ModRegs:$Mu2),
"$Rd32 = memub($Rx32++#$Ii:circ($Mu2))",
LD_tc_ld_SLOT01, TypeLD>, Enc_16303398 {
let Inst{12-9} = 0b0000;
let Inst{31-21} = 0b10011001001;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = ByteAccess;
let mayLoad = 1;
let Uses = [CS];
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadrub_pcr : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rd32 = memub($Rx32++I:circ($Mu2))",
LD_tc_ld_SLOT01, TypeLD>, Enc_48594 {
let Inst{12-5} = 0b00010000;
let Inst{31-21} = 0b10011001001;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = ByteAccess;
let mayLoad = 1;
let Uses = [CS];
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadrub_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_0Imm:$Ii),
"$Rd32 = memub($Rx32++#$Ii)",
LD_tc_ld_pi_SLOT01, TypeLD>, Enc_5598813, PredNewRel {
let Inst{13-9} = 0b00000;
let Inst{31-21} = 0b10011011001;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = ByteAccess;
let mayLoad = 1;
let BaseOpcode = "L2_loadrub_pi";
let isPredicable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadrub_pr : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rd32 = memub($Rx32++$Mu2)",
LD_tc_ld_SLOT01, TypeLD>, Enc_48594 {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b10011101001;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = ByteAccess;
let mayLoad = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadrub_zomap : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = memub($Rs32)",
PSEUDO, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_loadrubgp : HInst<
(outs IntRegs:$Rd32),
(ins u32_0Imm:$Ii),
"$Rd32 = memub(gp+#$Ii)",
V2LDST_tc_ld_SLOT01, TypeV2LDST>, Enc_1886960, AddrModeRel {
let Inst{24-21} = 0b1001;
let Inst{31-27} = 0b01001;
let hasNewValue = 1;
let opNewValue = 0;
let accessSize = ByteAccess;
let mayLoad = 1;
let Uses = [GP];
let BaseOpcode = "L4_loadrub_abs";
let isPredicable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 16;
let opExtentAlign = 0;
}
def L2_loadruh_io : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, s31_1Imm:$Ii),
"$Rd32 = memuh($Rs32+#$Ii)",
LD_tc_ld_SLOT01, TypeLD>, Enc_15275738, AddrModeRel {
let Inst{24-21} = 0b1011;
let Inst{31-27} = 0b10010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadruh";
let BaseOpcode = "L2_loadruh_io";
let isPredicable = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 12;
let opExtentAlign = 1;
}
def L2_loadruh_pbr : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rd32 = memuh($Rx32++$Mu2:brev)",
LD_tc_ld_SLOT01, TypeLD>, Enc_48594 {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b10011111011;
let hasNewValue = 1;
let opNewValue = 0;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadruh_pci : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_1Imm:$Ii, ModRegs:$Mu2),
"$Rd32 = memuh($Rx32++#$Ii:circ($Mu2))",
LD_tc_ld_SLOT01, TypeLD>, Enc_13303422 {
let Inst{12-9} = 0b0000;
let Inst{31-21} = 0b10011001011;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let Uses = [CS];
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadruh_pcr : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rd32 = memuh($Rx32++I:circ($Mu2))",
LD_tc_ld_SLOT01, TypeLD>, Enc_48594 {
let Inst{12-5} = 0b00010000;
let Inst{31-21} = 0b10011001011;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let Uses = [CS];
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadruh_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_1Imm:$Ii),
"$Rd32 = memuh($Rx32++#$Ii)",
LD_tc_ld_pi_SLOT01, TypeLD>, Enc_15376009, PredNewRel {
let Inst{13-9} = 0b00000;
let Inst{31-21} = 0b10011011011;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let BaseOpcode = "L2_loadruh_pi";
let isPredicable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadruh_pr : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rd32 = memuh($Rx32++$Mu2)",
LD_tc_ld_SLOT01, TypeLD>, Enc_48594 {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b10011101011;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadruh_zomap : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = memuh($Rs32)",
PSEUDO, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_loadruhgp : HInst<
(outs IntRegs:$Rd32),
(ins u31_1Imm:$Ii),
"$Rd32 = memuh(gp+#$Ii)",
V2LDST_tc_ld_SLOT01, TypeV2LDST>, Enc_12608570, AddrModeRel {
let Inst{24-21} = 0b1011;
let Inst{31-27} = 0b01001;
let hasNewValue = 1;
let opNewValue = 0;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let Uses = [GP];
let BaseOpcode = "L4_loadruh_abs";
let isPredicable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 17;
let opExtentAlign = 1;
}
def L2_loadw_locked : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = memw_locked($Rs32)",
LD_tc_ld_SLOT0, TypeLD>, Enc_4075554 {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b10010010000;
let hasNewValue = 1;
let opNewValue = 0;
let accessSize = WordAccess;
let isSoloAX = 1;
let mayLoad = 1;
}
def L2_ploadrbf_io : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32, u32_0Imm:$Ii),
"if (!$Pt4) $Rd32 = memb($Rs32+#$Ii)",
V2LDST_tc_ld_SLOT01, TypeV2LDST>, Enc_4835423, AddrModeRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01000101000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrb";
let BaseOpcode = "L2_loadrb_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L2_ploadrbf_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins PredRegs:$Pt4, IntRegs:$Rx32in, s4_0Imm:$Ii),
"if (!$Pt4) $Rd32 = memb($Rx32++#$Ii)",
LD_tc_ld_pi_SLOT01, TypeLD>, Enc_12212978, PredNewRel {
let Inst{13-11} = 0b101;
let Inst{31-21} = 0b10011011000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = ByteAccess;
let mayLoad = 1;
let BaseOpcode = "L2_loadrb_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def L2_ploadrbf_zomap : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32),
"if (!$Pt4) $Rd32 = memb($Rs32)",
PSEUDO, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_ploadrbfnew_io : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32, u32_0Imm:$Ii),
"if (!$Pt4.new) $Rd32 = memb($Rs32+#$Ii)",
V2LDST_tc_ld_SLOT01, TypeV2LDST>, Enc_4835423, AddrModeRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01000111000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrb";
let BaseOpcode = "L2_loadrb_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L2_ploadrbfnew_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins PredRegs:$Pt4, IntRegs:$Rx32in, s4_0Imm:$Ii),
"if (!$Pt4.new) $Rd32 = memb($Rx32++#$Ii)",
LD_tc_ld_pi_SLOT01, TypeLD>, Enc_12212978, PredNewRel {
let Inst{13-11} = 0b111;
let Inst{31-21} = 0b10011011000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = ByteAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let BaseOpcode = "L2_loadrb_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def L2_ploadrbfnew_zomap : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32),
"if (!$Pt4.new) $Rd32 = memb($Rs32)",
PSEUDO, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_ploadrbt_io : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32, u32_0Imm:$Ii),
"if ($Pt4) $Rd32 = memb($Rs32+#$Ii)",
V2LDST_tc_ld_SLOT01, TypeV2LDST>, Enc_4835423, AddrModeRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01000001000;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrb";
let BaseOpcode = "L2_loadrb_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L2_ploadrbt_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins PredRegs:$Pt4, IntRegs:$Rx32in, s4_0Imm:$Ii),
"if ($Pt4) $Rd32 = memb($Rx32++#$Ii)",
LD_tc_ld_pi_SLOT01, TypeLD>, Enc_12212978, PredNewRel {
let Inst{13-11} = 0b100;
let Inst{31-21} = 0b10011011000;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = ByteAccess;
let mayLoad = 1;
let BaseOpcode = "L2_loadrb_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def L2_ploadrbt_zomap : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32),
"if ($Pt4) $Rd32 = memb($Rs32)",
PSEUDO, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_ploadrbtnew_io : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32, u32_0Imm:$Ii),
"if ($Pt4.new) $Rd32 = memb($Rs32+#$Ii)",
V2LDST_tc_ld_SLOT01, TypeV2LDST>, Enc_4835423, AddrModeRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01000011000;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrb";
let BaseOpcode = "L2_loadrb_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L2_ploadrbtnew_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins PredRegs:$Pt4, IntRegs:$Rx32in, s4_0Imm:$Ii),
"if ($Pt4.new) $Rd32 = memb($Rx32++#$Ii)",
LD_tc_ld_pi_SLOT01, TypeLD>, Enc_12212978, PredNewRel {
let Inst{13-11} = 0b110;
let Inst{31-21} = 0b10011011000;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = ByteAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let BaseOpcode = "L2_loadrb_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def L2_ploadrbtnew_zomap : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32),
"if ($Pt4.new) $Rd32 = memb($Rs32)",
PSEUDO, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_ploadrdf_io : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32, u29_3Imm:$Ii),
"if (!$Pt4) $Rdd32 = memd($Rs32+#$Ii)",
V2LDST_tc_ld_SLOT01, TypeV2LDST>, Enc_677558, AddrModeRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01000101110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = DoubleWordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrd";
let BaseOpcode = "L2_loadrd_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 9;
let opExtentAlign = 3;
}
def L2_ploadrdf_pi : HInst<
(outs DoubleRegs:$Rdd32, IntRegs:$Rx32),
(ins PredRegs:$Pt4, IntRegs:$Rx32in, s4_3Imm:$Ii),
"if (!$Pt4) $Rdd32 = memd($Rx32++#$Ii)",
LD_tc_ld_pi_SLOT01, TypeLD>, Enc_5611087, PredNewRel {
let Inst{13-11} = 0b101;
let Inst{31-21} = 0b10011011110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = DoubleWordAccess;
let mayLoad = 1;
let BaseOpcode = "L2_loadrd_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def L2_ploadrdf_zomap : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32),
"if (!$Pt4) $Rdd32 = memd($Rs32)",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_ploadrdfnew_io : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32, u29_3Imm:$Ii),
"if (!$Pt4.new) $Rdd32 = memd($Rs32+#$Ii)",
V2LDST_tc_ld_SLOT01, TypeV2LDST>, Enc_677558, AddrModeRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01000111110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = DoubleWordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrd";
let BaseOpcode = "L2_loadrd_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 9;
let opExtentAlign = 3;
}
def L2_ploadrdfnew_pi : HInst<
(outs DoubleRegs:$Rdd32, IntRegs:$Rx32),
(ins PredRegs:$Pt4, IntRegs:$Rx32in, s4_3Imm:$Ii),
"if (!$Pt4.new) $Rdd32 = memd($Rx32++#$Ii)",
LD_tc_ld_pi_SLOT01, TypeLD>, Enc_5611087, PredNewRel {
let Inst{13-11} = 0b111;
let Inst{31-21} = 0b10011011110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = DoubleWordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let BaseOpcode = "L2_loadrd_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def L2_ploadrdfnew_zomap : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32),
"if (!$Pt4.new) $Rdd32 = memd($Rs32)",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_ploadrdt_io : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32, u29_3Imm:$Ii),
"if ($Pt4) $Rdd32 = memd($Rs32+#$Ii)",
V2LDST_tc_ld_SLOT01, TypeV2LDST>, Enc_677558, AddrModeRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01000001110;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = DoubleWordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrd";
let BaseOpcode = "L2_loadrd_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 9;
let opExtentAlign = 3;
}
def L2_ploadrdt_pi : HInst<
(outs DoubleRegs:$Rdd32, IntRegs:$Rx32),
(ins PredRegs:$Pt4, IntRegs:$Rx32in, s4_3Imm:$Ii),
"if ($Pt4) $Rdd32 = memd($Rx32++#$Ii)",
LD_tc_ld_pi_SLOT01, TypeLD>, Enc_5611087, PredNewRel {
let Inst{13-11} = 0b100;
let Inst{31-21} = 0b10011011110;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = DoubleWordAccess;
let mayLoad = 1;
let BaseOpcode = "L2_loadrd_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def L2_ploadrdt_zomap : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32),
"if ($Pt4) $Rdd32 = memd($Rs32)",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_ploadrdtnew_io : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32, u29_3Imm:$Ii),
"if ($Pt4.new) $Rdd32 = memd($Rs32+#$Ii)",
V2LDST_tc_ld_SLOT01, TypeV2LDST>, Enc_677558, AddrModeRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01000011110;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = DoubleWordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrd";
let BaseOpcode = "L2_loadrd_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 9;
let opExtentAlign = 3;
}
def L2_ploadrdtnew_pi : HInst<
(outs DoubleRegs:$Rdd32, IntRegs:$Rx32),
(ins PredRegs:$Pt4, IntRegs:$Rx32in, s4_3Imm:$Ii),
"if ($Pt4.new) $Rdd32 = memd($Rx32++#$Ii)",
LD_tc_ld_pi_SLOT01, TypeLD>, Enc_5611087, PredNewRel {
let Inst{13-11} = 0b110;
let Inst{31-21} = 0b10011011110;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = DoubleWordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let BaseOpcode = "L2_loadrd_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def L2_ploadrdtnew_zomap : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32),
"if ($Pt4.new) $Rdd32 = memd($Rs32)",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_ploadrhf_io : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32, u31_1Imm:$Ii),
"if (!$Pt4) $Rd32 = memh($Rs32+#$Ii)",
V2LDST_tc_ld_SLOT01, TypeV2LDST>, Enc_1835415, AddrModeRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01000101010;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrh";
let BaseOpcode = "L2_loadrh_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
}
def L2_ploadrhf_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins PredRegs:$Pt4, IntRegs:$Rx32in, s4_1Imm:$Ii),
"if (!$Pt4) $Rd32 = memh($Rx32++#$Ii)",
LD_tc_ld_pi_SLOT01, TypeLD>, Enc_7212930, PredNewRel {
let Inst{13-11} = 0b101;
let Inst{31-21} = 0b10011011010;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let BaseOpcode = "L2_loadrh_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def L2_ploadrhf_zomap : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32),
"if (!$Pt4) $Rd32 = memh($Rs32)",
PSEUDO, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_ploadrhfnew_io : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32, u31_1Imm:$Ii),
"if (!$Pt4.new) $Rd32 = memh($Rs32+#$Ii)",
V2LDST_tc_ld_SLOT01, TypeV2LDST>, Enc_1835415, AddrModeRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01000111010;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrh";
let BaseOpcode = "L2_loadrh_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
}
def L2_ploadrhfnew_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins PredRegs:$Pt4, IntRegs:$Rx32in, s4_1Imm:$Ii),
"if (!$Pt4.new) $Rd32 = memh($Rx32++#$Ii)",
LD_tc_ld_pi_SLOT01, TypeLD>, Enc_7212930, PredNewRel {
let Inst{13-11} = 0b111;
let Inst{31-21} = 0b10011011010;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let BaseOpcode = "L2_loadrh_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def L2_ploadrhfnew_zomap : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32),
"if (!$Pt4.new) $Rd32 = memh($Rs32)",
PSEUDO, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_ploadrht_io : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32, u31_1Imm:$Ii),
"if ($Pt4) $Rd32 = memh($Rs32+#$Ii)",
V2LDST_tc_ld_SLOT01, TypeV2LDST>, Enc_1835415, AddrModeRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01000001010;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrh";
let BaseOpcode = "L2_loadrh_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
}
def L2_ploadrht_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins PredRegs:$Pt4, IntRegs:$Rx32in, s4_1Imm:$Ii),
"if ($Pt4) $Rd32 = memh($Rx32++#$Ii)",
LD_tc_ld_pi_SLOT01, TypeLD>, Enc_7212930, PredNewRel {
let Inst{13-11} = 0b100;
let Inst{31-21} = 0b10011011010;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let BaseOpcode = "L2_loadrh_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def L2_ploadrht_zomap : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32),
"if ($Pt4) $Rd32 = memh($Rs32)",
PSEUDO, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_ploadrhtnew_io : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32, u31_1Imm:$Ii),
"if ($Pt4.new) $Rd32 = memh($Rs32+#$Ii)",
V2LDST_tc_ld_SLOT01, TypeV2LDST>, Enc_1835415, AddrModeRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01000011010;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrh";
let BaseOpcode = "L2_loadrh_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
}
def L2_ploadrhtnew_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins PredRegs:$Pt4, IntRegs:$Rx32in, s4_1Imm:$Ii),
"if ($Pt4.new) $Rd32 = memh($Rx32++#$Ii)",
LD_tc_ld_pi_SLOT01, TypeLD>, Enc_7212930, PredNewRel {
let Inst{13-11} = 0b110;
let Inst{31-21} = 0b10011011010;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let BaseOpcode = "L2_loadrh_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def L2_ploadrhtnew_zomap : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32),
"if ($Pt4.new) $Rd32 = memh($Rs32)",
PSEUDO, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_ploadrif_io : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32, u30_2Imm:$Ii),
"if (!$Pt4) $Rd32 = memw($Rs32+#$Ii)",
V2LDST_tc_ld_SLOT01, TypeV2LDST>, Enc_2835415, AddrModeRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01000101100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadri";
let BaseOpcode = "L2_loadri_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 2;
}
def L2_ploadrif_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins PredRegs:$Pt4, IntRegs:$Rx32in, s4_2Imm:$Ii),
"if (!$Pt4) $Rd32 = memw($Rx32++#$Ii)",
LD_tc_ld_pi_SLOT01, TypeLD>, Enc_6212930, PredNewRel {
let Inst{13-11} = 0b101;
let Inst{31-21} = 0b10011011100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = WordAccess;
let mayLoad = 1;
let BaseOpcode = "L2_loadri_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def L2_ploadrif_zomap : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32),
"if (!$Pt4) $Rd32 = memw($Rs32)",
PSEUDO, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_ploadrifnew_io : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32, u30_2Imm:$Ii),
"if (!$Pt4.new) $Rd32 = memw($Rs32+#$Ii)",
V2LDST_tc_ld_SLOT01, TypeV2LDST>, Enc_2835415, AddrModeRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01000111100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadri";
let BaseOpcode = "L2_loadri_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 2;
}
def L2_ploadrifnew_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins PredRegs:$Pt4, IntRegs:$Rx32in, s4_2Imm:$Ii),
"if (!$Pt4.new) $Rd32 = memw($Rx32++#$Ii)",
LD_tc_ld_pi_SLOT01, TypeLD>, Enc_6212930, PredNewRel {
let Inst{13-11} = 0b111;
let Inst{31-21} = 0b10011011100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = WordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let BaseOpcode = "L2_loadri_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def L2_ploadrifnew_zomap : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32),
"if (!$Pt4.new) $Rd32 = memw($Rs32)",
PSEUDO, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_ploadrit_io : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32, u30_2Imm:$Ii),
"if ($Pt4) $Rd32 = memw($Rs32+#$Ii)",
V2LDST_tc_ld_SLOT01, TypeV2LDST>, Enc_2835415, AddrModeRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01000001100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadri";
let BaseOpcode = "L2_loadri_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 2;
}
def L2_ploadrit_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins PredRegs:$Pt4, IntRegs:$Rx32in, s4_2Imm:$Ii),
"if ($Pt4) $Rd32 = memw($Rx32++#$Ii)",
LD_tc_ld_pi_SLOT01, TypeLD>, Enc_6212930, PredNewRel {
let Inst{13-11} = 0b100;
let Inst{31-21} = 0b10011011100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = WordAccess;
let mayLoad = 1;
let BaseOpcode = "L2_loadri_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def L2_ploadrit_zomap : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32),
"if ($Pt4) $Rd32 = memw($Rs32)",
PSEUDO, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_ploadritnew_io : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32, u30_2Imm:$Ii),
"if ($Pt4.new) $Rd32 = memw($Rs32+#$Ii)",
V2LDST_tc_ld_SLOT01, TypeV2LDST>, Enc_2835415, AddrModeRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01000011100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadri";
let BaseOpcode = "L2_loadri_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 2;
}
def L2_ploadritnew_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins PredRegs:$Pt4, IntRegs:$Rx32in, s4_2Imm:$Ii),
"if ($Pt4.new) $Rd32 = memw($Rx32++#$Ii)",
LD_tc_ld_pi_SLOT01, TypeLD>, Enc_6212930, PredNewRel {
let Inst{13-11} = 0b110;
let Inst{31-21} = 0b10011011100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = WordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let BaseOpcode = "L2_loadri_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def L2_ploadritnew_zomap : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32),
"if ($Pt4.new) $Rd32 = memw($Rs32)",
PSEUDO, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_ploadrubf_io : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32, u32_0Imm:$Ii),
"if (!$Pt4) $Rd32 = memub($Rs32+#$Ii)",
V2LDST_tc_ld_SLOT01, TypeV2LDST>, Enc_4835423, AddrModeRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01000101001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrub";
let BaseOpcode = "L2_loadrub_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L2_ploadrubf_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins PredRegs:$Pt4, IntRegs:$Rx32in, s4_0Imm:$Ii),
"if (!$Pt4) $Rd32 = memub($Rx32++#$Ii)",
LD_tc_ld_pi_SLOT01, TypeLD>, Enc_12212978, PredNewRel {
let Inst{13-11} = 0b101;
let Inst{31-21} = 0b10011011001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = ByteAccess;
let mayLoad = 1;
let BaseOpcode = "L2_loadrub_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def L2_ploadrubf_zomap : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32),
"if (!$Pt4) $Rd32 = memub($Rs32)",
PSEUDO, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_ploadrubfnew_io : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32, u32_0Imm:$Ii),
"if (!$Pt4.new) $Rd32 = memub($Rs32+#$Ii)",
V2LDST_tc_ld_SLOT01, TypeV2LDST>, Enc_4835423, AddrModeRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01000111001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrub";
let BaseOpcode = "L2_loadrub_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L2_ploadrubfnew_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins PredRegs:$Pt4, IntRegs:$Rx32in, s4_0Imm:$Ii),
"if (!$Pt4.new) $Rd32 = memub($Rx32++#$Ii)",
LD_tc_ld_pi_SLOT01, TypeLD>, Enc_12212978, PredNewRel {
let Inst{13-11} = 0b111;
let Inst{31-21} = 0b10011011001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = ByteAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let BaseOpcode = "L2_loadrub_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def L2_ploadrubfnew_zomap : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32),
"if (!$Pt4.new) $Rd32 = memub($Rs32)",
PSEUDO, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_ploadrubt_io : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32, u32_0Imm:$Ii),
"if ($Pt4) $Rd32 = memub($Rs32+#$Ii)",
V2LDST_tc_ld_SLOT01, TypeV2LDST>, Enc_4835423, AddrModeRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01000001001;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrub";
let BaseOpcode = "L2_loadrub_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L2_ploadrubt_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins PredRegs:$Pt4, IntRegs:$Rx32in, s4_0Imm:$Ii),
"if ($Pt4) $Rd32 = memub($Rx32++#$Ii)",
LD_tc_ld_pi_SLOT01, TypeLD>, Enc_12212978, PredNewRel {
let Inst{13-11} = 0b100;
let Inst{31-21} = 0b10011011001;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = ByteAccess;
let mayLoad = 1;
let BaseOpcode = "L2_loadrub_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def L2_ploadrubt_zomap : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32),
"if ($Pt4) $Rd32 = memub($Rs32)",
PSEUDO, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_ploadrubtnew_io : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32, u32_0Imm:$Ii),
"if ($Pt4.new) $Rd32 = memub($Rs32+#$Ii)",
V2LDST_tc_ld_SLOT01, TypeV2LDST>, Enc_4835423, AddrModeRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01000011001;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrub";
let BaseOpcode = "L2_loadrub_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L2_ploadrubtnew_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins PredRegs:$Pt4, IntRegs:$Rx32in, s4_0Imm:$Ii),
"if ($Pt4.new) $Rd32 = memub($Rx32++#$Ii)",
LD_tc_ld_pi_SLOT01, TypeLD>, Enc_12212978, PredNewRel {
let Inst{13-11} = 0b110;
let Inst{31-21} = 0b10011011001;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = ByteAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let BaseOpcode = "L2_loadrub_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def L2_ploadrubtnew_zomap : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32),
"if ($Pt4.new) $Rd32 = memub($Rs32)",
PSEUDO, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_ploadruhf_io : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32, u31_1Imm:$Ii),
"if (!$Pt4) $Rd32 = memuh($Rs32+#$Ii)",
V2LDST_tc_ld_SLOT01, TypeV2LDST>, Enc_1835415, AddrModeRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01000101011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadruh";
let BaseOpcode = "L2_loadruh_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
}
def L2_ploadruhf_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins PredRegs:$Pt4, IntRegs:$Rx32in, s4_1Imm:$Ii),
"if (!$Pt4) $Rd32 = memuh($Rx32++#$Ii)",
LD_tc_ld_pi_SLOT01, TypeLD>, Enc_7212930, PredNewRel {
let Inst{13-11} = 0b101;
let Inst{31-21} = 0b10011011011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let BaseOpcode = "L2_loadruh_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def L2_ploadruhf_zomap : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32),
"if (!$Pt4) $Rd32 = memuh($Rs32)",
PSEUDO, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_ploadruhfnew_io : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32, u31_1Imm:$Ii),
"if (!$Pt4.new) $Rd32 = memuh($Rs32+#$Ii)",
V2LDST_tc_ld_SLOT01, TypeV2LDST>, Enc_1835415, AddrModeRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01000111011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadruh";
let BaseOpcode = "L2_loadruh_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
}
def L2_ploadruhfnew_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins PredRegs:$Pt4, IntRegs:$Rx32in, s4_1Imm:$Ii),
"if (!$Pt4.new) $Rd32 = memuh($Rx32++#$Ii)",
LD_tc_ld_pi_SLOT01, TypeLD>, Enc_7212930, PredNewRel {
let Inst{13-11} = 0b111;
let Inst{31-21} = 0b10011011011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let BaseOpcode = "L2_loadruh_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def L2_ploadruhfnew_zomap : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32),
"if (!$Pt4.new) $Rd32 = memuh($Rs32)",
PSEUDO, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_ploadruht_io : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32, u31_1Imm:$Ii),
"if ($Pt4) $Rd32 = memuh($Rs32+#$Ii)",
V2LDST_tc_ld_SLOT01, TypeV2LDST>, Enc_1835415, AddrModeRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01000001011;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadruh";
let BaseOpcode = "L2_loadruh_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
}
def L2_ploadruht_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins PredRegs:$Pt4, IntRegs:$Rx32in, s4_1Imm:$Ii),
"if ($Pt4) $Rd32 = memuh($Rx32++#$Ii)",
LD_tc_ld_pi_SLOT01, TypeLD>, Enc_7212930, PredNewRel {
let Inst{13-11} = 0b100;
let Inst{31-21} = 0b10011011011;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let BaseOpcode = "L2_loadruh_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def L2_ploadruht_zomap : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32),
"if ($Pt4) $Rd32 = memuh($Rs32)",
PSEUDO, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_ploadruhtnew_io : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32, u31_1Imm:$Ii),
"if ($Pt4.new) $Rd32 = memuh($Rs32+#$Ii)",
V2LDST_tc_ld_SLOT01, TypeV2LDST>, Enc_1835415, AddrModeRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01000011011;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadruh";
let BaseOpcode = "L2_loadruh_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
}
def L2_ploadruhtnew_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins PredRegs:$Pt4, IntRegs:$Rx32in, s4_1Imm:$Ii),
"if ($Pt4.new) $Rd32 = memuh($Rx32++#$Ii)",
LD_tc_ld_pi_SLOT01, TypeLD>, Enc_7212930, PredNewRel {
let Inst{13-11} = 0b110;
let Inst{31-21} = 0b10011011011;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let BaseOpcode = "L2_loadruh_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def L2_ploadruhtnew_zomap : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32),
"if ($Pt4.new) $Rd32 = memuh($Rs32)",
PSEUDO, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_add_memopb_io : HInst<
(outs),
(ins IntRegs:$Rs32, u32_0Imm:$Ii, IntRegs:$Rt32),
"memb($Rs32+#$Ii) += $Rt32",
V4LDST_tc_st_SLOT0, TypeV4LDST>, Enc_11849200 {
let Inst{6-5} = 0b00;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00111110000;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let mayStore = 1;
let mayLoad = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_add_memopb_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"memb($Rs32) += $Rt32",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_add_memoph_io : HInst<
(outs),
(ins IntRegs:$Rs32, u31_1Imm:$Ii, IntRegs:$Rt32),
"memh($Rs32+#$Ii) += $Rt32",
V4LDST_tc_st_SLOT0, TypeV4LDST>, Enc_8849208 {
let Inst{6-5} = 0b00;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00111110001;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayStore = 1;
let mayLoad = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
}
def L4_add_memoph_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"memh($Rs32) += $Rt32",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_add_memopw_io : HInst<
(outs),
(ins IntRegs:$Rs32, u30_2Imm:$Ii, IntRegs:$Rt32),
"memw($Rs32+#$Ii) += $Rt32",
V4LDST_tc_st_SLOT0, TypeV4LDST>, Enc_9849208 {
let Inst{6-5} = 0b00;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00111110010;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let mayStore = 1;
let mayLoad = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 2;
}
def L4_add_memopw_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"memw($Rs32) += $Rt32",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_and_memopb_io : HInst<
(outs),
(ins IntRegs:$Rs32, u32_0Imm:$Ii, IntRegs:$Rt32),
"memb($Rs32+#$Ii) &= $Rt32",
V4LDST_tc_st_SLOT0, TypeV4LDST>, Enc_11849200 {
let Inst{6-5} = 0b10;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00111110000;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let mayStore = 1;
let mayLoad = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_and_memopb_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"memb($Rs32) &= $Rt32",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_and_memoph_io : HInst<
(outs),
(ins IntRegs:$Rs32, u31_1Imm:$Ii, IntRegs:$Rt32),
"memh($Rs32+#$Ii) &= $Rt32",
V4LDST_tc_st_SLOT0, TypeV4LDST>, Enc_8849208 {
let Inst{6-5} = 0b10;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00111110001;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayStore = 1;
let mayLoad = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
}
def L4_and_memoph_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"memh($Rs32) &= $Rt32",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_and_memopw_io : HInst<
(outs),
(ins IntRegs:$Rs32, u30_2Imm:$Ii, IntRegs:$Rt32),
"memw($Rs32+#$Ii) &= $Rt32",
V4LDST_tc_st_SLOT0, TypeV4LDST>, Enc_9849208 {
let Inst{6-5} = 0b10;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00111110010;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let mayStore = 1;
let mayLoad = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 2;
}
def L4_and_memopw_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"memw($Rs32) &= $Rt32",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_iadd_memopb_io : HInst<
(outs),
(ins IntRegs:$Rs32, u32_0Imm:$Ii, u5_0Imm:$II),
"memb($Rs32+#$Ii) += #$II",
V4LDST_tc_st_SLOT0, TypeV4LDST>, Enc_6773159 {
let Inst{6-5} = 0b00;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00111111000;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let mayStore = 1;
let mayLoad = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_iadd_memopb_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, u5_0Imm:$II),
"memb($Rs32) += #$II",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_iadd_memoph_io : HInst<
(outs),
(ins IntRegs:$Rs32, u31_1Imm:$Ii, u5_0Imm:$II),
"memh($Rs32+#$Ii) += #$II",
V4LDST_tc_st_SLOT0, TypeV4LDST>, Enc_9773167 {
let Inst{6-5} = 0b00;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00111111001;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayStore = 1;
let mayLoad = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
}
def L4_iadd_memoph_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, u5_0Imm:$II),
"memh($Rs32) += #$II",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_iadd_memopw_io : HInst<
(outs),
(ins IntRegs:$Rs32, u30_2Imm:$Ii, u5_0Imm:$II),
"memw($Rs32+#$Ii) += #$II",
V4LDST_tc_st_SLOT0, TypeV4LDST>, Enc_8773155 {
let Inst{6-5} = 0b00;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00111111010;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let mayStore = 1;
let mayLoad = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 2;
}
def L4_iadd_memopw_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, u5_0Imm:$II),
"memw($Rs32) += #$II",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_iand_memopb_io : HInst<
(outs),
(ins IntRegs:$Rs32, u32_0Imm:$Ii, u5_0Imm:$II),
"memb($Rs32+#$Ii) = clrbit(#$II)",
V4LDST_tc_st_SLOT0, TypeV4LDST>, Enc_6773159 {
let Inst{6-5} = 0b10;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00111111000;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let mayStore = 1;
let mayLoad = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_iand_memopb_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, u5_0Imm:$II),
"memb($Rs32) = clrbit(#$II)",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_iand_memoph_io : HInst<
(outs),
(ins IntRegs:$Rs32, u31_1Imm:$Ii, u5_0Imm:$II),
"memh($Rs32+#$Ii) = clrbit(#$II)",
V4LDST_tc_st_SLOT0, TypeV4LDST>, Enc_9773167 {
let Inst{6-5} = 0b10;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00111111001;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayStore = 1;
let mayLoad = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
}
def L4_iand_memoph_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, u5_0Imm:$II),
"memh($Rs32) = clrbit(#$II)",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_iand_memopw_io : HInst<
(outs),
(ins IntRegs:$Rs32, u30_2Imm:$Ii, u5_0Imm:$II),
"memw($Rs32+#$Ii) = clrbit(#$II)",
V4LDST_tc_st_SLOT0, TypeV4LDST>, Enc_8773155 {
let Inst{6-5} = 0b10;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00111111010;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let mayStore = 1;
let mayLoad = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 2;
}
def L4_iand_memopw_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, u5_0Imm:$II),
"memw($Rs32) = clrbit(#$II)",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_ior_memopb_io : HInst<
(outs),
(ins IntRegs:$Rs32, u32_0Imm:$Ii, u5_0Imm:$II),
"memb($Rs32+#$Ii) = setbit(#$II)",
V4LDST_tc_st_SLOT0, TypeV4LDST>, Enc_6773159 {
let Inst{6-5} = 0b11;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00111111000;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let mayStore = 1;
let mayLoad = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_ior_memopb_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, u5_0Imm:$II),
"memb($Rs32) = setbit(#$II)",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_ior_memoph_io : HInst<
(outs),
(ins IntRegs:$Rs32, u31_1Imm:$Ii, u5_0Imm:$II),
"memh($Rs32+#$Ii) = setbit(#$II)",
V4LDST_tc_st_SLOT0, TypeV4LDST>, Enc_9773167 {
let Inst{6-5} = 0b11;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00111111001;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayStore = 1;
let mayLoad = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
}
def L4_ior_memoph_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, u5_0Imm:$II),
"memh($Rs32) = setbit(#$II)",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_ior_memopw_io : HInst<
(outs),
(ins IntRegs:$Rs32, u30_2Imm:$Ii, u5_0Imm:$II),
"memw($Rs32+#$Ii) = setbit(#$II)",
V4LDST_tc_st_SLOT0, TypeV4LDST>, Enc_8773155 {
let Inst{6-5} = 0b11;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00111111010;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let mayStore = 1;
let mayLoad = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 2;
}
def L4_ior_memopw_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, u5_0Imm:$II),
"memw($Rs32) = setbit(#$II)",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_isub_memopb_io : HInst<
(outs),
(ins IntRegs:$Rs32, u32_0Imm:$Ii, u5_0Imm:$II),
"memb($Rs32+#$Ii) -= #$II",
V4LDST_tc_st_SLOT0, TypeV4LDST>, Enc_6773159 {
let Inst{6-5} = 0b01;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00111111000;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let mayStore = 1;
let mayLoad = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_isub_memopb_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, u5_0Imm:$II),
"memb($Rs32) -= #$II",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_isub_memoph_io : HInst<
(outs),
(ins IntRegs:$Rs32, u31_1Imm:$Ii, u5_0Imm:$II),
"memh($Rs32+#$Ii) -= #$II",
V4LDST_tc_st_SLOT0, TypeV4LDST>, Enc_9773167 {
let Inst{6-5} = 0b01;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00111111001;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayStore = 1;
let mayLoad = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
}
def L4_isub_memoph_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, u5_0Imm:$II),
"memh($Rs32) -= #$II",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_isub_memopw_io : HInst<
(outs),
(ins IntRegs:$Rs32, u30_2Imm:$Ii, u5_0Imm:$II),
"memw($Rs32+#$Ii) -= #$II",
V4LDST_tc_st_SLOT0, TypeV4LDST>, Enc_8773155 {
let Inst{6-5} = 0b01;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00111111010;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let mayStore = 1;
let mayLoad = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 2;
}
def L4_isub_memopw_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, u5_0Imm:$II),
"memw($Rs32) -= #$II",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_loadalignb_ap : HInst<
(outs DoubleRegs:$Ryy32, IntRegs:$Re32),
(ins DoubleRegs:$Ryy32in, u32_0Imm:$II),
"$Ryy32 = memb_fifo($Re32=#$II)",
LD_tc_ld_SLOT01, TypeLD>, Enc_11047413 {
let Inst{7-7} = 0b0;
let Inst{13-12} = 0b01;
let Inst{31-21} = 0b10011010100;
let hasNewValue = 1;
let opNewValue = 1;
let addrMode = AbsoluteSet;
let accessSize = ByteAccess;
let isExtended = 1;
let mayLoad = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let Constraints = "$Ryy32 = $Ryy32in";
}
def L4_loadalignb_ur : HInst<
(outs DoubleRegs:$Ryy32),
(ins DoubleRegs:$Ryy32in, IntRegs:$Rt32, u2_0Imm:$Ii, u32_0Imm:$II),
"$Ryy32 = memb_fifo($Rt32<<#$Ii+#$II)",
LD_tc_ld_SLOT01, TypeLD>, Enc_7303598 {
let Inst{12-12} = 0b1;
let Inst{31-21} = 0b10011100100;
let addrMode = BaseLongOffset;
let accessSize = ByteAccess;
let isExtended = 1;
let mayLoad = 1;
let InputType = "imm";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 4;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let Constraints = "$Ryy32 = $Ryy32in";
}
def L4_loadalignh_ap : HInst<
(outs DoubleRegs:$Ryy32, IntRegs:$Re32),
(ins DoubleRegs:$Ryy32in, u32_0Imm:$II),
"$Ryy32 = memh_fifo($Re32=#$II)",
LD_tc_ld_SLOT01, TypeLD>, Enc_11047413 {
let Inst{7-7} = 0b0;
let Inst{13-12} = 0b01;
let Inst{31-21} = 0b10011010010;
let hasNewValue = 1;
let opNewValue = 1;
let addrMode = AbsoluteSet;
let accessSize = HalfWordAccess;
let isExtended = 1;
let mayLoad = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let Constraints = "$Ryy32 = $Ryy32in";
}
def L4_loadalignh_ur : HInst<
(outs DoubleRegs:$Ryy32),
(ins DoubleRegs:$Ryy32in, IntRegs:$Rt32, u2_0Imm:$Ii, u32_0Imm:$II),
"$Ryy32 = memh_fifo($Rt32<<#$Ii+#$II)",
LD_tc_ld_SLOT01, TypeLD>, Enc_7303598 {
let Inst{12-12} = 0b1;
let Inst{31-21} = 0b10011100010;
let addrMode = BaseLongOffset;
let accessSize = HalfWordAccess;
let isExtended = 1;
let mayLoad = 1;
let InputType = "imm";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 4;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let Constraints = "$Ryy32 = $Ryy32in";
}
def L4_loadbsw2_ap : HInst<
(outs IntRegs:$Rd32, IntRegs:$Re32),
(ins u32_0Imm:$II),
"$Rd32 = membh($Re32=#$II)",
LD_tc_ld_SLOT01, TypeLD>, Enc_12616482 {
let Inst{7-7} = 0b0;
let Inst{13-12} = 0b01;
let Inst{31-21} = 0b10011010001;
let hasNewValue = 1;
let opNewValue = 0;
let hasNewValue2 = 1;
let opNewValue2 = 1;
let addrMode = AbsoluteSet;
let accessSize = HalfWordAccess;
let isExtended = 1;
let mayLoad = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_loadbsw2_ur : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, u2_0Imm:$Ii, u32_0Imm:$II),
"$Rd32 = membh($Rt32<<#$Ii+#$II)",
LD_tc_ld_SLOT01, TypeLD>, Enc_486163 {
let Inst{12-12} = 0b1;
let Inst{31-21} = 0b10011100001;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseLongOffset;
let accessSize = HalfWordAccess;
let isExtended = 1;
let mayLoad = 1;
let InputType = "imm";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_loadbsw4_ap : HInst<
(outs DoubleRegs:$Rdd32, IntRegs:$Re32),
(ins u32_0Imm:$II),
"$Rdd32 = membh($Re32=#$II)",
LD_tc_ld_SLOT01, TypeLD>, Enc_877823 {
let Inst{7-7} = 0b0;
let Inst{13-12} = 0b01;
let Inst{31-21} = 0b10011010111;
let hasNewValue = 1;
let opNewValue = 1;
let addrMode = AbsoluteSet;
let accessSize = WordAccess;
let isExtended = 1;
let mayLoad = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_loadbsw4_ur : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rt32, u2_0Imm:$Ii, u32_0Imm:$II),
"$Rdd32 = membh($Rt32<<#$Ii+#$II)",
LD_tc_ld_SLOT01, TypeLD>, Enc_5582416 {
let Inst{12-12} = 0b1;
let Inst{31-21} = 0b10011100111;
let addrMode = BaseLongOffset;
let accessSize = WordAccess;
let isExtended = 1;
let mayLoad = 1;
let InputType = "imm";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_loadbzw2_ap : HInst<
(outs IntRegs:$Rd32, IntRegs:$Re32),
(ins u32_0Imm:$II),
"$Rd32 = memubh($Re32=#$II)",
LD_tc_ld_SLOT01, TypeLD>, Enc_12616482 {
let Inst{7-7} = 0b0;
let Inst{13-12} = 0b01;
let Inst{31-21} = 0b10011010011;
let hasNewValue = 1;
let opNewValue = 0;
let hasNewValue2 = 1;
let opNewValue2 = 1;
let addrMode = AbsoluteSet;
let accessSize = HalfWordAccess;
let isExtended = 1;
let mayLoad = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_loadbzw2_ur : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, u2_0Imm:$Ii, u32_0Imm:$II),
"$Rd32 = memubh($Rt32<<#$Ii+#$II)",
LD_tc_ld_SLOT01, TypeLD>, Enc_486163 {
let Inst{12-12} = 0b1;
let Inst{31-21} = 0b10011100011;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseLongOffset;
let accessSize = HalfWordAccess;
let isExtended = 1;
let mayLoad = 1;
let InputType = "imm";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_loadbzw4_ap : HInst<
(outs DoubleRegs:$Rdd32, IntRegs:$Re32),
(ins u32_0Imm:$II),
"$Rdd32 = memubh($Re32=#$II)",
LD_tc_ld_SLOT01, TypeLD>, Enc_877823 {
let Inst{7-7} = 0b0;
let Inst{13-12} = 0b01;
let Inst{31-21} = 0b10011010101;
let hasNewValue = 1;
let opNewValue = 1;
let addrMode = AbsoluteSet;
let accessSize = WordAccess;
let isExtended = 1;
let mayLoad = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_loadbzw4_ur : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rt32, u2_0Imm:$Ii, u32_0Imm:$II),
"$Rdd32 = memubh($Rt32<<#$Ii+#$II)",
LD_tc_ld_SLOT01, TypeLD>, Enc_5582416 {
let Inst{12-12} = 0b1;
let Inst{31-21} = 0b10011100101;
let addrMode = BaseLongOffset;
let accessSize = WordAccess;
let isExtended = 1;
let mayLoad = 1;
let InputType = "imm";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_loadd_locked : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32),
"$Rdd32 = memd_locked($Rs32)",
LD_tc_ld_SLOT0, TypeLD>, Enc_4030179 {
let Inst{13-5} = 0b010000000;
let Inst{31-21} = 0b10010010000;
let accessSize = DoubleWordAccess;
let isSoloAX = 1;
let mayLoad = 1;
}
def L4_loadrb_ap : HInst<
(outs IntRegs:$Rd32, IntRegs:$Re32),
(ins u32_0Imm:$II),
"$Rd32 = memb($Re32=#$II)",
LD_tc_ld_SLOT01, TypeLD>, Enc_12616482 {
let Inst{7-7} = 0b0;
let Inst{13-12} = 0b01;
let Inst{31-21} = 0b10011011000;
let hasNewValue = 1;
let opNewValue = 0;
let hasNewValue2 = 1;
let opNewValue2 = 1;
let addrMode = AbsoluteSet;
let accessSize = ByteAccess;
let isExtended = 1;
let mayLoad = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_loadrb_rr : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"$Rd32 = memb($Rs32+$Rt32<<#$Ii)",
V4LDST_tc_ld_SLOT01, TypeLD>, Enc_10721363, AddrModeRel, ImmRegShl {
let Inst{6-5} = 0b00;
let Inst{31-21} = 0b00111010000;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseRegOffset;
let accessSize = ByteAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrb";
let InputType = "reg";
let BaseOpcode = "L4_loadrb_rr";
let isPredicable = 1;
}
def L4_loadrb_ur : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, u2_0Imm:$Ii, u32_0Imm:$II),
"$Rd32 = memb($Rt32<<#$Ii+#$II)",
LD_tc_ld_SLOT01, TypeLD>, Enc_486163, AddrModeRel, ImmRegShl {
let Inst{12-12} = 0b1;
let Inst{31-21} = 0b10011101000;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseLongOffset;
let accessSize = ByteAccess;
let isExtended = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrb";
let InputType = "imm";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_loadrd_ap : HInst<
(outs DoubleRegs:$Rdd32, IntRegs:$Re32),
(ins u32_0Imm:$II),
"$Rdd32 = memd($Re32=#$II)",
LD_tc_ld_SLOT01, TypeLD>, Enc_877823 {
let Inst{7-7} = 0b0;
let Inst{13-12} = 0b01;
let Inst{31-21} = 0b10011011110;
let hasNewValue = 1;
let opNewValue = 1;
let addrMode = AbsoluteSet;
let accessSize = DoubleWordAccess;
let isExtended = 1;
let mayLoad = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_loadrd_rr : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"$Rdd32 = memd($Rs32+$Rt32<<#$Ii)",
V4LDST_tc_ld_SLOT01, TypeLD>, Enc_7581852, AddrModeRel, ImmRegShl {
let Inst{6-5} = 0b00;
let Inst{31-21} = 0b00111010110;
let addrMode = BaseRegOffset;
let accessSize = DoubleWordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrd";
let InputType = "reg";
let BaseOpcode = "L4_loadrd_rr";
let isPredicable = 1;
}
def L4_loadrd_ur : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rt32, u2_0Imm:$Ii, u32_0Imm:$II),
"$Rdd32 = memd($Rt32<<#$Ii+#$II)",
LD_tc_ld_SLOT01, TypeLD>, Enc_5582416, AddrModeRel, ImmRegShl {
let Inst{12-12} = 0b1;
let Inst{31-21} = 0b10011101110;
let addrMode = BaseLongOffset;
let accessSize = DoubleWordAccess;
let isExtended = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrd";
let InputType = "imm";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_loadrh_ap : HInst<
(outs IntRegs:$Rd32, IntRegs:$Re32),
(ins u32_0Imm:$II),
"$Rd32 = memh($Re32=#$II)",
LD_tc_ld_SLOT01, TypeLD>, Enc_12616482 {
let Inst{7-7} = 0b0;
let Inst{13-12} = 0b01;
let Inst{31-21} = 0b10011011010;
let hasNewValue = 1;
let opNewValue = 0;
let hasNewValue2 = 1;
let opNewValue2 = 1;
let addrMode = AbsoluteSet;
let accessSize = HalfWordAccess;
let isExtended = 1;
let mayLoad = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_loadrh_rr : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"$Rd32 = memh($Rs32+$Rt32<<#$Ii)",
V4LDST_tc_ld_SLOT01, TypeLD>, Enc_10721363, AddrModeRel, ImmRegShl {
let Inst{6-5} = 0b00;
let Inst{31-21} = 0b00111010010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseRegOffset;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrh";
let InputType = "reg";
let BaseOpcode = "L4_loadrh_rr";
let isPredicable = 1;
}
def L4_loadrh_ur : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, u2_0Imm:$Ii, u32_0Imm:$II),
"$Rd32 = memh($Rt32<<#$Ii+#$II)",
LD_tc_ld_SLOT01, TypeLD>, Enc_486163, AddrModeRel, ImmRegShl {
let Inst{12-12} = 0b1;
let Inst{31-21} = 0b10011101010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseLongOffset;
let accessSize = HalfWordAccess;
let isExtended = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrh";
let InputType = "imm";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_loadri_ap : HInst<
(outs IntRegs:$Rd32, IntRegs:$Re32),
(ins u32_0Imm:$II),
"$Rd32 = memw($Re32=#$II)",
LD_tc_ld_SLOT01, TypeLD>, Enc_12616482 {
let Inst{7-7} = 0b0;
let Inst{13-12} = 0b01;
let Inst{31-21} = 0b10011011100;
let hasNewValue = 1;
let opNewValue = 0;
let hasNewValue2 = 1;
let opNewValue2 = 1;
let addrMode = AbsoluteSet;
let accessSize = WordAccess;
let isExtended = 1;
let mayLoad = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_loadri_rr : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"$Rd32 = memw($Rs32+$Rt32<<#$Ii)",
V4LDST_tc_ld_SLOT01, TypeLD>, Enc_10721363, AddrModeRel, ImmRegShl {
let Inst{6-5} = 0b00;
let Inst{31-21} = 0b00111010100;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseRegOffset;
let accessSize = WordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadri";
let InputType = "reg";
let BaseOpcode = "L4_loadri_rr";
let isPredicable = 1;
}
def L4_loadri_ur : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, u2_0Imm:$Ii, u32_0Imm:$II),
"$Rd32 = memw($Rt32<<#$Ii+#$II)",
LD_tc_ld_SLOT01, TypeLD>, Enc_486163, AddrModeRel, ImmRegShl {
let Inst{12-12} = 0b1;
let Inst{31-21} = 0b10011101100;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseLongOffset;
let accessSize = WordAccess;
let isExtended = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadri";
let InputType = "imm";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_loadrub_ap : HInst<
(outs IntRegs:$Rd32, IntRegs:$Re32),
(ins u32_0Imm:$II),
"$Rd32 = memub($Re32=#$II)",
LD_tc_ld_SLOT01, TypeLD>, Enc_12616482 {
let Inst{7-7} = 0b0;
let Inst{13-12} = 0b01;
let Inst{31-21} = 0b10011011001;
let hasNewValue = 1;
let opNewValue = 0;
let hasNewValue2 = 1;
let opNewValue2 = 1;
let addrMode = AbsoluteSet;
let accessSize = ByteAccess;
let isExtended = 1;
let mayLoad = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_loadrub_rr : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"$Rd32 = memub($Rs32+$Rt32<<#$Ii)",
V4LDST_tc_ld_SLOT01, TypeLD>, Enc_10721363, AddrModeRel, ImmRegShl {
let Inst{6-5} = 0b00;
let Inst{31-21} = 0b00111010001;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseRegOffset;
let accessSize = ByteAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrub";
let InputType = "reg";
let BaseOpcode = "L4_loadrub_rr";
let isPredicable = 1;
}
def L4_loadrub_ur : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, u2_0Imm:$Ii, u32_0Imm:$II),
"$Rd32 = memub($Rt32<<#$Ii+#$II)",
LD_tc_ld_SLOT01, TypeLD>, Enc_486163, AddrModeRel, ImmRegShl {
let Inst{12-12} = 0b1;
let Inst{31-21} = 0b10011101001;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseLongOffset;
let accessSize = ByteAccess;
let isExtended = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrub";
let InputType = "imm";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_loadruh_ap : HInst<
(outs IntRegs:$Rd32, IntRegs:$Re32),
(ins u32_0Imm:$II),
"$Rd32 = memuh($Re32=#$II)",
LD_tc_ld_SLOT01, TypeLD>, Enc_12616482 {
let Inst{7-7} = 0b0;
let Inst{13-12} = 0b01;
let Inst{31-21} = 0b10011011011;
let hasNewValue = 1;
let opNewValue = 0;
let hasNewValue2 = 1;
let opNewValue2 = 1;
let addrMode = AbsoluteSet;
let accessSize = HalfWordAccess;
let isExtended = 1;
let mayLoad = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_loadruh_rr : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"$Rd32 = memuh($Rs32+$Rt32<<#$Ii)",
V4LDST_tc_ld_SLOT01, TypeLD>, Enc_10721363, AddrModeRel, ImmRegShl {
let Inst{6-5} = 0b00;
let Inst{31-21} = 0b00111010011;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseRegOffset;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadruh";
let InputType = "reg";
let BaseOpcode = "L4_loadruh_rr";
let isPredicable = 1;
}
def L4_loadruh_ur : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, u2_0Imm:$Ii, u32_0Imm:$II),
"$Rd32 = memuh($Rt32<<#$Ii+#$II)",
LD_tc_ld_SLOT01, TypeLD>, Enc_486163, AddrModeRel, ImmRegShl {
let Inst{12-12} = 0b1;
let Inst{31-21} = 0b10011101011;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseLongOffset;
let accessSize = HalfWordAccess;
let isExtended = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadruh";
let InputType = "imm";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_or_memopb_io : HInst<
(outs),
(ins IntRegs:$Rs32, u32_0Imm:$Ii, IntRegs:$Rt32),
"memb($Rs32+#$Ii) |= $Rt32",
V4LDST_tc_st_SLOT0, TypeV4LDST>, Enc_11849200 {
let Inst{6-5} = 0b11;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00111110000;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let mayStore = 1;
let mayLoad = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_or_memopb_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"memb($Rs32) |= $Rt32",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_or_memoph_io : HInst<
(outs),
(ins IntRegs:$Rs32, u31_1Imm:$Ii, IntRegs:$Rt32),
"memh($Rs32+#$Ii) |= $Rt32",
V4LDST_tc_st_SLOT0, TypeV4LDST>, Enc_8849208 {
let Inst{6-5} = 0b11;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00111110001;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayStore = 1;
let mayLoad = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
}
def L4_or_memoph_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"memh($Rs32) |= $Rt32",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_or_memopw_io : HInst<
(outs),
(ins IntRegs:$Rs32, u30_2Imm:$Ii, IntRegs:$Rt32),
"memw($Rs32+#$Ii) |= $Rt32",
V4LDST_tc_st_SLOT0, TypeV4LDST>, Enc_9849208 {
let Inst{6-5} = 0b11;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00111110010;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let mayStore = 1;
let mayLoad = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 2;
}
def L4_or_memopw_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"memw($Rs32) |= $Rt32",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_ploadrbf_abs : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, u32_0Imm:$Ii),
"if (!$Pt4) $Rd32 = memb(#$Ii)",
LD_tc_ld_SLOT01, TypeLD>, Enc_13344657, AddrModeRel {
let Inst{7-5} = 0b100;
let Inst{13-11} = 0b101;
let Inst{31-21} = 0b10011111000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = Absolute;
let accessSize = ByteAccess;
let isExtended = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrb";
let BaseOpcode = "L4_loadrb_abs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_ploadrbf_rr : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"if (!$Pv4) $Rd32 = memb($Rs32+$Rt32<<#$Ii)",
V4LDST_tc_ld_SLOT01, TypeLD>, Enc_1793896, AddrModeRel {
let Inst{31-21} = 0b00110001000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseRegOffset;
let accessSize = ByteAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrb";
let InputType = "reg";
let BaseOpcode = "L4_loadrb_rr";
}
def L4_ploadrbfnew_abs : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, u32_0Imm:$Ii),
"if (!$Pt4.new) $Rd32 = memb(#$Ii)",
LD_tc_ld_SLOT01, TypeLD>, Enc_13344657, AddrModeRel {
let Inst{7-5} = 0b100;
let Inst{13-11} = 0b111;
let Inst{31-21} = 0b10011111000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = Absolute;
let accessSize = ByteAccess;
let isExtended = 1;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrb";
let BaseOpcode = "L4_loadrb_abs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_ploadrbfnew_rr : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"if (!$Pv4.new) $Rd32 = memb($Rs32+$Rt32<<#$Ii)",
V4LDST_tc_ld_SLOT01, TypeLD>, Enc_1793896, AddrModeRel {
let Inst{31-21} = 0b00110011000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseRegOffset;
let accessSize = ByteAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrb";
let InputType = "reg";
let BaseOpcode = "L4_loadrb_rr";
}
def L4_ploadrbt_abs : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, u32_0Imm:$Ii),
"if ($Pt4) $Rd32 = memb(#$Ii)",
LD_tc_ld_SLOT01, TypeLD>, Enc_13344657, AddrModeRel {
let Inst{7-5} = 0b100;
let Inst{13-11} = 0b100;
let Inst{31-21} = 0b10011111000;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = Absolute;
let accessSize = ByteAccess;
let isExtended = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrb";
let BaseOpcode = "L4_loadrb_abs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_ploadrbt_rr : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"if ($Pv4) $Rd32 = memb($Rs32+$Rt32<<#$Ii)",
V4LDST_tc_ld_SLOT01, TypeLD>, Enc_1793896, AddrModeRel {
let Inst{31-21} = 0b00110000000;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseRegOffset;
let accessSize = ByteAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrb";
let InputType = "reg";
let BaseOpcode = "L4_loadrb_rr";
}
def L4_ploadrbtnew_abs : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, u32_0Imm:$Ii),
"if ($Pt4.new) $Rd32 = memb(#$Ii)",
LD_tc_ld_SLOT01, TypeLD>, Enc_13344657, AddrModeRel {
let Inst{7-5} = 0b100;
let Inst{13-11} = 0b110;
let Inst{31-21} = 0b10011111000;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = Absolute;
let accessSize = ByteAccess;
let isExtended = 1;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrb";
let BaseOpcode = "L4_loadrb_abs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_ploadrbtnew_rr : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"if ($Pv4.new) $Rd32 = memb($Rs32+$Rt32<<#$Ii)",
V4LDST_tc_ld_SLOT01, TypeLD>, Enc_1793896, AddrModeRel {
let Inst{31-21} = 0b00110010000;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseRegOffset;
let accessSize = ByteAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrb";
let InputType = "reg";
let BaseOpcode = "L4_loadrb_rr";
}
def L4_ploadrdf_abs : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pt4, u32_0Imm:$Ii),
"if (!$Pt4) $Rdd32 = memd(#$Ii)",
LD_tc_ld_SLOT01, TypeLD>, Enc_15182416, AddrModeRel {
let Inst{7-5} = 0b100;
let Inst{13-11} = 0b101;
let Inst{31-21} = 0b10011111110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = Absolute;
let accessSize = DoubleWordAccess;
let isExtended = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrd";
let BaseOpcode = "L4_loadrd_abs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_ploadrdf_rr : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"if (!$Pv4) $Rdd32 = memd($Rs32+$Rt32<<#$Ii)",
V4LDST_tc_ld_SLOT01, TypeLD>, Enc_7254313, AddrModeRel {
let Inst{31-21} = 0b00110001110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseRegOffset;
let accessSize = DoubleWordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrd";
let InputType = "reg";
let BaseOpcode = "L4_loadrd_rr";
}
def L4_ploadrdfnew_abs : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pt4, u32_0Imm:$Ii),
"if (!$Pt4.new) $Rdd32 = memd(#$Ii)",
LD_tc_ld_SLOT01, TypeLD>, Enc_15182416, AddrModeRel {
let Inst{7-5} = 0b100;
let Inst{13-11} = 0b111;
let Inst{31-21} = 0b10011111110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = Absolute;
let accessSize = DoubleWordAccess;
let isExtended = 1;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrd";
let BaseOpcode = "L4_loadrd_abs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_ploadrdfnew_rr : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"if (!$Pv4.new) $Rdd32 = memd($Rs32+$Rt32<<#$Ii)",
V4LDST_tc_ld_SLOT01, TypeLD>, Enc_7254313, AddrModeRel {
let Inst{31-21} = 0b00110011110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseRegOffset;
let accessSize = DoubleWordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrd";
let InputType = "reg";
let BaseOpcode = "L4_loadrd_rr";
}
def L4_ploadrdt_abs : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pt4, u32_0Imm:$Ii),
"if ($Pt4) $Rdd32 = memd(#$Ii)",
LD_tc_ld_SLOT01, TypeLD>, Enc_15182416, AddrModeRel {
let Inst{7-5} = 0b100;
let Inst{13-11} = 0b100;
let Inst{31-21} = 0b10011111110;
let isPredicated = 1;
let addrMode = Absolute;
let accessSize = DoubleWordAccess;
let isExtended = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrd";
let BaseOpcode = "L4_loadrd_abs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_ploadrdt_rr : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"if ($Pv4) $Rdd32 = memd($Rs32+$Rt32<<#$Ii)",
V4LDST_tc_ld_SLOT01, TypeLD>, Enc_7254313, AddrModeRel {
let Inst{31-21} = 0b00110000110;
let isPredicated = 1;
let addrMode = BaseRegOffset;
let accessSize = DoubleWordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrd";
let InputType = "reg";
let BaseOpcode = "L4_loadrd_rr";
}
def L4_ploadrdtnew_abs : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pt4, u32_0Imm:$Ii),
"if ($Pt4.new) $Rdd32 = memd(#$Ii)",
LD_tc_ld_SLOT01, TypeLD>, Enc_15182416, AddrModeRel {
let Inst{7-5} = 0b100;
let Inst{13-11} = 0b110;
let Inst{31-21} = 0b10011111110;
let isPredicated = 1;
let addrMode = Absolute;
let accessSize = DoubleWordAccess;
let isExtended = 1;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrd";
let BaseOpcode = "L4_loadrd_abs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_ploadrdtnew_rr : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"if ($Pv4.new) $Rdd32 = memd($Rs32+$Rt32<<#$Ii)",
V4LDST_tc_ld_SLOT01, TypeLD>, Enc_7254313, AddrModeRel {
let Inst{31-21} = 0b00110010110;
let isPredicated = 1;
let addrMode = BaseRegOffset;
let accessSize = DoubleWordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrd";
let InputType = "reg";
let BaseOpcode = "L4_loadrd_rr";
}
def L4_ploadrhf_abs : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, u32_0Imm:$Ii),
"if (!$Pt4) $Rd32 = memh(#$Ii)",
LD_tc_ld_SLOT01, TypeLD>, Enc_13344657, AddrModeRel {
let Inst{7-5} = 0b100;
let Inst{13-11} = 0b101;
let Inst{31-21} = 0b10011111010;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = Absolute;
let accessSize = HalfWordAccess;
let isExtended = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrh";
let BaseOpcode = "L4_loadrh_abs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_ploadrhf_rr : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"if (!$Pv4) $Rd32 = memh($Rs32+$Rt32<<#$Ii)",
V4LDST_tc_ld_SLOT01, TypeLD>, Enc_1793896, AddrModeRel {
let Inst{31-21} = 0b00110001010;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseRegOffset;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrh";
let InputType = "reg";
let BaseOpcode = "L4_loadrh_rr";
}
def L4_ploadrhfnew_abs : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, u32_0Imm:$Ii),
"if (!$Pt4.new) $Rd32 = memh(#$Ii)",
LD_tc_ld_SLOT01, TypeLD>, Enc_13344657, AddrModeRel {
let Inst{7-5} = 0b100;
let Inst{13-11} = 0b111;
let Inst{31-21} = 0b10011111010;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = Absolute;
let accessSize = HalfWordAccess;
let isExtended = 1;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrh";
let BaseOpcode = "L4_loadrh_abs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_ploadrhfnew_rr : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"if (!$Pv4.new) $Rd32 = memh($Rs32+$Rt32<<#$Ii)",
V4LDST_tc_ld_SLOT01, TypeLD>, Enc_1793896, AddrModeRel {
let Inst{31-21} = 0b00110011010;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseRegOffset;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrh";
let InputType = "reg";
let BaseOpcode = "L4_loadrh_rr";
}
def L4_ploadrht_abs : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, u32_0Imm:$Ii),
"if ($Pt4) $Rd32 = memh(#$Ii)",
LD_tc_ld_SLOT01, TypeLD>, Enc_13344657, AddrModeRel {
let Inst{7-5} = 0b100;
let Inst{13-11} = 0b100;
let Inst{31-21} = 0b10011111010;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = Absolute;
let accessSize = HalfWordAccess;
let isExtended = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrh";
let BaseOpcode = "L4_loadrh_abs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_ploadrht_rr : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"if ($Pv4) $Rd32 = memh($Rs32+$Rt32<<#$Ii)",
V4LDST_tc_ld_SLOT01, TypeLD>, Enc_1793896, AddrModeRel {
let Inst{31-21} = 0b00110000010;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseRegOffset;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrh";
let InputType = "reg";
let BaseOpcode = "L4_loadrh_rr";
}
def L4_ploadrhtnew_abs : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, u32_0Imm:$Ii),
"if ($Pt4.new) $Rd32 = memh(#$Ii)",
LD_tc_ld_SLOT01, TypeLD>, Enc_13344657, AddrModeRel {
let Inst{7-5} = 0b100;
let Inst{13-11} = 0b110;
let Inst{31-21} = 0b10011111010;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = Absolute;
let accessSize = HalfWordAccess;
let isExtended = 1;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrh";
let BaseOpcode = "L4_loadrh_abs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_ploadrhtnew_rr : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"if ($Pv4.new) $Rd32 = memh($Rs32+$Rt32<<#$Ii)",
V4LDST_tc_ld_SLOT01, TypeLD>, Enc_1793896, AddrModeRel {
let Inst{31-21} = 0b00110010010;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseRegOffset;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrh";
let InputType = "reg";
let BaseOpcode = "L4_loadrh_rr";
}
def L4_ploadrif_abs : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, u32_0Imm:$Ii),
"if (!$Pt4) $Rd32 = memw(#$Ii)",
LD_tc_ld_SLOT01, TypeLD>, Enc_13344657, AddrModeRel {
let Inst{7-5} = 0b100;
let Inst{13-11} = 0b101;
let Inst{31-21} = 0b10011111100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = Absolute;
let accessSize = WordAccess;
let isExtended = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadri";
let BaseOpcode = "L4_loadri_abs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_ploadrif_rr : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"if (!$Pv4) $Rd32 = memw($Rs32+$Rt32<<#$Ii)",
V4LDST_tc_ld_SLOT01, TypeLD>, Enc_1793896, AddrModeRel {
let Inst{31-21} = 0b00110001100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseRegOffset;
let accessSize = WordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadri";
let InputType = "reg";
let BaseOpcode = "L4_loadri_rr";
}
def L4_ploadrifnew_abs : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, u32_0Imm:$Ii),
"if (!$Pt4.new) $Rd32 = memw(#$Ii)",
LD_tc_ld_SLOT01, TypeLD>, Enc_13344657, AddrModeRel {
let Inst{7-5} = 0b100;
let Inst{13-11} = 0b111;
let Inst{31-21} = 0b10011111100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = Absolute;
let accessSize = WordAccess;
let isExtended = 1;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadri";
let BaseOpcode = "L4_loadri_abs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_ploadrifnew_rr : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"if (!$Pv4.new) $Rd32 = memw($Rs32+$Rt32<<#$Ii)",
V4LDST_tc_ld_SLOT01, TypeLD>, Enc_1793896, AddrModeRel {
let Inst{31-21} = 0b00110011100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseRegOffset;
let accessSize = WordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadri";
let InputType = "reg";
let BaseOpcode = "L4_loadri_rr";
}
def L4_ploadrit_abs : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, u32_0Imm:$Ii),
"if ($Pt4) $Rd32 = memw(#$Ii)",
LD_tc_ld_SLOT01, TypeLD>, Enc_13344657, AddrModeRel {
let Inst{7-5} = 0b100;
let Inst{13-11} = 0b100;
let Inst{31-21} = 0b10011111100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = Absolute;
let accessSize = WordAccess;
let isExtended = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadri";
let BaseOpcode = "L4_loadri_abs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_ploadrit_rr : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"if ($Pv4) $Rd32 = memw($Rs32+$Rt32<<#$Ii)",
V4LDST_tc_ld_SLOT01, TypeLD>, Enc_1793896, AddrModeRel {
let Inst{31-21} = 0b00110000100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseRegOffset;
let accessSize = WordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadri";
let InputType = "reg";
let BaseOpcode = "L4_loadri_rr";
}
def L4_ploadritnew_abs : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, u32_0Imm:$Ii),
"if ($Pt4.new) $Rd32 = memw(#$Ii)",
LD_tc_ld_SLOT01, TypeLD>, Enc_13344657, AddrModeRel {
let Inst{7-5} = 0b100;
let Inst{13-11} = 0b110;
let Inst{31-21} = 0b10011111100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = Absolute;
let accessSize = WordAccess;
let isExtended = 1;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadri";
let BaseOpcode = "L4_loadri_abs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_ploadritnew_rr : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"if ($Pv4.new) $Rd32 = memw($Rs32+$Rt32<<#$Ii)",
V4LDST_tc_ld_SLOT01, TypeLD>, Enc_1793896, AddrModeRel {
let Inst{31-21} = 0b00110010100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseRegOffset;
let accessSize = WordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadri";
let InputType = "reg";
let BaseOpcode = "L4_loadri_rr";
}
def L4_ploadrubf_abs : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, u32_0Imm:$Ii),
"if (!$Pt4) $Rd32 = memub(#$Ii)",
LD_tc_ld_SLOT01, TypeLD>, Enc_13344657, AddrModeRel {
let Inst{7-5} = 0b100;
let Inst{13-11} = 0b101;
let Inst{31-21} = 0b10011111001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = Absolute;
let accessSize = ByteAccess;
let isExtended = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrub";
let BaseOpcode = "L4_loadrub_abs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_ploadrubf_rr : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"if (!$Pv4) $Rd32 = memub($Rs32+$Rt32<<#$Ii)",
V4LDST_tc_ld_SLOT01, TypeLD>, Enc_1793896, AddrModeRel {
let Inst{31-21} = 0b00110001001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseRegOffset;
let accessSize = ByteAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrub";
let InputType = "reg";
let BaseOpcode = "L4_loadrub_rr";
}
def L4_ploadrubfnew_abs : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, u32_0Imm:$Ii),
"if (!$Pt4.new) $Rd32 = memub(#$Ii)",
LD_tc_ld_SLOT01, TypeLD>, Enc_13344657, AddrModeRel {
let Inst{7-5} = 0b100;
let Inst{13-11} = 0b111;
let Inst{31-21} = 0b10011111001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = Absolute;
let accessSize = ByteAccess;
let isExtended = 1;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrub";
let BaseOpcode = "L4_loadrub_abs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_ploadrubfnew_rr : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"if (!$Pv4.new) $Rd32 = memub($Rs32+$Rt32<<#$Ii)",
V4LDST_tc_ld_SLOT01, TypeLD>, Enc_1793896, AddrModeRel {
let Inst{31-21} = 0b00110011001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseRegOffset;
let accessSize = ByteAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrub";
let InputType = "reg";
let BaseOpcode = "L4_loadrub_rr";
}
def L4_ploadrubt_abs : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, u32_0Imm:$Ii),
"if ($Pt4) $Rd32 = memub(#$Ii)",
LD_tc_ld_SLOT01, TypeLD>, Enc_13344657, AddrModeRel {
let Inst{7-5} = 0b100;
let Inst{13-11} = 0b100;
let Inst{31-21} = 0b10011111001;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = Absolute;
let accessSize = ByteAccess;
let isExtended = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrub";
let BaseOpcode = "L4_loadrub_abs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_ploadrubt_rr : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"if ($Pv4) $Rd32 = memub($Rs32+$Rt32<<#$Ii)",
V4LDST_tc_ld_SLOT01, TypeLD>, Enc_1793896, AddrModeRel {
let Inst{31-21} = 0b00110000001;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseRegOffset;
let accessSize = ByteAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrub";
let InputType = "reg";
let BaseOpcode = "L4_loadrub_rr";
}
def L4_ploadrubtnew_abs : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, u32_0Imm:$Ii),
"if ($Pt4.new) $Rd32 = memub(#$Ii)",
LD_tc_ld_SLOT01, TypeLD>, Enc_13344657, AddrModeRel {
let Inst{7-5} = 0b100;
let Inst{13-11} = 0b110;
let Inst{31-21} = 0b10011111001;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = Absolute;
let accessSize = ByteAccess;
let isExtended = 1;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrub";
let BaseOpcode = "L4_loadrub_abs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_ploadrubtnew_rr : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"if ($Pv4.new) $Rd32 = memub($Rs32+$Rt32<<#$Ii)",
V4LDST_tc_ld_SLOT01, TypeLD>, Enc_1793896, AddrModeRel {
let Inst{31-21} = 0b00110010001;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseRegOffset;
let accessSize = ByteAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrub";
let InputType = "reg";
let BaseOpcode = "L4_loadrub_rr";
}
def L4_ploadruhf_abs : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, u32_0Imm:$Ii),
"if (!$Pt4) $Rd32 = memuh(#$Ii)",
LD_tc_ld_SLOT01, TypeLD>, Enc_13344657, AddrModeRel {
let Inst{7-5} = 0b100;
let Inst{13-11} = 0b101;
let Inst{31-21} = 0b10011111011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = Absolute;
let accessSize = HalfWordAccess;
let isExtended = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadruh";
let BaseOpcode = "L4_loadruh_abs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_ploadruhf_rr : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"if (!$Pv4) $Rd32 = memuh($Rs32+$Rt32<<#$Ii)",
V4LDST_tc_ld_SLOT01, TypeLD>, Enc_1793896, AddrModeRel {
let Inst{31-21} = 0b00110001011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseRegOffset;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadruh";
let InputType = "reg";
let BaseOpcode = "L4_loadruh_rr";
}
def L4_ploadruhfnew_abs : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, u32_0Imm:$Ii),
"if (!$Pt4.new) $Rd32 = memuh(#$Ii)",
LD_tc_ld_SLOT01, TypeLD>, Enc_13344657, AddrModeRel {
let Inst{7-5} = 0b100;
let Inst{13-11} = 0b111;
let Inst{31-21} = 0b10011111011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = Absolute;
let accessSize = HalfWordAccess;
let isExtended = 1;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadruh";
let BaseOpcode = "L4_loadruh_abs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_ploadruhfnew_rr : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"if (!$Pv4.new) $Rd32 = memuh($Rs32+$Rt32<<#$Ii)",
V4LDST_tc_ld_SLOT01, TypeLD>, Enc_1793896, AddrModeRel {
let Inst{31-21} = 0b00110011011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseRegOffset;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadruh";
let InputType = "reg";
let BaseOpcode = "L4_loadruh_rr";
}
def L4_ploadruht_abs : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, u32_0Imm:$Ii),
"if ($Pt4) $Rd32 = memuh(#$Ii)",
LD_tc_ld_SLOT01, TypeLD>, Enc_13344657, AddrModeRel {
let Inst{7-5} = 0b100;
let Inst{13-11} = 0b100;
let Inst{31-21} = 0b10011111011;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = Absolute;
let accessSize = HalfWordAccess;
let isExtended = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadruh";
let BaseOpcode = "L4_loadruh_abs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_ploadruht_rr : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"if ($Pv4) $Rd32 = memuh($Rs32+$Rt32<<#$Ii)",
V4LDST_tc_ld_SLOT01, TypeLD>, Enc_1793896, AddrModeRel {
let Inst{31-21} = 0b00110000011;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseRegOffset;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadruh";
let InputType = "reg";
let BaseOpcode = "L4_loadruh_rr";
}
def L4_ploadruhtnew_abs : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, u32_0Imm:$Ii),
"if ($Pt4.new) $Rd32 = memuh(#$Ii)",
LD_tc_ld_SLOT01, TypeLD>, Enc_13344657, AddrModeRel {
let Inst{7-5} = 0b100;
let Inst{13-11} = 0b110;
let Inst{31-21} = 0b10011111011;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = Absolute;
let accessSize = HalfWordAccess;
let isExtended = 1;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadruh";
let BaseOpcode = "L4_loadruh_abs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_ploadruhtnew_rr : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"if ($Pv4.new) $Rd32 = memuh($Rs32+$Rt32<<#$Ii)",
V4LDST_tc_ld_SLOT01, TypeLD>, Enc_1793896, AddrModeRel {
let Inst{31-21} = 0b00110010011;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseRegOffset;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadruh";
let InputType = "reg";
let BaseOpcode = "L4_loadruh_rr";
}
def L4_return : HInst<
(outs),
(ins),
"dealloc_return",
LD_tc_3or4stall_SLOT0, TypeLD>, Enc_0, PredNewRel {
let Inst{4-0} = 0b11110;
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b10010110000;
let Inst{20-16} = 0b11110;
let isTerminator = 1;
let isIndirectBranch = 1;
let accessSize = DoubleWordAccess;
let cofMax1 = 1;
let isReturn = 1;
let mayLoad = 1;
let Uses = [R30];
let Defs = [PC, R29, R30, R31];
let BaseOpcode = "L4_return";
let isBarrier = 1;
let isPredicable = 1;
let isTaken = 1;
}
def L4_return_f : HInst<
(outs),
(ins PredRegs:$Pv4),
"if (!$Pv4) dealloc_return",
LD_tc_3or4stall_SLOT0, TypeLD>, Enc_12711252, PredNewRel {
let Inst{4-0} = 0b11110;
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1100;
let Inst{31-21} = 0b10010110000;
let Inst{20-16} = 0b11110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isIndirectBranch = 1;
let accessSize = DoubleWordAccess;
let cofMax1 = 1;
let isReturn = 1;
let mayLoad = 1;
let Uses = [R30];
let Defs = [PC, R29, R30, R31];
let BaseOpcode = "L4_return";
let isTaken = Inst{12};
}
def L4_return_fnew_pnt : HInst<
(outs),
(ins PredRegs:$Pv4),
"if (!$Pv4.new) dealloc_return:nt",
LD_tc_3or4stall_SLOT0, TypeLD>, Enc_12711252, PredNewRel {
let Inst{4-0} = 0b11110;
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1010;
let Inst{31-21} = 0b10010110000;
let Inst{20-16} = 0b11110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isIndirectBranch = 1;
let accessSize = DoubleWordAccess;
let cofMax1 = 1;
let isReturn = 1;
let isPredicatedNew = 1;
let mayLoad = 1;
let Uses = [R30];
let Defs = [PC, R29, R30, R31];
let BaseOpcode = "L4_return";
let isTaken = Inst{12};
}
def L4_return_fnew_pt : HInst<
(outs),
(ins PredRegs:$Pv4),
"if (!$Pv4.new) dealloc_return:t",
LD_tc_3or4stall_SLOT0, TypeLD>, Enc_12711252, PredNewRel {
let Inst{4-0} = 0b11110;
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1110;
let Inst{31-21} = 0b10010110000;
let Inst{20-16} = 0b11110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isIndirectBranch = 1;
let accessSize = DoubleWordAccess;
let cofMax1 = 1;
let isReturn = 1;
let isPredicatedNew = 1;
let mayLoad = 1;
let Uses = [R30];
let Defs = [PC, R29, R30, R31];
let BaseOpcode = "L4_return";
let isTaken = Inst{12};
}
def L4_return_t : HInst<
(outs),
(ins PredRegs:$Pv4),
"if ($Pv4) dealloc_return",
LD_tc_3or4stall_SLOT0, TypeLD>, Enc_12711252, PredNewRel {
let Inst{4-0} = 0b11110;
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b0100;
let Inst{31-21} = 0b10010110000;
let Inst{20-16} = 0b11110;
let isPredicated = 1;
let isTerminator = 1;
let isIndirectBranch = 1;
let accessSize = DoubleWordAccess;
let cofMax1 = 1;
let isReturn = 1;
let mayLoad = 1;
let Uses = [R30];
let Defs = [PC, R29, R30, R31];
let BaseOpcode = "L4_return";
let isTaken = Inst{12};
}
def L4_return_tnew_pnt : HInst<
(outs),
(ins PredRegs:$Pv4),
"if ($Pv4.new) dealloc_return:nt",
LD_tc_3or4stall_SLOT0, TypeLD>, Enc_12711252, PredNewRel {
let Inst{4-0} = 0b11110;
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b0010;
let Inst{31-21} = 0b10010110000;
let Inst{20-16} = 0b11110;
let isPredicated = 1;
let isTerminator = 1;
let isIndirectBranch = 1;
let accessSize = DoubleWordAccess;
let cofMax1 = 1;
let isReturn = 1;
let isPredicatedNew = 1;
let mayLoad = 1;
let Uses = [R30];
let Defs = [PC, R29, R30, R31];
let BaseOpcode = "L4_return";
let isTaken = Inst{12};
}
def L4_return_tnew_pt : HInst<
(outs),
(ins PredRegs:$Pv4),
"if ($Pv4.new) dealloc_return:t",
LD_tc_3or4stall_SLOT0, TypeLD>, Enc_12711252, PredNewRel {
let Inst{4-0} = 0b11110;
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b0110;
let Inst{31-21} = 0b10010110000;
let Inst{20-16} = 0b11110;
let isPredicated = 1;
let isTerminator = 1;
let isIndirectBranch = 1;
let accessSize = DoubleWordAccess;
let cofMax1 = 1;
let isReturn = 1;
let isPredicatedNew = 1;
let mayLoad = 1;
let Uses = [R30];
let Defs = [PC, R29, R30, R31];
let BaseOpcode = "L4_return";
let isTaken = Inst{12};
}
def L4_sub_memopb_io : HInst<
(outs),
(ins IntRegs:$Rs32, u32_0Imm:$Ii, IntRegs:$Rt32),
"memb($Rs32+#$Ii) -= $Rt32",
V4LDST_tc_st_SLOT0, TypeV4LDST>, Enc_11849200 {
let Inst{6-5} = 0b01;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00111110000;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let mayStore = 1;
let mayLoad = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_sub_memopb_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"memb($Rs32) -= $Rt32",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_sub_memoph_io : HInst<
(outs),
(ins IntRegs:$Rs32, u31_1Imm:$Ii, IntRegs:$Rt32),
"memh($Rs32+#$Ii) -= $Rt32",
V4LDST_tc_st_SLOT0, TypeV4LDST>, Enc_8849208 {
let Inst{6-5} = 0b01;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00111110001;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayStore = 1;
let mayLoad = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
}
def L4_sub_memoph_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"memh($Rs32) -= $Rt32",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_sub_memopw_io : HInst<
(outs),
(ins IntRegs:$Rs32, u30_2Imm:$Ii, IntRegs:$Rt32),
"memw($Rs32+#$Ii) -= $Rt32",
V4LDST_tc_st_SLOT0, TypeV4LDST>, Enc_9849208 {
let Inst{6-5} = 0b01;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00111110010;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let mayStore = 1;
let mayLoad = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 2;
}
def L4_sub_memopw_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"memw($Rs32) -= $Rt32",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def M2_acci : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += add($Rs32,$Rt32)",
M_tc_2_acc_SLOT23, TypeM>, Enc_9223889, ImmRegRel {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101111000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let CextOpcode = "M2_acci";
let InputType = "reg";
let Constraints = "$Rx32 = $Rx32in";
}
def M2_accii : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, s32_0Imm:$Ii),
"$Rx32 += add($Rs32,#$Ii)",
M_tc_2_acc_SLOT23, TypeM>, Enc_11522288, ImmRegRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100010000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let CextOpcode = "M2_acci";
let InputType = "imm";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 1;
let opExtentBits = 8;
let opExtentAlign = 0;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_cmaci_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += cmpyi($Rs32,$Rt32)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100111000;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_cmacr_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += cmpyr($Rs32,$Rt32)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100111000;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_cmacs_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += cmpy($Rs32,$Rt32):sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100111000;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_cmacs_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += cmpy($Rs32,$Rt32):<<1:sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100111100;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_cmacsc_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += cmpy($Rs32,$Rt32*):sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100111010;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_cmacsc_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += cmpy($Rs32,$Rt32*):<<1:sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100111110;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_cmpyi_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = cmpyi($Rs32,$Rt32)",
M_tc_3x_SLOT23, TypeM>, Enc_1997594 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100101000;
let prefersSlot3 = 1;
}
def M2_cmpyr_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = cmpyr($Rs32,$Rt32)",
M_tc_3x_SLOT23, TypeM>, Enc_1997594 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100101000;
let prefersSlot3 = 1;
}
def M2_cmpyrs_s0 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = cmpy($Rs32,$Rt32):rnd:sat",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101101001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_cmpyrs_s1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = cmpy($Rs32,$Rt32):<<1:rnd:sat",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101101101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_cmpyrsc_s0 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = cmpy($Rs32,$Rt32*):rnd:sat",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101101011;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_cmpyrsc_s1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = cmpy($Rs32,$Rt32*):<<1:rnd:sat",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101101111;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_cmpys_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = cmpy($Rs32,$Rt32):sat",
M_tc_3x_SLOT23, TypeM>, Enc_1997594 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100101000;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_cmpys_s1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = cmpy($Rs32,$Rt32):<<1:sat",
M_tc_3x_SLOT23, TypeM>, Enc_1997594 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100101100;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_cmpysc_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = cmpy($Rs32,$Rt32*):sat",
M_tc_3x_SLOT23, TypeM>, Enc_1997594 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100101010;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_cmpysc_s1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = cmpy($Rs32,$Rt32*):<<1:sat",
M_tc_3x_SLOT23, TypeM>, Enc_1997594 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100101110;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_cnacs_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 -= cmpy($Rs32,$Rt32):sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100111000;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_cnacs_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 -= cmpy($Rs32,$Rt32):<<1:sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100111100;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_cnacsc_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 -= cmpy($Rs32,$Rt32*):sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100111010;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_cnacsc_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 -= cmpy($Rs32,$Rt32*):<<1:sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100111110;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_dpmpyss_acc_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += mpy($Rs32,$Rt32)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100111000;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_dpmpyss_nac_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 -= mpy($Rs32,$Rt32)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100111001;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_dpmpyss_rnd_s0 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32,$Rt32):rnd",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101101001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_dpmpyss_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpy($Rs32,$Rt32)",
M_tc_3x_SLOT23, TypeM>, Enc_1997594 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100101000;
let prefersSlot3 = 1;
}
def M2_dpmpyuu_acc_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += mpyu($Rs32,$Rt32)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100111010;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_dpmpyuu_nac_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 -= mpyu($Rs32,$Rt32)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100111011;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_dpmpyuu_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpyu($Rs32,$Rt32)",
M_tc_3x_SLOT23, TypeM>, Enc_1997594 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100101010;
let prefersSlot3 = 1;
}
def M2_hmmpyh_rs1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32,$Rt32.h):<<1:rnd:sat",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101101101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_hmmpyh_s1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32,$Rt32.h):<<1:sat",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101101101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_hmmpyl_rs1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32,$Rt32.l):<<1:rnd:sat",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101101111;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_hmmpyl_s1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32,$Rt32.l):<<1:sat",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101101101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_maci : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpyi($Rs32,$Rt32)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_9223889, ImmRegRel {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101111000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let CextOpcode = "M2_maci";
let InputType = "reg";
let Constraints = "$Rx32 = $Rx32in";
}
def M2_macsin : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u32_0Imm:$Ii),
"$Rx32 -= mpyi($Rs32,#$Ii)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_11522288 {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100001100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let InputType = "imm";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 0;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_macsip : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u32_0Imm:$Ii),
"$Rx32 += mpyi($Rs32,#$Ii)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_11522288, ImmRegRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100001000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let CextOpcode = "M2_maci";
let InputType = "imm";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 0;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mmachs_rs0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vmpywoh($Rss32,$Rtt32):rnd:sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_12702821 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010001;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mmachs_rs1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vmpywoh($Rss32,$Rtt32):<<1:rnd:sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_12702821 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010101;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mmachs_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vmpywoh($Rss32,$Rtt32):sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_12702821 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010000;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mmachs_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vmpywoh($Rss32,$Rtt32):<<1:sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_12702821 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010100;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mmacls_rs0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vmpyweh($Rss32,$Rtt32):rnd:sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_12702821 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010001;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mmacls_rs1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vmpyweh($Rss32,$Rtt32):<<1:rnd:sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_12702821 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010101;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mmacls_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vmpyweh($Rss32,$Rtt32):sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_12702821 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010000;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mmacls_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vmpyweh($Rss32,$Rtt32):<<1:sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_12702821 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010100;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mmacuhs_rs0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vmpywouh($Rss32,$Rtt32):rnd:sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_12702821 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010011;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mmacuhs_rs1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vmpywouh($Rss32,$Rtt32):<<1:rnd:sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_12702821 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010111;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mmacuhs_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vmpywouh($Rss32,$Rtt32):sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_12702821 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010010;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mmacuhs_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vmpywouh($Rss32,$Rtt32):<<1:sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_12702821 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010110;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mmaculs_rs0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vmpyweuh($Rss32,$Rtt32):rnd:sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_12702821 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010011;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mmaculs_rs1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vmpyweuh($Rss32,$Rtt32):<<1:rnd:sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_12702821 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010111;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mmaculs_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vmpyweuh($Rss32,$Rtt32):sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_12702821 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010010;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mmaculs_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vmpyweuh($Rss32,$Rtt32):<<1:sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_12702821 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010110;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mmpyh_rs0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vmpywoh($Rss32,$Rtt32):rnd:sat",
M_tc_3x_SLOT23, TypeM>, Enc_8333157 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000001;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mmpyh_rs1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vmpywoh($Rss32,$Rtt32):<<1:rnd:sat",
M_tc_3x_SLOT23, TypeM>, Enc_8333157 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000101;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mmpyh_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vmpywoh($Rss32,$Rtt32):sat",
M_tc_3x_SLOT23, TypeM>, Enc_8333157 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000000;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mmpyh_s1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vmpywoh($Rss32,$Rtt32):<<1:sat",
M_tc_3x_SLOT23, TypeM>, Enc_8333157 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000100;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mmpyl_rs0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vmpyweh($Rss32,$Rtt32):rnd:sat",
M_tc_3x_SLOT23, TypeM>, Enc_8333157 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000001;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mmpyl_rs1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vmpyweh($Rss32,$Rtt32):<<1:rnd:sat",
M_tc_3x_SLOT23, TypeM>, Enc_8333157 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000101;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mmpyl_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vmpyweh($Rss32,$Rtt32):sat",
M_tc_3x_SLOT23, TypeM>, Enc_8333157 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000000;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mmpyl_s1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vmpyweh($Rss32,$Rtt32):<<1:sat",
M_tc_3x_SLOT23, TypeM>, Enc_8333157 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000100;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mmpyuh_rs0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vmpywouh($Rss32,$Rtt32):rnd:sat",
M_tc_3x_SLOT23, TypeM>, Enc_8333157 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000011;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mmpyuh_rs1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vmpywouh($Rss32,$Rtt32):<<1:rnd:sat",
M_tc_3x_SLOT23, TypeM>, Enc_8333157 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000111;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mmpyuh_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vmpywouh($Rss32,$Rtt32):sat",
M_tc_3x_SLOT23, TypeM>, Enc_8333157 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000010;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mmpyuh_s1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vmpywouh($Rss32,$Rtt32):<<1:sat",
M_tc_3x_SLOT23, TypeM>, Enc_8333157 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000110;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mmpyul_rs0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vmpyweuh($Rss32,$Rtt32):rnd:sat",
M_tc_3x_SLOT23, TypeM>, Enc_8333157 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000011;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mmpyul_rs1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vmpyweuh($Rss32,$Rtt32):<<1:rnd:sat",
M_tc_3x_SLOT23, TypeM>, Enc_8333157 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000111;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mmpyul_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vmpyweuh($Rss32,$Rtt32):sat",
M_tc_3x_SLOT23, TypeM>, Enc_8333157 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000010;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mmpyul_s1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vmpyweuh($Rss32,$Rtt32):<<1:sat",
M_tc_3x_SLOT23, TypeM>, Enc_8333157 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000110;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mpy_acc_hh_s0 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpy($Rs32.h,$Rt32.h)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_acc_hh_s1 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpy($Rs32.h,$Rt32.h):<<1",
M_tc_3x_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_acc_hl_s0 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpy($Rs32.h,$Rt32.l)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_acc_hl_s1 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpy($Rs32.h,$Rt32.l):<<1",
M_tc_3x_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_acc_lh_s0 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpy($Rs32.l,$Rt32.h)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_acc_lh_s1 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpy($Rs32.l,$Rt32.h):<<1",
M_tc_3x_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_acc_ll_s0 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpy($Rs32.l,$Rt32.l)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_acc_ll_s1 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpy($Rs32.l,$Rt32.l):<<1",
M_tc_3x_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_acc_sat_hh_s0 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpy($Rs32.h,$Rt32.h):sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_acc_sat_hh_s1 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpy($Rs32.h,$Rt32.h):<<1:sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_acc_sat_hl_s0 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpy($Rs32.h,$Rt32.l):sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_acc_sat_hl_s1 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpy($Rs32.h,$Rt32.l):<<1:sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_acc_sat_lh_s0 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpy($Rs32.l,$Rt32.h):sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_acc_sat_lh_s1 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpy($Rs32.l,$Rt32.h):<<1:sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_acc_sat_ll_s0 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpy($Rs32.l,$Rt32.l):sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_acc_sat_ll_s1 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpy($Rs32.l,$Rt32.l):<<1:sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_hh_s0 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.h,$Rt32.h)",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpy_hh_s1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.h,$Rt32.h):<<1",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpy_hl_s0 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.h,$Rt32.l)",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpy_hl_s1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.h,$Rt32.l):<<1",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpy_lh_s0 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.l,$Rt32.h)",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpy_lh_s1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.l,$Rt32.h):<<1",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpy_ll_s0 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.l,$Rt32.l)",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpy_ll_s1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.l,$Rt32.l):<<1",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpy_nac_hh_s0 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= mpy($Rs32.h,$Rt32.h)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_nac_hh_s1 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= mpy($Rs32.h,$Rt32.h):<<1",
M_tc_3x_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_nac_hl_s0 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= mpy($Rs32.h,$Rt32.l)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_nac_hl_s1 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= mpy($Rs32.h,$Rt32.l):<<1",
M_tc_3x_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_nac_lh_s0 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= mpy($Rs32.l,$Rt32.h)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_nac_lh_s1 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= mpy($Rs32.l,$Rt32.h):<<1",
M_tc_3x_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_nac_ll_s0 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= mpy($Rs32.l,$Rt32.l)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_nac_ll_s1 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= mpy($Rs32.l,$Rt32.l):<<1",
M_tc_3x_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_nac_sat_hh_s0 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= mpy($Rs32.h,$Rt32.h):sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_nac_sat_hh_s1 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= mpy($Rs32.h,$Rt32.h):<<1:sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_nac_sat_hl_s0 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= mpy($Rs32.h,$Rt32.l):sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_nac_sat_hl_s1 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= mpy($Rs32.h,$Rt32.l):<<1:sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_nac_sat_lh_s0 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= mpy($Rs32.l,$Rt32.h):sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_nac_sat_lh_s1 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= mpy($Rs32.l,$Rt32.h):<<1:sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_nac_sat_ll_s0 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= mpy($Rs32.l,$Rt32.l):sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_nac_sat_ll_s1 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= mpy($Rs32.l,$Rt32.l):<<1:sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_rnd_hh_s0 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.h,$Rt32.h):rnd",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpy_rnd_hh_s1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.h,$Rt32.h):<<1:rnd",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpy_rnd_hl_s0 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.h,$Rt32.l):rnd",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpy_rnd_hl_s1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.h,$Rt32.l):<<1:rnd",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpy_rnd_lh_s0 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.l,$Rt32.h):rnd",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpy_rnd_lh_s1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.l,$Rt32.h):<<1:rnd",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpy_rnd_ll_s0 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.l,$Rt32.l):rnd",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpy_rnd_ll_s1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.l,$Rt32.l):<<1:rnd",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpy_sat_hh_s0 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.h,$Rt32.h):sat",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mpy_sat_hh_s1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.h,$Rt32.h):<<1:sat",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mpy_sat_hl_s0 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.h,$Rt32.l):sat",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mpy_sat_hl_s1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.h,$Rt32.l):<<1:sat",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mpy_sat_lh_s0 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.l,$Rt32.h):sat",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mpy_sat_lh_s1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.l,$Rt32.h):<<1:sat",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mpy_sat_ll_s0 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.l,$Rt32.l):sat",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mpy_sat_ll_s1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.l,$Rt32.l):<<1:sat",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mpy_sat_rnd_hh_s0 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.h,$Rt32.h):rnd:sat",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mpy_sat_rnd_hh_s1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.h,$Rt32.h):<<1:rnd:sat",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mpy_sat_rnd_hl_s0 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.h,$Rt32.l):rnd:sat",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mpy_sat_rnd_hl_s1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.h,$Rt32.l):<<1:rnd:sat",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mpy_sat_rnd_lh_s0 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.l,$Rt32.h):rnd:sat",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mpy_sat_rnd_lh_s1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.l,$Rt32.h):<<1:rnd:sat",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mpy_sat_rnd_ll_s0 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.l,$Rt32.l):rnd:sat",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mpy_sat_rnd_ll_s1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.l,$Rt32.l):<<1:rnd:sat",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mpy_up : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32,$Rt32)",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101101000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpy_up_s1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32,$Rt32):<<1",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101101101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpy_up_s1_sat : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32,$Rt32):<<1:sat",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101101111;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mpyd_acc_hh_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += mpy($Rs32.h,$Rt32.h)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110000;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyd_acc_hh_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += mpy($Rs32.h,$Rt32.h):<<1",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110100;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyd_acc_hl_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += mpy($Rs32.h,$Rt32.l)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110000;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyd_acc_hl_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += mpy($Rs32.h,$Rt32.l):<<1",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110100;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyd_acc_lh_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += mpy($Rs32.l,$Rt32.h)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110000;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyd_acc_lh_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += mpy($Rs32.l,$Rt32.h):<<1",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110100;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyd_acc_ll_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += mpy($Rs32.l,$Rt32.l)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110000;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyd_acc_ll_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += mpy($Rs32.l,$Rt32.l):<<1",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110100;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyd_hh_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpy($Rs32.h,$Rt32.h)",
M_tc_3x_SLOT23, TypeM>, Enc_1997594 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100100000;
let prefersSlot3 = 1;
}
def M2_mpyd_hh_s1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpy($Rs32.h,$Rt32.h):<<1",
M_tc_3x_SLOT23, TypeM>, Enc_1997594 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100100100;
let prefersSlot3 = 1;
}
def M2_mpyd_hl_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpy($Rs32.h,$Rt32.l)",
M_tc_3x_SLOT23, TypeM>, Enc_1997594 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100100000;
let prefersSlot3 = 1;
}
def M2_mpyd_hl_s1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpy($Rs32.h,$Rt32.l):<<1",
M_tc_3x_SLOT23, TypeM>, Enc_1997594 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100100100;
let prefersSlot3 = 1;
}
def M2_mpyd_lh_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpy($Rs32.l,$Rt32.h)",
M_tc_3x_SLOT23, TypeM>, Enc_1997594 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100100000;
let prefersSlot3 = 1;
}
def M2_mpyd_lh_s1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpy($Rs32.l,$Rt32.h):<<1",
M_tc_3x_SLOT23, TypeM>, Enc_1997594 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100100100;
let prefersSlot3 = 1;
}
def M2_mpyd_ll_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpy($Rs32.l,$Rt32.l)",
M_tc_3x_SLOT23, TypeM>, Enc_1997594 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100100000;
let prefersSlot3 = 1;
}
def M2_mpyd_ll_s1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpy($Rs32.l,$Rt32.l):<<1",
M_tc_3x_SLOT23, TypeM>, Enc_1997594 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100100100;
let prefersSlot3 = 1;
}
def M2_mpyd_nac_hh_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 -= mpy($Rs32.h,$Rt32.h)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110001;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyd_nac_hh_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 -= mpy($Rs32.h,$Rt32.h):<<1",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110101;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyd_nac_hl_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 -= mpy($Rs32.h,$Rt32.l)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110001;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyd_nac_hl_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 -= mpy($Rs32.h,$Rt32.l):<<1",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110101;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyd_nac_lh_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 -= mpy($Rs32.l,$Rt32.h)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110001;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyd_nac_lh_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 -= mpy($Rs32.l,$Rt32.h):<<1",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110101;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyd_nac_ll_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 -= mpy($Rs32.l,$Rt32.l)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110001;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyd_nac_ll_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 -= mpy($Rs32.l,$Rt32.l):<<1",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110101;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyd_rnd_hh_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpy($Rs32.h,$Rt32.h):rnd",
M_tc_3x_SLOT23, TypeM>, Enc_1997594 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100100001;
let prefersSlot3 = 1;
}
def M2_mpyd_rnd_hh_s1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpy($Rs32.h,$Rt32.h):<<1:rnd",
M_tc_3x_SLOT23, TypeM>, Enc_1997594 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100100101;
let prefersSlot3 = 1;
}
def M2_mpyd_rnd_hl_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpy($Rs32.h,$Rt32.l):rnd",
M_tc_3x_SLOT23, TypeM>, Enc_1997594 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100100001;
let prefersSlot3 = 1;
}
def M2_mpyd_rnd_hl_s1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpy($Rs32.h,$Rt32.l):<<1:rnd",
M_tc_3x_SLOT23, TypeM>, Enc_1997594 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100100101;
let prefersSlot3 = 1;
}
def M2_mpyd_rnd_lh_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpy($Rs32.l,$Rt32.h):rnd",
M_tc_3x_SLOT23, TypeM>, Enc_1997594 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100100001;
let prefersSlot3 = 1;
}
def M2_mpyd_rnd_lh_s1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpy($Rs32.l,$Rt32.h):<<1:rnd",
M_tc_3x_SLOT23, TypeM>, Enc_1997594 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100100101;
let prefersSlot3 = 1;
}
def M2_mpyd_rnd_ll_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpy($Rs32.l,$Rt32.l):rnd",
M_tc_3x_SLOT23, TypeM>, Enc_1997594 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100100001;
let prefersSlot3 = 1;
}
def M2_mpyd_rnd_ll_s1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpy($Rs32.l,$Rt32.l):<<1:rnd",
M_tc_3x_SLOT23, TypeM>, Enc_1997594 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100100101;
let prefersSlot3 = 1;
}
def M2_mpyi : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpyi($Rs32,$Rt32)",
M_tc_3x_SLOT23, TypeM>, Enc_14071773, ImmRegRel {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101101000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let CextOpcode = "M2_mpyi";
let InputType = "reg";
}
def M2_mpysin : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, u8_0Imm:$Ii),
"$Rd32 = -mpyi($Rs32,#$Ii)",
M_tc_3x_SLOT23, TypeM>, Enc_16355964 {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100000100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpysip : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, u32_0Imm:$Ii),
"$Rd32 = +mpyi($Rs32,#$Ii)",
M_tc_3x_SLOT23, TypeM>, Enc_16355964 {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100000000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 0;
}
def M2_mpysmi : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, m32_0Imm:$Ii),
"$Rd32 = mpyi($Rs32,#$Ii)",
M_tc_3x_SLOT23, TypeM>, ImmRegRel {
let hasNewValue = 1;
let opNewValue = 0;
let CextOpcode = "M2_mpyi";
let InputType = "imm";
let isPseudo = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 9;
let opExtentAlign = 0;
}
def M2_mpysu_up : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpysu($Rs32,$Rt32)",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101101011;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpyu_acc_hh_s0 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpyu($Rs32.h,$Rt32.h)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpyu_acc_hh_s1 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpyu($Rs32.h,$Rt32.h):<<1",
M_tc_3x_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpyu_acc_hl_s0 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpyu($Rs32.h,$Rt32.l)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpyu_acc_hl_s1 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpyu($Rs32.h,$Rt32.l):<<1",
M_tc_3x_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpyu_acc_lh_s0 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpyu($Rs32.l,$Rt32.h)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpyu_acc_lh_s1 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpyu($Rs32.l,$Rt32.h):<<1",
M_tc_3x_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpyu_acc_ll_s0 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpyu($Rs32.l,$Rt32.l)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpyu_acc_ll_s1 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpyu($Rs32.l,$Rt32.l):<<1",
M_tc_3x_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpyu_hh_s0 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpyu($Rs32.h,$Rt32.h)",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpyu_hh_s1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpyu($Rs32.h,$Rt32.h):<<1",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpyu_hl_s0 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpyu($Rs32.h,$Rt32.l)",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpyu_hl_s1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpyu($Rs32.h,$Rt32.l):<<1",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpyu_lh_s0 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpyu($Rs32.l,$Rt32.h)",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpyu_lh_s1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpyu($Rs32.l,$Rt32.h):<<1",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpyu_ll_s0 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpyu($Rs32.l,$Rt32.l)",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpyu_ll_s1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpyu($Rs32.l,$Rt32.l):<<1",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpyu_nac_hh_s0 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= mpyu($Rs32.h,$Rt32.h)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110011;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpyu_nac_hh_s1 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= mpyu($Rs32.h,$Rt32.h):<<1",
M_tc_3x_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110111;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpyu_nac_hl_s0 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= mpyu($Rs32.h,$Rt32.l)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110011;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpyu_nac_hl_s1 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= mpyu($Rs32.h,$Rt32.l):<<1",
M_tc_3x_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110111;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpyu_nac_lh_s0 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= mpyu($Rs32.l,$Rt32.h)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110011;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpyu_nac_lh_s1 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= mpyu($Rs32.l,$Rt32.h):<<1",
M_tc_3x_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110111;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpyu_nac_ll_s0 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= mpyu($Rs32.l,$Rt32.l)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110011;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpyu_nac_ll_s1 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= mpyu($Rs32.l,$Rt32.l):<<1",
M_tc_3x_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110111;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpyu_up : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpyu($Rs32,$Rt32)",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101101010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpyud_acc_hh_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += mpyu($Rs32.h,$Rt32.h)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110010;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyud_acc_hh_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += mpyu($Rs32.h,$Rt32.h):<<1",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110110;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyud_acc_hl_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += mpyu($Rs32.h,$Rt32.l)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110010;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyud_acc_hl_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += mpyu($Rs32.h,$Rt32.l):<<1",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110110;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyud_acc_lh_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += mpyu($Rs32.l,$Rt32.h)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110010;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyud_acc_lh_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += mpyu($Rs32.l,$Rt32.h):<<1",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110110;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyud_acc_ll_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += mpyu($Rs32.l,$Rt32.l)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110010;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyud_acc_ll_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += mpyu($Rs32.l,$Rt32.l):<<1",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110110;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyud_hh_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpyu($Rs32.h,$Rt32.h)",
M_tc_3x_SLOT23, TypeM>, Enc_1997594 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100100010;
let prefersSlot3 = 1;
}
def M2_mpyud_hh_s1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpyu($Rs32.h,$Rt32.h):<<1",
M_tc_3x_SLOT23, TypeM>, Enc_1997594 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100100110;
let prefersSlot3 = 1;
}
def M2_mpyud_hl_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpyu($Rs32.h,$Rt32.l)",
M_tc_3x_SLOT23, TypeM>, Enc_1997594 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100100010;
let prefersSlot3 = 1;
}
def M2_mpyud_hl_s1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpyu($Rs32.h,$Rt32.l):<<1",
M_tc_3x_SLOT23, TypeM>, Enc_1997594 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100100110;
let prefersSlot3 = 1;
}
def M2_mpyud_lh_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpyu($Rs32.l,$Rt32.h)",
M_tc_3x_SLOT23, TypeM>, Enc_1997594 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100100010;
let prefersSlot3 = 1;
}
def M2_mpyud_lh_s1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpyu($Rs32.l,$Rt32.h):<<1",
M_tc_3x_SLOT23, TypeM>, Enc_1997594 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100100110;
let prefersSlot3 = 1;
}
def M2_mpyud_ll_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpyu($Rs32.l,$Rt32.l)",
M_tc_3x_SLOT23, TypeM>, Enc_1997594 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100100010;
let prefersSlot3 = 1;
}
def M2_mpyud_ll_s1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpyu($Rs32.l,$Rt32.l):<<1",
M_tc_3x_SLOT23, TypeM>, Enc_1997594 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100100110;
let prefersSlot3 = 1;
}
def M2_mpyud_nac_hh_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 -= mpyu($Rs32.h,$Rt32.h)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110011;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyud_nac_hh_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 -= mpyu($Rs32.h,$Rt32.h):<<1",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110111;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyud_nac_hl_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 -= mpyu($Rs32.h,$Rt32.l)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110011;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyud_nac_hl_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 -= mpyu($Rs32.h,$Rt32.l):<<1",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110111;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyud_nac_lh_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 -= mpyu($Rs32.l,$Rt32.h)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110011;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyud_nac_lh_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 -= mpyu($Rs32.l,$Rt32.h):<<1",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110111;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyud_nac_ll_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 -= mpyu($Rs32.l,$Rt32.l)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110011;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyud_nac_ll_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 -= mpyu($Rs32.l,$Rt32.l):<<1",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110111;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyui : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpyui($Rs32,$Rt32)",
M_tc_3x_SLOT23, TypeM> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def M2_nacci : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= add($Rs32,$Rt32)",
M_tc_2_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101111100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let InputType = "reg";
let Constraints = "$Rx32 = $Rx32in";
}
def M2_naccii : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, s32_0Imm:$Ii),
"$Rx32 -= add($Rs32,#$Ii)",
M_tc_2_acc_SLOT23, TypeM>, Enc_11522288 {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100010100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let InputType = "imm";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 1;
let opExtentBits = 8;
let opExtentAlign = 0;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_subacc : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rt32, IntRegs:$Rs32),
"$Rx32 += sub($Rt32,$Rs32)",
M_tc_2_acc_SLOT23, TypeM>, Enc_7692963 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101111000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let InputType = "reg";
let Constraints = "$Rx32 = $Rx32in";
}
def M2_vabsdiffh : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vabsdiffh($Rtt32,$Rss32)",
M_tc_2_SLOT23, TypeM>, Enc_11687333 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000011;
let prefersSlot3 = 1;
}
def M2_vabsdiffw : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vabsdiffw($Rtt32,$Rss32)",
M_tc_2_SLOT23, TypeM>, Enc_11687333 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000001;
let prefersSlot3 = 1;
}
def M2_vcmac_s0_sat_i : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vcmpyi($Rss32,$Rtt32):sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_12702821 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010010;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_vcmac_s0_sat_r : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vcmpyr($Rss32,$Rtt32):sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_12702821 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010001;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_vcmpy_s0_sat_i : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vcmpyi($Rss32,$Rtt32):sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_8333157 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000010;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_vcmpy_s0_sat_r : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vcmpyr($Rss32,$Rtt32):sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_8333157 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000001;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_vcmpy_s1_sat_i : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vcmpyi($Rss32,$Rtt32):<<1:sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_8333157 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000110;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_vcmpy_s1_sat_r : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vcmpyr($Rss32,$Rtt32):<<1:sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_8333157 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000101;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_vdmacs_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vdmpy($Rss32,$Rtt32):sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_12702821 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010000;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_vdmacs_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vdmpy($Rss32,$Rtt32):<<1:sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_12702821 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010100;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_vdmpyrs_s0 : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rd32 = vdmpy($Rss32,$Rtt32):rnd:sat",
M_tc_3x_SLOT23, TypeM>, Enc_9277990 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101001000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_vdmpyrs_s1 : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rd32 = vdmpy($Rss32,$Rtt32):<<1:rnd:sat",
M_tc_3x_SLOT23, TypeM>, Enc_9277990 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101001100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_vdmpys_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vdmpy($Rss32,$Rtt32):sat",
M_tc_3x_SLOT23, TypeM>, Enc_8333157 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000000;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_vdmpys_s1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vdmpy($Rss32,$Rtt32):<<1:sat",
M_tc_3x_SLOT23, TypeM>, Enc_8333157 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000100;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_vmac2 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += vmpyh($Rs32,$Rt32)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100111001;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_vmac2es : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vmpyeh($Rss32,$Rtt32)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_12702821 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010001;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_vmac2es_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vmpyeh($Rss32,$Rtt32):sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_12702821 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010000;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_vmac2es_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vmpyeh($Rss32,$Rtt32):<<1:sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_12702821 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010100;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_vmac2s_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += vmpyh($Rs32,$Rt32):sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100111000;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_vmac2s_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += vmpyh($Rs32,$Rt32):<<1:sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100111100;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_vmac2su_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += vmpyhsu($Rs32,$Rt32):sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100111011;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_vmac2su_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += vmpyhsu($Rs32,$Rt32):<<1:sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100111111;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_vmpy2es_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vmpyeh($Rss32,$Rtt32):sat",
M_tc_3x_SLOT23, TypeM>, Enc_8333157 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000000;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_vmpy2es_s1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vmpyeh($Rss32,$Rtt32):<<1:sat",
M_tc_3x_SLOT23, TypeM>, Enc_8333157 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000100;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_vmpy2s_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = vmpyh($Rs32,$Rt32):sat",
M_tc_3x_SLOT23, TypeM>, Enc_1997594 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100101000;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_vmpy2s_s0pack : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = vmpyh($Rs32,$Rt32):rnd:sat",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101101001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_vmpy2s_s1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = vmpyh($Rs32,$Rt32):<<1:sat",
M_tc_3x_SLOT23, TypeM>, Enc_1997594 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100101100;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_vmpy2s_s1pack : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = vmpyh($Rs32,$Rt32):<<1:rnd:sat",
M_tc_3x_SLOT23, TypeM>, Enc_14071773 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101101101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_vmpy2su_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = vmpyhsu($Rs32,$Rt32):sat",
M_tc_3x_SLOT23, TypeM>, Enc_1997594 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100101000;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_vmpy2su_s1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = vmpyhsu($Rs32,$Rt32):<<1:sat",
M_tc_3x_SLOT23, TypeM>, Enc_1997594 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100101100;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_vraddh : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rd32 = vraddh($Rss32,$Rtt32)",
M_tc_3x_SLOT23, TypeM>, Enc_9277990 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101001001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_vradduh : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rd32 = vradduh($Rss32,$Rtt32)",
M_tc_3x_SLOT23, TypeM>, Enc_9277990 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101001000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_vrcmaci_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vrcmpyi($Rss32,$Rtt32)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_12702821 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010000;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_vrcmaci_s0c : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vrcmpyi($Rss32,$Rtt32*)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_12702821 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010010;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_vrcmacr_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vrcmpyr($Rss32,$Rtt32)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_12702821 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010000;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_vrcmacr_s0c : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vrcmpyr($Rss32,$Rtt32*)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_12702821 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010011;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_vrcmpyi_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vrcmpyi($Rss32,$Rtt32)",
M_tc_3x_SLOT23, TypeM>, Enc_8333157 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000000;
let prefersSlot3 = 1;
}
def M2_vrcmpyi_s0c : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vrcmpyi($Rss32,$Rtt32*)",
M_tc_3x_SLOT23, TypeM>, Enc_8333157 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000010;
let prefersSlot3 = 1;
}
def M2_vrcmpyr_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vrcmpyr($Rss32,$Rtt32)",
M_tc_3x_SLOT23, TypeM>, Enc_8333157 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000000;
let prefersSlot3 = 1;
}
def M2_vrcmpyr_s0c : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vrcmpyr($Rss32,$Rtt32*)",
M_tc_3x_SLOT23, TypeM>, Enc_8333157 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000011;
let prefersSlot3 = 1;
}
def M2_vrcmpys_acc_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rxx32 += vrcmpys($Rss32,$Rt32):<<1:sat",
M_tc_3x_SLOT23, TypeM> {
let isPseudo = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_vrcmpys_acc_s1_h : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vrcmpys($Rss32,$Rtt32):<<1:sat:raw:hi",
M_tc_3x_SLOT23, TypeM>, Enc_12702821 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010101;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_vrcmpys_acc_s1_l : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vrcmpys($Rss32,$Rtt32):<<1:sat:raw:lo",
M_tc_3x_SLOT23, TypeM>, Enc_12702821 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010111;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_vrcmpys_s1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rdd32 = vrcmpys($Rss32,$Rt32):<<1:sat",
M_tc_3x_SLOT23, TypeM> {
let isPseudo = 1;
}
def M2_vrcmpys_s1_h : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vrcmpys($Rss32,$Rtt32):<<1:sat:raw:hi",
M_tc_3x_SLOT23, TypeM>, Enc_8333157 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000101;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_vrcmpys_s1_l : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vrcmpys($Rss32,$Rtt32):<<1:sat:raw:lo",
M_tc_3x_SLOT23, TypeM>, Enc_8333157 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000111;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_vrcmpys_s1rp : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rd32 = vrcmpys($Rss32,$Rt32):<<1:rnd:sat",
M_tc_3x_SLOT23, TypeM> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
}
def M2_vrcmpys_s1rp_h : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rd32 = vrcmpys($Rss32,$Rtt32):<<1:rnd:sat:raw:hi",
M_tc_3x_SLOT23, TypeM>, Enc_9277990 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101001101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_vrcmpys_s1rp_l : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rd32 = vrcmpys($Rss32,$Rtt32):<<1:rnd:sat:raw:lo",
M_tc_3x_SLOT23, TypeM>, Enc_9277990 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101001101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_vrmac_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vrmpyh($Rss32,$Rtt32)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_12702821 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010000;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_vrmpy_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vrmpyh($Rss32,$Rtt32)",
M_tc_3x_SLOT23, TypeM>, Enc_8333157 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000000;
let prefersSlot3 = 1;
}
def M2_xor_xacc : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 ^= xor($Rs32,$Rt32)",
M_tc_2_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101111100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let InputType = "reg";
let Constraints = "$Rx32 = $Rx32in";
}
def M4_and_and : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 &= and($Rs32,$Rt32)",
M_tc_2_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101111010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let InputType = "reg";
let Constraints = "$Rx32 = $Rx32in";
}
def M4_and_andn : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 &= and($Rs32,~$Rt32)",
M_tc_2_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101111001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let InputType = "reg";
let Constraints = "$Rx32 = $Rx32in";
}
def M4_and_or : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 &= or($Rs32,$Rt32)",
M_tc_2_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101111010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let InputType = "reg";
let Constraints = "$Rx32 = $Rx32in";
}
def M4_and_xor : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 &= xor($Rs32,$Rt32)",
M_tc_2_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101111010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let InputType = "reg";
let Constraints = "$Rx32 = $Rx32in";
}
def M4_cmpyi_wh : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rd32 = cmpyiwh($Rss32,$Rt32):<<1:rnd:sat",
S_3op_tc_3x_SLOT23, TypeS_3op>, Enc_14287645 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000101000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M4_cmpyi_whc : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rd32 = cmpyiwh($Rss32,$Rt32*):<<1:rnd:sat",
S_3op_tc_3x_SLOT23, TypeS_3op>, Enc_14287645, Requires<[HasV5T]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000101000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M4_cmpyr_wh : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rd32 = cmpyrwh($Rss32,$Rt32):<<1:rnd:sat",
S_3op_tc_3x_SLOT23, TypeS_3op>, Enc_14287645 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000101000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M4_cmpyr_whc : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rd32 = cmpyrwh($Rss32,$Rt32*):<<1:rnd:sat",
S_3op_tc_3x_SLOT23, TypeS_3op>, Enc_14287645, Requires<[HasV5T]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000101000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M4_mac_up_s1_sat : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpy($Rs32,$Rt32):<<1:sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101111011;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let InputType = "reg";
let Constraints = "$Rx32 = $Rx32in";
}
def M4_mpyri_addi : HInst<
(outs IntRegs:$Rd32),
(ins u32_0Imm:$Ii, IntRegs:$Rs32, u6_0Imm:$II),
"$Rd32 = add(#$Ii,mpyi($Rs32,#$II))",
ALU64_tc_3x_SLOT23, TypeALU64>, Enc_971574, ImmRegRel {
let Inst{31-24} = 0b11011000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let CextOpcode = "M4_mpyri_addr";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def M4_mpyri_addr : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Ru32, IntRegs:$Rs32, u32_0Imm:$Ii),
"$Rd32 = add($Ru32,mpyi($Rs32,#$Ii))",
ALU64_tc_3x_SLOT23, TypeALU64>, Enc_236434, ImmRegRel {
let Inst{31-23} = 0b110111111;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let CextOpcode = "M4_mpyri_addr";
let InputType = "imm";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def M4_mpyri_addr_u2 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Ru32, u6_2Imm:$Ii, IntRegs:$Rs32),
"$Rd32 = add($Ru32,mpyi(#$Ii,$Rs32))",
ALU64_tc_3x_SLOT23, TypeALU64>, Enc_9959498 {
let Inst{31-23} = 0b110111110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M4_mpyrr_addi : HInst<
(outs IntRegs:$Rd32),
(ins u32_0Imm:$Ii, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = add(#$Ii,mpyi($Rs32,$Rt32))",
ALU64_tc_3x_SLOT23, TypeALU64>, Enc_2216485, ImmRegRel {
let Inst{31-23} = 0b110101110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let CextOpcode = "M4_mpyrr_addr";
let InputType = "imm";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def M4_mpyrr_addr : HInst<
(outs IntRegs:$Ry32),
(ins IntRegs:$Ru32, IntRegs:$Ry32in, IntRegs:$Rs32),
"$Ry32 = add($Ru32,mpyi($Ry32in,$Rs32))",
M_tc_3x_SLOT23, TypeM>, Enc_13770697, ImmRegRel {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100011000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let CextOpcode = "M4_mpyrr_addr";
let InputType = "reg";
let Constraints = "$Ry32 = $Ry32in";
}
def M4_nac_up_s1_sat : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= mpy($Rs32,$Rt32):<<1:sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101111011;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let InputType = "reg";
let Constraints = "$Rx32 = $Rx32in";
}
def M4_or_and : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 |= and($Rs32,$Rt32)",
M_tc_2_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101111010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let InputType = "reg";
let Constraints = "$Rx32 = $Rx32in";
}
def M4_or_andn : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 |= and($Rs32,~$Rt32)",
M_tc_2_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101111001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let InputType = "reg";
let Constraints = "$Rx32 = $Rx32in";
}
def M4_or_or : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 |= or($Rs32,$Rt32)",
M_tc_2_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101111110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let InputType = "reg";
let Constraints = "$Rx32 = $Rx32in";
}
def M4_or_xor : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 |= xor($Rs32,$Rt32)",
M_tc_2_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101111110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let InputType = "reg";
let Constraints = "$Rx32 = $Rx32in";
}
def M4_pmpyw : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = pmpyw($Rs32,$Rt32)",
M_tc_3x_SLOT23, TypeM>, Enc_1997594 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100101010;
let prefersSlot3 = 1;
}
def M4_pmpyw_acc : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 ^= pmpyw($Rs32,$Rt32)",
M_tc_3x_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100111001;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M4_vpmpyh : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = vpmpyh($Rs32,$Rt32)",
M_tc_3x_SLOT23, TypeM>, Enc_1997594 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100101110;
let prefersSlot3 = 1;
}
def M4_vpmpyh_acc : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 ^= vpmpyh($Rs32,$Rt32)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100111101;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M4_vrmpyeh_acc_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vrmpyweh($Rss32,$Rtt32)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_12702821 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010001;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M4_vrmpyeh_acc_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vrmpyweh($Rss32,$Rtt32):<<1",
M_tc_3x_acc_SLOT23, TypeM>, Enc_12702821 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010101;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M4_vrmpyeh_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vrmpyweh($Rss32,$Rtt32)",
M_tc_3x_SLOT23, TypeM>, Enc_8333157 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000010;
let prefersSlot3 = 1;
}
def M4_vrmpyeh_s1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vrmpyweh($Rss32,$Rtt32):<<1",
M_tc_3x_SLOT23, TypeM>, Enc_8333157 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000110;
let prefersSlot3 = 1;
}
def M4_vrmpyoh_acc_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vrmpywoh($Rss32,$Rtt32)",
M_tc_3x_SLOT23, TypeM>, Enc_12702821 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010011;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M4_vrmpyoh_acc_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vrmpywoh($Rss32,$Rtt32):<<1",
M_tc_3x_SLOT23, TypeM>, Enc_12702821 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010111;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M4_vrmpyoh_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vrmpywoh($Rss32,$Rtt32)",
M_tc_3x_SLOT23, TypeM>, Enc_8333157 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000001;
let prefersSlot3 = 1;
}
def M4_vrmpyoh_s1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vrmpywoh($Rss32,$Rtt32):<<1",
M_tc_3x_SLOT23, TypeM>, Enc_8333157 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000101;
let prefersSlot3 = 1;
}
def M4_xor_and : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 ^= and($Rs32,$Rt32)",
M_tc_2_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101111110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let InputType = "reg";
let Constraints = "$Rx32 = $Rx32in";
}
def M4_xor_andn : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 ^= and($Rs32,~$Rt32)",
M_tc_2_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101111001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let InputType = "reg";
let Constraints = "$Rx32 = $Rx32in";
}
def M4_xor_or : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 ^= or($Rs32,$Rt32)",
M_tc_2_acc_SLOT23, TypeM>, Enc_9223889 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101111110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let InputType = "reg";
let Constraints = "$Rx32 = $Rx32in";
}
def M4_xor_xacc : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 ^= xor($Rss32,$Rtt32)",
S_3op_tc_1_SLOT23, TypeS_3op>, Enc_12702821 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001010100;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M5_vdmacbsu : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vdmpybsu($Rss32,$Rtt32):sat",
M_tc_3x_acc_SLOT23, TypeM>, Enc_12702821, Requires<[HasV5T]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010001;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M5_vdmpybsu : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vdmpybsu($Rss32,$Rtt32):sat",
M_tc_3x_SLOT23, TypeM>, Enc_8333157, Requires<[HasV5T]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000101;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M5_vmacbsu : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += vmpybsu($Rs32,$Rt32)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100111110;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M5_vmacbuu : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += vmpybu($Rs32,$Rt32)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_1409050 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100111100;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M5_vmpybsu : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = vmpybsu($Rs32,$Rt32)",
M_tc_3x_SLOT23, TypeM>, Enc_1997594 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100101010;
let prefersSlot3 = 1;
}
def M5_vmpybuu : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = vmpybu($Rs32,$Rt32)",
M_tc_3x_SLOT23, TypeM>, Enc_1997594 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100101100;
let prefersSlot3 = 1;
}
def M5_vrmacbsu : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vrmpybsu($Rss32,$Rtt32)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_12702821 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010110;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M5_vrmacbuu : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vrmpybu($Rss32,$Rtt32)",
M_tc_3x_acc_SLOT23, TypeM>, Enc_12702821 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010100;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M5_vrmpybsu : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vrmpybsu($Rss32,$Rtt32)",
M_tc_3x_SLOT23, TypeM>, Enc_8333157 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000110;
let prefersSlot3 = 1;
}
def M5_vrmpybuu : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vrmpybu($Rss32,$Rtt32)",
M_tc_3x_SLOT23, TypeM>, Enc_8333157 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000100;
let prefersSlot3 = 1;
}
def M6_vabsdiffb : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vabsdiffb($Rtt32,$Rss32)",
M_tc_2_SLOT23, TypeM>, Enc_11687333, Requires<[HasV62T]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000111;
let prefersSlot3 = 1;
}
def M6_vabsdiffub : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vabsdiffub($Rtt32,$Rss32)",
M_tc_2_SLOT23, TypeM>, Enc_11687333, Requires<[HasV62T]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000101;
let prefersSlot3 = 1;
}
def PS_loadrbabs : HInst<
(outs IntRegs:$Rd32),
(ins u32_0Imm:$Ii),
"$Rd32 = memb(#$Ii)",
V2LDST_tc_ld_SLOT01, TypeV2LDST>, Enc_1886960, AddrModeRel {
let Inst{24-21} = 0b1000;
let Inst{31-27} = 0b01001;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = Absolute;
let accessSize = ByteAccess;
let isExtended = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrb";
let BaseOpcode = "L4_loadrb_abs";
let isPredicable = 1;
let DecoderNamespace = "MustExtend";
let isExtended = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 16;
let opExtentAlign = 0;
}
def PS_loadrdabs : HInst<
(outs DoubleRegs:$Rdd32),
(ins u29_3Imm:$Ii),
"$Rdd32 = memd(#$Ii)",
V2LDST_tc_ld_SLOT01, TypeV2LDST>, Enc_4975051, AddrModeRel {
let Inst{24-21} = 0b1110;
let Inst{31-27} = 0b01001;
let addrMode = Absolute;
let accessSize = DoubleWordAccess;
let isExtended = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrd";
let BaseOpcode = "L4_loadrd_abs";
let isPredicable = 1;
let DecoderNamespace = "MustExtend";
let isExtended = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 19;
let opExtentAlign = 3;
}
def PS_loadrhabs : HInst<
(outs IntRegs:$Rd32),
(ins u31_1Imm:$Ii),
"$Rd32 = memh(#$Ii)",
V2LDST_tc_ld_SLOT01, TypeV2LDST>, Enc_12608570, AddrModeRel {
let Inst{24-21} = 0b1010;
let Inst{31-27} = 0b01001;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = Absolute;
let accessSize = HalfWordAccess;
let isExtended = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrh";
let BaseOpcode = "L4_loadrh_abs";
let isPredicable = 1;
let DecoderNamespace = "MustExtend";
let isExtended = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 17;
let opExtentAlign = 1;
}
def PS_loadriabs : HInst<
(outs IntRegs:$Rd32),
(ins u30_2Imm:$Ii),
"$Rd32 = memw(#$Ii)",
V2LDST_tc_ld_SLOT01, TypeV2LDST>, Enc_8814718, AddrModeRel {
let Inst{24-21} = 0b1100;
let Inst{31-27} = 0b01001;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = Absolute;
let accessSize = WordAccess;
let isExtended = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadri";
let BaseOpcode = "L4_loadri_abs";
let isPredicable = 1;
let DecoderNamespace = "MustExtend";
let isExtended = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 18;
let opExtentAlign = 2;
}
def PS_loadrubabs : HInst<
(outs IntRegs:$Rd32),
(ins u32_0Imm:$Ii),
"$Rd32 = memub(#$Ii)",
V2LDST_tc_ld_SLOT01, TypeV2LDST>, Enc_1886960, AddrModeRel {
let Inst{24-21} = 0b1001;
let Inst{31-27} = 0b01001;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = Absolute;
let accessSize = ByteAccess;
let isExtended = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrub";
let BaseOpcode = "L4_loadrub_abs";
let isPredicable = 1;
let DecoderNamespace = "MustExtend";
let isExtended = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 16;
let opExtentAlign = 0;
}
def PS_loadruhabs : HInst<
(outs IntRegs:$Rd32),
(ins u31_1Imm:$Ii),
"$Rd32 = memuh(#$Ii)",
V2LDST_tc_ld_SLOT01, TypeV2LDST>, Enc_12608570, AddrModeRel {
let Inst{24-21} = 0b1011;
let Inst{31-27} = 0b01001;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = Absolute;
let accessSize = HalfWordAccess;
let isExtended = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadruh";
let BaseOpcode = "L4_loadruh_abs";
let isPredicable = 1;
let DecoderNamespace = "MustExtend";
let isExtended = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 17;
let opExtentAlign = 1;
}
def PS_storerbabs : HInst<
(outs),
(ins u32_0Imm:$Ii, IntRegs:$Rt32),
"memb(#$Ii) = $Rt32",
ST_tc_st_SLOT01, TypeV2LDST>, Enc_12395768, AddrModeRel {
let Inst{24-21} = 0b0000;
let Inst{31-27} = 0b01001;
let addrMode = Absolute;
let accessSize = ByteAccess;
let isExtended = 1;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let BaseOpcode = "S2_storerbabs";
let isPredicable = 1;
let isNVStorable = 1;
let DecoderNamespace = "MustExtend";
let isExtended = 1;
let opExtendable = 0;
let isExtentSigned = 0;
let opExtentBits = 16;
let opExtentAlign = 0;
}
def PS_storerbnewabs : HInst<
(outs),
(ins u32_0Imm:$Ii, IntRegs:$Nt8),
"memb(#$Ii) = $Nt8.new",
NCJ_tc_3or4stall_SLOT0, TypeV2LDST>, Enc_4050532, AddrModeRel {
let Inst{12-11} = 0b00;
let Inst{24-21} = 0b0101;
let Inst{31-27} = 0b01001;
let addrMode = Absolute;
let accessSize = ByteAccess;
let isNVStore = 1;
let isExtended = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storerb";
let BaseOpcode = "S2_storerbabs";
let isPredicable = 1;
let DecoderNamespace = "MustExtend";
let isExtended = 1;
let opExtendable = 0;
let isExtentSigned = 0;
let opExtentBits = 16;
let opExtentAlign = 0;
let opNewValue = 1;
}
def PS_storerdabs : HInst<
(outs),
(ins u29_3Imm:$Ii, DoubleRegs:$Rtt32),
"memd(#$Ii) = $Rtt32",
ST_tc_st_SLOT01, TypeV2LDST>, Enc_11682941, AddrModeRel {
let Inst{24-21} = 0b0110;
let Inst{31-27} = 0b01001;
let addrMode = Absolute;
let accessSize = DoubleWordAccess;
let isExtended = 1;
let mayStore = 1;
let CextOpcode = "S2_storerd";
let BaseOpcode = "S2_storerdabs";
let isPredicable = 1;
let DecoderNamespace = "MustExtend";
let isExtended = 1;
let opExtendable = 0;
let isExtentSigned = 0;
let opExtentBits = 19;
let opExtentAlign = 3;
}
def PS_storerfabs : HInst<
(outs),
(ins u31_1Imm:$Ii, IntRegs:$Rt32),
"memh(#$Ii) = $Rt32.h",
ST_tc_st_SLOT01, TypeV2LDST>, Enc_1186018, AddrModeRel {
let Inst{24-21} = 0b0011;
let Inst{31-27} = 0b01001;
let addrMode = Absolute;
let accessSize = HalfWordAccess;
let isExtended = 1;
let mayStore = 1;
let CextOpcode = "S2_storerf";
let BaseOpcode = "S2_storerfabs";
let isPredicable = 1;
let DecoderNamespace = "MustExtend";
let isExtended = 1;
let opExtendable = 0;
let isExtentSigned = 0;
let opExtentBits = 17;
let opExtentAlign = 1;
}
def PS_storerhabs : HInst<
(outs),
(ins u31_1Imm:$Ii, IntRegs:$Rt32),
"memh(#$Ii) = $Rt32",
ST_tc_st_SLOT01, TypeV2LDST>, Enc_1186018, AddrModeRel {
let Inst{24-21} = 0b0010;
let Inst{31-27} = 0b01001;
let addrMode = Absolute;
let accessSize = HalfWordAccess;
let isExtended = 1;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let BaseOpcode = "S2_storerhabs";
let isPredicable = 1;
let isNVStorable = 1;
let DecoderNamespace = "MustExtend";
let isExtended = 1;
let opExtendable = 0;
let isExtentSigned = 0;
let opExtentBits = 17;
let opExtentAlign = 1;
}
def PS_storerhnewabs : HInst<
(outs),
(ins u31_1Imm:$Ii, IntRegs:$Nt8),
"memh(#$Ii) = $Nt8.new",
NCJ_tc_3or4stall_SLOT0, TypeV2LDST>, Enc_13618890, AddrModeRel {
let Inst{12-11} = 0b01;
let Inst{24-21} = 0b0101;
let Inst{31-27} = 0b01001;
let addrMode = Absolute;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let isExtended = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storerh";
let BaseOpcode = "S2_storerhabs";
let isPredicable = 1;
let DecoderNamespace = "MustExtend";
let isExtended = 1;
let opExtendable = 0;
let isExtentSigned = 0;
let opExtentBits = 17;
let opExtentAlign = 1;
let opNewValue = 1;
}
def PS_storeriabs : HInst<
(outs),
(ins u30_2Imm:$Ii, IntRegs:$Rt32),
"memw(#$Ii) = $Rt32",
ST_tc_st_SLOT01, TypeV2LDST>, Enc_15999208, AddrModeRel {
let Inst{24-21} = 0b0100;
let Inst{31-27} = 0b01001;
let addrMode = Absolute;
let accessSize = WordAccess;
let isExtended = 1;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let BaseOpcode = "S2_storeriabs";
let isPredicable = 1;
let isNVStorable = 1;
let DecoderNamespace = "MustExtend";
let isExtended = 1;
let opExtendable = 0;
let isExtentSigned = 0;
let opExtentBits = 18;
let opExtentAlign = 2;
}
def PS_storerinewabs : HInst<
(outs),
(ins u30_2Imm:$Ii, IntRegs:$Nt8),
"memw(#$Ii) = $Nt8.new",
NCJ_tc_3or4stall_SLOT0, TypeV2LDST>, Enc_12297800, AddrModeRel {
let Inst{12-11} = 0b10;
let Inst{24-21} = 0b0101;
let Inst{31-27} = 0b01001;
let addrMode = Absolute;
let accessSize = WordAccess;
let isNVStore = 1;
let isExtended = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storeri";
let BaseOpcode = "S2_storeriabs";
let isPredicable = 1;
let DecoderNamespace = "MustExtend";
let isExtended = 1;
let opExtendable = 0;
let isExtentSigned = 0;
let opExtentBits = 18;
let opExtentAlign = 2;
let opNewValue = 1;
}
def S2_addasl_rrri : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32, u3_0Imm:$Ii),
"$Rd32 = addasl($Rt32,$Rs32,#$Ii)",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_3494181 {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000100000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def S2_allocframe : HInst<
(outs),
(ins u11_3Imm:$Ii),
"allocframe(#$Ii)",
ST_tc_ld_SLOT0, TypeST>, Enc_15830826 {
let Inst{13-11} = 0b000;
let Inst{31-21} = 0b10100000100;
let Inst{20-16} = 0b11101;
let addrMode = BaseImmOffset;
let accessSize = DoubleWordAccess;
let mayStore = 1;
let Uses = [R29, R30, R31];
let Defs = [R29, R30];
}
def S2_asl_i_p : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, u6_0Imm:$Ii),
"$Rdd32 = asl($Rss32,#$Ii)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_4231995 {
let Inst{7-5} = 0b010;
let Inst{31-21} = 0b10000000000;
}
def S2_asl_i_p_acc : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, u6_0Imm:$Ii),
"$Rxx32 += asl($Rss32,#$Ii)",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_8497723 {
let Inst{7-5} = 0b110;
let Inst{31-21} = 0b10000010000;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_asl_i_p_and : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, u6_0Imm:$Ii),
"$Rxx32 &= asl($Rss32,#$Ii)",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_8497723 {
let Inst{7-5} = 0b010;
let Inst{31-21} = 0b10000010010;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_asl_i_p_nac : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, u6_0Imm:$Ii),
"$Rxx32 -= asl($Rss32,#$Ii)",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_8497723 {
let Inst{7-5} = 0b010;
let Inst{31-21} = 0b10000010000;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_asl_i_p_or : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, u6_0Imm:$Ii),
"$Rxx32 |= asl($Rss32,#$Ii)",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_8497723 {
let Inst{7-5} = 0b110;
let Inst{31-21} = 0b10000010010;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_asl_i_p_xacc : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, u6_0Imm:$Ii),
"$Rxx32 ^= asl($Rss32,#$Ii)",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_8497723 {
let Inst{7-5} = 0b010;
let Inst{31-21} = 0b10000010100;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_asl_i_r : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rd32 = asl($Rs32,#$Ii)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_2771456 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001100000;
let hasNewValue = 1;
let opNewValue = 0;
}
def S2_asl_i_r_acc : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rx32 += asl($Rs32,#$Ii)",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_2410156 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001110000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_asl_i_r_and : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rx32 &= asl($Rs32,#$Ii)",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_2410156 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001110010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_asl_i_r_nac : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rx32 -= asl($Rs32,#$Ii)",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_2410156 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001110000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_asl_i_r_or : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rx32 |= asl($Rs32,#$Ii)",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_2410156 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001110010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_asl_i_r_sat : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rd32 = asl($Rs32,#$Ii):sat",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_2771456 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001100010;
let hasNewValue = 1;
let opNewValue = 0;
let Defs = [USR_OVF];
}
def S2_asl_i_r_xacc : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rx32 ^= asl($Rs32,#$Ii)",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_2410156 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001110100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_asl_i_vh : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, u4_0Imm:$Ii),
"$Rdd32 = vaslh($Rss32,#$Ii)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_2082775 {
let Inst{7-5} = 0b010;
let Inst{13-12} = 0b00;
let Inst{31-21} = 0b10000000100;
}
def S2_asl_i_vw : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, u5_0Imm:$Ii),
"$Rdd32 = vaslw($Rss32,#$Ii)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_13201267 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10000000010;
}
def S2_asl_r_p : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rdd32 = asl($Rss32,$Rt32)",
S_3op_tc_1_SLOT23, TypeS_3op>, Enc_8940892 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000011100;
}
def S2_asl_r_p_acc : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rxx32 += asl($Rss32,$Rt32)",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_7912540 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001011110;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_asl_r_p_and : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rxx32 &= asl($Rss32,$Rt32)",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_7912540 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001011010;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_asl_r_p_nac : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rxx32 -= asl($Rss32,$Rt32)",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_7912540 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001011100;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_asl_r_p_or : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rxx32 |= asl($Rss32,$Rt32)",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_7912540 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001011000;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_asl_r_p_xor : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rxx32 ^= asl($Rss32,$Rt32)",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_7912540 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001011011;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_asl_r_r : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = asl($Rs32,$Rt32)",
S_3op_tc_1_SLOT23, TypeS_3op>, Enc_14071773 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000110010;
let hasNewValue = 1;
let opNewValue = 0;
}
def S2_asl_r_r_acc : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += asl($Rs32,$Rt32)",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_9223889 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001100110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_asl_r_r_and : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 &= asl($Rs32,$Rt32)",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_9223889 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001100010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_asl_r_r_nac : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= asl($Rs32,$Rt32)",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_9223889 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001100100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_asl_r_r_or : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 |= asl($Rs32,$Rt32)",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_9223889 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001100000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_asl_r_r_sat : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = asl($Rs32,$Rt32):sat",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_14071773 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000110000;
let hasNewValue = 1;
let opNewValue = 0;
let Defs = [USR_OVF];
}
def S2_asl_r_vh : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rdd32 = vaslh($Rss32,$Rt32)",
S_3op_tc_1_SLOT23, TypeS_3op>, Enc_8940892 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000011010;
}
def S2_asl_r_vw : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rdd32 = vaslw($Rss32,$Rt32)",
S_3op_tc_1_SLOT23, TypeS_3op>, Enc_8940892 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000011000;
}
def S2_asr_i_p : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, u6_0Imm:$Ii),
"$Rdd32 = asr($Rss32,#$Ii)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_4231995 {
let Inst{7-5} = 0b000;
let Inst{31-21} = 0b10000000000;
}
def S2_asr_i_p_acc : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, u6_0Imm:$Ii),
"$Rxx32 += asr($Rss32,#$Ii)",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_8497723 {
let Inst{7-5} = 0b100;
let Inst{31-21} = 0b10000010000;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_asr_i_p_and : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, u6_0Imm:$Ii),
"$Rxx32 &= asr($Rss32,#$Ii)",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_8497723 {
let Inst{7-5} = 0b000;
let Inst{31-21} = 0b10000010010;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_asr_i_p_nac : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, u6_0Imm:$Ii),
"$Rxx32 -= asr($Rss32,#$Ii)",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_8497723 {
let Inst{7-5} = 0b000;
let Inst{31-21} = 0b10000010000;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_asr_i_p_or : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, u6_0Imm:$Ii),
"$Rxx32 |= asr($Rss32,#$Ii)",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_8497723 {
let Inst{7-5} = 0b100;
let Inst{31-21} = 0b10000010010;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_asr_i_p_rnd : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, u6_0Imm:$Ii),
"$Rdd32 = asr($Rss32,#$Ii):rnd",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_4231995, Requires<[HasV5T]> {
let Inst{7-5} = 0b111;
let Inst{31-21} = 0b10000000110;
let prefersSlot3 = 1;
}
def S2_asr_i_p_rnd_goodsyntax : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, u6_0Imm:$Ii),
"$Rdd32 = asrrnd($Rss32,#$Ii)",
S_2op_tc_1_SLOT23, TypeS_2op>, Requires<[HasV5T]> {
let isPseudo = 1;
}
def S2_asr_i_r : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rd32 = asr($Rs32,#$Ii)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_2771456 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001100000;
let hasNewValue = 1;
let opNewValue = 0;
}
def S2_asr_i_r_acc : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rx32 += asr($Rs32,#$Ii)",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_2410156 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001110000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_asr_i_r_and : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rx32 &= asr($Rs32,#$Ii)",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_2410156 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001110010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_asr_i_r_nac : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rx32 -= asr($Rs32,#$Ii)",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_2410156 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001110000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_asr_i_r_or : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rx32 |= asr($Rs32,#$Ii)",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_2410156 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001110010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_asr_i_r_rnd : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rd32 = asr($Rs32,#$Ii):rnd",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_2771456 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001100010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def S2_asr_i_r_rnd_goodsyntax : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rd32 = asrrnd($Rs32,#$Ii)",
S_2op_tc_2_SLOT23, TypeS_2op> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
}
def S2_asr_i_svw_trun : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32, u5_0Imm:$Ii),
"$Rd32 = vasrw($Rss32,#$Ii)",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_2380082 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001000110;
let hasNewValue = 1;
let opNewValue = 0;
}
def S2_asr_i_vh : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, u4_0Imm:$Ii),
"$Rdd32 = vasrh($Rss32,#$Ii)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_2082775 {
let Inst{7-5} = 0b000;
let Inst{13-12} = 0b00;
let Inst{31-21} = 0b10000000100;
}
def S2_asr_i_vw : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, u5_0Imm:$Ii),
"$Rdd32 = vasrw($Rss32,#$Ii)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_13201267 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10000000010;
}
def S2_asr_r_p : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rdd32 = asr($Rss32,$Rt32)",
S_3op_tc_1_SLOT23, TypeS_3op>, Enc_8940892 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000011100;
}
def S2_asr_r_p_acc : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rxx32 += asr($Rss32,$Rt32)",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_7912540 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001011110;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_asr_r_p_and : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rxx32 &= asr($Rss32,$Rt32)",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_7912540 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001011010;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_asr_r_p_nac : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rxx32 -= asr($Rss32,$Rt32)",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_7912540 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001011100;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_asr_r_p_or : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rxx32 |= asr($Rss32,$Rt32)",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_7912540 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001011000;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_asr_r_p_xor : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rxx32 ^= asr($Rss32,$Rt32)",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_7912540 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001011011;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_asr_r_r : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = asr($Rs32,$Rt32)",
S_3op_tc_1_SLOT23, TypeS_3op>, Enc_14071773 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000110010;
let hasNewValue = 1;
let opNewValue = 0;
}
def S2_asr_r_r_acc : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += asr($Rs32,$Rt32)",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_9223889 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001100110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_asr_r_r_and : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 &= asr($Rs32,$Rt32)",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_9223889 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001100010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_asr_r_r_nac : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= asr($Rs32,$Rt32)",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_9223889 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001100100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_asr_r_r_or : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 |= asr($Rs32,$Rt32)",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_9223889 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001100000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_asr_r_r_sat : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = asr($Rs32,$Rt32):sat",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_14071773 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000110000;
let hasNewValue = 1;
let opNewValue = 0;
let Defs = [USR_OVF];
}
def S2_asr_r_svw_trun : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rd32 = vasrw($Rss32,$Rt32)",
S_3op_tc_1_SLOT23, TypeS_3op>, Enc_14287645 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000101000;
let hasNewValue = 1;
let opNewValue = 0;
}
def S2_asr_r_vh : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rdd32 = vasrh($Rss32,$Rt32)",
S_3op_tc_1_SLOT23, TypeS_3op>, Enc_8940892 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000011010;
}
def S2_asr_r_vw : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rdd32 = vasrw($Rss32,$Rt32)",
S_3op_tc_1_SLOT23, TypeS_3op>, Enc_8940892 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000011000;
}
def S2_brev : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = brev($Rs32)",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_4075554 {
let Inst{13-5} = 0b000000110;
let Inst{31-21} = 0b10001100010;
let hasNewValue = 1;
let opNewValue = 0;
}
def S2_brevp : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32),
"$Rdd32 = brev($Rss32)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_13133231 {
let Inst{13-5} = 0b000000110;
let Inst{31-21} = 0b10000000110;
}
def S2_cabacdecbin : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = decbin($Rss32,$Rtt32)",
S_3op_tc_1_SLOT23, TypeS_3op>, Enc_8333157 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000001110;
let isPredicateLate = 1;
let prefersSlot3 = 1;
let Defs = [P0];
}
def S2_cl0 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = cl0($Rs32)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_4075554 {
let Inst{13-5} = 0b000000101;
let Inst{31-21} = 0b10001100000;
let hasNewValue = 1;
let opNewValue = 0;
}
def S2_cl0p : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32),
"$Rd32 = cl0($Rss32)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_3742184 {
let Inst{13-5} = 0b000000010;
let Inst{31-21} = 0b10001000010;
let hasNewValue = 1;
let opNewValue = 0;
}
def S2_cl1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = cl1($Rs32)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_4075554 {
let Inst{13-5} = 0b000000110;
let Inst{31-21} = 0b10001100000;
let hasNewValue = 1;
let opNewValue = 0;
}
def S2_cl1p : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32),
"$Rd32 = cl1($Rss32)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_3742184 {
let Inst{13-5} = 0b000000100;
let Inst{31-21} = 0b10001000010;
let hasNewValue = 1;
let opNewValue = 0;
}
def S2_clb : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = clb($Rs32)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_4075554 {
let Inst{13-5} = 0b000000100;
let Inst{31-21} = 0b10001100000;
let hasNewValue = 1;
let opNewValue = 0;
}
def S2_clbnorm : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = normamt($Rs32)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_4075554 {
let Inst{13-5} = 0b000000111;
let Inst{31-21} = 0b10001100000;
let hasNewValue = 1;
let opNewValue = 0;
}
def S2_clbp : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32),
"$Rd32 = clb($Rss32)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_3742184 {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b10001000010;
let hasNewValue = 1;
let opNewValue = 0;
}
def S2_clrbit_i : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rd32 = clrbit($Rs32,#$Ii)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_2771456 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001100110;
let hasNewValue = 1;
let opNewValue = 0;
}
def S2_clrbit_r : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = clrbit($Rs32,$Rt32)",
S_3op_tc_1_SLOT23, TypeS_3op>, Enc_14071773 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000110100;
let hasNewValue = 1;
let opNewValue = 0;
}
def S2_ct0 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = ct0($Rs32)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_4075554 {
let Inst{13-5} = 0b000000100;
let Inst{31-21} = 0b10001100010;
let hasNewValue = 1;
let opNewValue = 0;
}
def S2_ct0p : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32),
"$Rd32 = ct0($Rss32)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_3742184 {
let Inst{13-5} = 0b000000010;
let Inst{31-21} = 0b10001000111;
let hasNewValue = 1;
let opNewValue = 0;
}
def S2_ct1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = ct1($Rs32)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_4075554 {
let Inst{13-5} = 0b000000101;
let Inst{31-21} = 0b10001100010;
let hasNewValue = 1;
let opNewValue = 0;
}
def S2_ct1p : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32),
"$Rd32 = ct1($Rss32)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_3742184 {
let Inst{13-5} = 0b000000100;
let Inst{31-21} = 0b10001000111;
let hasNewValue = 1;
let opNewValue = 0;
}
def S2_deinterleave : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32),
"$Rdd32 = deinterleave($Rss32)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_13133231 {
let Inst{13-5} = 0b000000100;
let Inst{31-21} = 0b10000000110;
}
def S2_extractu : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, u5_0Imm:$Ii, u5_0Imm:$II),
"$Rd32 = extractu($Rs32,#$Ii,#$II)",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_11930928 {
let Inst{13-13} = 0b0;
let Inst{31-23} = 0b100011010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def S2_extractu_rp : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, DoubleRegs:$Rtt32),
"$Rd32 = extractu($Rs32,$Rtt32)",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_15472748 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001001000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def S2_extractup : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, u6_0Imm:$Ii, u6_0Imm:$II),
"$Rdd32 = extractu($Rss32,#$Ii,#$II)",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_9894557 {
let Inst{31-24} = 0b10000001;
let prefersSlot3 = 1;
}
def S2_extractup_rp : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = extractu($Rss32,$Rtt32)",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_8333157 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000001000;
let prefersSlot3 = 1;
}
def S2_insert : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u5_0Imm:$Ii, u5_0Imm:$II),
"$Rx32 = insert($Rs32,#$Ii,#$II)",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_2880796 {
let Inst{13-13} = 0b0;
let Inst{31-23} = 0b100011110;
let hasNewValue = 1;
let opNewValue = 0;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_insert_rp : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, DoubleRegs:$Rtt32),
"$Rx32 = insert($Rs32,$Rtt32)",
S_3op_tc_1_SLOT23, TypeS_3op>, Enc_16311032 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001000000;
let hasNewValue = 1;
let opNewValue = 0;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_insertp : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, u6_0Imm:$Ii, u6_0Imm:$II),
"$Rxx32 = insert($Rss32,#$Ii,#$II)",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_631197 {
let Inst{31-24} = 0b10000011;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_insertp_rp : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 = insert($Rss32,$Rtt32)",
S_3op_tc_1_SLOT23, TypeS_3op>, Enc_12702821 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001010000;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_interleave : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32),
"$Rdd32 = interleave($Rss32)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_13133231 {
let Inst{13-5} = 0b000000101;
let Inst{31-21} = 0b10000000110;
}
def S2_lfsp : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = lfs($Rss32,$Rtt32)",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_8333157 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000001100;
let prefersSlot3 = 1;
}
def S2_lsl_r_p : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rdd32 = lsl($Rss32,$Rt32)",
S_3op_tc_1_SLOT23, TypeS_3op>, Enc_8940892 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000011100;
}
def S2_lsl_r_p_acc : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rxx32 += lsl($Rss32,$Rt32)",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_7912540 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001011110;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_lsl_r_p_and : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rxx32 &= lsl($Rss32,$Rt32)",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_7912540 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001011010;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_lsl_r_p_nac : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rxx32 -= lsl($Rss32,$Rt32)",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_7912540 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001011100;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_lsl_r_p_or : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rxx32 |= lsl($Rss32,$Rt32)",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_7912540 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001011000;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_lsl_r_p_xor : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rxx32 ^= lsl($Rss32,$Rt32)",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_7912540 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001011011;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_lsl_r_r : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = lsl($Rs32,$Rt32)",
S_3op_tc_1_SLOT23, TypeS_3op>, Enc_14071773 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000110010;
let hasNewValue = 1;
let opNewValue = 0;
}
def S2_lsl_r_r_acc : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += lsl($Rs32,$Rt32)",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_9223889 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001100110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_lsl_r_r_and : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 &= lsl($Rs32,$Rt32)",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_9223889 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001100010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_lsl_r_r_nac : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= lsl($Rs32,$Rt32)",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_9223889 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001100100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_lsl_r_r_or : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 |= lsl($Rs32,$Rt32)",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_9223889 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001100000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_lsl_r_vh : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rdd32 = vlslh($Rss32,$Rt32)",
S_3op_tc_1_SLOT23, TypeS_3op>, Enc_8940892 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000011010;
}
def S2_lsl_r_vw : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rdd32 = vlslw($Rss32,$Rt32)",
S_3op_tc_1_SLOT23, TypeS_3op>, Enc_8940892 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000011000;
}
def S2_lsr_i_p : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, u6_0Imm:$Ii),
"$Rdd32 = lsr($Rss32,#$Ii)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_4231995 {
let Inst{7-5} = 0b001;
let Inst{31-21} = 0b10000000000;
}
def S2_lsr_i_p_acc : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, u6_0Imm:$Ii),
"$Rxx32 += lsr($Rss32,#$Ii)",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_8497723 {
let Inst{7-5} = 0b101;
let Inst{31-21} = 0b10000010000;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_lsr_i_p_and : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, u6_0Imm:$Ii),
"$Rxx32 &= lsr($Rss32,#$Ii)",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_8497723 {
let Inst{7-5} = 0b001;
let Inst{31-21} = 0b10000010010;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_lsr_i_p_nac : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, u6_0Imm:$Ii),
"$Rxx32 -= lsr($Rss32,#$Ii)",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_8497723 {
let Inst{7-5} = 0b001;
let Inst{31-21} = 0b10000010000;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_lsr_i_p_or : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, u6_0Imm:$Ii),
"$Rxx32 |= lsr($Rss32,#$Ii)",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_8497723 {
let Inst{7-5} = 0b101;
let Inst{31-21} = 0b10000010010;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_lsr_i_p_xacc : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, u6_0Imm:$Ii),
"$Rxx32 ^= lsr($Rss32,#$Ii)",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_8497723 {
let Inst{7-5} = 0b001;
let Inst{31-21} = 0b10000010100;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_lsr_i_r : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rd32 = lsr($Rs32,#$Ii)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_2771456 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001100000;
let hasNewValue = 1;
let opNewValue = 0;
}
def S2_lsr_i_r_acc : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rx32 += lsr($Rs32,#$Ii)",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_2410156 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001110000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_lsr_i_r_and : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rx32 &= lsr($Rs32,#$Ii)",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_2410156 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001110010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_lsr_i_r_nac : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rx32 -= lsr($Rs32,#$Ii)",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_2410156 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001110000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_lsr_i_r_or : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rx32 |= lsr($Rs32,#$Ii)",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_2410156 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001110010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_lsr_i_r_xacc : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rx32 ^= lsr($Rs32,#$Ii)",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_2410156 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001110100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_lsr_i_vh : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, u4_0Imm:$Ii),
"$Rdd32 = vlsrh($Rss32,#$Ii)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_2082775 {
let Inst{7-5} = 0b001;
let Inst{13-12} = 0b00;
let Inst{31-21} = 0b10000000100;
}
def S2_lsr_i_vw : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, u5_0Imm:$Ii),
"$Rdd32 = vlsrw($Rss32,#$Ii)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_13201267 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10000000010;
}
def S2_lsr_r_p : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rdd32 = lsr($Rss32,$Rt32)",
S_3op_tc_1_SLOT23, TypeS_3op>, Enc_8940892 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000011100;
}
def S2_lsr_r_p_acc : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rxx32 += lsr($Rss32,$Rt32)",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_7912540 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001011110;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_lsr_r_p_and : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rxx32 &= lsr($Rss32,$Rt32)",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_7912540 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001011010;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_lsr_r_p_nac : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rxx32 -= lsr($Rss32,$Rt32)",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_7912540 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001011100;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_lsr_r_p_or : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rxx32 |= lsr($Rss32,$Rt32)",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_7912540 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001011000;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_lsr_r_p_xor : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rxx32 ^= lsr($Rss32,$Rt32)",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_7912540 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001011011;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_lsr_r_r : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = lsr($Rs32,$Rt32)",
S_3op_tc_1_SLOT23, TypeS_3op>, Enc_14071773 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000110010;
let hasNewValue = 1;
let opNewValue = 0;
}
def S2_lsr_r_r_acc : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += lsr($Rs32,$Rt32)",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_9223889 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001100110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_lsr_r_r_and : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 &= lsr($Rs32,$Rt32)",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_9223889 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001100010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_lsr_r_r_nac : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= lsr($Rs32,$Rt32)",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_9223889 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001100100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_lsr_r_r_or : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 |= lsr($Rs32,$Rt32)",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_9223889 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001100000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_lsr_r_vh : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rdd32 = vlsrh($Rss32,$Rt32)",
S_3op_tc_1_SLOT23, TypeS_3op>, Enc_8940892 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000011010;
}
def S2_lsr_r_vw : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rdd32 = vlsrw($Rss32,$Rt32)",
S_3op_tc_1_SLOT23, TypeS_3op>, Enc_8940892 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000011000;
}
def S2_packhl : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = packhl($Rs32,$Rt32)",
ALU32_3op_tc_1_SLOT0123, TypeALU32_3op>, Enc_1997594 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110101100;
let InputType = "reg";
}
def S2_parityp : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rd32 = parity($Rss32,$Rtt32)",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_9277990 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010000000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def S2_pstorerbf_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u32_0Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4) memb($Rs32+#$Ii) = $Rt32",
V2LDST_tc_st_SLOT01, TypeV2LDST>, Enc_14044877, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{31-21} = 0b01000100000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let InputType = "imm";
let BaseOpcode = "S2_storerb_io";
let isNVStorable = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S2_pstorerbf_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_0Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4) memb($Rx32++#$Ii) = $Rt32",
ST_tc_st_pi_SLOT01, TypeST>, Enc_8065534, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b10101011000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = ByteAccess;
let mayStore = 1;
let BaseOpcode = "S2_storerb_pi";
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerbf_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32),
"if (!$Pv4) memb($Rs32) = $Rt32",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S2_pstorerbfnew_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_0Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4.new) memb($Rx32++#$Ii) = $Rt32",
ST_tc_st_pi_SLOT01, TypeST>, Enc_8065534, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b10101011000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = ByteAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let BaseOpcode = "S2_storerb_pi";
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerbnewf_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u32_0Imm:$Ii, IntRegs:$Nt8),
"if (!$Pv4) memb($Rs32+#$Ii) = $Nt8.new",
V2LDST_tc_st_SLOT0, TypeV2LDST>, Enc_1737833, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b01000100101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storerb";
let InputType = "imm";
let BaseOpcode = "S2_storerb_io";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let opNewValue = 3;
}
def S2_pstorerbnewf_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_0Imm:$Ii, IntRegs:$Nt8),
"if (!$Pv4) memb($Rx32++#$Ii) = $Nt8.new",
ST_tc_st_pi_SLOT0, TypeST>, Enc_2813446, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b0;
let Inst{13-11} = 0b100;
let Inst{31-21} = 0b10101011101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = ByteAccess;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storerb";
let BaseOpcode = "S2_storerb_pi";
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerbnewf_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Nt8),
"if (!$Pv4) memb($Rs32) = $Nt8.new",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let opNewValue = 2;
}
def S2_pstorerbnewfnew_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_0Imm:$Ii, IntRegs:$Nt8),
"if (!$Pv4.new) memb($Rx32++#$Ii) = $Nt8.new",
ST_tc_st_pi_SLOT0, TypeST>, Enc_2813446, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b1;
let Inst{13-11} = 0b100;
let Inst{31-21} = 0b10101011101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = ByteAccess;
let isNVStore = 1;
let isPredicatedNew = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storerb";
let BaseOpcode = "S2_storerb_pi";
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerbnewt_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u32_0Imm:$Ii, IntRegs:$Nt8),
"if ($Pv4) memb($Rs32+#$Ii) = $Nt8.new",
V2LDST_tc_st_SLOT0, TypeV2LDST>, Enc_1737833, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b01000000101;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storerb";
let InputType = "imm";
let BaseOpcode = "S2_storerb_io";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let opNewValue = 3;
}
def S2_pstorerbnewt_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_0Imm:$Ii, IntRegs:$Nt8),
"if ($Pv4) memb($Rx32++#$Ii) = $Nt8.new",
ST_tc_st_pi_SLOT0, TypeST>, Enc_2813446, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b0;
let Inst{13-11} = 0b100;
let Inst{31-21} = 0b10101011101;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = ByteAccess;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storerb";
let BaseOpcode = "S2_storerb_pi";
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerbnewt_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Nt8),
"if ($Pv4) memb($Rs32) = $Nt8.new",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let opNewValue = 2;
}
def S2_pstorerbnewtnew_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_0Imm:$Ii, IntRegs:$Nt8),
"if ($Pv4.new) memb($Rx32++#$Ii) = $Nt8.new",
ST_tc_st_pi_SLOT0, TypeST>, Enc_2813446, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b1;
let Inst{13-11} = 0b100;
let Inst{31-21} = 0b10101011101;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = ByteAccess;
let isNVStore = 1;
let isPredicatedNew = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storerb";
let BaseOpcode = "S2_storerb_pi";
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerbt_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u32_0Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4) memb($Rs32+#$Ii) = $Rt32",
V2LDST_tc_st_SLOT01, TypeV2LDST>, Enc_14044877, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{31-21} = 0b01000000000;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let InputType = "imm";
let BaseOpcode = "S2_storerb_io";
let isNVStorable = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S2_pstorerbt_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_0Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4) memb($Rx32++#$Ii) = $Rt32",
ST_tc_st_pi_SLOT01, TypeST>, Enc_8065534, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b10101011000;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = ByteAccess;
let mayStore = 1;
let BaseOpcode = "S2_storerb_pi";
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerbt_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32),
"if ($Pv4) memb($Rs32) = $Rt32",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S2_pstorerbtnew_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_0Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4.new) memb($Rx32++#$Ii) = $Rt32",
ST_tc_st_pi_SLOT01, TypeST>, Enc_8065534, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b10101011000;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = ByteAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let BaseOpcode = "S2_storerb_pi";
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerdf_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u29_3Imm:$Ii, DoubleRegs:$Rtt32),
"if (!$Pv4) memd($Rs32+#$Ii) = $Rtt32",
V2LDST_tc_st_SLOT01, TypeV2LDST>, Enc_11049656, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{31-21} = 0b01000100110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = DoubleWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerd";
let InputType = "imm";
let BaseOpcode = "S2_storerd_io";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 9;
let opExtentAlign = 3;
}
def S2_pstorerdf_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_3Imm:$Ii, DoubleRegs:$Rtt32),
"if (!$Pv4) memd($Rx32++#$Ii) = $Rtt32",
ST_tc_st_pi_SLOT01, TypeST>, Enc_11959851, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b10101011110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = DoubleWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerd";
let BaseOpcode = "S2_storerd_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerdf_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, DoubleRegs:$Rtt32),
"if (!$Pv4) memd($Rs32) = $Rtt32",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S2_pstorerdfnew_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_3Imm:$Ii, DoubleRegs:$Rtt32),
"if (!$Pv4.new) memd($Rx32++#$Ii) = $Rtt32",
ST_tc_st_pi_SLOT01, TypeST>, Enc_11959851, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b10101011110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = DoubleWordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerd";
let BaseOpcode = "S2_storerd_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerdt_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u29_3Imm:$Ii, DoubleRegs:$Rtt32),
"if ($Pv4) memd($Rs32+#$Ii) = $Rtt32",
V2LDST_tc_st_SLOT01, TypeV2LDST>, Enc_11049656, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{31-21} = 0b01000000110;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = DoubleWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerd";
let InputType = "imm";
let BaseOpcode = "S2_storerd_io";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 9;
let opExtentAlign = 3;
}
def S2_pstorerdt_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_3Imm:$Ii, DoubleRegs:$Rtt32),
"if ($Pv4) memd($Rx32++#$Ii) = $Rtt32",
ST_tc_st_pi_SLOT01, TypeST>, Enc_11959851, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b10101011110;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = DoubleWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerd";
let BaseOpcode = "S2_storerd_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerdt_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, DoubleRegs:$Rtt32),
"if ($Pv4) memd($Rs32) = $Rtt32",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S2_pstorerdtnew_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_3Imm:$Ii, DoubleRegs:$Rtt32),
"if ($Pv4.new) memd($Rx32++#$Ii) = $Rtt32",
ST_tc_st_pi_SLOT01, TypeST>, Enc_11959851, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b10101011110;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = DoubleWordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerd";
let BaseOpcode = "S2_storerd_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerff_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u31_1Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4) memh($Rs32+#$Ii) = $Rt32.h",
V2LDST_tc_st_SLOT01, TypeV2LDST>, Enc_10979813, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{31-21} = 0b01000100011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerf";
let InputType = "imm";
let BaseOpcode = "S2_storerf_io";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
}
def S2_pstorerff_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_1Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4) memh($Rx32++#$Ii) = $Rt32.h",
ST_tc_st_pi_SLOT01, TypeST>, Enc_11065510, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b10101011011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerf";
let BaseOpcode = "S2_storerf_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerff_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32),
"if (!$Pv4) memh($Rs32) = $Rt32.h",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S2_pstorerffnew_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_1Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4.new) memh($Rx32++#$Ii) = $Rt32.h",
ST_tc_st_pi_SLOT01, TypeST>, Enc_11065510, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b10101011011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerf";
let BaseOpcode = "S2_storerf_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerft_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u31_1Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4) memh($Rs32+#$Ii) = $Rt32.h",
V2LDST_tc_st_SLOT01, TypeV2LDST>, Enc_10979813, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{31-21} = 0b01000000011;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerf";
let InputType = "imm";
let BaseOpcode = "S2_storerf_io";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
}
def S2_pstorerft_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_1Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4) memh($Rx32++#$Ii) = $Rt32.h",
ST_tc_st_pi_SLOT01, TypeST>, Enc_11065510, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b10101011011;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerf";
let BaseOpcode = "S2_storerf_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerft_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32),
"if ($Pv4) memh($Rs32) = $Rt32.h",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S2_pstorerftnew_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_1Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4.new) memh($Rx32++#$Ii) = $Rt32.h",
ST_tc_st_pi_SLOT01, TypeST>, Enc_11065510, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b10101011011;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerf";
let BaseOpcode = "S2_storerf_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerhf_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u31_1Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4) memh($Rs32+#$Ii) = $Rt32",
V2LDST_tc_st_SLOT01, TypeV2LDST>, Enc_10979813, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{31-21} = 0b01000100010;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let InputType = "imm";
let BaseOpcode = "S2_storerh_io";
let isNVStorable = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
}
def S2_pstorerhf_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_1Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4) memh($Rx32++#$Ii) = $Rt32",
ST_tc_st_pi_SLOT01, TypeST>, Enc_11065510, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b10101011010;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayStore = 1;
let BaseOpcode = "S2_storerh_pi";
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerhf_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32),
"if (!$Pv4) memh($Rs32) = $Rt32",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S2_pstorerhfnew_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_1Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4.new) memh($Rx32++#$Ii) = $Rt32",
ST_tc_st_pi_SLOT01, TypeST>, Enc_11065510, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b10101011010;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let BaseOpcode = "S2_storerh_pi";
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerhnewf_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u31_1Imm:$Ii, IntRegs:$Nt8),
"if (!$Pv4) memh($Rs32+#$Ii) = $Nt8.new",
V2LDST_tc_st_SLOT0, TypeV2LDST>, Enc_6154421, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{12-11} = 0b01;
let Inst{31-21} = 0b01000100101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storerh";
let InputType = "imm";
let BaseOpcode = "S2_storerh_io";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
let opNewValue = 3;
}
def S2_pstorerhnewf_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_1Imm:$Ii, IntRegs:$Nt8),
"if (!$Pv4) memh($Rx32++#$Ii) = $Nt8.new",
ST_tc_st_pi_SLOT0, TypeST>, Enc_3813442, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b0;
let Inst{13-11} = 0b101;
let Inst{31-21} = 0b10101011101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storerh";
let BaseOpcode = "S2_storerh_pi";
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerhnewf_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Nt8),
"if (!$Pv4) memh($Rs32) = $Nt8.new",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let opNewValue = 2;
}
def S2_pstorerhnewfnew_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_1Imm:$Ii, IntRegs:$Nt8),
"if (!$Pv4.new) memh($Rx32++#$Ii) = $Nt8.new",
ST_tc_st_pi_SLOT0, TypeST>, Enc_3813442, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b1;
let Inst{13-11} = 0b101;
let Inst{31-21} = 0b10101011101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let isPredicatedNew = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storerh";
let BaseOpcode = "S2_storerh_pi";
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerhnewt_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u31_1Imm:$Ii, IntRegs:$Nt8),
"if ($Pv4) memh($Rs32+#$Ii) = $Nt8.new",
V2LDST_tc_st_SLOT0, TypeV2LDST>, Enc_6154421, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{12-11} = 0b01;
let Inst{31-21} = 0b01000000101;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storerh";
let InputType = "imm";
let BaseOpcode = "S2_storerh_io";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
let opNewValue = 3;
}
def S2_pstorerhnewt_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_1Imm:$Ii, IntRegs:$Nt8),
"if ($Pv4) memh($Rx32++#$Ii) = $Nt8.new",
ST_tc_st_pi_SLOT0, TypeST>, Enc_3813442, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b0;
let Inst{13-11} = 0b101;
let Inst{31-21} = 0b10101011101;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storerh";
let BaseOpcode = "S2_storerh_pi";
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerhnewt_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Nt8),
"if ($Pv4) memh($Rs32) = $Nt8.new",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let opNewValue = 2;
}
def S2_pstorerhnewtnew_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_1Imm:$Ii, IntRegs:$Nt8),
"if ($Pv4.new) memh($Rx32++#$Ii) = $Nt8.new",
ST_tc_st_pi_SLOT0, TypeST>, Enc_3813442, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b1;
let Inst{13-11} = 0b101;
let Inst{31-21} = 0b10101011101;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let isPredicatedNew = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storerh";
let BaseOpcode = "S2_storerh_pi";
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerht_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u31_1Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4) memh($Rs32+#$Ii) = $Rt32",
V2LDST_tc_st_SLOT01, TypeV2LDST>, Enc_10979813, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{31-21} = 0b01000000010;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let InputType = "imm";
let BaseOpcode = "S2_storerh_io";
let isNVStorable = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
}
def S2_pstorerht_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_1Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4) memh($Rx32++#$Ii) = $Rt32",
ST_tc_st_pi_SLOT01, TypeST>, Enc_11065510, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b10101011010;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayStore = 1;
let BaseOpcode = "S2_storerh_pi";
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerht_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32),
"if ($Pv4) memh($Rs32) = $Rt32",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S2_pstorerhtnew_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_1Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4.new) memh($Rx32++#$Ii) = $Rt32",
ST_tc_st_pi_SLOT01, TypeST>, Enc_11065510, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b10101011010;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let BaseOpcode = "S2_storerh_pi";
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerif_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u30_2Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4) memw($Rs32+#$Ii) = $Rt32",
V2LDST_tc_st_SLOT01, TypeV2LDST>, Enc_8225953, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{31-21} = 0b01000100100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let InputType = "imm";
let BaseOpcode = "S2_storeri_io";
let isNVStorable = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 2;
}
def S2_pstorerif_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_2Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4) memw($Rx32++#$Ii) = $Rt32",
ST_tc_st_pi_SLOT01, TypeST>, Enc_10065510, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b10101011100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = WordAccess;
let mayStore = 1;
let BaseOpcode = "S2_storeri_pi";
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerif_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32),
"if (!$Pv4) memw($Rs32) = $Rt32",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S2_pstorerifnew_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_2Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4.new) memw($Rx32++#$Ii) = $Rt32",
ST_tc_st_pi_SLOT01, TypeST>, Enc_10065510, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b10101011100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = WordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let BaseOpcode = "S2_storeri_pi";
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerinewf_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u30_2Imm:$Ii, IntRegs:$Nt8),
"if (!$Pv4) memw($Rs32+#$Ii) = $Nt8.new",
V2LDST_tc_st_SLOT0, TypeV2LDST>, Enc_11224149, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{12-11} = 0b10;
let Inst{31-21} = 0b01000100101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storeri";
let InputType = "imm";
let BaseOpcode = "S2_storeri_io";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 2;
let opNewValue = 3;
}
def S2_pstorerinewf_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_2Imm:$Ii, IntRegs:$Nt8),
"if (!$Pv4) memw($Rx32++#$Ii) = $Nt8.new",
ST_tc_st_pi_SLOT0, TypeST>, Enc_4813442, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b0;
let Inst{13-11} = 0b110;
let Inst{31-21} = 0b10101011101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = WordAccess;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storeri";
let BaseOpcode = "S2_storeri_pi";
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerinewf_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Nt8),
"if (!$Pv4) memw($Rs32) = $Nt8.new",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let opNewValue = 2;
}
def S2_pstorerinewfnew_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_2Imm:$Ii, IntRegs:$Nt8),
"if (!$Pv4.new) memw($Rx32++#$Ii) = $Nt8.new",
ST_tc_st_pi_SLOT0, TypeST>, Enc_4813442, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b1;
let Inst{13-11} = 0b110;
let Inst{31-21} = 0b10101011101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = WordAccess;
let isNVStore = 1;
let isPredicatedNew = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storeri";
let BaseOpcode = "S2_storeri_pi";
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerinewt_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u30_2Imm:$Ii, IntRegs:$Nt8),
"if ($Pv4) memw($Rs32+#$Ii) = $Nt8.new",
V2LDST_tc_st_SLOT0, TypeV2LDST>, Enc_11224149, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{12-11} = 0b10;
let Inst{31-21} = 0b01000000101;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storeri";
let InputType = "imm";
let BaseOpcode = "S2_storeri_io";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 2;
let opNewValue = 3;
}
def S2_pstorerinewt_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_2Imm:$Ii, IntRegs:$Nt8),
"if ($Pv4) memw($Rx32++#$Ii) = $Nt8.new",
ST_tc_st_pi_SLOT0, TypeST>, Enc_4813442, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b0;
let Inst{13-11} = 0b110;
let Inst{31-21} = 0b10101011101;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = WordAccess;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storeri";
let BaseOpcode = "S2_storeri_pi";
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerinewt_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Nt8),
"if ($Pv4) memw($Rs32) = $Nt8.new",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let opNewValue = 2;
}
def S2_pstorerinewtnew_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_2Imm:$Ii, IntRegs:$Nt8),
"if ($Pv4.new) memw($Rx32++#$Ii) = $Nt8.new",
ST_tc_st_pi_SLOT0, TypeST>, Enc_4813442, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b1;
let Inst{13-11} = 0b110;
let Inst{31-21} = 0b10101011101;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = WordAccess;
let isNVStore = 1;
let isPredicatedNew = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storeri";
let BaseOpcode = "S2_storeri_pi";
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerit_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u30_2Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4) memw($Rs32+#$Ii) = $Rt32",
V2LDST_tc_st_SLOT01, TypeV2LDST>, Enc_8225953, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{31-21} = 0b01000000100;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let InputType = "imm";
let BaseOpcode = "S2_storeri_io";
let isNVStorable = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 2;
}
def S2_pstorerit_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_2Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4) memw($Rx32++#$Ii) = $Rt32",
ST_tc_st_pi_SLOT01, TypeST>, Enc_10065510, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b10101011100;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = WordAccess;
let mayStore = 1;
let BaseOpcode = "S2_storeri_pi";
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerit_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32),
"if ($Pv4) memw($Rs32) = $Rt32",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S2_pstoreritnew_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_2Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4.new) memw($Rx32++#$Ii) = $Rt32",
ST_tc_st_pi_SLOT01, TypeST>, Enc_10065510, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b10101011100;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = WordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let BaseOpcode = "S2_storeri_pi";
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_setbit_i : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rd32 = setbit($Rs32,#$Ii)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_2771456 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001100110;
let hasNewValue = 1;
let opNewValue = 0;
}
def S2_setbit_r : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = setbit($Rs32,$Rt32)",
S_3op_tc_1_SLOT23, TypeS_3op>, Enc_14071773 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000110100;
let hasNewValue = 1;
let opNewValue = 0;
}
def S2_shuffeb : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = shuffeb($Rss32,$Rtt32)",
S_3op_tc_1_SLOT23, TypeS_3op>, Enc_8333157 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000001000;
}
def S2_shuffeh : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = shuffeh($Rss32,$Rtt32)",
S_3op_tc_1_SLOT23, TypeS_3op>, Enc_8333157 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000001000;
}
def S2_shuffob : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = shuffob($Rtt32,$Rss32)",
S_3op_tc_1_SLOT23, TypeS_3op>, Enc_11687333 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000001000;
}
def S2_shuffoh : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = shuffoh($Rtt32,$Rss32)",
S_3op_tc_1_SLOT23, TypeS_3op>, Enc_11687333 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000001100;
}
def S2_storerb_io : HInst<
(outs),
(ins IntRegs:$Rs32, s32_0Imm:$Ii, IntRegs:$Rt32),
"memb($Rs32+#$Ii) = $Rt32",
ST_tc_st_SLOT01, TypeST>, Enc_13150110, AddrModeRel {
let Inst{24-21} = 0b1000;
let Inst{31-27} = 0b10100;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let InputType = "imm";
let BaseOpcode = "S2_storerb_io";
let isPredicable = 1;
let isNVStorable = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 0;
}
def S2_storerb_pbr : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, IntRegs:$Rt32),
"memb($Rx32++$Mu2:brev) = $Rt32",
ST_tc_st_SLOT01, TypeST>, Enc_7255914, AddrModeRel {
let Inst{7-0} = 0b00000000;
let Inst{31-21} = 0b10101111000;
let accessSize = ByteAccess;
let mayStore = 1;
let BaseOpcode = "S2_storerb_pbr";
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerb_pci : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_0Imm:$Ii, ModRegs:$Mu2, IntRegs:$Rt32),
"memb($Rx32++#$Ii:circ($Mu2)) = $Rt32",
ST_tc_st_SLOT01, TypeST>, Enc_3915770 {
let Inst{2-0} = 0b000;
let Inst{7-7} = 0b0;
let Inst{31-21} = 0b10101001000;
let addrMode = PostInc;
let accessSize = ByteAccess;
let mayStore = 1;
let Uses = [CS];
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerb_pcr : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, IntRegs:$Rt32),
"memb($Rx32++I:circ($Mu2)) = $Rt32",
ST_tc_st_SLOT01, TypeST>, Enc_7255914 {
let Inst{7-0} = 0b00000010;
let Inst{31-21} = 0b10101001000;
let addrMode = PostInc;
let accessSize = ByteAccess;
let mayStore = 1;
let Uses = [CS];
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerb_pi : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_0Imm:$Ii, IntRegs:$Rt32),
"memb($Rx32++#$Ii) = $Rt32",
ST_tc_st_pi_SLOT01, TypeST>, Enc_12492533, AddrModeRel {
let Inst{2-0} = 0b000;
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10101011000;
let addrMode = PostInc;
let accessSize = ByteAccess;
let mayStore = 1;
let BaseOpcode = "S2_storerb_pi";
let isPredicable = 1;
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerb_pr : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, IntRegs:$Rt32),
"memb($Rx32++$Mu2) = $Rt32",
ST_tc_st_SLOT01, TypeST>, Enc_7255914 {
let Inst{7-0} = 0b00000000;
let Inst{31-21} = 0b10101101000;
let addrMode = PostInc;
let accessSize = ByteAccess;
let mayStore = 1;
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerb_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"memb($Rs32) = $Rt32",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S2_storerbgp : HInst<
(outs),
(ins u32_0Imm:$Ii, IntRegs:$Rt32),
"memb(gp+#$Ii) = $Rt32",
V2LDST_tc_st_SLOT01, TypeV2LDST>, Enc_12395768, AddrModeRel {
let Inst{24-21} = 0b0000;
let Inst{31-27} = 0b01001;
let accessSize = ByteAccess;
let mayStore = 1;
let Uses = [GP];
let BaseOpcode = "S2_storerbabs";
let isPredicable = 1;
let isNVStorable = 1;
let opExtendable = 0;
let isExtentSigned = 0;
let opExtentBits = 16;
let opExtentAlign = 0;
}
def S2_storerbnew_io : HInst<
(outs),
(ins IntRegs:$Rs32, s32_0Imm:$Ii, IntRegs:$Nt8),
"memb($Rs32+#$Ii) = $Nt8.new",
ST_tc_st_SLOT0, TypeST>, Enc_10002182, AddrModeRel {
let Inst{12-11} = 0b00;
let Inst{24-21} = 0b1101;
let Inst{31-27} = 0b10100;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storerb";
let InputType = "imm";
let BaseOpcode = "S2_storerb_io";
let isPredicable = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 0;
let opNewValue = 2;
}
def S2_storerbnew_pbr : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, IntRegs:$Nt8),
"memb($Rx32++$Mu2:brev) = $Nt8.new",
NCJ_tc_3or4stall_SLOT0, TypeST>, Enc_10067774, AddrModeRel {
let Inst{7-0} = 0b00000000;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b10101111101;
let accessSize = ByteAccess;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let BaseOpcode = "S2_storerb_pbr";
let opNewValue = 3;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerbnew_pci : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_0Imm:$Ii, ModRegs:$Mu2, IntRegs:$Nt8),
"memb($Rx32++#$Ii:circ($Mu2)) = $Nt8.new",
NCJ_tc_3or4stall_SLOT0, TypeST>, Enc_5326450 {
let Inst{2-0} = 0b000;
let Inst{7-7} = 0b0;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b10101001101;
let addrMode = PostInc;
let accessSize = ByteAccess;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let Uses = [CS];
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerbnew_pcr : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, IntRegs:$Nt8),
"memb($Rx32++I:circ($Mu2)) = $Nt8.new",
NCJ_tc_3or4stall_SLOT0, TypeST>, Enc_10067774 {
let Inst{7-0} = 0b00000010;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b10101001101;
let addrMode = PostInc;
let accessSize = ByteAccess;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let Uses = [CS];
let opNewValue = 3;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerbnew_pi : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_0Imm:$Ii, IntRegs:$Nt8),
"memb($Rx32++#$Ii) = $Nt8.new",
ST_tc_st_pi_SLOT0, TypeST>, Enc_5900401, AddrModeRel {
let Inst{2-0} = 0b000;
let Inst{7-7} = 0b0;
let Inst{13-11} = 0b000;
let Inst{31-21} = 0b10101011101;
let addrMode = PostInc;
let accessSize = ByteAccess;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let BaseOpcode = "S2_storerb_pi";
let isPredicable = 1;
let isNVStorable = 1;
let opNewValue = 3;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerbnew_pr : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, IntRegs:$Nt8),
"memb($Rx32++$Mu2) = $Nt8.new",
ST_tc_st_SLOT0, TypeST>, Enc_10067774 {
let Inst{7-0} = 0b00000000;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b10101101101;
let addrMode = PostInc;
let accessSize = ByteAccess;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let opNewValue = 3;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerbnew_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Nt8),
"memb($Rs32) = $Nt8.new",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let opNewValue = 1;
}
def S2_storerbnewgp : HInst<
(outs),
(ins u32_0Imm:$Ii, IntRegs:$Nt8),
"memb(gp+#$Ii) = $Nt8.new",
V2LDST_tc_st_SLOT0, TypeV2LDST>, Enc_4050532, AddrModeRel {
let Inst{12-11} = 0b00;
let Inst{24-21} = 0b0101;
let Inst{31-27} = 0b01001;
let accessSize = ByteAccess;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let Uses = [GP];
let BaseOpcode = "S2_storerbabs";
let isPredicable = 1;
let opExtendable = 0;
let isExtentSigned = 0;
let opExtentBits = 16;
let opExtentAlign = 0;
let opNewValue = 1;
}
def S2_storerd_io : HInst<
(outs),
(ins IntRegs:$Rs32, s29_3Imm:$Ii, DoubleRegs:$Rtt32),
"memd($Rs32+#$Ii) = $Rtt32",
ST_tc_st_SLOT01, TypeST>, Enc_16319737, AddrModeRel {
let Inst{24-21} = 0b1110;
let Inst{31-27} = 0b10100;
let addrMode = BaseImmOffset;
let accessSize = DoubleWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerd";
let InputType = "imm";
let BaseOpcode = "S2_storerd_io";
let isPredicable = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 14;
let opExtentAlign = 3;
}
def S2_storerd_pbr : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, DoubleRegs:$Rtt32),
"memd($Rx32++$Mu2:brev) = $Rtt32",
ST_tc_st_SLOT01, TypeST>, Enc_15816255 {
let Inst{7-0} = 0b00000000;
let Inst{31-21} = 0b10101111110;
let accessSize = DoubleWordAccess;
let mayStore = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerd_pci : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_3Imm:$Ii, ModRegs:$Mu2, DoubleRegs:$Rtt32),
"memd($Rx32++#$Ii:circ($Mu2)) = $Rtt32",
ST_tc_st_SLOT01, TypeST>, Enc_4501395 {
let Inst{2-0} = 0b000;
let Inst{7-7} = 0b0;
let Inst{31-21} = 0b10101001110;
let addrMode = PostInc;
let accessSize = DoubleWordAccess;
let mayStore = 1;
let Uses = [CS];
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerd_pcr : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, DoubleRegs:$Rtt32),
"memd($Rx32++I:circ($Mu2)) = $Rtt32",
ST_tc_st_SLOT01, TypeST>, Enc_15816255 {
let Inst{7-0} = 0b00000010;
let Inst{31-21} = 0b10101001110;
let addrMode = PostInc;
let accessSize = DoubleWordAccess;
let mayStore = 1;
let Uses = [CS];
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerd_pi : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_3Imm:$Ii, DoubleRegs:$Rtt32),
"memd($Rx32++#$Ii) = $Rtt32",
ST_tc_st_pi_SLOT01, TypeST>, Enc_11271630, AddrModeRel {
let Inst{2-0} = 0b000;
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10101011110;
let addrMode = PostInc;
let accessSize = DoubleWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerd";
let BaseOpcode = "S2_storerd_pi";
let isPredicable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerd_pr : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, DoubleRegs:$Rtt32),
"memd($Rx32++$Mu2) = $Rtt32",
ST_tc_st_SLOT01, TypeST>, Enc_15816255 {
let Inst{7-0} = 0b00000000;
let Inst{31-21} = 0b10101101110;
let addrMode = PostInc;
let accessSize = DoubleWordAccess;
let mayStore = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerd_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, DoubleRegs:$Rtt32),
"memd($Rs32) = $Rtt32",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S2_storerdgp : HInst<
(outs),
(ins u29_3Imm:$Ii, DoubleRegs:$Rtt32),
"memd(gp+#$Ii) = $Rtt32",
V2LDST_tc_st_SLOT01, TypeV2LDST>, Enc_11682941, AddrModeRel {
let Inst{24-21} = 0b0110;
let Inst{31-27} = 0b01001;
let accessSize = DoubleWordAccess;
let mayStore = 1;
let Uses = [GP];
let BaseOpcode = "S2_storerdabs";
let isPredicable = 1;
let opExtendable = 0;
let isExtentSigned = 0;
let opExtentBits = 19;
let opExtentAlign = 3;
}
def S2_storerf_io : HInst<
(outs),
(ins IntRegs:$Rs32, s31_1Imm:$Ii, IntRegs:$Rt32),
"memh($Rs32+#$Ii) = $Rt32.h",
ST_tc_st_SLOT01, TypeST>, Enc_7736768, AddrModeRel {
let Inst{24-21} = 0b1011;
let Inst{31-27} = 0b10100;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerf";
let InputType = "imm";
let BaseOpcode = "S2_storerf_io";
let isPredicable = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 12;
let opExtentAlign = 1;
}
def S2_storerf_pbr : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, IntRegs:$Rt32),
"memh($Rx32++$Mu2:brev) = $Rt32.h",
ST_tc_st_SLOT01, TypeST>, Enc_7255914 {
let Inst{7-0} = 0b00000000;
let Inst{31-21} = 0b10101111011;
let accessSize = HalfWordAccess;
let mayStore = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerf_pci : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_1Imm:$Ii, ModRegs:$Mu2, IntRegs:$Rt32),
"memh($Rx32++#$Ii:circ($Mu2)) = $Rt32.h",
ST_tc_st_SLOT01, TypeST>, Enc_10915758 {
let Inst{2-0} = 0b000;
let Inst{7-7} = 0b0;
let Inst{31-21} = 0b10101001011;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayStore = 1;
let Uses = [CS];
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerf_pcr : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, IntRegs:$Rt32),
"memh($Rx32++I:circ($Mu2)) = $Rt32.h",
ST_tc_st_SLOT01, TypeST>, Enc_7255914 {
let Inst{7-0} = 0b00000010;
let Inst{31-21} = 0b10101001011;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayStore = 1;
let Uses = [CS];
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerf_pi : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_1Imm:$Ii, IntRegs:$Rt32),
"memh($Rx32++#$Ii) = $Rt32.h",
ST_tc_st_pi_SLOT01, TypeST>, Enc_11492529, AddrModeRel {
let Inst{2-0} = 0b000;
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10101011011;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerf";
let BaseOpcode = "S2_storerf_pi";
let isPredicable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerf_pr : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, IntRegs:$Rt32),
"memh($Rx32++$Mu2) = $Rt32.h",
ST_tc_st_SLOT01, TypeST>, Enc_7255914 {
let Inst{7-0} = 0b00000000;
let Inst{31-21} = 0b10101101011;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayStore = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerf_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"memh($Rs32) = $Rt32.h",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S2_storerfgp : HInst<
(outs),
(ins u31_1Imm:$Ii, IntRegs:$Rt32),
"memh(gp+#$Ii) = $Rt32.h",
V2LDST_tc_st_SLOT01, TypeV2LDST>, Enc_1186018, AddrModeRel {
let Inst{24-21} = 0b0011;
let Inst{31-27} = 0b01001;
let accessSize = HalfWordAccess;
let mayStore = 1;
let Uses = [GP];
let BaseOpcode = "S2_storerfabs";
let isPredicable = 1;
let opExtendable = 0;
let isExtentSigned = 0;
let opExtentBits = 17;
let opExtentAlign = 1;
}
def S2_storerh_io : HInst<
(outs),
(ins IntRegs:$Rs32, s31_1Imm:$Ii, IntRegs:$Rt32),
"memh($Rs32+#$Ii) = $Rt32",
ST_tc_st_SLOT01, TypeST>, Enc_7736768, AddrModeRel {
let Inst{24-21} = 0b1010;
let Inst{31-27} = 0b10100;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let InputType = "imm";
let BaseOpcode = "S2_storerh_io";
let isPredicable = 1;
let isNVStorable = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 12;
let opExtentAlign = 1;
}
def S2_storerh_pbr : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, IntRegs:$Rt32),
"memh($Rx32++$Mu2:brev) = $Rt32",
ST_tc_st_SLOT01, TypeST>, Enc_7255914, AddrModeRel {
let Inst{7-0} = 0b00000000;
let Inst{31-21} = 0b10101111010;
let accessSize = HalfWordAccess;
let mayStore = 1;
let BaseOpcode = "S2_storerh_pbr";
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerh_pci : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_1Imm:$Ii, ModRegs:$Mu2, IntRegs:$Rt32),
"memh($Rx32++#$Ii:circ($Mu2)) = $Rt32",
ST_tc_st_SLOT01, TypeST>, Enc_10915758 {
let Inst{2-0} = 0b000;
let Inst{7-7} = 0b0;
let Inst{31-21} = 0b10101001010;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayStore = 1;
let Uses = [CS];
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerh_pcr : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, IntRegs:$Rt32),
"memh($Rx32++I:circ($Mu2)) = $Rt32",
ST_tc_st_SLOT01, TypeST>, Enc_7255914 {
let Inst{7-0} = 0b00000010;
let Inst{31-21} = 0b10101001010;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayStore = 1;
let Uses = [CS];
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerh_pi : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_1Imm:$Ii, IntRegs:$Rt32),
"memh($Rx32++#$Ii) = $Rt32",
ST_tc_st_pi_SLOT01, TypeST>, Enc_11492529, AddrModeRel {
let Inst{2-0} = 0b000;
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10101011010;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayStore = 1;
let BaseOpcode = "S2_storerh_pi";
let isPredicable = 1;
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerh_pr : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, IntRegs:$Rt32),
"memh($Rx32++$Mu2) = $Rt32",
ST_tc_st_SLOT01, TypeST>, Enc_7255914 {
let Inst{7-0} = 0b00000000;
let Inst{31-21} = 0b10101101010;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayStore = 1;
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerh_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"memh($Rs32) = $Rt32",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S2_storerhgp : HInst<
(outs),
(ins u31_1Imm:$Ii, IntRegs:$Rt32),
"memh(gp+#$Ii) = $Rt32",
V2LDST_tc_st_SLOT01, TypeV2LDST>, Enc_1186018, AddrModeRel {
let Inst{24-21} = 0b0010;
let Inst{31-27} = 0b01001;
let accessSize = HalfWordAccess;
let mayStore = 1;
let Uses = [GP];
let BaseOpcode = "S2_storerhabs";
let isPredicable = 1;
let isNVStorable = 1;
let opExtendable = 0;
let isExtentSigned = 0;
let opExtentBits = 17;
let opExtentAlign = 1;
}
def S2_storerhnew_io : HInst<
(outs),
(ins IntRegs:$Rs32, s31_1Imm:$Ii, IntRegs:$Nt8),
"memh($Rs32+#$Ii) = $Nt8.new",
ST_tc_st_SLOT0, TypeST>, Enc_748676, AddrModeRel {
let Inst{12-11} = 0b01;
let Inst{24-21} = 0b1101;
let Inst{31-27} = 0b10100;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storerh";
let InputType = "imm";
let BaseOpcode = "S2_storerh_io";
let isPredicable = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 12;
let opExtentAlign = 1;
let opNewValue = 2;
}
def S2_storerhnew_pbr : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, IntRegs:$Nt8),
"memh($Rx32++$Mu2:brev) = $Nt8.new",
NCJ_tc_3or4stall_SLOT0, TypeST>, Enc_10067774, AddrModeRel {
let Inst{7-0} = 0b00000000;
let Inst{12-11} = 0b01;
let Inst{31-21} = 0b10101111101;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let BaseOpcode = "S2_storerh_pbr";
let opNewValue = 3;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerhnew_pci : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_1Imm:$Ii, ModRegs:$Mu2, IntRegs:$Nt8),
"memh($Rx32++#$Ii:circ($Mu2)) = $Nt8.new",
NCJ_tc_3or4stall_SLOT0, TypeST>, Enc_10326434 {
let Inst{2-0} = 0b000;
let Inst{7-7} = 0b0;
let Inst{12-11} = 0b01;
let Inst{31-21} = 0b10101001101;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let Uses = [CS];
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerhnew_pcr : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, IntRegs:$Nt8),
"memh($Rx32++I:circ($Mu2)) = $Nt8.new",
NCJ_tc_3or4stall_SLOT0, TypeST>, Enc_10067774 {
let Inst{7-0} = 0b00000010;
let Inst{12-11} = 0b01;
let Inst{31-21} = 0b10101001101;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let Uses = [CS];
let opNewValue = 3;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerhnew_pi : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_1Imm:$Ii, IntRegs:$Nt8),
"memh($Rx32++#$Ii) = $Nt8.new",
ST_tc_st_pi_SLOT0, TypeST>, Enc_6900405, AddrModeRel {
let Inst{2-0} = 0b000;
let Inst{7-7} = 0b0;
let Inst{13-11} = 0b001;
let Inst{31-21} = 0b10101011101;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let BaseOpcode = "S2_storerh_pi";
let isNVStorable = 1;
let isPredicable = 1;
let opNewValue = 3;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerhnew_pr : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, IntRegs:$Nt8),
"memh($Rx32++$Mu2) = $Nt8.new",
ST_tc_st_SLOT0, TypeST>, Enc_10067774 {
let Inst{7-0} = 0b00000000;
let Inst{12-11} = 0b01;
let Inst{31-21} = 0b10101101101;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let opNewValue = 3;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerhnew_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Nt8),
"memh($Rs32) = $Nt8.new",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let opNewValue = 1;
}
def S2_storerhnewgp : HInst<
(outs),
(ins u31_1Imm:$Ii, IntRegs:$Nt8),
"memh(gp+#$Ii) = $Nt8.new",
V2LDST_tc_st_SLOT0, TypeV2LDST>, Enc_13618890, AddrModeRel {
let Inst{12-11} = 0b01;
let Inst{24-21} = 0b0101;
let Inst{31-27} = 0b01001;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let Uses = [GP];
let BaseOpcode = "S2_storerhabs";
let isPredicable = 1;
let opExtendable = 0;
let isExtentSigned = 0;
let opExtentBits = 17;
let opExtentAlign = 1;
let opNewValue = 1;
}
def S2_storeri_io : HInst<
(outs),
(ins IntRegs:$Rs32, s30_2Imm:$Ii, IntRegs:$Rt32),
"memw($Rs32+#$Ii) = $Rt32",
ST_tc_st_SLOT01, TypeST>, Enc_6673186, AddrModeRel {
let Inst{24-21} = 0b1100;
let Inst{31-27} = 0b10100;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let InputType = "imm";
let BaseOpcode = "S2_storeri_io";
let isPredicable = 1;
let isNVStorable = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 13;
let opExtentAlign = 2;
}
def S2_storeri_pbr : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, IntRegs:$Rt32),
"memw($Rx32++$Mu2:brev) = $Rt32",
ST_tc_st_SLOT01, TypeST>, Enc_7255914, AddrModeRel {
let Inst{7-0} = 0b00000000;
let Inst{31-21} = 0b10101111100;
let accessSize = WordAccess;
let mayStore = 1;
let BaseOpcode = "S2_storeri_pbr";
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storeri_pci : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_2Imm:$Ii, ModRegs:$Mu2, IntRegs:$Rt32),
"memw($Rx32++#$Ii:circ($Mu2)) = $Rt32",
ST_tc_st_SLOT01, TypeST>, Enc_9915754 {
let Inst{2-0} = 0b000;
let Inst{7-7} = 0b0;
let Inst{31-21} = 0b10101001100;
let addrMode = PostInc;
let accessSize = WordAccess;
let mayStore = 1;
let Uses = [CS];
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storeri_pcr : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, IntRegs:$Rt32),
"memw($Rx32++I:circ($Mu2)) = $Rt32",
ST_tc_st_SLOT01, TypeST>, Enc_7255914 {
let Inst{7-0} = 0b00000010;
let Inst{31-21} = 0b10101001100;
let addrMode = PostInc;
let accessSize = WordAccess;
let mayStore = 1;
let Uses = [CS];
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storeri_pi : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_2Imm:$Ii, IntRegs:$Rt32),
"memw($Rx32++#$Ii) = $Rt32",
ST_tc_st_pi_SLOT01, TypeST>, Enc_10492541, AddrModeRel {
let Inst{2-0} = 0b000;
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10101011100;
let addrMode = PostInc;
let accessSize = WordAccess;
let mayStore = 1;
let BaseOpcode = "S2_storeri_pi";
let isPredicable = 1;
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storeri_pr : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, IntRegs:$Rt32),
"memw($Rx32++$Mu2) = $Rt32",
ST_tc_st_SLOT01, TypeST>, Enc_7255914 {
let Inst{7-0} = 0b00000000;
let Inst{31-21} = 0b10101101100;
let addrMode = PostInc;
let accessSize = WordAccess;
let mayStore = 1;
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storeri_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"memw($Rs32) = $Rt32",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S2_storerigp : HInst<
(outs),
(ins u30_2Imm:$Ii, IntRegs:$Rt32),
"memw(gp+#$Ii) = $Rt32",
V2LDST_tc_st_SLOT01, TypeV2LDST>, Enc_15999208, AddrModeRel {
let Inst{24-21} = 0b0100;
let Inst{31-27} = 0b01001;
let accessSize = WordAccess;
let mayStore = 1;
let Uses = [GP];
let BaseOpcode = "S2_storeriabs";
let isPredicable = 1;
let isNVStorable = 1;
let opExtendable = 0;
let isExtentSigned = 0;
let opExtentBits = 18;
let opExtentAlign = 2;
}
def S2_storerinew_io : HInst<
(outs),
(ins IntRegs:$Rs32, s30_2Imm:$Ii, IntRegs:$Nt8),
"memw($Rs32+#$Ii) = $Nt8.new",
ST_tc_st_SLOT0, TypeST>, Enc_8409782, AddrModeRel {
let Inst{12-11} = 0b10;
let Inst{24-21} = 0b1101;
let Inst{31-27} = 0b10100;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storeri";
let InputType = "imm";
let BaseOpcode = "S2_storeri_io";
let isPredicable = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 13;
let opExtentAlign = 2;
let opNewValue = 2;
}
def S2_storerinew_pbr : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, IntRegs:$Nt8),
"memw($Rx32++$Mu2:brev) = $Nt8.new",
NCJ_tc_3or4stall_SLOT0, TypeST>, Enc_10067774, AddrModeRel {
let Inst{7-0} = 0b00000000;
let Inst{12-11} = 0b10;
let Inst{31-21} = 0b10101111101;
let accessSize = WordAccess;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let BaseOpcode = "S2_storeri_pbr";
let opNewValue = 3;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerinew_pci : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_2Imm:$Ii, ModRegs:$Mu2, IntRegs:$Nt8),
"memw($Rx32++#$Ii:circ($Mu2)) = $Nt8.new",
NCJ_tc_3or4stall_SLOT0, TypeST>, Enc_11326438 {
let Inst{2-0} = 0b000;
let Inst{7-7} = 0b0;
let Inst{12-11} = 0b10;
let Inst{31-21} = 0b10101001101;
let addrMode = PostInc;
let accessSize = WordAccess;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let Uses = [CS];
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerinew_pcr : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, IntRegs:$Nt8),
"memw($Rx32++I:circ($Mu2)) = $Nt8.new",
NCJ_tc_3or4stall_SLOT0, TypeST>, Enc_10067774 {
let Inst{7-0} = 0b00000010;
let Inst{12-11} = 0b10;
let Inst{31-21} = 0b10101001101;
let addrMode = PostInc;
let accessSize = WordAccess;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let Uses = [CS];
let opNewValue = 3;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerinew_pi : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_2Imm:$Ii, IntRegs:$Nt8),
"memw($Rx32++#$Ii) = $Nt8.new",
ST_tc_st_pi_SLOT0, TypeST>, Enc_7900405, AddrModeRel {
let Inst{2-0} = 0b000;
let Inst{7-7} = 0b0;
let Inst{13-11} = 0b010;
let Inst{31-21} = 0b10101011101;
let addrMode = PostInc;
let accessSize = WordAccess;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let BaseOpcode = "S2_storeri_pi";
let isPredicable = 1;
let opNewValue = 3;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerinew_pr : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, IntRegs:$Nt8),
"memw($Rx32++$Mu2) = $Nt8.new",
ST_tc_st_SLOT0, TypeST>, Enc_10067774 {
let Inst{7-0} = 0b00000000;
let Inst{12-11} = 0b10;
let Inst{31-21} = 0b10101101101;
let addrMode = PostInc;
let accessSize = WordAccess;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let opNewValue = 3;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerinew_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Nt8),
"memw($Rs32) = $Nt8.new",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let opNewValue = 1;
}
def S2_storerinewgp : HInst<
(outs),
(ins u30_2Imm:$Ii, IntRegs:$Nt8),
"memw(gp+#$Ii) = $Nt8.new",
V2LDST_tc_st_SLOT0, TypeV2LDST>, Enc_12297800, AddrModeRel {
let Inst{12-11} = 0b10;
let Inst{24-21} = 0b0101;
let Inst{31-27} = 0b01001;
let accessSize = WordAccess;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let Uses = [GP];
let BaseOpcode = "S2_storeriabs";
let isPredicable = 1;
let opExtendable = 0;
let isExtentSigned = 0;
let opExtentBits = 18;
let opExtentAlign = 2;
let opNewValue = 1;
}
def S2_storew_locked : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"memw_locked($Rs32,$Pd4) = $Rt32",
ST_tc_ld_SLOT0, TypeST>, Enc_10157519 {
let Inst{7-2} = 0b000000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10100000101;
let accessSize = WordAccess;
let isSoloAX = 1;
let mayStore = 1;
let isPredicateLate = 1;
}
def S2_svsathb : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = vsathb($Rs32)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_4075554 {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b10001100100;
let hasNewValue = 1;
let opNewValue = 0;
let Defs = [USR_OVF];
}
def S2_svsathub : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = vsathub($Rs32)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_4075554 {
let Inst{13-5} = 0b000000010;
let Inst{31-21} = 0b10001100100;
let hasNewValue = 1;
let opNewValue = 0;
let Defs = [USR_OVF];
}
def S2_tableidxb : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u4_0Imm:$Ii, s6_0Imm:$II),
"$Rx32 = tableidxb($Rs32,#$Ii,#$II):raw",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_8838398 {
let Inst{31-22} = 0b1000011100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_tableidxb_goodsyntax : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u4_0Imm:$Ii, u5_0Imm:$II),
"$Rx32 = tableidxb($Rs32,#$Ii,#$II)",
S_2op_tc_1_SLOT23, TypeS_2op> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_tableidxd : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u4_0Imm:$Ii, s6_0Imm:$II),
"$Rx32 = tableidxd($Rs32,#$Ii,#$II):raw",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_8838398 {
let Inst{31-22} = 0b1000011111;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_tableidxd_goodsyntax : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u4_0Imm:$Ii, u5_0Imm:$II),
"$Rx32 = tableidxd($Rs32,#$Ii,#$II)",
S_2op_tc_1_SLOT23, TypeS_2op> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_tableidxh : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u4_0Imm:$Ii, s6_0Imm:$II),
"$Rx32 = tableidxh($Rs32,#$Ii,#$II):raw",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_8838398 {
let Inst{31-22} = 0b1000011101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_tableidxh_goodsyntax : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u4_0Imm:$Ii, u5_0Imm:$II),
"$Rx32 = tableidxh($Rs32,#$Ii,#$II)",
S_2op_tc_1_SLOT23, TypeS_2op> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_tableidxw : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u4_0Imm:$Ii, s6_0Imm:$II),
"$Rx32 = tableidxw($Rs32,#$Ii,#$II):raw",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_8838398 {
let Inst{31-22} = 0b1000011110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_tableidxw_goodsyntax : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u4_0Imm:$Ii, u5_0Imm:$II),
"$Rx32 = tableidxw($Rs32,#$Ii,#$II)",
S_2op_tc_1_SLOT23, TypeS_2op> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_togglebit_i : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rd32 = togglebit($Rs32,#$Ii)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_2771456 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001100110;
let hasNewValue = 1;
let opNewValue = 0;
}
def S2_togglebit_r : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = togglebit($Rs32,$Rt32)",
S_3op_tc_1_SLOT23, TypeS_3op>, Enc_14071773 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000110100;
let hasNewValue = 1;
let opNewValue = 0;
}
def S2_tstbit_i : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, u5_0Imm:$Ii),
"$Pd4 = tstbit($Rs32,#$Ii)",
S_2op_tc_2early_SLOT23, TypeS_2op>, Enc_2103742 {
let Inst{7-2} = 0b000000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10000101000;
}
def S2_tstbit_r : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Pd4 = tstbit($Rs32,$Rt32)",
S_3op_tc_2early_SLOT23, TypeS_3op>, Enc_10157519 {
let Inst{7-2} = 0b000000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000111000;
}
def S2_valignib : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32, u3_0Imm:$Ii),
"$Rdd32 = valignb($Rtt32,$Rss32,#$Ii)",
S_3op_tc_1_SLOT23, TypeS_3op>, Enc_11971407 {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000000000;
}
def S2_valignrb : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32, PredRegs:$Pu4),
"$Rdd32 = valignb($Rtt32,$Rss32,$Pu4)",
S_3op_tc_1_SLOT23, TypeS_3op>, Enc_11552785 {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000010000;
}
def S2_vcnegh : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rdd32 = vcnegh($Rss32,$Rt32)",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_8940892 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000011110;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def S2_vcrotate : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rdd32 = vcrotate($Rss32,$Rt32)",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_8940892 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000011110;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def S2_vrcnegh : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rxx32 += vrcnegh($Rss32,$Rt32)",
S_3op_tc_3x_SLOT23, TypeS_3op>, Enc_7912540 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b11001011001;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_vrndpackwh : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32),
"$Rd32 = vrndwh($Rss32)",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_3742184 {
let Inst{13-5} = 0b000000100;
let Inst{31-21} = 0b10001000100;
let hasNewValue = 1;
let opNewValue = 0;
}
def S2_vrndpackwhs : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32),
"$Rd32 = vrndwh($Rss32):sat",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_3742184 {
let Inst{13-5} = 0b000000110;
let Inst{31-21} = 0b10001000100;
let hasNewValue = 1;
let opNewValue = 0;
let Defs = [USR_OVF];
}
def S2_vsathb : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32),
"$Rd32 = vsathb($Rss32)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_3742184 {
let Inst{13-5} = 0b000000110;
let Inst{31-21} = 0b10001000000;
let hasNewValue = 1;
let opNewValue = 0;
let Defs = [USR_OVF];
}
def S2_vsathb_nopack : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32),
"$Rdd32 = vsathb($Rss32)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_13133231 {
let Inst{13-5} = 0b000000111;
let Inst{31-21} = 0b10000000000;
let Defs = [USR_OVF];
}
def S2_vsathub : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32),
"$Rd32 = vsathub($Rss32)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_3742184 {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b10001000000;
let hasNewValue = 1;
let opNewValue = 0;
let Defs = [USR_OVF];
}
def S2_vsathub_nopack : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32),
"$Rdd32 = vsathub($Rss32)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_13133231 {
let Inst{13-5} = 0b000000100;
let Inst{31-21} = 0b10000000000;
let Defs = [USR_OVF];
}
def S2_vsatwh : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32),
"$Rd32 = vsatwh($Rss32)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_3742184 {
let Inst{13-5} = 0b000000010;
let Inst{31-21} = 0b10001000000;
let hasNewValue = 1;
let opNewValue = 0;
let Defs = [USR_OVF];
}
def S2_vsatwh_nopack : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32),
"$Rdd32 = vsatwh($Rss32)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_13133231 {
let Inst{13-5} = 0b000000110;
let Inst{31-21} = 0b10000000000;
let Defs = [USR_OVF];
}
def S2_vsatwuh : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32),
"$Rd32 = vsatwuh($Rss32)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_3742184 {
let Inst{13-5} = 0b000000100;
let Inst{31-21} = 0b10001000000;
let hasNewValue = 1;
let opNewValue = 0;
let Defs = [USR_OVF];
}
def S2_vsatwuh_nopack : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32),
"$Rdd32 = vsatwuh($Rss32)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_13133231 {
let Inst{13-5} = 0b000000101;
let Inst{31-21} = 0b10000000000;
let Defs = [USR_OVF];
}
def S2_vsplatrb : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = vsplatb($Rs32)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_4075554 {
let Inst{13-5} = 0b000000111;
let Inst{31-21} = 0b10001100010;
let hasNewValue = 1;
let opNewValue = 0;
let isReMaterializable = 1;
let isAsCheapAsAMove = 1;
}
def S2_vsplatrh : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32),
"$Rdd32 = vsplath($Rs32)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_4030179 {
let Inst{13-5} = 0b000000010;
let Inst{31-21} = 0b10000100010;
let isReMaterializable = 1;
let isAsCheapAsAMove = 1;
}
def S2_vspliceib : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32, u3_0Imm:$Ii),
"$Rdd32 = vspliceb($Rss32,$Rtt32,#$Ii)",
S_3op_tc_1_SLOT23, TypeS_3op>, Enc_16730127 {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000000100;
}
def S2_vsplicerb : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32, PredRegs:$Pu4),
"$Rdd32 = vspliceb($Rss32,$Rtt32,$Pu4)",
S_3op_tc_1_SLOT23, TypeS_3op>, Enc_5178985 {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000010100;
}
def S2_vsxtbh : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32),
"$Rdd32 = vsxtbh($Rs32)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_4030179 {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b10000100000;
let isReMaterializable = 1;
let isAsCheapAsAMove = 1;
}
def S2_vsxthw : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32),
"$Rdd32 = vsxthw($Rs32)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_4030179 {
let Inst{13-5} = 0b000000100;
let Inst{31-21} = 0b10000100000;
let isReMaterializable = 1;
let isAsCheapAsAMove = 1;
}
def S2_vtrunehb : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32),
"$Rd32 = vtrunehb($Rss32)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_3742184 {
let Inst{13-5} = 0b000000010;
let Inst{31-21} = 0b10001000100;
let hasNewValue = 1;
let opNewValue = 0;
}
def S2_vtrunewh : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vtrunewh($Rss32,$Rtt32)",
S_3op_tc_1_SLOT23, TypeS_3op>, Enc_8333157 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000001100;
}
def S2_vtrunohb : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32),
"$Rd32 = vtrunohb($Rss32)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_3742184 {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b10001000100;
let hasNewValue = 1;
let opNewValue = 0;
}
def S2_vtrunowh : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vtrunowh($Rss32,$Rtt32)",
S_3op_tc_1_SLOT23, TypeS_3op>, Enc_8333157 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000001100;
}
def S2_vzxtbh : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32),
"$Rdd32 = vzxtbh($Rs32)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_4030179 {
let Inst{13-5} = 0b000000010;
let Inst{31-21} = 0b10000100000;
let isReMaterializable = 1;
let isAsCheapAsAMove = 1;
}
def S2_vzxthw : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32),
"$Rdd32 = vzxthw($Rs32)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_4030179 {
let Inst{13-5} = 0b000000110;
let Inst{31-21} = 0b10000100000;
let isReMaterializable = 1;
let isAsCheapAsAMove = 1;
}
def S4_addaddi : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Ru32, s32_0Imm:$Ii),
"$Rd32 = add($Rs32,add($Ru32,#$Ii))",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_6495334 {
let Inst{31-23} = 0b110110110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 1;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_addi_asl_ri : HInst<
(outs IntRegs:$Rx32),
(ins u32_0Imm:$Ii, IntRegs:$Rx32in, u5_0Imm:$II),
"$Rx32 = add(#$Ii,asl($Rx32in,#$II))",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_117962 {
let Inst{2-0} = 0b100;
let Inst{4-4} = 0b0;
let Inst{31-24} = 0b11011110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 0;
let Constraints = "$Rx32 = $Rx32in";
}
def S4_addi_lsr_ri : HInst<
(outs IntRegs:$Rx32),
(ins u32_0Imm:$Ii, IntRegs:$Rx32in, u5_0Imm:$II),
"$Rx32 = add(#$Ii,lsr($Rx32in,#$II))",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_117962 {
let Inst{2-0} = 0b100;
let Inst{4-4} = 0b1;
let Inst{31-24} = 0b11011110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 0;
let Constraints = "$Rx32 = $Rx32in";
}
def S4_andi_asl_ri : HInst<
(outs IntRegs:$Rx32),
(ins u32_0Imm:$Ii, IntRegs:$Rx32in, u5_0Imm:$II),
"$Rx32 = and(#$Ii,asl($Rx32in,#$II))",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_117962 {
let Inst{2-0} = 0b000;
let Inst{4-4} = 0b0;
let Inst{31-24} = 0b11011110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 0;
let Constraints = "$Rx32 = $Rx32in";
}
def S4_andi_lsr_ri : HInst<
(outs IntRegs:$Rx32),
(ins u32_0Imm:$Ii, IntRegs:$Rx32in, u5_0Imm:$II),
"$Rx32 = and(#$Ii,lsr($Rx32in,#$II))",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_117962 {
let Inst{2-0} = 0b000;
let Inst{4-4} = 0b1;
let Inst{31-24} = 0b11011110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 0;
let Constraints = "$Rx32 = $Rx32in";
}
def S4_clbaddi : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, s6_0Imm:$Ii),
"$Rd32 = add(clb($Rs32),#$Ii)",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_5523416 {
let Inst{7-5} = 0b000;
let Inst{31-21} = 0b10001100001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def S4_clbpaddi : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32, s6_0Imm:$Ii),
"$Rd32 = add(clb($Rss32),#$Ii)",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_10188026 {
let Inst{7-5} = 0b010;
let Inst{31-21} = 0b10001000011;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def S4_clbpnorm : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32),
"$Rd32 = normamt($Rss32)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_3742184 {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b10001000011;
let hasNewValue = 1;
let opNewValue = 0;
}
def S4_extract : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, u5_0Imm:$Ii, u5_0Imm:$II),
"$Rd32 = extract($Rs32,#$Ii,#$II)",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_11930928 {
let Inst{13-13} = 0b0;
let Inst{31-23} = 0b100011011;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def S4_extract_rp : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, DoubleRegs:$Rtt32),
"$Rd32 = extract($Rs32,$Rtt32)",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_15472748 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001001000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def S4_extractp : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, u6_0Imm:$Ii, u6_0Imm:$II),
"$Rdd32 = extract($Rss32,#$Ii,#$II)",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_9894557 {
let Inst{31-24} = 0b10001010;
let prefersSlot3 = 1;
}
def S4_extractp_rp : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = extract($Rss32,$Rtt32)",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_8333157 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000001110;
let prefersSlot3 = 1;
}
def S4_lsli : HInst<
(outs IntRegs:$Rd32),
(ins s6_0Imm:$Ii, IntRegs:$Rt32),
"$Rd32 = lsl(#$Ii,$Rt32)",
S_3op_tc_1_SLOT23, TypeS_3op>, Enc_518319 {
let Inst{7-6} = 0b11;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000110100;
let hasNewValue = 1;
let opNewValue = 0;
}
def S4_ntstbit_i : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, u5_0Imm:$Ii),
"$Pd4 = !tstbit($Rs32,#$Ii)",
S_2op_tc_2early_SLOT23, TypeS_2op>, Enc_2103742 {
let Inst{7-2} = 0b000000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10000101001;
}
def S4_ntstbit_r : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Pd4 = !tstbit($Rs32,$Rt32)",
S_3op_tc_2early_SLOT23, TypeS_3op>, Enc_10157519 {
let Inst{7-2} = 0b000000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000111001;
}
def S4_or_andi : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, s32_0Imm:$Ii),
"$Rx32 |= and($Rs32,#$Ii)",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_6356866 {
let Inst{31-22} = 0b1101101000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let InputType = "imm";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 1;
let opExtentBits = 10;
let opExtentAlign = 0;
let Constraints = "$Rx32 = $Rx32in";
}
def S4_or_andix : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Ru32, IntRegs:$Rx32in, s32_0Imm:$Ii),
"$Rx32 = or($Ru32,and($Rx32in,#$Ii))",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_7504828 {
let Inst{31-22} = 0b1101101001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 1;
let opExtentBits = 10;
let opExtentAlign = 0;
let Constraints = "$Rx32 = $Rx32in";
}
def S4_or_ori : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, s32_0Imm:$Ii),
"$Rx32 |= or($Rs32,#$Ii)",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_6356866 {
let Inst{31-22} = 0b1101101010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let InputType = "imm";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 1;
let opExtentBits = 10;
let opExtentAlign = 0;
let Constraints = "$Rx32 = $Rx32in";
}
def S4_ori_asl_ri : HInst<
(outs IntRegs:$Rx32),
(ins u32_0Imm:$Ii, IntRegs:$Rx32in, u5_0Imm:$II),
"$Rx32 = or(#$Ii,asl($Rx32in,#$II))",
ALU64_tc_1_SLOT23, TypeALU64>, Enc_117962 {
let Inst{2-0} = 0b010;
let Inst{4-4} = 0b0;
let Inst{31-24} = 0b11011110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 0;
let Constraints = "$Rx32 = $Rx32in";
}
def S4_ori_lsr_ri : HInst<
(outs IntRegs:$Rx32),
(ins u32_0Imm:$Ii, IntRegs:$Rx32in, u5_0Imm:$II),
"$Rx32 = or(#$Ii,lsr($Rx32in,#$II))",
ALU64_tc_1_SLOT23, TypeALU64>, Enc_117962 {
let Inst{2-0} = 0b010;
let Inst{4-4} = 0b1;
let Inst{31-24} = 0b11011110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 0;
let Constraints = "$Rx32 = $Rx32in";
}
def S4_parity : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = parity($Rs32,$Rt32)",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_14071773 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101111;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def S4_pstorerbf_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4) memb(#$Ii) = $Rt32",
ST_tc_st_SLOT01, TypeST>, Enc_16657398, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b0;
let Inst{31-18} = 0b10101111000000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = Absolute;
let accessSize = ByteAccess;
let isExtended = 1;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let BaseOpcode = "S2_storerbabs";
let isNVStorable = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_pstorerbf_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4) memb($Rs32+$Ru32<<#$Ii) = $Rt32",
V4LDST_tc_st_SLOT01, TypeST>, Enc_11940513, AddrModeRel {
let Inst{31-21} = 0b00110101000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseRegOffset;
let accessSize = ByteAccess;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let InputType = "reg";
let BaseOpcode = "S4_storerb_rr";
let isNVStorable = 1;
}
def S4_pstorerbfnew_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4.new) memb(#$Ii) = $Rt32",
ST_tc_st_SLOT01, TypeST>, Enc_16657398, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-18} = 0b10101111000000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = Absolute;
let accessSize = ByteAccess;
let isExtended = 1;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let BaseOpcode = "S2_storerbabs";
let isNVStorable = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_pstorerbfnew_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u32_0Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4.new) memb($Rs32+#$Ii) = $Rt32",
V2LDST_tc_st_SLOT01, TypeV2LDST>, Enc_14044877, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{31-21} = 0b01000110000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let InputType = "imm";
let BaseOpcode = "S2_storerb_io";
let isNVStorable = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_pstorerbfnew_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4.new) memb($Rs32+$Ru32<<#$Ii) = $Rt32",
V4LDST_tc_st_SLOT01, TypeST>, Enc_11940513, AddrModeRel {
let Inst{31-21} = 0b00110111000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseRegOffset;
let accessSize = ByteAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let InputType = "reg";
let BaseOpcode = "S4_storerb_rr";
let isNVStorable = 1;
}
def S4_pstorerbfnew_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32),
"if (!$Pv4.new) memb($Rs32) = $Rt32",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S4_pstorerbnewf_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Nt8),
"if (!$Pv4) memb(#$Ii) = $Nt8.new",
NCJ_tc_3or4stall_SLOT0, TypeST>, Enc_1774350, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b1;
let Inst{13-11} = 0b000;
let Inst{31-18} = 0b10101111101000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = Absolute;
let accessSize = ByteAccess;
let isNVStore = 1;
let isExtended = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storerb";
let BaseOpcode = "S2_storerbabs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let opNewValue = 2;
}
def S4_pstorerbnewf_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Nt8),
"if (!$Pv4) memb($Rs32+$Ru32<<#$Ii) = $Nt8.new",
V4LDST_tc_st_SLOT0, TypeST>, Enc_11000933, AddrModeRel {
let Inst{4-3} = 0b00;
let Inst{31-21} = 0b00110101101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseRegOffset;
let accessSize = ByteAccess;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storerb";
let InputType = "reg";
let BaseOpcode = "S4_storerb_rr";
let opNewValue = 4;
}
def S4_pstorerbnewfnew_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Nt8),
"if (!$Pv4.new) memb(#$Ii) = $Nt8.new",
NCJ_tc_3or4stall_SLOT0, TypeST>, Enc_1774350, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b1;
let Inst{13-11} = 0b100;
let Inst{31-18} = 0b10101111101000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = Absolute;
let accessSize = ByteAccess;
let isNVStore = 1;
let isExtended = 1;
let isPredicatedNew = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storerb";
let BaseOpcode = "S2_storerbabs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let opNewValue = 2;
}
def S4_pstorerbnewfnew_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u32_0Imm:$Ii, IntRegs:$Nt8),
"if (!$Pv4.new) memb($Rs32+#$Ii) = $Nt8.new",
V2LDST_tc_st_SLOT0, TypeV2LDST>, Enc_1737833, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b01000110101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let isNVStore = 1;
let isPredicatedNew = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storerb";
let InputType = "imm";
let BaseOpcode = "S2_storerb_io";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let opNewValue = 3;
}
def S4_pstorerbnewfnew_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Nt8),
"if (!$Pv4.new) memb($Rs32+$Ru32<<#$Ii) = $Nt8.new",
V4LDST_tc_st_SLOT0, TypeST>, Enc_11000933, AddrModeRel {
let Inst{4-3} = 0b00;
let Inst{31-21} = 0b00110111101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseRegOffset;
let accessSize = ByteAccess;
let isNVStore = 1;
let isPredicatedNew = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storerb";
let InputType = "reg";
let BaseOpcode = "S4_storerb_rr";
let opNewValue = 4;
}
def S4_pstorerbnewfnew_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Nt8),
"if (!$Pv4.new) memb($Rs32) = $Nt8.new",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let opNewValue = 2;
}
def S4_pstorerbnewt_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Nt8),
"if ($Pv4) memb(#$Ii) = $Nt8.new",
NCJ_tc_3or4stall_SLOT0, TypeST>, Enc_1774350, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b1;
let Inst{13-11} = 0b000;
let Inst{31-18} = 0b10101111101000;
let isPredicated = 1;
let addrMode = Absolute;
let accessSize = ByteAccess;
let isNVStore = 1;
let isExtended = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storerb";
let BaseOpcode = "S2_storerbabs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let opNewValue = 2;
}
def S4_pstorerbnewt_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Nt8),
"if ($Pv4) memb($Rs32+$Ru32<<#$Ii) = $Nt8.new",
V4LDST_tc_st_SLOT0, TypeST>, Enc_11000933, AddrModeRel {
let Inst{4-3} = 0b00;
let Inst{31-21} = 0b00110100101;
let isPredicated = 1;
let addrMode = BaseRegOffset;
let accessSize = ByteAccess;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storerb";
let InputType = "reg";
let BaseOpcode = "S4_storerb_rr";
let opNewValue = 4;
}
def S4_pstorerbnewtnew_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Nt8),
"if ($Pv4.new) memb(#$Ii) = $Nt8.new",
NCJ_tc_3or4stall_SLOT0, TypeST>, Enc_1774350, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b1;
let Inst{13-11} = 0b100;
let Inst{31-18} = 0b10101111101000;
let isPredicated = 1;
let addrMode = Absolute;
let accessSize = ByteAccess;
let isNVStore = 1;
let isExtended = 1;
let isPredicatedNew = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storerb";
let BaseOpcode = "S2_storerbabs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let opNewValue = 2;
}
def S4_pstorerbnewtnew_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u32_0Imm:$Ii, IntRegs:$Nt8),
"if ($Pv4.new) memb($Rs32+#$Ii) = $Nt8.new",
V2LDST_tc_st_SLOT0, TypeV2LDST>, Enc_1737833, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b01000010101;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let isNVStore = 1;
let isPredicatedNew = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storerb";
let InputType = "imm";
let BaseOpcode = "S2_storerb_io";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let opNewValue = 3;
}
def S4_pstorerbnewtnew_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Nt8),
"if ($Pv4.new) memb($Rs32+$Ru32<<#$Ii) = $Nt8.new",
V4LDST_tc_st_SLOT0, TypeST>, Enc_11000933, AddrModeRel {
let Inst{4-3} = 0b00;
let Inst{31-21} = 0b00110110101;
let isPredicated = 1;
let addrMode = BaseRegOffset;
let accessSize = ByteAccess;
let isNVStore = 1;
let isPredicatedNew = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storerb";
let InputType = "reg";
let BaseOpcode = "S4_storerb_rr";
let opNewValue = 4;
}
def S4_pstorerbnewtnew_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Nt8),
"if ($Pv4.new) memb($Rs32) = $Nt8.new",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let opNewValue = 2;
}
def S4_pstorerbt_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4) memb(#$Ii) = $Rt32",
ST_tc_st_SLOT01, TypeST>, Enc_16657398, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b0;
let Inst{31-18} = 0b10101111000000;
let isPredicated = 1;
let addrMode = Absolute;
let accessSize = ByteAccess;
let isExtended = 1;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let BaseOpcode = "S2_storerbabs";
let isNVStorable = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_pstorerbt_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4) memb($Rs32+$Ru32<<#$Ii) = $Rt32",
V4LDST_tc_st_SLOT01, TypeST>, Enc_11940513, AddrModeRel {
let Inst{31-21} = 0b00110100000;
let isPredicated = 1;
let addrMode = BaseRegOffset;
let accessSize = ByteAccess;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let InputType = "reg";
let BaseOpcode = "S4_storerb_rr";
let isNVStorable = 1;
}
def S4_pstorerbtnew_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4.new) memb(#$Ii) = $Rt32",
ST_tc_st_SLOT01, TypeST>, Enc_16657398, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-18} = 0b10101111000000;
let isPredicated = 1;
let addrMode = Absolute;
let accessSize = ByteAccess;
let isExtended = 1;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let BaseOpcode = "S2_storerbabs";
let isNVStorable = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_pstorerbtnew_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u32_0Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4.new) memb($Rs32+#$Ii) = $Rt32",
V2LDST_tc_st_SLOT01, TypeV2LDST>, Enc_14044877, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{31-21} = 0b01000010000;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let InputType = "imm";
let BaseOpcode = "S2_storerb_io";
let isNVStorable = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_pstorerbtnew_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4.new) memb($Rs32+$Ru32<<#$Ii) = $Rt32",
V4LDST_tc_st_SLOT01, TypeST>, Enc_11940513, AddrModeRel {
let Inst{31-21} = 0b00110110000;
let isPredicated = 1;
let addrMode = BaseRegOffset;
let accessSize = ByteAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let InputType = "reg";
let BaseOpcode = "S4_storerb_rr";
let isNVStorable = 1;
}
def S4_pstorerbtnew_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32),
"if ($Pv4.new) memb($Rs32) = $Rt32",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S4_pstorerdf_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, DoubleRegs:$Rtt32),
"if (!$Pv4) memd(#$Ii) = $Rtt32",
ST_tc_st_SLOT01, TypeST>, Enc_13715847, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b0;
let Inst{31-18} = 0b10101111110000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = Absolute;
let accessSize = DoubleWordAccess;
let isExtended = 1;
let mayStore = 1;
let CextOpcode = "S2_storerd";
let BaseOpcode = "S2_storerdabs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_pstorerdf_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, DoubleRegs:$Rtt32),
"if (!$Pv4) memd($Rs32+$Ru32<<#$Ii) = $Rtt32",
V4LDST_tc_st_SLOT01, TypeST>, Enc_9920336, AddrModeRel {
let Inst{31-21} = 0b00110101110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseRegOffset;
let accessSize = DoubleWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerd";
let InputType = "reg";
let BaseOpcode = "S2_storerd_rr";
}
def S4_pstorerdfnew_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, DoubleRegs:$Rtt32),
"if (!$Pv4.new) memd(#$Ii) = $Rtt32",
ST_tc_st_SLOT01, TypeST>, Enc_13715847, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-18} = 0b10101111110000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = Absolute;
let accessSize = DoubleWordAccess;
let isExtended = 1;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerd";
let BaseOpcode = "S2_storerdabs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_pstorerdfnew_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u29_3Imm:$Ii, DoubleRegs:$Rtt32),
"if (!$Pv4.new) memd($Rs32+#$Ii) = $Rtt32",
V2LDST_tc_st_SLOT01, TypeV2LDST>, Enc_11049656, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{31-21} = 0b01000110110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = DoubleWordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerd";
let InputType = "imm";
let BaseOpcode = "S2_storerd_io";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 9;
let opExtentAlign = 3;
}
def S4_pstorerdfnew_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, DoubleRegs:$Rtt32),
"if (!$Pv4.new) memd($Rs32+$Ru32<<#$Ii) = $Rtt32",
V4LDST_tc_st_SLOT01, TypeST>, Enc_9920336, AddrModeRel {
let Inst{31-21} = 0b00110111110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseRegOffset;
let accessSize = DoubleWordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerd";
let InputType = "reg";
let BaseOpcode = "S2_storerd_rr";
}
def S4_pstorerdfnew_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, DoubleRegs:$Rtt32),
"if (!$Pv4.new) memd($Rs32) = $Rtt32",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S4_pstorerdt_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, DoubleRegs:$Rtt32),
"if ($Pv4) memd(#$Ii) = $Rtt32",
ST_tc_st_SLOT01, TypeST>, Enc_13715847, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b0;
let Inst{31-18} = 0b10101111110000;
let isPredicated = 1;
let addrMode = Absolute;
let accessSize = DoubleWordAccess;
let isExtended = 1;
let mayStore = 1;
let CextOpcode = "S2_storerd";
let BaseOpcode = "S2_storerdabs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_pstorerdt_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, DoubleRegs:$Rtt32),
"if ($Pv4) memd($Rs32+$Ru32<<#$Ii) = $Rtt32",
V4LDST_tc_st_SLOT01, TypeST>, Enc_9920336, AddrModeRel {
let Inst{31-21} = 0b00110100110;
let isPredicated = 1;
let addrMode = BaseRegOffset;
let accessSize = DoubleWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerd";
let InputType = "reg";
let BaseOpcode = "S2_storerd_rr";
}
def S4_pstorerdtnew_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, DoubleRegs:$Rtt32),
"if ($Pv4.new) memd(#$Ii) = $Rtt32",
ST_tc_st_SLOT01, TypeST>, Enc_13715847, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-18} = 0b10101111110000;
let isPredicated = 1;
let addrMode = Absolute;
let accessSize = DoubleWordAccess;
let isExtended = 1;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerd";
let BaseOpcode = "S2_storerdabs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_pstorerdtnew_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u29_3Imm:$Ii, DoubleRegs:$Rtt32),
"if ($Pv4.new) memd($Rs32+#$Ii) = $Rtt32",
V2LDST_tc_st_SLOT01, TypeV2LDST>, Enc_11049656, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{31-21} = 0b01000010110;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = DoubleWordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerd";
let InputType = "imm";
let BaseOpcode = "S2_storerd_io";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 9;
let opExtentAlign = 3;
}
def S4_pstorerdtnew_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, DoubleRegs:$Rtt32),
"if ($Pv4.new) memd($Rs32+$Ru32<<#$Ii) = $Rtt32",
V4LDST_tc_st_SLOT01, TypeST>, Enc_9920336, AddrModeRel {
let Inst{31-21} = 0b00110110110;
let isPredicated = 1;
let addrMode = BaseRegOffset;
let accessSize = DoubleWordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerd";
let InputType = "reg";
let BaseOpcode = "S2_storerd_rr";
}
def S4_pstorerdtnew_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, DoubleRegs:$Rtt32),
"if ($Pv4.new) memd($Rs32) = $Rtt32",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S4_pstorerff_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4) memh(#$Ii) = $Rt32.h",
ST_tc_st_SLOT01, TypeST>, Enc_16657398, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b0;
let Inst{31-18} = 0b10101111011000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = Absolute;
let accessSize = HalfWordAccess;
let isExtended = 1;
let mayStore = 1;
let CextOpcode = "S2_storerf";
let BaseOpcode = "S2_storerfabs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_pstorerff_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4) memh($Rs32+$Ru32<<#$Ii) = $Rt32.h",
V4LDST_tc_st_SLOT01, TypeST>, Enc_11940513, AddrModeRel {
let Inst{31-21} = 0b00110101011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseRegOffset;
let accessSize = HalfWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerf";
let InputType = "reg";
let BaseOpcode = "S4_storerf_rr";
}
def S4_pstorerffnew_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4.new) memh(#$Ii) = $Rt32.h",
ST_tc_st_SLOT01, TypeST>, Enc_16657398, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-18} = 0b10101111011000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = Absolute;
let accessSize = HalfWordAccess;
let isExtended = 1;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerf";
let BaseOpcode = "S2_storerfabs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_pstorerffnew_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u31_1Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4.new) memh($Rs32+#$Ii) = $Rt32.h",
V2LDST_tc_st_SLOT01, TypeV2LDST>, Enc_10979813, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{31-21} = 0b01000110011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerf";
let InputType = "imm";
let BaseOpcode = "S2_storerf_io";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
}
def S4_pstorerffnew_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4.new) memh($Rs32+$Ru32<<#$Ii) = $Rt32.h",
V4LDST_tc_st_SLOT01, TypeST>, Enc_11940513, AddrModeRel {
let Inst{31-21} = 0b00110111011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseRegOffset;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerf";
let InputType = "reg";
let BaseOpcode = "S4_storerf_rr";
}
def S4_pstorerffnew_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32),
"if (!$Pv4.new) memh($Rs32) = $Rt32.h",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S4_pstorerft_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4) memh(#$Ii) = $Rt32.h",
ST_tc_st_SLOT01, TypeST>, Enc_16657398, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b0;
let Inst{31-18} = 0b10101111011000;
let isPredicated = 1;
let addrMode = Absolute;
let accessSize = HalfWordAccess;
let isExtended = 1;
let mayStore = 1;
let CextOpcode = "S2_storerf";
let BaseOpcode = "S2_storerfabs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_pstorerft_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4) memh($Rs32+$Ru32<<#$Ii) = $Rt32.h",
V4LDST_tc_st_SLOT01, TypeST>, Enc_11940513, AddrModeRel {
let Inst{31-21} = 0b00110100011;
let isPredicated = 1;
let addrMode = BaseRegOffset;
let accessSize = HalfWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerf";
let InputType = "reg";
let BaseOpcode = "S4_storerf_rr";
}
def S4_pstorerftnew_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4.new) memh(#$Ii) = $Rt32.h",
ST_tc_st_SLOT01, TypeST>, Enc_16657398, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-18} = 0b10101111011000;
let isPredicated = 1;
let addrMode = Absolute;
let accessSize = HalfWordAccess;
let isExtended = 1;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerf";
let BaseOpcode = "S2_storerfabs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_pstorerftnew_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u31_1Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4.new) memh($Rs32+#$Ii) = $Rt32.h",
V2LDST_tc_st_SLOT01, TypeV2LDST>, Enc_10979813, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{31-21} = 0b01000010011;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerf";
let InputType = "imm";
let BaseOpcode = "S2_storerf_io";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
}
def S4_pstorerftnew_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4.new) memh($Rs32+$Ru32<<#$Ii) = $Rt32.h",
V4LDST_tc_st_SLOT01, TypeST>, Enc_11940513, AddrModeRel {
let Inst{31-21} = 0b00110110011;
let isPredicated = 1;
let addrMode = BaseRegOffset;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerf";
let InputType = "reg";
let BaseOpcode = "S4_storerf_rr";
}
def S4_pstorerftnew_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32),
"if ($Pv4.new) memh($Rs32) = $Rt32.h",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S4_pstorerhf_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4) memh(#$Ii) = $Rt32",
ST_tc_st_SLOT01, TypeST>, Enc_16657398, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b0;
let Inst{31-18} = 0b10101111010000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = Absolute;
let accessSize = HalfWordAccess;
let isExtended = 1;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let BaseOpcode = "S2_storerhabs";
let isNVStorable = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_pstorerhf_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4) memh($Rs32+$Ru32<<#$Ii) = $Rt32",
V4LDST_tc_st_SLOT01, TypeST>, Enc_11940513, AddrModeRel {
let Inst{31-21} = 0b00110101010;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseRegOffset;
let accessSize = HalfWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let InputType = "reg";
let BaseOpcode = "S2_storerh_rr";
let isNVStorable = 1;
}
def S4_pstorerhfnew_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4.new) memh(#$Ii) = $Rt32",
ST_tc_st_SLOT01, TypeST>, Enc_16657398, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-18} = 0b10101111010000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = Absolute;
let accessSize = HalfWordAccess;
let isExtended = 1;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let BaseOpcode = "S2_storerhabs";
let isNVStorable = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_pstorerhfnew_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u31_1Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4.new) memh($Rs32+#$Ii) = $Rt32",
V2LDST_tc_st_SLOT01, TypeV2LDST>, Enc_10979813, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{31-21} = 0b01000110010;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let InputType = "imm";
let BaseOpcode = "S2_storerh_io";
let isNVStorable = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
}
def S4_pstorerhfnew_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4.new) memh($Rs32+$Ru32<<#$Ii) = $Rt32",
V4LDST_tc_st_SLOT01, TypeST>, Enc_11940513, AddrModeRel {
let Inst{31-21} = 0b00110111010;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseRegOffset;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let InputType = "reg";
let BaseOpcode = "S2_storerh_rr";
let isNVStorable = 1;
}
def S4_pstorerhfnew_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32),
"if (!$Pv4.new) memh($Rs32) = $Rt32",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S4_pstorerhnewf_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Nt8),
"if (!$Pv4) memh(#$Ii) = $Nt8.new",
NCJ_tc_3or4stall_SLOT0, TypeST>, Enc_1774350, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b1;
let Inst{13-11} = 0b001;
let Inst{31-18} = 0b10101111101000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = Absolute;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let isExtended = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storerh";
let BaseOpcode = "S2_storerhabs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let opNewValue = 2;
}
def S4_pstorerhnewf_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Nt8),
"if (!$Pv4) memh($Rs32+$Ru32<<#$Ii) = $Nt8.new",
V4LDST_tc_st_SLOT0, TypeST>, Enc_11000933, AddrModeRel {
let Inst{4-3} = 0b01;
let Inst{31-21} = 0b00110101101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseRegOffset;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storerh";
let InputType = "reg";
let BaseOpcode = "S2_storerh_rr";
let opNewValue = 4;
}
def S4_pstorerhnewfnew_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Nt8),
"if (!$Pv4.new) memh(#$Ii) = $Nt8.new",
NCJ_tc_3or4stall_SLOT0, TypeST>, Enc_1774350, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b1;
let Inst{13-11} = 0b101;
let Inst{31-18} = 0b10101111101000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = Absolute;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let isExtended = 1;
let isPredicatedNew = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storerh";
let BaseOpcode = "S2_storerhabs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let opNewValue = 2;
}
def S4_pstorerhnewfnew_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u31_1Imm:$Ii, IntRegs:$Nt8),
"if (!$Pv4.new) memh($Rs32+#$Ii) = $Nt8.new",
V2LDST_tc_st_SLOT0, TypeV2LDST>, Enc_6154421, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{12-11} = 0b01;
let Inst{31-21} = 0b01000110101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let isPredicatedNew = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storerh";
let InputType = "imm";
let BaseOpcode = "S2_storerh_io";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
let opNewValue = 3;
}
def S4_pstorerhnewfnew_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Nt8),
"if (!$Pv4.new) memh($Rs32+$Ru32<<#$Ii) = $Nt8.new",
V4LDST_tc_st_SLOT0, TypeST>, Enc_11000933, AddrModeRel {
let Inst{4-3} = 0b01;
let Inst{31-21} = 0b00110111101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseRegOffset;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let isPredicatedNew = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storerh";
let InputType = "reg";
let BaseOpcode = "S2_storerh_rr";
let opNewValue = 4;
}
def S4_pstorerhnewfnew_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Nt8),
"if (!$Pv4.new) memh($Rs32) = $Nt8.new",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let opNewValue = 2;
}
def S4_pstorerhnewt_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Nt8),
"if ($Pv4) memh(#$Ii) = $Nt8.new",
NCJ_tc_3or4stall_SLOT0, TypeST>, Enc_1774350, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b1;
let Inst{13-11} = 0b001;
let Inst{31-18} = 0b10101111101000;
let isPredicated = 1;
let addrMode = Absolute;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let isExtended = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storerh";
let BaseOpcode = "S2_storerhabs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let opNewValue = 2;
}
def S4_pstorerhnewt_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Nt8),
"if ($Pv4) memh($Rs32+$Ru32<<#$Ii) = $Nt8.new",
V4LDST_tc_st_SLOT0, TypeST>, Enc_11000933, AddrModeRel {
let Inst{4-3} = 0b01;
let Inst{31-21} = 0b00110100101;
let isPredicated = 1;
let addrMode = BaseRegOffset;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storerh";
let InputType = "reg";
let BaseOpcode = "S2_storerh_rr";
let opNewValue = 4;
}
def S4_pstorerhnewtnew_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Nt8),
"if ($Pv4.new) memh(#$Ii) = $Nt8.new",
NCJ_tc_3or4stall_SLOT0, TypeST>, Enc_1774350, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b1;
let Inst{13-11} = 0b101;
let Inst{31-18} = 0b10101111101000;
let isPredicated = 1;
let addrMode = Absolute;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let isExtended = 1;
let isPredicatedNew = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storerh";
let BaseOpcode = "S2_storerhabs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let opNewValue = 2;
}
def S4_pstorerhnewtnew_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u31_1Imm:$Ii, IntRegs:$Nt8),
"if ($Pv4.new) memh($Rs32+#$Ii) = $Nt8.new",
V2LDST_tc_st_SLOT0, TypeV2LDST>, Enc_6154421, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{12-11} = 0b01;
let Inst{31-21} = 0b01000010101;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let isPredicatedNew = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storerh";
let InputType = "imm";
let BaseOpcode = "S2_storerh_io";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
let opNewValue = 3;
}
def S4_pstorerhnewtnew_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Nt8),
"if ($Pv4.new) memh($Rs32+$Ru32<<#$Ii) = $Nt8.new",
V4LDST_tc_st_SLOT0, TypeST>, Enc_11000933, AddrModeRel {
let Inst{4-3} = 0b01;
let Inst{31-21} = 0b00110110101;
let isPredicated = 1;
let addrMode = BaseRegOffset;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let isPredicatedNew = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storerh";
let InputType = "reg";
let BaseOpcode = "S2_storerh_rr";
let opNewValue = 4;
}
def S4_pstorerhnewtnew_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Nt8),
"if ($Pv4.new) memh($Rs32) = $Nt8.new",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let opNewValue = 2;
}
def S4_pstorerht_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4) memh(#$Ii) = $Rt32",
ST_tc_st_SLOT01, TypeST>, Enc_16657398, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b0;
let Inst{31-18} = 0b10101111010000;
let isPredicated = 1;
let addrMode = Absolute;
let accessSize = HalfWordAccess;
let isExtended = 1;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let BaseOpcode = "S2_storerhabs";
let isNVStorable = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_pstorerht_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4) memh($Rs32+$Ru32<<#$Ii) = $Rt32",
V4LDST_tc_st_SLOT01, TypeST>, Enc_11940513, AddrModeRel {
let Inst{31-21} = 0b00110100010;
let isPredicated = 1;
let addrMode = BaseRegOffset;
let accessSize = HalfWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let InputType = "reg";
let BaseOpcode = "S2_storerh_rr";
let isNVStorable = 1;
}
def S4_pstorerhtnew_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4.new) memh(#$Ii) = $Rt32",
ST_tc_st_SLOT01, TypeST>, Enc_16657398, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-18} = 0b10101111010000;
let isPredicated = 1;
let addrMode = Absolute;
let accessSize = HalfWordAccess;
let isExtended = 1;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let BaseOpcode = "S2_storerhabs";
let isNVStorable = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_pstorerhtnew_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u31_1Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4.new) memh($Rs32+#$Ii) = $Rt32",
V2LDST_tc_st_SLOT01, TypeV2LDST>, Enc_10979813, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{31-21} = 0b01000010010;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let InputType = "imm";
let BaseOpcode = "S2_storerh_io";
let isNVStorable = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
}
def S4_pstorerhtnew_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4.new) memh($Rs32+$Ru32<<#$Ii) = $Rt32",
V4LDST_tc_st_SLOT01, TypeST>, Enc_11940513, AddrModeRel {
let Inst{31-21} = 0b00110110010;
let isPredicated = 1;
let addrMode = BaseRegOffset;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let InputType = "reg";
let BaseOpcode = "S2_storerh_rr";
let isNVStorable = 1;
}
def S4_pstorerhtnew_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32),
"if ($Pv4.new) memh($Rs32) = $Rt32",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S4_pstorerif_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4) memw(#$Ii) = $Rt32",
ST_tc_st_SLOT01, TypeST>, Enc_16657398, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b0;
let Inst{31-18} = 0b10101111100000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = Absolute;
let accessSize = WordAccess;
let isExtended = 1;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let BaseOpcode = "S2_storeriabs";
let isNVStorable = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_pstorerif_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4) memw($Rs32+$Ru32<<#$Ii) = $Rt32",
V4LDST_tc_st_SLOT01, TypeST>, Enc_11940513, AddrModeRel {
let Inst{31-21} = 0b00110101100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseRegOffset;
let accessSize = WordAccess;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let InputType = "reg";
let BaseOpcode = "S2_storeri_rr";
let isNVStorable = 1;
}
def S4_pstorerifnew_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4.new) memw(#$Ii) = $Rt32",
ST_tc_st_SLOT01, TypeST>, Enc_16657398, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-18} = 0b10101111100000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = Absolute;
let accessSize = WordAccess;
let isExtended = 1;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let BaseOpcode = "S2_storeriabs";
let isNVStorable = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_pstorerifnew_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u30_2Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4.new) memw($Rs32+#$Ii) = $Rt32",
V2LDST_tc_st_SLOT01, TypeV2LDST>, Enc_8225953, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{31-21} = 0b01000110100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let InputType = "imm";
let BaseOpcode = "S2_storeri_io";
let isNVStorable = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 2;
}
def S4_pstorerifnew_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4.new) memw($Rs32+$Ru32<<#$Ii) = $Rt32",
V4LDST_tc_st_SLOT01, TypeST>, Enc_11940513, AddrModeRel {
let Inst{31-21} = 0b00110111100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseRegOffset;
let accessSize = WordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let InputType = "reg";
let BaseOpcode = "S2_storeri_rr";
let isNVStorable = 1;
}
def S4_pstorerifnew_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32),
"if (!$Pv4.new) memw($Rs32) = $Rt32",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S4_pstorerinewf_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Nt8),
"if (!$Pv4) memw(#$Ii) = $Nt8.new",
NCJ_tc_3or4stall_SLOT0, TypeST>, Enc_1774350, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b1;
let Inst{13-11} = 0b010;
let Inst{31-18} = 0b10101111101000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = Absolute;
let accessSize = WordAccess;
let isNVStore = 1;
let isExtended = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storeri";
let BaseOpcode = "S2_storeriabs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let opNewValue = 2;
}
def S4_pstorerinewf_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Nt8),
"if (!$Pv4) memw($Rs32+$Ru32<<#$Ii) = $Nt8.new",
V4LDST_tc_st_SLOT0, TypeST>, Enc_11000933, AddrModeRel {
let Inst{4-3} = 0b10;
let Inst{31-21} = 0b00110101101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseRegOffset;
let accessSize = WordAccess;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storeri";
let InputType = "reg";
let BaseOpcode = "S2_storeri_rr";
let opNewValue = 4;
}
def S4_pstorerinewfnew_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Nt8),
"if (!$Pv4.new) memw(#$Ii) = $Nt8.new",
NCJ_tc_3or4stall_SLOT0, TypeST>, Enc_1774350, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b1;
let Inst{13-11} = 0b110;
let Inst{31-18} = 0b10101111101000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = Absolute;
let accessSize = WordAccess;
let isNVStore = 1;
let isExtended = 1;
let isPredicatedNew = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storeri";
let BaseOpcode = "S2_storeriabs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let opNewValue = 2;
}
def S4_pstorerinewfnew_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u30_2Imm:$Ii, IntRegs:$Nt8),
"if (!$Pv4.new) memw($Rs32+#$Ii) = $Nt8.new",
V2LDST_tc_st_SLOT0, TypeV2LDST>, Enc_11224149, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{12-11} = 0b10;
let Inst{31-21} = 0b01000110101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let isNVStore = 1;
let isPredicatedNew = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storeri";
let InputType = "imm";
let BaseOpcode = "S2_storeri_io";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 2;
let opNewValue = 3;
}
def S4_pstorerinewfnew_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Nt8),
"if (!$Pv4.new) memw($Rs32+$Ru32<<#$Ii) = $Nt8.new",
V4LDST_tc_st_SLOT0, TypeST>, Enc_11000933, AddrModeRel {
let Inst{4-3} = 0b10;
let Inst{31-21} = 0b00110111101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseRegOffset;
let accessSize = WordAccess;
let isNVStore = 1;
let isPredicatedNew = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storeri";
let InputType = "reg";
let BaseOpcode = "S2_storeri_rr";
let opNewValue = 4;
}
def S4_pstorerinewfnew_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Nt8),
"if (!$Pv4.new) memw($Rs32) = $Nt8.new",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let opNewValue = 2;
}
def S4_pstorerinewt_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Nt8),
"if ($Pv4) memw(#$Ii) = $Nt8.new",
NCJ_tc_3or4stall_SLOT0, TypeST>, Enc_1774350, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b1;
let Inst{13-11} = 0b010;
let Inst{31-18} = 0b10101111101000;
let isPredicated = 1;
let addrMode = Absolute;
let accessSize = WordAccess;
let isNVStore = 1;
let isExtended = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storeri";
let BaseOpcode = "S2_storeriabs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let opNewValue = 2;
}
def S4_pstorerinewt_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Nt8),
"if ($Pv4) memw($Rs32+$Ru32<<#$Ii) = $Nt8.new",
V4LDST_tc_st_SLOT0, TypeST>, Enc_11000933, AddrModeRel {
let Inst{4-3} = 0b10;
let Inst{31-21} = 0b00110100101;
let isPredicated = 1;
let addrMode = BaseRegOffset;
let accessSize = WordAccess;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storeri";
let InputType = "reg";
let BaseOpcode = "S2_storeri_rr";
let opNewValue = 4;
}
def S4_pstorerinewtnew_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Nt8),
"if ($Pv4.new) memw(#$Ii) = $Nt8.new",
NCJ_tc_3or4stall_SLOT0, TypeST>, Enc_1774350, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b1;
let Inst{13-11} = 0b110;
let Inst{31-18} = 0b10101111101000;
let isPredicated = 1;
let addrMode = Absolute;
let accessSize = WordAccess;
let isNVStore = 1;
let isExtended = 1;
let isPredicatedNew = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storeri";
let BaseOpcode = "S2_storeriabs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let opNewValue = 2;
}
def S4_pstorerinewtnew_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u30_2Imm:$Ii, IntRegs:$Nt8),
"if ($Pv4.new) memw($Rs32+#$Ii) = $Nt8.new",
V2LDST_tc_st_SLOT0, TypeV2LDST>, Enc_11224149, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{12-11} = 0b10;
let Inst{31-21} = 0b01000010101;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let isNVStore = 1;
let isPredicatedNew = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storeri";
let InputType = "imm";
let BaseOpcode = "S2_storeri_io";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 2;
let opNewValue = 3;
}
def S4_pstorerinewtnew_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Nt8),
"if ($Pv4.new) memw($Rs32+$Ru32<<#$Ii) = $Nt8.new",
V4LDST_tc_st_SLOT0, TypeST>, Enc_11000933, AddrModeRel {
let Inst{4-3} = 0b10;
let Inst{31-21} = 0b00110110101;
let isPredicated = 1;
let addrMode = BaseRegOffset;
let accessSize = WordAccess;
let isNVStore = 1;
let isPredicatedNew = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storeri";
let InputType = "reg";
let BaseOpcode = "S2_storeri_rr";
let opNewValue = 4;
}
def S4_pstorerinewtnew_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Nt8),
"if ($Pv4.new) memw($Rs32) = $Nt8.new",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let opNewValue = 2;
}
def S4_pstorerit_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4) memw(#$Ii) = $Rt32",
ST_tc_st_SLOT01, TypeST>, Enc_16657398, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b0;
let Inst{31-18} = 0b10101111100000;
let isPredicated = 1;
let addrMode = Absolute;
let accessSize = WordAccess;
let isExtended = 1;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let BaseOpcode = "S2_storeriabs";
let isNVStorable = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_pstorerit_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4) memw($Rs32+$Ru32<<#$Ii) = $Rt32",
V4LDST_tc_st_SLOT01, TypeST>, Enc_11940513, AddrModeRel {
let Inst{31-21} = 0b00110100100;
let isPredicated = 1;
let addrMode = BaseRegOffset;
let accessSize = WordAccess;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let InputType = "reg";
let BaseOpcode = "S2_storeri_rr";
let isNVStorable = 1;
}
def S4_pstoreritnew_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4.new) memw(#$Ii) = $Rt32",
ST_tc_st_SLOT01, TypeST>, Enc_16657398, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-18} = 0b10101111100000;
let isPredicated = 1;
let addrMode = Absolute;
let accessSize = WordAccess;
let isExtended = 1;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let BaseOpcode = "S2_storeriabs";
let isNVStorable = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_pstoreritnew_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u30_2Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4.new) memw($Rs32+#$Ii) = $Rt32",
V2LDST_tc_st_SLOT01, TypeV2LDST>, Enc_8225953, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{31-21} = 0b01000010100;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let InputType = "imm";
let BaseOpcode = "S2_storeri_io";
let isNVStorable = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 2;
}
def S4_pstoreritnew_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4.new) memw($Rs32+$Ru32<<#$Ii) = $Rt32",
V4LDST_tc_st_SLOT01, TypeST>, Enc_11940513, AddrModeRel {
let Inst{31-21} = 0b00110110100;
let isPredicated = 1;
let addrMode = BaseRegOffset;
let accessSize = WordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let InputType = "reg";
let BaseOpcode = "S2_storeri_rr";
let isNVStorable = 1;
}
def S4_pstoreritnew_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32),
"if ($Pv4.new) memw($Rs32) = $Rt32",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S4_stored_locked : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, DoubleRegs:$Rtt32),
"memd_locked($Rs32,$Pd4) = $Rtt32",
ST_tc_ld_SLOT0, TypeST>, Enc_2921694 {
let Inst{7-2} = 0b000000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10100000111;
let accessSize = DoubleWordAccess;
let isSoloAX = 1;
let mayStore = 1;
let isPredicateLate = 1;
}
def S4_storeirb_io : HInst<
(outs),
(ins IntRegs:$Rs32, u6_0Imm:$Ii, s32_0Imm:$II),
"memb($Rs32+#$Ii) = #$II",
V4LDST_tc_st_SLOT01, TypeST>, Enc_11282123, PredNewRel {
let Inst{31-21} = 0b00111100000;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let InputType = "imm";
let BaseOpcode = "S4_storeirb_io";
let isPredicable = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 8;
let opExtentAlign = 0;
}
def S4_storeirb_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, s8_0Imm:$II),
"memb($Rs32) = #$II",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S4_storeirbf_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u6_0Imm:$Ii, s32_0Imm:$II),
"if (!$Pv4) memb($Rs32+#$Ii) = #$II",
V4LDST_tc_st_SLOT01, TypeST>, Enc_5967898, PredNewRel {
let Inst{31-21} = 0b00111000100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let InputType = "imm";
let BaseOpcode = "S4_storeirb_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 1;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_storeirbf_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, s6_0Imm:$II),
"if (!$Pv4) memb($Rs32) = #$II",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S4_storeirbfnew_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u6_0Imm:$Ii, s32_0Imm:$II),
"if (!$Pv4.new) memb($Rs32+#$Ii) = #$II",
V4LDST_tc_st_SLOT01, TypeST>, Enc_5967898, PredNewRel {
let Inst{31-21} = 0b00111001100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let InputType = "imm";
let BaseOpcode = "S4_storeirb_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 1;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_storeirbfnew_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, s6_0Imm:$II),
"if (!$Pv4.new) memb($Rs32) = #$II",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S4_storeirbt_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u6_0Imm:$Ii, s32_0Imm:$II),
"if ($Pv4) memb($Rs32+#$Ii) = #$II",
V4LDST_tc_st_SLOT01, TypeST>, Enc_5967898, PredNewRel {
let Inst{31-21} = 0b00111000000;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let InputType = "imm";
let BaseOpcode = "S4_storeirb_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 1;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_storeirbt_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, s6_0Imm:$II),
"if ($Pv4) memb($Rs32) = #$II",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S4_storeirbtnew_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u6_0Imm:$Ii, s32_0Imm:$II),
"if ($Pv4.new) memb($Rs32+#$Ii) = #$II",
V4LDST_tc_st_SLOT01, TypeST>, Enc_5967898, PredNewRel {
let Inst{31-21} = 0b00111001000;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let InputType = "imm";
let BaseOpcode = "S4_storeirb_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 1;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_storeirbtnew_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, s6_0Imm:$II),
"if ($Pv4.new) memb($Rs32) = #$II",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S4_storeirh_io : HInst<
(outs),
(ins IntRegs:$Rs32, u6_1Imm:$Ii, s32_0Imm:$II),
"memh($Rs32+#$Ii) = #$II",
V4LDST_tc_st_SLOT01, TypeST>, Enc_10282127, PredNewRel {
let Inst{31-21} = 0b00111100001;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let InputType = "imm";
let BaseOpcode = "S4_storeirh_io";
let isPredicable = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 8;
let opExtentAlign = 0;
}
def S4_storeirh_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, s8_0Imm:$II),
"memh($Rs32) = #$II",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S4_storeirhf_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u6_1Imm:$Ii, s32_0Imm:$II),
"if (!$Pv4) memh($Rs32+#$Ii) = #$II",
V4LDST_tc_st_SLOT01, TypeST>, Enc_4967902, PredNewRel {
let Inst{31-21} = 0b00111000101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let InputType = "imm";
let BaseOpcode = "S4_storeirh_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 1;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_storeirhf_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, s6_0Imm:$II),
"if (!$Pv4) memh($Rs32) = #$II",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S4_storeirhfnew_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u6_1Imm:$Ii, s32_0Imm:$II),
"if (!$Pv4.new) memh($Rs32+#$Ii) = #$II",
V4LDST_tc_st_SLOT01, TypeST>, Enc_4967902, PredNewRel {
let Inst{31-21} = 0b00111001101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let InputType = "imm";
let BaseOpcode = "S4_storeirh_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 1;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_storeirhfnew_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, s6_0Imm:$II),
"if (!$Pv4.new) memh($Rs32) = #$II",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S4_storeirht_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u6_1Imm:$Ii, s32_0Imm:$II),
"if ($Pv4) memh($Rs32+#$Ii) = #$II",
V4LDST_tc_st_SLOT01, TypeST>, Enc_4967902, PredNewRel {
let Inst{31-21} = 0b00111000001;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let InputType = "imm";
let BaseOpcode = "S4_storeirh_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 1;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_storeirht_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, s6_0Imm:$II),
"if ($Pv4) memh($Rs32) = #$II",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S4_storeirhtnew_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u6_1Imm:$Ii, s32_0Imm:$II),
"if ($Pv4.new) memh($Rs32+#$Ii) = #$II",
V4LDST_tc_st_SLOT01, TypeST>, Enc_4967902, PredNewRel {
let Inst{31-21} = 0b00111001001;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let InputType = "imm";
let BaseOpcode = "S4_storeirh_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 1;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_storeirhtnew_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, s6_0Imm:$II),
"if ($Pv4.new) memh($Rs32) = #$II",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S4_storeiri_io : HInst<
(outs),
(ins IntRegs:$Rs32, u6_2Imm:$Ii, s32_0Imm:$II),
"memw($Rs32+#$Ii) = #$II",
V4LDST_tc_st_SLOT01, TypeST>, Enc_9282127, PredNewRel {
let Inst{31-21} = 0b00111100010;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let InputType = "imm";
let BaseOpcode = "S4_storeiri_io";
let isPredicable = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 8;
let opExtentAlign = 0;
}
def S4_storeiri_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, s8_0Imm:$II),
"memw($Rs32) = #$II",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S4_storeirif_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u6_2Imm:$Ii, s32_0Imm:$II),
"if (!$Pv4) memw($Rs32+#$Ii) = #$II",
V4LDST_tc_st_SLOT01, TypeST>, Enc_3967902, PredNewRel {
let Inst{31-21} = 0b00111000110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let InputType = "imm";
let BaseOpcode = "S4_storeiri_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 1;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_storeirif_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, s6_0Imm:$II),
"if (!$Pv4) memw($Rs32) = #$II",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S4_storeirifnew_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u6_2Imm:$Ii, s32_0Imm:$II),
"if (!$Pv4.new) memw($Rs32+#$Ii) = #$II",
V4LDST_tc_st_SLOT01, TypeST>, Enc_3967902, PredNewRel {
let Inst{31-21} = 0b00111001110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let InputType = "imm";
let BaseOpcode = "S4_storeiri_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 1;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_storeirifnew_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, s6_0Imm:$II),
"if (!$Pv4.new) memw($Rs32) = #$II",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S4_storeirit_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u6_2Imm:$Ii, s32_0Imm:$II),
"if ($Pv4) memw($Rs32+#$Ii) = #$II",
V4LDST_tc_st_SLOT01, TypeST>, Enc_3967902, PredNewRel {
let Inst{31-21} = 0b00111000010;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let InputType = "imm";
let BaseOpcode = "S4_storeiri_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 1;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_storeirit_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, s6_0Imm:$II),
"if ($Pv4) memw($Rs32) = #$II",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S4_storeiritnew_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u6_2Imm:$Ii, s32_0Imm:$II),
"if ($Pv4.new) memw($Rs32+#$Ii) = #$II",
V4LDST_tc_st_SLOT01, TypeST>, Enc_3967902, PredNewRel {
let Inst{31-21} = 0b00111001010;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let InputType = "imm";
let BaseOpcode = "S4_storeiri_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 1;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_storeiritnew_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, s6_0Imm:$II),
"if ($Pv4.new) memw($Rs32) = #$II",
PSEUDO, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S4_storerb_ap : HInst<
(outs IntRegs:$Re32),
(ins u32_0Imm:$II, IntRegs:$Rt32),
"memb($Re32=#$II) = $Rt32",
ST_tc_st_SLOT01, TypeST>, Enc_11477246, AddrModeRel {
let Inst{7-6} = 0b10;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10101011000;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = AbsoluteSet;
let accessSize = ByteAccess;
let isExtended = 1;
let mayStore = 1;
let BaseOpcode = "S2_storerb_ap";
let isNVStorable = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_storerb_rr : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Rt32),
"memb($Rs32+$Ru32<<#$Ii) = $Rt32",
V4LDST_tc_st_SLOT01, TypeST>, Enc_14046916, AddrModeRel, ImmRegShl {
let Inst{6-5} = 0b00;
let Inst{31-21} = 0b00111011000;
let addrMode = BaseRegOffset;
let accessSize = ByteAccess;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let InputType = "reg";
let BaseOpcode = "S4_storerb_rr";
let isNVStorable = 1;
let isPredicable = 1;
}
def S4_storerb_ur : HInst<
(outs),
(ins IntRegs:$Ru32, u2_0Imm:$Ii, u32_0Imm:$II, IntRegs:$Rt32),
"memb($Ru32<<#$Ii+#$II) = $Rt32",
ST_tc_st_SLOT01, TypeST>, Enc_14689096, AddrModeRel, ImmRegShl {
let Inst{7-7} = 0b1;
let Inst{31-21} = 0b10101101000;
let addrMode = BaseLongOffset;
let accessSize = ByteAccess;
let isExtended = 1;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let InputType = "imm";
let BaseOpcode = "S4_storerb_ur";
let isNVStorable = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_storerbnew_ap : HInst<
(outs IntRegs:$Re32),
(ins u32_0Imm:$II, IntRegs:$Nt8),
"memb($Re32=#$II) = $Nt8.new",
NCJ_tc_3or4stall_SLOT0, TypeST>, Enc_14193700, AddrModeRel {
let Inst{7-6} = 0b10;
let Inst{13-11} = 0b000;
let Inst{31-21} = 0b10101011101;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = AbsoluteSet;
let accessSize = ByteAccess;
let isNVStore = 1;
let isExtended = 1;
let mayStore = 1;
let isNewValue = 1;
let BaseOpcode = "S2_storerb_ap";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let opNewValue = 2;
}
def S4_storerbnew_rr : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Nt8),
"memb($Rs32+$Ru32<<#$Ii) = $Nt8.new",
V4LDST_tc_st_SLOT0, TypeST>, Enc_5486172, AddrModeRel {
let Inst{6-3} = 0b0000;
let Inst{31-21} = 0b00111011101;
let addrMode = BaseRegOffset;
let accessSize = ByteAccess;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storerb";
let InputType = "reg";
let BaseOpcode = "S4_storerb_rr";
let isPredicable = 1;
let opNewValue = 3;
}
def S4_storerbnew_ur : HInst<
(outs),
(ins IntRegs:$Ru32, u2_0Imm:$Ii, u32_0Imm:$II, IntRegs:$Nt8),
"memb($Ru32<<#$Ii+#$II) = $Nt8.new",
NCJ_tc_3or4stall_SLOT0, TypeST>, Enc_10076500, AddrModeRel {
let Inst{7-7} = 0b1;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b10101101101;
let addrMode = BaseLongOffset;
let accessSize = ByteAccess;
let isNVStore = 1;
let isExtended = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storerb";
let BaseOpcode = "S4_storerb_ur";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let opNewValue = 3;
}
def S4_storerd_ap : HInst<
(outs IntRegs:$Re32),
(ins u32_0Imm:$II, DoubleRegs:$Rtt32),
"memd($Re32=#$II) = $Rtt32",
ST_tc_st_SLOT01, TypeST>, Enc_8131399 {
let Inst{7-6} = 0b10;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10101011110;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = AbsoluteSet;
let accessSize = DoubleWordAccess;
let isExtended = 1;
let mayStore = 1;
let BaseOpcode = "S4_storerd_ap";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_storerd_rr : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, DoubleRegs:$Rtt32),
"memd($Rs32+$Ru32<<#$Ii) = $Rtt32",
V4LDST_tc_st_SLOT01, TypeST>, Enc_9772987, AddrModeRel, ImmRegShl {
let Inst{6-5} = 0b00;
let Inst{31-21} = 0b00111011110;
let addrMode = BaseRegOffset;
let accessSize = DoubleWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerd";
let InputType = "reg";
let BaseOpcode = "S2_storerd_rr";
let isPredicable = 1;
}
def S4_storerd_ur : HInst<
(outs),
(ins IntRegs:$Ru32, u2_0Imm:$Ii, u32_0Imm:$II, DoubleRegs:$Rtt32),
"memd($Ru32<<#$Ii+#$II) = $Rtt32",
ST_tc_st_SLOT01, TypeST>, Enc_12848507, AddrModeRel, ImmRegShl {
let Inst{7-7} = 0b1;
let Inst{31-21} = 0b10101101110;
let addrMode = BaseLongOffset;
let accessSize = DoubleWordAccess;
let isExtended = 1;
let mayStore = 1;
let CextOpcode = "S2_storerd";
let InputType = "imm";
let BaseOpcode = "S2_storerd_ur";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_storerf_ap : HInst<
(outs IntRegs:$Re32),
(ins u32_0Imm:$II, IntRegs:$Rt32),
"memh($Re32=#$II) = $Rt32.h",
ST_tc_st_SLOT01, TypeST>, Enc_11477246 {
let Inst{7-6} = 0b10;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10101011011;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = AbsoluteSet;
let accessSize = HalfWordAccess;
let isExtended = 1;
let mayStore = 1;
let BaseOpcode = "S4_storerf_ap";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_storerf_rr : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Rt32),
"memh($Rs32+$Ru32<<#$Ii) = $Rt32.h",
V4LDST_tc_st_SLOT01, TypeST>, Enc_14046916, AddrModeRel, ImmRegShl {
let Inst{6-5} = 0b00;
let Inst{31-21} = 0b00111011011;
let addrMode = BaseRegOffset;
let accessSize = HalfWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerf";
let InputType = "reg";
let BaseOpcode = "S4_storerf_rr";
let isPredicable = 1;
}
def S4_storerf_ur : HInst<
(outs),
(ins IntRegs:$Ru32, u2_0Imm:$Ii, u32_0Imm:$II, IntRegs:$Rt32),
"memh($Ru32<<#$Ii+#$II) = $Rt32.h",
ST_tc_st_SLOT01, TypeST>, Enc_14689096, AddrModeRel, ImmRegShl {
let Inst{7-7} = 0b1;
let Inst{31-21} = 0b10101101011;
let addrMode = BaseLongOffset;
let accessSize = HalfWordAccess;
let isExtended = 1;
let mayStore = 1;
let CextOpcode = "S2_storerf";
let InputType = "imm";
let BaseOpcode = "S4_storerf_rr";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_storerh_ap : HInst<
(outs IntRegs:$Re32),
(ins u32_0Imm:$II, IntRegs:$Rt32),
"memh($Re32=#$II) = $Rt32",
ST_tc_st_SLOT01, TypeST>, Enc_11477246, AddrModeRel {
let Inst{7-6} = 0b10;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10101011010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = AbsoluteSet;
let accessSize = HalfWordAccess;
let isExtended = 1;
let mayStore = 1;
let BaseOpcode = "S2_storerh_ap";
let isNVStorable = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_storerh_rr : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Rt32),
"memh($Rs32+$Ru32<<#$Ii) = $Rt32",
V4LDST_tc_st_SLOT01, TypeST>, Enc_14046916, AddrModeRel, ImmRegShl {
let Inst{6-5} = 0b00;
let Inst{31-21} = 0b00111011010;
let addrMode = BaseRegOffset;
let accessSize = HalfWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let InputType = "reg";
let BaseOpcode = "S2_storerh_rr";
let isNVStorable = 1;
let isPredicable = 1;
}
def S4_storerh_ur : HInst<
(outs),
(ins IntRegs:$Ru32, u2_0Imm:$Ii, u32_0Imm:$II, IntRegs:$Rt32),
"memh($Ru32<<#$Ii+#$II) = $Rt32",
ST_tc_st_SLOT01, TypeST>, Enc_14689096, AddrModeRel, ImmRegShl {
let Inst{7-7} = 0b1;
let Inst{31-21} = 0b10101101010;
let addrMode = BaseLongOffset;
let accessSize = HalfWordAccess;
let isExtended = 1;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let InputType = "imm";
let BaseOpcode = "S2_storerh_ur";
let isNVStorable = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_storerhnew_ap : HInst<
(outs IntRegs:$Re32),
(ins u32_0Imm:$II, IntRegs:$Nt8),
"memh($Re32=#$II) = $Nt8.new",
NCJ_tc_3or4stall_SLOT0, TypeST>, Enc_14193700, AddrModeRel {
let Inst{7-6} = 0b10;
let Inst{13-11} = 0b001;
let Inst{31-21} = 0b10101011101;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = AbsoluteSet;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let isExtended = 1;
let mayStore = 1;
let isNewValue = 1;
let BaseOpcode = "S2_storerh_ap";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let opNewValue = 2;
}
def S4_storerhnew_rr : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Nt8),
"memh($Rs32+$Ru32<<#$Ii) = $Nt8.new",
V4LDST_tc_st_SLOT0, TypeST>, Enc_5486172, AddrModeRel {
let Inst{6-3} = 0b0001;
let Inst{31-21} = 0b00111011101;
let addrMode = BaseRegOffset;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storerh";
let InputType = "reg";
let BaseOpcode = "S2_storerh_rr";
let isPredicable = 1;
let opNewValue = 3;
}
def S4_storerhnew_ur : HInst<
(outs),
(ins IntRegs:$Ru32, u2_0Imm:$Ii, u32_0Imm:$II, IntRegs:$Nt8),
"memh($Ru32<<#$Ii+#$II) = $Nt8.new",
NCJ_tc_3or4stall_SLOT0, TypeST>, Enc_10076500, AddrModeRel {
let Inst{7-7} = 0b1;
let Inst{12-11} = 0b01;
let Inst{31-21} = 0b10101101101;
let addrMode = BaseLongOffset;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let isExtended = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storerh";
let BaseOpcode = "S2_storerh_ur";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let opNewValue = 3;
}
def S4_storeri_ap : HInst<
(outs IntRegs:$Re32),
(ins u32_0Imm:$II, IntRegs:$Rt32),
"memw($Re32=#$II) = $Rt32",
ST_tc_st_SLOT01, TypeST>, Enc_11477246, AddrModeRel {
let Inst{7-6} = 0b10;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10101011100;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = AbsoluteSet;
let accessSize = WordAccess;
let isExtended = 1;
let mayStore = 1;
let BaseOpcode = "S2_storeri_ap";
let isNVStorable = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_storeri_rr : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Rt32),
"memw($Rs32+$Ru32<<#$Ii) = $Rt32",
V4LDST_tc_st_SLOT01, TypeST>, Enc_14046916, AddrModeRel, ImmRegShl {
let Inst{6-5} = 0b00;
let Inst{31-21} = 0b00111011100;
let addrMode = BaseRegOffset;
let accessSize = WordAccess;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let InputType = "reg";
let BaseOpcode = "S2_storeri_rr";
let isNVStorable = 1;
let isPredicable = 1;
}
def S4_storeri_ur : HInst<
(outs),
(ins IntRegs:$Ru32, u2_0Imm:$Ii, u32_0Imm:$II, IntRegs:$Rt32),
"memw($Ru32<<#$Ii+#$II) = $Rt32",
ST_tc_st_SLOT01, TypeST>, Enc_14689096, AddrModeRel, ImmRegShl {
let Inst{7-7} = 0b1;
let Inst{31-21} = 0b10101101100;
let addrMode = BaseLongOffset;
let accessSize = WordAccess;
let isExtended = 1;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let InputType = "imm";
let BaseOpcode = "S2_storeri_ur";
let isNVStorable = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_storerinew_ap : HInst<
(outs IntRegs:$Re32),
(ins u32_0Imm:$II, IntRegs:$Nt8),
"memw($Re32=#$II) = $Nt8.new",
NCJ_tc_3or4stall_SLOT0, TypeST>, Enc_14193700, AddrModeRel {
let Inst{7-6} = 0b10;
let Inst{13-11} = 0b010;
let Inst{31-21} = 0b10101011101;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = AbsoluteSet;
let accessSize = WordAccess;
let isNVStore = 1;
let isExtended = 1;
let mayStore = 1;
let isNewValue = 1;
let BaseOpcode = "S2_storeri_ap";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let opNewValue = 2;
}
def S4_storerinew_rr : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Nt8),
"memw($Rs32+$Ru32<<#$Ii) = $Nt8.new",
V4LDST_tc_st_SLOT0, TypeST>, Enc_5486172, AddrModeRel {
let Inst{6-3} = 0b0010;
let Inst{31-21} = 0b00111011101;
let addrMode = BaseRegOffset;
let accessSize = WordAccess;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storeri";
let InputType = "reg";
let BaseOpcode = "S2_storeri_rr";
let isPredicable = 1;
let opNewValue = 3;
}
def S4_storerinew_ur : HInst<
(outs),
(ins IntRegs:$Ru32, u2_0Imm:$Ii, u32_0Imm:$II, IntRegs:$Nt8),
"memw($Ru32<<#$Ii+#$II) = $Nt8.new",
NCJ_tc_3or4stall_SLOT0, TypeST>, Enc_10076500, AddrModeRel {
let Inst{7-7} = 0b1;
let Inst{12-11} = 0b10;
let Inst{31-21} = 0b10101101101;
let addrMode = BaseLongOffset;
let accessSize = WordAccess;
let isNVStore = 1;
let isExtended = 1;
let mayStore = 1;
let isNewValue = 1;
let CextOpcode = "S2_storeri";
let BaseOpcode = "S2_storeri_ur";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let opNewValue = 3;
}
def S4_subaddi : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, s32_0Imm:$Ii, IntRegs:$Ru32),
"$Rd32 = add($Rs32,sub(#$Ii,$Ru32))",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_6495334 {
let Inst{31-23} = 0b110110111;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_subi_asl_ri : HInst<
(outs IntRegs:$Rx32),
(ins u32_0Imm:$Ii, IntRegs:$Rx32in, u5_0Imm:$II),
"$Rx32 = sub(#$Ii,asl($Rx32in,#$II))",
ALU64_tc_1_SLOT23, TypeALU64>, Enc_117962 {
let Inst{2-0} = 0b110;
let Inst{4-4} = 0b0;
let Inst{31-24} = 0b11011110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 0;
let Constraints = "$Rx32 = $Rx32in";
}
def S4_subi_lsr_ri : HInst<
(outs IntRegs:$Rx32),
(ins u32_0Imm:$Ii, IntRegs:$Rx32in, u5_0Imm:$II),
"$Rx32 = sub(#$Ii,lsr($Rx32in,#$II))",
ALU64_tc_1_SLOT23, TypeALU64>, Enc_117962 {
let Inst{2-0} = 0b110;
let Inst{4-4} = 0b1;
let Inst{31-24} = 0b11011110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 0;
let Constraints = "$Rx32 = $Rx32in";
}
def S4_vrcrotate : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, IntRegs:$Rt32, u2_0Imm:$Ii),
"$Rdd32 = vrcrotate($Rss32,$Rt32,#$Ii)",
S_3op_tc_3x_SLOT23, TypeS_3op>, Enc_114098 {
let Inst{7-6} = 0b11;
let Inst{31-21} = 0b11000011110;
let prefersSlot3 = 1;
}
def S4_vrcrotate_acc : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Rt32, u2_0Imm:$Ii),
"$Rxx32 += vrcrotate($Rss32,$Rt32,#$Ii)",
S_3op_tc_3x_SLOT23, TypeS_3op>, Enc_13114546 {
let Inst{7-6} = 0b00;
let Inst{31-21} = 0b11001011101;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S4_vxaddsubh : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vxaddsubh($Rss32,$Rtt32):sat",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_8333157 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000001010;
let Defs = [USR_OVF];
}
def S4_vxaddsubhr : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vxaddsubh($Rss32,$Rtt32):rnd:>>1:sat",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_8333157 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000001110;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def S4_vxaddsubw : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vxaddsubw($Rss32,$Rtt32):sat",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_8333157 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000001010;
let Defs = [USR_OVF];
}
def S4_vxsubaddh : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vxsubaddh($Rss32,$Rtt32):sat",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_8333157 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000001010;
let Defs = [USR_OVF];
}
def S4_vxsubaddhr : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vxsubaddh($Rss32,$Rtt32):rnd:>>1:sat",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_8333157 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000001110;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def S4_vxsubaddw : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vxsubaddw($Rss32,$Rtt32):sat",
S_3op_tc_2_SLOT23, TypeS_3op>, Enc_8333157 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000001010;
let Defs = [USR_OVF];
}
def S5_asrhub_rnd_sat : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32, u4_0Imm:$Ii),
"$Rd32 = vasrhub($Rss32,#$Ii):raw",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_8038806, Requires<[HasV5T]> {
let Inst{7-5} = 0b100;
let Inst{13-12} = 0b00;
let Inst{31-21} = 0b10001000011;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def S5_asrhub_rnd_sat_goodsyntax : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32, u4_0Imm:$Ii),
"$Rd32 = vasrhub($Rss32,#$Ii):rnd:sat",
S_2op_tc_2_SLOT23, TypeS_2op>, Requires<[HasV5T]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
}
def S5_asrhub_sat : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32, u4_0Imm:$Ii),
"$Rd32 = vasrhub($Rss32,#$Ii):sat",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_8038806, Requires<[HasV5T]> {
let Inst{7-5} = 0b101;
let Inst{13-12} = 0b00;
let Inst{31-21} = 0b10001000011;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def S5_popcountp : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32),
"$Rd32 = popcount($Rss32)",
S_2op_tc_2_SLOT23, TypeS_2op>, Enc_3742184, Requires<[HasV5T]> {
let Inst{13-5} = 0b000000011;
let Inst{31-21} = 0b10001000011;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def S5_vasrhrnd : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, u4_0Imm:$Ii),
"$Rdd32 = vasrh($Rss32,#$Ii):raw",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_2082775, Requires<[HasV5T]> {
let Inst{7-5} = 0b000;
let Inst{13-12} = 0b00;
let Inst{31-21} = 0b10000000001;
let prefersSlot3 = 1;
}
def S5_vasrhrnd_goodsyntax : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, u4_0Imm:$Ii),
"$Rdd32 = vasrh($Rss32,#$Ii):rnd",
S_2op_tc_1_SLOT23, TypeS_2op>, Requires<[HasV5T]> {
let isPseudo = 1;
}
def S6_rol_i_p : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, u6_0Imm:$Ii),
"$Rdd32 = rol($Rss32,#$Ii)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_4231995, Requires<[HasV60T]> {
let Inst{7-5} = 0b011;
let Inst{31-21} = 0b10000000000;
}
def S6_rol_i_p_acc : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, u6_0Imm:$Ii),
"$Rxx32 += rol($Rss32,#$Ii)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_8497723, Requires<[HasV60T]> {
let Inst{7-5} = 0b111;
let Inst{31-21} = 0b10000010000;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S6_rol_i_p_and : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, u6_0Imm:$Ii),
"$Rxx32 &= rol($Rss32,#$Ii)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_8497723, Requires<[HasV60T]> {
let Inst{7-5} = 0b011;
let Inst{31-21} = 0b10000010010;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S6_rol_i_p_nac : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, u6_0Imm:$Ii),
"$Rxx32 -= rol($Rss32,#$Ii)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_8497723, Requires<[HasV60T]> {
let Inst{7-5} = 0b011;
let Inst{31-21} = 0b10000010000;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S6_rol_i_p_or : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, u6_0Imm:$Ii),
"$Rxx32 |= rol($Rss32,#$Ii)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_8497723, Requires<[HasV60T]> {
let Inst{7-5} = 0b111;
let Inst{31-21} = 0b10000010010;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S6_rol_i_p_xacc : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, u6_0Imm:$Ii),
"$Rxx32 ^= rol($Rss32,#$Ii)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_8497723, Requires<[HasV60T]> {
let Inst{7-5} = 0b011;
let Inst{31-21} = 0b10000010100;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S6_rol_i_r : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rd32 = rol($Rs32,#$Ii)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_2771456, Requires<[HasV60T]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001100000;
let hasNewValue = 1;
let opNewValue = 0;
}
def S6_rol_i_r_acc : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rx32 += rol($Rs32,#$Ii)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_2410156, Requires<[HasV60T]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001110000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S6_rol_i_r_and : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rx32 &= rol($Rs32,#$Ii)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_2410156, Requires<[HasV60T]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001110010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S6_rol_i_r_nac : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rx32 -= rol($Rs32,#$Ii)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_2410156, Requires<[HasV60T]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001110000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S6_rol_i_r_or : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rx32 |= rol($Rs32,#$Ii)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_2410156, Requires<[HasV60T]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001110010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S6_rol_i_r_xacc : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rx32 ^= rol($Rs32,#$Ii)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_2410156, Requires<[HasV60T]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001110100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S6_vsplatrbp : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32),
"$Rdd32 = vsplatb($Rs32)",
S_2op_tc_1_SLOT23, TypeS_2op>, Enc_4030179, Requires<[HasV62T]> {
let Inst{13-5} = 0b000000100;
let Inst{31-21} = 0b10000100010;
}
def S6_vtrunehb_ppp : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vtrunehb($Rss32,$Rtt32)",
S_3op_tc_1_SLOT23, TypeS_3op>, Enc_8333157, Requires<[HasV62T]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000001100;
}
def S6_vtrunohb_ppp : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vtrunohb($Rss32,$Rtt32)",
S_3op_tc_1_SLOT23, TypeS_3op>, Enc_8333157, Requires<[HasV62T]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000001100;
}
def SA1_addi : HInst<
(outs GeneralSubRegs:$Rx16),
(ins IntRegs:$Rx16in, s32_0Imm:$Ii),
"$Rx16 = add($Rx16in,#$Ii)",
PSEUDO, TypeSUBINSN>, Enc_3974695 {
let Inst{12-11} = 0b00;
let hasNewValue = 1;
let opNewValue = 0;
let AsmVariantName = "NonParsable";
let DecoderNamespace = "SUBINSN_A";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 7;
let opExtentAlign = 0;
let Constraints = "$Rx16 = $Rx16in";
}
def SA1_addrx : HInst<
(outs GeneralSubRegs:$Rx16),
(ins IntRegs:$Rx16in, GeneralSubRegs:$Rs16),
"$Rx16 = add($Rx16in,$Rs16)",
PSEUDO, TypeSUBINSN>, Enc_6135183 {
let Inst{12-8} = 0b11000;
let hasNewValue = 1;
let opNewValue = 0;
let AsmVariantName = "NonParsable";
let DecoderNamespace = "SUBINSN_A";
let Constraints = "$Rx16 = $Rx16in";
}
def SA1_addsp : HInst<
(outs GeneralSubRegs:$Rd16),
(ins u6_2Imm:$Ii),
"$Rd16 = add(r29,#$Ii)",
PSEUDO, TypeSUBINSN>, Enc_176263 {
let Inst{12-10} = 0b011;
let hasNewValue = 1;
let opNewValue = 0;
let AsmVariantName = "NonParsable";
let Uses = [R29];
let DecoderNamespace = "SUBINSN_A";
}
def SA1_and1 : HInst<
(outs GeneralSubRegs:$Rd16),
(ins GeneralSubRegs:$Rs16),
"$Rd16 = and($Rs16,#1)",
PSEUDO, TypeSUBINSN>, Enc_14939491 {
let Inst{12-8} = 0b10010;
let hasNewValue = 1;
let opNewValue = 0;
let AsmVariantName = "NonParsable";
let DecoderNamespace = "SUBINSN_A";
}
def SA1_clrf : HInst<
(outs GeneralSubRegs:$Rd16),
(ins),
"if (!p0) $Rd16 = #0",
PSEUDO, TypeSUBINSN>, Enc_1451363 {
let Inst{12-4} = 0b110100111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let AsmVariantName = "NonParsable";
let Uses = [P0];
let DecoderNamespace = "SUBINSN_A";
}
def SA1_clrfnew : HInst<
(outs GeneralSubRegs:$Rd16),
(ins),
"if (!p0.new) $Rd16 = #0",
PSEUDO, TypeSUBINSN>, Enc_1451363 {
let Inst{12-4} = 0b110100101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let AsmVariantName = "NonParsable";
let isPredicatedNew = 1;
let Uses = [P0];
let DecoderNamespace = "SUBINSN_A";
}
def SA1_clrt : HInst<
(outs GeneralSubRegs:$Rd16),
(ins),
"if (p0) $Rd16 = #0",
PSEUDO, TypeSUBINSN>, Enc_1451363 {
let Inst{12-4} = 0b110100110;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let AsmVariantName = "NonParsable";
let Uses = [P0];
let DecoderNamespace = "SUBINSN_A";
}
def SA1_clrtnew : HInst<
(outs GeneralSubRegs:$Rd16),
(ins),
"if (p0.new) $Rd16 = #0",
PSEUDO, TypeSUBINSN>, Enc_1451363 {
let Inst{12-4} = 0b110100100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let AsmVariantName = "NonParsable";
let isPredicatedNew = 1;
let Uses = [P0];
let DecoderNamespace = "SUBINSN_A";
}
def SA1_cmpeqi : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u2_0Imm:$Ii),
"p0 = cmp.eq($Rs16,#$Ii)",
PSEUDO, TypeSUBINSN>, Enc_2079016 {
let Inst{3-2} = 0b00;
let Inst{12-8} = 0b11001;
let AsmVariantName = "NonParsable";
let Defs = [P0];
let DecoderNamespace = "SUBINSN_A";
}
def SA1_combine0i : HInst<
(outs GeneralDoubleLow8Regs:$Rdd8),
(ins u2_0Imm:$Ii),
"$Rdd8 = combine(#0,#$Ii)",
PSEUDO, TypeSUBINSN>, Enc_15946706 {
let Inst{4-3} = 0b00;
let Inst{12-7} = 0b111000;
let hasNewValue = 1;
let opNewValue = 0;
let AsmVariantName = "NonParsable";
let DecoderNamespace = "SUBINSN_A";
}
def SA1_combine1i : HInst<
(outs GeneralDoubleLow8Regs:$Rdd8),
(ins u2_0Imm:$Ii),
"$Rdd8 = combine(#1,#$Ii)",
PSEUDO, TypeSUBINSN>, Enc_15946706 {
let Inst{4-3} = 0b01;
let Inst{12-7} = 0b111000;
let hasNewValue = 1;
let opNewValue = 0;
let AsmVariantName = "NonParsable";
let DecoderNamespace = "SUBINSN_A";
}
def SA1_combine2i : HInst<
(outs GeneralDoubleLow8Regs:$Rdd8),
(ins u2_0Imm:$Ii),
"$Rdd8 = combine(#2,#$Ii)",
PSEUDO, TypeSUBINSN>, Enc_15946706 {
let Inst{4-3} = 0b10;
let Inst{12-7} = 0b111000;
let hasNewValue = 1;
let opNewValue = 0;
let AsmVariantName = "NonParsable";
let DecoderNamespace = "SUBINSN_A";
}
def SA1_combine3i : HInst<
(outs GeneralDoubleLow8Regs:$Rdd8),
(ins u2_0Imm:$Ii),
"$Rdd8 = combine(#3,#$Ii)",
PSEUDO, TypeSUBINSN>, Enc_15946706 {
let Inst{4-3} = 0b11;
let Inst{12-7} = 0b111000;
let hasNewValue = 1;
let opNewValue = 0;
let AsmVariantName = "NonParsable";
let DecoderNamespace = "SUBINSN_A";
}
def SA1_combinerz : HInst<
(outs GeneralDoubleLow8Regs:$Rdd8),
(ins GeneralSubRegs:$Rs16),
"$Rdd8 = combine($Rs16,#0)",
PSEUDO, TypeSUBINSN>, Enc_10501894 {
let Inst{3-3} = 0b1;
let Inst{12-8} = 0b11101;
let hasNewValue = 1;
let opNewValue = 0;
let AsmVariantName = "NonParsable";
let DecoderNamespace = "SUBINSN_A";
}
def SA1_combinezr : HInst<
(outs GeneralDoubleLow8Regs:$Rdd8),
(ins GeneralSubRegs:$Rs16),
"$Rdd8 = combine(#0,$Rs16)",
PSEUDO, TypeSUBINSN>, Enc_10501894 {
let Inst{3-3} = 0b0;
let Inst{12-8} = 0b11101;
let hasNewValue = 1;
let opNewValue = 0;
let AsmVariantName = "NonParsable";
let DecoderNamespace = "SUBINSN_A";
}
def SA1_dec : HInst<
(outs GeneralSubRegs:$Rd16),
(ins GeneralSubRegs:$Rs16, n1Const:$n1),
"$Rd16 = add($Rs16,#$n1)",
PSEUDO, TypeSUBINSN>, Enc_10597934 {
let Inst{12-8} = 0b10011;
let hasNewValue = 1;
let opNewValue = 0;
let AsmVariantName = "NonParsable";
let DecoderNamespace = "SUBINSN_A";
}
def SA1_inc : HInst<
(outs GeneralSubRegs:$Rd16),
(ins GeneralSubRegs:$Rs16),
"$Rd16 = add($Rs16,#1)",
PSEUDO, TypeSUBINSN>, Enc_14939491 {
let Inst{12-8} = 0b10001;
let hasNewValue = 1;
let opNewValue = 0;
let AsmVariantName = "NonParsable";
let DecoderNamespace = "SUBINSN_A";
}
def SA1_seti : HInst<
(outs GeneralSubRegs:$Rd16),
(ins u32_0Imm:$Ii),
"$Rd16 = #$Ii",
PSEUDO, TypeSUBINSN>, Enc_2176383 {
let Inst{12-10} = 0b010;
let hasNewValue = 1;
let opNewValue = 0;
let AsmVariantName = "NonParsable";
let DecoderNamespace = "SUBINSN_A";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def SA1_setin1 : HInst<
(outs GeneralSubRegs:$Rd16),
(ins n1Const:$n1),
"$Rd16 = #$n1",
PSEUDO, TypeSUBINSN>, Enc_13336212 {
let Inst{12-4} = 0b110100000;
let hasNewValue = 1;
let opNewValue = 0;
let AsmVariantName = "NonParsable";
let DecoderNamespace = "SUBINSN_A";
}
def SA1_sxtb : HInst<
(outs GeneralSubRegs:$Rd16),
(ins GeneralSubRegs:$Rs16),
"$Rd16 = sxtb($Rs16)",
PSEUDO, TypeSUBINSN>, Enc_14939491 {
let Inst{12-8} = 0b10101;
let hasNewValue = 1;
let opNewValue = 0;
let AsmVariantName = "NonParsable";
let DecoderNamespace = "SUBINSN_A";
}
def SA1_sxth : HInst<
(outs GeneralSubRegs:$Rd16),
(ins GeneralSubRegs:$Rs16),
"$Rd16 = sxth($Rs16)",
PSEUDO, TypeSUBINSN>, Enc_14939491 {
let Inst{12-8} = 0b10100;
let hasNewValue = 1;
let opNewValue = 0;
let AsmVariantName = "NonParsable";
let DecoderNamespace = "SUBINSN_A";
}
def SA1_tfr : HInst<
(outs GeneralSubRegs:$Rd16),
(ins GeneralSubRegs:$Rs16),
"$Rd16 = $Rs16",
PSEUDO, TypeSUBINSN>, Enc_14939491 {
let Inst{12-8} = 0b10000;
let hasNewValue = 1;
let opNewValue = 0;
let AsmVariantName = "NonParsable";
let DecoderNamespace = "SUBINSN_A";
}
def SA1_zxtb : HInst<
(outs GeneralSubRegs:$Rd16),
(ins GeneralSubRegs:$Rs16),
"$Rd16 = and($Rs16,#255)",
PSEUDO, TypeSUBINSN>, Enc_14939491 {
let Inst{12-8} = 0b10111;
let hasNewValue = 1;
let opNewValue = 0;
let AsmVariantName = "NonParsable";
let DecoderNamespace = "SUBINSN_A";
}
def SA1_zxth : HInst<
(outs GeneralSubRegs:$Rd16),
(ins GeneralSubRegs:$Rs16),
"$Rd16 = zxth($Rs16)",
PSEUDO, TypeSUBINSN>, Enc_14939491 {
let Inst{12-8} = 0b10110;
let hasNewValue = 1;
let opNewValue = 0;
let AsmVariantName = "NonParsable";
let DecoderNamespace = "SUBINSN_A";
}
def SL1_loadri_io : HInst<
(outs GeneralSubRegs:$Rd16),
(ins GeneralSubRegs:$Rs16, u4_2Imm:$Ii),
"$Rd16 = memw($Rs16+#$Ii)",
PSEUDO, TypeSUBINSN>, Enc_13606251 {
let Inst{12-12} = 0b0;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let AsmVariantName = "NonParsable";
let mayLoad = 1;
let DecoderNamespace = "SUBINSN_L1";
}
def SL1_loadrub_io : HInst<
(outs GeneralSubRegs:$Rd16),
(ins GeneralSubRegs:$Rs16, u4_0Imm:$Ii),
"$Rd16 = memub($Rs16+#$Ii)",
PSEUDO, TypeSUBINSN>, Enc_15606259 {
let Inst{12-12} = 0b1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let AsmVariantName = "NonParsable";
let mayLoad = 1;
let DecoderNamespace = "SUBINSN_L1";
}
def SL2_deallocframe : HInst<
(outs),
(ins),
"deallocframe",
PSEUDO, TypeSUBINSN>, Enc_0 {
let Inst{12-0} = 0b1111100000000;
let accessSize = DoubleWordAccess;
let AsmVariantName = "NonParsable";
let mayLoad = 1;
let Uses = [R30];
let Defs = [R30, R29, R31];
let DecoderNamespace = "SUBINSN_L2";
}
def SL2_jumpr31 : HInst<
(outs),
(ins),
"jumpr r31",
PSEUDO, TypeSUBINSN>, Enc_0 {
let Inst{12-0} = 0b1111111000000;
let isTerminator = 1;
let isIndirectBranch = 1;
let cofMax1 = 1;
let AsmVariantName = "NonParsable";
let isReturn = 1;
let Uses = [R31];
let Defs = [PC];
let DecoderNamespace = "SUBINSN_L2";
}
def SL2_jumpr31_f : HInst<
(outs),
(ins),
"if (!p0) jumpr r31",
PSEUDO, TypeSUBINSN>, Enc_0 {
let Inst{12-0} = 0b1111111000101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isIndirectBranch = 1;
let cofMax1 = 1;
let AsmVariantName = "NonParsable";
let isReturn = 1;
let Uses = [P0, R31];
let Defs = [PC];
let isTaken = Inst{4};
let DecoderNamespace = "SUBINSN_L2";
}
def SL2_jumpr31_fnew : HInst<
(outs),
(ins),
"if (!p0.new) jumpr:nt r31",
PSEUDO, TypeSUBINSN>, Enc_0 {
let Inst{12-0} = 0b1111111000111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isIndirectBranch = 1;
let cofMax1 = 1;
let AsmVariantName = "NonParsable";
let isReturn = 1;
let isPredicatedNew = 1;
let Uses = [P0, R31];
let Defs = [PC];
let isTaken = Inst{4};
let DecoderNamespace = "SUBINSN_L2";
}
def SL2_jumpr31_t : HInst<
(outs),
(ins),
"if (p0) jumpr r31",
PSEUDO, TypeSUBINSN>, Enc_0 {
let Inst{12-0} = 0b1111111000100;
let isPredicated = 1;
let isTerminator = 1;
let isIndirectBranch = 1;
let cofMax1 = 1;
let AsmVariantName = "NonParsable";
let isReturn = 1;
let Uses = [P0, R31];
let Defs = [PC];
let isTaken = Inst{4};
let DecoderNamespace = "SUBINSN_L2";
}
def SL2_jumpr31_tnew : HInst<
(outs),
(ins),
"if (p0.new) jumpr:nt r31",
PSEUDO, TypeSUBINSN>, Enc_0 {
let Inst{12-0} = 0b1111111000110;
let isPredicated = 1;
let isTerminator = 1;
let isIndirectBranch = 1;
let cofMax1 = 1;
let AsmVariantName = "NonParsable";
let isReturn = 1;
let isPredicatedNew = 1;
let Uses = [P0, R31];
let Defs = [PC];
let isTaken = Inst{4};
let DecoderNamespace = "SUBINSN_L2";
}
def SL2_loadrb_io : HInst<
(outs GeneralSubRegs:$Rd16),
(ins GeneralSubRegs:$Rs16, u3_0Imm:$Ii),
"$Rd16 = memb($Rs16+#$Ii)",
PSEUDO, TypeSUBINSN>, Enc_3135259 {
let Inst{12-11} = 0b10;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let AsmVariantName = "NonParsable";
let mayLoad = 1;
let DecoderNamespace = "SUBINSN_L2";
}
def SL2_loadrd_sp : HInst<
(outs GeneralDoubleLow8Regs:$Rdd8),
(ins u5_3Imm:$Ii),
"$Rdd8 = memd(r29+#$Ii)",
PSEUDO, TypeSUBINSN>, Enc_16479122 {
let Inst{12-8} = 0b11110;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = DoubleWordAccess;
let AsmVariantName = "NonParsable";
let mayLoad = 1;
let Uses = [R29];
let DecoderNamespace = "SUBINSN_L2";
}
def SL2_loadrh_io : HInst<
(outs GeneralSubRegs:$Rd16),
(ins GeneralSubRegs:$Rs16, u3_1Imm:$Ii),
"$Rd16 = memh($Rs16+#$Ii)",
PSEUDO, TypeSUBINSN>, Enc_4135257 {
let Inst{12-11} = 0b00;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let AsmVariantName = "NonParsable";
let mayLoad = 1;
let DecoderNamespace = "SUBINSN_L2";
}
def SL2_loadri_sp : HInst<
(outs GeneralSubRegs:$Rd16),
(ins u5_2Imm:$Ii),
"$Rd16 = memw(r29+#$Ii)",
PSEUDO, TypeSUBINSN>, Enc_64199 {
let Inst{12-9} = 0b1110;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let AsmVariantName = "NonParsable";
let mayLoad = 1;
let Uses = [R29];
let DecoderNamespace = "SUBINSN_L2";
}
def SL2_loadruh_io : HInst<
(outs GeneralSubRegs:$Rd16),
(ins GeneralSubRegs:$Rs16, u3_1Imm:$Ii),
"$Rd16 = memuh($Rs16+#$Ii)",
PSEUDO, TypeSUBINSN>, Enc_4135257 {
let Inst{12-11} = 0b01;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let AsmVariantName = "NonParsable";
let mayLoad = 1;
let DecoderNamespace = "SUBINSN_L2";
}
def SL2_return : HInst<
(outs),
(ins),
"dealloc_return",
PSEUDO, TypeSUBINSN>, Enc_0 {
let Inst{12-0} = 0b1111101000000;
let isTerminator = 1;
let isIndirectBranch = 1;
let accessSize = DoubleWordAccess;
let cofMax1 = 1;
let AsmVariantName = "NonParsable";
let isReturn = 1;
let mayLoad = 1;
let Uses = [R30];
let Defs = [PC, R30, R29, R31];
let DecoderNamespace = "SUBINSN_L2";
}
def SL2_return_f : HInst<
(outs),
(ins),
"if (!p0) dealloc_return",
PSEUDO, TypeSUBINSN>, Enc_0 {
let Inst{12-0} = 0b1111101000101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isIndirectBranch = 1;
let accessSize = DoubleWordAccess;
let cofMax1 = 1;
let AsmVariantName = "NonParsable";
let isReturn = 1;
let mayLoad = 1;
let Uses = [P0, R30];
let Defs = [PC, R30, R29, R31];
let isTaken = Inst{4};
let DecoderNamespace = "SUBINSN_L2";
}
def SL2_return_fnew : HInst<
(outs),
(ins),
"if (!p0.new) dealloc_return:nt",
PSEUDO, TypeSUBINSN>, Enc_0 {
let Inst{12-0} = 0b1111101000111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isIndirectBranch = 1;
let accessSize = DoubleWordAccess;
let cofMax1 = 1;
let AsmVariantName = "NonParsable";
let isReturn = 1;
let isPredicatedNew = 1;
let mayLoad = 1;
let Uses = [P0, R30];
let Defs = [PC, R30, R29, R31];
let isTaken = Inst{4};
let DecoderNamespace = "SUBINSN_L2";
}
def SL2_return_t : HInst<
(outs),
(ins),
"if (p0) dealloc_return",
PSEUDO, TypeSUBINSN>, Enc_0 {
let Inst{12-0} = 0b1111101000100;
let isPredicated = 1;
let isTerminator = 1;
let isIndirectBranch = 1;
let accessSize = DoubleWordAccess;
let cofMax1 = 1;
let AsmVariantName = "NonParsable";
let isReturn = 1;
let mayLoad = 1;
let Uses = [P0, R30];
let Defs = [PC, R30, R29, R31];
let isTaken = Inst{4};
let DecoderNamespace = "SUBINSN_L2";
}
def SL2_return_tnew : HInst<
(outs),
(ins),
"if (p0.new) dealloc_return:nt",
PSEUDO, TypeSUBINSN>, Enc_0 {
let Inst{12-0} = 0b1111101000110;
let isPredicated = 1;
let isTerminator = 1;
let isIndirectBranch = 1;
let accessSize = DoubleWordAccess;
let cofMax1 = 1;
let AsmVariantName = "NonParsable";
let isReturn = 1;
let isPredicatedNew = 1;
let mayLoad = 1;
let Uses = [P0, R30];
let Defs = [PC, R30, R29, R31];
let isTaken = Inst{4};
let DecoderNamespace = "SUBINSN_L2";
}
def SS1_storeb_io : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u4_0Imm:$Ii, GeneralSubRegs:$Rt16),
"memb($Rs16+#$Ii) = $Rt16",
PSEUDO, TypeSUBINSN>, Enc_13204995 {
let Inst{12-12} = 0b1;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let AsmVariantName = "NonParsable";
let mayStore = 1;
let DecoderNamespace = "SUBINSN_S1";
}
def SS1_storew_io : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u4_2Imm:$Ii, GeneralSubRegs:$Rt16),
"memw($Rs16+#$Ii) = $Rt16",
PSEUDO, TypeSUBINSN>, Enc_11205051 {
let Inst{12-12} = 0b0;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let AsmVariantName = "NonParsable";
let mayStore = 1;
let DecoderNamespace = "SUBINSN_S1";
}
def SS2_allocframe : HInst<
(outs),
(ins u5_3Imm:$Ii),
"allocframe(#$Ii)",
PSEUDO, TypeSUBINSN>, Enc_7884306 {
let Inst{3-0} = 0b0000;
let Inst{12-9} = 0b1110;
let addrMode = BaseImmOffset;
let accessSize = DoubleWordAccess;
let AsmVariantName = "NonParsable";
let mayStore = 1;
let Uses = [R30, R29, R31];
let Defs = [R30, R29];
let DecoderNamespace = "SUBINSN_S2";
}
def SS2_storebi0 : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u4_0Imm:$Ii),
"memb($Rs16+#$Ii) = #0",
PSEUDO, TypeSUBINSN>, Enc_13536408 {
let Inst{12-8} = 0b10010;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let AsmVariantName = "NonParsable";
let mayStore = 1;
let DecoderNamespace = "SUBINSN_S2";
}
def SS2_storebi1 : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u4_0Imm:$Ii),
"memb($Rs16+#$Ii) = #1",
PSEUDO, TypeSUBINSN>, Enc_13536408 {
let Inst{12-8} = 0b10011;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let AsmVariantName = "NonParsable";
let mayStore = 1;
let DecoderNamespace = "SUBINSN_S2";
}
def SS2_stored_sp : HInst<
(outs),
(ins s6_3Imm:$Ii, GeneralDoubleLow8Regs:$Rtt8),
"memd(r29+#$Ii) = $Rtt8",
PSEUDO, TypeSUBINSN>, Enc_9165078 {
let Inst{12-9} = 0b0101;
let addrMode = BaseImmOffset;
let accessSize = DoubleWordAccess;
let AsmVariantName = "NonParsable";
let mayStore = 1;
let Uses = [R29];
let DecoderNamespace = "SUBINSN_S2";
}
def SS2_storeh_io : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u3_1Imm:$Ii, GeneralSubRegs:$Rt16),
"memh($Rs16+#$Ii) = $Rt16",
PSEUDO, TypeSUBINSN>, Enc_1734121 {
let Inst{12-11} = 0b00;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let AsmVariantName = "NonParsable";
let mayStore = 1;
let DecoderNamespace = "SUBINSN_S2";
}
def SS2_storew_sp : HInst<
(outs),
(ins u5_2Imm:$Ii, GeneralSubRegs:$Rt16),
"memw(r29+#$Ii) = $Rt16",
PSEUDO, TypeSUBINSN>, Enc_6690615 {
let Inst{12-9} = 0b0100;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let AsmVariantName = "NonParsable";
let mayStore = 1;
let Uses = [R29];
let DecoderNamespace = "SUBINSN_S2";
}
def SS2_storewi0 : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u4_2Imm:$Ii),
"memw($Rs16+#$Ii) = #0",
PSEUDO, TypeSUBINSN>, Enc_15536400 {
let Inst{12-8} = 0b10000;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let AsmVariantName = "NonParsable";
let mayStore = 1;
let DecoderNamespace = "SUBINSN_S2";
}
def SS2_storewi1 : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u4_2Imm:$Ii),
"memw($Rs16+#$Ii) = #1",
PSEUDO, TypeSUBINSN>, Enc_15536400 {
let Inst{12-8} = 0b10001;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let AsmVariantName = "NonParsable";
let mayStore = 1;
let DecoderNamespace = "SUBINSN_S2";
}
def V6_MAP_equb : HInst<
(outs VecPredRegs:$Qd4),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Qd4 = vcmp.eq($Vu32.ub,$Vv32.ub)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_MAP_equb_128B : HInst<
(outs VecPredRegs128B:$Qd4),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Qd4 = vcmp.eq($Vu32.ub,$Vv32.ub)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_MAP_equb_and : HInst<
(outs VecPredRegs:$Qx4),
(ins VecPredRegs:$Qx4in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Qx4 &= vcmp.eq($Vu32.ub,$Vv32.ub)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_MAP_equb_and_128B : HInst<
(outs VecPredRegs128B:$Qx4),
(ins VecPredRegs128B:$Qx4in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Qx4 &= vcmp.eq($Vu32.ub,$Vv32.ub)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Qx4 = $Qx4in";
}
def V6_MAP_equb_ior : HInst<
(outs VecPredRegs:$Qx4),
(ins VecPredRegs:$Qx4in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Qx4 |= vcmp.eq($Vu32.ub,$Vv32.ub)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_MAP_equb_ior_128B : HInst<
(outs VecPredRegs128B:$Qx4),
(ins VecPredRegs128B:$Qx4in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Qx4 |= vcmp.eq($Vu32.ub,$Vv32.ub)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Qx4 = $Qx4in";
}
def V6_MAP_equb_xor : HInst<
(outs VecPredRegs:$Qx4),
(ins VecPredRegs:$Qx4in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Qx4 ^= vcmp.eq($Vu32.ub,$Vv32.ub)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_MAP_equb_xor_128B : HInst<
(outs VecPredRegs128B:$Qx4),
(ins VecPredRegs128B:$Qx4in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Qx4 ^= vcmp.eq($Vu32.ub,$Vv32.ub)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Qx4 = $Qx4in";
}
def V6_MAP_equh : HInst<
(outs VecPredRegs:$Qd4),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Qd4 = vcmp.eq($Vu32.uh,$Vv32.uh)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_MAP_equh_128B : HInst<
(outs VecPredRegs128B:$Qd4),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Qd4 = vcmp.eq($Vu32.uh,$Vv32.uh)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_MAP_equh_and : HInst<
(outs VecPredRegs:$Qx4),
(ins VecPredRegs:$Qx4in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Qx4 &= vcmp.eq($Vu32.uh,$Vv32.uh)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_MAP_equh_and_128B : HInst<
(outs VecPredRegs128B:$Qx4),
(ins VecPredRegs128B:$Qx4in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Qx4 &= vcmp.eq($Vu32.uh,$Vv32.uh)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Qx4 = $Qx4in";
}
def V6_MAP_equh_ior : HInst<
(outs VecPredRegs:$Qx4),
(ins VecPredRegs:$Qx4in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Qx4 |= vcmp.eq($Vu32.uh,$Vv32.uh)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_MAP_equh_ior_128B : HInst<
(outs VecPredRegs128B:$Qx4),
(ins VecPredRegs128B:$Qx4in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Qx4 |= vcmp.eq($Vu32.uh,$Vv32.uh)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Qx4 = $Qx4in";
}
def V6_MAP_equh_xor : HInst<
(outs VecPredRegs:$Qx4),
(ins VecPredRegs:$Qx4in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Qx4 ^= vcmp.eq($Vu32.uh,$Vv32.uh)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_MAP_equh_xor_128B : HInst<
(outs VecPredRegs128B:$Qx4),
(ins VecPredRegs128B:$Qx4in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Qx4 ^= vcmp.eq($Vu32.uh,$Vv32.uh)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Qx4 = $Qx4in";
}
def V6_MAP_equw : HInst<
(outs VecPredRegs:$Qd4),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Qd4 = vcmp.eq($Vu32.uw,$Vv32.uw)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_MAP_equw_128B : HInst<
(outs VecPredRegs128B:$Qd4),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Qd4 = vcmp.eq($Vu32.uw,$Vv32.uw)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_MAP_equw_and : HInst<
(outs VecPredRegs:$Qx4),
(ins VecPredRegs:$Qx4in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Qx4 &= vcmp.eq($Vu32.uw,$Vv32.uw)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_MAP_equw_and_128B : HInst<
(outs VecPredRegs128B:$Qx4),
(ins VecPredRegs128B:$Qx4in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Qx4 &= vcmp.eq($Vu32.uw,$Vv32.uw)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Qx4 = $Qx4in";
}
def V6_MAP_equw_ior : HInst<
(outs VecPredRegs:$Qx4),
(ins VecPredRegs:$Qx4in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Qx4 |= vcmp.eq($Vu32.uw,$Vv32.uw)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_MAP_equw_ior_128B : HInst<
(outs VecPredRegs128B:$Qx4),
(ins VecPredRegs128B:$Qx4in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Qx4 |= vcmp.eq($Vu32.uw,$Vv32.uw)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Qx4 = $Qx4in";
}
def V6_MAP_equw_xor : HInst<
(outs VecPredRegs:$Qx4),
(ins VecPredRegs:$Qx4in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Qx4 ^= vcmp.eq($Vu32.uw,$Vv32.uw)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_MAP_equw_xor_128B : HInst<
(outs VecPredRegs128B:$Qx4),
(ins VecPredRegs128B:$Qx4in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Qx4 ^= vcmp.eq($Vu32.uw,$Vv32.uw)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Qx4 = $Qx4in";
}
def V6_extractw : HInst<
(outs IntRegs:$Rd32),
(ins VectorRegs:$Vu32, IntRegs:$Rs32),
"$Rd32 = vextract($Vu32,$Rs32)",
LD_tc_ld_SLOT0, TypeLD>, Enc_16601956, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10010010000;
let hasNewValue = 1;
let opNewValue = 0;
let isSolo = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_extractw_128B : HInst<
(outs IntRegs:$Rd32),
(ins VectorRegs128B:$Vu32, IntRegs:$Rs32),
"$Rd32 = vextract($Vu32,$Rs32)",
LD_tc_ld_SLOT0, TypeLD>, Enc_16601956, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10010010000;
let hasNewValue = 1;
let opNewValue = 0;
let isSolo = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_extractw_alt : HInst<
(outs IntRegs:$Rd32),
(ins VectorRegs:$Vu32, IntRegs:$Rs32),
"$Rd32.w = vextract($Vu32,$Rs32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_extractw_alt_128B : HInst<
(outs IntRegs:$Rd32),
(ins VectorRegs128B:$Vu32, IntRegs:$Rs32),
"$Rd32.w = vextract($Vu32,$Rs32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_hi : HInst<
(outs VectorRegs:$Vd32),
(ins VecDblRegs:$Vss32),
"$Vd32 = hi($Vss32)",
CVI_VA, TypeCVI_VA>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_hi_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VecDblRegs128B:$Vss32),
"$Vd32 = hi($Vss32)",
CVI_VA, TypeCVI_VA>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_ld0 : HInst<
(outs VectorRegs:$Vd32),
(ins IntRegs:$Rt32),
"$Vd32 = vmem($Rt32)",
PSEUDO, TypeCVI_VM_LD>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_ld0_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins IntRegs:$Rt32),
"$Vd32 = vmem($Rt32)",
PSEUDO, TypeCVI_VM_LD>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_ldnt0 : HInst<
(outs VectorRegs:$Vd32),
(ins IntRegs:$Rt32),
"$Vd32 = vmem($Rt32):nt",
PSEUDO, TypeCVI_VM_LD>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_ldnt0_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins IntRegs:$Rt32),
"$Vd32 = vmem($Rt32):nt",
PSEUDO, TypeCVI_VM_LD>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_ldu0 : HInst<
(outs VectorRegs:$Vd32),
(ins IntRegs:$Rt32),
"$Vd32 = vmemu($Rt32)",
PSEUDO, TypeCVI_VM_LD>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_ldu0_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins IntRegs:$Rt32),
"$Vd32 = vmemu($Rt32)",
PSEUDO, TypeCVI_VM_LD>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_lo : HInst<
(outs VectorRegs:$Vd32),
(ins VecDblRegs:$Vss32),
"$Vd32 = lo($Vss32)",
CVI_VA, TypeCVI_VA>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_lo_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VecDblRegs128B:$Vss32),
"$Vd32 = lo($Vss32)",
CVI_VA, TypeCVI_VA>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_lvsplatb : HInst<
(outs VectorRegs:$Vd32),
(ins IntRegs:$Rt32),
"$Vd32.b = vsplat($Rt32)",
CVI_VX, TypeCVI_VX>, Enc_9768377, Requires<[HasV62T,UseHVX]> {
let Inst{13-5} = 0b000000010;
let Inst{31-21} = 0b00011001110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_lvsplatb_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins IntRegs:$Rt32),
"$Vd32.b = vsplat($Rt32)",
CVI_VX, TypeCVI_VX>, Enc_9768377, Requires<[HasV62T,UseHVX]> {
let Inst{13-5} = 0b000000010;
let Inst{31-21} = 0b00011001110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_lvsplath : HInst<
(outs VectorRegs:$Vd32),
(ins IntRegs:$Rt32),
"$Vd32.h = vsplat($Rt32)",
CVI_VX, TypeCVI_VX>, Enc_9768377, Requires<[HasV62T,UseHVX]> {
let Inst{13-5} = 0b000000001;
let Inst{31-21} = 0b00011001110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_lvsplath_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins IntRegs:$Rt32),
"$Vd32.h = vsplat($Rt32)",
CVI_VX, TypeCVI_VX>, Enc_9768377, Requires<[HasV62T,UseHVX]> {
let Inst{13-5} = 0b000000001;
let Inst{31-21} = 0b00011001110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_lvsplatw : HInst<
(outs VectorRegs:$Vd32),
(ins IntRegs:$Rt32),
"$Vd32 = vsplat($Rt32)",
CVI_VX_LATE, TypeCVI_VX>, Enc_9768377, Requires<[HasV60T,UseHVX]> {
let Inst{13-5} = 0b000000001;
let Inst{31-21} = 0b00011001101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_lvsplatw_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins IntRegs:$Rt32),
"$Vd32 = vsplat($Rt32)",
CVI_VX_LATE, TypeCVI_VX>, Enc_9768377, Requires<[HasV60T,UseHVX]> {
let Inst{13-5} = 0b000000001;
let Inst{31-21} = 0b00011001101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_pred_and : HInst<
(outs VecPredRegs:$Qd4),
(ins VecPredRegs:$Qs4, VecPredRegs:$Qt4),
"$Qd4 = and($Qs4,$Qt4)",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_6091631, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b000000;
let Inst{13-10} = 0b0000;
let Inst{21-16} = 0b000011;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_pred_and_128B : HInst<
(outs VecPredRegs128B:$Qd4),
(ins VecPredRegs128B:$Qs4, VecPredRegs128B:$Qt4),
"$Qd4 = and($Qs4,$Qt4)",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_6091631, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b000000;
let Inst{13-10} = 0b0000;
let Inst{21-16} = 0b000011;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_pred_and_n : HInst<
(outs VecPredRegs:$Qd4),
(ins VecPredRegs:$Qs4, VecPredRegs:$Qt4),
"$Qd4 = and($Qs4,!$Qt4)",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_6091631, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b000101;
let Inst{13-10} = 0b0000;
let Inst{21-16} = 0b000011;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_pred_and_n_128B : HInst<
(outs VecPredRegs128B:$Qd4),
(ins VecPredRegs128B:$Qs4, VecPredRegs128B:$Qt4),
"$Qd4 = and($Qs4,!$Qt4)",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_6091631, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b000101;
let Inst{13-10} = 0b0000;
let Inst{21-16} = 0b000011;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_pred_not : HInst<
(outs VecPredRegs:$Qd4),
(ins VecPredRegs:$Qs4),
"$Qd4 = not($Qs4)",
CVI_VA, TypeCVI_VA>, Enc_4897205, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b000010;
let Inst{13-10} = 0b0000;
let Inst{31-16} = 0b0001111000000011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_pred_not_128B : HInst<
(outs VecPredRegs128B:$Qd4),
(ins VecPredRegs128B:$Qs4),
"$Qd4 = not($Qs4)",
CVI_VA, TypeCVI_VA>, Enc_4897205, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b000010;
let Inst{13-10} = 0b0000;
let Inst{31-16} = 0b0001111000000011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_pred_or : HInst<
(outs VecPredRegs:$Qd4),
(ins VecPredRegs:$Qs4, VecPredRegs:$Qt4),
"$Qd4 = or($Qs4,$Qt4)",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_6091631, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b000001;
let Inst{13-10} = 0b0000;
let Inst{21-16} = 0b000011;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_pred_or_128B : HInst<
(outs VecPredRegs128B:$Qd4),
(ins VecPredRegs128B:$Qs4, VecPredRegs128B:$Qt4),
"$Qd4 = or($Qs4,$Qt4)",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_6091631, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b000001;
let Inst{13-10} = 0b0000;
let Inst{21-16} = 0b000011;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_pred_or_n : HInst<
(outs VecPredRegs:$Qd4),
(ins VecPredRegs:$Qs4, VecPredRegs:$Qt4),
"$Qd4 = or($Qs4,!$Qt4)",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_6091631, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b000100;
let Inst{13-10} = 0b0000;
let Inst{21-16} = 0b000011;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_pred_or_n_128B : HInst<
(outs VecPredRegs128B:$Qd4),
(ins VecPredRegs128B:$Qs4, VecPredRegs128B:$Qt4),
"$Qd4 = or($Qs4,!$Qt4)",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_6091631, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b000100;
let Inst{13-10} = 0b0000;
let Inst{21-16} = 0b000011;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_pred_scalar2 : HInst<
(outs VecPredRegs:$Qd4),
(ins IntRegs:$Rt32),
"$Qd4 = vsetq($Rt32)",
CVI_VP_LONG, TypeCVI_VP>, Enc_12781442, Requires<[HasV60T,UseHVX]> {
let Inst{13-2} = 0b000000010001;
let Inst{31-21} = 0b00011001101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_pred_scalar2_128B : HInst<
(outs VecPredRegs128B:$Qd4),
(ins IntRegs:$Rt32),
"$Qd4 = vsetq($Rt32)",
CVI_VP_LONG, TypeCVI_VP>, Enc_12781442, Requires<[HasV60T,UseHVX]> {
let Inst{13-2} = 0b000000010001;
let Inst{31-21} = 0b00011001101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_pred_scalar2v2 : HInst<
(outs VecPredRegs:$Qd4),
(ins IntRegs:$Rt32),
"$Qd4 = vsetq2($Rt32)",
CVI_VP_LONG, TypeCVI_VP>, Enc_12781442, Requires<[HasV62T,UseHVX]> {
let Inst{13-2} = 0b000000010011;
let Inst{31-21} = 0b00011001101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_pred_scalar2v2_128B : HInst<
(outs VecPredRegs128B:$Qd4),
(ins IntRegs:$Rt32),
"$Qd4 = vsetq2($Rt32)",
CVI_VP_LONG, TypeCVI_VP>, Enc_12781442, Requires<[HasV62T,UseHVX]> {
let Inst{13-2} = 0b000000010011;
let Inst{31-21} = 0b00011001101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_pred_xor : HInst<
(outs VecPredRegs:$Qd4),
(ins VecPredRegs:$Qs4, VecPredRegs:$Qt4),
"$Qd4 = xor($Qs4,$Qt4)",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_6091631, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b000011;
let Inst{13-10} = 0b0000;
let Inst{21-16} = 0b000011;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_pred_xor_128B : HInst<
(outs VecPredRegs128B:$Qd4),
(ins VecPredRegs128B:$Qs4, VecPredRegs128B:$Qt4),
"$Qd4 = xor($Qs4,$Qt4)",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_6091631, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b000011;
let Inst{13-10} = 0b0000;
let Inst{21-16} = 0b000011;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_shuffeqh : HInst<
(outs VecPredRegs:$Qd4),
(ins VecPredRegs:$Qs4, VecPredRegs:$Qt4),
"$Qd4.b = vshuffe($Qs4.h,$Qt4.h)",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_6091631, Requires<[HasV62T,UseHVX]> {
let Inst{7-2} = 0b000110;
let Inst{13-10} = 0b0000;
let Inst{21-16} = 0b000011;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_shuffeqh_128B : HInst<
(outs VecPredRegs128B:$Qd4),
(ins VecPredRegs128B:$Qs4, VecPredRegs128B:$Qt4),
"$Qd4.b = vshuffe($Qs4.h,$Qt4.h)",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_6091631, Requires<[HasV62T,UseHVX]> {
let Inst{7-2} = 0b000110;
let Inst{13-10} = 0b0000;
let Inst{21-16} = 0b000011;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_shuffeqw : HInst<
(outs VecPredRegs:$Qd4),
(ins VecPredRegs:$Qs4, VecPredRegs:$Qt4),
"$Qd4.h = vshuffe($Qs4.w,$Qt4.w)",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_6091631, Requires<[HasV62T,UseHVX]> {
let Inst{7-2} = 0b000111;
let Inst{13-10} = 0b0000;
let Inst{21-16} = 0b000011;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_shuffeqw_128B : HInst<
(outs VecPredRegs128B:$Qd4),
(ins VecPredRegs128B:$Qs4, VecPredRegs128B:$Qt4),
"$Qd4.h = vshuffe($Qs4.w,$Qt4.w)",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_6091631, Requires<[HasV62T,UseHVX]> {
let Inst{7-2} = 0b000111;
let Inst{13-10} = 0b0000;
let Inst{21-16} = 0b000011;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_st0 : HInst<
(outs),
(ins IntRegs:$Rt32, VectorRegs:$Vs32),
"vmem($Rt32) = $Vs32",
PSEUDO, TypeCVI_VM_ST>, Requires<[HasV60T,UseHVX]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_st0_128B : HInst<
(outs),
(ins IntRegs:$Rt32, VectorRegs128B:$Vs32),
"vmem($Rt32) = $Vs32",
PSEUDO, TypeCVI_VM_ST>, Requires<[HasV60T,UseHVX]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_stn0 : HInst<
(outs),
(ins IntRegs:$Rt32, VectorRegs:$Os8),
"vmem($Rt32) = $Os8.new",
PSEUDO, TypeCVI_VM_ST>, Requires<[HasV60T,UseHVX]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let opNewValue = 1;
}
def V6_stn0_128B : HInst<
(outs),
(ins IntRegs:$Rt32, VectorRegs128B:$Os8),
"vmem($Rt32) = $Os8.new",
PSEUDO, TypeCVI_VM_ST>, Requires<[HasV60T,UseHVX]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let opNewValue = 1;
}
def V6_stnnt0 : HInst<
(outs),
(ins IntRegs:$Rt32, VectorRegs:$Os8),
"vmem($Rt32):nt = $Os8.new",
PSEUDO, TypeCVI_VM_ST>, Requires<[HasV60T,UseHVX]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let opNewValue = 1;
}
def V6_stnnt0_128B : HInst<
(outs),
(ins IntRegs:$Rt32, VectorRegs128B:$Os8),
"vmem($Rt32):nt = $Os8.new",
PSEUDO, TypeCVI_VM_ST>, Requires<[HasV60T,UseHVX]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let opNewValue = 1;
}
def V6_stnp0 : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rt32, VectorRegs:$Vs32),
"if (!$Pv4) vmem($Rt32) = $Vs32",
PSEUDO, TypeCVI_VM_ST>, Requires<[HasV60T,UseHVX]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_stnp0_128B : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rt32, VectorRegs128B:$Vs32),
"if (!$Pv4) vmem($Rt32) = $Vs32",
PSEUDO, TypeCVI_VM_ST>, Requires<[HasV60T,UseHVX]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_stnpnt0 : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rt32, VectorRegs:$Vs32),
"if (!$Pv4) vmem($Rt32):nt = $Vs32",
PSEUDO, TypeCVI_VM_ST>, Requires<[HasV60T,UseHVX]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_stnpnt0_128B : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rt32, VectorRegs128B:$Vs32),
"if (!$Pv4) vmem($Rt32):nt = $Vs32",
PSEUDO, TypeCVI_VM_ST>, Requires<[HasV60T,UseHVX]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_stnq0 : HInst<
(outs),
(ins VecPredRegs:$Qv4, IntRegs:$Rt32, VectorRegs:$Vs32),
"if (!$Qv4) vmem($Rt32) = $Vs32",
PSEUDO, TypeCVI_VM_ST>, Requires<[HasV60T,UseHVX]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_stnq0_128B : HInst<
(outs),
(ins VecPredRegs128B:$Qv4, IntRegs:$Rt32, VectorRegs128B:$Vs32),
"if (!$Qv4) vmem($Rt32) = $Vs32",
PSEUDO, TypeCVI_VM_ST>, Requires<[HasV60T,UseHVX]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_stnqnt0 : HInst<
(outs),
(ins VecPredRegs:$Qv4, IntRegs:$Rt32, VectorRegs:$Vs32),
"if (!$Qv4) vmem($Rt32):nt = $Vs32",
PSEUDO, TypeCVI_VM_ST>, Requires<[HasV60T,UseHVX]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_stnqnt0_128B : HInst<
(outs),
(ins VecPredRegs128B:$Qv4, IntRegs:$Rt32, VectorRegs128B:$Vs32),
"if (!$Qv4) vmem($Rt32):nt = $Vs32",
PSEUDO, TypeCVI_VM_ST>, Requires<[HasV60T,UseHVX]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_stnt0 : HInst<
(outs),
(ins IntRegs:$Rt32, VectorRegs:$Vs32),
"vmem($Rt32):nt = $Vs32",
PSEUDO, TypeCVI_VM_ST>, Requires<[HasV60T,UseHVX]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_stnt0_128B : HInst<
(outs),
(ins IntRegs:$Rt32, VectorRegs128B:$Vs32),
"vmem($Rt32):nt = $Vs32",
PSEUDO, TypeCVI_VM_ST>, Requires<[HasV60T,UseHVX]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_stp0 : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rt32, VectorRegs:$Vs32),
"if ($Pv4) vmem($Rt32) = $Vs32",
PSEUDO, TypeCVI_VM_ST>, Requires<[HasV60T,UseHVX]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_stp0_128B : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rt32, VectorRegs128B:$Vs32),
"if ($Pv4) vmem($Rt32) = $Vs32",
PSEUDO, TypeCVI_VM_ST>, Requires<[HasV60T,UseHVX]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_stpnt0 : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rt32, VectorRegs:$Vs32),
"if ($Pv4) vmem($Rt32):nt = $Vs32",
PSEUDO, TypeCVI_VM_ST>, Requires<[HasV60T,UseHVX]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_stpnt0_128B : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rt32, VectorRegs128B:$Vs32),
"if ($Pv4) vmem($Rt32):nt = $Vs32",
PSEUDO, TypeCVI_VM_ST>, Requires<[HasV60T,UseHVX]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_stq0 : HInst<
(outs),
(ins VecPredRegs:$Qv4, IntRegs:$Rt32, VectorRegs:$Vs32),
"if ($Qv4) vmem($Rt32) = $Vs32",
PSEUDO, TypeCVI_VM_ST>, Requires<[HasV60T,UseHVX]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_stq0_128B : HInst<
(outs),
(ins VecPredRegs128B:$Qv4, IntRegs:$Rt32, VectorRegs128B:$Vs32),
"if ($Qv4) vmem($Rt32) = $Vs32",
PSEUDO, TypeCVI_VM_ST>, Requires<[HasV60T,UseHVX]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_stqnt0 : HInst<
(outs),
(ins VecPredRegs:$Qv4, IntRegs:$Rt32, VectorRegs:$Vs32),
"if ($Qv4) vmem($Rt32):nt = $Vs32",
PSEUDO, TypeCVI_VM_ST>, Requires<[HasV60T,UseHVX]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_stqnt0_128B : HInst<
(outs),
(ins VecPredRegs128B:$Qv4, IntRegs:$Rt32, VectorRegs128B:$Vs32),
"if ($Qv4) vmem($Rt32):nt = $Vs32",
PSEUDO, TypeCVI_VM_ST>, Requires<[HasV60T,UseHVX]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_stu0 : HInst<
(outs),
(ins IntRegs:$Rt32, VectorRegs:$Vs32),
"vmemu($Rt32) = $Vs32",
PSEUDO, TypeCVI_VM_ST>, Requires<[HasV60T,UseHVX]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_stu0_128B : HInst<
(outs),
(ins IntRegs:$Rt32, VectorRegs128B:$Vs32),
"vmemu($Rt32) = $Vs32",
PSEUDO, TypeCVI_VM_ST>, Requires<[HasV60T,UseHVX]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_stunp0 : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rt32, VectorRegs:$Vs32),
"if (!$Pv4) vmemu($Rt32) = $Vs32",
PSEUDO, TypeCVI_VM_ST>, Requires<[HasV60T,UseHVX]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_stunp0_128B : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rt32, VectorRegs128B:$Vs32),
"if (!$Pv4) vmemu($Rt32) = $Vs32",
PSEUDO, TypeCVI_VM_ST>, Requires<[HasV60T,UseHVX]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_stup0 : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rt32, VectorRegs:$Vs32),
"if ($Pv4) vmemu($Rt32) = $Vs32",
PSEUDO, TypeCVI_VM_ST>, Requires<[HasV60T,UseHVX]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_stup0_128B : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rt32, VectorRegs128B:$Vs32),
"if ($Pv4) vmemu($Rt32) = $Vs32",
PSEUDO, TypeCVI_VM_ST>, Requires<[HasV60T,UseHVX]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vL32Ub_ai : HInst<
(outs VectorRegs:$Vd32),
(ins IntRegs:$Rt32, s4_6Imm:$Ii),
"$Vd32 = vmemu($Rt32+#$Ii)",
CVI_VM_VP_LDU, TypeCVI_VM_VP_LDU>, Enc_1244745, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b00101000000;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = Vector64Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vL32Ub_ai_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins IntRegs:$Rt32, s4_7Imm:$Ii),
"$Vd32 = vmemu($Rt32+#$Ii)",
CVI_VM_VP_LDU, TypeCVI_VM_VP_LDU>, Enc_8437395, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b00101000000;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = Vector128Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vL32Ub_pi : HInst<
(outs VectorRegs:$Vd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s3_6Imm:$Ii),
"$Vd32 = vmemu($Rx32++#$Ii)",
CVI_VM_VP_LDU, TypeCVI_VM_VP_LDU>, Enc_10039393, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-11} = 0b000;
let Inst{31-21} = 0b00101001000;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector64Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32Ub_pi_128B : HInst<
(outs VectorRegs128B:$Vd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s3_7Imm:$Ii),
"$Vd32 = vmemu($Rx32++#$Ii)",
CVI_VM_VP_LDU, TypeCVI_VM_VP_LDU>, Enc_11039423, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-11} = 0b000;
let Inst{31-21} = 0b00101001000;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector128Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32Ub_ppu : HInst<
(outs VectorRegs:$Vd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Vd32 = vmemu($Rx32++$Mu2)",
CVI_VM_VP_LDU, TypeCVI_VM_VP_LDU>, Enc_15949334, Requires<[HasV60T,UseHVX]> {
let Inst{12-5} = 0b00000111;
let Inst{31-21} = 0b00101011000;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector64Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32Ub_ppu_128B : HInst<
(outs VectorRegs128B:$Vd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Vd32 = vmemu($Rx32++$Mu2)",
CVI_VM_VP_LDU, TypeCVI_VM_VP_LDU>, Enc_15949334, Requires<[HasV60T,UseHVX]> {
let Inst{12-5} = 0b00000111;
let Inst{31-21} = 0b00101011000;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector128Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_ai : HInst<
(outs VectorRegs:$Vd32),
(ins IntRegs:$Rt32, s4_6Imm:$Ii),
"$Vd32 = vmem($Rt32+#$Ii)",
CVI_VM_LD, TypeCVI_VM_LD>, Enc_1244745, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b00101000000;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = Vector64Access;
let isCVLoad = 1;
let mayLoad = 1;
let isCVLoadable = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vL32b_ai_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins IntRegs:$Rt32, s4_7Imm:$Ii),
"$Vd32 = vmem($Rt32+#$Ii)",
CVI_VM_LD, TypeCVI_VM_LD>, Enc_8437395, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b00101000000;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = Vector128Access;
let isCVLoad = 1;
let mayLoad = 1;
let isCVLoadable = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vL32b_cur_ai : HInst<
(outs VectorRegs:$Vd32),
(ins IntRegs:$Rt32, s4_6Imm:$Ii),
"$Vd32.cur = vmem($Rt32+#$Ii)",
CVI_VM_LD, TypeCVI_VM_LD>, Enc_1244745, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b00101000000;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = Vector64Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vL32b_cur_ai_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins IntRegs:$Rt32, s4_7Imm:$Ii),
"$Vd32.cur = vmem($Rt32+#$Ii)",
CVI_VM_LD, TypeCVI_VM_LD>, Enc_8437395, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b00101000000;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = Vector128Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vL32b_cur_npred_ai : HInst<
(outs VectorRegs:$Vd32),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_6Imm:$Ii),
"if (!$Pv4) $Vd32.cur = vmem($Rt32+#$Ii)",
CVI_VM_CUR_LD, TypeCVI_VM_CUR_LD>, Enc_13338314, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{31-21} = 0b00101000100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = Vector64Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vL32b_cur_npred_ai_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_7Imm:$Ii),
"if (!$Pv4) $Vd32.cur = vmem($Rt32+#$Ii)",
CVI_VM_CUR_LD, TypeCVI_VM_CUR_LD>, Enc_738356, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{31-21} = 0b00101000100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = Vector128Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vL32b_cur_npred_pi : HInst<
(outs VectorRegs:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_6Imm:$Ii),
"if (!$Pv4) $Vd32.cur = vmem($Rx32++#$Ii)",
CVI_VM_CUR_LD, TypeCVI_VM_CUR_LD>, Enc_14560494, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector64Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_cur_npred_pi_128B : HInst<
(outs VectorRegs128B:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_7Imm:$Ii),
"if (!$Pv4) $Vd32.cur = vmem($Rx32++#$Ii)",
CVI_VM_CUR_LD, TypeCVI_VM_CUR_LD>, Enc_15560488, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector128Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_cur_npred_ppu : HInst<
(outs VectorRegs:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2),
"if (!$Pv4) $Vd32.cur = vmem($Rx32++$Mu2)",
CVI_VM_CUR_LD, TypeCVI_VM_CUR_LD>, Enc_3158657, Requires<[HasV62T,UseHVX]> {
let Inst{10-5} = 0b000101;
let Inst{31-21} = 0b00101011100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector64Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_cur_npred_ppu_128B : HInst<
(outs VectorRegs128B:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2),
"if (!$Pv4) $Vd32.cur = vmem($Rx32++$Mu2)",
CVI_VM_CUR_LD, TypeCVI_VM_CUR_LD>, Enc_3158657, Requires<[HasV62T,UseHVX]> {
let Inst{10-5} = 0b000101;
let Inst{31-21} = 0b00101011100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector128Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_cur_pi : HInst<
(outs VectorRegs:$Vd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s3_6Imm:$Ii),
"$Vd32.cur = vmem($Rx32++#$Ii)",
CVI_VM_LD, TypeCVI_VM_LD>, Enc_10039393, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-11} = 0b000;
let Inst{31-21} = 0b00101001000;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector64Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_cur_pi_128B : HInst<
(outs VectorRegs128B:$Vd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s3_7Imm:$Ii),
"$Vd32.cur = vmem($Rx32++#$Ii)",
CVI_VM_LD, TypeCVI_VM_LD>, Enc_11039423, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-11} = 0b000;
let Inst{31-21} = 0b00101001000;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector128Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_cur_ppu : HInst<
(outs VectorRegs:$Vd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Vd32.cur = vmem($Rx32++$Mu2)",
CVI_VM_CUR_LD, TypeCVI_VM_CUR_LD>, Enc_15949334, Requires<[HasV60T,UseHVX]> {
let Inst{12-5} = 0b00000001;
let Inst{31-21} = 0b00101011000;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector64Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_cur_ppu_128B : HInst<
(outs VectorRegs128B:$Vd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Vd32.cur = vmem($Rx32++$Mu2)",
CVI_VM_CUR_LD, TypeCVI_VM_CUR_LD>, Enc_15949334, Requires<[HasV60T,UseHVX]> {
let Inst{12-5} = 0b00000001;
let Inst{31-21} = 0b00101011000;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector128Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_cur_pred_ai : HInst<
(outs VectorRegs:$Vd32),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_6Imm:$Ii),
"if ($Pv4) $Vd32.cur = vmem($Rt32+#$Ii)",
CVI_VM_CUR_LD, TypeCVI_VM_CUR_LD>, Enc_13338314, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{31-21} = 0b00101000100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = Vector64Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vL32b_cur_pred_ai_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_7Imm:$Ii),
"if ($Pv4) $Vd32.cur = vmem($Rt32+#$Ii)",
CVI_VM_CUR_LD, TypeCVI_VM_CUR_LD>, Enc_738356, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{31-21} = 0b00101000100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = Vector128Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vL32b_cur_pred_pi : HInst<
(outs VectorRegs:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_6Imm:$Ii),
"if ($Pv4) $Vd32.cur = vmem($Rx32++#$Ii)",
CVI_VM_CUR_LD, TypeCOPROC_VMEM>, Enc_14560494, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector64Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_cur_pred_pi_128B : HInst<
(outs VectorRegs128B:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_7Imm:$Ii),
"if ($Pv4) $Vd32.cur = vmem($Rx32++#$Ii)",
CVI_VM_CUR_LD, TypeCOPROC_VMEM>, Enc_15560488, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector128Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_cur_pred_ppu : HInst<
(outs VectorRegs:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2),
"if ($Pv4) $Vd32.cur = vmem($Rx32++$Mu2)",
CVI_VM_CUR_LD, TypeCVI_VM_CUR_LD>, Enc_3158657, Requires<[HasV62T,UseHVX]> {
let Inst{10-5} = 0b000100;
let Inst{31-21} = 0b00101011100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector64Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_cur_pred_ppu_128B : HInst<
(outs VectorRegs128B:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2),
"if ($Pv4) $Vd32.cur = vmem($Rx32++$Mu2)",
CVI_VM_CUR_LD, TypeCVI_VM_CUR_LD>, Enc_3158657, Requires<[HasV62T,UseHVX]> {
let Inst{10-5} = 0b000100;
let Inst{31-21} = 0b00101011100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector128Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_npred_ai : HInst<
(outs VectorRegs:$Vd32),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_6Imm:$Ii),
"if (!$Pv4) $Vd32 = vmem($Rt32+#$Ii)",
CVI_VM_LD, TypeCVI_VM_LD>, Enc_13338314, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{31-21} = 0b00101000100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = Vector64Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vL32b_npred_ai_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_7Imm:$Ii),
"if (!$Pv4) $Vd32 = vmem($Rt32+#$Ii)",
CVI_VM_LD, TypeCVI_VM_LD>, Enc_738356, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{31-21} = 0b00101000100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = Vector128Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vL32b_npred_pi : HInst<
(outs VectorRegs:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_6Imm:$Ii),
"if (!$Pv4) $Vd32 = vmem($Rx32++#$Ii)",
CVI_VM_LD, TypeCVI_VM_LD>, Enc_14560494, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector64Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_npred_pi_128B : HInst<
(outs VectorRegs128B:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_7Imm:$Ii),
"if (!$Pv4) $Vd32 = vmem($Rx32++#$Ii)",
CVI_VM_LD, TypeCVI_VM_LD>, Enc_15560488, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector128Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_npred_ppu : HInst<
(outs VectorRegs:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2),
"if (!$Pv4) $Vd32 = vmem($Rx32++$Mu2)",
CVI_VM_LD, TypeCVI_VM_LD>, Enc_3158657, Requires<[HasV62T,UseHVX]> {
let Inst{10-5} = 0b000011;
let Inst{31-21} = 0b00101011100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector64Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_npred_ppu_128B : HInst<
(outs VectorRegs128B:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2),
"if (!$Pv4) $Vd32 = vmem($Rx32++$Mu2)",
CVI_VM_LD, TypeCVI_VM_LD>, Enc_3158657, Requires<[HasV62T,UseHVX]> {
let Inst{10-5} = 0b000011;
let Inst{31-21} = 0b00101011100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector128Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_ai : HInst<
(outs VectorRegs:$Vd32),
(ins IntRegs:$Rt32, s4_6Imm:$Ii),
"$Vd32 = vmem($Rt32+#$Ii):nt",
CVI_VM_LD, TypeCVI_VM_LD>, Enc_1244745, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b00101000010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = Vector64Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let isCVLoadable = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vL32b_nt_ai_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins IntRegs:$Rt32, s4_7Imm:$Ii),
"$Vd32 = vmem($Rt32+#$Ii):nt",
CVI_VM_LD, TypeCVI_VM_LD>, Enc_8437395, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b00101000010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = Vector128Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let isCVLoadable = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vL32b_nt_cur_ai : HInst<
(outs VectorRegs:$Vd32),
(ins IntRegs:$Rt32, s4_6Imm:$Ii),
"$Vd32.cur = vmem($Rt32+#$Ii):nt",
CVI_VM_LD, TypeCVI_VM_LD>, Enc_1244745, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b00101000010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = Vector64Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vL32b_nt_cur_ai_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins IntRegs:$Rt32, s4_7Imm:$Ii),
"$Vd32.cur = vmem($Rt32+#$Ii):nt",
CVI_VM_LD, TypeCVI_VM_LD>, Enc_8437395, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b00101000010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = Vector128Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vL32b_nt_cur_npred_ai : HInst<
(outs VectorRegs:$Vd32),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_6Imm:$Ii),
"if (!$Pv4) $Vd32.cur = vmem($Rt32+#$Ii):nt",
CVI_VM_CUR_LD, TypeCVI_VM_CUR_LD>, Enc_13338314, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{31-21} = 0b00101000110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = Vector64Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vL32b_nt_cur_npred_ai_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_7Imm:$Ii),
"if (!$Pv4) $Vd32.cur = vmem($Rt32+#$Ii):nt",
CVI_VM_CUR_LD, TypeCVI_VM_CUR_LD>, Enc_738356, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{31-21} = 0b00101000110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = Vector128Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vL32b_nt_cur_npred_pi : HInst<
(outs VectorRegs:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_6Imm:$Ii),
"if (!$Pv4) $Vd32.cur = vmem($Rx32++#$Ii):nt",
CVI_VM_CUR_LD, TypeCVI_VM_CUR_LD>, Enc_14560494, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector64Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_cur_npred_pi_128B : HInst<
(outs VectorRegs128B:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_7Imm:$Ii),
"if (!$Pv4) $Vd32.cur = vmem($Rx32++#$Ii):nt",
CVI_VM_CUR_LD, TypeCVI_VM_CUR_LD>, Enc_15560488, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector128Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_cur_npred_ppu : HInst<
(outs VectorRegs:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2),
"if (!$Pv4) $Vd32.cur = vmem($Rx32++$Mu2):nt",
CVI_VM_CUR_LD, TypeCVI_VM_CUR_LD>, Enc_3158657, Requires<[HasV62T,UseHVX]> {
let Inst{10-5} = 0b000101;
let Inst{31-21} = 0b00101011110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector64Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_cur_npred_ppu_128B : HInst<
(outs VectorRegs128B:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2),
"if (!$Pv4) $Vd32.cur = vmem($Rx32++$Mu2):nt",
CVI_VM_CUR_LD, TypeCVI_VM_CUR_LD>, Enc_3158657, Requires<[HasV62T,UseHVX]> {
let Inst{10-5} = 0b000101;
let Inst{31-21} = 0b00101011110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector128Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_cur_pi : HInst<
(outs VectorRegs:$Vd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s3_6Imm:$Ii),
"$Vd32.cur = vmem($Rx32++#$Ii):nt",
CVI_VM_LD, TypeCVI_VM_LD>, Enc_10039393, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-11} = 0b000;
let Inst{31-21} = 0b00101001010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector64Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_cur_pi_128B : HInst<
(outs VectorRegs128B:$Vd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s3_7Imm:$Ii),
"$Vd32.cur = vmem($Rx32++#$Ii):nt",
CVI_VM_LD, TypeCVI_VM_LD>, Enc_11039423, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-11} = 0b000;
let Inst{31-21} = 0b00101001010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector128Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_cur_ppu : HInst<
(outs VectorRegs:$Vd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Vd32.cur = vmem($Rx32++$Mu2):nt",
CVI_VM_CUR_LD, TypeCVI_VM_CUR_LD>, Enc_15949334, Requires<[HasV60T,UseHVX]> {
let Inst{12-5} = 0b00000001;
let Inst{31-21} = 0b00101011010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector64Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_cur_ppu_128B : HInst<
(outs VectorRegs128B:$Vd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Vd32.cur = vmem($Rx32++$Mu2):nt",
CVI_VM_CUR_LD, TypeCVI_VM_CUR_LD>, Enc_15949334, Requires<[HasV60T,UseHVX]> {
let Inst{12-5} = 0b00000001;
let Inst{31-21} = 0b00101011010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector128Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_cur_pred_ai : HInst<
(outs VectorRegs:$Vd32),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_6Imm:$Ii),
"if ($Pv4) $Vd32.cur = vmem($Rt32+#$Ii):nt",
CVI_VM_CUR_LD, TypeCVI_VM_CUR_LD>, Enc_13338314, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{31-21} = 0b00101000110;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = Vector64Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vL32b_nt_cur_pred_ai_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_7Imm:$Ii),
"if ($Pv4) $Vd32.cur = vmem($Rt32+#$Ii):nt",
CVI_VM_CUR_LD, TypeCVI_VM_CUR_LD>, Enc_738356, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{31-21} = 0b00101000110;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = Vector128Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vL32b_nt_cur_pred_pi : HInst<
(outs VectorRegs:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_6Imm:$Ii),
"if ($Pv4) $Vd32.cur = vmem($Rx32++#$Ii):nt",
CVI_VM_CUR_LD, TypeCVI_VM_CUR_LD>, Enc_14560494, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001110;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector64Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_cur_pred_pi_128B : HInst<
(outs VectorRegs128B:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_7Imm:$Ii),
"if ($Pv4) $Vd32.cur = vmem($Rx32++#$Ii):nt",
CVI_VM_CUR_LD, TypeCVI_VM_CUR_LD>, Enc_15560488, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001110;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector128Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_cur_pred_ppu : HInst<
(outs VectorRegs:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2),
"if ($Pv4) $Vd32.cur = vmem($Rx32++$Mu2):nt",
CVI_VM_CUR_LD, TypeCOPROC_VMEM>, Enc_3158657, Requires<[HasV62T,UseHVX]> {
let Inst{10-5} = 0b000100;
let Inst{31-21} = 0b00101011110;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector64Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_cur_pred_ppu_128B : HInst<
(outs VectorRegs128B:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2),
"if ($Pv4) $Vd32.cur = vmem($Rx32++$Mu2):nt",
CVI_VM_CUR_LD, TypeCOPROC_VMEM>, Enc_3158657, Requires<[HasV62T,UseHVX]> {
let Inst{10-5} = 0b000100;
let Inst{31-21} = 0b00101011110;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector128Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_npred_ai : HInst<
(outs VectorRegs:$Vd32),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_6Imm:$Ii),
"if (!$Pv4) $Vd32 = vmem($Rt32+#$Ii):nt",
CVI_VM_LD, TypeCVI_VM_LD>, Enc_13338314, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{31-21} = 0b00101000110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = Vector64Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vL32b_nt_npred_ai_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_7Imm:$Ii),
"if (!$Pv4) $Vd32 = vmem($Rt32+#$Ii):nt",
CVI_VM_LD, TypeCVI_VM_LD>, Enc_738356, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{31-21} = 0b00101000110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = Vector128Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vL32b_nt_npred_pi : HInst<
(outs VectorRegs:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_6Imm:$Ii),
"if (!$Pv4) $Vd32 = vmem($Rx32++#$Ii):nt",
CVI_VM_LD, TypeCVI_VM_LD>, Enc_14560494, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector64Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_npred_pi_128B : HInst<
(outs VectorRegs128B:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_7Imm:$Ii),
"if (!$Pv4) $Vd32 = vmem($Rx32++#$Ii):nt",
CVI_VM_LD, TypeCVI_VM_LD>, Enc_15560488, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector128Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_npred_ppu : HInst<
(outs VectorRegs:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2),
"if (!$Pv4) $Vd32 = vmem($Rx32++$Mu2):nt",
CVI_VM_LD, TypeCVI_VM_LD>, Enc_3158657, Requires<[HasV62T,UseHVX]> {
let Inst{10-5} = 0b000011;
let Inst{31-21} = 0b00101011110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector64Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_npred_ppu_128B : HInst<
(outs VectorRegs128B:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2),
"if (!$Pv4) $Vd32 = vmem($Rx32++$Mu2):nt",
CVI_VM_LD, TypeCVI_VM_LD>, Enc_3158657, Requires<[HasV62T,UseHVX]> {
let Inst{10-5} = 0b000011;
let Inst{31-21} = 0b00101011110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector128Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_pi : HInst<
(outs VectorRegs:$Vd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s3_6Imm:$Ii),
"$Vd32 = vmem($Rx32++#$Ii):nt",
CVI_VM_LD, TypeCVI_VM_LD>, Enc_10039393, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-11} = 0b000;
let Inst{31-21} = 0b00101001010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector64Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let isCVLoadable = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_pi_128B : HInst<
(outs VectorRegs128B:$Vd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s3_7Imm:$Ii),
"$Vd32 = vmem($Rx32++#$Ii):nt",
CVI_VM_LD, TypeCVI_VM_LD>, Enc_11039423, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-11} = 0b000;
let Inst{31-21} = 0b00101001010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector128Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let isCVLoadable = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_ppu : HInst<
(outs VectorRegs:$Vd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Vd32 = vmem($Rx32++$Mu2):nt",
CVI_VM_LD, TypeCVI_VM_LD>, Enc_15949334, Requires<[HasV60T,UseHVX]> {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b00101011010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector64Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let isCVLoadable = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_ppu_128B : HInst<
(outs VectorRegs128B:$Vd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Vd32 = vmem($Rx32++$Mu2):nt",
CVI_VM_LD, TypeCVI_VM_LD>, Enc_15949334, Requires<[HasV60T,UseHVX]> {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b00101011010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector128Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let isCVLoadable = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_pred_ai : HInst<
(outs VectorRegs:$Vd32),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_6Imm:$Ii),
"if ($Pv4) $Vd32 = vmem($Rt32+#$Ii):nt",
CVI_VM_LD, TypeCVI_VM_LD>, Enc_13338314, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{31-21} = 0b00101000110;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = Vector64Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vL32b_nt_pred_ai_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_7Imm:$Ii),
"if ($Pv4) $Vd32 = vmem($Rt32+#$Ii):nt",
CVI_VM_LD, TypeCVI_VM_LD>, Enc_738356, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{31-21} = 0b00101000110;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = Vector128Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vL32b_nt_pred_pi : HInst<
(outs VectorRegs:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_6Imm:$Ii),
"if ($Pv4) $Vd32 = vmem($Rx32++#$Ii):nt",
CVI_VM_LD, TypeCVI_VM_LD>, Enc_14560494, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001110;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector64Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_pred_pi_128B : HInst<
(outs VectorRegs128B:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_7Imm:$Ii),
"if ($Pv4) $Vd32 = vmem($Rx32++#$Ii):nt",
CVI_VM_LD, TypeCVI_VM_LD>, Enc_15560488, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001110;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector128Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_pred_ppu : HInst<
(outs VectorRegs:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2),
"if ($Pv4) $Vd32 = vmem($Rx32++$Mu2):nt",
CVI_VM_LD, TypeCVI_VM_LD>, Enc_3158657, Requires<[HasV62T,UseHVX]> {
let Inst{10-5} = 0b000010;
let Inst{31-21} = 0b00101011110;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector64Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_pred_ppu_128B : HInst<
(outs VectorRegs128B:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2),
"if ($Pv4) $Vd32 = vmem($Rx32++$Mu2):nt",
CVI_VM_LD, TypeCVI_VM_LD>, Enc_3158657, Requires<[HasV62T,UseHVX]> {
let Inst{10-5} = 0b000010;
let Inst{31-21} = 0b00101011110;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector128Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_tmp_ai : HInst<
(outs VectorRegs:$Vd32),
(ins IntRegs:$Rt32, s4_6Imm:$Ii),
"$Vd32.tmp = vmem($Rt32+#$Ii):nt",
CVI_VM_TMP_LD, TypeCVI_VM_TMP_LD>, Enc_1244745, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b00101000010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = Vector64Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vL32b_nt_tmp_ai_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins IntRegs:$Rt32, s4_7Imm:$Ii),
"$Vd32.tmp = vmem($Rt32+#$Ii):nt",
CVI_VM_TMP_LD, TypeCVI_VM_TMP_LD>, Enc_8437395, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b00101000010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = Vector128Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vL32b_nt_tmp_npred_ai : HInst<
(outs VectorRegs:$Vd32),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_6Imm:$Ii),
"if (!$Pv4) $Vd32.tmp = vmem($Rt32+#$Ii):nt",
CVI_VM_TMP_LD, TypeCVI_VM_TMP_LD>, Enc_13338314, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{31-21} = 0b00101000110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = Vector64Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vL32b_nt_tmp_npred_ai_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_7Imm:$Ii),
"if (!$Pv4) $Vd32.tmp = vmem($Rt32+#$Ii):nt",
CVI_VM_TMP_LD, TypeCVI_VM_TMP_LD>, Enc_738356, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{31-21} = 0b00101000110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = Vector128Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vL32b_nt_tmp_npred_pi : HInst<
(outs VectorRegs:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_6Imm:$Ii),
"if (!$Pv4) $Vd32.tmp = vmem($Rx32++#$Ii):nt",
CVI_VM_TMP_LD, TypeCVI_VM_TMP_LD>, Enc_14560494, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector64Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_tmp_npred_pi_128B : HInst<
(outs VectorRegs128B:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_7Imm:$Ii),
"if (!$Pv4) $Vd32.tmp = vmem($Rx32++#$Ii):nt",
CVI_VM_TMP_LD, TypeCVI_VM_TMP_LD>, Enc_15560488, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector128Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_tmp_npred_ppu : HInst<
(outs VectorRegs:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2),
"if (!$Pv4) $Vd32.tmp = vmem($Rx32++$Mu2):nt",
CVI_VM_TMP_LD, TypeCVI_VM_TMP_LD>, Enc_3158657, Requires<[HasV62T,UseHVX]> {
let Inst{10-5} = 0b000111;
let Inst{31-21} = 0b00101011110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector64Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_tmp_npred_ppu_128B : HInst<
(outs VectorRegs128B:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2),
"if (!$Pv4) $Vd32.tmp = vmem($Rx32++$Mu2):nt",
CVI_VM_TMP_LD, TypeCVI_VM_TMP_LD>, Enc_3158657, Requires<[HasV62T,UseHVX]> {
let Inst{10-5} = 0b000111;
let Inst{31-21} = 0b00101011110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector128Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_tmp_pi : HInst<
(outs VectorRegs:$Vd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s3_6Imm:$Ii),
"$Vd32.tmp = vmem($Rx32++#$Ii):nt",
CVI_VM_TMP_LD, TypeCVI_VM_TMP_LD>, Enc_10039393, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-11} = 0b000;
let Inst{31-21} = 0b00101001010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector64Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_tmp_pi_128B : HInst<
(outs VectorRegs128B:$Vd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s3_7Imm:$Ii),
"$Vd32.tmp = vmem($Rx32++#$Ii):nt",
CVI_VM_TMP_LD, TypeCVI_VM_TMP_LD>, Enc_11039423, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-11} = 0b000;
let Inst{31-21} = 0b00101001010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector128Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_tmp_ppu : HInst<
(outs VectorRegs:$Vd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Vd32.tmp = vmem($Rx32++$Mu2):nt",
CVI_VM_TMP_LD, TypeCVI_VM_TMP_LD>, Enc_15949334, Requires<[HasV60T,UseHVX]> {
let Inst{12-5} = 0b00000010;
let Inst{31-21} = 0b00101011010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector64Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_tmp_ppu_128B : HInst<
(outs VectorRegs128B:$Vd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Vd32.tmp = vmem($Rx32++$Mu2):nt",
CVI_VM_TMP_LD, TypeCVI_VM_TMP_LD>, Enc_15949334, Requires<[HasV60T,UseHVX]> {
let Inst{12-5} = 0b00000010;
let Inst{31-21} = 0b00101011010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector128Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_tmp_pred_ai : HInst<
(outs VectorRegs:$Vd32),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_6Imm:$Ii),
"if ($Pv4) $Vd32.tmp = vmem($Rt32+#$Ii):nt",
CVI_VM_TMP_LD, TypeCVI_VM_TMP_LD>, Enc_13338314, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{31-21} = 0b00101000110;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = Vector64Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vL32b_nt_tmp_pred_ai_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_7Imm:$Ii),
"if ($Pv4) $Vd32.tmp = vmem($Rt32+#$Ii):nt",
CVI_VM_TMP_LD, TypeCVI_VM_TMP_LD>, Enc_738356, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{31-21} = 0b00101000110;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = Vector128Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vL32b_nt_tmp_pred_pi : HInst<
(outs VectorRegs:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_6Imm:$Ii),
"if ($Pv4) $Vd32.tmp = vmem($Rx32++#$Ii):nt",
CVI_VM_TMP_LD, TypeCVI_VM_TMP_LD>, Enc_14560494, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001110;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector64Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_tmp_pred_pi_128B : HInst<
(outs VectorRegs128B:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_7Imm:$Ii),
"if ($Pv4) $Vd32.tmp = vmem($Rx32++#$Ii):nt",
CVI_VM_TMP_LD, TypeCVI_VM_TMP_LD>, Enc_15560488, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001110;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector128Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_tmp_pred_ppu : HInst<
(outs VectorRegs:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2),
"if ($Pv4) $Vd32.tmp = vmem($Rx32++$Mu2):nt",
CVI_VM_TMP_LD, TypeCVI_VM_TMP_LD>, Enc_3158657, Requires<[HasV62T,UseHVX]> {
let Inst{10-5} = 0b000110;
let Inst{31-21} = 0b00101011110;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector64Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_tmp_pred_ppu_128B : HInst<
(outs VectorRegs128B:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2),
"if ($Pv4) $Vd32.tmp = vmem($Rx32++$Mu2):nt",
CVI_VM_TMP_LD, TypeCVI_VM_TMP_LD>, Enc_3158657, Requires<[HasV62T,UseHVX]> {
let Inst{10-5} = 0b000110;
let Inst{31-21} = 0b00101011110;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector128Access;
let isCVLoad = 1;
let isNonTemporal = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_pi : HInst<
(outs VectorRegs:$Vd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s3_6Imm:$Ii),
"$Vd32 = vmem($Rx32++#$Ii)",
CVI_VM_LD, TypeCVI_VM_LD>, Enc_10039393, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-11} = 0b000;
let Inst{31-21} = 0b00101001000;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector64Access;
let isCVLoad = 1;
let mayLoad = 1;
let isCVLoadable = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_pi_128B : HInst<
(outs VectorRegs128B:$Vd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s3_7Imm:$Ii),
"$Vd32 = vmem($Rx32++#$Ii)",
CVI_VM_LD, TypeCVI_VM_LD>, Enc_11039423, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-11} = 0b000;
let Inst{31-21} = 0b00101001000;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector128Access;
let isCVLoad = 1;
let mayLoad = 1;
let isCVLoadable = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_ppu : HInst<
(outs VectorRegs:$Vd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Vd32 = vmem($Rx32++$Mu2)",
CVI_VM_LD, TypeCVI_VM_LD>, Enc_15949334, Requires<[HasV60T,UseHVX]> {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b00101011000;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector64Access;
let isCVLoad = 1;
let mayLoad = 1;
let isCVLoadable = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_ppu_128B : HInst<
(outs VectorRegs128B:$Vd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Vd32 = vmem($Rx32++$Mu2)",
CVI_VM_LD, TypeCVI_VM_LD>, Enc_15949334, Requires<[HasV60T,UseHVX]> {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b00101011000;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector128Access;
let isCVLoad = 1;
let mayLoad = 1;
let isCVLoadable = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_pred_ai : HInst<
(outs VectorRegs:$Vd32),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_6Imm:$Ii),
"if ($Pv4) $Vd32 = vmem($Rt32+#$Ii)",
CVI_VM_LD, TypeCVI_VM_LD>, Enc_13338314, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{31-21} = 0b00101000100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = Vector64Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vL32b_pred_ai_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_7Imm:$Ii),
"if ($Pv4) $Vd32 = vmem($Rt32+#$Ii)",
CVI_VM_LD, TypeCVI_VM_LD>, Enc_738356, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{31-21} = 0b00101000100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = Vector128Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vL32b_pred_pi : HInst<
(outs VectorRegs:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_6Imm:$Ii),
"if ($Pv4) $Vd32 = vmem($Rx32++#$Ii)",
CVI_VM_LD, TypeCVI_VM_LD>, Enc_14560494, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector64Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_pred_pi_128B : HInst<
(outs VectorRegs128B:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_7Imm:$Ii),
"if ($Pv4) $Vd32 = vmem($Rx32++#$Ii)",
CVI_VM_LD, TypeCVI_VM_LD>, Enc_15560488, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector128Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_pred_ppu : HInst<
(outs VectorRegs:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2),
"if ($Pv4) $Vd32 = vmem($Rx32++$Mu2)",
CVI_VM_LD, TypeCVI_VM_LD>, Enc_3158657, Requires<[HasV62T,UseHVX]> {
let Inst{10-5} = 0b000010;
let Inst{31-21} = 0b00101011100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector64Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_pred_ppu_128B : HInst<
(outs VectorRegs128B:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2),
"if ($Pv4) $Vd32 = vmem($Rx32++$Mu2)",
CVI_VM_LD, TypeCVI_VM_LD>, Enc_3158657, Requires<[HasV62T,UseHVX]> {
let Inst{10-5} = 0b000010;
let Inst{31-21} = 0b00101011100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector128Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_tmp_ai : HInst<
(outs VectorRegs:$Vd32),
(ins IntRegs:$Rt32, s4_6Imm:$Ii),
"$Vd32.tmp = vmem($Rt32+#$Ii)",
CVI_VM_TMP_LD, TypeCVI_VM_TMP_LD>, Enc_1244745, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b00101000000;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = Vector64Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vL32b_tmp_ai_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins IntRegs:$Rt32, s4_7Imm:$Ii),
"$Vd32.tmp = vmem($Rt32+#$Ii)",
CVI_VM_TMP_LD, TypeCVI_VM_TMP_LD>, Enc_8437395, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b00101000000;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = Vector128Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vL32b_tmp_npred_ai : HInst<
(outs VectorRegs:$Vd32),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_6Imm:$Ii),
"if (!$Pv4) $Vd32.tmp = vmem($Rt32+#$Ii)",
CVI_VM_TMP_LD, TypeCVI_VM_TMP_LD>, Enc_13338314, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{31-21} = 0b00101000100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = Vector64Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vL32b_tmp_npred_ai_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_7Imm:$Ii),
"if (!$Pv4) $Vd32.tmp = vmem($Rt32+#$Ii)",
CVI_VM_TMP_LD, TypeCVI_VM_TMP_LD>, Enc_738356, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{31-21} = 0b00101000100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = Vector128Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vL32b_tmp_npred_pi : HInst<
(outs VectorRegs:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_6Imm:$Ii),
"if (!$Pv4) $Vd32.tmp = vmem($Rx32++#$Ii)",
CVI_VM_TMP_LD, TypeCVI_VM_TMP_LD>, Enc_14560494, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector64Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_tmp_npred_pi_128B : HInst<
(outs VectorRegs128B:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_7Imm:$Ii),
"if (!$Pv4) $Vd32.tmp = vmem($Rx32++#$Ii)",
CVI_VM_TMP_LD, TypeCVI_VM_TMP_LD>, Enc_15560488, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector128Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_tmp_npred_ppu : HInst<
(outs VectorRegs:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2),
"if (!$Pv4) $Vd32.tmp = vmem($Rx32++$Mu2)",
CVI_VM_TMP_LD, TypeCVI_VM_TMP_LD>, Enc_3158657, Requires<[HasV62T,UseHVX]> {
let Inst{10-5} = 0b000111;
let Inst{31-21} = 0b00101011100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector64Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_tmp_npred_ppu_128B : HInst<
(outs VectorRegs128B:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2),
"if (!$Pv4) $Vd32.tmp = vmem($Rx32++$Mu2)",
CVI_VM_TMP_LD, TypeCVI_VM_TMP_LD>, Enc_3158657, Requires<[HasV62T,UseHVX]> {
let Inst{10-5} = 0b000111;
let Inst{31-21} = 0b00101011100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector128Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_tmp_pi : HInst<
(outs VectorRegs:$Vd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s3_6Imm:$Ii),
"$Vd32.tmp = vmem($Rx32++#$Ii)",
CVI_VM_TMP_LD, TypeCVI_VM_TMP_LD>, Enc_10039393, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-11} = 0b000;
let Inst{31-21} = 0b00101001000;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector64Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_tmp_pi_128B : HInst<
(outs VectorRegs128B:$Vd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s3_7Imm:$Ii),
"$Vd32.tmp = vmem($Rx32++#$Ii)",
CVI_VM_TMP_LD, TypeCVI_VM_TMP_LD>, Enc_11039423, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-11} = 0b000;
let Inst{31-21} = 0b00101001000;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector128Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_tmp_ppu : HInst<
(outs VectorRegs:$Vd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Vd32.tmp = vmem($Rx32++$Mu2)",
CVI_VM_TMP_LD, TypeCVI_VM_TMP_LD>, Enc_15949334, Requires<[HasV60T,UseHVX]> {
let Inst{12-5} = 0b00000010;
let Inst{31-21} = 0b00101011000;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector64Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_tmp_ppu_128B : HInst<
(outs VectorRegs128B:$Vd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Vd32.tmp = vmem($Rx32++$Mu2)",
CVI_VM_TMP_LD, TypeCVI_VM_TMP_LD>, Enc_15949334, Requires<[HasV60T,UseHVX]> {
let Inst{12-5} = 0b00000010;
let Inst{31-21} = 0b00101011000;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector128Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_tmp_pred_ai : HInst<
(outs VectorRegs:$Vd32),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_6Imm:$Ii),
"if ($Pv4) $Vd32.tmp = vmem($Rt32+#$Ii)",
CVI_VM_TMP_LD, TypeCVI_VM_TMP_LD>, Enc_13338314, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{31-21} = 0b00101000100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = Vector64Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vL32b_tmp_pred_ai_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_7Imm:$Ii),
"if ($Pv4) $Vd32.tmp = vmem($Rt32+#$Ii)",
CVI_VM_TMP_LD, TypeCVI_VM_TMP_LD>, Enc_738356, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{31-21} = 0b00101000100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = Vector128Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vL32b_tmp_pred_pi : HInst<
(outs VectorRegs:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_6Imm:$Ii),
"if ($Pv4) $Vd32.tmp = vmem($Rx32++#$Ii)",
CVI_VM_TMP_LD, TypeCVI_VM_TMP_LD>, Enc_14560494, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector64Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_tmp_pred_pi_128B : HInst<
(outs VectorRegs128B:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_7Imm:$Ii),
"if ($Pv4) $Vd32.tmp = vmem($Rx32++#$Ii)",
CVI_VM_TMP_LD, TypeCVI_VM_TMP_LD>, Enc_15560488, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector128Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_tmp_pred_ppu : HInst<
(outs VectorRegs:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2),
"if ($Pv4) $Vd32.tmp = vmem($Rx32++$Mu2)",
CVI_VM_TMP_LD, TypeCVI_VM_TMP_LD>, Enc_3158657, Requires<[HasV62T,UseHVX]> {
let Inst{10-5} = 0b000110;
let Inst{31-21} = 0b00101011100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector64Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_tmp_pred_ppu_128B : HInst<
(outs VectorRegs128B:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2),
"if ($Pv4) $Vd32.tmp = vmem($Rx32++$Mu2)",
CVI_VM_TMP_LD, TypeCVI_VM_TMP_LD>, Enc_3158657, Requires<[HasV62T,UseHVX]> {
let Inst{10-5} = 0b000110;
let Inst{31-21} = 0b00101011100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = Vector128Access;
let isCVLoad = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32Ub_ai : HInst<
(outs),
(ins IntRegs:$Rt32, s4_6Imm:$Ii, VectorRegs:$Vs32),
"vmemu($Rt32+#$Ii) = $Vs32",
CVI_VM_STU, TypeCVI_VM_STU>, Enc_6923828, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-5} = 0b111;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b00101000001;
let addrMode = BaseImmOffset;
let accessSize = Vector64Access;
let mayStore = 1;
let BaseOpcode = "V6_vS32Ub_ai";
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vS32Ub_ai_128B : HInst<
(outs),
(ins IntRegs:$Rt32, s4_7Imm:$Ii, VectorRegs128B:$Vs32),
"vmemu($Rt32+#$Ii) = $Vs32",
CVI_VM_STU, TypeCVI_VM_STU>, Enc_5757366, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-5} = 0b111;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b00101000001;
let addrMode = BaseImmOffset;
let accessSize = Vector128Access;
let mayStore = 1;
let BaseOpcode = "V6_vS32Ub_ai_128B";
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vS32Ub_npred_ai : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_6Imm:$Ii, VectorRegs:$Vs32),
"if (!$Pv4) vmemu($Rt32+#$Ii) = $Vs32",
CVI_VM_STU, TypeCVI_VM_STU>, Enc_10075393, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-5} = 0b111;
let Inst{31-21} = 0b00101000101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = Vector64Access;
let mayStore = 1;
let BaseOpcode = "V6_vS32Ub_ai";
let DecoderNamespace = "EXT_mmvec";
}
def V6_vS32Ub_npred_ai_128B : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_7Imm:$Ii, VectorRegs128B:$Vs32),
"if (!$Pv4) vmemu($Rt32+#$Ii) = $Vs32",
CVI_VM_STU, TypeCVI_VM_STU>, Enc_9470751, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-5} = 0b111;
let Inst{31-21} = 0b00101000101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = Vector128Access;
let mayStore = 1;
let BaseOpcode = "V6_vS32Ub_ai_128B";
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vS32Ub_npred_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_6Imm:$Ii, VectorRegs:$Vs32),
"if (!$Pv4) vmemu($Rx32++#$Ii) = $Vs32",
CVI_VM_STU, TypeCVI_VM_STU>, Enc_15459921, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = Vector64Access;
let mayStore = 1;
let BaseOpcode = "V6_vS32Ub_pi";
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32Ub_npred_pi_128B : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_7Imm:$Ii, VectorRegs128B:$Vs32),
"if (!$Pv4) vmemu($Rx32++#$Ii) = $Vs32",
CVI_VM_STU, TypeCVI_VM_STU>, Enc_14459927, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = Vector128Access;
let mayStore = 1;
let BaseOpcode = "V6_vS32Ub_pi_128B";
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32Ub_npred_ppu : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2, VectorRegs:$Vs32),
"if (!$Pv4) vmemu($Rx32++$Mu2) = $Vs32",
CVI_VM_STU, TypeCVI_VM_STU>, Enc_15733946, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{10-5} = 0b000111;
let Inst{31-21} = 0b00101011101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = Vector64Access;
let mayStore = 1;
let BaseOpcode = "V6_vS32Ub_ppu";
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32Ub_npred_ppu_128B : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2, VectorRegs128B:$Vs32),
"if (!$Pv4) vmemu($Rx32++$Mu2) = $Vs32",
CVI_VM_STU, TypeCVI_VM_STU>, Enc_15733946, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{10-5} = 0b000111;
let Inst{31-21} = 0b00101011101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = Vector128Access;
let mayStore = 1;
let BaseOpcode = "V6_vS32Ub_ppu_128B";
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32Ub_pi : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s3_6Imm:$Ii, VectorRegs:$Vs32),
"vmemu($Rx32++#$Ii) = $Vs32",
CVI_VM_STU, TypeCVI_VM_STU>, Enc_3296020, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-5} = 0b111;
let Inst{13-11} = 0b000;
let Inst{31-21} = 0b00101001001;
let addrMode = PostInc;
let accessSize = Vector64Access;
let mayStore = 1;
let BaseOpcode = "V6_vS32Ub_pi";
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32Ub_pi_128B : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s3_7Imm:$Ii, VectorRegs128B:$Vs32),
"vmemu($Rx32++#$Ii) = $Vs32",
CVI_VM_STU, TypeCVI_VM_STU>, Enc_2296022, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-5} = 0b111;
let Inst{13-11} = 0b000;
let Inst{31-21} = 0b00101001001;
let addrMode = PostInc;
let accessSize = Vector128Access;
let mayStore = 1;
let BaseOpcode = "V6_vS32Ub_pi_128B";
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32Ub_ppu : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, VectorRegs:$Vs32),
"vmemu($Rx32++$Mu2) = $Vs32",
CVI_VM_STU, TypeCVI_VM_STU>, Enc_11281763, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{12-5} = 0b00000111;
let Inst{31-21} = 0b00101011001;
let addrMode = PostInc;
let accessSize = Vector64Access;
let mayStore = 1;
let BaseOpcode = "V6_vS32Ub_ppu";
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32Ub_ppu_128B : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, VectorRegs128B:$Vs32),
"vmemu($Rx32++$Mu2) = $Vs32",
CVI_VM_STU, TypeCVI_VM_STU>, Enc_11281763, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{12-5} = 0b00000111;
let Inst{31-21} = 0b00101011001;
let addrMode = PostInc;
let accessSize = Vector128Access;
let mayStore = 1;
let BaseOpcode = "V6_vS32Ub_ppu_128B";
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32Ub_pred_ai : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_6Imm:$Ii, VectorRegs:$Vs32),
"if ($Pv4) vmemu($Rt32+#$Ii) = $Vs32",
CVI_VM_STU, TypeCVI_VM_STU>, Enc_10075393, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-5} = 0b110;
let Inst{31-21} = 0b00101000101;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = Vector64Access;
let mayStore = 1;
let BaseOpcode = "V6_vS32Ub_ai";
let DecoderNamespace = "EXT_mmvec";
}
def V6_vS32Ub_pred_ai_128B : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_7Imm:$Ii, VectorRegs128B:$Vs32),
"if ($Pv4) vmemu($Rt32+#$Ii) = $Vs32",
CVI_VM_STU, TypeCVI_VM_STU>, Enc_9470751, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-5} = 0b110;
let Inst{31-21} = 0b00101000101;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = Vector128Access;
let mayStore = 1;
let BaseOpcode = "V6_vS32Ub_ai_128B";
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vS32Ub_pred_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_6Imm:$Ii, VectorRegs:$Vs32),
"if ($Pv4) vmemu($Rx32++#$Ii) = $Vs32",
CVI_VM_STU, TypeCVI_VM_STU>, Enc_15459921, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001101;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = Vector64Access;
let mayStore = 1;
let BaseOpcode = "V6_vS32Ub_pi";
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32Ub_pred_pi_128B : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_7Imm:$Ii, VectorRegs128B:$Vs32),
"if ($Pv4) vmemu($Rx32++#$Ii) = $Vs32",
CVI_VM_STU, TypeCVI_VM_STU>, Enc_14459927, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001101;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = Vector128Access;
let mayStore = 1;
let BaseOpcode = "V6_vS32Ub_pi_128B";
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32Ub_pred_ppu : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2, VectorRegs:$Vs32),
"if ($Pv4) vmemu($Rx32++$Mu2) = $Vs32",
CVI_VM_STU, TypeCVI_VM_STU>, Enc_15733946, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{10-5} = 0b000110;
let Inst{31-21} = 0b00101011101;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = Vector64Access;
let mayStore = 1;
let BaseOpcode = "V6_vS32Ub_ppu";
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32Ub_pred_ppu_128B : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2, VectorRegs128B:$Vs32),
"if ($Pv4) vmemu($Rx32++$Mu2) = $Vs32",
CVI_VM_STU, TypeCVI_VM_STU>, Enc_15733946, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{10-5} = 0b000110;
let Inst{31-21} = 0b00101011101;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = Vector128Access;
let mayStore = 1;
let BaseOpcode = "V6_vS32Ub_ppu_128B";
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_ai : HInst<
(outs),
(ins IntRegs:$Rt32, s4_6Imm:$Ii, VectorRegs:$Vs32),
"vmem($Rt32+#$Ii) = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_6923828, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-5} = 0b000;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b00101000001;
let addrMode = BaseImmOffset;
let accessSize = Vector64Access;
let mayStore = 1;
let BaseOpcode = "V6_vS32b_ai";
let isNVStorable = 1;
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vS32b_ai_128B : HInst<
(outs),
(ins IntRegs:$Rt32, s4_7Imm:$Ii, VectorRegs128B:$Vs32),
"vmem($Rt32+#$Ii) = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_5757366, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-5} = 0b000;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b00101000001;
let addrMode = BaseImmOffset;
let accessSize = Vector128Access;
let mayStore = 1;
let BaseOpcode = "V6_vS32b_ai_128B";
let isNVStorable = 1;
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vS32b_new_ai : HInst<
(outs),
(ins IntRegs:$Rt32, s4_6Imm:$Ii, VectorRegs:$Os8),
"vmem($Rt32+#$Ii) = $Os8.new",
CVI_VM_NEW_ST, TypeCVI_VM_NEW_ST>, Enc_6608821, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-3} = 0b00100;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b00101000001;
let addrMode = BaseImmOffset;
let accessSize = Vector64Access;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let BaseOpcode = "V6_vS32b_ai";
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
let opNewValue = 2;
}
def V6_vS32b_new_ai_128B : HInst<
(outs),
(ins IntRegs:$Rt32, s4_7Imm:$Ii, VectorRegs128B:$Os8),
"vmem($Rt32+#$Ii) = $Os8.new",
CVI_VM_NEW_ST, TypeCVI_VM_NEW_ST>, Enc_2152247, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-3} = 0b00100;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b00101000001;
let addrMode = BaseImmOffset;
let accessSize = Vector128Access;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let BaseOpcode = "V6_vS32b_ai_128B";
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let opNewValue = 2;
}
def V6_vS32b_new_npred_ai : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_6Imm:$Ii, VectorRegs:$Os8),
"if (!$Pv4) vmem($Rt32+#$Ii) = $Os8.new",
CVI_VM_NEW_ST, TypeCVI_VM_NEW_ST>, Enc_9372046, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-3} = 0b01101;
let Inst{31-21} = 0b00101000101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = Vector64Access;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let BaseOpcode = "V6_vS32b_ai";
let DecoderNamespace = "EXT_mmvec";
let opNewValue = 3;
}
def V6_vS32b_new_npred_ai_128B : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_7Imm:$Ii, VectorRegs128B:$Os8),
"if (!$Pv4) vmem($Rt32+#$Ii) = $Os8.new",
CVI_VM_NEW_ST, TypeCVI_VM_NEW_ST>, Enc_13937564, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-3} = 0b01101;
let Inst{31-21} = 0b00101000101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = Vector128Access;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let BaseOpcode = "V6_vS32b_ai_128B";
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let opNewValue = 3;
}
def V6_vS32b_new_npred_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_6Imm:$Ii, VectorRegs:$Os8),
"if (!$Pv4) vmem($Rx32++#$Ii) = $Os8.new",
CVI_VM_NEW_ST, TypeCVI_VM_NEW_ST>, Enc_3735566, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-3} = 0b01101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = Vector64Access;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let BaseOpcode = "V6_vS32b_pi";
let DecoderNamespace = "EXT_mmvec";
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_new_npred_pi_128B : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_7Imm:$Ii, VectorRegs128B:$Os8),
"if (!$Pv4) vmem($Rx32++#$Ii) = $Os8.new",
CVI_VM_NEW_ST, TypeCVI_VM_NEW_ST>, Enc_2735552, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-3} = 0b01101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = Vector128Access;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let BaseOpcode = "V6_vS32b_pi_128B";
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_new_npred_ppu : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2, VectorRegs:$Os8),
"if (!$Pv4) vmem($Rx32++$Mu2) = $Os8.new",
CVI_VM_NEW_ST, TypeCVI_VM_NEW_ST>, Enc_8498433, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{10-3} = 0b00001101;
let Inst{31-21} = 0b00101011101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = Vector64Access;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let BaseOpcode = "V6_vS32b_ppu";
let DecoderNamespace = "EXT_mmvec";
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_new_npred_ppu_128B : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2, VectorRegs128B:$Os8),
"if (!$Pv4) vmem($Rx32++$Mu2) = $Os8.new",
CVI_VM_NEW_ST, TypeCVI_VM_NEW_ST>, Enc_8498433, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{10-3} = 0b00001101;
let Inst{31-21} = 0b00101011101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = Vector128Access;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let BaseOpcode = "V6_vS32b_ppu_128B";
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_new_pi : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s3_6Imm:$Ii, VectorRegs:$Os8),
"vmem($Rx32++#$Ii) = $Os8.new",
CVI_VM_NEW_ST, TypeCVI_VM_NEW_ST>, Enc_12244921, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-3} = 0b00100;
let Inst{13-11} = 0b000;
let Inst{31-21} = 0b00101001001;
let addrMode = PostInc;
let accessSize = Vector64Access;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let BaseOpcode = "V6_vS32b_pi";
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
let opNewValue = 3;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_new_pi_128B : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s3_7Imm:$Ii, VectorRegs128B:$Os8),
"vmem($Rx32++#$Ii) = $Os8.new",
CVI_VM_NEW_ST, TypeCVI_VM_NEW_ST>, Enc_11244923, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-3} = 0b00100;
let Inst{13-11} = 0b000;
let Inst{31-21} = 0b00101001001;
let addrMode = PostInc;
let accessSize = Vector128Access;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let BaseOpcode = "V6_vS32b_pi_128B";
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let opNewValue = 3;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_new_ppu : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, VectorRegs:$Os8),
"vmem($Rx32++$Mu2) = $Os8.new",
CVI_VM_NEW_ST, TypeCVI_VM_NEW_ST>, Enc_1589406, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{12-3} = 0b0000000100;
let Inst{31-21} = 0b00101011001;
let addrMode = PostInc;
let accessSize = Vector64Access;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let BaseOpcode = "V6_vS32b_ppu";
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
let opNewValue = 3;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_new_ppu_128B : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, VectorRegs128B:$Os8),
"vmem($Rx32++$Mu2) = $Os8.new",
CVI_VM_NEW_ST, TypeCVI_VM_NEW_ST>, Enc_1589406, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{12-3} = 0b0000000100;
let Inst{31-21} = 0b00101011001;
let addrMode = PostInc;
let accessSize = Vector128Access;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let BaseOpcode = "V6_vS32b_ppu_128B";
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let opNewValue = 3;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_new_pred_ai : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_6Imm:$Ii, VectorRegs:$Os8),
"if ($Pv4) vmem($Rt32+#$Ii) = $Os8.new",
CVI_VM_NEW_ST, TypeCVI_VM_NEW_ST>, Enc_9372046, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-3} = 0b01000;
let Inst{31-21} = 0b00101000101;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = Vector64Access;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let BaseOpcode = "V6_vS32b_ai";
let DecoderNamespace = "EXT_mmvec";
let opNewValue = 3;
}
def V6_vS32b_new_pred_ai_128B : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_7Imm:$Ii, VectorRegs128B:$Os8),
"if ($Pv4) vmem($Rt32+#$Ii) = $Os8.new",
CVI_VM_NEW_ST, TypeCVI_VM_NEW_ST>, Enc_13937564, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-3} = 0b01000;
let Inst{31-21} = 0b00101000101;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = Vector128Access;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let BaseOpcode = "V6_vS32b_ai_128B";
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let opNewValue = 3;
}
def V6_vS32b_new_pred_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_6Imm:$Ii, VectorRegs:$Os8),
"if ($Pv4) vmem($Rx32++#$Ii) = $Os8.new",
CVI_VM_NEW_ST, TypeCVI_VM_NEW_ST>, Enc_3735566, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-3} = 0b01000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001101;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = Vector64Access;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let BaseOpcode = "V6_vS32b_pi";
let DecoderNamespace = "EXT_mmvec";
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_new_pred_pi_128B : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_7Imm:$Ii, VectorRegs128B:$Os8),
"if ($Pv4) vmem($Rx32++#$Ii) = $Os8.new",
CVI_VM_NEW_ST, TypeCVI_VM_NEW_ST>, Enc_2735552, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-3} = 0b01000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001101;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = Vector128Access;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let BaseOpcode = "V6_vS32b_pi_128B";
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_new_pred_ppu : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2, VectorRegs:$Os8),
"if ($Pv4) vmem($Rx32++$Mu2) = $Os8.new",
CVI_VM_NEW_ST, TypeCVI_VM_NEW_ST>, Enc_8498433, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{10-3} = 0b00001000;
let Inst{31-21} = 0b00101011101;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = Vector64Access;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let BaseOpcode = "V6_vS32b_ppu";
let DecoderNamespace = "EXT_mmvec";
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_new_pred_ppu_128B : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2, VectorRegs128B:$Os8),
"if ($Pv4) vmem($Rx32++$Mu2) = $Os8.new",
CVI_VM_NEW_ST, TypeCVI_VM_NEW_ST>, Enc_8498433, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{10-3} = 0b00001000;
let Inst{31-21} = 0b00101011101;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = Vector128Access;
let isNVStore = 1;
let mayStore = 1;
let isNewValue = 1;
let BaseOpcode = "V6_vS32b_ppu_128B";
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_npred_ai : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_6Imm:$Ii, VectorRegs:$Vs32),
"if (!$Pv4) vmem($Rt32+#$Ii) = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_10075393, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-5} = 0b001;
let Inst{31-21} = 0b00101000101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = Vector64Access;
let mayStore = 1;
let BaseOpcode = "V6_vS32b_ai";
let isNVStorable = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vS32b_npred_ai_128B : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_7Imm:$Ii, VectorRegs128B:$Vs32),
"if (!$Pv4) vmem($Rt32+#$Ii) = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_9470751, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-5} = 0b001;
let Inst{31-21} = 0b00101000101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = Vector128Access;
let mayStore = 1;
let BaseOpcode = "V6_vS32b_ai_128B";
let isNVStorable = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vS32b_npred_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_6Imm:$Ii, VectorRegs:$Vs32),
"if (!$Pv4) vmem($Rx32++#$Ii) = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_15459921, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = Vector64Access;
let mayStore = 1;
let BaseOpcode = "V6_vS32b_pi";
let isNVStorable = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_npred_pi_128B : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_7Imm:$Ii, VectorRegs128B:$Vs32),
"if (!$Pv4) vmem($Rx32++#$Ii) = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_14459927, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = Vector128Access;
let mayStore = 1;
let BaseOpcode = "V6_vS32b_pi_128B";
let isNVStorable = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_npred_ppu : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2, VectorRegs:$Vs32),
"if (!$Pv4) vmem($Rx32++$Mu2) = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_15733946, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{10-5} = 0b000001;
let Inst{31-21} = 0b00101011101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = Vector64Access;
let mayStore = 1;
let BaseOpcode = "V6_vS32b_ppu";
let isNVStorable = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_npred_ppu_128B : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2, VectorRegs128B:$Vs32),
"if (!$Pv4) vmem($Rx32++$Mu2) = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_15733946, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{10-5} = 0b000001;
let Inst{31-21} = 0b00101011101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = Vector128Access;
let mayStore = 1;
let BaseOpcode = "V6_vS32b_ppu_128B";
let isNVStorable = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nqpred_ai : HInst<
(outs),
(ins VecPredRegs:$Qv4, IntRegs:$Rt32, s4_6Imm:$Ii, VectorRegs:$Vs32),
"if (!$Qv4) vmem($Rt32+#$Ii) = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_16279406, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{31-21} = 0b00101000100;
let addrMode = BaseImmOffset;
let accessSize = Vector64Access;
let mayStore = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vS32b_nqpred_ai_128B : HInst<
(outs),
(ins VecPredRegs128B:$Qv4, IntRegs:$Rt32, s4_7Imm:$Ii, VectorRegs128B:$Vs32),
"if (!$Qv4) vmem($Rt32+#$Ii) = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_2703240, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{31-21} = 0b00101000100;
let addrMode = BaseImmOffset;
let accessSize = Vector128Access;
let mayStore = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vS32b_nqpred_pi : HInst<
(outs IntRegs:$Rx32),
(ins VecPredRegs:$Qv4, IntRegs:$Rx32in, s3_6Imm:$Ii, VectorRegs:$Vs32),
"if (!$Qv4) vmem($Rx32++#$Ii) = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_12397062, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001100;
let addrMode = PostInc;
let accessSize = Vector64Access;
let mayStore = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nqpred_pi_128B : HInst<
(outs IntRegs:$Rx32),
(ins VecPredRegs128B:$Qv4, IntRegs:$Rx32in, s3_7Imm:$Ii, VectorRegs128B:$Vs32),
"if (!$Qv4) vmem($Rx32++#$Ii) = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_13397056, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001100;
let addrMode = PostInc;
let accessSize = Vector128Access;
let mayStore = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nqpred_ppu : HInst<
(outs IntRegs:$Rx32),
(ins VecPredRegs:$Qv4, IntRegs:$Rx32in, ModRegs:$Mu2, VectorRegs:$Vs32),
"if (!$Qv4) vmem($Rx32++$Mu2) = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_13425035, Requires<[HasV60T,UseHVX]> {
let Inst{10-5} = 0b000001;
let Inst{31-21} = 0b00101011100;
let addrMode = PostInc;
let accessSize = Vector64Access;
let mayStore = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nqpred_ppu_128B : HInst<
(outs IntRegs:$Rx32),
(ins VecPredRegs128B:$Qv4, IntRegs:$Rx32in, ModRegs:$Mu2, VectorRegs128B:$Vs32),
"if (!$Qv4) vmem($Rx32++$Mu2) = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_13425035, Requires<[HasV60T,UseHVX]> {
let Inst{10-5} = 0b000001;
let Inst{31-21} = 0b00101011100;
let addrMode = PostInc;
let accessSize = Vector128Access;
let mayStore = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nt_ai : HInst<
(outs),
(ins IntRegs:$Rt32, s4_6Imm:$Ii, VectorRegs:$Vs32),
"vmem($Rt32+#$Ii):nt = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_6923828, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-5} = 0b000;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b00101000011;
let addrMode = BaseImmOffset;
let accessSize = Vector64Access;
let mayStore = 1;
let isNonTemporal = 1;
let BaseOpcode = "V6_vS32b_ai";
let isNVStorable = 1;
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vS32b_nt_ai_128B : HInst<
(outs),
(ins IntRegs:$Rt32, s4_7Imm:$Ii, VectorRegs128B:$Vs32),
"vmem($Rt32+#$Ii):nt = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_5757366, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-5} = 0b000;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b00101000011;
let addrMode = BaseImmOffset;
let accessSize = Vector128Access;
let mayStore = 1;
let isNonTemporal = 1;
let BaseOpcode = "V6_vS32b_ai_128B";
let isNVStorable = 1;
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vS32b_nt_new_ai : HInst<
(outs),
(ins IntRegs:$Rt32, s4_6Imm:$Ii, VectorRegs:$Os8),
"vmem($Rt32+#$Ii):nt = $Os8.new",
CVI_VM_NEW_ST, TypeCVI_VM_NEW_ST>, Enc_6608821, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-3} = 0b00100;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b00101000011;
let addrMode = BaseImmOffset;
let accessSize = Vector64Access;
let isNVStore = 1;
let mayStore = 1;
let isNonTemporal = 1;
let isNewValue = 1;
let BaseOpcode = "V6_vS32b_ai";
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
let opNewValue = 2;
}
def V6_vS32b_nt_new_ai_128B : HInst<
(outs),
(ins IntRegs:$Rt32, s4_7Imm:$Ii, VectorRegs128B:$Os8),
"vmem($Rt32+#$Ii):nt = $Os8.new",
CVI_VM_NEW_ST, TypeCVI_VM_NEW_ST>, Enc_2152247, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-3} = 0b00100;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b00101000011;
let addrMode = BaseImmOffset;
let accessSize = Vector128Access;
let isNVStore = 1;
let mayStore = 1;
let isNonTemporal = 1;
let isNewValue = 1;
let BaseOpcode = "V6_vS32b_ai_128B";
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let opNewValue = 2;
}
def V6_vS32b_nt_new_npred_ai : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_6Imm:$Ii, VectorRegs:$Os8),
"if (!$Pv4) vmem($Rt32+#$Ii):nt = $Os8.new",
CVI_VM_NEW_ST, TypeCVI_VM_NEW_ST>, Enc_9372046, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-3} = 0b01111;
let Inst{31-21} = 0b00101000111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = Vector64Access;
let isNVStore = 1;
let mayStore = 1;
let isNonTemporal = 1;
let isNewValue = 1;
let BaseOpcode = "V6_vS32b_ai";
let DecoderNamespace = "EXT_mmvec";
let opNewValue = 3;
}
def V6_vS32b_nt_new_npred_ai_128B : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_7Imm:$Ii, VectorRegs128B:$Os8),
"if (!$Pv4) vmem($Rt32+#$Ii):nt = $Os8.new",
CVI_VM_NEW_ST, TypeCVI_VM_NEW_ST>, Enc_13937564, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-3} = 0b01111;
let Inst{31-21} = 0b00101000111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = Vector128Access;
let isNVStore = 1;
let mayStore = 1;
let isNonTemporal = 1;
let isNewValue = 1;
let BaseOpcode = "V6_vS32b_ai_128B";
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let opNewValue = 3;
}
def V6_vS32b_nt_new_npred_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_6Imm:$Ii, VectorRegs:$Os8),
"if (!$Pv4) vmem($Rx32++#$Ii):nt = $Os8.new",
CVI_VM_NEW_ST, TypeCVI_VM_NEW_ST>, Enc_3735566, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-3} = 0b01111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = Vector64Access;
let isNVStore = 1;
let mayStore = 1;
let isNonTemporal = 1;
let isNewValue = 1;
let BaseOpcode = "V6_vS32b_pi";
let DecoderNamespace = "EXT_mmvec";
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nt_new_npred_pi_128B : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_7Imm:$Ii, VectorRegs128B:$Os8),
"if (!$Pv4) vmem($Rx32++#$Ii):nt = $Os8.new",
CVI_VM_NEW_ST, TypeCVI_VM_NEW_ST>, Enc_2735552, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-3} = 0b01111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = Vector128Access;
let isNVStore = 1;
let mayStore = 1;
let isNonTemporal = 1;
let isNewValue = 1;
let BaseOpcode = "V6_vS32b_pi_128B";
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nt_new_npred_ppu : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2, VectorRegs:$Os8),
"if (!$Pv4) vmem($Rx32++$Mu2):nt = $Os8.new",
CVI_VM_NEW_ST, TypeCVI_VM_NEW_ST>, Enc_8498433, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{10-3} = 0b00001111;
let Inst{31-21} = 0b00101011111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = Vector64Access;
let isNVStore = 1;
let mayStore = 1;
let isNonTemporal = 1;
let isNewValue = 1;
let BaseOpcode = "V6_vS32b_ppu";
let DecoderNamespace = "EXT_mmvec";
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nt_new_npred_ppu_128B : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2, VectorRegs128B:$Os8),
"if (!$Pv4) vmem($Rx32++$Mu2):nt = $Os8.new",
CVI_VM_NEW_ST, TypeCVI_VM_NEW_ST>, Enc_8498433, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{10-3} = 0b00001111;
let Inst{31-21} = 0b00101011111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = Vector128Access;
let isNVStore = 1;
let mayStore = 1;
let isNonTemporal = 1;
let isNewValue = 1;
let BaseOpcode = "V6_vS32b_ppu_128B";
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nt_new_pi : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s3_6Imm:$Ii, VectorRegs:$Os8),
"vmem($Rx32++#$Ii):nt = $Os8.new",
CVI_VM_NEW_ST, TypeCVI_VM_NEW_ST>, Enc_12244921, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-3} = 0b00100;
let Inst{13-11} = 0b000;
let Inst{31-21} = 0b00101001011;
let addrMode = PostInc;
let accessSize = Vector64Access;
let isNVStore = 1;
let mayStore = 1;
let isNonTemporal = 1;
let isNewValue = 1;
let BaseOpcode = "V6_vS32b_pi";
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
let opNewValue = 3;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nt_new_pi_128B : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s3_7Imm:$Ii, VectorRegs128B:$Os8),
"vmem($Rx32++#$Ii):nt = $Os8.new",
CVI_VM_NEW_ST, TypeCVI_VM_NEW_ST>, Enc_11244923, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-3} = 0b00100;
let Inst{13-11} = 0b000;
let Inst{31-21} = 0b00101001011;
let addrMode = PostInc;
let accessSize = Vector128Access;
let isNVStore = 1;
let mayStore = 1;
let isNonTemporal = 1;
let isNewValue = 1;
let BaseOpcode = "V6_vS32b_pi_128B";
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let opNewValue = 3;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nt_new_ppu : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, VectorRegs:$Os8),
"vmem($Rx32++$Mu2):nt = $Os8.new",
CVI_VM_NEW_ST, TypeCVI_VM_NEW_ST>, Enc_1589406, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{12-3} = 0b0000000100;
let Inst{31-21} = 0b00101011011;
let addrMode = PostInc;
let accessSize = Vector64Access;
let isNVStore = 1;
let mayStore = 1;
let isNonTemporal = 1;
let isNewValue = 1;
let BaseOpcode = "V6_vS32b_ppu";
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
let opNewValue = 3;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nt_new_ppu_128B : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, VectorRegs128B:$Os8),
"vmem($Rx32++$Mu2):nt = $Os8.new",
CVI_VM_NEW_ST, TypeCVI_VM_NEW_ST>, Enc_1589406, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{12-3} = 0b0000000100;
let Inst{31-21} = 0b00101011011;
let addrMode = PostInc;
let accessSize = Vector128Access;
let isNVStore = 1;
let mayStore = 1;
let isNonTemporal = 1;
let isNewValue = 1;
let BaseOpcode = "V6_vS32b_ppu_128B";
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let opNewValue = 3;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nt_new_pred_ai : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_6Imm:$Ii, VectorRegs:$Os8),
"if ($Pv4) vmem($Rt32+#$Ii):nt = $Os8.new",
CVI_VM_NEW_ST, TypeCVI_VM_NEW_ST>, Enc_9372046, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-3} = 0b01010;
let Inst{31-21} = 0b00101000111;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = Vector64Access;
let isNVStore = 1;
let mayStore = 1;
let isNonTemporal = 1;
let isNewValue = 1;
let BaseOpcode = "V6_vS32b_ai";
let DecoderNamespace = "EXT_mmvec";
let opNewValue = 3;
}
def V6_vS32b_nt_new_pred_ai_128B : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_7Imm:$Ii, VectorRegs128B:$Os8),
"if ($Pv4) vmem($Rt32+#$Ii):nt = $Os8.new",
CVI_VM_NEW_ST, TypeCVI_VM_NEW_ST>, Enc_13937564, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-3} = 0b01010;
let Inst{31-21} = 0b00101000111;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = Vector128Access;
let isNVStore = 1;
let mayStore = 1;
let isNonTemporal = 1;
let isNewValue = 1;
let BaseOpcode = "V6_vS32b_ai_128B";
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let opNewValue = 3;
}
def V6_vS32b_nt_new_pred_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_6Imm:$Ii, VectorRegs:$Os8),
"if ($Pv4) vmem($Rx32++#$Ii):nt = $Os8.new",
CVI_VM_NEW_ST, TypeCVI_VM_NEW_ST>, Enc_3735566, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-3} = 0b01010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001111;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = Vector64Access;
let isNVStore = 1;
let mayStore = 1;
let isNonTemporal = 1;
let isNewValue = 1;
let BaseOpcode = "V6_vS32b_pi";
let DecoderNamespace = "EXT_mmvec";
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nt_new_pred_pi_128B : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_7Imm:$Ii, VectorRegs128B:$Os8),
"if ($Pv4) vmem($Rx32++#$Ii):nt = $Os8.new",
CVI_VM_NEW_ST, TypeCVI_VM_NEW_ST>, Enc_2735552, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-3} = 0b01010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001111;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = Vector128Access;
let isNVStore = 1;
let mayStore = 1;
let isNonTemporal = 1;
let isNewValue = 1;
let BaseOpcode = "V6_vS32b_pi_128B";
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nt_new_pred_ppu : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2, VectorRegs:$Os8),
"if ($Pv4) vmem($Rx32++$Mu2):nt = $Os8.new",
CVI_VM_NEW_ST, TypeCVI_VM_NEW_ST>, Enc_8498433, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{10-3} = 0b00001010;
let Inst{31-21} = 0b00101011111;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = Vector64Access;
let isNVStore = 1;
let mayStore = 1;
let isNonTemporal = 1;
let isNewValue = 1;
let BaseOpcode = "V6_vS32b_ppu";
let DecoderNamespace = "EXT_mmvec";
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nt_new_pred_ppu_128B : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2, VectorRegs128B:$Os8),
"if ($Pv4) vmem($Rx32++$Mu2):nt = $Os8.new",
CVI_VM_NEW_ST, TypeCVI_VM_NEW_ST>, Enc_8498433, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{10-3} = 0b00001010;
let Inst{31-21} = 0b00101011111;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = Vector128Access;
let isNVStore = 1;
let mayStore = 1;
let isNonTemporal = 1;
let isNewValue = 1;
let BaseOpcode = "V6_vS32b_ppu_128B";
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nt_npred_ai : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_6Imm:$Ii, VectorRegs:$Vs32),
"if (!$Pv4) vmem($Rt32+#$Ii):nt = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_10075393, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-5} = 0b001;
let Inst{31-21} = 0b00101000111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = Vector64Access;
let mayStore = 1;
let isNonTemporal = 1;
let BaseOpcode = "V6_vS32b_ai";
let isNVStorable = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vS32b_nt_npred_ai_128B : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_7Imm:$Ii, VectorRegs128B:$Vs32),
"if (!$Pv4) vmem($Rt32+#$Ii):nt = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_9470751, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-5} = 0b001;
let Inst{31-21} = 0b00101000111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = Vector128Access;
let mayStore = 1;
let isNonTemporal = 1;
let BaseOpcode = "V6_vS32b_ai_128B";
let isNVStorable = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vS32b_nt_npred_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_6Imm:$Ii, VectorRegs:$Vs32),
"if (!$Pv4) vmem($Rx32++#$Ii):nt = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_15459921, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = Vector64Access;
let mayStore = 1;
let isNonTemporal = 1;
let BaseOpcode = "V6_vS32b_pi";
let isNVStorable = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nt_npred_pi_128B : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_7Imm:$Ii, VectorRegs128B:$Vs32),
"if (!$Pv4) vmem($Rx32++#$Ii):nt = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_14459927, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = Vector128Access;
let mayStore = 1;
let isNonTemporal = 1;
let BaseOpcode = "V6_vS32b_pi_128B";
let isNVStorable = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nt_npred_ppu : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2, VectorRegs:$Vs32),
"if (!$Pv4) vmem($Rx32++$Mu2):nt = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_15733946, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{10-5} = 0b000001;
let Inst{31-21} = 0b00101011111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = Vector64Access;
let mayStore = 1;
let isNonTemporal = 1;
let BaseOpcode = "V6_vS32b_ppu";
let isNVStorable = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nt_npred_ppu_128B : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2, VectorRegs128B:$Vs32),
"if (!$Pv4) vmem($Rx32++$Mu2):nt = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_15733946, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{10-5} = 0b000001;
let Inst{31-21} = 0b00101011111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = Vector128Access;
let mayStore = 1;
let isNonTemporal = 1;
let BaseOpcode = "V6_vS32b_ppu_128B";
let isNVStorable = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nt_nqpred_ai : HInst<
(outs),
(ins VecPredRegs:$Qv4, IntRegs:$Rt32, s4_6Imm:$Ii, VectorRegs:$Vs32),
"if (!$Qv4) vmem($Rt32+#$Ii):nt = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_16279406, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{31-21} = 0b00101000110;
let addrMode = BaseImmOffset;
let accessSize = Vector64Access;
let mayStore = 1;
let isNonTemporal = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vS32b_nt_nqpred_ai_128B : HInst<
(outs),
(ins VecPredRegs128B:$Qv4, IntRegs:$Rt32, s4_7Imm:$Ii, VectorRegs128B:$Vs32),
"if (!$Qv4) vmem($Rt32+#$Ii):nt = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_2703240, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{31-21} = 0b00101000110;
let addrMode = BaseImmOffset;
let accessSize = Vector128Access;
let mayStore = 1;
let isNonTemporal = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vS32b_nt_nqpred_pi : HInst<
(outs IntRegs:$Rx32),
(ins VecPredRegs:$Qv4, IntRegs:$Rx32in, s3_6Imm:$Ii, VectorRegs:$Vs32),
"if (!$Qv4) vmem($Rx32++#$Ii):nt = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_12397062, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001110;
let addrMode = PostInc;
let accessSize = Vector64Access;
let mayStore = 1;
let isNonTemporal = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nt_nqpred_pi_128B : HInst<
(outs IntRegs:$Rx32),
(ins VecPredRegs128B:$Qv4, IntRegs:$Rx32in, s3_7Imm:$Ii, VectorRegs128B:$Vs32),
"if (!$Qv4) vmem($Rx32++#$Ii):nt = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_13397056, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001110;
let addrMode = PostInc;
let accessSize = Vector128Access;
let mayStore = 1;
let isNonTemporal = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nt_nqpred_ppu : HInst<
(outs IntRegs:$Rx32),
(ins VecPredRegs:$Qv4, IntRegs:$Rx32in, ModRegs:$Mu2, VectorRegs:$Vs32),
"if (!$Qv4) vmem($Rx32++$Mu2):nt = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_13425035, Requires<[HasV60T,UseHVX]> {
let Inst{10-5} = 0b000001;
let Inst{31-21} = 0b00101011110;
let addrMode = PostInc;
let accessSize = Vector64Access;
let mayStore = 1;
let isNonTemporal = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nt_nqpred_ppu_128B : HInst<
(outs IntRegs:$Rx32),
(ins VecPredRegs128B:$Qv4, IntRegs:$Rx32in, ModRegs:$Mu2, VectorRegs128B:$Vs32),
"if (!$Qv4) vmem($Rx32++$Mu2):nt = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_13425035, Requires<[HasV60T,UseHVX]> {
let Inst{10-5} = 0b000001;
let Inst{31-21} = 0b00101011110;
let addrMode = PostInc;
let accessSize = Vector128Access;
let mayStore = 1;
let isNonTemporal = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nt_pi : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s3_6Imm:$Ii, VectorRegs:$Vs32),
"vmem($Rx32++#$Ii):nt = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_3296020, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-5} = 0b000;
let Inst{13-11} = 0b000;
let Inst{31-21} = 0b00101001011;
let addrMode = PostInc;
let accessSize = Vector64Access;
let mayStore = 1;
let isNonTemporal = 1;
let BaseOpcode = "V6_vS32b_pi";
let isNVStorable = 1;
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nt_pi_128B : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s3_7Imm:$Ii, VectorRegs128B:$Vs32),
"vmem($Rx32++#$Ii):nt = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_2296022, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-5} = 0b000;
let Inst{13-11} = 0b000;
let Inst{31-21} = 0b00101001011;
let addrMode = PostInc;
let accessSize = Vector128Access;
let mayStore = 1;
let isNonTemporal = 1;
let BaseOpcode = "V6_vS32b_pi_128B";
let isNVStorable = 1;
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nt_ppu : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, VectorRegs:$Vs32),
"vmem($Rx32++$Mu2):nt = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_11281763, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b00101011011;
let addrMode = PostInc;
let accessSize = Vector64Access;
let mayStore = 1;
let isNonTemporal = 1;
let BaseOpcode = "V6_vS32b_ppu";
let isNVStorable = 1;
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nt_ppu_128B : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, VectorRegs128B:$Vs32),
"vmem($Rx32++$Mu2):nt = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_11281763, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b00101011011;
let addrMode = PostInc;
let accessSize = Vector128Access;
let mayStore = 1;
let isNonTemporal = 1;
let BaseOpcode = "V6_vS32b_ppu_128B";
let isNVStorable = 1;
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nt_pred_ai : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_6Imm:$Ii, VectorRegs:$Vs32),
"if ($Pv4) vmem($Rt32+#$Ii):nt = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_10075393, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-5} = 0b000;
let Inst{31-21} = 0b00101000111;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = Vector64Access;
let mayStore = 1;
let isNonTemporal = 1;
let BaseOpcode = "V6_vS32b_ai";
let isNVStorable = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vS32b_nt_pred_ai_128B : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_7Imm:$Ii, VectorRegs128B:$Vs32),
"if ($Pv4) vmem($Rt32+#$Ii):nt = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_9470751, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-5} = 0b000;
let Inst{31-21} = 0b00101000111;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = Vector128Access;
let mayStore = 1;
let isNonTemporal = 1;
let BaseOpcode = "V6_vS32b_ai_128B";
let isNVStorable = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vS32b_nt_pred_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_6Imm:$Ii, VectorRegs:$Vs32),
"if ($Pv4) vmem($Rx32++#$Ii):nt = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_15459921, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001111;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = Vector64Access;
let mayStore = 1;
let isNonTemporal = 1;
let BaseOpcode = "V6_vS32b_pi";
let isNVStorable = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nt_pred_pi_128B : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_7Imm:$Ii, VectorRegs128B:$Vs32),
"if ($Pv4) vmem($Rx32++#$Ii):nt = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_14459927, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001111;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = Vector128Access;
let mayStore = 1;
let isNonTemporal = 1;
let BaseOpcode = "V6_vS32b_pi_128B";
let isNVStorable = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nt_pred_ppu : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2, VectorRegs:$Vs32),
"if ($Pv4) vmem($Rx32++$Mu2):nt = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_15733946, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{10-5} = 0b000000;
let Inst{31-21} = 0b00101011111;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = Vector64Access;
let mayStore = 1;
let isNonTemporal = 1;
let BaseOpcode = "V6_vS32b_ppu";
let isNVStorable = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nt_pred_ppu_128B : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2, VectorRegs128B:$Vs32),
"if ($Pv4) vmem($Rx32++$Mu2):nt = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_15733946, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{10-5} = 0b000000;
let Inst{31-21} = 0b00101011111;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = Vector128Access;
let mayStore = 1;
let isNonTemporal = 1;
let BaseOpcode = "V6_vS32b_ppu_128B";
let isNVStorable = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nt_qpred_ai : HInst<
(outs),
(ins VecPredRegs:$Qv4, IntRegs:$Rt32, s4_6Imm:$Ii, VectorRegs:$Vs32),
"if ($Qv4) vmem($Rt32+#$Ii):nt = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_16279406, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{31-21} = 0b00101000110;
let addrMode = BaseImmOffset;
let accessSize = Vector64Access;
let mayStore = 1;
let isNonTemporal = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vS32b_nt_qpred_ai_128B : HInst<
(outs),
(ins VecPredRegs128B:$Qv4, IntRegs:$Rt32, s4_7Imm:$Ii, VectorRegs128B:$Vs32),
"if ($Qv4) vmem($Rt32+#$Ii):nt = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_2703240, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{31-21} = 0b00101000110;
let addrMode = BaseImmOffset;
let accessSize = Vector128Access;
let mayStore = 1;
let isNonTemporal = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vS32b_nt_qpred_pi : HInst<
(outs IntRegs:$Rx32),
(ins VecPredRegs:$Qv4, IntRegs:$Rx32in, s3_6Imm:$Ii, VectorRegs:$Vs32),
"if ($Qv4) vmem($Rx32++#$Ii):nt = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_12397062, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001110;
let addrMode = PostInc;
let accessSize = Vector64Access;
let mayStore = 1;
let isNonTemporal = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nt_qpred_pi_128B : HInst<
(outs IntRegs:$Rx32),
(ins VecPredRegs128B:$Qv4, IntRegs:$Rx32in, s3_7Imm:$Ii, VectorRegs128B:$Vs32),
"if ($Qv4) vmem($Rx32++#$Ii):nt = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_13397056, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001110;
let addrMode = PostInc;
let accessSize = Vector128Access;
let mayStore = 1;
let isNonTemporal = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nt_qpred_ppu : HInst<
(outs IntRegs:$Rx32),
(ins VecPredRegs:$Qv4, IntRegs:$Rx32in, ModRegs:$Mu2, VectorRegs:$Vs32),
"if ($Qv4) vmem($Rx32++$Mu2):nt = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_13425035, Requires<[HasV60T,UseHVX]> {
let Inst{10-5} = 0b000000;
let Inst{31-21} = 0b00101011110;
let addrMode = PostInc;
let accessSize = Vector64Access;
let mayStore = 1;
let isNonTemporal = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nt_qpred_ppu_128B : HInst<
(outs IntRegs:$Rx32),
(ins VecPredRegs128B:$Qv4, IntRegs:$Rx32in, ModRegs:$Mu2, VectorRegs128B:$Vs32),
"if ($Qv4) vmem($Rx32++$Mu2):nt = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_13425035, Requires<[HasV60T,UseHVX]> {
let Inst{10-5} = 0b000000;
let Inst{31-21} = 0b00101011110;
let addrMode = PostInc;
let accessSize = Vector128Access;
let mayStore = 1;
let isNonTemporal = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_pi : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s3_6Imm:$Ii, VectorRegs:$Vs32),
"vmem($Rx32++#$Ii) = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_3296020, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-5} = 0b000;
let Inst{13-11} = 0b000;
let Inst{31-21} = 0b00101001001;
let addrMode = PostInc;
let accessSize = Vector64Access;
let mayStore = 1;
let BaseOpcode = "V6_vS32b_pi";
let isNVStorable = 1;
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_pi_128B : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s3_7Imm:$Ii, VectorRegs128B:$Vs32),
"vmem($Rx32++#$Ii) = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_2296022, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-5} = 0b000;
let Inst{13-11} = 0b000;
let Inst{31-21} = 0b00101001001;
let addrMode = PostInc;
let accessSize = Vector128Access;
let mayStore = 1;
let BaseOpcode = "V6_vS32b_pi_128B";
let isNVStorable = 1;
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_ppu : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, VectorRegs:$Vs32),
"vmem($Rx32++$Mu2) = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_11281763, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b00101011001;
let addrMode = PostInc;
let accessSize = Vector64Access;
let mayStore = 1;
let isNVStorable = 1;
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_ppu_128B : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, VectorRegs128B:$Vs32),
"vmem($Rx32++$Mu2) = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_11281763, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b00101011001;
let addrMode = PostInc;
let accessSize = Vector128Access;
let mayStore = 1;
let isNVStorable = 1;
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_pred_ai : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_6Imm:$Ii, VectorRegs:$Vs32),
"if ($Pv4) vmem($Rt32+#$Ii) = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_10075393, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-5} = 0b000;
let Inst{31-21} = 0b00101000101;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = Vector64Access;
let mayStore = 1;
let BaseOpcode = "V6_vS32b_ai";
let isNVStorable = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vS32b_pred_ai_128B : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_7Imm:$Ii, VectorRegs128B:$Vs32),
"if ($Pv4) vmem($Rt32+#$Ii) = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_9470751, Requires<[HasV60T,UseHVX]>, NewValueRel {
let Inst{7-5} = 0b000;
let Inst{31-21} = 0b00101000101;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = Vector128Access;
let mayStore = 1;
let BaseOpcode = "V6_vS32b_ai_128B";
let isNVStorable = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vS32b_pred_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_6Imm:$Ii, VectorRegs:$Vs32),
"if ($Pv4) vmem($Rx32++#$Ii) = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_15459921, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001101;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = Vector64Access;
let mayStore = 1;
let BaseOpcode = "V6_vS32b_pi";
let isNVStorable = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_pred_pi_128B : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_7Imm:$Ii, VectorRegs128B:$Vs32),
"if ($Pv4) vmem($Rx32++#$Ii) = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_14459927, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001101;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = Vector128Access;
let mayStore = 1;
let BaseOpcode = "V6_vS32b_pi_128B";
let isNVStorable = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_pred_ppu : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2, VectorRegs:$Vs32),
"if ($Pv4) vmem($Rx32++$Mu2) = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_15733946, Requires<[HasV60T,UseHVX]> {
let Inst{10-5} = 0b000000;
let Inst{31-21} = 0b00101011101;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = Vector64Access;
let mayStore = 1;
let isNVStorable = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_pred_ppu_128B : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2, VectorRegs128B:$Vs32),
"if ($Pv4) vmem($Rx32++$Mu2) = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_15733946, Requires<[HasV60T,UseHVX]> {
let Inst{10-5} = 0b000000;
let Inst{31-21} = 0b00101011101;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = Vector128Access;
let mayStore = 1;
let isNVStorable = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_qpred_ai : HInst<
(outs),
(ins VecPredRegs:$Qv4, IntRegs:$Rt32, s4_6Imm:$Ii, VectorRegs:$Vs32),
"if ($Qv4) vmem($Rt32+#$Ii) = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_16279406, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{31-21} = 0b00101000100;
let addrMode = BaseImmOffset;
let accessSize = Vector64Access;
let mayStore = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vS32b_qpred_ai_128B : HInst<
(outs),
(ins VecPredRegs128B:$Qv4, IntRegs:$Rt32, s4_7Imm:$Ii, VectorRegs128B:$Vs32),
"if ($Qv4) vmem($Rt32+#$Ii) = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_2703240, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{31-21} = 0b00101000100;
let addrMode = BaseImmOffset;
let accessSize = Vector128Access;
let mayStore = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vS32b_qpred_pi : HInst<
(outs IntRegs:$Rx32),
(ins VecPredRegs:$Qv4, IntRegs:$Rx32in, s3_6Imm:$Ii, VectorRegs:$Vs32),
"if ($Qv4) vmem($Rx32++#$Ii) = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_12397062, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001100;
let addrMode = PostInc;
let accessSize = Vector64Access;
let mayStore = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_qpred_pi_128B : HInst<
(outs IntRegs:$Rx32),
(ins VecPredRegs128B:$Qv4, IntRegs:$Rx32in, s3_7Imm:$Ii, VectorRegs128B:$Vs32),
"if ($Qv4) vmem($Rx32++#$Ii) = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_13397056, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001100;
let addrMode = PostInc;
let accessSize = Vector128Access;
let mayStore = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_qpred_ppu : HInst<
(outs IntRegs:$Rx32),
(ins VecPredRegs:$Qv4, IntRegs:$Rx32in, ModRegs:$Mu2, VectorRegs:$Vs32),
"if ($Qv4) vmem($Rx32++$Mu2) = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_13425035, Requires<[HasV60T,UseHVX]> {
let Inst{10-5} = 0b000000;
let Inst{31-21} = 0b00101011100;
let addrMode = PostInc;
let accessSize = Vector64Access;
let mayStore = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_qpred_ppu_128B : HInst<
(outs IntRegs:$Rx32),
(ins VecPredRegs128B:$Qv4, IntRegs:$Rx32in, ModRegs:$Mu2, VectorRegs128B:$Vs32),
"if ($Qv4) vmem($Rx32++$Mu2) = $Vs32",
CVI_VM_ST, TypeCVI_VM_ST>, Enc_13425035, Requires<[HasV60T,UseHVX]> {
let Inst{10-5} = 0b000000;
let Inst{31-21} = 0b00101011100;
let addrMode = PostInc;
let accessSize = Vector128Access;
let mayStore = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vabsdiffh : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.uh = vabsdiff($Vu32.h,$Vv32.h)",
CVI_VX, TypeCVI_VX>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vabsdiffh_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.uh = vabsdiff($Vu32.h,$Vv32.h)",
CVI_VX, TypeCVI_VX>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vabsdiffh_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vabsdiffh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vabsdiffh_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vabsdiffh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vabsdiffub : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.ub = vabsdiff($Vu32.ub,$Vv32.ub)",
CVI_VX, TypeCVI_VX>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vabsdiffub_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.ub = vabsdiff($Vu32.ub,$Vv32.ub)",
CVI_VX, TypeCVI_VX>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vabsdiffub_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vabsdiffub($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vabsdiffub_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vabsdiffub($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vabsdiffuh : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.uh = vabsdiff($Vu32.uh,$Vv32.uh)",
CVI_VX, TypeCVI_VX>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vabsdiffuh_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.uh = vabsdiff($Vu32.uh,$Vv32.uh)",
CVI_VX, TypeCVI_VX>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vabsdiffuh_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vabsdiffuh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vabsdiffuh_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vabsdiffuh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vabsdiffw : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.uw = vabsdiff($Vu32.w,$Vv32.w)",
CVI_VX, TypeCVI_VX>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vabsdiffw_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.uw = vabsdiff($Vu32.w,$Vv32.w)",
CVI_VX, TypeCVI_VX>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vabsdiffw_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vabsdiffw($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vabsdiffw_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vabsdiffw($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vabsh : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32),
"$Vd32.h = vabs($Vu32.h)",
CVI_VA, TypeCVI_VA>, Enc_900013, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vabsh_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32),
"$Vd32.h = vabs($Vu32.h)",
CVI_VA, TypeCVI_VA>, Enc_900013, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vabsh_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32),
"$Vd32 = vabsh($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vabsh_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32),
"$Vd32 = vabsh($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vabsh_sat : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32),
"$Vd32.h = vabs($Vu32.h):sat",
CVI_VA, TypeCVI_VA>, Enc_900013, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vabsh_sat_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32),
"$Vd32.h = vabs($Vu32.h):sat",
CVI_VA, TypeCVI_VA>, Enc_900013, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vabsh_sat_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32),
"$Vd32 = vabsh($Vu32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vabsh_sat_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32),
"$Vd32 = vabsh($Vu32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vabsw : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32),
"$Vd32.w = vabs($Vu32.w)",
CVI_VA, TypeCVI_VA>, Enc_900013, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vabsw_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32),
"$Vd32.w = vabs($Vu32.w)",
CVI_VA, TypeCVI_VA>, Enc_900013, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vabsw_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32),
"$Vd32 = vabsw($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vabsw_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32),
"$Vd32 = vabsw($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vabsw_sat : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32),
"$Vd32.w = vabs($Vu32.w):sat",
CVI_VA, TypeCVI_VA>, Enc_900013, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vabsw_sat_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32),
"$Vd32.w = vabs($Vu32.w):sat",
CVI_VA, TypeCVI_VA>, Enc_900013, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vabsw_sat_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32),
"$Vd32 = vabsw($Vu32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vabsw_sat_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32),
"$Vd32 = vabsw($Vu32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vaddb : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.b = vadd($Vu32.b,$Vv32.b)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddb_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.b = vadd($Vu32.b,$Vv32.b)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vaddb_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vaddb($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddb_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vaddb($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vaddb_dv : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, VecDblRegs:$Vvv32),
"$Vdd32.b = vadd($Vuu32.b,$Vvv32.b)",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_13211717, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddb_dv_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, VecDblRegs128B:$Vvv32),
"$Vdd32.b = vadd($Vuu32.b,$Vvv32.b)",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_13211717, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vaddb_dv_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, VecDblRegs:$Vvv32),
"$Vdd32 = vaddb($Vuu32,$Vvv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddb_dv_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, VecDblRegs128B:$Vvv32),
"$Vdd32 = vaddb($Vuu32,$Vvv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vaddbnq : HInst<
(outs VectorRegs:$Vx32),
(ins VecPredRegs:$Qv4, VectorRegs:$Vx32in, VectorRegs:$Vu32),
"if (!$Qv4) $Vx32.b += $Vu32.b",
CVI_VA, TypeCVI_VA>, Enc_12535811, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b1;
let Inst{21-16} = 0b000001;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vaddbnq_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VecPredRegs128B:$Qv4, VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32),
"if (!$Qv4) $Vx32.b += $Vu32.b",
CVI_VA, TypeCVI_VA>, Enc_12535811, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b1;
let Inst{21-16} = 0b000001;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vaddbnq_alt : HInst<
(outs VectorRegs:$Vx32),
(ins VecPredRegs:$Qv4, VectorRegs:$Vx32in, VectorRegs:$Vu32),
"if (!$Qv4.b) $Vx32.b += $Vu32.b",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vaddbnq_alt_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VecPredRegs128B:$Qv4, VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32),
"if (!$Qv4.b) $Vx32.b += $Vu32.b",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vaddbq : HInst<
(outs VectorRegs:$Vx32),
(ins VecPredRegs:$Qv4, VectorRegs:$Vx32in, VectorRegs:$Vu32),
"if ($Qv4) $Vx32.b += $Vu32.b",
CVI_VA, TypeCVI_VA>, Enc_12535811, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b1;
let Inst{21-16} = 0b000001;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vaddbq_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VecPredRegs128B:$Qv4, VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32),
"if ($Qv4) $Vx32.b += $Vu32.b",
CVI_VA, TypeCVI_VA>, Enc_12535811, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b1;
let Inst{21-16} = 0b000001;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vaddbq_alt : HInst<
(outs VectorRegs:$Vx32),
(ins VecPredRegs:$Qv4, VectorRegs:$Vx32in, VectorRegs:$Vu32),
"if ($Qv4.b) $Vx32.b += $Vu32.b",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vaddbq_alt_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VecPredRegs128B:$Qv4, VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32),
"if ($Qv4.b) $Vx32.b += $Vu32.b",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vaddbsat : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.b = vadd($Vu32.b,$Vv32.b):sat",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddbsat_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.b = vadd($Vu32.b,$Vv32.b):sat",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vaddbsat_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vaddb($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV62T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddbsat_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vaddb($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV62T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vaddbsat_dv : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, VecDblRegs:$Vvv32),
"$Vdd32.b = vadd($Vuu32.b,$Vvv32.b):sat",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_13211717, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011110101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddbsat_dv_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, VecDblRegs128B:$Vvv32),
"$Vdd32.b = vadd($Vuu32.b,$Vvv32.b):sat",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_13211717, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011110101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vaddbsat_dv_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, VecDblRegs:$Vvv32),
"$Vdd32 = vaddb($Vuu32,$Vvv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV62T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddbsat_dv_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, VecDblRegs128B:$Vvv32),
"$Vdd32 = vaddb($Vuu32,$Vvv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV62T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vaddcarry : HInst<
(outs VectorRegs:$Vd32, VecPredRegs:$Qx4),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32, VecPredRegs:$Qx4in),
"$Vd32.w = vadd($Vu32.w,$Vv32.w,$Qx4):carry",
CVI_VA, TypeCVI_VA>, Enc_13691337, Requires<[HasV62T,UseHVX]> {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100101;
let hasNewValue = 1;
let opNewValue = 0;
let hasNewValue2 = 1;
let opNewValue2 = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vaddcarry_128B : HInst<
(outs VectorRegs128B:$Vd32, VecPredRegs128B:$Qx4),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32, VecPredRegs128B:$Qx4in),
"$Vd32.w = vadd($Vu32.w,$Vv32.w,$Qx4):carry",
CVI_VA, TypeCVI_VA>, Enc_13691337, Requires<[HasV62T,UseHVX]> {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100101;
let hasNewValue = 1;
let opNewValue = 0;
let hasNewValue2 = 1;
let opNewValue2 = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vaddclbh : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.h = vadd(vclb($Vu32.h),$Vv32.h)",
CVI_VS, TypeCVI_VS>, Enc_6223403, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011111000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddclbh_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.h = vadd(vclb($Vu32.h),$Vv32.h)",
CVI_VS, TypeCVI_VS>, Enc_6223403, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011111000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vaddclbw : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.w = vadd(vclb($Vu32.w),$Vv32.w)",
CVI_VS, TypeCVI_VS>, Enc_6223403, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011111000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddclbw_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.w = vadd(vclb($Vu32.w),$Vv32.w)",
CVI_VS, TypeCVI_VS>, Enc_6223403, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011111000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vaddh : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.h = vadd($Vu32.h,$Vv32.h)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddh_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.h = vadd($Vu32.h,$Vv32.h)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vaddh_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vaddh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddh_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vaddh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vaddh_dv : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, VecDblRegs:$Vvv32),
"$Vdd32.h = vadd($Vuu32.h,$Vvv32.h)",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_13211717, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddh_dv_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, VecDblRegs128B:$Vvv32),
"$Vdd32.h = vadd($Vuu32.h,$Vvv32.h)",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_13211717, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vaddh_dv_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, VecDblRegs:$Vvv32),
"$Vdd32 = vaddh($Vuu32,$Vvv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddh_dv_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, VecDblRegs128B:$Vvv32),
"$Vdd32 = vaddh($Vuu32,$Vvv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vaddhnq : HInst<
(outs VectorRegs:$Vx32),
(ins VecPredRegs:$Qv4, VectorRegs:$Vx32in, VectorRegs:$Vu32),
"if (!$Qv4) $Vx32.h += $Vu32.h",
CVI_VA, TypeCVI_VA>, Enc_12535811, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b1;
let Inst{21-16} = 0b000001;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vaddhnq_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VecPredRegs128B:$Qv4, VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32),
"if (!$Qv4) $Vx32.h += $Vu32.h",
CVI_VA, TypeCVI_VA>, Enc_12535811, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b1;
let Inst{21-16} = 0b000001;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vaddhnq_alt : HInst<
(outs VectorRegs:$Vx32),
(ins VecPredRegs:$Qv4, VectorRegs:$Vx32in, VectorRegs:$Vu32),
"if (!$Qv4.h) $Vx32.h += $Vu32.h",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vaddhnq_alt_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VecPredRegs128B:$Qv4, VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32),
"if (!$Qv4.h) $Vx32.h += $Vu32.h",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vaddhq : HInst<
(outs VectorRegs:$Vx32),
(ins VecPredRegs:$Qv4, VectorRegs:$Vx32in, VectorRegs:$Vu32),
"if ($Qv4) $Vx32.h += $Vu32.h",
CVI_VA, TypeCVI_VA>, Enc_12535811, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b1;
let Inst{21-16} = 0b000001;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vaddhq_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VecPredRegs128B:$Qv4, VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32),
"if ($Qv4) $Vx32.h += $Vu32.h",
CVI_VA, TypeCVI_VA>, Enc_12535811, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b1;
let Inst{21-16} = 0b000001;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vaddhq_alt : HInst<
(outs VectorRegs:$Vx32),
(ins VecPredRegs:$Qv4, VectorRegs:$Vx32in, VectorRegs:$Vu32),
"if ($Qv4.h) $Vx32.h += $Vu32.h",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vaddhq_alt_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VecPredRegs128B:$Qv4, VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32),
"if ($Qv4.h) $Vx32.h += $Vu32.h",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vaddhsat : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.h = vadd($Vu32.h,$Vv32.h):sat",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddhsat_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.h = vadd($Vu32.h,$Vv32.h):sat",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vaddhsat_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vaddh($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddhsat_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vaddh($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vaddhsat_dv : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, VecDblRegs:$Vvv32),
"$Vdd32.h = vadd($Vuu32.h,$Vvv32.h):sat",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_13211717, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddhsat_dv_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, VecDblRegs128B:$Vvv32),
"$Vdd32.h = vadd($Vuu32.h,$Vvv32.h):sat",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_13211717, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vaddhsat_dv_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, VecDblRegs:$Vvv32),
"$Vdd32 = vaddh($Vuu32,$Vvv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddhsat_dv_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, VecDblRegs128B:$Vvv32),
"$Vdd32 = vaddh($Vuu32,$Vvv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vaddhw : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vdd32.w = vadd($Vu32.h,$Vv32.h)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_15290236, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddhw_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vdd32.w = vadd($Vu32.h,$Vv32.h)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_15290236, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vaddhw_acc : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vxx32.w += vadd($Vu32.h,$Vv32.h)",
CVI_VX_DV_LONG, TypeCVI_VX_DV>, Enc_5972412, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100001;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vaddhw_acc_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vxx32.w += vadd($Vu32.h,$Vv32.h)",
CVI_VX_DV_LONG, TypeCVI_VX_DV>, Enc_5972412, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100001;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vaddhw_acc_alt : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vxx32 += vaddh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV62T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vaddhw_acc_alt_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vxx32 += vaddh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV62T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vaddhw_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vdd32 = vaddh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddhw_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vdd32 = vaddh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vaddubh : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vdd32.h = vadd($Vu32.ub,$Vv32.ub)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_15290236, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddubh_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vdd32.h = vadd($Vu32.ub,$Vv32.ub)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_15290236, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vaddubh_acc : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vxx32.h += vadd($Vu32.ub,$Vv32.ub)",
CVI_VX_DV_LONG, TypeCVI_VX_DV>, Enc_5972412, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100010;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vaddubh_acc_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vxx32.h += vadd($Vu32.ub,$Vv32.ub)",
CVI_VX_DV_LONG, TypeCVI_VX_DV>, Enc_5972412, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100010;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vaddubh_acc_alt : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vxx32 += vaddub($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV62T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vaddubh_acc_alt_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vxx32 += vaddub($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV62T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vaddubh_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vdd32 = vaddub($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddubh_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vdd32 = vaddub($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vaddubsat : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.ub = vadd($Vu32.ub,$Vv32.ub):sat",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddubsat_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.ub = vadd($Vu32.ub,$Vv32.ub):sat",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vaddubsat_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vaddub($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddubsat_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vaddub($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vaddubsat_dv : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, VecDblRegs:$Vvv32),
"$Vdd32.ub = vadd($Vuu32.ub,$Vvv32.ub):sat",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_13211717, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddubsat_dv_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, VecDblRegs128B:$Vvv32),
"$Vdd32.ub = vadd($Vuu32.ub,$Vvv32.ub):sat",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_13211717, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vaddubsat_dv_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, VecDblRegs:$Vvv32),
"$Vdd32 = vaddub($Vuu32,$Vvv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddubsat_dv_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, VecDblRegs128B:$Vvv32),
"$Vdd32 = vaddub($Vuu32,$Vvv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vaddububb_sat : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.ub = vadd($Vu32.ub,$Vv32.b):sat",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011110101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddububb_sat_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.ub = vadd($Vu32.ub,$Vv32.b):sat",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011110101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vadduhsat : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.uh = vadd($Vu32.uh,$Vv32.uh):sat",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vadduhsat_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.uh = vadd($Vu32.uh,$Vv32.uh):sat",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vadduhsat_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vadduh($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vadduhsat_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vadduh($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vadduhsat_dv : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, VecDblRegs:$Vvv32),
"$Vdd32.uh = vadd($Vuu32.uh,$Vvv32.uh):sat",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_13211717, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vadduhsat_dv_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, VecDblRegs128B:$Vvv32),
"$Vdd32.uh = vadd($Vuu32.uh,$Vvv32.uh):sat",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_13211717, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vadduhsat_dv_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, VecDblRegs:$Vvv32),
"$Vdd32 = vadduh($Vuu32,$Vvv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vadduhsat_dv_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, VecDblRegs128B:$Vvv32),
"$Vdd32 = vadduh($Vuu32,$Vvv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vadduhw : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vdd32.w = vadd($Vu32.uh,$Vv32.uh)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_15290236, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vadduhw_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vdd32.w = vadd($Vu32.uh,$Vv32.uh)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_15290236, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vadduhw_acc : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vxx32.w += vadd($Vu32.uh,$Vv32.uh)",
CVI_VX_DV_LONG, TypeCVI_VX_DV>, Enc_5972412, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100010;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vadduhw_acc_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vxx32.w += vadd($Vu32.uh,$Vv32.uh)",
CVI_VX_DV_LONG, TypeCVI_VX_DV>, Enc_5972412, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100010;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vadduhw_acc_alt : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vxx32 += vadduh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV62T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vadduhw_acc_alt_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vxx32 += vadduh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV62T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vadduhw_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vdd32 = vadduh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vadduhw_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vdd32 = vadduh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vadduwsat : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.uw = vadd($Vu32.uw,$Vv32.uw):sat",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vadduwsat_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.uw = vadd($Vu32.uw,$Vv32.uw):sat",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vadduwsat_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vadduw($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV62T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vadduwsat_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vadduw($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV62T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vadduwsat_dv : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, VecDblRegs:$Vvv32),
"$Vdd32.uw = vadd($Vuu32.uw,$Vvv32.uw):sat",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_13211717, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011110101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vadduwsat_dv_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, VecDblRegs128B:$Vvv32),
"$Vdd32.uw = vadd($Vuu32.uw,$Vvv32.uw):sat",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_13211717, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011110101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vadduwsat_dv_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, VecDblRegs:$Vvv32),
"$Vdd32 = vadduw($Vuu32,$Vvv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV62T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vadduwsat_dv_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, VecDblRegs128B:$Vvv32),
"$Vdd32 = vadduw($Vuu32,$Vvv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV62T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vaddw : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.w = vadd($Vu32.w,$Vv32.w)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddw_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.w = vadd($Vu32.w,$Vv32.w)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vaddw_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vaddw($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddw_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vaddw($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vaddw_dv : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, VecDblRegs:$Vvv32),
"$Vdd32.w = vadd($Vuu32.w,$Vvv32.w)",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_13211717, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddw_dv_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, VecDblRegs128B:$Vvv32),
"$Vdd32.w = vadd($Vuu32.w,$Vvv32.w)",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_13211717, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vaddw_dv_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, VecDblRegs:$Vvv32),
"$Vdd32 = vaddw($Vuu32,$Vvv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddw_dv_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, VecDblRegs128B:$Vvv32),
"$Vdd32 = vaddw($Vuu32,$Vvv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vaddwnq : HInst<
(outs VectorRegs:$Vx32),
(ins VecPredRegs:$Qv4, VectorRegs:$Vx32in, VectorRegs:$Vu32),
"if (!$Qv4) $Vx32.w += $Vu32.w",
CVI_VA, TypeCVI_VA>, Enc_12535811, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b1;
let Inst{21-16} = 0b000001;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vaddwnq_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VecPredRegs128B:$Qv4, VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32),
"if (!$Qv4) $Vx32.w += $Vu32.w",
CVI_VA, TypeCVI_VA>, Enc_12535811, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b1;
let Inst{21-16} = 0b000001;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vaddwnq_alt : HInst<
(outs VectorRegs:$Vx32),
(ins VecPredRegs:$Qv4, VectorRegs:$Vx32in, VectorRegs:$Vu32),
"if (!$Qv4.w) $Vx32.w += $Vu32.w",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vaddwnq_alt_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VecPredRegs128B:$Qv4, VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32),
"if (!$Qv4.w) $Vx32.w += $Vu32.w",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vaddwq : HInst<
(outs VectorRegs:$Vx32),
(ins VecPredRegs:$Qv4, VectorRegs:$Vx32in, VectorRegs:$Vu32),
"if ($Qv4) $Vx32.w += $Vu32.w",
CVI_VA, TypeCVI_VA>, Enc_12535811, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b1;
let Inst{21-16} = 0b000001;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vaddwq_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VecPredRegs128B:$Qv4, VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32),
"if ($Qv4) $Vx32.w += $Vu32.w",
CVI_VA, TypeCVI_VA>, Enc_12535811, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b1;
let Inst{21-16} = 0b000001;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vaddwq_alt : HInst<
(outs VectorRegs:$Vx32),
(ins VecPredRegs:$Qv4, VectorRegs:$Vx32in, VectorRegs:$Vu32),
"if ($Qv4.w) $Vx32.w += $Vu32.w",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vaddwq_alt_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VecPredRegs128B:$Qv4, VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32),
"if ($Qv4.w) $Vx32.w += $Vu32.w",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vaddwsat : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.w = vadd($Vu32.w,$Vv32.w):sat",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddwsat_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.w = vadd($Vu32.w,$Vv32.w):sat",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vaddwsat_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vaddw($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddwsat_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vaddw($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vaddwsat_dv : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, VecDblRegs:$Vvv32),
"$Vdd32.w = vadd($Vuu32.w,$Vvv32.w):sat",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_13211717, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddwsat_dv_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, VecDblRegs128B:$Vvv32),
"$Vdd32.w = vadd($Vuu32.w,$Vvv32.w):sat",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_13211717, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vaddwsat_dv_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, VecDblRegs:$Vvv32),
"$Vdd32 = vaddw($Vuu32,$Vvv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddwsat_dv_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, VecDblRegs128B:$Vvv32),
"$Vdd32 = vaddw($Vuu32,$Vvv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_valignb : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32, IntRegsLow8:$Rt8),
"$Vd32 = valign($Vu32,$Vv32,$Rt8)",
CVI_VP_LONG, TypeCVI_VP>, Enc_11083408, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-24} = 0b00011011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_valignb_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32, IntRegsLow8:$Rt8),
"$Vd32 = valign($Vu32,$Vv32,$Rt8)",
CVI_VP_LONG, TypeCVI_VP>, Enc_11083408, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-24} = 0b00011011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_valignbi : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32, u3_0Imm:$Ii),
"$Vd32 = valign($Vu32,$Vv32,#$Ii)",
CVI_VP_LONG, TypeCVI_VP>, Enc_7171569, Requires<[HasV60T,UseHVX]> {
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011110001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_valignbi_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32, u3_0Imm:$Ii),
"$Vd32 = valign($Vu32,$Vv32,#$Ii)",
CVI_VP_LONG, TypeCVI_VP>, Enc_7171569, Requires<[HasV60T,UseHVX]> {
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011110001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vand : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vand($Vu32,$Vv32)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vand_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vand($Vu32,$Vv32)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vandnqrt : HInst<
(outs VectorRegs:$Vd32),
(ins VecPredRegs:$Qu4, IntRegs:$Rt32),
"$Vd32 = vand(!$Qu4,$Rt32)",
CVI_VX, TypeCVI_VX>, Enc_4711514, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-10} = 0b0001;
let Inst{31-21} = 0b00011001101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vandnqrt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VecPredRegs128B:$Qu4, IntRegs:$Rt32),
"$Vd32 = vand(!$Qu4,$Rt32)",
CVI_VX, TypeCVI_VX>, Enc_4711514, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-10} = 0b0001;
let Inst{31-21} = 0b00011001101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vandnqrt_acc : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VecPredRegs:$Qu4, IntRegs:$Rt32),
"$Vx32 |= vand(!$Qu4,$Rt32)",
CVI_VX, TypeCVI_VX>, Enc_4944558, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-10} = 0b1001;
let Inst{31-21} = 0b00011001011;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vandnqrt_acc_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VecPredRegs128B:$Qu4, IntRegs:$Rt32),
"$Vx32 |= vand(!$Qu4,$Rt32)",
CVI_VX, TypeCVI_VX>, Enc_4944558, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-10} = 0b1001;
let Inst{31-21} = 0b00011001011;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vandnqrt_acc_alt : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VecPredRegs:$Qu4, IntRegs:$Rt32),
"$Vx32.ub |= vand(!$Qu4.ub,$Rt32.ub)",
PSEUDO, TypeMAPPING>, Requires<[HasV62T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vandnqrt_acc_alt_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VecPredRegs128B:$Qu4, IntRegs:$Rt32),
"$Vx32.ub |= vand(!$Qu4.ub,$Rt32.ub)",
PSEUDO, TypeMAPPING>, Requires<[HasV62T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vandnqrt_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VecPredRegs:$Qu4, IntRegs:$Rt32),
"$Vd32.ub = vand(!$Qu4.ub,$Rt32.ub)",
PSEUDO, TypeMAPPING>, Requires<[HasV62T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vandnqrt_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VecPredRegs128B:$Qu4, IntRegs:$Rt32),
"$Vd32.ub = vand(!$Qu4.ub,$Rt32.ub)",
PSEUDO, TypeMAPPING>, Requires<[HasV62T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vandqrt : HInst<
(outs VectorRegs:$Vd32),
(ins VecPredRegs:$Qu4, IntRegs:$Rt32),
"$Vd32 = vand($Qu4,$Rt32)",
CVI_VX_LATE, TypeCVI_VX>, Enc_4711514, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-10} = 0b0000;
let Inst{31-21} = 0b00011001101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vandqrt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VecPredRegs128B:$Qu4, IntRegs:$Rt32),
"$Vd32 = vand($Qu4,$Rt32)",
CVI_VX_LATE, TypeCVI_VX>, Enc_4711514, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-10} = 0b0000;
let Inst{31-21} = 0b00011001101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vandqrt_acc : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VecPredRegs:$Qu4, IntRegs:$Rt32),
"$Vx32 |= vand($Qu4,$Rt32)",
CVI_VX_LATE, TypeCVI_VX>, Enc_4944558, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-10} = 0b1000;
let Inst{31-21} = 0b00011001011;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vandqrt_acc_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VecPredRegs128B:$Qu4, IntRegs:$Rt32),
"$Vx32 |= vand($Qu4,$Rt32)",
CVI_VX_LATE, TypeCVI_VX>, Enc_4944558, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-10} = 0b1000;
let Inst{31-21} = 0b00011001011;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vandqrt_acc_alt : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VecPredRegs:$Qu4, IntRegs:$Rt32),
"$Vx32.ub |= vand($Qu4.ub,$Rt32.ub)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vandqrt_acc_alt_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VecPredRegs128B:$Qu4, IntRegs:$Rt32),
"$Vx32.ub |= vand($Qu4.ub,$Rt32.ub)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vandqrt_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VecPredRegs:$Qu4, IntRegs:$Rt32),
"$Vd32.ub = vand($Qu4.ub,$Rt32.ub)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vandqrt_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VecPredRegs128B:$Qu4, IntRegs:$Rt32),
"$Vd32.ub = vand($Qu4.ub,$Rt32.ub)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vandvnqv : HInst<
(outs VectorRegs:$Vd32),
(ins VecPredRegs:$Qv4, VectorRegs:$Vu32),
"$Vd32 = vand(!$Qv4,$Vu32)",
CVI_VA, TypeCVI_VA>, Enc_1220199, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b1;
let Inst{21-16} = 0b000011;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vandvnqv_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VecPredRegs128B:$Qv4, VectorRegs128B:$Vu32),
"$Vd32 = vand(!$Qv4,$Vu32)",
CVI_VA, TypeCVI_VA>, Enc_1220199, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b1;
let Inst{21-16} = 0b000011;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vandvqv : HInst<
(outs VectorRegs:$Vd32),
(ins VecPredRegs:$Qv4, VectorRegs:$Vu32),
"$Vd32 = vand($Qv4,$Vu32)",
CVI_VA, TypeCVI_VA>, Enc_1220199, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b1;
let Inst{21-16} = 0b000011;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vandvqv_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VecPredRegs128B:$Qv4, VectorRegs128B:$Vu32),
"$Vd32 = vand($Qv4,$Vu32)",
CVI_VA, TypeCVI_VA>, Enc_1220199, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b1;
let Inst{21-16} = 0b000011;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vandvrt : HInst<
(outs VecPredRegs:$Qd4),
(ins VectorRegs:$Vu32, IntRegs:$Rt32),
"$Qd4 = vand($Vu32,$Rt32)",
CVI_VX_LATE, TypeCVI_VX>, Enc_11498120, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b010010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vandvrt_128B : HInst<
(outs VecPredRegs128B:$Qd4),
(ins VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Qd4 = vand($Vu32,$Rt32)",
CVI_VX_LATE, TypeCVI_VX>, Enc_11498120, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b010010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vandvrt_acc : HInst<
(outs VecPredRegs:$Qx4),
(ins VecPredRegs:$Qx4in, VectorRegs:$Vu32, IntRegs:$Rt32),
"$Qx4 |= vand($Vu32,$Rt32)",
CVI_VX_LATE, TypeCVI_VX>, Enc_10612292, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b100000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001011;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vandvrt_acc_128B : HInst<
(outs VecPredRegs128B:$Qx4),
(ins VecPredRegs128B:$Qx4in, VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Qx4 |= vand($Vu32,$Rt32)",
CVI_VX_LATE, TypeCVI_VX>, Enc_10612292, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b100000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001011;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vandvrt_acc_alt : HInst<
(outs VecPredRegs:$Qx4),
(ins VecPredRegs:$Qx4in, VectorRegs:$Vu32, IntRegs:$Rt32),
"$Qx4.ub |= vand($Vu32.ub,$Rt32.ub)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vandvrt_acc_alt_128B : HInst<
(outs VecPredRegs128B:$Qx4),
(ins VecPredRegs128B:$Qx4in, VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Qx4.ub |= vand($Vu32.ub,$Rt32.ub)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vandvrt_alt : HInst<
(outs VecPredRegs:$Qd4),
(ins VectorRegs:$Vu32, IntRegs:$Rt32),
"$Qd4.ub = vand($Vu32.ub,$Rt32.ub)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vandvrt_alt_128B : HInst<
(outs VecPredRegs128B:$Qd4),
(ins VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Qd4.ub = vand($Vu32.ub,$Rt32.ub)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vaslh : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vd32.h = vasl($Vu32.h,$Rt32)",
CVI_VS, TypeCVI_VS>, Enc_16214129, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaslh_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vd32.h = vasl($Vu32.h,$Rt32)",
CVI_VS, TypeCVI_VS>, Enc_16214129, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vaslh_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vd32 = vaslh($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaslh_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vd32 = vaslh($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vaslhv : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.h = vasl($Vu32.h,$Vv32.h)",
CVI_VS, TypeCVI_VS>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaslhv_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.h = vasl($Vu32.h,$Vv32.h)",
CVI_VS, TypeCVI_VS>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vaslhv_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vaslh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaslhv_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vaslh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vaslw : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vd32.w = vasl($Vu32.w,$Rt32)",
CVI_VS, TypeCVI_VS>, Enc_16214129, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaslw_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vd32.w = vasl($Vu32.w,$Rt32)",
CVI_VS, TypeCVI_VS>, Enc_16214129, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vaslw_acc : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vx32.w += vasl($Vu32.w,$Rt32)",
CVI_VS, TypeCVI_VS>, Enc_10058269, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001011;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vaslw_acc_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vx32.w += vasl($Vu32.w,$Rt32)",
CVI_VS, TypeCVI_VS>, Enc_10058269, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001011;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vaslw_acc_alt : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vx32 += vaslw($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vaslw_acc_alt_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vx32 += vaslw($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vaslw_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vd32 = vaslw($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaslw_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vd32 = vaslw($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vaslwv : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.w = vasl($Vu32.w,$Vv32.w)",
CVI_VS, TypeCVI_VS>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaslwv_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.w = vasl($Vu32.w,$Vv32.w)",
CVI_VS, TypeCVI_VS>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vaslwv_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vaslw($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaslwv_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vaslw($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vasrh : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vd32.h = vasr($Vu32.h,$Rt32)",
CVI_VS, TypeCVI_VS>, Enc_16214129, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vasrh_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vd32.h = vasr($Vu32.h,$Rt32)",
CVI_VS, TypeCVI_VS>, Enc_16214129, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vasrh_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vd32 = vasrh($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vasrh_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vd32 = vasrh($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vasrhbrndsat : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32, IntRegsLow8:$Rt8),
"$Vd32.b = vasr($Vu32.h,$Vv32.h,$Rt8):rnd:sat",
CVI_VS, TypeCVI_VS>, Enc_11083408, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b1;
let Inst{31-24} = 0b00011011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vasrhbrndsat_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32, IntRegsLow8:$Rt8),
"$Vd32.b = vasr($Vu32.h,$Vv32.h,$Rt8):rnd:sat",
CVI_VS, TypeCVI_VS>, Enc_11083408, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b1;
let Inst{31-24} = 0b00011011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vasrhbrndsat_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32, IntRegsLow8:$Rt8),
"$Vd32 = vasrhb($Vu32,$Vv32,$Rt8):rnd:sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def V6_vasrhbsat : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32, IntRegsLow8:$Rt8),
"$Vd32.b = vasr($Vu32.h,$Vv32.h,$Rt8):sat",
CVI_VS, TypeCVI_VS>, Enc_11083408, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-24} = 0b00011000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vasrhbsat_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32, IntRegsLow8:$Rt8),
"$Vd32.b = vasr($Vu32.h,$Vv32.h,$Rt8):sat",
CVI_VS, TypeCVI_VS>, Enc_11083408, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-24} = 0b00011000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vasrhubrndsat : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32, IntRegsLow8:$Rt8),
"$Vd32.ub = vasr($Vu32.h,$Vv32.h,$Rt8):rnd:sat",
CVI_VS, TypeCVI_VS>, Enc_11083408, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-24} = 0b00011011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vasrhubrndsat_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32, IntRegsLow8:$Rt8),
"$Vd32.ub = vasr($Vu32.h,$Vv32.h,$Rt8):rnd:sat",
CVI_VS, TypeCVI_VS>, Enc_11083408, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-24} = 0b00011011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vasrhubrndsat_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32, IntRegsLow8:$Rt8),
"$Vd32 = vasrhub($Vu32,$Vv32,$Rt8):rnd:sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def V6_vasrhubsat : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32, IntRegsLow8:$Rt8),
"$Vd32.ub = vasr($Vu32.h,$Vv32.h,$Rt8):sat",
CVI_VS, TypeCVI_VS>, Enc_11083408, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-24} = 0b00011011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vasrhubsat_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32, IntRegsLow8:$Rt8),
"$Vd32.ub = vasr($Vu32.h,$Vv32.h,$Rt8):sat",
CVI_VS, TypeCVI_VS>, Enc_11083408, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-24} = 0b00011011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vasrhubsat_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32, IntRegsLow8:$Rt8),
"$Vd32 = vasrhub($Vu32,$Vv32,$Rt8):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def V6_vasrhv : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.h = vasr($Vu32.h,$Vv32.h)",
CVI_VS, TypeCVI_VS>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vasrhv_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.h = vasr($Vu32.h,$Vv32.h)",
CVI_VS, TypeCVI_VS>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vasrhv_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vasrh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vasrhv_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vasrh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vasruwuhrndsat : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32, IntRegsLow8:$Rt8),
"$Vd32.uh = vasr($Vu32.uw,$Vv32.uw,$Rt8):rnd:sat",
CVI_VS, TypeCVI_VS>, Enc_11083408, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-24} = 0b00011000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vasruwuhrndsat_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32, IntRegsLow8:$Rt8),
"$Vd32.uh = vasr($Vu32.uw,$Vv32.uw,$Rt8):rnd:sat",
CVI_VS, TypeCVI_VS>, Enc_11083408, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-24} = 0b00011000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vasrw : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vd32.w = vasr($Vu32.w,$Rt32)",
CVI_VS, TypeCVI_VS>, Enc_16214129, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vasrw_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vd32.w = vasr($Vu32.w,$Rt32)",
CVI_VS, TypeCVI_VS>, Enc_16214129, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vasrw_acc : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vx32.w += vasr($Vu32.w,$Rt32)",
CVI_VS, TypeCVI_VS>, Enc_10058269, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001011;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vasrw_acc_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vx32.w += vasr($Vu32.w,$Rt32)",
CVI_VS, TypeCVI_VS>, Enc_10058269, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001011;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vasrw_acc_alt : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vx32 += vasrw($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vasrw_acc_alt_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vx32 += vasrw($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vasrw_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vd32 = vasrw($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vasrw_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vd32 = vasrw($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vasrwh : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32, IntRegsLow8:$Rt8),
"$Vd32.h = vasr($Vu32.w,$Vv32.w,$Rt8)",
CVI_VS, TypeCVI_VS>, Enc_11083408, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-24} = 0b00011011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vasrwh_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32, IntRegsLow8:$Rt8),
"$Vd32.h = vasr($Vu32.w,$Vv32.w,$Rt8)",
CVI_VS, TypeCVI_VS>, Enc_11083408, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-24} = 0b00011011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vasrwh_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32, IntRegsLow8:$Rt8),
"$Vd32 = vasrwh($Vu32,$Vv32,$Rt8)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def V6_vasrwhrndsat : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32, IntRegsLow8:$Rt8),
"$Vd32.h = vasr($Vu32.w,$Vv32.w,$Rt8):rnd:sat",
CVI_VS, TypeCVI_VS>, Enc_11083408, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-24} = 0b00011011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vasrwhrndsat_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32, IntRegsLow8:$Rt8),
"$Vd32.h = vasr($Vu32.w,$Vv32.w,$Rt8):rnd:sat",
CVI_VS, TypeCVI_VS>, Enc_11083408, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-24} = 0b00011011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vasrwhrndsat_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32, IntRegsLow8:$Rt8),
"$Vd32 = vasrwh($Vu32,$Vv32,$Rt8):rnd:sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def V6_vasrwhsat : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32, IntRegsLow8:$Rt8),
"$Vd32.h = vasr($Vu32.w,$Vv32.w,$Rt8):sat",
CVI_VS, TypeCVI_VS>, Enc_11083408, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-24} = 0b00011011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vasrwhsat_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32, IntRegsLow8:$Rt8),
"$Vd32.h = vasr($Vu32.w,$Vv32.w,$Rt8):sat",
CVI_VS, TypeCVI_VS>, Enc_11083408, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-24} = 0b00011011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vasrwhsat_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32, IntRegsLow8:$Rt8),
"$Vd32 = vasrwh($Vu32,$Vv32,$Rt8):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def V6_vasrwuhrndsat : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32, IntRegsLow8:$Rt8),
"$Vd32.uh = vasr($Vu32.w,$Vv32.w,$Rt8):rnd:sat",
CVI_VS, TypeCVI_VS>, Enc_11083408, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-24} = 0b00011000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vasrwuhrndsat_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32, IntRegsLow8:$Rt8),
"$Vd32.uh = vasr($Vu32.w,$Vv32.w,$Rt8):rnd:sat",
CVI_VS, TypeCVI_VS>, Enc_11083408, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-24} = 0b00011000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vasrwuhsat : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32, IntRegsLow8:$Rt8),
"$Vd32.uh = vasr($Vu32.w,$Vv32.w,$Rt8):sat",
CVI_VS, TypeCVI_VS>, Enc_11083408, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-24} = 0b00011011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vasrwuhsat_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32, IntRegsLow8:$Rt8),
"$Vd32.uh = vasr($Vu32.w,$Vv32.w,$Rt8):sat",
CVI_VS, TypeCVI_VS>, Enc_11083408, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-24} = 0b00011011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vasrwuhsat_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32, IntRegsLow8:$Rt8),
"$Vd32 = vasrwuh($Vu32,$Vv32,$Rt8):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def V6_vasrwv : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.w = vasr($Vu32.w,$Vv32.w)",
CVI_VS, TypeCVI_VS>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vasrwv_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.w = vasr($Vu32.w,$Vv32.w)",
CVI_VS, TypeCVI_VS>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vasrwv_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vasrw($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vasrwv_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vasrw($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vassign : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32),
"$Vd32 = $Vu32",
CVI_VA, TypeCVI_VA>, Enc_900013, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b1;
let Inst{31-16} = 0b0001111000000011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vassign_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32),
"$Vd32 = $Vu32",
CVI_VA, TypeCVI_VA>, Enc_900013, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b1;
let Inst{31-16} = 0b0001111000000011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vassignp : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32),
"$Vdd32 = $Vuu32",
CVI_VA, TypeCVI_VA>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vassignp_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32),
"$Vdd32 = $Vuu32",
CVI_VA, TypeCVI_VA>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vavgh : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.h = vavg($Vu32.h,$Vv32.h)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vavgh_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.h = vavg($Vu32.h,$Vv32.h)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vavgh_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vavgh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vavgh_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vavgh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vavghrnd : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.h = vavg($Vu32.h,$Vv32.h):rnd",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100111;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vavghrnd_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.h = vavg($Vu32.h,$Vv32.h):rnd",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100111;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vavghrnd_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vavgh($Vu32,$Vv32):rnd",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vavghrnd_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vavgh($Vu32,$Vv32):rnd",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vavgub : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.ub = vavg($Vu32.ub,$Vv32.ub)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vavgub_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.ub = vavg($Vu32.ub,$Vv32.ub)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vavgub_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vavgub($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vavgub_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vavgub($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vavgubrnd : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.ub = vavg($Vu32.ub,$Vv32.ub):rnd",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100111;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vavgubrnd_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.ub = vavg($Vu32.ub,$Vv32.ub):rnd",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100111;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vavgubrnd_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vavgub($Vu32,$Vv32):rnd",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vavgubrnd_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vavgub($Vu32,$Vv32):rnd",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vavguh : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.uh = vavg($Vu32.uh,$Vv32.uh)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vavguh_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.uh = vavg($Vu32.uh,$Vv32.uh)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vavguh_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vavguh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vavguh_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vavguh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vavguhrnd : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.uh = vavg($Vu32.uh,$Vv32.uh):rnd",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100111;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vavguhrnd_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.uh = vavg($Vu32.uh,$Vv32.uh):rnd",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100111;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vavguhrnd_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vavguh($Vu32,$Vv32):rnd",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vavguhrnd_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vavguh($Vu32,$Vv32):rnd",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vavgw : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.w = vavg($Vu32.w,$Vv32.w)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vavgw_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.w = vavg($Vu32.w,$Vv32.w)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vavgw_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vavgw($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vavgw_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vavgw($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vavgwrnd : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.w = vavg($Vu32.w,$Vv32.w):rnd",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100111;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vavgwrnd_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.w = vavg($Vu32.w,$Vv32.w):rnd",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100111;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vavgwrnd_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vavgw($Vu32,$Vv32):rnd",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vavgwrnd_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vavgw($Vu32,$Vv32):rnd",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vccombine : HInst<
(outs VecDblRegs:$Vdd32),
(ins PredRegs:$Ps4, VectorRegs:$Vu32, VectorRegs:$Vv32),
"if ($Ps4) $Vdd32 = vcombine($Vu32,$Vv32)",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_16145290, Requires<[HasV60T,UseHVX]> {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011010011;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vccombine_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins PredRegs:$Ps4, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"if ($Ps4) $Vdd32 = vcombine($Vu32,$Vv32)",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_16145290, Requires<[HasV60T,UseHVX]> {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011010011;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vcl0h : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32),
"$Vd32.uh = vcl0($Vu32.uh)",
CVI_VS, TypeCVI_VS>, Enc_900013, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vcl0h_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32),
"$Vd32.uh = vcl0($Vu32.uh)",
CVI_VS, TypeCVI_VS>, Enc_900013, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vcl0h_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32),
"$Vd32 = vcl0h($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vcl0h_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32),
"$Vd32 = vcl0h($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vcl0w : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32),
"$Vd32.uw = vcl0($Vu32.uw)",
CVI_VS, TypeCVI_VS>, Enc_900013, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vcl0w_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32),
"$Vd32.uw = vcl0($Vu32.uw)",
CVI_VS, TypeCVI_VS>, Enc_900013, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vcl0w_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32),
"$Vd32 = vcl0w($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vcl0w_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32),
"$Vd32 = vcl0w($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vcmov : HInst<
(outs VectorRegs:$Vd32),
(ins PredRegs:$Ps4, VectorRegs:$Vu32),
"if ($Ps4) $Vd32 = $Vu32",
CVI_VA, TypeCVI_VA>, Enc_12023037, Requires<[HasV60T,UseHVX]> {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001101000000000;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vcmov_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins PredRegs:$Ps4, VectorRegs128B:$Vu32),
"if ($Ps4) $Vd32 = $Vu32",
CVI_VA, TypeCVI_VA>, Enc_12023037, Requires<[HasV60T,UseHVX]> {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001101000000000;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vcombine : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vdd32 = vcombine($Vu32,$Vv32)",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_15290236, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111010;
let hasNewValue = 1;
let opNewValue = 0;
let isRegSequence = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vcombine_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vdd32 = vcombine($Vu32,$Vv32)",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_15290236, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111010;
let hasNewValue = 1;
let opNewValue = 0;
let isRegSequence = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vd0 : HInst<
(outs VectorRegs:$Vd32),
(ins),
"$Vd32 = #0",
CVI_VA, TypeCVI_VA>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vd0_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins),
"$Vd32 = #0",
CVI_VA, TypeCVI_VA>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vdeal : HInst<
(outs VectorRegs:$Vy32, VectorRegs:$Vx32),
(ins VectorRegs:$Vy32in, VectorRegs:$Vx32in, IntRegs:$Rt32),
"vdeal($Vy32,$Vx32,$Rt32)",
CVI_VP_VS_LONG_EARLY, TypeCVI_VP_VS>, Enc_11422009, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001111;
let hasNewValue = 1;
let opNewValue = 0;
let hasNewValue2 = 1;
let opNewValue2 = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vy32 = $Vy32in, $Vx32 = $Vx32in";
}
def V6_vdeal_128B : HInst<
(outs VectorRegs128B:$Vy32, VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vy32in, VectorRegs128B:$Vx32in, IntRegs:$Rt32),
"vdeal($Vy32,$Vx32,$Rt32)",
CVI_VP_VS_LONG_EARLY, TypeCVI_VP_VS>, Enc_11422009, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001111;
let hasNewValue = 1;
let opNewValue = 0;
let hasNewValue2 = 1;
let opNewValue2 = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vy32 = $Vy32in, $Vx32 = $Vx32in";
}
def V6_vdealb : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32),
"$Vd32.b = vdeal($Vu32.b)",
CVI_VP, TypeCVI_VP>, Enc_900013, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdealb4w : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.b = vdeale($Vu32.b,$Vv32.b)",
CVI_VP, TypeCVI_VP>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdealb4w_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.b = vdeale($Vu32.b,$Vv32.b)",
CVI_VP, TypeCVI_VP>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vdealb4w_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vdealb4w($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdealb4w_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vdealb4w($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vdealb_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32),
"$Vd32.b = vdeal($Vu32.b)",
CVI_VP, TypeCVI_VP>, Enc_900013, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vdealb_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32),
"$Vd32 = vdealb($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdealb_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32),
"$Vd32 = vdealb($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vdealh : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32),
"$Vd32.h = vdeal($Vu32.h)",
CVI_VP, TypeCVI_VP>, Enc_900013, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdealh_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32),
"$Vd32.h = vdeal($Vu32.h)",
CVI_VP, TypeCVI_VP>, Enc_900013, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vdealh_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32),
"$Vd32 = vdealh($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdealh_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32),
"$Vd32 = vdealh($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vdealvdd : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32, IntRegsLow8:$Rt8),
"$Vdd32 = vdeal($Vu32,$Vv32,$Rt8)",
CVI_VP_VS_LONG, TypeCVI_VP_VS>, Enc_14767681, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b1;
let Inst{31-24} = 0b00011011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdealvdd_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32, IntRegsLow8:$Rt8),
"$Vdd32 = vdeal($Vu32,$Vv32,$Rt8)",
CVI_VP_VS_LONG, TypeCVI_VP_VS>, Enc_14767681, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b1;
let Inst{31-24} = 0b00011011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vdelta : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vdelta($Vu32,$Vv32)",
CVI_VP, TypeCVI_VP>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdelta_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vdelta($Vu32,$Vv32)",
CVI_VP, TypeCVI_VP>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vdmpybus : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vd32.h = vdmpy($Vu32.ub,$Rt32.b)",
CVI_VX, TypeCVI_VX>, Enc_16214129, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdmpybus_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vd32.h = vdmpy($Vu32.ub,$Rt32.b)",
CVI_VX, TypeCVI_VX>, Enc_16214129, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vdmpybus_acc : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vx32.h += vdmpy($Vu32.ub,$Rt32.b)",
CVI_VX, TypeCVI_VX>, Enc_10058269, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vdmpybus_acc_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vx32.h += vdmpy($Vu32.ub,$Rt32.b)",
CVI_VX, TypeCVI_VX>, Enc_10058269, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vdmpybus_acc_alt : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vx32 += vdmpybus($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vdmpybus_acc_alt_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vx32 += vdmpybus($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vdmpybus_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vd32 = vdmpybus($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdmpybus_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vd32 = vdmpybus($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vdmpybus_dv : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, IntRegs:$Rt32),
"$Vdd32.h = vdmpy($Vuu32.ub,$Rt32.b)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_5023792, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdmpybus_dv_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, IntRegs:$Rt32),
"$Vdd32.h = vdmpy($Vuu32.ub,$Rt32.b)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_5023792, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vdmpybus_dv_acc : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VecDblRegs:$Vuu32, IntRegs:$Rt32),
"$Vxx32.h += vdmpy($Vuu32.ub,$Rt32.b)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_4327792, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vdmpybus_dv_acc_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VecDblRegs128B:$Vuu32, IntRegs:$Rt32),
"$Vxx32.h += vdmpy($Vuu32.ub,$Rt32.b)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_4327792, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vdmpybus_dv_acc_alt : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VecDblRegs:$Vuu32, IntRegs:$Rt32),
"$Vxx32 += vdmpybus($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vdmpybus_dv_acc_alt_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VecDblRegs128B:$Vuu32, IntRegs:$Rt32),
"$Vxx32 += vdmpybus($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vdmpybus_dv_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, IntRegs:$Rt32),
"$Vdd32 = vdmpybus($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdmpybus_dv_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, IntRegs:$Rt32),
"$Vdd32 = vdmpybus($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vdmpyhb : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vd32.w = vdmpy($Vu32.h,$Rt32.b)",
CVI_VX, TypeCVI_VX>, Enc_16214129, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdmpyhb_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vd32.w = vdmpy($Vu32.h,$Rt32.b)",
CVI_VX, TypeCVI_VX>, Enc_16214129, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vdmpyhb_acc : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vx32.w += vdmpy($Vu32.h,$Rt32.b)",
CVI_VX, TypeCVI_VX>, Enc_10058269, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vdmpyhb_acc_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vx32.w += vdmpy($Vu32.h,$Rt32.b)",
CVI_VX, TypeCVI_VX>, Enc_10058269, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vdmpyhb_acc_alt : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vx32 += vdmpyhb($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vdmpyhb_acc_alt_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vx32 += vdmpyhb($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vdmpyhb_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vd32 = vdmpyhb($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdmpyhb_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vd32 = vdmpyhb($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vdmpyhb_dv : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, IntRegs:$Rt32),
"$Vdd32.w = vdmpy($Vuu32.h,$Rt32.b)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_5023792, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdmpyhb_dv_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, IntRegs:$Rt32),
"$Vdd32.w = vdmpy($Vuu32.h,$Rt32.b)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_5023792, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vdmpyhb_dv_acc : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VecDblRegs:$Vuu32, IntRegs:$Rt32),
"$Vxx32.w += vdmpy($Vuu32.h,$Rt32.b)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_4327792, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001001;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vdmpyhb_dv_acc_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VecDblRegs128B:$Vuu32, IntRegs:$Rt32),
"$Vxx32.w += vdmpy($Vuu32.h,$Rt32.b)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_4327792, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001001;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vdmpyhb_dv_acc_alt : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VecDblRegs:$Vuu32, IntRegs:$Rt32),
"$Vxx32 += vdmpyhb($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vdmpyhb_dv_acc_alt_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VecDblRegs128B:$Vuu32, IntRegs:$Rt32),
"$Vxx32 += vdmpyhb($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vdmpyhb_dv_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, IntRegs:$Rt32),
"$Vdd32 = vdmpyhb($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdmpyhb_dv_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, IntRegs:$Rt32),
"$Vdd32 = vdmpyhb($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vdmpyhisat : HInst<
(outs VectorRegs:$Vd32),
(ins VecDblRegs:$Vuu32, IntRegs:$Rt32),
"$Vd32.w = vdmpy($Vuu32.h,$Rt32.h):sat",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_36641, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdmpyhisat_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VecDblRegs128B:$Vuu32, IntRegs:$Rt32),
"$Vd32.w = vdmpy($Vuu32.h,$Rt32.h):sat",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_36641, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vdmpyhisat_acc : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VecDblRegs:$Vuu32, IntRegs:$Rt32),
"$Vx32.w += vdmpy($Vuu32.h,$Rt32.h):sat",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_5890213, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001001;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vdmpyhisat_acc_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VecDblRegs128B:$Vuu32, IntRegs:$Rt32),
"$Vx32.w += vdmpy($Vuu32.h,$Rt32.h):sat",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_5890213, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001001;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vdmpyhisat_acc_alt : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VecDblRegs:$Vuu32, IntRegs:$Rt32),
"$Vx32 += vdmpyh($Vuu32,$Rt32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vdmpyhisat_acc_alt_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VecDblRegs128B:$Vuu32, IntRegs:$Rt32),
"$Vx32 += vdmpyh($Vuu32,$Rt32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vdmpyhisat_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VecDblRegs:$Vuu32, IntRegs:$Rt32),
"$Vd32 = vdmpyh($Vuu32,$Rt32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdmpyhisat_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VecDblRegs128B:$Vuu32, IntRegs:$Rt32),
"$Vd32 = vdmpyh($Vuu32,$Rt32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vdmpyhsat : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vd32.w = vdmpy($Vu32.h,$Rt32.h):sat",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_16214129, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdmpyhsat_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vd32.w = vdmpy($Vu32.h,$Rt32.h):sat",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_16214129, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vdmpyhsat_acc : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vx32.w += vdmpy($Vu32.h,$Rt32.h):sat",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_10058269, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001001;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vdmpyhsat_acc_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vx32.w += vdmpy($Vu32.h,$Rt32.h):sat",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_10058269, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001001;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vdmpyhsat_acc_alt : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vx32 += vdmpyh($Vu32,$Rt32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vdmpyhsat_acc_alt_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vx32 += vdmpyh($Vu32,$Rt32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vdmpyhsat_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vd32 = vdmpyh($Vu32,$Rt32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdmpyhsat_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vd32 = vdmpyh($Vu32,$Rt32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vdmpyhsuisat : HInst<
(outs VectorRegs:$Vd32),
(ins VecDblRegs:$Vuu32, IntRegs:$Rt32),
"$Vd32.w = vdmpy($Vuu32.h,$Rt32.uh,#1):sat",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_36641, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdmpyhsuisat_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VecDblRegs128B:$Vuu32, IntRegs:$Rt32),
"$Vd32.w = vdmpy($Vuu32.h,$Rt32.uh,#1):sat",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_36641, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vdmpyhsuisat_acc : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VecDblRegs:$Vuu32, IntRegs:$Rt32),
"$Vx32.w += vdmpy($Vuu32.h,$Rt32.uh,#1):sat",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_5890213, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001001;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vdmpyhsuisat_acc_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VecDblRegs128B:$Vuu32, IntRegs:$Rt32),
"$Vx32.w += vdmpy($Vuu32.h,$Rt32.uh,#1):sat",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_5890213, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001001;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vdmpyhsuisat_acc_alt : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VecDblRegs:$Vuu32, IntRegs:$Rt32),
"$Vx32 += vdmpyhsu($Vuu32,$Rt32,#1):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vdmpyhsuisat_acc_alt_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VecDblRegs128B:$Vuu32, IntRegs:$Rt32),
"$Vx32 += vdmpyhsu($Vuu32,$Rt32,#1):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vdmpyhsuisat_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VecDblRegs:$Vuu32, IntRegs:$Rt32),
"$Vd32 = vdmpyhsu($Vuu32,$Rt32,#1):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdmpyhsuisat_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VecDblRegs128B:$Vuu32, IntRegs:$Rt32),
"$Vd32 = vdmpyhsu($Vuu32,$Rt32,#1):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vdmpyhsusat : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vd32.w = vdmpy($Vu32.h,$Rt32.uh):sat",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_16214129, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdmpyhsusat_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vd32.w = vdmpy($Vu32.h,$Rt32.uh):sat",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_16214129, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vdmpyhsusat_acc : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vx32.w += vdmpy($Vu32.h,$Rt32.uh):sat",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_10058269, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001001;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vdmpyhsusat_acc_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vx32.w += vdmpy($Vu32.h,$Rt32.uh):sat",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_10058269, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001001;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vdmpyhsusat_acc_alt : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vx32 += vdmpyhsu($Vu32,$Rt32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vdmpyhsusat_acc_alt_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vx32 += vdmpyhsu($Vu32,$Rt32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vdmpyhsusat_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vd32 = vdmpyhsu($Vu32,$Rt32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdmpyhsusat_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vd32 = vdmpyhsu($Vu32,$Rt32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vdmpyhvsat : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.w = vdmpy($Vu32.h,$Vv32.h):sat",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdmpyhvsat_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.w = vdmpy($Vu32.h,$Vv32.h):sat",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vdmpyhvsat_acc : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vx32.w += vdmpy($Vu32.h,$Vv32.h):sat",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_2328527, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vdmpyhvsat_acc_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vx32.w += vdmpy($Vu32.h,$Vv32.h):sat",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_2328527, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vdmpyhvsat_acc_alt : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vx32 += vdmpyh($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vdmpyhvsat_acc_alt_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vx32 += vdmpyh($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vdmpyhvsat_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vdmpyh($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdmpyhvsat_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vdmpyh($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vdsaduh : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, IntRegs:$Rt32),
"$Vdd32.uw = vdsad($Vuu32.uh,$Rt32.uh)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_5023792, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdsaduh_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, IntRegs:$Rt32),
"$Vdd32.uw = vdsad($Vuu32.uh,$Rt32.uh)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_5023792, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vdsaduh_acc : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VecDblRegs:$Vuu32, IntRegs:$Rt32),
"$Vxx32.uw += vdsad($Vuu32.uh,$Rt32.uh)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_4327792, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001011;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vdsaduh_acc_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VecDblRegs128B:$Vuu32, IntRegs:$Rt32),
"$Vxx32.uw += vdsad($Vuu32.uh,$Rt32.uh)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_4327792, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001011;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vdsaduh_acc_alt : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VecDblRegs:$Vuu32, IntRegs:$Rt32),
"$Vxx32 += vdsaduh($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vdsaduh_acc_alt_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VecDblRegs128B:$Vuu32, IntRegs:$Rt32),
"$Vxx32 += vdsaduh($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vdsaduh_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, IntRegs:$Rt32),
"$Vdd32 = vdsaduh($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdsaduh_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, IntRegs:$Rt32),
"$Vdd32 = vdsaduh($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_veqb : HInst<
(outs VecPredRegs:$Qd4),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Qd4 = vcmp.eq($Vu32.b,$Vv32.b)",
CVI_VA, TypeCVI_VA>, Enc_13983714, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b000000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_veqb_128B : HInst<
(outs VecPredRegs128B:$Qd4),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Qd4 = vcmp.eq($Vu32.b,$Vv32.b)",
CVI_VA, TypeCVI_VA>, Enc_13983714, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b000000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_veqb_and : HInst<
(outs VecPredRegs:$Qx4),
(ins VecPredRegs:$Qx4in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Qx4 &= vcmp.eq($Vu32.b,$Vv32.b)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b000000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_veqb_and_128B : HInst<
(outs VecPredRegs128B:$Qx4),
(ins VecPredRegs128B:$Qx4in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Qx4 &= vcmp.eq($Vu32.b,$Vv32.b)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b000000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Qx4 = $Qx4in";
}
def V6_veqb_or : HInst<
(outs VecPredRegs:$Qx4),
(ins VecPredRegs:$Qx4in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Qx4 |= vcmp.eq($Vu32.b,$Vv32.b)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b010000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_veqb_or_128B : HInst<
(outs VecPredRegs128B:$Qx4),
(ins VecPredRegs128B:$Qx4in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Qx4 |= vcmp.eq($Vu32.b,$Vv32.b)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b010000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Qx4 = $Qx4in";
}
def V6_veqb_xor : HInst<
(outs VecPredRegs:$Qx4),
(ins VecPredRegs:$Qx4in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Qx4 ^= vcmp.eq($Vu32.b,$Vv32.b)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b100000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_veqb_xor_128B : HInst<
(outs VecPredRegs128B:$Qx4),
(ins VecPredRegs128B:$Qx4in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Qx4 ^= vcmp.eq($Vu32.b,$Vv32.b)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b100000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Qx4 = $Qx4in";
}
def V6_veqh : HInst<
(outs VecPredRegs:$Qd4),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Qd4 = vcmp.eq($Vu32.h,$Vv32.h)",
CVI_VA, TypeCVI_VA>, Enc_13983714, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b000001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_veqh_128B : HInst<
(outs VecPredRegs128B:$Qd4),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Qd4 = vcmp.eq($Vu32.h,$Vv32.h)",
CVI_VA, TypeCVI_VA>, Enc_13983714, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b000001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_veqh_and : HInst<
(outs VecPredRegs:$Qx4),
(ins VecPredRegs:$Qx4in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Qx4 &= vcmp.eq($Vu32.h,$Vv32.h)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b000001;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_veqh_and_128B : HInst<
(outs VecPredRegs128B:$Qx4),
(ins VecPredRegs128B:$Qx4in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Qx4 &= vcmp.eq($Vu32.h,$Vv32.h)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b000001;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Qx4 = $Qx4in";
}
def V6_veqh_or : HInst<
(outs VecPredRegs:$Qx4),
(ins VecPredRegs:$Qx4in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Qx4 |= vcmp.eq($Vu32.h,$Vv32.h)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b010001;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_veqh_or_128B : HInst<
(outs VecPredRegs128B:$Qx4),
(ins VecPredRegs128B:$Qx4in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Qx4 |= vcmp.eq($Vu32.h,$Vv32.h)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b010001;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Qx4 = $Qx4in";
}
def V6_veqh_xor : HInst<
(outs VecPredRegs:$Qx4),
(ins VecPredRegs:$Qx4in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Qx4 ^= vcmp.eq($Vu32.h,$Vv32.h)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b100001;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_veqh_xor_128B : HInst<
(outs VecPredRegs128B:$Qx4),
(ins VecPredRegs128B:$Qx4in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Qx4 ^= vcmp.eq($Vu32.h,$Vv32.h)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b100001;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Qx4 = $Qx4in";
}
def V6_veqw : HInst<
(outs VecPredRegs:$Qd4),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Qd4 = vcmp.eq($Vu32.w,$Vv32.w)",
CVI_VA, TypeCVI_VA>, Enc_13983714, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b000010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_veqw_128B : HInst<
(outs VecPredRegs128B:$Qd4),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Qd4 = vcmp.eq($Vu32.w,$Vv32.w)",
CVI_VA, TypeCVI_VA>, Enc_13983714, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b000010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_veqw_and : HInst<
(outs VecPredRegs:$Qx4),
(ins VecPredRegs:$Qx4in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Qx4 &= vcmp.eq($Vu32.w,$Vv32.w)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b000010;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_veqw_and_128B : HInst<
(outs VecPredRegs128B:$Qx4),
(ins VecPredRegs128B:$Qx4in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Qx4 &= vcmp.eq($Vu32.w,$Vv32.w)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b000010;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Qx4 = $Qx4in";
}
def V6_veqw_or : HInst<
(outs VecPredRegs:$Qx4),
(ins VecPredRegs:$Qx4in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Qx4 |= vcmp.eq($Vu32.w,$Vv32.w)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b010010;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_veqw_or_128B : HInst<
(outs VecPredRegs128B:$Qx4),
(ins VecPredRegs128B:$Qx4in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Qx4 |= vcmp.eq($Vu32.w,$Vv32.w)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b010010;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Qx4 = $Qx4in";
}
def V6_veqw_xor : HInst<
(outs VecPredRegs:$Qx4),
(ins VecPredRegs:$Qx4in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Qx4 ^= vcmp.eq($Vu32.w,$Vv32.w)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b100010;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_veqw_xor_128B : HInst<
(outs VecPredRegs128B:$Qx4),
(ins VecPredRegs128B:$Qx4in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Qx4 ^= vcmp.eq($Vu32.w,$Vv32.w)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b100010;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgtb : HInst<
(outs VecPredRegs:$Qd4),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Qd4 = vcmp.gt($Vu32.b,$Vv32.b)",
CVI_VA, TypeCVI_VA>, Enc_13983714, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b000100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vgtb_128B : HInst<
(outs VecPredRegs128B:$Qd4),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Qd4 = vcmp.gt($Vu32.b,$Vv32.b)",
CVI_VA, TypeCVI_VA>, Enc_13983714, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b000100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vgtb_and : HInst<
(outs VecPredRegs:$Qx4),
(ins VecPredRegs:$Qx4in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Qx4 &= vcmp.gt($Vu32.b,$Vv32.b)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b000100;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgtb_and_128B : HInst<
(outs VecPredRegs128B:$Qx4),
(ins VecPredRegs128B:$Qx4in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Qx4 &= vcmp.gt($Vu32.b,$Vv32.b)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b000100;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgtb_or : HInst<
(outs VecPredRegs:$Qx4),
(ins VecPredRegs:$Qx4in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Qx4 |= vcmp.gt($Vu32.b,$Vv32.b)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b010100;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgtb_or_128B : HInst<
(outs VecPredRegs128B:$Qx4),
(ins VecPredRegs128B:$Qx4in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Qx4 |= vcmp.gt($Vu32.b,$Vv32.b)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b010100;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgtb_xor : HInst<
(outs VecPredRegs:$Qx4),
(ins VecPredRegs:$Qx4in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Qx4 ^= vcmp.gt($Vu32.b,$Vv32.b)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b100100;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgtb_xor_128B : HInst<
(outs VecPredRegs128B:$Qx4),
(ins VecPredRegs128B:$Qx4in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Qx4 ^= vcmp.gt($Vu32.b,$Vv32.b)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b100100;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgth : HInst<
(outs VecPredRegs:$Qd4),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Qd4 = vcmp.gt($Vu32.h,$Vv32.h)",
CVI_VA, TypeCVI_VA>, Enc_13983714, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b000101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vgth_128B : HInst<
(outs VecPredRegs128B:$Qd4),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Qd4 = vcmp.gt($Vu32.h,$Vv32.h)",
CVI_VA, TypeCVI_VA>, Enc_13983714, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b000101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vgth_and : HInst<
(outs VecPredRegs:$Qx4),
(ins VecPredRegs:$Qx4in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Qx4 &= vcmp.gt($Vu32.h,$Vv32.h)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b000101;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgth_and_128B : HInst<
(outs VecPredRegs128B:$Qx4),
(ins VecPredRegs128B:$Qx4in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Qx4 &= vcmp.gt($Vu32.h,$Vv32.h)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b000101;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgth_or : HInst<
(outs VecPredRegs:$Qx4),
(ins VecPredRegs:$Qx4in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Qx4 |= vcmp.gt($Vu32.h,$Vv32.h)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b010101;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgth_or_128B : HInst<
(outs VecPredRegs128B:$Qx4),
(ins VecPredRegs128B:$Qx4in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Qx4 |= vcmp.gt($Vu32.h,$Vv32.h)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b010101;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgth_xor : HInst<
(outs VecPredRegs:$Qx4),
(ins VecPredRegs:$Qx4in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Qx4 ^= vcmp.gt($Vu32.h,$Vv32.h)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b100101;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgth_xor_128B : HInst<
(outs VecPredRegs128B:$Qx4),
(ins VecPredRegs128B:$Qx4in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Qx4 ^= vcmp.gt($Vu32.h,$Vv32.h)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b100101;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgtub : HInst<
(outs VecPredRegs:$Qd4),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Qd4 = vcmp.gt($Vu32.ub,$Vv32.ub)",
CVI_VA, TypeCVI_VA>, Enc_13983714, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b001000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vgtub_128B : HInst<
(outs VecPredRegs128B:$Qd4),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Qd4 = vcmp.gt($Vu32.ub,$Vv32.ub)",
CVI_VA, TypeCVI_VA>, Enc_13983714, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b001000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vgtub_and : HInst<
(outs VecPredRegs:$Qx4),
(ins VecPredRegs:$Qx4in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Qx4 &= vcmp.gt($Vu32.ub,$Vv32.ub)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b001000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgtub_and_128B : HInst<
(outs VecPredRegs128B:$Qx4),
(ins VecPredRegs128B:$Qx4in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Qx4 &= vcmp.gt($Vu32.ub,$Vv32.ub)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b001000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgtub_or : HInst<
(outs VecPredRegs:$Qx4),
(ins VecPredRegs:$Qx4in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Qx4 |= vcmp.gt($Vu32.ub,$Vv32.ub)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b011000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgtub_or_128B : HInst<
(outs VecPredRegs128B:$Qx4),
(ins VecPredRegs128B:$Qx4in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Qx4 |= vcmp.gt($Vu32.ub,$Vv32.ub)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b011000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgtub_xor : HInst<
(outs VecPredRegs:$Qx4),
(ins VecPredRegs:$Qx4in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Qx4 ^= vcmp.gt($Vu32.ub,$Vv32.ub)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b101000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgtub_xor_128B : HInst<
(outs VecPredRegs128B:$Qx4),
(ins VecPredRegs128B:$Qx4in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Qx4 ^= vcmp.gt($Vu32.ub,$Vv32.ub)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b101000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgtuh : HInst<
(outs VecPredRegs:$Qd4),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Qd4 = vcmp.gt($Vu32.uh,$Vv32.uh)",
CVI_VA, TypeCVI_VA>, Enc_13983714, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b001001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vgtuh_128B : HInst<
(outs VecPredRegs128B:$Qd4),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Qd4 = vcmp.gt($Vu32.uh,$Vv32.uh)",
CVI_VA, TypeCVI_VA>, Enc_13983714, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b001001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vgtuh_and : HInst<
(outs VecPredRegs:$Qx4),
(ins VecPredRegs:$Qx4in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Qx4 &= vcmp.gt($Vu32.uh,$Vv32.uh)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b001001;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgtuh_and_128B : HInst<
(outs VecPredRegs128B:$Qx4),
(ins VecPredRegs128B:$Qx4in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Qx4 &= vcmp.gt($Vu32.uh,$Vv32.uh)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b001001;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgtuh_or : HInst<
(outs VecPredRegs:$Qx4),
(ins VecPredRegs:$Qx4in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Qx4 |= vcmp.gt($Vu32.uh,$Vv32.uh)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b011001;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgtuh_or_128B : HInst<
(outs VecPredRegs128B:$Qx4),
(ins VecPredRegs128B:$Qx4in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Qx4 |= vcmp.gt($Vu32.uh,$Vv32.uh)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b011001;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgtuh_xor : HInst<
(outs VecPredRegs:$Qx4),
(ins VecPredRegs:$Qx4in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Qx4 ^= vcmp.gt($Vu32.uh,$Vv32.uh)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b101001;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgtuh_xor_128B : HInst<
(outs VecPredRegs128B:$Qx4),
(ins VecPredRegs128B:$Qx4in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Qx4 ^= vcmp.gt($Vu32.uh,$Vv32.uh)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b101001;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgtuw : HInst<
(outs VecPredRegs:$Qd4),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Qd4 = vcmp.gt($Vu32.uw,$Vv32.uw)",
CVI_VA, TypeCVI_VA>, Enc_13983714, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b001010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vgtuw_128B : HInst<
(outs VecPredRegs128B:$Qd4),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Qd4 = vcmp.gt($Vu32.uw,$Vv32.uw)",
CVI_VA, TypeCVI_VA>, Enc_13983714, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b001010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vgtuw_and : HInst<
(outs VecPredRegs:$Qx4),
(ins VecPredRegs:$Qx4in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Qx4 &= vcmp.gt($Vu32.uw,$Vv32.uw)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b001010;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgtuw_and_128B : HInst<
(outs VecPredRegs128B:$Qx4),
(ins VecPredRegs128B:$Qx4in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Qx4 &= vcmp.gt($Vu32.uw,$Vv32.uw)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b001010;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgtuw_or : HInst<
(outs VecPredRegs:$Qx4),
(ins VecPredRegs:$Qx4in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Qx4 |= vcmp.gt($Vu32.uw,$Vv32.uw)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b011010;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgtuw_or_128B : HInst<
(outs VecPredRegs128B:$Qx4),
(ins VecPredRegs128B:$Qx4in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Qx4 |= vcmp.gt($Vu32.uw,$Vv32.uw)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b011010;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgtuw_xor : HInst<
(outs VecPredRegs:$Qx4),
(ins VecPredRegs:$Qx4in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Qx4 ^= vcmp.gt($Vu32.uw,$Vv32.uw)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b101010;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgtuw_xor_128B : HInst<
(outs VecPredRegs128B:$Qx4),
(ins VecPredRegs128B:$Qx4in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Qx4 ^= vcmp.gt($Vu32.uw,$Vv32.uw)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b101010;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgtw : HInst<
(outs VecPredRegs:$Qd4),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Qd4 = vcmp.gt($Vu32.w,$Vv32.w)",
CVI_VA, TypeCVI_VA>, Enc_13983714, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b000110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vgtw_128B : HInst<
(outs VecPredRegs128B:$Qd4),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Qd4 = vcmp.gt($Vu32.w,$Vv32.w)",
CVI_VA, TypeCVI_VA>, Enc_13983714, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b000110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vgtw_and : HInst<
(outs VecPredRegs:$Qx4),
(ins VecPredRegs:$Qx4in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Qx4 &= vcmp.gt($Vu32.w,$Vv32.w)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b000110;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgtw_and_128B : HInst<
(outs VecPredRegs128B:$Qx4),
(ins VecPredRegs128B:$Qx4in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Qx4 &= vcmp.gt($Vu32.w,$Vv32.w)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b000110;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgtw_or : HInst<
(outs VecPredRegs:$Qx4),
(ins VecPredRegs:$Qx4in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Qx4 |= vcmp.gt($Vu32.w,$Vv32.w)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b010110;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgtw_or_128B : HInst<
(outs VecPredRegs128B:$Qx4),
(ins VecPredRegs128B:$Qx4in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Qx4 |= vcmp.gt($Vu32.w,$Vv32.w)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b010110;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgtw_xor : HInst<
(outs VecPredRegs:$Qx4),
(ins VecPredRegs:$Qx4in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Qx4 ^= vcmp.gt($Vu32.w,$Vv32.w)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b100110;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgtw_xor_128B : HInst<
(outs VecPredRegs128B:$Qx4),
(ins VecPredRegs128B:$Qx4in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Qx4 ^= vcmp.gt($Vu32.w,$Vv32.w)",
CVI_VA, TypeCVI_VA>, Enc_7470998, Requires<[HasV60T,UseHVX]> {
let Inst{7-2} = 0b100110;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vhist : HInst<
(outs),
(ins),
"vhist",
CVI_HIST, TypeCVI_HIST>, Enc_0, Requires<[HasV60T,UseHVX]> {
let Inst{13-0} = 0b10000010000000;
let Inst{31-16} = 0b0001111000000000;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vhist_128B : HInst<
(outs),
(ins),
"vhist",
CVI_HIST, TypeCVI_HIST>, Enc_0, Requires<[HasV60T,UseHVX]> {
let Inst{13-0} = 0b10000010000000;
let Inst{31-16} = 0b0001111000000000;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vhistq : HInst<
(outs),
(ins VecPredRegs:$Qv4),
"vhist($Qv4)",
CVI_HIST, TypeCVI_HIST>, Enc_4109168, Requires<[HasV60T,UseHVX]> {
let Inst{13-0} = 0b10000010000000;
let Inst{21-16} = 0b000010;
let Inst{31-24} = 0b00011110;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vhistq_128B : HInst<
(outs),
(ins VecPredRegs128B:$Qv4),
"vhist($Qv4)",
CVI_HIST, TypeCVI_HIST>, Enc_4109168, Requires<[HasV60T,UseHVX]> {
let Inst{13-0} = 0b10000010000000;
let Inst{21-16} = 0b000010;
let Inst{31-24} = 0b00011110;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vinsertwr : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, IntRegs:$Rt32),
"$Vx32.w = vinsert($Rt32)",
CVI_VX_LATE, TypeCVI_VX>, Enc_313333, Requires<[HasV60T,UseHVX]> {
let Inst{13-5} = 0b100000001;
let Inst{31-21} = 0b00011001101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vinsertwr_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, IntRegs:$Rt32),
"$Vx32.w = vinsert($Rt32)",
CVI_VX_LATE, TypeCVI_VX>, Enc_313333, Requires<[HasV60T,UseHVX]> {
let Inst{13-5} = 0b100000001;
let Inst{31-21} = 0b00011001101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vlalignb : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32, IntRegsLow8:$Rt8),
"$Vd32 = vlalign($Vu32,$Vv32,$Rt8)",
CVI_VP_LONG, TypeCVI_VP>, Enc_11083408, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-24} = 0b00011011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vlalignb_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32, IntRegsLow8:$Rt8),
"$Vd32 = vlalign($Vu32,$Vv32,$Rt8)",
CVI_VP_LONG, TypeCVI_VP>, Enc_11083408, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-24} = 0b00011011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vlalignbi : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32, u3_0Imm:$Ii),
"$Vd32 = vlalign($Vu32,$Vv32,#$Ii)",
CVI_VP_LONG, TypeCVI_VP>, Enc_7171569, Requires<[HasV60T,UseHVX]> {
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011110011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vlalignbi_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32, u3_0Imm:$Ii),
"$Vd32 = vlalign($Vu32,$Vv32,#$Ii)",
CVI_VP_LONG, TypeCVI_VP>, Enc_7171569, Requires<[HasV60T,UseHVX]> {
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011110011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vlsrb : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vd32.ub = vlsr($Vu32.ub,$Rt32)",
CVI_VS, TypeCVI_VS>, Enc_16214129, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vlsrb_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vd32.ub = vlsr($Vu32.ub,$Rt32)",
CVI_VS, TypeCVI_VS>, Enc_16214129, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vlsrh : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vd32.uh = vlsr($Vu32.uh,$Rt32)",
CVI_VS, TypeCVI_VS>, Enc_16214129, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vlsrh_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vd32.uh = vlsr($Vu32.uh,$Rt32)",
CVI_VS, TypeCVI_VS>, Enc_16214129, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vlsrh_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vd32 = vlsrh($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vlsrh_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vd32 = vlsrh($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vlsrhv : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.h = vlsr($Vu32.h,$Vv32.h)",
CVI_VS, TypeCVI_VS>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vlsrhv_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.h = vlsr($Vu32.h,$Vv32.h)",
CVI_VS, TypeCVI_VS>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vlsrhv_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vlsrh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vlsrhv_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vlsrh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vlsrw : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vd32.uw = vlsr($Vu32.uw,$Rt32)",
CVI_VS, TypeCVI_VS>, Enc_16214129, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vlsrw_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vd32.uw = vlsr($Vu32.uw,$Rt32)",
CVI_VS, TypeCVI_VS>, Enc_16214129, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vlsrw_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vd32 = vlsrw($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vlsrw_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vd32 = vlsrw($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vlsrwv : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.w = vlsr($Vu32.w,$Vv32.w)",
CVI_VS, TypeCVI_VS>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vlsrwv_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.w = vlsr($Vu32.w,$Vv32.w)",
CVI_VS, TypeCVI_VS>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vlsrwv_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vlsrw($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vlsrwv_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vlsrw($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vlutvvb : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32, IntRegsLow8:$Rt8),
"$Vd32.b = vlut32($Vu32.b,$Vv32.b,$Rt8)",
CVI_VP_LONG, TypeCVI_VP>, Enc_11083408, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b1;
let Inst{31-24} = 0b00011011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vlutvvb_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32, IntRegsLow8:$Rt8),
"$Vd32.b = vlut32($Vu32.b,$Vv32.b,$Rt8)",
CVI_VP_LONG, TypeCVI_VP>, Enc_11083408, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b1;
let Inst{31-24} = 0b00011011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vlutvvb_nm : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32, IntRegsLow8:$Rt8),
"$Vd32.b = vlut32($Vu32.b,$Vv32.b,$Rt8):nomatch",
CVI_VP_LONG, TypeCVI_VP>, Enc_11083408, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-24} = 0b00011000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vlutvvb_nm_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32, IntRegsLow8:$Rt8),
"$Vd32.b = vlut32($Vu32.b,$Vv32.b,$Rt8):nomatch",
CVI_VP_LONG, TypeCVI_VP>, Enc_11083408, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-24} = 0b00011000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vlutvvb_oracc : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VectorRegs:$Vu32, VectorRegs:$Vv32, IntRegsLow8:$Rt8),
"$Vx32.b |= vlut32($Vu32.b,$Vv32.b,$Rt8)",
CVI_VP_VS_LONG, TypeCVI_VP_VS>, Enc_8877260, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b1;
let Inst{31-24} = 0b00011011;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vlutvvb_oracc_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32, IntRegsLow8:$Rt8),
"$Vx32.b |= vlut32($Vu32.b,$Vv32.b,$Rt8)",
CVI_VP_VS_LONG, TypeCVI_VP_VS>, Enc_8877260, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b1;
let Inst{31-24} = 0b00011011;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vlutvvb_oracci : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VectorRegs:$Vu32, VectorRegs:$Vv32, u3_0Imm:$Ii),
"$Vx32.b |= vlut32($Vu32.b,$Vv32.b,#$Ii)",
CVI_VP_VS_LONG, TypeCVI_VP_VS>, Enc_8280533, Requires<[HasV62T,UseHVX]> {
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100110;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vlutvvb_oracci_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32, u3_0Imm:$Ii),
"$Vx32.b |= vlut32($Vu32.b,$Vv32.b,#$Ii)",
CVI_VP_VS_LONG, TypeCVI_VP_VS>, Enc_8280533, Requires<[HasV62T,UseHVX]> {
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100110;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vlutvvbi : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32, u3_0Imm:$Ii),
"$Vd32.b = vlut32($Vu32.b,$Vv32.b,#$Ii)",
CVI_VP_LONG, TypeCVI_VP>, Enc_7171569, Requires<[HasV62T,UseHVX]> {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011110001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vlutvvbi_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32, u3_0Imm:$Ii),
"$Vd32.b = vlut32($Vu32.b,$Vv32.b,#$Ii)",
CVI_VP_LONG, TypeCVI_VP>, Enc_7171569, Requires<[HasV62T,UseHVX]> {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011110001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vlutvwh : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32, IntRegsLow8:$Rt8),
"$Vdd32.h = vlut16($Vu32.b,$Vv32.h,$Rt8)",
CVI_VP_VS_LONG, TypeCVI_VP_VS>, Enc_14767681, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b1;
let Inst{31-24} = 0b00011011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vlutvwh_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32, IntRegsLow8:$Rt8),
"$Vdd32.h = vlut16($Vu32.b,$Vv32.h,$Rt8)",
CVI_VP_VS_LONG, TypeCVI_VP_VS>, Enc_14767681, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b1;
let Inst{31-24} = 0b00011011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vlutvwh_nm : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32, IntRegsLow8:$Rt8),
"$Vdd32.h = vlut16($Vu32.b,$Vv32.h,$Rt8):nomatch",
CVI_VP_VS_LONG, TypeCVI_VP_VS>, Enc_14767681, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-24} = 0b00011000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vlutvwh_nm_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32, IntRegsLow8:$Rt8),
"$Vdd32.h = vlut16($Vu32.b,$Vv32.h,$Rt8):nomatch",
CVI_VP_VS_LONG, TypeCVI_VP_VS>, Enc_14767681, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-24} = 0b00011000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vlutvwh_oracc : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VectorRegs:$Vu32, VectorRegs:$Vv32, IntRegsLow8:$Rt8),
"$Vxx32.h |= vlut16($Vu32.b,$Vv32.h,$Rt8)",
CVI_VP_VS_LONG, TypeCVI_VP_VS>, Enc_16213761, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b1;
let Inst{31-24} = 0b00011011;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vlutvwh_oracc_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32, IntRegsLow8:$Rt8),
"$Vxx32.h |= vlut16($Vu32.b,$Vv32.h,$Rt8)",
CVI_VP_VS_LONG, TypeCVI_VP_VS>, Enc_16213761, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b1;
let Inst{31-24} = 0b00011011;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vlutvwh_oracci : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VectorRegs:$Vu32, VectorRegs:$Vv32, u3_0Imm:$Ii),
"$Vxx32.h |= vlut16($Vu32.b,$Vv32.h,#$Ii)",
CVI_VP_VS_LONG, TypeCVI_VP_VS>, Enc_3457570, Requires<[HasV62T,UseHVX]> {
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100111;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vlutvwh_oracci_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32, u3_0Imm:$Ii),
"$Vxx32.h |= vlut16($Vu32.b,$Vv32.h,#$Ii)",
CVI_VP_VS_LONG, TypeCVI_VP_VS>, Enc_3457570, Requires<[HasV62T,UseHVX]> {
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100111;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vlutvwhi : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32, u3_0Imm:$Ii),
"$Vdd32.h = vlut16($Vu32.b,$Vv32.h,#$Ii)",
CVI_VP_VS_LONG, TypeCVI_VP_VS>, Enc_13261538, Requires<[HasV62T,UseHVX]> {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011110011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vlutvwhi_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32, u3_0Imm:$Ii),
"$Vdd32.h = vlut16($Vu32.b,$Vv32.h,#$Ii)",
CVI_VP_VS_LONG, TypeCVI_VP_VS>, Enc_13261538, Requires<[HasV62T,UseHVX]> {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011110011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmaxb : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.b = vmax($Vu32.b,$Vv32.b)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmaxb_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.b = vmax($Vu32.b,$Vv32.b)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmaxb_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vmaxb($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV62T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmaxb_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vmaxb($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV62T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmaxh : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.h = vmax($Vu32.h,$Vv32.h)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmaxh_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.h = vmax($Vu32.h,$Vv32.h)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmaxh_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vmaxh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmaxh_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vmaxh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmaxub : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.ub = vmax($Vu32.ub,$Vv32.ub)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmaxub_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.ub = vmax($Vu32.ub,$Vv32.ub)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmaxub_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vmaxub($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmaxub_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vmaxub($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmaxuh : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.uh = vmax($Vu32.uh,$Vv32.uh)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmaxuh_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.uh = vmax($Vu32.uh,$Vv32.uh)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmaxuh_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vmaxuh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmaxuh_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vmaxuh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmaxw : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.w = vmax($Vu32.w,$Vv32.w)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmaxw_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.w = vmax($Vu32.w,$Vv32.w)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmaxw_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vmaxw($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmaxw_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vmaxw($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vminb : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.b = vmin($Vu32.b,$Vv32.b)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vminb_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.b = vmin($Vu32.b,$Vv32.b)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vminb_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vminb($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV62T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vminb_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vminb($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV62T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vminh : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.h = vmin($Vu32.h,$Vv32.h)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vminh_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.h = vmin($Vu32.h,$Vv32.h)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vminh_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vminh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vminh_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vminh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vminub : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.ub = vmin($Vu32.ub,$Vv32.ub)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vminub_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.ub = vmin($Vu32.ub,$Vv32.ub)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vminub_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vminub($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vminub_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vminub($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vminuh : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.uh = vmin($Vu32.uh,$Vv32.uh)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vminuh_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.uh = vmin($Vu32.uh,$Vv32.uh)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vminuh_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vminuh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vminuh_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vminuh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vminw : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.w = vmin($Vu32.w,$Vv32.w)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vminw_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.w = vmin($Vu32.w,$Vv32.w)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vminw_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vminw($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vminw_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vminw($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpabus : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, IntRegs:$Rt32),
"$Vdd32.h = vmpa($Vuu32.ub,$Rt32.b)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_5023792, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpabus_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, IntRegs:$Rt32),
"$Vdd32.h = vmpa($Vuu32.ub,$Rt32.b)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_5023792, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpabus_acc : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VecDblRegs:$Vuu32, IntRegs:$Rt32),
"$Vxx32.h += vmpa($Vuu32.ub,$Rt32.b)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_4327792, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001001;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpabus_acc_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VecDblRegs128B:$Vuu32, IntRegs:$Rt32),
"$Vxx32.h += vmpa($Vuu32.ub,$Rt32.b)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_4327792, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001001;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpabus_acc_alt : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VecDblRegs:$Vuu32, IntRegs:$Rt32),
"$Vxx32 += vmpabus($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpabus_acc_alt_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VecDblRegs128B:$Vuu32, IntRegs:$Rt32),
"$Vxx32 += vmpabus($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpabus_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, IntRegs:$Rt32),
"$Vdd32 = vmpabus($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpabus_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, IntRegs:$Rt32),
"$Vdd32 = vmpabus($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpabusv : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, VecDblRegs:$Vvv32),
"$Vdd32.h = vmpa($Vuu32.ub,$Vvv32.b)",
CVI_VX_DV_LONG, TypeCVI_VX_DV>, Enc_13211717, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpabusv_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, VecDblRegs128B:$Vvv32),
"$Vdd32.h = vmpa($Vuu32.ub,$Vvv32.b)",
CVI_VX_DV_LONG, TypeCVI_VX_DV>, Enc_13211717, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpabusv_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, VecDblRegs:$Vvv32),
"$Vdd32 = vmpabus($Vuu32,$Vvv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpabusv_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, VecDblRegs128B:$Vvv32),
"$Vdd32 = vmpabus($Vuu32,$Vvv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpabuuv : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, VecDblRegs:$Vvv32),
"$Vdd32.h = vmpa($Vuu32.ub,$Vvv32.ub)",
CVI_VX_DV_LONG, TypeCVI_VX_DV>, Enc_13211717, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100111;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpabuuv_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, VecDblRegs128B:$Vvv32),
"$Vdd32.h = vmpa($Vuu32.ub,$Vvv32.ub)",
CVI_VX_DV_LONG, TypeCVI_VX_DV>, Enc_13211717, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100111;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpabuuv_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, VecDblRegs:$Vvv32),
"$Vdd32 = vmpabuu($Vuu32,$Vvv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpabuuv_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, VecDblRegs128B:$Vvv32),
"$Vdd32 = vmpabuu($Vuu32,$Vvv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpahb : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, IntRegs:$Rt32),
"$Vdd32.w = vmpa($Vuu32.h,$Rt32.b)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_5023792, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpahb_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, IntRegs:$Rt32),
"$Vdd32.w = vmpa($Vuu32.h,$Rt32.b)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_5023792, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpahb_acc : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VecDblRegs:$Vuu32, IntRegs:$Rt32),
"$Vxx32.w += vmpa($Vuu32.h,$Rt32.b)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_4327792, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001001;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpahb_acc_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VecDblRegs128B:$Vuu32, IntRegs:$Rt32),
"$Vxx32.w += vmpa($Vuu32.h,$Rt32.b)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_4327792, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001001;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpahb_acc_alt : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VecDblRegs:$Vuu32, IntRegs:$Rt32),
"$Vxx32 += vmpahb($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpahb_acc_alt_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VecDblRegs128B:$Vuu32, IntRegs:$Rt32),
"$Vxx32 += vmpahb($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpahb_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, IntRegs:$Rt32),
"$Vdd32 = vmpahb($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpahb_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, IntRegs:$Rt32),
"$Vdd32 = vmpahb($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpauhb : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, IntRegs:$Rt32),
"$Vdd32.w = vmpa($Vuu32.uh,$Rt32.b)",
CVI_VX_DV_LONG, TypeCVI_VX_DV>, Enc_5023792, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpauhb_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, IntRegs:$Rt32),
"$Vdd32.w = vmpa($Vuu32.uh,$Rt32.b)",
CVI_VX_DV_LONG, TypeCVI_VX_DV>, Enc_5023792, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpauhb_acc : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VecDblRegs:$Vuu32, IntRegs:$Rt32),
"$Vxx32.w += vmpa($Vuu32.uh,$Rt32.b)",
CVI_VX_DV_LONG, TypeCVI_VX_DV>, Enc_4327792, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001100;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpauhb_acc_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VecDblRegs128B:$Vuu32, IntRegs:$Rt32),
"$Vxx32.w += vmpa($Vuu32.uh,$Rt32.b)",
CVI_VX_DV_LONG, TypeCVI_VX_DV>, Enc_4327792, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001100;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpauhb_acc_alt : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VecDblRegs:$Vuu32, IntRegs:$Rt32),
"$Vxx32 += vmpauhb($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV62T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpauhb_acc_alt_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VecDblRegs128B:$Vuu32, IntRegs:$Rt32),
"$Vxx32 += vmpauhb($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV62T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpauhb_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, IntRegs:$Rt32),
"$Vdd32 = vmpauhb($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV62T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpauhb_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, IntRegs:$Rt32),
"$Vdd32 = vmpauhb($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV62T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpybus : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vdd32.h = vmpy($Vu32.ub,$Rt32.b)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_11471622, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpybus_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vdd32.h = vmpy($Vu32.ub,$Rt32.b)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_11471622, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpybus_acc : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vxx32.h += vmpy($Vu32.ub,$Rt32.b)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_2153798, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001001;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpybus_acc_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vxx32.h += vmpy($Vu32.ub,$Rt32.b)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_2153798, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001001;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpybus_acc_alt : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vxx32 += vmpybus($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpybus_acc_alt_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vxx32 += vmpybus($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpybus_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vdd32 = vmpybus($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpybus_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vdd32 = vmpybus($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpybusv : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vdd32.h = vmpy($Vu32.ub,$Vv32.b)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_15290236, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpybusv_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vdd32.h = vmpy($Vu32.ub,$Vv32.b)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_15290236, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpybusv_acc : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vxx32.h += vmpy($Vu32.ub,$Vv32.b)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_5972412, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpybusv_acc_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vxx32.h += vmpy($Vu32.ub,$Vv32.b)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_5972412, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpybusv_acc_alt : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vxx32 += vmpybus($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpybusv_acc_alt_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vxx32 += vmpybus($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpybusv_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vdd32 = vmpybus($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpybusv_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vdd32 = vmpybus($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpybv : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vdd32.h = vmpy($Vu32.b,$Vv32.b)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_15290236, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpybv_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vdd32.h = vmpy($Vu32.b,$Vv32.b)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_15290236, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpybv_acc : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vxx32.h += vmpy($Vu32.b,$Vv32.b)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_5972412, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpybv_acc_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vxx32.h += vmpy($Vu32.b,$Vv32.b)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_5972412, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpybv_acc_alt : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vxx32 += vmpyb($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpybv_acc_alt_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vxx32 += vmpyb($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpybv_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vdd32 = vmpyb($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpybv_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vdd32 = vmpyb($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpyewuh : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.w = vmpye($Vu32.w,$Vv32.uh)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111111;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyewuh_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.w = vmpye($Vu32.w,$Vv32.uh)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111111;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpyewuh_64 : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vdd32 = vmpye($Vu32.w,$Vv32.uh)",
CVI_VX_DV_LONG, TypeCVI_VX_DV>, Enc_15290236, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011110101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyewuh_64_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vdd32 = vmpye($Vu32.w,$Vv32.uh)",
CVI_VX_DV_LONG, TypeCVI_VX_DV>, Enc_15290236, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011110101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpyewuh_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vmpyewuh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyewuh_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vmpyewuh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpyh : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vdd32.w = vmpy($Vu32.h,$Rt32.h)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_11471622, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyh_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vdd32.w = vmpy($Vu32.h,$Rt32.h)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_11471622, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpyh_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vdd32 = vmpyh($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyh_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vdd32 = vmpyh($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpyhsat_acc : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vxx32.w += vmpy($Vu32.h,$Rt32.h):sat",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_2153798, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001010;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpyhsat_acc_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vxx32.w += vmpy($Vu32.h,$Rt32.h):sat",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_2153798, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001010;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpyhsat_acc_alt : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vxx32 += vmpyh($Vu32,$Rt32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpyhsat_acc_alt_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vxx32 += vmpyh($Vu32,$Rt32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpyhsrs : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vd32.h = vmpy($Vu32.h,$Rt32.h):<<1:rnd:sat",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_16214129, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyhsrs_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vd32.h = vmpy($Vu32.h,$Rt32.h):<<1:rnd:sat",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_16214129, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpyhsrs_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vd32 = vmpyh($Vu32,$Rt32):<<1:rnd:sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyhsrs_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vd32 = vmpyh($Vu32,$Rt32):<<1:rnd:sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpyhss : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vd32.h = vmpy($Vu32.h,$Rt32.h):<<1:sat",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_16214129, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyhss_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vd32.h = vmpy($Vu32.h,$Rt32.h):<<1:sat",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_16214129, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpyhss_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vd32 = vmpyh($Vu32,$Rt32):<<1:sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyhss_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vd32 = vmpyh($Vu32,$Rt32):<<1:sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpyhus : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vdd32.w = vmpy($Vu32.h,$Vv32.uh)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_15290236, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyhus_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vdd32.w = vmpy($Vu32.h,$Vv32.uh)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_15290236, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpyhus_acc : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vxx32.w += vmpy($Vu32.h,$Vv32.uh)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_5972412, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100001;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpyhus_acc_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vxx32.w += vmpy($Vu32.h,$Vv32.uh)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_5972412, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100001;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpyhus_acc_alt : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vxx32 += vmpyhus($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpyhus_acc_alt_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vxx32 += vmpyhus($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpyhus_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vdd32 = vmpyhus($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyhus_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vdd32 = vmpyhus($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpyhv : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vdd32.w = vmpy($Vu32.h,$Vv32.h)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_15290236, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyhv_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vdd32.w = vmpy($Vu32.h,$Vv32.h)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_15290236, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpyhv_acc : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vxx32.w += vmpy($Vu32.h,$Vv32.h)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_5972412, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpyhv_acc_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vxx32.w += vmpy($Vu32.h,$Vv32.h)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_5972412, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpyhv_acc_alt : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vxx32 += vmpyh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpyhv_acc_alt_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vxx32 += vmpyh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpyhv_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vdd32 = vmpyh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyhv_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vdd32 = vmpyh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpyhvsrs : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.h = vmpy($Vu32.h,$Vv32.h):<<1:rnd:sat",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyhvsrs_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.h = vmpy($Vu32.h,$Vv32.h):<<1:rnd:sat",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpyhvsrs_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vmpyh($Vu32,$Vv32):<<1:rnd:sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyhvsrs_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vmpyh($Vu32,$Vv32):<<1:rnd:sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpyieoh : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.w = vmpyieo($Vu32.h,$Vv32.h)",
CVI_VX, TypeCVI_VX>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyieoh_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.w = vmpyieo($Vu32.h,$Vv32.h)",
CVI_VX, TypeCVI_VX>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpyiewh_acc : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vx32.w += vmpyie($Vu32.w,$Vv32.h)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_2328527, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100010;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyiewh_acc_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vx32.w += vmpyie($Vu32.w,$Vv32.h)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_2328527, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100010;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyiewh_acc_alt : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vx32 += vmpyiewh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyiewh_acc_alt_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vx32 += vmpyiewh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyiewuh : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.w = vmpyie($Vu32.w,$Vv32.uh)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyiewuh_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.w = vmpyie($Vu32.w,$Vv32.uh)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpyiewuh_acc : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vx32.w += vmpyie($Vu32.w,$Vv32.uh)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_2328527, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100001;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyiewuh_acc_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vx32.w += vmpyie($Vu32.w,$Vv32.uh)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_2328527, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100001;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyiewuh_acc_alt : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vx32 += vmpyiewuh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyiewuh_acc_alt_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vx32 += vmpyiewuh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyiewuh_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vmpyiewuh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyiewuh_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vmpyiewuh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpyih : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.h = vmpyi($Vu32.h,$Vv32.h)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyih_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.h = vmpyi($Vu32.h,$Vv32.h)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpyih_acc : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vx32.h += vmpyi($Vu32.h,$Vv32.h)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_2328527, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100001;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyih_acc_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vx32.h += vmpyi($Vu32.h,$Vv32.h)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_2328527, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100001;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyih_acc_alt : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vx32 += vmpyih($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyih_acc_alt_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vx32 += vmpyih($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyih_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vmpyih($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyih_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vmpyih($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpyihb : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vd32.h = vmpyi($Vu32.h,$Rt32.b)",
CVI_VX_LONG, TypeCVI_VX>, Enc_16214129, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyihb_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vd32.h = vmpyi($Vu32.h,$Rt32.b)",
CVI_VX_LONG, TypeCVI_VX>, Enc_16214129, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpyihb_acc : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vx32.h += vmpyi($Vu32.h,$Rt32.b)",
CVI_VX, TypeCVI_VX>, Enc_10058269, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001011;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyihb_acc_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vx32.h += vmpyi($Vu32.h,$Rt32.b)",
CVI_VX, TypeCVI_VX>, Enc_10058269, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001011;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyihb_acc_alt : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vx32 += vmpyihb($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyihb_acc_alt_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vx32 += vmpyihb($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyihb_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vd32 = vmpyihb($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyihb_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vd32 = vmpyihb($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpyiowh : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.w = vmpyio($Vu32.w,$Vv32.h)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyiowh_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.w = vmpyio($Vu32.w,$Vv32.h)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpyiowh_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vmpyiowh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyiowh_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vmpyiowh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpyiwb : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vd32.w = vmpyi($Vu32.w,$Rt32.b)",
CVI_VX, TypeCVI_VX>, Enc_16214129, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyiwb_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vd32.w = vmpyi($Vu32.w,$Rt32.b)",
CVI_VX, TypeCVI_VX>, Enc_16214129, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpyiwb_acc : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vx32.w += vmpyi($Vu32.w,$Rt32.b)",
CVI_VX, TypeCVI_VX>, Enc_10058269, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001010;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyiwb_acc_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vx32.w += vmpyi($Vu32.w,$Rt32.b)",
CVI_VX, TypeCVI_VX>, Enc_10058269, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001010;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyiwb_acc_alt : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vx32 += vmpyiwb($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyiwb_acc_alt_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vx32 += vmpyiwb($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyiwb_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vd32 = vmpyiwb($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyiwb_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vd32 = vmpyiwb($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpyiwh : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vd32.w = vmpyi($Vu32.w,$Rt32.h)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_16214129, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyiwh_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vd32.w = vmpyi($Vu32.w,$Rt32.h)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_16214129, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpyiwh_acc : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vx32.w += vmpyi($Vu32.w,$Rt32.h)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_10058269, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001010;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyiwh_acc_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vx32.w += vmpyi($Vu32.w,$Rt32.h)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_10058269, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001010;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyiwh_acc_alt : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vx32 += vmpyiwh($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyiwh_acc_alt_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vx32 += vmpyiwh($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyiwh_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vd32 = vmpyiwh($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyiwh_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vd32 = vmpyiwh($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpyiwub : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vd32.w = vmpyi($Vu32.w,$Rt32.ub)",
CVI_VX_LONG, TypeCVI_VX>, Enc_16214129, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyiwub_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vd32.w = vmpyi($Vu32.w,$Rt32.ub)",
CVI_VX_LONG, TypeCVI_VX>, Enc_16214129, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpyiwub_acc : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vx32.w += vmpyi($Vu32.w,$Rt32.ub)",
CVI_VX_LONG, TypeCVI_VX>, Enc_10058269, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001100;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyiwub_acc_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vx32.w += vmpyi($Vu32.w,$Rt32.ub)",
CVI_VX_LONG, TypeCVI_VX>, Enc_10058269, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001100;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyiwub_acc_alt : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vx32 += vmpyiwub($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV62T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyiwub_acc_alt_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vx32 += vmpyiwub($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV62T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyiwub_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vd32 = vmpyiwub($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV62T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyiwub_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vd32 = vmpyiwub($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV62T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpyowh : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.w = vmpyo($Vu32.w,$Vv32.h):<<1:sat",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111111;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyowh_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.w = vmpyo($Vu32.w,$Vv32.h):<<1:sat",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111111;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpyowh_64_acc : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vxx32 += vmpyo($Vu32.w,$Vv32.h)",
CVI_VX_DV_LONG, TypeCVI_VX_DV>, Enc_5972412, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100001;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpyowh_64_acc_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vxx32 += vmpyo($Vu32.w,$Vv32.h)",
CVI_VX_DV_LONG, TypeCVI_VX_DV>, Enc_5972412, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100001;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpyowh_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vmpyowh($Vu32,$Vv32):<<1:sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyowh_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vmpyowh($Vu32,$Vv32):<<1:sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpyowh_rnd : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.w = vmpyo($Vu32.w,$Vv32.h):<<1:rnd:sat",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyowh_rnd_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.w = vmpyo($Vu32.w,$Vv32.h):<<1:rnd:sat",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpyowh_rnd_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vmpyowh($Vu32,$Vv32):<<1:rnd:sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyowh_rnd_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vmpyowh($Vu32,$Vv32):<<1:rnd:sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpyowh_rnd_sacc : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vx32.w += vmpyo($Vu32.w,$Vv32.h):<<1:rnd:sat:shift",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_2328527, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100001;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyowh_rnd_sacc_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vx32.w += vmpyo($Vu32.w,$Vv32.h):<<1:rnd:sat:shift",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_2328527, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100001;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyowh_rnd_sacc_alt : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vx32 += vmpyowh($Vu32,$Vv32):<<1:rnd:sat:shift",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyowh_rnd_sacc_alt_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vx32 += vmpyowh($Vu32,$Vv32):<<1:rnd:sat:shift",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyowh_sacc : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vx32.w += vmpyo($Vu32.w,$Vv32.h):<<1:sat:shift",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_2328527, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100001;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyowh_sacc_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vx32.w += vmpyo($Vu32.w,$Vv32.h):<<1:sat:shift",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_2328527, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100001;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyowh_sacc_alt : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vx32 += vmpyowh($Vu32,$Vv32):<<1:sat:shift",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyowh_sacc_alt_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vx32 += vmpyowh($Vu32,$Vv32):<<1:sat:shift",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyub : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vdd32.uh = vmpy($Vu32.ub,$Rt32.ub)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_11471622, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyub_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vdd32.uh = vmpy($Vu32.ub,$Rt32.ub)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_11471622, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpyub_acc : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vxx32.uh += vmpy($Vu32.ub,$Rt32.ub)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_2153798, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001100;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpyub_acc_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vxx32.uh += vmpy($Vu32.ub,$Rt32.ub)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_2153798, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001100;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpyub_acc_alt : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vxx32 += vmpyub($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpyub_acc_alt_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vxx32 += vmpyub($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpyub_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vdd32 = vmpyub($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyub_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vdd32 = vmpyub($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpyubv : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vdd32.uh = vmpy($Vu32.ub,$Vv32.ub)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_15290236, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyubv_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vdd32.uh = vmpy($Vu32.ub,$Vv32.ub)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_15290236, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpyubv_acc : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vxx32.uh += vmpy($Vu32.ub,$Vv32.ub)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_5972412, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpyubv_acc_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vxx32.uh += vmpy($Vu32.ub,$Vv32.ub)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_5972412, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpyubv_acc_alt : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vxx32 += vmpyub($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpyubv_acc_alt_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vxx32 += vmpyub($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpyubv_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vdd32 = vmpyub($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyubv_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vdd32 = vmpyub($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpyuh : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vdd32.uw = vmpy($Vu32.uh,$Rt32.uh)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_11471622, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyuh_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vdd32.uw = vmpy($Vu32.uh,$Rt32.uh)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_11471622, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpyuh_acc : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vxx32.uw += vmpy($Vu32.uh,$Rt32.uh)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_2153798, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001010;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpyuh_acc_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vxx32.uw += vmpy($Vu32.uh,$Rt32.uh)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_2153798, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001010;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpyuh_acc_alt : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vxx32 += vmpyuh($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpyuh_acc_alt_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vxx32 += vmpyuh($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpyuh_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vdd32 = vmpyuh($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyuh_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vdd32 = vmpyuh($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpyuhv : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vdd32.uw = vmpy($Vu32.uh,$Vv32.uh)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_15290236, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyuhv_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vdd32.uw = vmpy($Vu32.uh,$Vv32.uh)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_15290236, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmpyuhv_acc : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vxx32.uw += vmpy($Vu32.uh,$Vv32.uh)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_5972412, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100001;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpyuhv_acc_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vxx32.uw += vmpy($Vu32.uh,$Vv32.uh)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_5972412, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100001;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpyuhv_acc_alt : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vxx32 += vmpyuh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpyuhv_acc_alt_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vxx32 += vmpyuh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpyuhv_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vdd32 = vmpyuh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyuhv_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vdd32 = vmpyuh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vmux : HInst<
(outs VectorRegs:$Vd32),
(ins VecPredRegs:$Qt4, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vmux($Qt4,$Vu32,$Vv32)",
CVI_VA, TypeCVI_VA>, Enc_1572239, Requires<[HasV60T,UseHVX]> {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011110111;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmux_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VecPredRegs128B:$Qt4, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vmux($Qt4,$Vu32,$Vv32)",
CVI_VA, TypeCVI_VA>, Enc_1572239, Requires<[HasV60T,UseHVX]> {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011110111;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vnavgh : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.h = vnavg($Vu32.h,$Vv32.h)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100111;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vnavgh_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.h = vnavg($Vu32.h,$Vv32.h)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100111;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vnavgh_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vnavgh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vnavgh_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vnavgh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vnavgub : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.b = vnavg($Vu32.ub,$Vv32.ub)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100111;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vnavgub_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.b = vnavg($Vu32.ub,$Vv32.ub)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100111;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vnavgub_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vnavgub($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vnavgub_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vnavgub($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vnavgw : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.w = vnavg($Vu32.w,$Vv32.w)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100111;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vnavgw_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.w = vnavg($Vu32.w,$Vv32.w)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100111;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vnavgw_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vnavgw($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vnavgw_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vnavgw($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vnccombine : HInst<
(outs VecDblRegs:$Vdd32),
(ins PredRegs:$Ps4, VectorRegs:$Vu32, VectorRegs:$Vv32),
"if (!$Ps4) $Vdd32 = vcombine($Vu32,$Vv32)",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_16145290, Requires<[HasV60T,UseHVX]> {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011010010;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vnccombine_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins PredRegs:$Ps4, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"if (!$Ps4) $Vdd32 = vcombine($Vu32,$Vv32)",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_16145290, Requires<[HasV60T,UseHVX]> {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011010010;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vncmov : HInst<
(outs VectorRegs:$Vd32),
(ins PredRegs:$Ps4, VectorRegs:$Vu32),
"if (!$Ps4) $Vd32 = $Vu32",
CVI_VA, TypeCVI_VA>, Enc_12023037, Requires<[HasV60T,UseHVX]> {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001101000100000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vncmov_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins PredRegs:$Ps4, VectorRegs128B:$Vu32),
"if (!$Ps4) $Vd32 = $Vu32",
CVI_VA, TypeCVI_VA>, Enc_12023037, Requires<[HasV60T,UseHVX]> {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001101000100000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vnormamth : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32),
"$Vd32.h = vnormamt($Vu32.h)",
CVI_VS, TypeCVI_VS>, Enc_900013, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vnormamth_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32),
"$Vd32.h = vnormamt($Vu32.h)",
CVI_VS, TypeCVI_VS>, Enc_900013, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vnormamth_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32),
"$Vd32 = vnormamth($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vnormamth_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32),
"$Vd32 = vnormamth($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vnormamtw : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32),
"$Vd32.w = vnormamt($Vu32.w)",
CVI_VS, TypeCVI_VS>, Enc_900013, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vnormamtw_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32),
"$Vd32.w = vnormamt($Vu32.w)",
CVI_VS, TypeCVI_VS>, Enc_900013, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vnormamtw_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32),
"$Vd32 = vnormamtw($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vnormamtw_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32),
"$Vd32 = vnormamtw($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vnot : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32),
"$Vd32 = vnot($Vu32)",
CVI_VA, TypeCVI_VA>, Enc_900013, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vnot_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32),
"$Vd32 = vnot($Vu32)",
CVI_VA, TypeCVI_VA>, Enc_900013, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vor : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vor($Vu32,$Vv32)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vor_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vor($Vu32,$Vv32)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vpackeb : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.b = vpacke($Vu32.h,$Vv32.h)",
CVI_VP, TypeCVI_VP>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vpackeb_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.b = vpacke($Vu32.h,$Vv32.h)",
CVI_VP, TypeCVI_VP>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vpackeb_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vpackeb($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vpackeb_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vpackeb($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vpackeh : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.h = vpacke($Vu32.w,$Vv32.w)",
CVI_VP, TypeCVI_VP>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vpackeh_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.h = vpacke($Vu32.w,$Vv32.w)",
CVI_VP, TypeCVI_VP>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vpackeh_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vpackeh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vpackeh_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vpackeh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vpackhb_sat : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.b = vpack($Vu32.h,$Vv32.h):sat",
CVI_VP, TypeCVI_VP>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vpackhb_sat_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.b = vpack($Vu32.h,$Vv32.h):sat",
CVI_VP, TypeCVI_VP>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vpackhb_sat_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vpackhb($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vpackhb_sat_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vpackhb($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vpackhub_sat : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.ub = vpack($Vu32.h,$Vv32.h):sat",
CVI_VP, TypeCVI_VP>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vpackhub_sat_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.ub = vpack($Vu32.h,$Vv32.h):sat",
CVI_VP, TypeCVI_VP>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vpackhub_sat_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vpackhub($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vpackhub_sat_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vpackhub($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vpackob : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.b = vpacko($Vu32.h,$Vv32.h)",
CVI_VP, TypeCVI_VP>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111111;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vpackob_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.b = vpacko($Vu32.h,$Vv32.h)",
CVI_VP, TypeCVI_VP>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111111;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vpackob_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vpackob($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vpackob_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vpackob($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vpackoh : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.h = vpacko($Vu32.w,$Vv32.w)",
CVI_VP, TypeCVI_VP>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111111;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vpackoh_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.h = vpacko($Vu32.w,$Vv32.w)",
CVI_VP, TypeCVI_VP>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111111;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vpackoh_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vpackoh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vpackoh_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vpackoh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vpackwh_sat : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.h = vpack($Vu32.w,$Vv32.w):sat",
CVI_VP, TypeCVI_VP>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111111;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vpackwh_sat_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.h = vpack($Vu32.w,$Vv32.w):sat",
CVI_VP, TypeCVI_VP>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111111;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vpackwh_sat_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vpackwh($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vpackwh_sat_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vpackwh($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vpackwuh_sat : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.uh = vpack($Vu32.w,$Vv32.w):sat",
CVI_VP, TypeCVI_VP>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vpackwuh_sat_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.uh = vpack($Vu32.w,$Vv32.w):sat",
CVI_VP, TypeCVI_VP>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vpackwuh_sat_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vpackwuh($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vpackwuh_sat_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vpackwuh($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vpopcounth : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32),
"$Vd32.h = vpopcount($Vu32.h)",
CVI_VS, TypeCVI_VS>, Enc_900013, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vpopcounth_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32),
"$Vd32.h = vpopcount($Vu32.h)",
CVI_VS, TypeCVI_VS>, Enc_900013, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vpopcounth_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32),
"$Vd32 = vpopcounth($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vpopcounth_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32),
"$Vd32 = vpopcounth($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vrdelta : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vrdelta($Vu32,$Vv32)",
CVI_VP, TypeCVI_VP>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrdelta_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vrdelta($Vu32,$Vv32)",
CVI_VP, TypeCVI_VP>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vrmpybus : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vd32.w = vrmpy($Vu32.ub,$Rt32.b)",
CVI_VX, TypeCVI_VX>, Enc_16214129, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrmpybus_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vd32.w = vrmpy($Vu32.ub,$Rt32.b)",
CVI_VX, TypeCVI_VX>, Enc_16214129, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vrmpybus_acc : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vx32.w += vrmpy($Vu32.ub,$Rt32.b)",
CVI_VX, TypeCVI_VX>, Enc_10058269, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vrmpybus_acc_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vx32.w += vrmpy($Vu32.ub,$Rt32.b)",
CVI_VX, TypeCVI_VX>, Enc_10058269, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vrmpybus_acc_alt : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vx32 += vrmpybus($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vrmpybus_acc_alt_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vx32 += vrmpybus($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vrmpybus_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vd32 = vrmpybus($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrmpybus_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vd32 = vrmpybus($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vrmpybusi : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, IntRegs:$Rt32, u1_0Imm:$Ii),
"$Vdd32.w = vrmpy($Vuu32.ub,$Rt32.b,#$Ii)",
CVI_VX_DV_LONG, TypeCVI_VX_DV>, Enc_14172170, Requires<[HasV60T,UseHVX]> {
let Inst{7-6} = 0b10;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrmpybusi_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, IntRegs:$Rt32, u1_0Imm:$Ii),
"$Vdd32.w = vrmpy($Vuu32.ub,$Rt32.b,#$Ii)",
CVI_VX_DV_LONG, TypeCVI_VX_DV>, Enc_14172170, Requires<[HasV60T,UseHVX]> {
let Inst{7-6} = 0b10;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vrmpybusi_acc : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VecDblRegs:$Vuu32, IntRegs:$Rt32, u1_0Imm:$Ii),
"$Vxx32.w += vrmpy($Vuu32.ub,$Rt32.b,#$Ii)",
CVI_VX_DV_LONG, TypeCVI_VX_DV>, Enc_13189194, Requires<[HasV60T,UseHVX]> {
let Inst{7-6} = 0b10;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001010;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vrmpybusi_acc_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VecDblRegs128B:$Vuu32, IntRegs:$Rt32, u1_0Imm:$Ii),
"$Vxx32.w += vrmpy($Vuu32.ub,$Rt32.b,#$Ii)",
CVI_VX_DV_LONG, TypeCVI_VX_DV>, Enc_13189194, Requires<[HasV60T,UseHVX]> {
let Inst{7-6} = 0b10;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001010;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vrmpybusi_acc_alt : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VecDblRegs:$Vuu32, IntRegs:$Rt32, u1_0Imm:$Ii),
"$Vxx32 += vrmpybus($Vuu32,$Rt32,#$Ii)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vrmpybusi_acc_alt_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VecDblRegs128B:$Vuu32, IntRegs:$Rt32, u1_0Imm:$Ii),
"$Vxx32 += vrmpybus($Vuu32,$Rt32,#$Ii)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vrmpybusi_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, IntRegs:$Rt32, u1_0Imm:$Ii),
"$Vdd32 = vrmpybus($Vuu32,$Rt32,#$Ii)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrmpybusi_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, IntRegs:$Rt32, u1_0Imm:$Ii),
"$Vdd32 = vrmpybus($Vuu32,$Rt32,#$Ii)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vrmpybusv : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.w = vrmpy($Vu32.ub,$Vv32.b)",
CVI_VX, TypeCVI_VX>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrmpybusv_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.w = vrmpy($Vu32.ub,$Vv32.b)",
CVI_VX, TypeCVI_VX>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vrmpybusv_acc : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vx32.w += vrmpy($Vu32.ub,$Vv32.b)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_2328527, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vrmpybusv_acc_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vx32.w += vrmpy($Vu32.ub,$Vv32.b)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_2328527, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vrmpybusv_acc_alt : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vx32 += vrmpybus($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vrmpybusv_acc_alt_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vx32 += vrmpybus($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vrmpybusv_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vrmpybus($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrmpybusv_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vrmpybus($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vrmpybv : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.w = vrmpy($Vu32.b,$Vv32.b)",
CVI_VX, TypeCVI_VX>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrmpybv_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.w = vrmpy($Vu32.b,$Vv32.b)",
CVI_VX, TypeCVI_VX>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vrmpybv_acc : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vx32.w += vrmpy($Vu32.b,$Vv32.b)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_2328527, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vrmpybv_acc_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vx32.w += vrmpy($Vu32.b,$Vv32.b)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_2328527, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vrmpybv_acc_alt : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vx32 += vrmpyb($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vrmpybv_acc_alt_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vx32 += vrmpyb($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vrmpybv_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vrmpyb($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrmpybv_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vrmpyb($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vrmpyub : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vd32.uw = vrmpy($Vu32.ub,$Rt32.ub)",
CVI_VX, TypeCVI_VX>, Enc_16214129, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrmpyub_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vd32.uw = vrmpy($Vu32.ub,$Rt32.ub)",
CVI_VX, TypeCVI_VX>, Enc_16214129, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vrmpyub_acc : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vx32.uw += vrmpy($Vu32.ub,$Rt32.ub)",
CVI_VX, TypeCVI_VX>, Enc_10058269, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vrmpyub_acc_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vx32.uw += vrmpy($Vu32.ub,$Rt32.ub)",
CVI_VX, TypeCVI_VX>, Enc_10058269, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vrmpyub_acc_alt : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vx32 += vrmpyub($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vrmpyub_acc_alt_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vx32 += vrmpyub($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vrmpyub_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vd32 = vrmpyub($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrmpyub_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vd32 = vrmpyub($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vrmpyubi : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, IntRegs:$Rt32, u1_0Imm:$Ii),
"$Vdd32.uw = vrmpy($Vuu32.ub,$Rt32.ub,#$Ii)",
CVI_VX_DV_LONG, TypeCVI_VX_DV>, Enc_14172170, Requires<[HasV60T,UseHVX]> {
let Inst{7-6} = 0b11;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrmpyubi_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, IntRegs:$Rt32, u1_0Imm:$Ii),
"$Vdd32.uw = vrmpy($Vuu32.ub,$Rt32.ub,#$Ii)",
CVI_VX_DV_LONG, TypeCVI_VX_DV>, Enc_14172170, Requires<[HasV60T,UseHVX]> {
let Inst{7-6} = 0b11;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vrmpyubi_acc : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VecDblRegs:$Vuu32, IntRegs:$Rt32, u1_0Imm:$Ii),
"$Vxx32.uw += vrmpy($Vuu32.ub,$Rt32.ub,#$Ii)",
CVI_VX_DV_LONG, TypeCVI_VX_DV>, Enc_13189194, Requires<[HasV60T,UseHVX]> {
let Inst{7-6} = 0b11;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001011;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vrmpyubi_acc_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VecDblRegs128B:$Vuu32, IntRegs:$Rt32, u1_0Imm:$Ii),
"$Vxx32.uw += vrmpy($Vuu32.ub,$Rt32.ub,#$Ii)",
CVI_VX_DV_LONG, TypeCVI_VX_DV>, Enc_13189194, Requires<[HasV60T,UseHVX]> {
let Inst{7-6} = 0b11;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001011;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vrmpyubi_acc_alt : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VecDblRegs:$Vuu32, IntRegs:$Rt32, u1_0Imm:$Ii),
"$Vxx32 += vrmpyub($Vuu32,$Rt32,#$Ii)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vrmpyubi_acc_alt_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VecDblRegs128B:$Vuu32, IntRegs:$Rt32, u1_0Imm:$Ii),
"$Vxx32 += vrmpyub($Vuu32,$Rt32,#$Ii)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vrmpyubi_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, IntRegs:$Rt32, u1_0Imm:$Ii),
"$Vdd32 = vrmpyub($Vuu32,$Rt32,#$Ii)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrmpyubi_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, IntRegs:$Rt32, u1_0Imm:$Ii),
"$Vdd32 = vrmpyub($Vuu32,$Rt32,#$Ii)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vrmpyubv : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.uw = vrmpy($Vu32.ub,$Vv32.ub)",
CVI_VX, TypeCVI_VX>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrmpyubv_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.uw = vrmpy($Vu32.ub,$Vv32.ub)",
CVI_VX, TypeCVI_VX>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vrmpyubv_acc : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vx32.uw += vrmpy($Vu32.ub,$Vv32.ub)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_2328527, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vrmpyubv_acc_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vx32.uw += vrmpy($Vu32.ub,$Vv32.ub)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_2328527, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vrmpyubv_acc_alt : HInst<
(outs VectorRegs:$Vx32),
(ins VectorRegs:$Vx32in, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vx32 += vrmpyub($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vrmpyubv_acc_alt_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vx32 += vrmpyub($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vrmpyubv_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vrmpyub($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrmpyubv_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vrmpyub($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vror : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, IntRegs:$Rt32),
"$Vd32 = vror($Vu32,$Rt32)",
CVI_VP, TypeCVI_VP>, Enc_16214129, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vror_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, IntRegs:$Rt32),
"$Vd32 = vror($Vu32,$Rt32)",
CVI_VP, TypeCVI_VP>, Enc_16214129, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vroundhb : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.b = vround($Vu32.h,$Vv32.h):sat",
CVI_VS, TypeCVI_VS>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vroundhb_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.b = vround($Vu32.h,$Vv32.h):sat",
CVI_VS, TypeCVI_VS>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vroundhb_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vroundhb($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vroundhb_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vroundhb($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vroundhub : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.ub = vround($Vu32.h,$Vv32.h):sat",
CVI_VS, TypeCVI_VS>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vroundhub_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.ub = vround($Vu32.h,$Vv32.h):sat",
CVI_VS, TypeCVI_VS>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vroundhub_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vroundhub($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vroundhub_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vroundhub($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vrounduhub : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.ub = vround($Vu32.uh,$Vv32.uh):sat",
CVI_VS, TypeCVI_VS>, Enc_6223403, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111111;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrounduhub_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.ub = vround($Vu32.uh,$Vv32.uh):sat",
CVI_VS, TypeCVI_VS>, Enc_6223403, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111111;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vrounduhub_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vrounduhub($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV62T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrounduhub_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vrounduhub($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV62T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vrounduwuh : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.uh = vround($Vu32.uw,$Vv32.uw):sat",
CVI_VS, TypeCVI_VS>, Enc_6223403, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111111;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrounduwuh_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.uh = vround($Vu32.uw,$Vv32.uw):sat",
CVI_VS, TypeCVI_VS>, Enc_6223403, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111111;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vrounduwuh_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vrounduwuh($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV62T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrounduwuh_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vrounduwuh($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV62T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vroundwh : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.h = vround($Vu32.w,$Vv32.w):sat",
CVI_VS, TypeCVI_VS>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vroundwh_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.h = vround($Vu32.w,$Vv32.w):sat",
CVI_VS, TypeCVI_VS>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vroundwh_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vroundwh($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vroundwh_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vroundwh($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vroundwuh : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.uh = vround($Vu32.w,$Vv32.w):sat",
CVI_VS, TypeCVI_VS>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vroundwuh_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.uh = vround($Vu32.w,$Vv32.w):sat",
CVI_VS, TypeCVI_VS>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vroundwuh_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vroundwuh($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vroundwuh_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vroundwuh($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vrsadubi : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, IntRegs:$Rt32, u1_0Imm:$Ii),
"$Vdd32.uw = vrsad($Vuu32.ub,$Rt32.ub,#$Ii)",
CVI_VX_DV_LONG, TypeCVI_VX_DV>, Enc_14172170, Requires<[HasV60T,UseHVX]> {
let Inst{7-6} = 0b11;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrsadubi_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, IntRegs:$Rt32, u1_0Imm:$Ii),
"$Vdd32.uw = vrsad($Vuu32.ub,$Rt32.ub,#$Ii)",
CVI_VX_DV_LONG, TypeCVI_VX_DV>, Enc_14172170, Requires<[HasV60T,UseHVX]> {
let Inst{7-6} = 0b11;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vrsadubi_acc : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VecDblRegs:$Vuu32, IntRegs:$Rt32, u1_0Imm:$Ii),
"$Vxx32.uw += vrsad($Vuu32.ub,$Rt32.ub,#$Ii)",
CVI_VX_DV_LONG, TypeCVI_VX_DV>, Enc_13189194, Requires<[HasV60T,UseHVX]> {
let Inst{7-6} = 0b11;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001010;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vrsadubi_acc_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VecDblRegs128B:$Vuu32, IntRegs:$Rt32, u1_0Imm:$Ii),
"$Vxx32.uw += vrsad($Vuu32.ub,$Rt32.ub,#$Ii)",
CVI_VX_DV_LONG, TypeCVI_VX_DV>, Enc_13189194, Requires<[HasV60T,UseHVX]> {
let Inst{7-6} = 0b11;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001010;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vrsadubi_acc_alt : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VecDblRegs:$Vuu32, IntRegs:$Rt32, u1_0Imm:$Ii),
"$Vxx32 += vrsadub($Vuu32,$Rt32,#$Ii)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vrsadubi_acc_alt_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VecDblRegs128B:$Vuu32, IntRegs:$Rt32, u1_0Imm:$Ii),
"$Vxx32 += vrsadub($Vuu32,$Rt32,#$Ii)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vrsadubi_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, IntRegs:$Rt32, u1_0Imm:$Ii),
"$Vdd32 = vrsadub($Vuu32,$Rt32,#$Ii)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrsadubi_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, IntRegs:$Rt32, u1_0Imm:$Ii),
"$Vdd32 = vrsadub($Vuu32,$Rt32,#$Ii)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsathub : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.ub = vsat($Vu32.h,$Vv32.h)",
CVI_VINLANESAT, TypeCVI_VINLANESAT>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsathub_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.ub = vsat($Vu32.h,$Vv32.h)",
CVI_VINLANESAT, TypeCVI_VINLANESAT>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsathub_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vsathub($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsathub_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vsathub($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsatuwuh : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.uh = vsat($Vu32.uw,$Vv32.uw)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsatuwuh_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.uh = vsat($Vu32.uw,$Vv32.uw)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsatuwuh_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vsatuwuh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV62T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsatuwuh_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vsatuwuh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV62T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsatwh : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.h = vsat($Vu32.w,$Vv32.w)",
CVI_VINLANESAT, TypeCVI_VINLANESAT>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsatwh_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.h = vsat($Vu32.w,$Vv32.w)",
CVI_VINLANESAT, TypeCVI_VINLANESAT>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsatwh_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vsatwh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsatwh_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vsatwh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsb : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32),
"$Vdd32.h = vsxt($Vu32.b)",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_14631806, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsb_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32),
"$Vdd32.h = vsxt($Vu32.b)",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_14631806, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsb_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32),
"$Vdd32 = vsxtb($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsb_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32),
"$Vdd32 = vsxtb($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsh : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32),
"$Vdd32.w = vsxt($Vu32.h)",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_14631806, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsh_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32),
"$Vdd32.w = vsxt($Vu32.h)",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_14631806, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsh_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32),
"$Vdd32 = vsxth($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsh_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32),
"$Vdd32 = vsxth($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vshufeh : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.h = vshuffe($Vu32.h,$Vv32.h)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vshufeh_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.h = vshuffe($Vu32.h,$Vv32.h)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vshufeh_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vshuffeh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vshufeh_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vshuffeh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vshuff : HInst<
(outs VectorRegs:$Vy32, VectorRegs:$Vx32),
(ins VectorRegs:$Vy32in, VectorRegs:$Vx32in, IntRegs:$Rt32),
"vshuff($Vy32,$Vx32,$Rt32)",
CVI_VP_VS_LONG_EARLY, TypeCVI_VP_VS>, Enc_11422009, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001111;
let hasNewValue = 1;
let opNewValue = 0;
let hasNewValue2 = 1;
let opNewValue2 = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vy32 = $Vy32in, $Vx32 = $Vx32in";
}
def V6_vshuff_128B : HInst<
(outs VectorRegs128B:$Vy32, VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vy32in, VectorRegs128B:$Vx32in, IntRegs:$Rt32),
"vshuff($Vy32,$Vx32,$Rt32)",
CVI_VP_VS_LONG_EARLY, TypeCVI_VP_VS>, Enc_11422009, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001111;
let hasNewValue = 1;
let opNewValue = 0;
let hasNewValue2 = 1;
let opNewValue2 = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vy32 = $Vy32in, $Vx32 = $Vx32in";
}
def V6_vshuffb : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32),
"$Vd32.b = vshuff($Vu32.b)",
CVI_VP, TypeCVI_VP>, Enc_900013, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vshuffb_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32),
"$Vd32.b = vshuff($Vu32.b)",
CVI_VP, TypeCVI_VP>, Enc_900013, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vshuffb_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32),
"$Vd32 = vshuffb($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vshuffb_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32),
"$Vd32 = vshuffb($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vshuffeb : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.b = vshuffe($Vu32.b,$Vv32.b)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vshuffeb_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.b = vshuffe($Vu32.b,$Vv32.b)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vshuffeb_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vshuffeb($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vshuffeb_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vshuffeb($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vshuffh : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32),
"$Vd32.h = vshuff($Vu32.h)",
CVI_VP, TypeCVI_VP>, Enc_900013, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vshuffh_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32),
"$Vd32.h = vshuff($Vu32.h)",
CVI_VP, TypeCVI_VP>, Enc_900013, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vshuffh_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32),
"$Vd32 = vshuffh($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vshuffh_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32),
"$Vd32 = vshuffh($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vshuffob : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.b = vshuffo($Vu32.b,$Vv32.b)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vshuffob_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.b = vshuffo($Vu32.b,$Vv32.b)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vshuffob_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vshuffob($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vshuffob_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vshuffob($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vshuffvdd : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32, IntRegsLow8:$Rt8),
"$Vdd32 = vshuff($Vu32,$Vv32,$Rt8)",
CVI_VP_VS_LONG, TypeCVI_VP_VS>, Enc_14767681, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b1;
let Inst{31-24} = 0b00011011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vshuffvdd_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32, IntRegsLow8:$Rt8),
"$Vdd32 = vshuff($Vu32,$Vv32,$Rt8)",
CVI_VP_VS_LONG, TypeCVI_VP_VS>, Enc_14767681, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b1;
let Inst{31-24} = 0b00011011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vshufoeb : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vdd32.b = vshuffoe($Vu32.b,$Vv32.b)",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_15290236, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vshufoeb_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vdd32.b = vshuffoe($Vu32.b,$Vv32.b)",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_15290236, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vshufoeb_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vdd32 = vshuffoeb($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vshufoeb_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vdd32 = vshuffoeb($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vshufoeh : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vdd32.h = vshuffoe($Vu32.h,$Vv32.h)",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_15290236, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vshufoeh_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vdd32.h = vshuffoe($Vu32.h,$Vv32.h)",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_15290236, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vshufoeh_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vdd32 = vshuffoeh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vshufoeh_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vdd32 = vshuffoeh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vshufoh : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.h = vshuffo($Vu32.h,$Vv32.h)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vshufoh_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.h = vshuffo($Vu32.h,$Vv32.h)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vshufoh_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vshuffoh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vshufoh_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vshuffoh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsubb : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.b = vsub($Vu32.b,$Vv32.b)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubb_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.b = vsub($Vu32.b,$Vv32.b)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsubb_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vsubb($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubb_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vsubb($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsubb_dv : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, VecDblRegs:$Vvv32),
"$Vdd32.b = vsub($Vuu32.b,$Vvv32.b)",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_13211717, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubb_dv_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, VecDblRegs128B:$Vvv32),
"$Vdd32.b = vsub($Vuu32.b,$Vvv32.b)",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_13211717, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsubb_dv_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, VecDblRegs:$Vvv32),
"$Vdd32 = vsubb($Vuu32,$Vvv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubb_dv_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, VecDblRegs128B:$Vvv32),
"$Vdd32 = vsubb($Vuu32,$Vvv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsubbnq : HInst<
(outs VectorRegs:$Vx32),
(ins VecPredRegs:$Qv4, VectorRegs:$Vx32in, VectorRegs:$Vu32),
"if (!$Qv4) $Vx32.b -= $Vu32.b",
CVI_VA, TypeCVI_VA>, Enc_12535811, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b1;
let Inst{21-16} = 0b000010;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vsubbnq_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VecPredRegs128B:$Qv4, VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32),
"if (!$Qv4) $Vx32.b -= $Vu32.b",
CVI_VA, TypeCVI_VA>, Enc_12535811, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b1;
let Inst{21-16} = 0b000010;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vsubbnq_alt : HInst<
(outs VectorRegs:$Vx32),
(ins VecPredRegs:$Qv4, VectorRegs:$Vx32in, VectorRegs:$Vu32),
"if (!$Qv4.b) $Vx32.b -= $Vu32.b",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vsubbnq_alt_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VecPredRegs128B:$Qv4, VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32),
"if (!$Qv4.b) $Vx32.b -= $Vu32.b",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vsubbq : HInst<
(outs VectorRegs:$Vx32),
(ins VecPredRegs:$Qv4, VectorRegs:$Vx32in, VectorRegs:$Vu32),
"if ($Qv4) $Vx32.b -= $Vu32.b",
CVI_VA, TypeCVI_VA>, Enc_12535811, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b1;
let Inst{21-16} = 0b000001;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vsubbq_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VecPredRegs128B:$Qv4, VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32),
"if ($Qv4) $Vx32.b -= $Vu32.b",
CVI_VA, TypeCVI_VA>, Enc_12535811, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b1;
let Inst{21-16} = 0b000001;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vsubbq_alt : HInst<
(outs VectorRegs:$Vx32),
(ins VecPredRegs:$Qv4, VectorRegs:$Vx32in, VectorRegs:$Vu32),
"if ($Qv4.b) $Vx32.b -= $Vu32.b",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vsubbq_alt_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VecPredRegs128B:$Qv4, VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32),
"if ($Qv4.b) $Vx32.b -= $Vu32.b",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vsubbsat : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.b = vsub($Vu32.b,$Vv32.b):sat",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubbsat_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.b = vsub($Vu32.b,$Vv32.b):sat",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsubbsat_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vsubb($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV62T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubbsat_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vsubb($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV62T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsubbsat_dv : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, VecDblRegs:$Vvv32),
"$Vdd32.b = vsub($Vuu32.b,$Vvv32.b):sat",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_13211717, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011110101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubbsat_dv_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, VecDblRegs128B:$Vvv32),
"$Vdd32.b = vsub($Vuu32.b,$Vvv32.b):sat",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_13211717, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011110101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsubbsat_dv_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, VecDblRegs:$Vvv32),
"$Vdd32 = vsubb($Vuu32,$Vvv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV62T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubbsat_dv_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, VecDblRegs128B:$Vvv32),
"$Vdd32 = vsubb($Vuu32,$Vvv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV62T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsubcarry : HInst<
(outs VectorRegs:$Vd32, VecPredRegs:$Qx4),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32, VecPredRegs:$Qx4in),
"$Vd32.w = vsub($Vu32.w,$Vv32.w,$Qx4):carry",
CVI_VA, TypeCVI_VA>, Enc_13691337, Requires<[HasV62T,UseHVX]> {
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100101;
let hasNewValue = 1;
let opNewValue = 0;
let hasNewValue2 = 1;
let opNewValue2 = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vsubcarry_128B : HInst<
(outs VectorRegs128B:$Vd32, VecPredRegs128B:$Qx4),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32, VecPredRegs128B:$Qx4in),
"$Vd32.w = vsub($Vu32.w,$Vv32.w,$Qx4):carry",
CVI_VA, TypeCVI_VA>, Enc_13691337, Requires<[HasV62T,UseHVX]> {
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100101;
let hasNewValue = 1;
let opNewValue = 0;
let hasNewValue2 = 1;
let opNewValue2 = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vsubh : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.h = vsub($Vu32.h,$Vv32.h)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubh_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.h = vsub($Vu32.h,$Vv32.h)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsubh_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vsubh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubh_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vsubh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsubh_dv : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, VecDblRegs:$Vvv32),
"$Vdd32.h = vsub($Vuu32.h,$Vvv32.h)",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_13211717, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubh_dv_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, VecDblRegs128B:$Vvv32),
"$Vdd32.h = vsub($Vuu32.h,$Vvv32.h)",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_13211717, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsubh_dv_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, VecDblRegs:$Vvv32),
"$Vdd32 = vsubh($Vuu32,$Vvv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubh_dv_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, VecDblRegs128B:$Vvv32),
"$Vdd32 = vsubh($Vuu32,$Vvv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsubhnq : HInst<
(outs VectorRegs:$Vx32),
(ins VecPredRegs:$Qv4, VectorRegs:$Vx32in, VectorRegs:$Vu32),
"if (!$Qv4) $Vx32.h -= $Vu32.h",
CVI_VA, TypeCVI_VA>, Enc_12535811, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b1;
let Inst{21-16} = 0b000010;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vsubhnq_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VecPredRegs128B:$Qv4, VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32),
"if (!$Qv4) $Vx32.h -= $Vu32.h",
CVI_VA, TypeCVI_VA>, Enc_12535811, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b1;
let Inst{21-16} = 0b000010;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vsubhnq_alt : HInst<
(outs VectorRegs:$Vx32),
(ins VecPredRegs:$Qv4, VectorRegs:$Vx32in, VectorRegs:$Vu32),
"if (!$Qv4.h) $Vx32.h -= $Vu32.h",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vsubhnq_alt_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VecPredRegs128B:$Qv4, VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32),
"if (!$Qv4.h) $Vx32.h -= $Vu32.h",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vsubhq : HInst<
(outs VectorRegs:$Vx32),
(ins VecPredRegs:$Qv4, VectorRegs:$Vx32in, VectorRegs:$Vu32),
"if ($Qv4) $Vx32.h -= $Vu32.h",
CVI_VA, TypeCVI_VA>, Enc_12535811, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b1;
let Inst{21-16} = 0b000001;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vsubhq_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VecPredRegs128B:$Qv4, VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32),
"if ($Qv4) $Vx32.h -= $Vu32.h",
CVI_VA, TypeCVI_VA>, Enc_12535811, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b1;
let Inst{21-16} = 0b000001;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vsubhq_alt : HInst<
(outs VectorRegs:$Vx32),
(ins VecPredRegs:$Qv4, VectorRegs:$Vx32in, VectorRegs:$Vu32),
"if ($Qv4.h) $Vx32.h -= $Vu32.h",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vsubhq_alt_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VecPredRegs128B:$Qv4, VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32),
"if ($Qv4.h) $Vx32.h -= $Vu32.h",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vsubhsat : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.h = vsub($Vu32.h,$Vv32.h):sat",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubhsat_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.h = vsub($Vu32.h,$Vv32.h):sat",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsubhsat_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vsubh($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubhsat_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vsubh($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsubhsat_dv : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, VecDblRegs:$Vvv32),
"$Vdd32.h = vsub($Vuu32.h,$Vvv32.h):sat",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_13211717, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubhsat_dv_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, VecDblRegs128B:$Vvv32),
"$Vdd32.h = vsub($Vuu32.h,$Vvv32.h):sat",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_13211717, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsubhsat_dv_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, VecDblRegs:$Vvv32),
"$Vdd32 = vsubh($Vuu32,$Vvv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubhsat_dv_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, VecDblRegs128B:$Vvv32),
"$Vdd32 = vsubh($Vuu32,$Vvv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsubhw : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vdd32.w = vsub($Vu32.h,$Vv32.h)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_15290236, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubhw_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vdd32.w = vsub($Vu32.h,$Vv32.h)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_15290236, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsubhw_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vdd32 = vsubh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubhw_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vdd32 = vsubh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsububh : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vdd32.h = vsub($Vu32.ub,$Vv32.ub)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_15290236, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsububh_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vdd32.h = vsub($Vu32.ub,$Vv32.ub)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_15290236, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsububh_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vdd32 = vsubub($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsububh_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vdd32 = vsubub($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsububsat : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.ub = vsub($Vu32.ub,$Vv32.ub):sat",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsububsat_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.ub = vsub($Vu32.ub,$Vv32.ub):sat",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsububsat_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vsubub($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsububsat_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vsubub($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsububsat_dv : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, VecDblRegs:$Vvv32),
"$Vdd32.ub = vsub($Vuu32.ub,$Vvv32.ub):sat",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_13211717, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsububsat_dv_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, VecDblRegs128B:$Vvv32),
"$Vdd32.ub = vsub($Vuu32.ub,$Vvv32.ub):sat",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_13211717, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsububsat_dv_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, VecDblRegs:$Vvv32),
"$Vdd32 = vsubub($Vuu32,$Vvv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsububsat_dv_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, VecDblRegs128B:$Vvv32),
"$Vdd32 = vsubub($Vuu32,$Vvv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsubububb_sat : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.ub = vsub($Vu32.ub,$Vv32.b):sat",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011110101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubububb_sat_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.ub = vsub($Vu32.ub,$Vv32.b):sat",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011110101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsubuhsat : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.uh = vsub($Vu32.uh,$Vv32.uh):sat",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubuhsat_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.uh = vsub($Vu32.uh,$Vv32.uh):sat",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsubuhsat_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vsubuh($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubuhsat_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vsubuh($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsubuhsat_dv : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, VecDblRegs:$Vvv32),
"$Vdd32.uh = vsub($Vuu32.uh,$Vvv32.uh):sat",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_13211717, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubuhsat_dv_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, VecDblRegs128B:$Vvv32),
"$Vdd32.uh = vsub($Vuu32.uh,$Vvv32.uh):sat",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_13211717, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsubuhsat_dv_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, VecDblRegs:$Vvv32),
"$Vdd32 = vsubuh($Vuu32,$Vvv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubuhsat_dv_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, VecDblRegs128B:$Vvv32),
"$Vdd32 = vsubuh($Vuu32,$Vvv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsubuhw : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vdd32.w = vsub($Vu32.uh,$Vv32.uh)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_15290236, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubuhw_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vdd32.w = vsub($Vu32.uh,$Vv32.uh)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_15290236, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsubuhw_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vdd32 = vsubuh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubuhw_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vdd32 = vsubuh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsubuwsat : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.uw = vsub($Vu32.uw,$Vv32.uw):sat",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubuwsat_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.uw = vsub($Vu32.uw,$Vv32.uw):sat",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsubuwsat_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vsubuw($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV62T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubuwsat_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vsubuw($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV62T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsubuwsat_dv : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, VecDblRegs:$Vvv32),
"$Vdd32.uw = vsub($Vuu32.uw,$Vvv32.uw):sat",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_13211717, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011110101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubuwsat_dv_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, VecDblRegs128B:$Vvv32),
"$Vdd32.uw = vsub($Vuu32.uw,$Vvv32.uw):sat",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_13211717, Requires<[HasV62T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011110101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsubuwsat_dv_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, VecDblRegs:$Vvv32),
"$Vdd32 = vsubuw($Vuu32,$Vvv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV62T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubuwsat_dv_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, VecDblRegs128B:$Vvv32),
"$Vdd32 = vsubuw($Vuu32,$Vvv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV62T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsubw : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.w = vsub($Vu32.w,$Vv32.w)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubw_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.w = vsub($Vu32.w,$Vv32.w)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsubw_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vsubw($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubw_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vsubw($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsubw_dv : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, VecDblRegs:$Vvv32),
"$Vdd32.w = vsub($Vuu32.w,$Vvv32.w)",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_13211717, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubw_dv_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, VecDblRegs128B:$Vvv32),
"$Vdd32.w = vsub($Vuu32.w,$Vvv32.w)",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_13211717, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsubw_dv_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, VecDblRegs:$Vvv32),
"$Vdd32 = vsubw($Vuu32,$Vvv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubw_dv_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, VecDblRegs128B:$Vvv32),
"$Vdd32 = vsubw($Vuu32,$Vvv32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsubwnq : HInst<
(outs VectorRegs:$Vx32),
(ins VecPredRegs:$Qv4, VectorRegs:$Vx32in, VectorRegs:$Vu32),
"if (!$Qv4) $Vx32.w -= $Vu32.w",
CVI_VA, TypeCVI_VA>, Enc_12535811, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b1;
let Inst{21-16} = 0b000010;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vsubwnq_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VecPredRegs128B:$Qv4, VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32),
"if (!$Qv4) $Vx32.w -= $Vu32.w",
CVI_VA, TypeCVI_VA>, Enc_12535811, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b1;
let Inst{21-16} = 0b000010;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vsubwnq_alt : HInst<
(outs VectorRegs:$Vx32),
(ins VecPredRegs:$Qv4, VectorRegs:$Vx32in, VectorRegs:$Vu32),
"if (!$Qv4.w) $Vx32.w -= $Vu32.w",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vsubwnq_alt_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VecPredRegs128B:$Qv4, VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32),
"if (!$Qv4.w) $Vx32.w -= $Vu32.w",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vsubwq : HInst<
(outs VectorRegs:$Vx32),
(ins VecPredRegs:$Qv4, VectorRegs:$Vx32in, VectorRegs:$Vu32),
"if ($Qv4) $Vx32.w -= $Vu32.w",
CVI_VA, TypeCVI_VA>, Enc_12535811, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b1;
let Inst{21-16} = 0b000010;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vsubwq_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VecPredRegs128B:$Qv4, VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32),
"if ($Qv4) $Vx32.w -= $Vu32.w",
CVI_VA, TypeCVI_VA>, Enc_12535811, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b1;
let Inst{21-16} = 0b000010;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vsubwq_alt : HInst<
(outs VectorRegs:$Vx32),
(ins VecPredRegs:$Qv4, VectorRegs:$Vx32in, VectorRegs:$Vu32),
"if ($Qv4.w) $Vx32.w -= $Vu32.w",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vsubwq_alt_128B : HInst<
(outs VectorRegs128B:$Vx32),
(ins VecPredRegs128B:$Qv4, VectorRegs128B:$Vx32in, VectorRegs128B:$Vu32),
"if ($Qv4.w) $Vx32.w -= $Vu32.w",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vsubwsat : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32.w = vsub($Vu32.w,$Vv32.w):sat",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubwsat_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32.w = vsub($Vu32.w,$Vv32.w):sat",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsubwsat_alt : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vsubw($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubwsat_alt_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vsubw($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsubwsat_dv : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, VecDblRegs:$Vvv32),
"$Vdd32.w = vsub($Vuu32.w,$Vvv32.w):sat",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_13211717, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubwsat_dv_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, VecDblRegs128B:$Vvv32),
"$Vdd32.w = vsub($Vuu32.w,$Vvv32.w):sat",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_13211717, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vsubwsat_dv_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, VecDblRegs:$Vvv32),
"$Vdd32 = vsubw($Vuu32,$Vvv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubwsat_dv_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, VecDblRegs128B:$Vvv32),
"$Vdd32 = vsubw($Vuu32,$Vvv32):sat",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vswap : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecPredRegs:$Qt4, VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vdd32 = vswap($Qt4,$Vu32,$Vv32)",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_11424254, Requires<[HasV60T,UseHVX]> {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011110101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vswap_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecPredRegs128B:$Qt4, VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vdd32 = vswap($Qt4,$Vu32,$Vv32)",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_11424254, Requires<[HasV60T,UseHVX]> {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011110101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vtmpyb : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, IntRegs:$Rt32),
"$Vdd32.h = vtmpy($Vuu32.b,$Rt32.b)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_5023792, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vtmpyb_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, IntRegs:$Rt32),
"$Vdd32.h = vtmpy($Vuu32.b,$Rt32.b)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_5023792, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vtmpyb_acc : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VecDblRegs:$Vuu32, IntRegs:$Rt32),
"$Vxx32.h += vtmpy($Vuu32.b,$Rt32.b)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_4327792, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vtmpyb_acc_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VecDblRegs128B:$Vuu32, IntRegs:$Rt32),
"$Vxx32.h += vtmpy($Vuu32.b,$Rt32.b)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_4327792, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vtmpyb_acc_alt : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VecDblRegs:$Vuu32, IntRegs:$Rt32),
"$Vxx32 += vtmpyb($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vtmpyb_acc_alt_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VecDblRegs128B:$Vuu32, IntRegs:$Rt32),
"$Vxx32 += vtmpyb($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vtmpyb_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, IntRegs:$Rt32),
"$Vdd32 = vtmpyb($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vtmpyb_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, IntRegs:$Rt32),
"$Vdd32 = vtmpyb($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vtmpybus : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, IntRegs:$Rt32),
"$Vdd32.h = vtmpy($Vuu32.ub,$Rt32.b)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_5023792, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vtmpybus_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, IntRegs:$Rt32),
"$Vdd32.h = vtmpy($Vuu32.ub,$Rt32.b)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_5023792, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vtmpybus_acc : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VecDblRegs:$Vuu32, IntRegs:$Rt32),
"$Vxx32.h += vtmpy($Vuu32.ub,$Rt32.b)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_4327792, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vtmpybus_acc_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VecDblRegs128B:$Vuu32, IntRegs:$Rt32),
"$Vxx32.h += vtmpy($Vuu32.ub,$Rt32.b)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_4327792, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vtmpybus_acc_alt : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VecDblRegs:$Vuu32, IntRegs:$Rt32),
"$Vxx32 += vtmpybus($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vtmpybus_acc_alt_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VecDblRegs128B:$Vuu32, IntRegs:$Rt32),
"$Vxx32 += vtmpybus($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vtmpybus_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, IntRegs:$Rt32),
"$Vdd32 = vtmpybus($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vtmpybus_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, IntRegs:$Rt32),
"$Vdd32 = vtmpybus($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vtmpyhb : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, IntRegs:$Rt32),
"$Vdd32.w = vtmpy($Vuu32.h,$Rt32.b)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_5023792, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vtmpyhb_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, IntRegs:$Rt32),
"$Vdd32.w = vtmpy($Vuu32.h,$Rt32.b)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_5023792, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vtmpyhb_acc : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VecDblRegs:$Vuu32, IntRegs:$Rt32),
"$Vxx32.w += vtmpy($Vuu32.h,$Rt32.b)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_4327792, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vtmpyhb_acc_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VecDblRegs128B:$Vuu32, IntRegs:$Rt32),
"$Vxx32.w += vtmpy($Vuu32.h,$Rt32.b)",
CVI_VX_DV, TypeCVI_VX_DV>, Enc_4327792, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vtmpyhb_acc_alt : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VecDblRegs:$Vuu32, IntRegs:$Rt32),
"$Vxx32 += vtmpyhb($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vtmpyhb_acc_alt_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VecDblRegs128B:$Vuu32, IntRegs:$Rt32),
"$Vxx32 += vtmpyhb($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vtmpyhb_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VecDblRegs:$Vuu32, IntRegs:$Rt32),
"$Vdd32 = vtmpyhb($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vtmpyhb_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VecDblRegs128B:$Vuu32, IntRegs:$Rt32),
"$Vdd32 = vtmpyhb($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vtran2x2_map : HInst<
(outs VectorRegs:$Vy32, VectorRegs:$Vx32),
(ins VectorRegs:$Vy32in, VectorRegs:$Vx32in, IntRegs:$Rt32),
"vtrans2x2($Vy32,$Vx32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let hasNewValue2 = 1;
let opNewValue2 = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vy32 = $Vy32in, $Vx32 = $Vx32in";
}
def V6_vtran2x2_map_128B : HInst<
(outs VectorRegs128B:$Vy32, VectorRegs128B:$Vx32),
(ins VectorRegs128B:$Vy32in, VectorRegs128B:$Vx32in, IntRegs:$Rt32),
"vtrans2x2($Vy32,$Vx32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let hasNewValue2 = 1;
let opNewValue2 = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vy32 = $Vy32in, $Vx32 = $Vx32in";
}
def V6_vunpackb : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32),
"$Vdd32.h = vunpack($Vu32.b)",
CVI_VP_VS, TypeCVI_VP_VS>, Enc_14631806, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vunpackb_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32),
"$Vdd32.h = vunpack($Vu32.b)",
CVI_VP_VS, TypeCVI_VP_VS>, Enc_14631806, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vunpackb_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32),
"$Vdd32 = vunpackb($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vunpackb_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32),
"$Vdd32 = vunpackb($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vunpackh : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32),
"$Vdd32.w = vunpack($Vu32.h)",
CVI_VP_VS, TypeCVI_VP_VS>, Enc_14631806, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vunpackh_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32),
"$Vdd32.w = vunpack($Vu32.h)",
CVI_VP_VS, TypeCVI_VP_VS>, Enc_14631806, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vunpackh_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32),
"$Vdd32 = vunpackh($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vunpackh_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32),
"$Vdd32 = vunpackh($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vunpackob : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VectorRegs:$Vu32),
"$Vxx32.h |= vunpacko($Vu32.b)",
CVI_VP_VS_LONG, TypeCVI_VP_VS>, Enc_12669374, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b1;
let Inst{31-16} = 0b0001111000000000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vunpackob_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VectorRegs128B:$Vu32),
"$Vxx32.h |= vunpacko($Vu32.b)",
CVI_VP_VS_LONG, TypeCVI_VP_VS>, Enc_12669374, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b1;
let Inst{31-16} = 0b0001111000000000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vunpackob_alt : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VectorRegs:$Vu32),
"$Vxx32 |= vunpackob($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vunpackob_alt_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VectorRegs128B:$Vu32),
"$Vxx32 |= vunpackob($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vunpackoh : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VectorRegs:$Vu32),
"$Vxx32.w |= vunpacko($Vu32.h)",
CVI_VP_VS_LONG, TypeCVI_VP_VS>, Enc_12669374, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b1;
let Inst{31-16} = 0b0001111000000000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vunpackoh_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VectorRegs128B:$Vu32),
"$Vxx32.w |= vunpacko($Vu32.h)",
CVI_VP_VS_LONG, TypeCVI_VP_VS>, Enc_12669374, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b1;
let Inst{31-16} = 0b0001111000000000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vunpackoh_alt : HInst<
(outs VecDblRegs:$Vxx32),
(ins VecDblRegs:$Vxx32in, VectorRegs:$Vu32),
"$Vxx32 |= vunpackoh($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vunpackoh_alt_128B : HInst<
(outs VecDblRegs128B:$Vxx32),
(ins VecDblRegs128B:$Vxx32in, VectorRegs128B:$Vu32),
"$Vxx32 |= vunpackoh($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vunpackub : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32),
"$Vdd32.uh = vunpack($Vu32.ub)",
CVI_VP_VS, TypeCVI_VP_VS>, Enc_14631806, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vunpackub_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32),
"$Vdd32.uh = vunpack($Vu32.ub)",
CVI_VP_VS, TypeCVI_VP_VS>, Enc_14631806, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vunpackub_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32),
"$Vdd32 = vunpackub($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vunpackub_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32),
"$Vdd32 = vunpackub($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vunpackuh : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32),
"$Vdd32.uw = vunpack($Vu32.uh)",
CVI_VP_VS, TypeCVI_VP_VS>, Enc_14631806, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vunpackuh_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32),
"$Vdd32.uw = vunpack($Vu32.uh)",
CVI_VP_VS, TypeCVI_VP_VS>, Enc_14631806, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vunpackuh_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32),
"$Vdd32 = vunpackuh($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vunpackuh_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32),
"$Vdd32 = vunpackuh($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vwhist128 : HInst<
(outs),
(ins),
"vwhist128",
CVI_HIST, TypeCVI_HIST>, Enc_0, Requires<[HasV62T,UseHVX]> {
let Inst{13-0} = 0b10010010000000;
let Inst{31-16} = 0b0001111000000000;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vwhist128_128B : HInst<
(outs),
(ins),
"vwhist128",
CVI_HIST, TypeCVI_HIST>, Enc_0, Requires<[HasV62T,UseHVX]> {
let Inst{13-0} = 0b10010010000000;
let Inst{31-16} = 0b0001111000000000;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vwhist128m : HInst<
(outs),
(ins u1_0Imm:$Ii),
"vwhist128(#$Ii)",
CVI_HIST, TypeCVI_HIST>, Enc_1291652, Requires<[HasV62T,UseHVX]> {
let Inst{7-0} = 0b10000000;
let Inst{13-9} = 0b10011;
let Inst{31-16} = 0b0001111000000000;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vwhist128m_128B : HInst<
(outs),
(ins u1_0Imm:$Ii),
"vwhist128(#$Ii)",
CVI_HIST, TypeCVI_HIST>, Enc_1291652, Requires<[HasV62T,UseHVX]> {
let Inst{7-0} = 0b10000000;
let Inst{13-9} = 0b10011;
let Inst{31-16} = 0b0001111000000000;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vwhist128q : HInst<
(outs),
(ins VecPredRegs:$Qv4),
"vwhist128($Qv4)",
CVI_HIST, TypeCVI_HIST>, Enc_4109168, Requires<[HasV62T,UseHVX]> {
let Inst{13-0} = 0b10010010000000;
let Inst{21-16} = 0b000010;
let Inst{31-24} = 0b00011110;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vwhist128q_128B : HInst<
(outs),
(ins VecPredRegs128B:$Qv4),
"vwhist128($Qv4)",
CVI_HIST, TypeCVI_HIST>, Enc_4109168, Requires<[HasV62T,UseHVX]> {
let Inst{13-0} = 0b10010010000000;
let Inst{21-16} = 0b000010;
let Inst{31-24} = 0b00011110;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vwhist128qm : HInst<
(outs),
(ins VecPredRegs:$Qv4, u1_0Imm:$Ii),
"vwhist128($Qv4,#$Ii)",
CVI_HIST, TypeCVI_HIST>, Enc_7978128, Requires<[HasV62T,UseHVX]> {
let Inst{7-0} = 0b10000000;
let Inst{13-9} = 0b10011;
let Inst{21-16} = 0b000010;
let Inst{31-24} = 0b00011110;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vwhist128qm_128B : HInst<
(outs),
(ins VecPredRegs128B:$Qv4, u1_0Imm:$Ii),
"vwhist128($Qv4,#$Ii)",
CVI_HIST, TypeCVI_HIST>, Enc_7978128, Requires<[HasV62T,UseHVX]> {
let Inst{7-0} = 0b10000000;
let Inst{13-9} = 0b10011;
let Inst{21-16} = 0b000010;
let Inst{31-24} = 0b00011110;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vwhist256 : HInst<
(outs),
(ins),
"vwhist256",
CVI_HIST, TypeCVI_HIST>, Enc_0, Requires<[HasV62T,UseHVX]> {
let Inst{13-0} = 0b10001010000000;
let Inst{31-16} = 0b0001111000000000;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vwhist256_128B : HInst<
(outs),
(ins),
"vwhist256",
CVI_HIST, TypeCVI_HIST>, Enc_0, Requires<[HasV62T,UseHVX]> {
let Inst{13-0} = 0b10001010000000;
let Inst{31-16} = 0b0001111000000000;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vwhist256_sat : HInst<
(outs),
(ins),
"vwhist256:sat",
CVI_HIST, TypeCVI_HIST>, Enc_0, Requires<[HasV62T,UseHVX]> {
let Inst{13-0} = 0b10001110000000;
let Inst{31-16} = 0b0001111000000000;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vwhist256_sat_128B : HInst<
(outs),
(ins),
"vwhist256:sat",
CVI_HIST, TypeCVI_HIST>, Enc_0, Requires<[HasV62T,UseHVX]> {
let Inst{13-0} = 0b10001110000000;
let Inst{31-16} = 0b0001111000000000;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vwhist256q : HInst<
(outs),
(ins VecPredRegs:$Qv4),
"vwhist256($Qv4)",
CVI_HIST, TypeCVI_HIST>, Enc_4109168, Requires<[HasV62T,UseHVX]> {
let Inst{13-0} = 0b10001010000000;
let Inst{21-16} = 0b000010;
let Inst{31-24} = 0b00011110;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vwhist256q_128B : HInst<
(outs),
(ins VecPredRegs128B:$Qv4),
"vwhist256($Qv4)",
CVI_HIST, TypeCVI_HIST>, Enc_4109168, Requires<[HasV62T,UseHVX]> {
let Inst{13-0} = 0b10001010000000;
let Inst{21-16} = 0b000010;
let Inst{31-24} = 0b00011110;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vwhist256q_sat : HInst<
(outs),
(ins VecPredRegs:$Qv4),
"vwhist256($Qv4):sat",
CVI_HIST, TypeCVI_HIST>, Enc_4109168, Requires<[HasV62T,UseHVX]> {
let Inst{13-0} = 0b10001110000000;
let Inst{21-16} = 0b000010;
let Inst{31-24} = 0b00011110;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vwhist256q_sat_128B : HInst<
(outs),
(ins VecPredRegs128B:$Qv4),
"vwhist256($Qv4):sat",
CVI_HIST, TypeCVI_HIST>, Enc_4109168, Requires<[HasV62T,UseHVX]> {
let Inst{13-0} = 0b10001110000000;
let Inst{21-16} = 0b000010;
let Inst{31-24} = 0b00011110;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vxor : HInst<
(outs VectorRegs:$Vd32),
(ins VectorRegs:$Vu32, VectorRegs:$Vv32),
"$Vd32 = vxor($Vu32,$Vv32)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vxor_128B : HInst<
(outs VectorRegs128B:$Vd32),
(ins VectorRegs128B:$Vu32, VectorRegs128B:$Vv32),
"$Vd32 = vxor($Vu32,$Vv32)",
CVI_VA, TypeCVI_VA>, Enc_6223403, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vzb : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32),
"$Vdd32.uh = vzxt($Vu32.ub)",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_14631806, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vzb_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32),
"$Vdd32.uh = vzxt($Vu32.ub)",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_14631806, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vzb_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32),
"$Vdd32 = vzxtb($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vzb_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32),
"$Vdd32 = vzxtb($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vzh : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32),
"$Vdd32.uw = vzxt($Vu32.uh)",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_14631806, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vzh_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32),
"$Vdd32.uw = vzxt($Vu32.uh)",
CVI_VA_DV, TypeCVI_VA_DV>, Enc_14631806, Requires<[HasV60T,UseHVX]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def V6_vzh_alt : HInst<
(outs VecDblRegs:$Vdd32),
(ins VectorRegs:$Vu32),
"$Vdd32 = vzxth($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vzh_alt_128B : HInst<
(outs VecDblRegs128B:$Vdd32),
(ins VectorRegs128B:$Vu32),
"$Vdd32 = vzxth($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[HasV60T,UseHVX]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let isCodeGenOnly = 1;
}
def Y2_barrier : HInst<
(outs),
(ins),
"barrier",
ST_tc_3stall_SLOT0, TypeST>, Enc_0 {
let Inst{13-0} = 0b00000000000000;
let Inst{31-16} = 0b1010100000000000;
let isSoloAX = 1;
let hasSideEffects = 1;
}
def Y2_break : HInst<
(outs),
(ins),
"brkpt",
CR_tc_3x_SLOT3, TypeCR>, Enc_0 {
let Inst{13-0} = 0b00000000000000;
let Inst{31-16} = 0b0110110000100000;
let isSolo = 1;
}
def Y2_dccleana : HInst<
(outs),
(ins IntRegs:$Rs32),
"dccleana($Rs32)",
ST_tc_ld_SLOT0, TypeST>, Enc_11704059 {
let Inst{13-0} = 0b00000000000000;
let Inst{31-21} = 0b10100000000;
let isSoloAin1 = 1;
}
def Y2_dccleaninva : HInst<
(outs),
(ins IntRegs:$Rs32),
"dccleaninva($Rs32)",
ST_tc_ld_SLOT0, TypeST>, Enc_11704059 {
let Inst{13-0} = 0b00000000000000;
let Inst{31-21} = 0b10100000010;
let isSoloAin1 = 1;
}
def Y2_dcfetch : HInst<
(outs),
(ins IntRegs:$Rs32),
"dcfetch($Rs32)",
PSEUDO, TypeMAPPING> {
let hasSideEffects = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def Y2_dcfetchbo : HInst<
(outs),
(ins IntRegs:$Rs32, u11_3Imm:$Ii),
"dcfetch($Rs32+#$Ii)",
LD_tc_ld_SLOT0, TypeLD>, Enc_4983213 {
let Inst{13-11} = 0b000;
let Inst{31-21} = 0b10010100000;
let addrMode = BaseImmOffset;
let hasSideEffects = 1;
}
def Y2_dcinva : HInst<
(outs),
(ins IntRegs:$Rs32),
"dcinva($Rs32)",
ST_tc_ld_SLOT0, TypeST>, Enc_11704059 {
let Inst{13-0} = 0b00000000000000;
let Inst{31-21} = 0b10100000001;
let isSoloAin1 = 1;
}
def Y2_dczeroa : HInst<
(outs),
(ins IntRegs:$Rs32),
"dczeroa($Rs32)",
ST_tc_ld_SLOT0, TypeST>, Enc_11704059 {
let Inst{13-0} = 0b00000000000000;
let Inst{31-21} = 0b10100000110;
let mayStore = 1;
let isSoloAin1 = 1;
}
def Y2_icinva : HInst<
(outs),
(ins IntRegs:$Rs32),
"icinva($Rs32)",
J_tc_2early_SLOT2, TypeJ>, Enc_11704059 {
let Inst{13-0} = 0b00000000000000;
let Inst{31-21} = 0b01010110110;
let isSolo = 1;
}
def Y2_isync : HInst<
(outs),
(ins),
"isync",
J_tc_2early_SLOT2, TypeJ>, Enc_0 {
let Inst{13-0} = 0b00000000000010;
let Inst{31-16} = 0b0101011111000000;
let isSolo = 1;
}
def Y2_syncht : HInst<
(outs),
(ins),
"syncht",
ST_tc_ld_SLOT0, TypeST>, Enc_0 {
let Inst{13-0} = 0b00000000000000;
let Inst{31-16} = 0b1010100001000000;
let isSolo = 1;
}
def Y4_l2fetch : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"l2fetch($Rs32,$Rt32)",
ST_tc_3stall_SLOT0, TypeST>, Enc_14620934 {
let Inst{7-0} = 0b00000000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10100110000;
let isSoloAX = 1;
let mayStore = 1;
let hasSideEffects = 1;
}
def Y4_trace : HInst<
(outs),
(ins IntRegs:$Rs32),
"trace($Rs32)",
CR_tc_2early_SLOT3, TypeCR>, Enc_11704059 {
let Inst{13-0} = 0b00000000000000;
let Inst{31-21} = 0b01100010010;
let isSoloAX = 1;
}
def Y5_l2fetch : HInst<
(outs),
(ins IntRegs:$Rs32, DoubleRegs:$Rtt32),
"l2fetch($Rs32,$Rtt32)",
ST_tc_3stall_SLOT0, TypeST>, Enc_8943121, Requires<[HasV5T]> {
let Inst{7-0} = 0b00000000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10100110100;
let isSoloAX = 1;
let mayStore = 1;
let hasSideEffects = 1;
}
def dep_A2_addsat : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = add($Rs32,$Rt32):sat:deprecated",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_14071773 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101100;
let hasNewValue = 1;
let opNewValue = 0;
let Defs = [USR_OVF];
}
def dep_A2_subsat : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = sub($Rt32,$Rs32):sat:deprecated",
ALU64_tc_2_SLOT23, TypeALU64>, Enc_8605375 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101100;
let hasNewValue = 1;
let opNewValue = 0;
let Defs = [USR_OVF];
}
def dep_S2_packhl : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = packhl($Rs32,$Rt32):deprecated",
ALU64_tc_1_SLOT23, TypeALU64>, Enc_1997594 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010100000;
}
