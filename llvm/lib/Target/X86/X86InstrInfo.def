//===-- X86InstructionInfo.def - X86 Instruction Information ----*- C++ -*-===//
//
// This file describes all of the instructions that the X86 backend uses.  It
// relys on an external 'I' macro being defined that takes the arguments
// specified below, and is used to make all of the information relevant to an
// instruction be in one place.
//
// Note that X86 Instructions always have the destination register listed as
// operand 0, unless it does not produce a value (in which case the TSFlags will
// include X86II::Void).
//
//===----------------------------------------------------------------------===//

// NOTE: No include guards desired

#ifndef I
#errror "Must define I macro before including X86/X86InstructionInfo.def!"
#endif

// Arguments to be passed into the I macro
//  #1: Enum name - This ends up being the opcode symbol in the X86 namespace
//  #2: Opcode name, as used by the gnu assembler
//  #3: Instruction Flags - This should be a field or'd together that contains
//      constants from the MachineInstrInfo.h file.
//  #4: Target Specific Flags - Another bitfield containing X86 specific flags
//      that we are interested in for each instruction.  These should be flags
//      defined in X86InstrInfo.h in the X86II namespace.
//

// The first instruction must always be the PHI instruction: (FIXME, not yet)
I(PHI         , "phi",                0, 0)

// The second instruction must always be the noop instruction: (FIXME, not yet)
I(NOOP        , "nop",                0, X86II::Void) // nop          90

// Flow control instructions
I(RET         , "ret",       M_RET_FLAG, X86II::Void) // ret          CB
I(JMP         , "jmp",    M_BRANCH_FLAG, X86II::Void) // jmp foo      EB|E9 cb|w

// Misc instructions
I(LEAVE       , "leave",              0, 0)           // leave        C9

// Move instructions
I(MOVrr8      , "movb",               0, 0)           // R8  = R8     88/r
I(MOVrr16     , "movw",               0, 0)           // R16 = R16    89/r
I(MOVrr32     , "movl",               0, 0)           // R32 = R32    89/r
I(MOVir8      , "movb",               0, 0)           // R8  = imm8   B0+ rb
I(MOVir16     , "movw",               0, 0)           // R16 = imm16  B8+ rw
I(MOVir32     , "movl",               0, 0)           // R32 = imm32  B8+ rd
I(MOVmr8      , "movb",               0, 0)           // R8  = [mem]  8A/r
I(MOVmr16     , "movw",               0, 0)           // R16 = [mem]  8B/r
I(MOVmr32     , "movl",               0, 0)           // R32 = [mem]  8B/r
I(MOVrm8      , "movb",               0, 0)           // [mem] = R8   88/r
I(MOVrm16     , "movw",               0, 0)           // [mem] = R16  89/r
I(MOVrm32     , "movl",               0, 0)           // [mem] = R32  89/r

// Arithmetic instructions
I(ADDrr8      , "addb",               0, 0)           // R8  += R8    00/r
I(ADDrr16     , "addw",               0, 0)           // R16 += R16   01/r
I(ADDrr32     , "addl",               0, 0)           // R32 += R32   01/r
I(SUBrr8      , "subb",               0, 0)           // R8  -= R8    2A/r
I(SUBrr16     , "subw",               0, 0)           // R16 -= R16   2B/r
I(SUBrr32     , "subl",               0, 0)           // R32 -= R32   2B/r
I(MULrr8      , "mulb",               0, 0)           // AX   = AL*R8  F6/4
I(MULrr16     , "mulw",               0, 0)           // DX:AX= AX*R16 F7/4
I(MULrr32     , "mull",               0, 0)           // ED:EA= EA*R32 F7/4

// unsigned division/remainder
I(DIVrr8      , "divb",               0, 0)           // AX/r8= AL&AH  F6/6
I(DIVrr16     , "divw",               0, 0)           // DA/r16=AX&DX  F7/6
I(DIVrr32     , "divl",               0, 0)           // DA/r32=EAX&DX F7/6

// signed division/remainder
I(IDIVrr8     , "idivb",              0, 0)           // AX/r8= AL&AH  F6/6
I(IDIVrr16    , "idivw",              0, 0)           // DA/r16=AX&DX  F7/6
I(IDIVrr32    , "idivl",              0, 0)           // DA/r32=EAX&DX F7/6

// Logical operators
I(ANDrr8      , "andb",               0, 0)           // R8  &= R8    20/r
I(ANDrr16     , "andw",               0, 0)           // R16 &= R16   21/r
I(ANDrr32     , "andl",               0, 0)           // R32 &= R32   21/r
I(ORrr8       , "orb",                0, 0)           // R8  |= R8    08/r
I(ORrr16      , "orw",                0, 0)           // R16 |= R16   09/r
I(ORrr32      , "orl",                0, 0)           // R32 |= R32   09/r
I(XORrr8      , "xorb",               0, 0)           // R8  ^= R8    30/r
I(XORrr16     , "xorw",               0, 0)           // R16 ^= R16   31/r
I(XORrr32     , "xorl",               0, 0)           // R32 ^= R32   31/r

// Shift instructions
I(SHLrr8      , "shlb",               0, 0)           // R8   <<= cl   D2/4
I(SHLir8      , "shlb",               0, 0)           // R8   <<= imm8 C0/4 ib
I(SHLrr16     , "shlw",               0, 0)           // R16  <<= cl   D3/4
I(SHLir16     , "shlw",               0, 0)           // R16  <<= imm8 C1/4 ib
I(SHLrr32     , "shll",               0, 0)           // R32  <<= cl   D3/4
I(SHLir32     , "shll",               0, 0)           // R32  <<= imm8 C1/4 ib
I(SHRrr8      , "shrb",               0, 0)           // R8  >>>= cl   D2/5
I(SHRir8      , "shrb",               0, 0)           // R8  >>>= imm8 C0/5 ib
I(SHRrr16     , "shrw",               0, 0)           // R16 >>>= cl   D3/5
I(SHRir16     , "shrw",               0, 0)           // R16 >>>= imm8 C1/5 ib
I(SHRrr32     , "shrl",               0, 0)           // R32 >>>= cl   D3/5
I(SHRir32     , "shrl",               0, 0)           // R32 >>>= imm8 C1/5 ib
I(SARrr8      , "sarb",               0, 0)           // R8   >>= cl   D2/7
I(SARir8      , "sarb",               0, 0)           // R8   >>= imm8 C0/7 ib
I(SARrr16     , "sarw",               0, 0)           // R16  >>= cl   D3/7
I(SARir16     , "sarw",               0, 0)           // R16  >>= imm8 C1/7 ib
I(SARrr32     , "sarl",               0, 0)           // R32  >>= cl   D3/7
I(SARir32     , "sarl",               0, 0)           // R32  >>= imm8 C1/7 ib

// Floating point loads
I(FLDr4       , "flds",               0, X86II::Void) // push float    D9/0
I(FLDr8       , "fldl ",              0, X86II::Void) // push double   DD/0

// Floating point compares
I(FUCOMPP     , "fucompp",            0, X86II::Void) // compare+pop2x DA E9

// Floating point flag ops
I(FNSTSWr8    , "fnstsw",             0, X86II::Void) // AX = fp flags DF E0

// Condition code ops, incl. set if equal/not equal/...
I(SAHF        , "sahf",               0, 0)           // flags = AH    9E
I(SETA        , "seta",               0, 0)           // R8 = > unsign 0F 97
I(SETAE       , "setae",              0, 0)           // R8 = >=unsign 0F 93
I(SETB        , "setb",               0, 0)           // R8 = < unsign 0F 92
I(SETBE       , "setbe",              0, 0)           // R8 = <=unsign 0F 96
I(SETE        , "sete",               0, 0)           // R8 = ==       0F 94
I(SETG        , "setg",               0, 0)           // R8 = > signed 0F 9F
I(SETGE       , "setge",              0, 0)           // R8 = >=signed 0F 9D
I(SETL        , "setl",               0, 0)           // R8 = < signed 0F 9C
I(SETLE       , "setle",              0, 0)           // R8 = <=signed 0F 9E
I(SETNE       , "setne",              0, 0)           // R8 = !=       0F 95

// Integer comparisons
I(CMPrr8      , "cmpb",               0, 0)           // compare R8,R8   38/r
I(CMPrr16     , "cmpw",               0, 0)           // compare R16,R16 39/r
I(CMPrr32     , "cmpl",               0, 0)           // compare R32,R32 39/r

// Sign extenders (first 3 are good for DIV/IDIV; the others are more general)
I(CBW         , "cbw",                0, 0)     // AX = signext(AL)         98
I(CWD         , "cwd",                0, 0)     // DX:AX = signext(AX)      99
I(CDQ         , "cdq",                0, 0)     // EDX:EAX = signext(EAX)   99
I(MOVSXr16r8  , "movsx",              0, 0)     // R32 = signext(R8)  0F BE /r
I(MOVSXr32r8  , "movsx",              0, 0)     // R32 = signext(R8)  0F BE /r
I(MOVSXr32r16 , "movsx",              0, 0)     // R32 = signext(R16) 0F BF /r
I(MOVZXr16r8  , "movzx",              0, 0)     // R32 = zeroext(R8)  0F B6 /r
I(MOVZXr32r8  , "movzx",              0, 0)     // R32 = zeroext(R8)  0F B6 /r
I(MOVZXr32r16 , "movzx",              0, 0)     // R32 = zeroext(R16) 0F B7 /r

// At this point, I is dead, so undefine the macro
#undef I
