//===-- X86RegisterInfo.def - X86 Register Information ----------*- C++ -*-===//
//
// This file describes all of the registers that the X86 backend uses. It relies
// on an external 'R' macro being defined that takes the arguments specified
// below, and is used to make all of the information relevant to registers be in
// one place.
//
//===----------------------------------------------------------------------===//

// NOTE: No include guards desired
#ifndef R
#define R(ENUM, NAME, FLAGS, TSFLAGS, A1, A2, A3)
#endif

#ifndef R8
#define R8(ENUM, NAME, FLAGS, TSFLAGS, A1, A2, A3) \
   R(ENUM, NAME, FLAGS, TSFLAGS, A1, A2, A3)
#endif

#ifndef R16
#define R16(ENUM, NAME, FLAGS, TSFLAGS, A1, A2, A3) \
   R(ENUM, NAME, FLAGS, TSFLAGS, A1, A2, A3)
#endif

#ifndef R32
#define R32(ENUM, NAME, FLAGS, TSFLAGS, A1, A2, A3) \
   R(ENUM, NAME, FLAGS, TSFLAGS, A1, A2, A3)
#endif

// Arguments passed into the R macros
//  #1: Enum Name - This ends up being a symbol in the X86 namespace
//  #2: Register name - The name of the register as used by the gnu assembler
//  #3: Register Flags - A bitfield of flags or'd together from the
//      MRegisterInfo.h file.
//  #4: Target Specific Flags - Another bitfield containing X86 specific flags
//      as neccesary.
//
//  #5,6,7: Registers aliased to this register, or 0 if none.


// The first register must always be a 'noop' register for all backends.  This
// is used as the destination register for instructions that do not produce a
// value.  Some frontends may use this as an operand register to mean special
// things, for example, the Sparc backend uses R#0 to mean %g0 which always
// PRODUCES the value 0.
//
// The X86 backend uses this value as an operand register only in memory
// references where it means that there is no base or index register.
//
R(NoReg,"none",          0, 0,       0,       0,       0)

// 32 bit registers, ordered as the processor does...
R32(EAX, "EAX", MRF::INT32, 0, X86::AX, X86::AH, X86::AL)
R32(ECX, "ECX", MRF::INT32, 0, X86::CX, X86::CH, X86::CL)
R32(EDX, "EDX", MRF::INT32, 0, X86::DX, X86::DH, X86::DL)
R32(EBX, "EBX", MRF::INT32, 0, X86::BX, X86::BH, X86::BL)
R32(ESP, "ESP", MRF::INT32, 0, X86::SP,       0,       0)
R32(EBP, "EBP", MRF::INT32, 0, X86::BP,       0,       0)
R32(ESI, "ESI", MRF::INT32, 0, X86::SI,       0,       0)
R32(EDI, "EDI", MRF::INT32, 0, X86::DI,       0,       0)

// 16 bit registers, aliased with the corresponding 32 bit registers above
R16( AX, "AX" , MRF::INT16, 0, X86::EAX, X86::AH, X86::AL)
R16( CX, "CX" , MRF::INT16, 0, X86::ECX, X86::CH, X86::CL)
R16( DX, "DX" , MRF::INT16, 0, X86::EDX, X86::DH, X86::DL)
R16( BX, "BX" , MRF::INT16, 0, X86::EBX, X86::BH, X86::BL)
R16( SP, "SP" , MRF::INT16, 0, X86::ESP,       0,       0)
R16( BP, "BP" , MRF::INT16, 0, X86::EBP,       0,       0)
R16( SI, "SI" , MRF::INT16, 0, X86::ESI,       0,       0)
R16( DI, "DI" , MRF::INT16, 0, X86::EDI,       0,       0)

// 8 bit registers aliased with registers above as well
R8 ( AL, "AL" , MRF::INT8 , 0, X86::EAX, X86::AX,       0)
R8 ( CL, "CL" , MRF::INT8 , 0, X86::ECX, X86::CX,       0)
R8 ( DL, "DL" , MRF::INT8 , 0, X86::EDX, X86::DX,       0)
R8 ( BL, "BL" , MRF::INT8 , 0, X86::EBX, X86::BX,       0)
R8 ( AH, "AH" , MRF::INT8 , 0, X86::EAX, X86::AX,       0)
R8 ( CH, "CH" , MRF::INT8 , 0, X86::ECX, X86::CX,       0)
R8 ( DH, "DH" , MRF::INT8 , 0, X86::EDX, X86::DX,       0)
R8 ( BH, "BH" , MRF::INT8 , 0, X86::EBX, X86::BX,       0)

// Flags, Segment registers, etc...

// This is a slimy hack to make it possible to say that flags are clobbered...
// Ideally we'd model instructions based on which particular flag(s) they
// could clobber. 
R(EFLAGS, "EFLAGS", MRF::INT16, 0,    0,       0,       0)


// We are now done with the R* macros
#undef R
#undef R8
#undef R16
#undef R32
