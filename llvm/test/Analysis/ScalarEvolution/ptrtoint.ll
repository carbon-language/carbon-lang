; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py
; RUN: opt < %s --data-layout="e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128" -S -analyze -enable-new-pm=0 -scalar-evolution | FileCheck --check-prefixes=ALL,X64 %s
; RUN: opt < %s --data-layout="e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128" -S -disable-output "-passes=print<scalar-evolution>" 2>&1 | FileCheck --check-prefixes=ALL,X64 %s
; RUN: opt < %s --data-layout="e-m:e-p:32:32-p270:32:32-p271:32:32-p272:64:64-f64:32:64-f80:32-n8:16:32-S128" -S -analyze -enable-new-pm=0 -scalar-evolution | FileCheck --check-prefixes=ALL,X32 %s
; RUN: opt < %s --data-layout="e-m:e-p:32:32-p270:32:32-p271:32:32-p272:64:64-f64:32:64-f80:32-n8:16:32-S128" -S -disable-output "-passes=print<scalar-evolution>" 2>&1 | FileCheck --check-prefixes=ALL,X32 %s

; While we can't treat inttoptr/ptrtoint casts as fully transparent,
; for ptrtoint cast, instead of modelling it as fully opaque (unknown),
; we can at least model it as zext/trunc/self of an unknown,
; iff it it's argument would be modelled as unknown anyways.

declare void @useptr(i8*)

; Simple ptrtoint of an argument, with casts to potentially different bit widths.
define void @ptrtoint(i8* %in, i64* %out0, i32* %out1, i16* %out2, i128* %out3) {
; X64-LABEL: 'ptrtoint'
; X64-NEXT:  Classifying expressions for: @ptrtoint
; X64-NEXT:    %p0 = ptrtoint i8* %in to i64
; X64-NEXT:    --> %in U: full-set S: full-set
; X64-NEXT:    %p1 = ptrtoint i8* %in to i32
; X64-NEXT:    --> (trunc i8* %in to i32) U: full-set S: full-set
; X64-NEXT:    %p2 = ptrtoint i8* %in to i16
; X64-NEXT:    --> (trunc i8* %in to i16) U: full-set S: full-set
; X64-NEXT:    %p3 = ptrtoint i8* %in to i128
; X64-NEXT:    --> (zext i8* %in to i128) U: [0,18446744073709551616) S: [0,18446744073709551616)
; X64-NEXT:  Determining loop execution counts for: @ptrtoint
;
; X32-LABEL: 'ptrtoint'
; X32-NEXT:  Classifying expressions for: @ptrtoint
; X32-NEXT:    %p0 = ptrtoint i8* %in to i64
; X32-NEXT:    --> (zext i8* %in to i64) U: [0,4294967296) S: [0,4294967296)
; X32-NEXT:    %p1 = ptrtoint i8* %in to i32
; X32-NEXT:    --> %in U: full-set S: full-set
; X32-NEXT:    %p2 = ptrtoint i8* %in to i16
; X32-NEXT:    --> (trunc i8* %in to i16) U: full-set S: full-set
; X32-NEXT:    %p3 = ptrtoint i8* %in to i128
; X32-NEXT:    --> (zext i8* %in to i128) U: [0,4294967296) S: [0,4294967296)
; X32-NEXT:  Determining loop execution counts for: @ptrtoint
;
  %p0 = ptrtoint i8* %in to i64
  %p1 = ptrtoint i8* %in to i32
  %p2 = ptrtoint i8* %in to i16
  %p3 = ptrtoint i8* %in to i128
  store i64  %p0, i64*  %out0
  store i32  %p1, i32*  %out1
  store i16  %p2, i16*  %out2
  store i128 %p3, i128* %out3
  ret void
}

; Same, but from non-zero/non-default address space.
define void @ptrtoint_as1(i8 addrspace(1)* %in, i64* %out0, i32* %out1, i16* %out2, i128* %out3) {
; X64-LABEL: 'ptrtoint_as1'
; X64-NEXT:  Classifying expressions for: @ptrtoint_as1
; X64-NEXT:    %p0 = ptrtoint i8 addrspace(1)* %in to i64
; X64-NEXT:    --> %in U: full-set S: full-set
; X64-NEXT:    %p1 = ptrtoint i8 addrspace(1)* %in to i32
; X64-NEXT:    --> (trunc i8 addrspace(1)* %in to i32) U: full-set S: full-set
; X64-NEXT:    %p2 = ptrtoint i8 addrspace(1)* %in to i16
; X64-NEXT:    --> (trunc i8 addrspace(1)* %in to i16) U: full-set S: full-set
; X64-NEXT:    %p3 = ptrtoint i8 addrspace(1)* %in to i128
; X64-NEXT:    --> (zext i8 addrspace(1)* %in to i128) U: [0,18446744073709551616) S: [0,18446744073709551616)
; X64-NEXT:  Determining loop execution counts for: @ptrtoint_as1
;
; X32-LABEL: 'ptrtoint_as1'
; X32-NEXT:  Classifying expressions for: @ptrtoint_as1
; X32-NEXT:    %p0 = ptrtoint i8 addrspace(1)* %in to i64
; X32-NEXT:    --> (zext i8 addrspace(1)* %in to i64) U: [0,4294967296) S: [0,4294967296)
; X32-NEXT:    %p1 = ptrtoint i8 addrspace(1)* %in to i32
; X32-NEXT:    --> %in U: full-set S: full-set
; X32-NEXT:    %p2 = ptrtoint i8 addrspace(1)* %in to i16
; X32-NEXT:    --> (trunc i8 addrspace(1)* %in to i16) U: full-set S: full-set
; X32-NEXT:    %p3 = ptrtoint i8 addrspace(1)* %in to i128
; X32-NEXT:    --> (zext i8 addrspace(1)* %in to i128) U: [0,4294967296) S: [0,4294967296)
; X32-NEXT:  Determining loop execution counts for: @ptrtoint_as1
;
  %p0 = ptrtoint i8 addrspace(1)* %in to i64
  %p1 = ptrtoint i8 addrspace(1)* %in to i32
  %p2 = ptrtoint i8 addrspace(1)* %in to i16
  %p3 = ptrtoint i8 addrspace(1)* %in to i128
  store i64  %p0, i64*  %out0
  store i32  %p1, i32*  %out1
  store i16  %p2, i16*  %out2
  store i128 %p3, i128* %out3
  ret void
}

; Likewise, ptrtoint of a bitcast is fine, we simply skip it.
define void @ptrtoint_of_bitcast(i8* %in, i64* %out0) {
; X64-LABEL: 'ptrtoint_of_bitcast'
; X64-NEXT:  Classifying expressions for: @ptrtoint_of_bitcast
; X64-NEXT:    %in_casted = bitcast i8* %in to float*
; X64-NEXT:    --> %in U: full-set S: full-set
; X64-NEXT:    %p0 = ptrtoint float* %in_casted to i64
; X64-NEXT:    --> %in U: full-set S: full-set
; X64-NEXT:  Determining loop execution counts for: @ptrtoint_of_bitcast
;
; X32-LABEL: 'ptrtoint_of_bitcast'
; X32-NEXT:  Classifying expressions for: @ptrtoint_of_bitcast
; X32-NEXT:    %in_casted = bitcast i8* %in to float*
; X32-NEXT:    --> %in U: full-set S: full-set
; X32-NEXT:    %p0 = ptrtoint float* %in_casted to i64
; X32-NEXT:    --> (zext i8* %in to i64) U: [0,4294967296) S: [0,4294967296)
; X32-NEXT:  Determining loop execution counts for: @ptrtoint_of_bitcast
;
  %in_casted = bitcast i8* %in to float*
  %p0 = ptrtoint float* %in_casted to i64
  store i64 %p0, i64* %out0
  ret void
}

; addrspacecast is fine too, but We don't model addrspacecast, so we stop there.
define void @ptrtoint_of_addrspacecast(i8* %in, i64* %out0) {
; X64-LABEL: 'ptrtoint_of_addrspacecast'
; X64-NEXT:  Classifying expressions for: @ptrtoint_of_addrspacecast
; X64-NEXT:    %in_casted = addrspacecast i8* %in to i8 addrspace(1)*
; X64-NEXT:    --> %in_casted U: full-set S: full-set
; X64-NEXT:    %p0 = ptrtoint i8 addrspace(1)* %in_casted to i64
; X64-NEXT:    --> %in_casted U: full-set S: full-set
; X64-NEXT:  Determining loop execution counts for: @ptrtoint_of_addrspacecast
;
; X32-LABEL: 'ptrtoint_of_addrspacecast'
; X32-NEXT:  Classifying expressions for: @ptrtoint_of_addrspacecast
; X32-NEXT:    %in_casted = addrspacecast i8* %in to i8 addrspace(1)*
; X32-NEXT:    --> %in_casted U: full-set S: full-set
; X32-NEXT:    %p0 = ptrtoint i8 addrspace(1)* %in_casted to i64
; X32-NEXT:    --> (zext i8 addrspace(1)* %in_casted to i64) U: [0,4294967296) S: [0,4294967296)
; X32-NEXT:  Determining loop execution counts for: @ptrtoint_of_addrspacecast
;
  %in_casted = addrspacecast i8* %in to i8 addrspace(1)*
  %p0 = ptrtoint i8 addrspace(1)* %in_casted to i64
  store i64 %p0, i64* %out0
  ret void
}

; inttoptr is fine too, but we don't (and can't) model inttoptr, so we stop there.
define void @ptrtoint_of_inttoptr(i64 %in, i64* %out0) {
; X64-LABEL: 'ptrtoint_of_inttoptr'
; X64-NEXT:  Classifying expressions for: @ptrtoint_of_inttoptr
; X64-NEXT:    %in_casted = inttoptr i64 %in to i8*
; X64-NEXT:    --> %in_casted U: full-set S: full-set
; X64-NEXT:    %p0 = ptrtoint i8* %in_casted to i64
; X64-NEXT:    --> %in_casted U: full-set S: full-set
; X64-NEXT:  Determining loop execution counts for: @ptrtoint_of_inttoptr
;
; X32-LABEL: 'ptrtoint_of_inttoptr'
; X32-NEXT:  Classifying expressions for: @ptrtoint_of_inttoptr
; X32-NEXT:    %in_casted = inttoptr i64 %in to i8*
; X32-NEXT:    --> %in_casted U: full-set S: full-set
; X32-NEXT:    %p0 = ptrtoint i8* %in_casted to i64
; X32-NEXT:    --> (zext i8* %in_casted to i64) U: [0,4294967296) S: [0,4294967296)
; X32-NEXT:  Determining loop execution counts for: @ptrtoint_of_inttoptr
;
  %in_casted = inttoptr i64 %in to i8*
  %p0 = ptrtoint i8* %in_casted to i64
  store i64 %p0, i64* %out0
  ret void
}

; However, GEP is something SCEV knows how to model, so in this case ptrtoint
; can't be modelled as a cast, only as an unknown.
define void @ptrtoint_of_gep(i8* %in, i64* %out0) {
; X64-LABEL: 'ptrtoint_of_gep'
; X64-NEXT:  Classifying expressions for: @ptrtoint_of_gep
; X64-NEXT:    %in_adj = getelementptr inbounds i8, i8* %in, i64 42
; X64-NEXT:    --> (42 + %in)<nsw> U: [-9223372036854775766,-9223372036854775808) S: [-9223372036854775766,-9223372036854775808)
; X64-NEXT:    %p0 = ptrtoint i8* %in_adj to i64
; X64-NEXT:    --> %p0 U: full-set S: full-set
; X64-NEXT:  Determining loop execution counts for: @ptrtoint_of_gep
;
; X32-LABEL: 'ptrtoint_of_gep'
; X32-NEXT:  Classifying expressions for: @ptrtoint_of_gep
; X32-NEXT:    %in_adj = getelementptr inbounds i8, i8* %in, i64 42
; X32-NEXT:    --> (42 + %in)<nsw> U: [-2147483606,-2147483648) S: [-2147483606,-2147483648)
; X32-NEXT:    %p0 = ptrtoint i8* %in_adj to i64
; X32-NEXT:    --> %p0 U: [0,4294967296) S: [-4294967296,4294967296)
; X32-NEXT:  Determining loop execution counts for: @ptrtoint_of_gep
;
  %in_adj = getelementptr inbounds i8, i8* %in, i64 42
  %p0 = ptrtoint i8* %in_adj to i64
  store i64  %p0, i64*  %out0
  ret void
}

; A constant pointer is fine
define void @ptrtoint_of_nullptr(i64* %out0) {
; ALL-LABEL: 'ptrtoint_of_nullptr'
; ALL-NEXT:  Classifying expressions for: @ptrtoint_of_nullptr
; ALL-NEXT:    %p0 = ptrtoint i8* null to i64
; ALL-NEXT:    --> %p0 U: [0,1) S: [-1,1)
; ALL-NEXT:  Determining loop execution counts for: @ptrtoint_of_nullptr
;
  %p0 = ptrtoint i8* null to i64
  store i64 %p0, i64* %out0
  ret void
}

; A constant inttoptr argument of an ptrtoint is still bad.
define void @ptrtoint_of_constantexpr_inttoptr(i64* %out0) {
; X64-LABEL: 'ptrtoint_of_constantexpr_inttoptr'
; X64-NEXT:  Classifying expressions for: @ptrtoint_of_constantexpr_inttoptr
; X64-NEXT:    %p0 = ptrtoint i8* inttoptr (i64 42 to i8*) to i64
; X64-NEXT:    --> inttoptr (i64 42 to i8*) U: [42,43) S: [-64,64)
; X64-NEXT:  Determining loop execution counts for: @ptrtoint_of_constantexpr_inttoptr
;
; X32-LABEL: 'ptrtoint_of_constantexpr_inttoptr'
; X32-NEXT:  Classifying expressions for: @ptrtoint_of_constantexpr_inttoptr
; X32-NEXT:    %p0 = ptrtoint i8* inttoptr (i64 42 to i8*) to i64
; X32-NEXT:    --> (zext i8* inttoptr (i64 42 to i8*) to i64) U: [42,43) S: [0,4294967296)
; X32-NEXT:  Determining loop execution counts for: @ptrtoint_of_constantexpr_inttoptr
;
  %p0 = ptrtoint i8* inttoptr (i64 42 to i8*) to i64
  store i64 %p0, i64* %out0
  ret void
}

; However, while bitcast would be fine, GEP we can model, so we are back
; to modelling the whole cast as unknown..
define void @ptrtoint_of_bitcast_of_gep(i8* %in, i64* %out0) {
; X64-LABEL: 'ptrtoint_of_bitcast_of_gep'
; X64-NEXT:  Classifying expressions for: @ptrtoint_of_bitcast_of_gep
; X64-NEXT:    %in_adj = getelementptr inbounds i8, i8* %in, i64 42
; X64-NEXT:    --> (42 + %in)<nsw> U: [-9223372036854775766,-9223372036854775808) S: [-9223372036854775766,-9223372036854775808)
; X64-NEXT:    %in_adj_casted = bitcast i8* %in_adj to float*
; X64-NEXT:    --> (42 + %in)<nsw> U: [-9223372036854775766,-9223372036854775808) S: [-9223372036854775766,-9223372036854775808)
; X64-NEXT:    %p0 = ptrtoint float* %in_adj_casted to i64
; X64-NEXT:    --> %p0 U: full-set S: full-set
; X64-NEXT:  Determining loop execution counts for: @ptrtoint_of_bitcast_of_gep
;
; X32-LABEL: 'ptrtoint_of_bitcast_of_gep'
; X32-NEXT:  Classifying expressions for: @ptrtoint_of_bitcast_of_gep
; X32-NEXT:    %in_adj = getelementptr inbounds i8, i8* %in, i64 42
; X32-NEXT:    --> (42 + %in)<nsw> U: [-2147483606,-2147483648) S: [-2147483606,-2147483648)
; X32-NEXT:    %in_adj_casted = bitcast i8* %in_adj to float*
; X32-NEXT:    --> (42 + %in)<nsw> U: [-2147483606,-2147483648) S: [-2147483606,-2147483648)
; X32-NEXT:    %p0 = ptrtoint float* %in_adj_casted to i64
; X32-NEXT:    --> %p0 U: [0,4294967296) S: [-4294967296,4294967296)
; X32-NEXT:  Determining loop execution counts for: @ptrtoint_of_bitcast_of_gep
;
  %in_adj = getelementptr inbounds i8, i8* %in, i64 42
  %in_adj_casted = bitcast i8* %in_adj to float*
  %p0 = ptrtoint float* %in_adj_casted to i64
  store i64 %p0, i64* %out0
  ret void
}
