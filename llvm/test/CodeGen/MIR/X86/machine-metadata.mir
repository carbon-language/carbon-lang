# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
# RUN: llc -mtriple=x86_64-linux-gnu -run-pass=none -o - %s | FileCheck %s
--- |
  ; ModuleID = 'test/CodeGen/X86/memcpy-scoped-aa.ll'
  source_filename = "test/CodeGen/X86/memcpy-scoped-aa.ll"
  target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
  target triple = "x86_64-unknown-linux-gnu"

  define i32 @test_memcpy(i32* nocapture %p, i32* nocapture readonly %q) {
    %p0 = bitcast i32* %p to i8*
    %add.ptr = getelementptr inbounds i32, i32* %p, i64 4
    %p1 = bitcast i32* %add.ptr to i8*
    tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(16) %p0, i8* noundef nonnull align 4 dereferenceable(16) %p1, i64 16, i1 false), !alias.scope !0, !noalias !3
    %v0 = load i32, i32* %q, align 4, !alias.scope !3, !noalias !0
    %q1 = getelementptr inbounds i32, i32* %q, i64 1
    %v1 = load i32, i32* %q1, align 4, !alias.scope !3, !noalias !0
    %add = add i32 %v0, %v1
    ret i32 %add
  }

  define i32 @test_memcpy_inline(i32* nocapture %p, i32* nocapture readonly %q) {
    %p0 = bitcast i32* %p to i8*
    %add.ptr = getelementptr inbounds i32, i32* %p, i64 4
    %p1 = bitcast i32* %add.ptr to i8*
    tail call void @llvm.memcpy.inline.p0i8.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(16) %p0, i8* noundef nonnull align 4 dereferenceable(16) %p1, i64 16, i1 false), !alias.scope !0, !noalias !3
    %v0 = load i32, i32* %q, align 4, !alias.scope !3, !noalias !0
    %q1 = getelementptr inbounds i32, i32* %q, i64 1
    %v1 = load i32, i32* %q1, align 4, !alias.scope !3, !noalias !0
    %add = add i32 %v0, %v1
    ret i32 %add
  }

  define i32 @test_mempcpy(i32* nocapture %p, i32* nocapture readonly %q) {
    %p0 = bitcast i32* %p to i8*
    %add.ptr = getelementptr inbounds i32, i32* %p, i64 4
    %p1 = bitcast i32* %add.ptr to i8*
    %call = tail call i8* @mempcpy(i8* noundef nonnull align 4 dereferenceable(16) %p0, i8* noundef nonnull align 4 dereferenceable(16) %p1, i64 16), !alias.scope !0, !noalias !3
    %v0 = load i32, i32* %q, align 4, !alias.scope !3, !noalias !0
    %q1 = getelementptr inbounds i32, i32* %q, i64 1
    %v1 = load i32, i32* %q1, align 4, !alias.scope !3, !noalias !0
    %add = add i32 %v0, %v1
    ret i32 %add
  }

  ; Function Attrs: argmemonly nofree nounwind willreturn
  declare void @llvm.memcpy.p0i8.p0i8.i64(i8* noalias nocapture writeonly, i8* noalias nocapture readonly, i64, i1 immarg) #0

  ; Function Attrs: argmemonly nofree nounwind willreturn
  declare void @llvm.memcpy.inline.p0i8.p0i8.i64(i8* noalias nocapture writeonly, i8* noalias nocapture readonly, i64 immarg, i1 immarg) #0

  declare i8* @mempcpy(i8*, i8*, i64)

  attributes #0 = { argmemonly nofree nounwind willreturn }

  !0 = !{!1}
  !1 = distinct !{!1, !2, !"bax: %p"}
  !2 = distinct !{!2, !"bax"}
  !3 = !{!4}
  !4 = distinct !{!4, !2, !"bax: %q"}

...
---
name:            test_memcpy
machineMetadataNodes:
  - '!7 = distinct !{!7, !"MemcpyLoweringDomain"}'
  - '!9 = distinct !{!9, !7, !"Dst"}'
  - '!8 = !{!4, !9}'
  - '!5 = !{!1, !6}'
  - '!6 = distinct !{!6, !7, !"Src"}'
  - '!11 = !{!4, !6}'
  - '!10 = !{!1, !9}'
body:             |
  bb.0 (%ir-block.0):
    liveins: $rdi, $rsi

    ; CHECK-LABEL: name: test_memcpy
    ; CHECK: [[COPY:%[0-9]+]]:gr64 = COPY $rsi
    ; CHECK: [[COPY1:%[0-9]+]]:gr64 = COPY $rdi
    ; CHECK: [[MOV64rm:%[0-9]+]]:gr64 = MOV64rm [[COPY1]], 1, $noreg, 16, $noreg :: (load (s64) from %ir.p1, align 4, !alias.scope !5, !noalias !8)
    ; CHECK: [[MOV64rm1:%[0-9]+]]:gr64 = MOV64rm [[COPY1]], 1, $noreg, 24, $noreg :: (load (s64) from %ir.p1 + 8, align 4, !alias.scope !5, !noalias !8)
    ; CHECK: MOV64mr [[COPY1]], 1, $noreg, 8, $noreg, killed [[MOV64rm1]] :: (store (s64) into %ir.p0 + 8, align 4, !alias.scope !10, !noalias !11)
    ; CHECK: MOV64mr [[COPY1]], 1, $noreg, 0, $noreg, killed [[MOV64rm]] :: (store (s64) into %ir.p0, align 4, !alias.scope !10, !noalias !11)
    ; CHECK: [[MOV32rm:%[0-9]+]]:gr32 = MOV32rm [[COPY]], 1, $noreg, 0, $noreg :: (load (s32) from %ir.q, !alias.scope !3, !noalias !0)
    ; CHECK: [[ADD32rm:%[0-9]+]]:gr32 = ADD32rm [[MOV32rm]], [[COPY]], 1, $noreg, 4, $noreg, implicit-def dead $eflags :: (load (s32) from %ir.q1, !alias.scope !3, !noalias !0)
    ; CHECK: $eax = COPY [[ADD32rm]]
    ; CHECK: RET 0, $eax
    %1:gr64 = COPY $rsi
    %0:gr64 = COPY $rdi
    %2:gr64 = MOV64rm %0, 1, $noreg, 16, $noreg :: (load (s64) from %ir.p1, align 4, !alias.scope !5, !noalias !8)
    %3:gr64 = MOV64rm %0, 1, $noreg, 24, $noreg :: (load (s64) from %ir.p1 + 8, align 4, !alias.scope !5, !noalias !8)
    MOV64mr %0, 1, $noreg, 8, $noreg, killed %3 :: (store (s64) into %ir.p0 + 8, align 4, !alias.scope !10, !noalias !11)
    MOV64mr %0, 1, $noreg, 0, $noreg, killed %2 :: (store (s64) into %ir.p0, align 4, !alias.scope !10, !noalias !11)
    %4:gr32 = MOV32rm %1, 1, $noreg, 0, $noreg :: (load (s32) from %ir.q, !alias.scope !3, !noalias !0)
    %5:gr32 = ADD32rm %4, %1, 1, $noreg, 4, $noreg, implicit-def dead $eflags :: (load (s32) from %ir.q1, !alias.scope !3, !noalias !0)
    $eax = COPY %5
    RET 0, $eax

...
---
name:            test_memcpy_inline
machineMetadataNodes:
  - '!8 = !{!4, !9}'
  - '!9 = distinct !{!9, !7, !"Dst"}'
  - '!5 = !{!1, !6}'
  - '!7 = distinct !{!7, !"MemcpyLoweringDomain"}'
  - '!11 = !{!4, !6}'
  - '!10 = !{!1, !9}'
  - '!6 = distinct !{!6, !7, !"Src"}'
body:             |
  bb.0 (%ir-block.0):
    liveins: $rdi, $rsi

    ; CHECK-LABEL: name: test_memcpy_inline
    ; CHECK: [[COPY:%[0-9]+]]:gr64 = COPY $rsi
    ; CHECK: [[COPY1:%[0-9]+]]:gr64 = COPY $rdi
    ; CHECK: [[MOV64rm:%[0-9]+]]:gr64 = MOV64rm [[COPY1]], 1, $noreg, 16, $noreg :: (load (s64) from %ir.p1, align 4, !alias.scope !5, !noalias !8)
    ; CHECK: [[MOV64rm1:%[0-9]+]]:gr64 = MOV64rm [[COPY1]], 1, $noreg, 24, $noreg :: (load (s64) from %ir.p1 + 8, align 4, !alias.scope !5, !noalias !8)
    ; CHECK: MOV64mr [[COPY1]], 1, $noreg, 8, $noreg, killed [[MOV64rm1]] :: (store (s64) into %ir.p0 + 8, align 4, !alias.scope !10, !noalias !11)
    ; CHECK: MOV64mr [[COPY1]], 1, $noreg, 0, $noreg, killed [[MOV64rm]] :: (store (s64) into %ir.p0, align 4, !alias.scope !10, !noalias !11)
    ; CHECK: [[MOV32rm:%[0-9]+]]:gr32 = MOV32rm [[COPY]], 1, $noreg, 0, $noreg :: (load (s32) from %ir.q, !alias.scope !3, !noalias !0)
    ; CHECK: [[ADD32rm:%[0-9]+]]:gr32 = ADD32rm [[MOV32rm]], [[COPY]], 1, $noreg, 4, $noreg, implicit-def dead $eflags :: (load (s32) from %ir.q1, !alias.scope !3, !noalias !0)
    ; CHECK: $eax = COPY [[ADD32rm]]
    ; CHECK: RET 0, $eax
    %1:gr64 = COPY $rsi
    %0:gr64 = COPY $rdi
    %2:gr64 = MOV64rm %0, 1, $noreg, 16, $noreg :: (load (s64) from %ir.p1, align 4, !alias.scope !5, !noalias !8)
    %3:gr64 = MOV64rm %0, 1, $noreg, 24, $noreg :: (load (s64) from %ir.p1 + 8, align 4, !alias.scope !5, !noalias !8)
    MOV64mr %0, 1, $noreg, 8, $noreg, killed %3 :: (store (s64) into %ir.p0 + 8, align 4, !alias.scope !10, !noalias !11)
    MOV64mr %0, 1, $noreg, 0, $noreg, killed %2 :: (store (s64) into %ir.p0, align 4, !alias.scope !10, !noalias !11)
    %4:gr32 = MOV32rm %1, 1, $noreg, 0, $noreg :: (load (s32) from %ir.q, !alias.scope !3, !noalias !0)
    %5:gr32 = ADD32rm %4, %1, 1, $noreg, 4, $noreg, implicit-def dead $eflags :: (load (s32) from %ir.q1, !alias.scope !3, !noalias !0)
    $eax = COPY %5
    RET 0, $eax

...
---
name:            test_mempcpy
machineMetadataNodes:
  - '!5 = !{!1, !6}'
  - '!8 = !{!4, !9}'
  - '!11 = !{!4, !6}'
  - '!10 = !{!1, !9}'
  - '!7 = distinct !{!7, !"MemcpyLoweringDomain"}'
  - '!6 = distinct !{!6, !7, !"Src"}'
  - '!9 = distinct !{!9, !7, !"Dst"}'
body:             |
  bb.0 (%ir-block.0):
    liveins: $rdi, $rsi

    ; CHECK-LABEL: name: test_mempcpy
    ; CHECK: [[COPY:%[0-9]+]]:gr64 = COPY $rsi
    ; CHECK: [[COPY1:%[0-9]+]]:gr64 = COPY $rdi
    ; CHECK: [[MOV64rm:%[0-9]+]]:gr64 = MOV64rm [[COPY1]], 1, $noreg, 16, $noreg :: (load (s64) from %ir.p1, align 1, !alias.scope !5, !noalias !8)
    ; CHECK: [[MOV64rm1:%[0-9]+]]:gr64 = MOV64rm [[COPY1]], 1, $noreg, 24, $noreg :: (load (s64) from %ir.p1 + 8, align 1, !alias.scope !5, !noalias !8)
    ; CHECK: MOV64mr [[COPY1]], 1, $noreg, 8, $noreg, killed [[MOV64rm1]] :: (store (s64) into %ir.p0 + 8, align 1, !alias.scope !10, !noalias !11)
    ; CHECK: MOV64mr [[COPY1]], 1, $noreg, 0, $noreg, killed [[MOV64rm]] :: (store (s64) into %ir.p0, align 1, !alias.scope !10, !noalias !11)
    ; CHECK: [[MOV32rm:%[0-9]+]]:gr32 = MOV32rm [[COPY]], 1, $noreg, 0, $noreg :: (load (s32) from %ir.q, !alias.scope !3, !noalias !0)
    ; CHECK: [[ADD32rm:%[0-9]+]]:gr32 = ADD32rm [[MOV32rm]], [[COPY]], 1, $noreg, 4, $noreg, implicit-def dead $eflags :: (load (s32) from %ir.q1, !alias.scope !3, !noalias !0)
    ; CHECK: $eax = COPY [[ADD32rm]]
    ; CHECK: RET 0, $eax
    %1:gr64 = COPY $rsi
    %0:gr64 = COPY $rdi
    %2:gr64 = MOV64rm %0, 1, $noreg, 16, $noreg :: (load (s64) from %ir.p1, align 1, !alias.scope !5, !noalias !8)
    %3:gr64 = MOV64rm %0, 1, $noreg, 24, $noreg :: (load (s64) from %ir.p1 + 8, align 1, !alias.scope !5, !noalias !8)
    MOV64mr %0, 1, $noreg, 8, $noreg, killed %3 :: (store (s64) into %ir.p0 + 8, align 1, !alias.scope !10, !noalias !11)
    MOV64mr %0, 1, $noreg, 0, $noreg, killed %2 :: (store (s64) into %ir.p0, align 1, !alias.scope !10, !noalias !11)
    %4:gr32 = MOV32rm %1, 1, $noreg, 0, $noreg :: (load (s32) from %ir.q, !alias.scope !3, !noalias !0)
    %5:gr32 = ADD32rm %4, %1, 1, $noreg, 4, $noreg, implicit-def dead $eflags :: (load (s32) from %ir.q1, !alias.scope !3, !noalias !0)
    $eax = COPY %5
    RET 0, $eax

...
