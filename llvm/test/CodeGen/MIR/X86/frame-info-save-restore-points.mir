# RUN: llc -march=x86-64 -run-pass none -o - %s | FileCheck %s
# This test ensures that the MIR parser parses the save and restore points in
# the machine frame info correctly.

--- |

  define i32 @foo(i32 %a, i32 %b) {
  entry:
    %tmp = alloca i32, align 4
    %tmp2 = icmp slt i32 %a, %b
    br i1 %tmp2, label %true, label %false

  true:
    store i32 %a, i32* %tmp, align 4
    %tmp4 = call i32 @doSomething(i32 0, i32* %tmp)
    br label %false

  false:
    %tmp.0 = phi i32 [ %tmp4, %true ], [ %a, %entry ]
    ret i32 %tmp.0
  }

  declare i32 @doSomething(i32, i32*)

...
---
name:            foo
tracksRegLiveness: true
liveins:
  - { reg: '%edi' }
  - { reg: '%esi' }
# CHECK: frameInfo:
# CHECK:      savePoint: '%bb.2.true'
# CHECK-NEXT: restorePoint: '%bb.2.true'
# CHECK: stack
frameInfo:
  maxAlignment:  4
  hasCalls:      true
  savePoint:     '%bb.2.true'
  restorePoint:  '%bb.2.true'
stack:
  - { id: 0, name: tmp, offset: 0, size: 4, alignment: 4 }
body: |
  bb.0:
    successors: %bb.2.true, %bb.1
    liveins: %edi, %esi

    %eax = COPY %edi
    CMP32rr %eax, killed %esi, implicit-def %eflags
    JL_1 %bb.2.true, implicit killed %eflags

  bb.1:
    successors: %bb.3.false
    liveins: %eax

    JMP_1 %bb.3.false

  bb.2.true:
    successors: %bb.3.false
    liveins: %eax

    MOV32mr %stack.0.tmp, 1, _, 0, _, killed %eax
    ADJCALLSTACKDOWN64 0, 0, implicit-def %rsp, implicit-def dead %eflags, implicit %rsp
    %rsi = LEA64r %stack.0.tmp, 1, _, 0, _
    %edi = MOV32r0 implicit-def dead %eflags
    CALL64pcrel32 @doSomething, csr_64, implicit %rsp, implicit %edi, implicit %rsi, implicit-def %rsp, implicit-def %eax
    ADJCALLSTACKUP64 0, 0, implicit-def %rsp, implicit-def dead %eflags, implicit %rsp

  bb.3.false:
    liveins: %eax

    RETQ %eax
...
