; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -frame-pointer=all -O0 -mcpu=i486 | FileCheck %s
;; magic constants are 3.999f and half of 3.999
; ModuleID = '1489.c'
target datalayout = "e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:32:64-f32:32:32-f64:32:64-v64:64:64-v128:128:128-a0:0:64"
target triple = "i686-apple-darwin8"
@.str = internal constant [13 x i8] c"%d %d %d %d\0A\00"		; <[13 x i8]*> [#uses=1]

define i32 @quux() nounwind {
; CHECK-LABEL: quux:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    pushl %ebp
; CHECK-NEXT:    movl %esp, %ebp
; CHECK-NEXT:    subl $8, %esp
; CHECK-NEXT:    movl %esp, %eax
; CHECK-NEXT:    movl $1082126238, (%eax) ## imm = 0x407FEF9E
; CHECK-NEXT:    calll _lrintf
; CHECK-NEXT:    cmpl $1, %eax
; CHECK-NEXT:    setl %cl
; CHECK-NEXT:    andb $1, %cl
; CHECK-NEXT:    movzbl %cl, %eax
; CHECK-NEXT:    addl $8, %esp
; CHECK-NEXT:    popl %ebp
; CHECK-NEXT:    retl
entry:
	%tmp1 = tail call i32 @lrintf( float 0x400FFDF3C0000000 )		; <i32> [#uses=1]
	%tmp2 = icmp slt i32 %tmp1, 1		; <i1> [#uses=1]
	%tmp23 = zext i1 %tmp2 to i32		; <i32> [#uses=1]
	ret i32 %tmp23
}

declare i32 @lrintf(float)

define i32 @foo() nounwind {
; CHECK-LABEL: foo:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    pushl %ebp
; CHECK-NEXT:    movl %esp, %ebp
; CHECK-NEXT:    subl $8, %esp
; CHECK-NEXT:    movl %esp, %eax
; CHECK-NEXT:    movl $1074789875, 4(%eax) ## imm = 0x400FFDF3
; CHECK-NEXT:    movl $-1236950581, (%eax) ## imm = 0xB645A1CB
; CHECK-NEXT:    calll _lrint
; CHECK-NEXT:    cmpl $1, %eax
; CHECK-NEXT:    setl %cl
; CHECK-NEXT:    andb $1, %cl
; CHECK-NEXT:    movzbl %cl, %eax
; CHECK-NEXT:    addl $8, %esp
; CHECK-NEXT:    popl %ebp
; CHECK-NEXT:    retl
entry:
	%tmp1 = tail call i32 @lrint( double 3.999000e+00 )		; <i32> [#uses=1]
	%tmp2 = icmp slt i32 %tmp1, 1		; <i1> [#uses=1]
	%tmp23 = zext i1 %tmp2 to i32		; <i32> [#uses=1]
	ret i32 %tmp23
}

declare i32 @lrint(double)

define i32 @bar() nounwind {
; CHECK-LABEL: bar:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    pushl %ebp
; CHECK-NEXT:    movl %esp, %ebp
; CHECK-NEXT:    subl $8, %esp
; CHECK-NEXT:    movl %esp, %eax
; CHECK-NEXT:    movl $1082126238, (%eax) ## imm = 0x407FEF9E
; CHECK-NEXT:    calll _lrintf
; CHECK-NEXT:    cmpl $1, %eax
; CHECK-NEXT:    setl %cl
; CHECK-NEXT:    andb $1, %cl
; CHECK-NEXT:    movzbl %cl, %eax
; CHECK-NEXT:    addl $8, %esp
; CHECK-NEXT:    popl %ebp
; CHECK-NEXT:    retl
entry:
	%tmp1 = tail call i32 @lrintf( float 0x400FFDF3C0000000 )		; <i32> [#uses=1]
	%tmp2 = icmp slt i32 %tmp1, 1		; <i1> [#uses=1]
	%tmp23 = zext i1 %tmp2 to i32		; <i32> [#uses=1]
	ret i32 %tmp23
}

define i32 @baz() nounwind {
; CHECK-LABEL: baz:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    pushl %ebp
; CHECK-NEXT:    movl %esp, %ebp
; CHECK-NEXT:    subl $8, %esp
; CHECK-NEXT:    movl %esp, %eax
; CHECK-NEXT:    movl $1082126238, (%eax) ## imm = 0x407FEF9E
; CHECK-NEXT:    calll _lrintf
; CHECK-NEXT:    cmpl $1, %eax
; CHECK-NEXT:    setl %cl
; CHECK-NEXT:    andb $1, %cl
; CHECK-NEXT:    movzbl %cl, %eax
; CHECK-NEXT:    addl $8, %esp
; CHECK-NEXT:    popl %ebp
; CHECK-NEXT:    retl
entry:
	%tmp1 = tail call i32 @lrintf( float 0x400FFDF3C0000000 )		; <i32> [#uses=1]
	%tmp2 = icmp slt i32 %tmp1, 1		; <i1> [#uses=1]
	%tmp23 = zext i1 %tmp2 to i32		; <i32> [#uses=1]
	ret i32 %tmp23
}

define i32 @main() nounwind {
; CHECK-LABEL: main:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    pushl %ebp
; CHECK-NEXT:    movl %esp, %ebp
; CHECK-NEXT:    pushl %edi
; CHECK-NEXT:    pushl %esi
; CHECK-NEXT:    subl $48, %esp
; CHECK-NEXT:    calll _baz
; CHECK-NEXT:    movl %eax, {{[-0-9]+}}(%e{{[sb]}}p) ## 4-byte Spill
; CHECK-NEXT:    calll _bar
; CHECK-NEXT:    movl %eax, {{[-0-9]+}}(%e{{[sb]}}p) ## 4-byte Spill
; CHECK-NEXT:    calll _foo
; CHECK-NEXT:    movl %eax, {{[-0-9]+}}(%e{{[sb]}}p) ## 4-byte Spill
; CHECK-NEXT:    calll _quux
; CHECK-NEXT:    movl %esp, %ecx
; CHECK-NEXT:    movl {{[-0-9]+}}(%e{{[sb]}}p), %edx ## 4-byte Reload
; CHECK-NEXT:    movl %edx, 16(%ecx)
; CHECK-NEXT:    movl {{[-0-9]+}}(%e{{[sb]}}p), %esi ## 4-byte Reload
; CHECK-NEXT:    movl %esi, 12(%ecx)
; CHECK-NEXT:    movl {{[-0-9]+}}(%e{{[sb]}}p), %edi ## 4-byte Reload
; CHECK-NEXT:    movl %edi, 8(%ecx)
; CHECK-NEXT:    movl %eax, 4(%ecx)
; CHECK-NEXT:    movl $_.str, (%ecx)
; CHECK-NEXT:    calll _printf
; CHECK-NEXT:    ## implicit-def: $ecx
; CHECK-NEXT:    movl %eax, {{[-0-9]+}}(%e{{[sb]}}p) ## 4-byte Spill
; CHECK-NEXT:    movl %ecx, %eax
; CHECK-NEXT:    addl $48, %esp
; CHECK-NEXT:    popl %esi
; CHECK-NEXT:    popl %edi
; CHECK-NEXT:    popl %ebp
; CHECK-NEXT:    retl
entry:
	%tmp = tail call i32 @baz( )		; <i32> [#uses=1]
	%tmp1 = tail call i32 @bar( )		; <i32> [#uses=1]
	%tmp2 = tail call i32 @foo( )		; <i32> [#uses=1]
	%tmp3 = tail call i32 @quux( )		; <i32> [#uses=1]
	%tmp5 = tail call i32 (i8*, ...) @printf( i8* getelementptr ([13 x i8], [13 x i8]* @.str, i32 0, i32 0), i32 %tmp3, i32 %tmp2, i32 %tmp1, i32 %tmp )		; <i32> [#uses=0]
	ret i32 undef
}

declare i32 @printf(i8*, ...)
