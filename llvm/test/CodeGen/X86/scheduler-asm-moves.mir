# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
# RUN: llc -run-pass=machine-scheduler -mcpu=sandybridge %s -o - | FileCheck %s

--- |
  ; ModuleID = 'crash.ll'
  source_filename = "crash.c"
  target datalayout = "e-m:e-p:32:32-p270:32:32-p271:32:32-p272:64:64-f64:32:64-f80:32-n8:16:32-S128"
  target triple = "i386-unknown-linux-gnu"

  %struct.in6_addr = type { %struct.anon }
  %struct.anon = type { i8 }
  %struct.sk_buff = type { i8 }
  %struct.ipv6hdr = type { %struct.in6_addr }

  @csum_ipv6_magic_sum = dso_local local_unnamed_addr global i32 0, align 4
  @csum_ipv6_magic_saddr = dso_local local_unnamed_addr global %struct.in6_addr zeroinitializer, align 1
  @csum_ipv6_magic_daddr = dso_local local_unnamed_addr global i32 0, align 4
  @csum_ipv6_magic_proto = dso_local local_unnamed_addr global i32 0, align 4
  @synproxy_send_tcp_ipv6_nskb = dso_local local_unnamed_addr global %struct.sk_buff* null, align 4
  @synproxy_send_tcp_ipv6_fl6 = dso_local local_unnamed_addr global %struct.in6_addr zeroinitializer, align 1

  ; Function Attrs: nounwind uwtable
  define dso_local void @synproxy_send_tcp_ipv6(i32 inreg %skb.coerce, %struct.ipv6hdr* inreg nocapture noundef readonly %niph) local_unnamed_addr #0 {
  entry:
    %0 = load i8, i8* getelementptr inbounds (%struct.in6_addr, %struct.in6_addr* @csum_ipv6_magic_saddr, i32 0, i32 0, i32 0), align 1
    %1 = load i32, i32* @csum_ipv6_magic_daddr, align 4, !tbaa !5
    %2 = load i32, i32* @csum_ipv6_magic_proto, align 4, !tbaa !5
    %3 = tail call i32 asm "", "=&r,r,r,r,r,~{dirflag},~{fpsr},~{flags}"(i8 %0, i32 %1, i32 0, i32 %2) #2, !srcloc !9
    store i32 %3, i32* @csum_ipv6_magic_sum, align 4, !tbaa !5
    %4 = load i8*, i8** bitcast (%struct.sk_buff** @synproxy_send_tcp_ipv6_nskb to i8**), align 4, !tbaa !10
    %bf.load = load i8, i8* %4, align 1
    %bf.set = or i8 %bf.load, 3
    store i8 %bf.set, i8* %4, align 1
    %5 = bitcast %struct.ipv6hdr* %niph to i8*
    %6 = load i8, i8* %5, align 1, !tbaa !12
    store i8 %6, i8* getelementptr inbounds (%struct.in6_addr, %struct.in6_addr* @synproxy_send_tcp_ipv6_fl6, i32 0, i32 0, i32 0), align 1, !tbaa !12
    %skb.coerce1.sroa.0.0.insert.ext = and i32 %skb.coerce, 255
    tail call void @fl6nthsecurity_skb_classify_flow(i32 inreg %skb.coerce1.sroa.0.0.insert.ext) #3
    ret void
  }

  declare dso_local void @fl6nthsecurity_skb_classify_flow(i32 inreg) local_unnamed_addr #1

  attributes #0 = { nounwind uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="pentium4" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
  attributes #1 = { "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="pentium4" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
  attributes #2 = { nounwind readnone }
  attributes #3 = { nounwind }

  !llvm.module.flags = !{!0, !1, !2, !3}

  !0 = !{i32 1, !"NumRegisterParameters", i32 3}
  !1 = !{i32 1, !"wchar_size", i32 4}
  !2 = !{i32 7, !"uwtable", i32 2}
  !3 = !{i32 7, !"frame-pointer", i32 2}
  !5 = !{!6, !6, i64 0}
  !6 = !{!"int", !7, i64 0}
  !7 = !{!"omnipotent char", !8, i64 0}
  !8 = !{!"Simple C/C++ TBAA"}
  !9 = !{i64 429}
  !10 = !{!11, !11, i64 0}
  !11 = !{!"any pointer", !7, i64 0}
  !12 = !{!7, !7, i64 0}

...
---
name:            synproxy_send_tcp_ipv6
alignment:       16
exposesReturnsTwice: false
legalized:       false
regBankSelected: false
selected:        false
failedISel:      false
tracksRegLiveness: true
hasWinCFI:       false
failsVerification: false
tracksDebugUserValues: false
registers:
  - { id: 0, class: gr32_abcd, preferred-register: '' }
  - { id: 1, class: gr32, preferred-register: '' }
  - { id: 2, class: gr32, preferred-register: '' }
  - { id: 3, class: gr8, preferred-register: '' }
  - { id: 4, class: gr32, preferred-register: '' }
  - { id: 5, class: gr32, preferred-register: '' }
  - { id: 6, class: gr32, preferred-register: '' }
  - { id: 7, class: gr32, preferred-register: '' }
  - { id: 8, class: gr8, preferred-register: '' }
  - { id: 9, class: gr8, preferred-register: '' }
  - { id: 10, class: gr32, preferred-register: '' }
liveins:
  - { reg: '$eax', virtual-reg: '%0' }
  - { reg: '$edx', virtual-reg: '%1' }
frameInfo:
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    1
  adjustsStack:    false
  hasCalls:        false
  stackProtector:  ''
  maxCallFrameSize: 4294967295
  cvBytesOfCalleeSavedRegisters: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
  hasTailCall:     true
  localFrameSize:  0
  savePoint:       ''
  restorePoint:    ''
fixedStack:      []
stack:           []
callSites:       []
debugValueSubstitutions: []
constants:       []
machineFunctionInfo: {}
body:             |
  bb.0.entry:
    liveins: $eax, $edx

    ; CHECK-LABEL: name: synproxy_send_tcp_ipv6
    ; CHECK: liveins: $eax, $edx
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: [[COPY:%[0-9]+]]:gr32 = COPY $edx
    ; CHECK-NEXT: [[COPY1:%[0-9]+]]:gr32_abcd = COPY $eax
    ; CHECK-NEXT: [[MOV8rm:%[0-9]+]]:gr8 = MOV8rm $noreg, 1, $noreg, @csum_ipv6_magic_saddr, $noreg :: (dereferenceable load (s8) from `i8* getelementptr inbounds (%struct.in6_addr, %struct.in6_addr* @csum_ipv6_magic_saddr, i32 0, i32 0, i32 0)`)
    ; CHECK-NEXT: [[MOV32rm:%[0-9]+]]:gr32 = MOV32rm $noreg, 1, $noreg, @csum_ipv6_magic_daddr, $noreg :: (dereferenceable load (s32) from @csum_ipv6_magic_daddr, !tbaa !4)
    ; CHECK-NEXT: [[MOV32rm1:%[0-9]+]]:gr32 = MOV32rm $noreg, 1, $noreg, @csum_ipv6_magic_proto, $noreg :: (dereferenceable load (s32) from @csum_ipv6_magic_proto, !tbaa !4)
    ; CHECK-NEXT: [[MOV32r0_:%[0-9]+]]:gr32 = MOV32r0 implicit-def dead $eflags
    ; CHECK-NEXT: INLINEASM &"", 0 /* attdialect */, 2359307 /* regdef-ec:GR32 */, def early-clobber %2, 65545 /* reguse:GR8 */, [[MOV8rm]], 2359305 /* reguse:GR32 */, [[MOV32rm]], 2359305 /* reguse:GR32 */, [[MOV32r0_]], 2359305 /* reguse:GR32 */, [[MOV32rm1]], 12 /* clobber */, implicit-def dead early-clobber $df, 12 /* clobber */, implicit-def early-clobber $fpsw, 12 /* clobber */, implicit-def dead early-clobber $eflags, !8
    ; CHECK-NEXT: MOV32mr $noreg, 1, $noreg, @csum_ipv6_magic_sum, $noreg, %2 :: (store (s32) into @csum_ipv6_magic_sum, !tbaa !4)
    ; CHECK-NEXT: [[MOV32rm2:%[0-9]+]]:gr32 = MOV32rm $noreg, 1, $noreg, @synproxy_send_tcp_ipv6_nskb, $noreg :: (dereferenceable load (s32) from `i8** bitcast (%struct.sk_buff** @synproxy_send_tcp_ipv6_nskb to i8**)`, !tbaa !9)
    ; CHECK-NEXT: OR8mi [[MOV32rm2]], 1, $noreg, 0, $noreg, 3, implicit-def dead $eflags :: (store (s8) into %ir.4), (load (s8) from %ir.4)
    ; CHECK-NEXT: [[MOV8rm1:%[0-9]+]]:gr8 = MOV8rm [[COPY]], 1, $noreg, 0, $noreg :: (load (s8) from %ir.5, !tbaa !11)
    ; CHECK-NEXT: MOV8mr $noreg, 1, $noreg, @synproxy_send_tcp_ipv6_fl6, $noreg, [[MOV8rm1]] :: (store (s8) into `i8* getelementptr inbounds (%struct.in6_addr, %struct.in6_addr* @synproxy_send_tcp_ipv6_fl6, i32 0, i32 0, i32 0)`, !tbaa !11)
    ; CHECK-NEXT: [[MOVZX32rr8_:%[0-9]+]]:gr32 = MOVZX32rr8 [[COPY1]].sub_8bit
    ; CHECK-NEXT: $eax = COPY [[MOVZX32rr8_]]
    ; CHECK-NEXT: TCRETURNdi @fl6nthsecurity_skb_classify_flow, 0, csr_32, implicit $esp, implicit $ssp, implicit $eax
    %1:gr32 = COPY $edx
    %0:gr32_abcd = COPY $eax
    %3:gr8 = MOV8rm $noreg, 1, $noreg, @csum_ipv6_magic_saddr, $noreg :: (dereferenceable load (s8) from `i8* getelementptr inbounds (%struct.in6_addr, %struct.in6_addr* @csum_ipv6_magic_saddr, i32 0, i32 0, i32 0)`)
    %4:gr32 = MOV32rm $noreg, 1, $noreg, @csum_ipv6_magic_daddr, $noreg :: (dereferenceable load (s32) from @csum_ipv6_magic_daddr, !tbaa !5)
    %6:gr32 = MOV32rm $noreg, 1, $noreg, @csum_ipv6_magic_proto, $noreg :: (dereferenceable load (s32) from @csum_ipv6_magic_proto, !tbaa !5)
    %5:gr32 = MOV32r0 implicit-def dead $eflags
    INLINEASM &"", 0 /* attdialect */, 2359307 /* regdef-ec:GR32 */, def early-clobber %2, 65545 /* reguse:GR8 */, %3, 2359305 /* reguse:GR32 */, %4, 2359305 /* reguse:GR32 */, %5, 2359305 /* reguse:GR32 */, %6, 12 /* clobber */, implicit-def dead early-clobber $df, 12 /* clobber */, implicit-def early-clobber $fpsw, 12 /* clobber */, implicit-def dead early-clobber $eflags, !9
    MOV32mr $noreg, 1, $noreg, @csum_ipv6_magic_sum, $noreg, %2 :: (store (s32) into @csum_ipv6_magic_sum, !tbaa !5)
    %7:gr32 = MOV32rm $noreg, 1, $noreg, @synproxy_send_tcp_ipv6_nskb, $noreg :: (dereferenceable load (s32) from `i8** bitcast (%struct.sk_buff** @synproxy_send_tcp_ipv6_nskb to i8**)`, !tbaa !10)
    OR8mi %7, 1, $noreg, 0, $noreg, 3, implicit-def dead $eflags :: (store (s8) into %ir.4), (load (s8) from %ir.4)
    %8:gr8 = MOV8rm %1, 1, $noreg, 0, $noreg :: (load (s8) from %ir.5, !tbaa !12)
    MOV8mr $noreg, 1, $noreg, @synproxy_send_tcp_ipv6_fl6, $noreg, %8 :: (store (s8) into `i8* getelementptr inbounds (%struct.in6_addr, %struct.in6_addr* @synproxy_send_tcp_ipv6_fl6, i32 0, i32 0, i32 0)`, !tbaa !12)
    %10:gr32 = MOVZX32rr8 %0.sub_8bit
    $eax = COPY %10
    TCRETURNdi @fl6nthsecurity_skb_classify_flow, 0, csr_32, implicit $esp, implicit $ssp, implicit $eax

...
