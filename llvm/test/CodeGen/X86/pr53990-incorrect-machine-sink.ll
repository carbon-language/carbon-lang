; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=x86_64-- < %s | FileCheck %s

declare void @clobber()

define void @test(i1 %c, i64* %p, i64* noalias %p2) nounwind {
; CHECK-LABEL: test:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    pushq %rbp
; CHECK-NEXT:    pushq %r15
; CHECK-NEXT:    pushq %r14
; CHECK-NEXT:    pushq %rbx
; CHECK-NEXT:    pushq %rax
; CHECK-NEXT:    movq %rdx, %rbx
; CHECK-NEXT:    movq %rsi, %r14
; CHECK-NEXT:    movl %edi, %r15d
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    jmpq *.LJTI0_0(,%rax,8)
; CHECK-NEXT:  .LBB0_1: # %split.3
; CHECK-NEXT:    movq (%r14), %rbp
; CHECK-NEXT:    testb $1, %r15b
; CHECK-NEXT:    je .LBB0_3
; CHECK-NEXT:  # %bb.2: # %clobber
; CHECK-NEXT:    callq clobber@PLT
; CHECK-NEXT:  .LBB0_3: # %sink
; CHECK-NEXT:    movq %rbp, (%rbx)
; CHECK-NEXT:  .LBB0_4: # %latch
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    jmpq *.LJTI0_0(,%rax,8)
entry:
  %val = load i64, i64* %p, align 8
  br label %loop

loop:
  switch i8 undef, label %unreachable [
    i8 0, label %latch
    i8 1, label %split.1
    i8 2, label %split.2
    i8 3, label %split.3
  ]

unreachable:
  unreachable

split.3:
  br i1 %c, label %clobber, label %sink

split.1:
  br label %latch

split.2:
  br label %latch

clobber:
  call void @clobber()
  br label %sink

sink:
  store i64 %val, i64* %p2, align 8
  br label %latch

latch:
  %phi = phi i64 [ 0, %sink ], [ 0, %split.2 ], [ 1, %split.1 ], [ 0, %loop ]
  %phi.live = add i64 %phi, 0
  br label %loop
}
