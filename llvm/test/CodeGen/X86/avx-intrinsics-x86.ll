; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=i686-apple-darwin -mattr=avx,aes,pclmul -show-mc-encoding | FileCheck %s --check-prefix=CHECK --check-prefix=AVX
; RUN: llc < %s -mtriple=i686-apple-darwin -mcpu=skx -show-mc-encoding | FileCheck %s --check-prefix=CHECK --check-prefix=AVX512VL

define <2 x i64> @test_x86_aesni_aesdec(<2 x i64> %a0, <2 x i64> %a1) {
; CHECK-LABEL: test_x86_aesni_aesdec:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vaesdec %xmm1, %xmm0, %xmm0 ## encoding: [0xc4,0xe2,0x79,0xde,0xc1]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <2 x i64> @llvm.x86.aesni.aesdec(<2 x i64> %a0, <2 x i64> %a1) ; <<2 x i64>> [#uses=1]
  ret <2 x i64> %res
}
declare <2 x i64> @llvm.x86.aesni.aesdec(<2 x i64>, <2 x i64>) nounwind readnone


define <2 x i64> @test_x86_aesni_aesdeclast(<2 x i64> %a0, <2 x i64> %a1) {
; CHECK-LABEL: test_x86_aesni_aesdeclast:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vaesdeclast %xmm1, %xmm0, %xmm0 ## encoding: [0xc4,0xe2,0x79,0xdf,0xc1]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <2 x i64> @llvm.x86.aesni.aesdeclast(<2 x i64> %a0, <2 x i64> %a1) ; <<2 x i64>> [#uses=1]
  ret <2 x i64> %res
}
declare <2 x i64> @llvm.x86.aesni.aesdeclast(<2 x i64>, <2 x i64>) nounwind readnone


define <2 x i64> @test_x86_aesni_aesenc(<2 x i64> %a0, <2 x i64> %a1) {
; CHECK-LABEL: test_x86_aesni_aesenc:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vaesenc %xmm1, %xmm0, %xmm0 ## encoding: [0xc4,0xe2,0x79,0xdc,0xc1]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <2 x i64> @llvm.x86.aesni.aesenc(<2 x i64> %a0, <2 x i64> %a1) ; <<2 x i64>> [#uses=1]
  ret <2 x i64> %res
}
declare <2 x i64> @llvm.x86.aesni.aesenc(<2 x i64>, <2 x i64>) nounwind readnone


define <2 x i64> @test_x86_aesni_aesenclast(<2 x i64> %a0, <2 x i64> %a1) {
; CHECK-LABEL: test_x86_aesni_aesenclast:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vaesenclast %xmm1, %xmm0, %xmm0 ## encoding: [0xc4,0xe2,0x79,0xdd,0xc1]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <2 x i64> @llvm.x86.aesni.aesenclast(<2 x i64> %a0, <2 x i64> %a1) ; <<2 x i64>> [#uses=1]
  ret <2 x i64> %res
}
declare <2 x i64> @llvm.x86.aesni.aesenclast(<2 x i64>, <2 x i64>) nounwind readnone


define <2 x i64> @test_x86_aesni_aesimc(<2 x i64> %a0) {
; CHECK-LABEL: test_x86_aesni_aesimc:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vaesimc %xmm0, %xmm0 ## encoding: [0xc4,0xe2,0x79,0xdb,0xc0]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <2 x i64> @llvm.x86.aesni.aesimc(<2 x i64> %a0) ; <<2 x i64>> [#uses=1]
  ret <2 x i64> %res
}
declare <2 x i64> @llvm.x86.aesni.aesimc(<2 x i64>) nounwind readnone


define <2 x i64> @test_x86_aesni_aeskeygenassist(<2 x i64> %a0) {
; CHECK-LABEL: test_x86_aesni_aeskeygenassist:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vaeskeygenassist $7, %xmm0, %xmm0 ## encoding: [0xc4,0xe3,0x79,0xdf,0xc0,0x07]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <2 x i64> @llvm.x86.aesni.aeskeygenassist(<2 x i64> %a0, i8 7) ; <<2 x i64>> [#uses=1]
  ret <2 x i64> %res
}
declare <2 x i64> @llvm.x86.aesni.aeskeygenassist(<2 x i64>, i8) nounwind readnone


define <2 x double> @test_x86_sse2_cmp_pd(<2 x double> %a0, <2 x double> %a1) {
; CHECK-LABEL: test_x86_sse2_cmp_pd:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vcmpordpd %xmm1, %xmm0, %xmm0 ## encoding: [0xc5,0xf9,0xc2,0xc1,0x07]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <2 x double> @llvm.x86.sse2.cmp.pd(<2 x double> %a0, <2 x double> %a1, i8 7) ; <<2 x double>> [#uses=1]
  ret <2 x double> %res
}
declare <2 x double> @llvm.x86.sse2.cmp.pd(<2 x double>, <2 x double>, i8) nounwind readnone


define <2 x double> @test_x86_sse2_cmp_sd(<2 x double> %a0, <2 x double> %a1) {
; CHECK-LABEL: test_x86_sse2_cmp_sd:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vcmpordsd %xmm1, %xmm0, %xmm0 ## encoding: [0xc5,0xfb,0xc2,0xc1,0x07]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <2 x double> @llvm.x86.sse2.cmp.sd(<2 x double> %a0, <2 x double> %a1, i8 7) ; <<2 x double>> [#uses=1]
  ret <2 x double> %res
}
declare <2 x double> @llvm.x86.sse2.cmp.sd(<2 x double>, <2 x double>, i8) nounwind readnone


define i32 @test_x86_sse2_comieq_sd(<2 x double> %a0, <2 x double> %a1) {
; AVX-LABEL: test_x86_sse2_comieq_sd:
; AVX:       ## BB#0:
; AVX-NEXT:    vcomisd %xmm1, %xmm0 ## encoding: [0xc5,0xf9,0x2f,0xc1]
; AVX-NEXT:    setnp %al ## encoding: [0x0f,0x9b,0xc0]
; AVX-NEXT:    sete %cl ## encoding: [0x0f,0x94,0xc1]
; AVX-NEXT:    andb %al, %cl ## encoding: [0x20,0xc1]
; AVX-NEXT:    movzbl %cl, %eax ## encoding: [0x0f,0xb6,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_comieq_sd:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vcomisd %xmm1, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0x2f,0xc1]
; AVX512VL-NEXT:    setnp %al ## encoding: [0x0f,0x9b,0xc0]
; AVX512VL-NEXT:    sete %cl ## encoding: [0x0f,0x94,0xc1]
; AVX512VL-NEXT:    andb %al, %cl ## encoding: [0x20,0xc1]
; AVX512VL-NEXT:    movzbl %cl, %eax ## encoding: [0x0f,0xb6,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call i32 @llvm.x86.sse2.comieq.sd(<2 x double> %a0, <2 x double> %a1) ; <i32> [#uses=1]
  ret i32 %res
}
declare i32 @llvm.x86.sse2.comieq.sd(<2 x double>, <2 x double>) nounwind readnone


define i32 @test_x86_sse2_comige_sd(<2 x double> %a0, <2 x double> %a1) {
; AVX-LABEL: test_x86_sse2_comige_sd:
; AVX:       ## BB#0:
; AVX-NEXT:    xorl %eax, %eax ## encoding: [0x31,0xc0]
; AVX-NEXT:    vcomisd %xmm1, %xmm0 ## encoding: [0xc5,0xf9,0x2f,0xc1]
; AVX-NEXT:    setae %al ## encoding: [0x0f,0x93,0xc0]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_comige_sd:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    xorl %eax, %eax ## encoding: [0x31,0xc0]
; AVX512VL-NEXT:    vcomisd %xmm1, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0x2f,0xc1]
; AVX512VL-NEXT:    setae %al ## encoding: [0x0f,0x93,0xc0]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call i32 @llvm.x86.sse2.comige.sd(<2 x double> %a0, <2 x double> %a1) ; <i32> [#uses=1]
  ret i32 %res
}
declare i32 @llvm.x86.sse2.comige.sd(<2 x double>, <2 x double>) nounwind readnone


define i32 @test_x86_sse2_comigt_sd(<2 x double> %a0, <2 x double> %a1) {
; AVX-LABEL: test_x86_sse2_comigt_sd:
; AVX:       ## BB#0:
; AVX-NEXT:    xorl %eax, %eax ## encoding: [0x31,0xc0]
; AVX-NEXT:    vcomisd %xmm1, %xmm0 ## encoding: [0xc5,0xf9,0x2f,0xc1]
; AVX-NEXT:    seta %al ## encoding: [0x0f,0x97,0xc0]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_comigt_sd:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    xorl %eax, %eax ## encoding: [0x31,0xc0]
; AVX512VL-NEXT:    vcomisd %xmm1, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0x2f,0xc1]
; AVX512VL-NEXT:    seta %al ## encoding: [0x0f,0x97,0xc0]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call i32 @llvm.x86.sse2.comigt.sd(<2 x double> %a0, <2 x double> %a1) ; <i32> [#uses=1]
  ret i32 %res
}
declare i32 @llvm.x86.sse2.comigt.sd(<2 x double>, <2 x double>) nounwind readnone


define i32 @test_x86_sse2_comile_sd(<2 x double> %a0, <2 x double> %a1) {
; AVX-LABEL: test_x86_sse2_comile_sd:
; AVX:       ## BB#0:
; AVX-NEXT:    xorl %eax, %eax ## encoding: [0x31,0xc0]
; AVX-NEXT:    vcomisd %xmm0, %xmm1 ## encoding: [0xc5,0xf9,0x2f,0xc8]
; AVX-NEXT:    setae %al ## encoding: [0x0f,0x93,0xc0]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_comile_sd:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    xorl %eax, %eax ## encoding: [0x31,0xc0]
; AVX512VL-NEXT:    vcomisd %xmm0, %xmm1 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0x2f,0xc8]
; AVX512VL-NEXT:    setae %al ## encoding: [0x0f,0x93,0xc0]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call i32 @llvm.x86.sse2.comile.sd(<2 x double> %a0, <2 x double> %a1) ; <i32> [#uses=1]
  ret i32 %res
}
declare i32 @llvm.x86.sse2.comile.sd(<2 x double>, <2 x double>) nounwind readnone


define i32 @test_x86_sse2_comilt_sd(<2 x double> %a0, <2 x double> %a1) {
; AVX-LABEL: test_x86_sse2_comilt_sd:
; AVX:       ## BB#0:
; AVX-NEXT:    xorl %eax, %eax ## encoding: [0x31,0xc0]
; AVX-NEXT:    vcomisd %xmm0, %xmm1 ## encoding: [0xc5,0xf9,0x2f,0xc8]
; AVX-NEXT:    seta %al ## encoding: [0x0f,0x97,0xc0]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_comilt_sd:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    xorl %eax, %eax ## encoding: [0x31,0xc0]
; AVX512VL-NEXT:    vcomisd %xmm0, %xmm1 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0x2f,0xc8]
; AVX512VL-NEXT:    seta %al ## encoding: [0x0f,0x97,0xc0]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call i32 @llvm.x86.sse2.comilt.sd(<2 x double> %a0, <2 x double> %a1) ; <i32> [#uses=1]
  ret i32 %res
}
declare i32 @llvm.x86.sse2.comilt.sd(<2 x double>, <2 x double>) nounwind readnone


define i32 @test_x86_sse2_comineq_sd(<2 x double> %a0, <2 x double> %a1) {
; AVX-LABEL: test_x86_sse2_comineq_sd:
; AVX:       ## BB#0:
; AVX-NEXT:    vcomisd %xmm1, %xmm0 ## encoding: [0xc5,0xf9,0x2f,0xc1]
; AVX-NEXT:    setp %al ## encoding: [0x0f,0x9a,0xc0]
; AVX-NEXT:    setne %cl ## encoding: [0x0f,0x95,0xc1]
; AVX-NEXT:    orb %al, %cl ## encoding: [0x08,0xc1]
; AVX-NEXT:    movzbl %cl, %eax ## encoding: [0x0f,0xb6,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_comineq_sd:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vcomisd %xmm1, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0x2f,0xc1]
; AVX512VL-NEXT:    setp %al ## encoding: [0x0f,0x9a,0xc0]
; AVX512VL-NEXT:    setne %cl ## encoding: [0x0f,0x95,0xc1]
; AVX512VL-NEXT:    orb %al, %cl ## encoding: [0x08,0xc1]
; AVX512VL-NEXT:    movzbl %cl, %eax ## encoding: [0x0f,0xb6,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call i32 @llvm.x86.sse2.comineq.sd(<2 x double> %a0, <2 x double> %a1) ; <i32> [#uses=1]
  ret i32 %res
}
declare i32 @llvm.x86.sse2.comineq.sd(<2 x double>, <2 x double>) nounwind readnone


define <4 x float> @test_x86_sse2_cvtdq2ps(<4 x i32> %a0) {
; AVX-LABEL: test_x86_sse2_cvtdq2ps:
; AVX:       ## BB#0:
; AVX-NEXT:    vcvtdq2ps %xmm0, %xmm0 ## encoding: [0xc5,0xf8,0x5b,0xc0]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_cvtdq2ps:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vcvtdq2ps %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf8,0x5b,0xc0]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <4 x float> @llvm.x86.sse2.cvtdq2ps(<4 x i32> %a0) ; <<4 x float>> [#uses=1]
  ret <4 x float> %res
}
declare <4 x float> @llvm.x86.sse2.cvtdq2ps(<4 x i32>) nounwind readnone


define <4 x i32> @test_x86_sse2_cvtpd2dq(<2 x double> %a0) {
; AVX-LABEL: test_x86_sse2_cvtpd2dq:
; AVX:       ## BB#0:
; AVX-NEXT:    vcvtpd2dq %xmm0, %xmm0 ## encoding: [0xc5,0xfb,0xe6,0xc0]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_cvtpd2dq:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vcvtpd2dq %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xfb,0xe6,0xc0]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <4 x i32> @llvm.x86.sse2.cvtpd2dq(<2 x double> %a0) ; <<4 x i32>> [#uses=1]
  ret <4 x i32> %res
}
declare <4 x i32> @llvm.x86.sse2.cvtpd2dq(<2 x double>) nounwind readnone


define <4 x float> @test_x86_sse2_cvtpd2ps(<2 x double> %a0) {
; AVX-LABEL: test_x86_sse2_cvtpd2ps:
; AVX:       ## BB#0:
; AVX-NEXT:    vcvtpd2ps %xmm0, %xmm0 ## encoding: [0xc5,0xf9,0x5a,0xc0]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_cvtpd2ps:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vcvtpd2ps %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0x5a,0xc0]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <4 x float> @llvm.x86.sse2.cvtpd2ps(<2 x double> %a0) ; <<4 x float>> [#uses=1]
  ret <4 x float> %res
}
declare <4 x float> @llvm.x86.sse2.cvtpd2ps(<2 x double>) nounwind readnone


define <4 x i32> @test_x86_sse2_cvtps2dq(<4 x float> %a0) {
; CHECK-LABEL: test_x86_sse2_cvtps2dq:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vcvtps2dq %xmm0, %xmm0 ## encoding: [0xc5,0xf9,0x5b,0xc0]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <4 x i32> @llvm.x86.sse2.cvtps2dq(<4 x float> %a0) ; <<4 x i32>> [#uses=1]
  ret <4 x i32> %res
}
declare <4 x i32> @llvm.x86.sse2.cvtps2dq(<4 x float>) nounwind readnone


define i32 @test_x86_sse2_cvtsd2si(<2 x double> %a0) {
; AVX-LABEL: test_x86_sse2_cvtsd2si:
; AVX:       ## BB#0:
; AVX-NEXT:    vcvtsd2si %xmm0, %eax ## encoding: [0xc5,0xfb,0x2d,0xc0]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_cvtsd2si:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vcvtsd2si %xmm0, %eax ## EVEX TO VEX Compression encoding: [0xc5,0xfb,0x2d,0xc0]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call i32 @llvm.x86.sse2.cvtsd2si(<2 x double> %a0) ; <i32> [#uses=1]
  ret i32 %res
}
declare i32 @llvm.x86.sse2.cvtsd2si(<2 x double>) nounwind readnone


define <4 x float> @test_x86_sse2_cvtsd2ss(<4 x float> %a0, <2 x double> %a1) {
; CHECK-LABEL: test_x86_sse2_cvtsd2ss:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vcvtsd2ss %xmm1, %xmm0, %xmm0 ## encoding: [0xc5,0xfb,0x5a,0xc1]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <4 x float> @llvm.x86.sse2.cvtsd2ss(<4 x float> %a0, <2 x double> %a1) ; <<4 x float>> [#uses=1]
  ret <4 x float> %res
}
declare <4 x float> @llvm.x86.sse2.cvtsd2ss(<4 x float>, <2 x double>) nounwind readnone


define <2 x double> @test_x86_sse2_cvtsi2sd(<2 x double> %a0, i32 %a1) {
; AVX-LABEL: test_x86_sse2_cvtsi2sd:
; AVX:       ## BB#0:
; AVX-NEXT:    vcvtsi2sdl {{[0-9]+}}(%esp), %xmm0, %xmm0 ## encoding: [0xc5,0xfb,0x2a,0x44,0x24,0x04]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_cvtsi2sd:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vcvtsi2sdl {{[0-9]+}}(%esp), %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xfb,0x2a,0x44,0x24,0x04]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <2 x double> @llvm.x86.sse2.cvtsi2sd(<2 x double> %a0, i32 %a1) ; <<2 x double>> [#uses=1]
  ret <2 x double> %res
}
declare <2 x double> @llvm.x86.sse2.cvtsi2sd(<2 x double>, i32) nounwind readnone


define <2 x double> @test_x86_sse2_cvtss2sd(<2 x double> %a0, <4 x float> %a1) {
; CHECK-LABEL: test_x86_sse2_cvtss2sd:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vcvtss2sd %xmm1, %xmm0, %xmm0 ## encoding: [0xc5,0xfa,0x5a,0xc1]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <2 x double> @llvm.x86.sse2.cvtss2sd(<2 x double> %a0, <4 x float> %a1) ; <<2 x double>> [#uses=1]
  ret <2 x double> %res
}
declare <2 x double> @llvm.x86.sse2.cvtss2sd(<2 x double>, <4 x float>) nounwind readnone


define <4 x i32> @test_x86_sse2_cvttpd2dq(<2 x double> %a0) {
; AVX-LABEL: test_x86_sse2_cvttpd2dq:
; AVX:       ## BB#0:
; AVX-NEXT:    vcvttpd2dq %xmm0, %xmm0 ## encoding: [0xc5,0xf9,0xe6,0xc0]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_cvttpd2dq:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vcvttpd2dq %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0xe6,0xc0]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <4 x i32> @llvm.x86.sse2.cvttpd2dq(<2 x double> %a0) ; <<4 x i32>> [#uses=1]
  ret <4 x i32> %res
}
declare <4 x i32> @llvm.x86.sse2.cvttpd2dq(<2 x double>) nounwind readnone


define <4 x i32> @test_x86_sse2_cvttps2dq(<4 x float> %a0) {
; AVX-LABEL: test_x86_sse2_cvttps2dq:
; AVX:       ## BB#0:
; AVX-NEXT:    vcvttps2dq %xmm0, %xmm0 ## encoding: [0xc5,0xfa,0x5b,0xc0]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_cvttps2dq:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vcvttps2dq %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xfa,0x5b,0xc0]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <4 x i32> @llvm.x86.sse2.cvttps2dq(<4 x float> %a0) ; <<4 x i32>> [#uses=1]
  ret <4 x i32> %res
}
declare <4 x i32> @llvm.x86.sse2.cvttps2dq(<4 x float>) nounwind readnone


define i32 @test_x86_sse2_cvttsd2si(<2 x double> %a0) {
; AVX-LABEL: test_x86_sse2_cvttsd2si:
; AVX:       ## BB#0:
; AVX-NEXT:    vcvttsd2si %xmm0, %eax ## encoding: [0xc5,0xfb,0x2c,0xc0]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_cvttsd2si:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vcvttsd2si %xmm0, %eax ## EVEX TO VEX Compression encoding: [0xc5,0xfb,0x2c,0xc0]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call i32 @llvm.x86.sse2.cvttsd2si(<2 x double> %a0) ; <i32> [#uses=1]
  ret i32 %res
}
declare i32 @llvm.x86.sse2.cvttsd2si(<2 x double>) nounwind readnone



define <2 x double> @test_x86_sse2_max_pd(<2 x double> %a0, <2 x double> %a1) {
; AVX-LABEL: test_x86_sse2_max_pd:
; AVX:       ## BB#0:
; AVX-NEXT:    vmaxpd %xmm1, %xmm0, %xmm0 ## encoding: [0xc5,0xf9,0x5f,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_max_pd:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vmaxpd %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0x5f,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <2 x double> @llvm.x86.sse2.max.pd(<2 x double> %a0, <2 x double> %a1) ; <<2 x double>> [#uses=1]
  ret <2 x double> %res
}
declare <2 x double> @llvm.x86.sse2.max.pd(<2 x double>, <2 x double>) nounwind readnone


define <2 x double> @test_x86_sse2_max_sd(<2 x double> %a0, <2 x double> %a1) {
; CHECK-LABEL: test_x86_sse2_max_sd:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vmaxsd %xmm1, %xmm0, %xmm0 ## encoding: [0xc5,0xfb,0x5f,0xc1]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <2 x double> @llvm.x86.sse2.max.sd(<2 x double> %a0, <2 x double> %a1) ; <<2 x double>> [#uses=1]
  ret <2 x double> %res
}
declare <2 x double> @llvm.x86.sse2.max.sd(<2 x double>, <2 x double>) nounwind readnone


define <2 x double> @test_x86_sse2_min_pd(<2 x double> %a0, <2 x double> %a1) {
; AVX-LABEL: test_x86_sse2_min_pd:
; AVX:       ## BB#0:
; AVX-NEXT:    vminpd %xmm1, %xmm0, %xmm0 ## encoding: [0xc5,0xf9,0x5d,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_min_pd:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vminpd %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0x5d,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <2 x double> @llvm.x86.sse2.min.pd(<2 x double> %a0, <2 x double> %a1) ; <<2 x double>> [#uses=1]
  ret <2 x double> %res
}
declare <2 x double> @llvm.x86.sse2.min.pd(<2 x double>, <2 x double>) nounwind readnone


define <2 x double> @test_x86_sse2_min_sd(<2 x double> %a0, <2 x double> %a1) {
; CHECK-LABEL: test_x86_sse2_min_sd:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vminsd %xmm1, %xmm0, %xmm0 ## encoding: [0xc5,0xfb,0x5d,0xc1]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <2 x double> @llvm.x86.sse2.min.sd(<2 x double> %a0, <2 x double> %a1) ; <<2 x double>> [#uses=1]
  ret <2 x double> %res
}
declare <2 x double> @llvm.x86.sse2.min.sd(<2 x double>, <2 x double>) nounwind readnone


define i32 @test_x86_sse2_movmsk_pd(<2 x double> %a0) {
; CHECK-LABEL: test_x86_sse2_movmsk_pd:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vmovmskpd %xmm0, %eax ## encoding: [0xc5,0xf9,0x50,0xc0]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call i32 @llvm.x86.sse2.movmsk.pd(<2 x double> %a0) ; <i32> [#uses=1]
  ret i32 %res
}
declare i32 @llvm.x86.sse2.movmsk.pd(<2 x double>) nounwind readnone




define <8 x i16> @test_x86_sse2_packssdw_128(<4 x i32> %a0, <4 x i32> %a1) {
; AVX-LABEL: test_x86_sse2_packssdw_128:
; AVX:       ## BB#0:
; AVX-NEXT:    vpackssdw %xmm1, %xmm0, %xmm0 ## encoding: [0xc5,0xf9,0x6b,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_packssdw_128:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpackssdw %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0x6b,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <8 x i16> @llvm.x86.sse2.packssdw.128(<4 x i32> %a0, <4 x i32> %a1) ; <<8 x i16>> [#uses=1]
  ret <8 x i16> %res
}
declare <8 x i16> @llvm.x86.sse2.packssdw.128(<4 x i32>, <4 x i32>) nounwind readnone


define <16 x i8> @test_x86_sse2_packsswb_128(<8 x i16> %a0, <8 x i16> %a1) {
; AVX-LABEL: test_x86_sse2_packsswb_128:
; AVX:       ## BB#0:
; AVX-NEXT:    vpacksswb %xmm1, %xmm0, %xmm0 ## encoding: [0xc5,0xf9,0x63,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_packsswb_128:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpacksswb %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0x63,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <16 x i8> @llvm.x86.sse2.packsswb.128(<8 x i16> %a0, <8 x i16> %a1) ; <<16 x i8>> [#uses=1]
  ret <16 x i8> %res
}
declare <16 x i8> @llvm.x86.sse2.packsswb.128(<8 x i16>, <8 x i16>) nounwind readnone


define <16 x i8> @test_x86_sse2_packuswb_128(<8 x i16> %a0, <8 x i16> %a1) {
; AVX-LABEL: test_x86_sse2_packuswb_128:
; AVX:       ## BB#0:
; AVX-NEXT:    vpackuswb %xmm1, %xmm0, %xmm0 ## encoding: [0xc5,0xf9,0x67,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_packuswb_128:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpackuswb %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0x67,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <16 x i8> @llvm.x86.sse2.packuswb.128(<8 x i16> %a0, <8 x i16> %a1) ; <<16 x i8>> [#uses=1]
  ret <16 x i8> %res
}
declare <16 x i8> @llvm.x86.sse2.packuswb.128(<8 x i16>, <8 x i16>) nounwind readnone


define <16 x i8> @test_x86_sse2_padds_b(<16 x i8> %a0, <16 x i8> %a1) {
; AVX-LABEL: test_x86_sse2_padds_b:
; AVX:       ## BB#0:
; AVX-NEXT:    vpaddsb %xmm1, %xmm0, %xmm0 ## encoding: [0xc5,0xf9,0xec,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_padds_b:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpaddsb %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0xec,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <16 x i8> @llvm.x86.sse2.padds.b(<16 x i8> %a0, <16 x i8> %a1) ; <<16 x i8>> [#uses=1]
  ret <16 x i8> %res
}
declare <16 x i8> @llvm.x86.sse2.padds.b(<16 x i8>, <16 x i8>) nounwind readnone


define <8 x i16> @test_x86_sse2_padds_w(<8 x i16> %a0, <8 x i16> %a1) {
; AVX-LABEL: test_x86_sse2_padds_w:
; AVX:       ## BB#0:
; AVX-NEXT:    vpaddsw %xmm1, %xmm0, %xmm0 ## encoding: [0xc5,0xf9,0xed,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_padds_w:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpaddsw %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0xed,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <8 x i16> @llvm.x86.sse2.padds.w(<8 x i16> %a0, <8 x i16> %a1) ; <<8 x i16>> [#uses=1]
  ret <8 x i16> %res
}
declare <8 x i16> @llvm.x86.sse2.padds.w(<8 x i16>, <8 x i16>) nounwind readnone


define <16 x i8> @test_x86_sse2_paddus_b(<16 x i8> %a0, <16 x i8> %a1) {
; AVX-LABEL: test_x86_sse2_paddus_b:
; AVX:       ## BB#0:
; AVX-NEXT:    vpaddusb %xmm1, %xmm0, %xmm0 ## encoding: [0xc5,0xf9,0xdc,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_paddus_b:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpaddusb %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0xdc,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %a0, <16 x i8> %a1) ; <<16 x i8>> [#uses=1]
  ret <16 x i8> %res
}
declare <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8>, <16 x i8>) nounwind readnone


define <8 x i16> @test_x86_sse2_paddus_w(<8 x i16> %a0, <8 x i16> %a1) {
; AVX-LABEL: test_x86_sse2_paddus_w:
; AVX:       ## BB#0:
; AVX-NEXT:    vpaddusw %xmm1, %xmm0, %xmm0 ## encoding: [0xc5,0xf9,0xdd,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_paddus_w:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpaddusw %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0xdd,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <8 x i16> @llvm.x86.sse2.paddus.w(<8 x i16> %a0, <8 x i16> %a1) ; <<8 x i16>> [#uses=1]
  ret <8 x i16> %res
}
declare <8 x i16> @llvm.x86.sse2.paddus.w(<8 x i16>, <8 x i16>) nounwind readnone


define <16 x i8> @test_x86_sse2_pavg_b(<16 x i8> %a0, <16 x i8> %a1) {
; AVX-LABEL: test_x86_sse2_pavg_b:
; AVX:       ## BB#0:
; AVX-NEXT:    vpavgb %xmm1, %xmm0, %xmm0 ## encoding: [0xc5,0xf9,0xe0,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_pavg_b:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpavgb %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0xe0,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <16 x i8> @llvm.x86.sse2.pavg.b(<16 x i8> %a0, <16 x i8> %a1) ; <<16 x i8>> [#uses=1]
  ret <16 x i8> %res
}
declare <16 x i8> @llvm.x86.sse2.pavg.b(<16 x i8>, <16 x i8>) nounwind readnone


define <8 x i16> @test_x86_sse2_pavg_w(<8 x i16> %a0, <8 x i16> %a1) {
; AVX-LABEL: test_x86_sse2_pavg_w:
; AVX:       ## BB#0:
; AVX-NEXT:    vpavgw %xmm1, %xmm0, %xmm0 ## encoding: [0xc5,0xf9,0xe3,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_pavg_w:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpavgw %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0xe3,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <8 x i16> @llvm.x86.sse2.pavg.w(<8 x i16> %a0, <8 x i16> %a1) ; <<8 x i16>> [#uses=1]
  ret <8 x i16> %res
}
declare <8 x i16> @llvm.x86.sse2.pavg.w(<8 x i16>, <8 x i16>) nounwind readnone


define <4 x i32> @test_x86_sse2_pmadd_wd(<8 x i16> %a0, <8 x i16> %a1) {
; AVX-LABEL: test_x86_sse2_pmadd_wd:
; AVX:       ## BB#0:
; AVX-NEXT:    vpmaddwd %xmm1, %xmm0, %xmm0 ## encoding: [0xc5,0xf9,0xf5,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_pmadd_wd:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpmaddwd %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0xf5,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <4 x i32> @llvm.x86.sse2.pmadd.wd(<8 x i16> %a0, <8 x i16> %a1) ; <<4 x i32>> [#uses=1]
  ret <4 x i32> %res
}
declare <4 x i32> @llvm.x86.sse2.pmadd.wd(<8 x i16>, <8 x i16>) nounwind readnone


define <8 x i16> @test_x86_sse2_pmaxs_w(<8 x i16> %a0, <8 x i16> %a1) {
; AVX-LABEL: test_x86_sse2_pmaxs_w:
; AVX:       ## BB#0:
; AVX-NEXT:    vpmaxsw %xmm1, %xmm0, %xmm0 ## encoding: [0xc5,0xf9,0xee,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_pmaxs_w:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpmaxsw %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0xee,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <8 x i16> @llvm.x86.sse2.pmaxs.w(<8 x i16> %a0, <8 x i16> %a1) ; <<8 x i16>> [#uses=1]
  ret <8 x i16> %res
}
declare <8 x i16> @llvm.x86.sse2.pmaxs.w(<8 x i16>, <8 x i16>) nounwind readnone


define <16 x i8> @test_x86_sse2_pmaxu_b(<16 x i8> %a0, <16 x i8> %a1) {
; AVX-LABEL: test_x86_sse2_pmaxu_b:
; AVX:       ## BB#0:
; AVX-NEXT:    vpmaxub %xmm1, %xmm0, %xmm0 ## encoding: [0xc5,0xf9,0xde,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_pmaxu_b:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpmaxub %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0xde,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <16 x i8> @llvm.x86.sse2.pmaxu.b(<16 x i8> %a0, <16 x i8> %a1) ; <<16 x i8>> [#uses=1]
  ret <16 x i8> %res
}
declare <16 x i8> @llvm.x86.sse2.pmaxu.b(<16 x i8>, <16 x i8>) nounwind readnone


define <8 x i16> @test_x86_sse2_pmins_w(<8 x i16> %a0, <8 x i16> %a1) {
; AVX-LABEL: test_x86_sse2_pmins_w:
; AVX:       ## BB#0:
; AVX-NEXT:    vpminsw %xmm1, %xmm0, %xmm0 ## encoding: [0xc5,0xf9,0xea,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_pmins_w:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpminsw %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0xea,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <8 x i16> @llvm.x86.sse2.pmins.w(<8 x i16> %a0, <8 x i16> %a1) ; <<8 x i16>> [#uses=1]
  ret <8 x i16> %res
}
declare <8 x i16> @llvm.x86.sse2.pmins.w(<8 x i16>, <8 x i16>) nounwind readnone


define <16 x i8> @test_x86_sse2_pminu_b(<16 x i8> %a0, <16 x i8> %a1) {
; AVX-LABEL: test_x86_sse2_pminu_b:
; AVX:       ## BB#0:
; AVX-NEXT:    vpminub %xmm1, %xmm0, %xmm0 ## encoding: [0xc5,0xf9,0xda,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_pminu_b:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpminub %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0xda,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <16 x i8> @llvm.x86.sse2.pminu.b(<16 x i8> %a0, <16 x i8> %a1) ; <<16 x i8>> [#uses=1]
  ret <16 x i8> %res
}
declare <16 x i8> @llvm.x86.sse2.pminu.b(<16 x i8>, <16 x i8>) nounwind readnone


define i32 @test_x86_sse2_pmovmskb_128(<16 x i8> %a0) {
; CHECK-LABEL: test_x86_sse2_pmovmskb_128:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vpmovmskb %xmm0, %eax ## encoding: [0xc5,0xf9,0xd7,0xc0]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call i32 @llvm.x86.sse2.pmovmskb.128(<16 x i8> %a0) ; <i32> [#uses=1]
  ret i32 %res
}
declare i32 @llvm.x86.sse2.pmovmskb.128(<16 x i8>) nounwind readnone


define <8 x i16> @test_x86_sse2_pmulh_w(<8 x i16> %a0, <8 x i16> %a1) {
; AVX-LABEL: test_x86_sse2_pmulh_w:
; AVX:       ## BB#0:
; AVX-NEXT:    vpmulhw %xmm1, %xmm0, %xmm0 ## encoding: [0xc5,0xf9,0xe5,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_pmulh_w:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpmulhw %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0xe5,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <8 x i16> @llvm.x86.sse2.pmulh.w(<8 x i16> %a0, <8 x i16> %a1) ; <<8 x i16>> [#uses=1]
  ret <8 x i16> %res
}
declare <8 x i16> @llvm.x86.sse2.pmulh.w(<8 x i16>, <8 x i16>) nounwind readnone


define <8 x i16> @test_x86_sse2_pmulhu_w(<8 x i16> %a0, <8 x i16> %a1) {
; AVX-LABEL: test_x86_sse2_pmulhu_w:
; AVX:       ## BB#0:
; AVX-NEXT:    vpmulhuw %xmm1, %xmm0, %xmm0 ## encoding: [0xc5,0xf9,0xe4,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_pmulhu_w:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpmulhuw %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0xe4,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <8 x i16> @llvm.x86.sse2.pmulhu.w(<8 x i16> %a0, <8 x i16> %a1) ; <<8 x i16>> [#uses=1]
  ret <8 x i16> %res
}
declare <8 x i16> @llvm.x86.sse2.pmulhu.w(<8 x i16>, <8 x i16>) nounwind readnone


define <2 x i64> @test_x86_sse2_pmulu_dq(<4 x i32> %a0, <4 x i32> %a1) {
; AVX-LABEL: test_x86_sse2_pmulu_dq:
; AVX:       ## BB#0:
; AVX-NEXT:    vpmuludq %xmm1, %xmm0, %xmm0 ## encoding: [0xc5,0xf9,0xf4,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_pmulu_dq:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpmuludq %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0xf4,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <2 x i64> @llvm.x86.sse2.pmulu.dq(<4 x i32> %a0, <4 x i32> %a1) ; <<2 x i64>> [#uses=1]
  ret <2 x i64> %res
}
declare <2 x i64> @llvm.x86.sse2.pmulu.dq(<4 x i32>, <4 x i32>) nounwind readnone


define <2 x i64> @test_x86_sse2_psad_bw(<16 x i8> %a0, <16 x i8> %a1) {
; AVX-LABEL: test_x86_sse2_psad_bw:
; AVX:       ## BB#0:
; AVX-NEXT:    vpsadbw %xmm1, %xmm0, %xmm0 ## encoding: [0xc5,0xf9,0xf6,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_psad_bw:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpsadbw %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0xf6,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <2 x i64> @llvm.x86.sse2.psad.bw(<16 x i8> %a0, <16 x i8> %a1) ; <<2 x i64>> [#uses=1]
  ret <2 x i64> %res
}
declare <2 x i64> @llvm.x86.sse2.psad.bw(<16 x i8>, <16 x i8>) nounwind readnone


define <4 x i32> @test_x86_sse2_psll_d(<4 x i32> %a0, <4 x i32> %a1) {
; AVX-LABEL: test_x86_sse2_psll_d:
; AVX:       ## BB#0:
; AVX-NEXT:    vpslld %xmm1, %xmm0, %xmm0 ## encoding: [0xc5,0xf9,0xf2,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_psll_d:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpslld %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0xf2,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <4 x i32> @llvm.x86.sse2.psll.d(<4 x i32> %a0, <4 x i32> %a1) ; <<4 x i32>> [#uses=1]
  ret <4 x i32> %res
}
declare <4 x i32> @llvm.x86.sse2.psll.d(<4 x i32>, <4 x i32>) nounwind readnone


define <2 x i64> @test_x86_sse2_psll_q(<2 x i64> %a0, <2 x i64> %a1) {
; AVX-LABEL: test_x86_sse2_psll_q:
; AVX:       ## BB#0:
; AVX-NEXT:    vpsllq %xmm1, %xmm0, %xmm0 ## encoding: [0xc5,0xf9,0xf3,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_psll_q:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpsllq %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0xf3,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <2 x i64> @llvm.x86.sse2.psll.q(<2 x i64> %a0, <2 x i64> %a1) ; <<2 x i64>> [#uses=1]
  ret <2 x i64> %res
}
declare <2 x i64> @llvm.x86.sse2.psll.q(<2 x i64>, <2 x i64>) nounwind readnone


define <8 x i16> @test_x86_sse2_psll_w(<8 x i16> %a0, <8 x i16> %a1) {
; AVX-LABEL: test_x86_sse2_psll_w:
; AVX:       ## BB#0:
; AVX-NEXT:    vpsllw %xmm1, %xmm0, %xmm0 ## encoding: [0xc5,0xf9,0xf1,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_psll_w:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpsllw %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0xf1,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <8 x i16> @llvm.x86.sse2.psll.w(<8 x i16> %a0, <8 x i16> %a1) ; <<8 x i16>> [#uses=1]
  ret <8 x i16> %res
}
declare <8 x i16> @llvm.x86.sse2.psll.w(<8 x i16>, <8 x i16>) nounwind readnone


define <4 x i32> @test_x86_sse2_pslli_d(<4 x i32> %a0) {
; AVX-LABEL: test_x86_sse2_pslli_d:
; AVX:       ## BB#0:
; AVX-NEXT:    vpslld $7, %xmm0, %xmm0 ## encoding: [0xc5,0xf9,0x72,0xf0,0x07]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_pslli_d:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpslld $7, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0x72,0xf0,0x07]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <4 x i32> @llvm.x86.sse2.pslli.d(<4 x i32> %a0, i32 7) ; <<4 x i32>> [#uses=1]
  ret <4 x i32> %res
}
declare <4 x i32> @llvm.x86.sse2.pslli.d(<4 x i32>, i32) nounwind readnone


define <2 x i64> @test_x86_sse2_pslli_q(<2 x i64> %a0) {
; AVX-LABEL: test_x86_sse2_pslli_q:
; AVX:       ## BB#0:
; AVX-NEXT:    vpsllq $7, %xmm0, %xmm0 ## encoding: [0xc5,0xf9,0x73,0xf0,0x07]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_pslli_q:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpsllq $7, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0x73,0xf0,0x07]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <2 x i64> @llvm.x86.sse2.pslli.q(<2 x i64> %a0, i32 7) ; <<2 x i64>> [#uses=1]
  ret <2 x i64> %res
}
declare <2 x i64> @llvm.x86.sse2.pslli.q(<2 x i64>, i32) nounwind readnone


define <8 x i16> @test_x86_sse2_pslli_w(<8 x i16> %a0) {
; AVX-LABEL: test_x86_sse2_pslli_w:
; AVX:       ## BB#0:
; AVX-NEXT:    vpsllw $7, %xmm0, %xmm0 ## encoding: [0xc5,0xf9,0x71,0xf0,0x07]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_pslli_w:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpsllw $7, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0x71,0xf0,0x07]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <8 x i16> @llvm.x86.sse2.pslli.w(<8 x i16> %a0, i32 7) ; <<8 x i16>> [#uses=1]
  ret <8 x i16> %res
}
declare <8 x i16> @llvm.x86.sse2.pslli.w(<8 x i16>, i32) nounwind readnone


define <4 x i32> @test_x86_sse2_psra_d(<4 x i32> %a0, <4 x i32> %a1) {
; AVX-LABEL: test_x86_sse2_psra_d:
; AVX:       ## BB#0:
; AVX-NEXT:    vpsrad %xmm1, %xmm0, %xmm0 ## encoding: [0xc5,0xf9,0xe2,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_psra_d:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpsrad %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0xe2,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <4 x i32> @llvm.x86.sse2.psra.d(<4 x i32> %a0, <4 x i32> %a1) ; <<4 x i32>> [#uses=1]
  ret <4 x i32> %res
}
declare <4 x i32> @llvm.x86.sse2.psra.d(<4 x i32>, <4 x i32>) nounwind readnone


define <8 x i16> @test_x86_sse2_psra_w(<8 x i16> %a0, <8 x i16> %a1) {
; AVX-LABEL: test_x86_sse2_psra_w:
; AVX:       ## BB#0:
; AVX-NEXT:    vpsraw %xmm1, %xmm0, %xmm0 ## encoding: [0xc5,0xf9,0xe1,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_psra_w:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpsraw %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0xe1,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <8 x i16> @llvm.x86.sse2.psra.w(<8 x i16> %a0, <8 x i16> %a1) ; <<8 x i16>> [#uses=1]
  ret <8 x i16> %res
}
declare <8 x i16> @llvm.x86.sse2.psra.w(<8 x i16>, <8 x i16>) nounwind readnone


define <4 x i32> @test_x86_sse2_psrai_d(<4 x i32> %a0) {
; AVX-LABEL: test_x86_sse2_psrai_d:
; AVX:       ## BB#0:
; AVX-NEXT:    vpsrad $7, %xmm0, %xmm0 ## encoding: [0xc5,0xf9,0x72,0xe0,0x07]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_psrai_d:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpsrad $7, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0x72,0xe0,0x07]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <4 x i32> @llvm.x86.sse2.psrai.d(<4 x i32> %a0, i32 7) ; <<4 x i32>> [#uses=1]
  ret <4 x i32> %res
}
declare <4 x i32> @llvm.x86.sse2.psrai.d(<4 x i32>, i32) nounwind readnone


define <8 x i16> @test_x86_sse2_psrai_w(<8 x i16> %a0) {
; AVX-LABEL: test_x86_sse2_psrai_w:
; AVX:       ## BB#0:
; AVX-NEXT:    vpsraw $7, %xmm0, %xmm0 ## encoding: [0xc5,0xf9,0x71,0xe0,0x07]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_psrai_w:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpsraw $7, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0x71,0xe0,0x07]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <8 x i16> @llvm.x86.sse2.psrai.w(<8 x i16> %a0, i32 7) ; <<8 x i16>> [#uses=1]
  ret <8 x i16> %res
}
declare <8 x i16> @llvm.x86.sse2.psrai.w(<8 x i16>, i32) nounwind readnone


define <4 x i32> @test_x86_sse2_psrl_d(<4 x i32> %a0, <4 x i32> %a1) {
; AVX-LABEL: test_x86_sse2_psrl_d:
; AVX:       ## BB#0:
; AVX-NEXT:    vpsrld %xmm1, %xmm0, %xmm0 ## encoding: [0xc5,0xf9,0xd2,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_psrl_d:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpsrld %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0xd2,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <4 x i32> @llvm.x86.sse2.psrl.d(<4 x i32> %a0, <4 x i32> %a1) ; <<4 x i32>> [#uses=1]
  ret <4 x i32> %res
}
declare <4 x i32> @llvm.x86.sse2.psrl.d(<4 x i32>, <4 x i32>) nounwind readnone


define <2 x i64> @test_x86_sse2_psrl_q(<2 x i64> %a0, <2 x i64> %a1) {
; AVX-LABEL: test_x86_sse2_psrl_q:
; AVX:       ## BB#0:
; AVX-NEXT:    vpsrlq %xmm1, %xmm0, %xmm0 ## encoding: [0xc5,0xf9,0xd3,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_psrl_q:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpsrlq %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0xd3,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <2 x i64> @llvm.x86.sse2.psrl.q(<2 x i64> %a0, <2 x i64> %a1) ; <<2 x i64>> [#uses=1]
  ret <2 x i64> %res
}
declare <2 x i64> @llvm.x86.sse2.psrl.q(<2 x i64>, <2 x i64>) nounwind readnone


define <8 x i16> @test_x86_sse2_psrl_w(<8 x i16> %a0, <8 x i16> %a1) {
; AVX-LABEL: test_x86_sse2_psrl_w:
; AVX:       ## BB#0:
; AVX-NEXT:    vpsrlw %xmm1, %xmm0, %xmm0 ## encoding: [0xc5,0xf9,0xd1,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_psrl_w:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpsrlw %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0xd1,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <8 x i16> @llvm.x86.sse2.psrl.w(<8 x i16> %a0, <8 x i16> %a1) ; <<8 x i16>> [#uses=1]
  ret <8 x i16> %res
}
declare <8 x i16> @llvm.x86.sse2.psrl.w(<8 x i16>, <8 x i16>) nounwind readnone


define <4 x i32> @test_x86_sse2_psrli_d(<4 x i32> %a0) {
; AVX-LABEL: test_x86_sse2_psrli_d:
; AVX:       ## BB#0:
; AVX-NEXT:    vpsrld $7, %xmm0, %xmm0 ## encoding: [0xc5,0xf9,0x72,0xd0,0x07]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_psrli_d:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpsrld $7, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0x72,0xd0,0x07]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <4 x i32> @llvm.x86.sse2.psrli.d(<4 x i32> %a0, i32 7) ; <<4 x i32>> [#uses=1]
  ret <4 x i32> %res
}
declare <4 x i32> @llvm.x86.sse2.psrli.d(<4 x i32>, i32) nounwind readnone


define <2 x i64> @test_x86_sse2_psrli_q(<2 x i64> %a0) {
; AVX-LABEL: test_x86_sse2_psrli_q:
; AVX:       ## BB#0:
; AVX-NEXT:    vpsrlq $7, %xmm0, %xmm0 ## encoding: [0xc5,0xf9,0x73,0xd0,0x07]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_psrli_q:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpsrlq $7, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0x73,0xd0,0x07]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <2 x i64> @llvm.x86.sse2.psrli.q(<2 x i64> %a0, i32 7) ; <<2 x i64>> [#uses=1]
  ret <2 x i64> %res
}
declare <2 x i64> @llvm.x86.sse2.psrli.q(<2 x i64>, i32) nounwind readnone


define <8 x i16> @test_x86_sse2_psrli_w(<8 x i16> %a0) {
; AVX-LABEL: test_x86_sse2_psrli_w:
; AVX:       ## BB#0:
; AVX-NEXT:    vpsrlw $7, %xmm0, %xmm0 ## encoding: [0xc5,0xf9,0x71,0xd0,0x07]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_psrli_w:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpsrlw $7, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0x71,0xd0,0x07]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <8 x i16> @llvm.x86.sse2.psrli.w(<8 x i16> %a0, i32 7) ; <<8 x i16>> [#uses=1]
  ret <8 x i16> %res
}
declare <8 x i16> @llvm.x86.sse2.psrli.w(<8 x i16>, i32) nounwind readnone


define <16 x i8> @test_x86_sse2_psubs_b(<16 x i8> %a0, <16 x i8> %a1) {
; AVX-LABEL: test_x86_sse2_psubs_b:
; AVX:       ## BB#0:
; AVX-NEXT:    vpsubsb %xmm1, %xmm0, %xmm0 ## encoding: [0xc5,0xf9,0xe8,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_psubs_b:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpsubsb %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0xe8,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <16 x i8> @llvm.x86.sse2.psubs.b(<16 x i8> %a0, <16 x i8> %a1) ; <<16 x i8>> [#uses=1]
  ret <16 x i8> %res
}
declare <16 x i8> @llvm.x86.sse2.psubs.b(<16 x i8>, <16 x i8>) nounwind readnone


define <8 x i16> @test_x86_sse2_psubs_w(<8 x i16> %a0, <8 x i16> %a1) {
; AVX-LABEL: test_x86_sse2_psubs_w:
; AVX:       ## BB#0:
; AVX-NEXT:    vpsubsw %xmm1, %xmm0, %xmm0 ## encoding: [0xc5,0xf9,0xe9,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_psubs_w:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpsubsw %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0xe9,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <8 x i16> @llvm.x86.sse2.psubs.w(<8 x i16> %a0, <8 x i16> %a1) ; <<8 x i16>> [#uses=1]
  ret <8 x i16> %res
}
declare <8 x i16> @llvm.x86.sse2.psubs.w(<8 x i16>, <8 x i16>) nounwind readnone


define <16 x i8> @test_x86_sse2_psubus_b(<16 x i8> %a0, <16 x i8> %a1) {
; AVX-LABEL: test_x86_sse2_psubus_b:
; AVX:       ## BB#0:
; AVX-NEXT:    vpsubusb %xmm1, %xmm0, %xmm0 ## encoding: [0xc5,0xf9,0xd8,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_psubus_b:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpsubusb %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0xd8,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <16 x i8> @llvm.x86.sse2.psubus.b(<16 x i8> %a0, <16 x i8> %a1) ; <<16 x i8>> [#uses=1]
  ret <16 x i8> %res
}
declare <16 x i8> @llvm.x86.sse2.psubus.b(<16 x i8>, <16 x i8>) nounwind readnone


define <8 x i16> @test_x86_sse2_psubus_w(<8 x i16> %a0, <8 x i16> %a1) {
; AVX-LABEL: test_x86_sse2_psubus_w:
; AVX:       ## BB#0:
; AVX-NEXT:    vpsubusw %xmm1, %xmm0, %xmm0 ## encoding: [0xc5,0xf9,0xd9,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_psubus_w:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpsubusw %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0xd9,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <8 x i16> @llvm.x86.sse2.psubus.w(<8 x i16> %a0, <8 x i16> %a1) ; <<8 x i16>> [#uses=1]
  ret <8 x i16> %res
}
declare <8 x i16> @llvm.x86.sse2.psubus.w(<8 x i16>, <8 x i16>) nounwind readnone


define <2 x double> @test_x86_sse2_sqrt_pd(<2 x double> %a0) {
; CHECK-LABEL: test_x86_sse2_sqrt_pd:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vsqrtpd %xmm0, %xmm0 ## encoding: [0xc5,0xf9,0x51,0xc0]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <2 x double> @llvm.x86.sse2.sqrt.pd(<2 x double> %a0) ; <<2 x double>> [#uses=1]
  ret <2 x double> %res
}
declare <2 x double> @llvm.x86.sse2.sqrt.pd(<2 x double>) nounwind readnone


define <2 x double> @test_x86_sse2_sqrt_sd(<2 x double> %a0) {
; CHECK-LABEL: test_x86_sse2_sqrt_sd:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vsqrtsd %xmm0, %xmm0, %xmm0 ## encoding: [0xc5,0xfb,0x51,0xc0]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <2 x double> @llvm.x86.sse2.sqrt.sd(<2 x double> %a0) ; <<2 x double>> [#uses=1]
  ret <2 x double> %res
}
declare <2 x double> @llvm.x86.sse2.sqrt.sd(<2 x double>) nounwind readnone


define i32 @test_x86_sse2_ucomieq_sd(<2 x double> %a0, <2 x double> %a1) {
; AVX-LABEL: test_x86_sse2_ucomieq_sd:
; AVX:       ## BB#0:
; AVX-NEXT:    vucomisd %xmm1, %xmm0 ## encoding: [0xc5,0xf9,0x2e,0xc1]
; AVX-NEXT:    setnp %al ## encoding: [0x0f,0x9b,0xc0]
; AVX-NEXT:    sete %cl ## encoding: [0x0f,0x94,0xc1]
; AVX-NEXT:    andb %al, %cl ## encoding: [0x20,0xc1]
; AVX-NEXT:    movzbl %cl, %eax ## encoding: [0x0f,0xb6,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_ucomieq_sd:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vucomisd %xmm1, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0x2e,0xc1]
; AVX512VL-NEXT:    setnp %al ## encoding: [0x0f,0x9b,0xc0]
; AVX512VL-NEXT:    sete %cl ## encoding: [0x0f,0x94,0xc1]
; AVX512VL-NEXT:    andb %al, %cl ## encoding: [0x20,0xc1]
; AVX512VL-NEXT:    movzbl %cl, %eax ## encoding: [0x0f,0xb6,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call i32 @llvm.x86.sse2.ucomieq.sd(<2 x double> %a0, <2 x double> %a1) ; <i32> [#uses=1]
  ret i32 %res
}
declare i32 @llvm.x86.sse2.ucomieq.sd(<2 x double>, <2 x double>) nounwind readnone


define i32 @test_x86_sse2_ucomige_sd(<2 x double> %a0, <2 x double> %a1) {
; AVX-LABEL: test_x86_sse2_ucomige_sd:
; AVX:       ## BB#0:
; AVX-NEXT:    xorl %eax, %eax ## encoding: [0x31,0xc0]
; AVX-NEXT:    vucomisd %xmm1, %xmm0 ## encoding: [0xc5,0xf9,0x2e,0xc1]
; AVX-NEXT:    setae %al ## encoding: [0x0f,0x93,0xc0]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_ucomige_sd:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    xorl %eax, %eax ## encoding: [0x31,0xc0]
; AVX512VL-NEXT:    vucomisd %xmm1, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0x2e,0xc1]
; AVX512VL-NEXT:    setae %al ## encoding: [0x0f,0x93,0xc0]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call i32 @llvm.x86.sse2.ucomige.sd(<2 x double> %a0, <2 x double> %a1) ; <i32> [#uses=1]
  ret i32 %res
}
declare i32 @llvm.x86.sse2.ucomige.sd(<2 x double>, <2 x double>) nounwind readnone


define i32 @test_x86_sse2_ucomigt_sd(<2 x double> %a0, <2 x double> %a1) {
; AVX-LABEL: test_x86_sse2_ucomigt_sd:
; AVX:       ## BB#0:
; AVX-NEXT:    xorl %eax, %eax ## encoding: [0x31,0xc0]
; AVX-NEXT:    vucomisd %xmm1, %xmm0 ## encoding: [0xc5,0xf9,0x2e,0xc1]
; AVX-NEXT:    seta %al ## encoding: [0x0f,0x97,0xc0]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_ucomigt_sd:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    xorl %eax, %eax ## encoding: [0x31,0xc0]
; AVX512VL-NEXT:    vucomisd %xmm1, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0x2e,0xc1]
; AVX512VL-NEXT:    seta %al ## encoding: [0x0f,0x97,0xc0]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call i32 @llvm.x86.sse2.ucomigt.sd(<2 x double> %a0, <2 x double> %a1) ; <i32> [#uses=1]
  ret i32 %res
}
declare i32 @llvm.x86.sse2.ucomigt.sd(<2 x double>, <2 x double>) nounwind readnone


define i32 @test_x86_sse2_ucomile_sd(<2 x double> %a0, <2 x double> %a1) {
; AVX-LABEL: test_x86_sse2_ucomile_sd:
; AVX:       ## BB#0:
; AVX-NEXT:    xorl %eax, %eax ## encoding: [0x31,0xc0]
; AVX-NEXT:    vucomisd %xmm0, %xmm1 ## encoding: [0xc5,0xf9,0x2e,0xc8]
; AVX-NEXT:    setae %al ## encoding: [0x0f,0x93,0xc0]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_ucomile_sd:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    xorl %eax, %eax ## encoding: [0x31,0xc0]
; AVX512VL-NEXT:    vucomisd %xmm0, %xmm1 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0x2e,0xc8]
; AVX512VL-NEXT:    setae %al ## encoding: [0x0f,0x93,0xc0]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call i32 @llvm.x86.sse2.ucomile.sd(<2 x double> %a0, <2 x double> %a1) ; <i32> [#uses=1]
  ret i32 %res
}
declare i32 @llvm.x86.sse2.ucomile.sd(<2 x double>, <2 x double>) nounwind readnone


define i32 @test_x86_sse2_ucomilt_sd(<2 x double> %a0, <2 x double> %a1) {
; AVX-LABEL: test_x86_sse2_ucomilt_sd:
; AVX:       ## BB#0:
; AVX-NEXT:    xorl %eax, %eax ## encoding: [0x31,0xc0]
; AVX-NEXT:    vucomisd %xmm0, %xmm1 ## encoding: [0xc5,0xf9,0x2e,0xc8]
; AVX-NEXT:    seta %al ## encoding: [0x0f,0x97,0xc0]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_ucomilt_sd:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    xorl %eax, %eax ## encoding: [0x31,0xc0]
; AVX512VL-NEXT:    vucomisd %xmm0, %xmm1 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0x2e,0xc8]
; AVX512VL-NEXT:    seta %al ## encoding: [0x0f,0x97,0xc0]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call i32 @llvm.x86.sse2.ucomilt.sd(<2 x double> %a0, <2 x double> %a1) ; <i32> [#uses=1]
  ret i32 %res
}
declare i32 @llvm.x86.sse2.ucomilt.sd(<2 x double>, <2 x double>) nounwind readnone


define i32 @test_x86_sse2_ucomineq_sd(<2 x double> %a0, <2 x double> %a1) {
; AVX-LABEL: test_x86_sse2_ucomineq_sd:
; AVX:       ## BB#0:
; AVX-NEXT:    vucomisd %xmm1, %xmm0 ## encoding: [0xc5,0xf9,0x2e,0xc1]
; AVX-NEXT:    setp %al ## encoding: [0x0f,0x9a,0xc0]
; AVX-NEXT:    setne %cl ## encoding: [0x0f,0x95,0xc1]
; AVX-NEXT:    orb %al, %cl ## encoding: [0x08,0xc1]
; AVX-NEXT:    movzbl %cl, %eax ## encoding: [0x0f,0xb6,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse2_ucomineq_sd:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vucomisd %xmm1, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0x2e,0xc1]
; AVX512VL-NEXT:    setp %al ## encoding: [0x0f,0x9a,0xc0]
; AVX512VL-NEXT:    setne %cl ## encoding: [0x0f,0x95,0xc1]
; AVX512VL-NEXT:    orb %al, %cl ## encoding: [0x08,0xc1]
; AVX512VL-NEXT:    movzbl %cl, %eax ## encoding: [0x0f,0xb6,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call i32 @llvm.x86.sse2.ucomineq.sd(<2 x double> %a0, <2 x double> %a1) ; <i32> [#uses=1]
  ret i32 %res
}
declare i32 @llvm.x86.sse2.ucomineq.sd(<2 x double>, <2 x double>) nounwind readnone


define <2 x double> @test_x86_sse3_addsub_pd(<2 x double> %a0, <2 x double> %a1) {
; CHECK-LABEL: test_x86_sse3_addsub_pd:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vaddsubpd %xmm1, %xmm0, %xmm0 ## encoding: [0xc5,0xf9,0xd0,0xc1]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <2 x double> @llvm.x86.sse3.addsub.pd(<2 x double> %a0, <2 x double> %a1) ; <<2 x double>> [#uses=1]
  ret <2 x double> %res
}
declare <2 x double> @llvm.x86.sse3.addsub.pd(<2 x double>, <2 x double>) nounwind readnone


define <4 x float> @test_x86_sse3_addsub_ps(<4 x float> %a0, <4 x float> %a1) {
; CHECK-LABEL: test_x86_sse3_addsub_ps:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vaddsubps %xmm1, %xmm0, %xmm0 ## encoding: [0xc5,0xfb,0xd0,0xc1]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <4 x float> @llvm.x86.sse3.addsub.ps(<4 x float> %a0, <4 x float> %a1) ; <<4 x float>> [#uses=1]
  ret <4 x float> %res
}
declare <4 x float> @llvm.x86.sse3.addsub.ps(<4 x float>, <4 x float>) nounwind readnone


define <2 x double> @test_x86_sse3_hadd_pd(<2 x double> %a0, <2 x double> %a1) {
; CHECK-LABEL: test_x86_sse3_hadd_pd:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vhaddpd %xmm1, %xmm0, %xmm0 ## encoding: [0xc5,0xf9,0x7c,0xc1]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <2 x double> @llvm.x86.sse3.hadd.pd(<2 x double> %a0, <2 x double> %a1) ; <<2 x double>> [#uses=1]
  ret <2 x double> %res
}
declare <2 x double> @llvm.x86.sse3.hadd.pd(<2 x double>, <2 x double>) nounwind readnone


define <4 x float> @test_x86_sse3_hadd_ps(<4 x float> %a0, <4 x float> %a1) {
; CHECK-LABEL: test_x86_sse3_hadd_ps:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vhaddps %xmm1, %xmm0, %xmm0 ## encoding: [0xc5,0xfb,0x7c,0xc1]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <4 x float> @llvm.x86.sse3.hadd.ps(<4 x float> %a0, <4 x float> %a1) ; <<4 x float>> [#uses=1]
  ret <4 x float> %res
}
declare <4 x float> @llvm.x86.sse3.hadd.ps(<4 x float>, <4 x float>) nounwind readnone


define <2 x double> @test_x86_sse3_hsub_pd(<2 x double> %a0, <2 x double> %a1) {
; CHECK-LABEL: test_x86_sse3_hsub_pd:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vhsubpd %xmm1, %xmm0, %xmm0 ## encoding: [0xc5,0xf9,0x7d,0xc1]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <2 x double> @llvm.x86.sse3.hsub.pd(<2 x double> %a0, <2 x double> %a1) ; <<2 x double>> [#uses=1]
  ret <2 x double> %res
}
declare <2 x double> @llvm.x86.sse3.hsub.pd(<2 x double>, <2 x double>) nounwind readnone


define <4 x float> @test_x86_sse3_hsub_ps(<4 x float> %a0, <4 x float> %a1) {
; CHECK-LABEL: test_x86_sse3_hsub_ps:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vhsubps %xmm1, %xmm0, %xmm0 ## encoding: [0xc5,0xfb,0x7d,0xc1]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <4 x float> @llvm.x86.sse3.hsub.ps(<4 x float> %a0, <4 x float> %a1) ; <<4 x float>> [#uses=1]
  ret <4 x float> %res
}
declare <4 x float> @llvm.x86.sse3.hsub.ps(<4 x float>, <4 x float>) nounwind readnone


define <16 x i8> @test_x86_sse3_ldu_dq(i8* %a0) {
; CHECK-LABEL: test_x86_sse3_ldu_dq:
; CHECK:       ## BB#0:
; CHECK-NEXT:    movl {{[0-9]+}}(%esp), %eax ## encoding: [0x8b,0x44,0x24,0x04]
; CHECK-NEXT:    vlddqu (%eax), %xmm0 ## encoding: [0xc5,0xfb,0xf0,0x00]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <16 x i8> @llvm.x86.sse3.ldu.dq(i8* %a0) ; <<16 x i8>> [#uses=1]
  ret <16 x i8> %res
}
declare <16 x i8> @llvm.x86.sse3.ldu.dq(i8*) nounwind readonly


define <2 x double> @test_x86_sse41_blendvpd(<2 x double> %a0, <2 x double> %a1, <2 x double> %a2) {
; CHECK-LABEL: test_x86_sse41_blendvpd:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vblendvpd %xmm2, %xmm1, %xmm0, %xmm0 ## encoding: [0xc4,0xe3,0x79,0x4b,0xc1,0x20]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <2 x double> @llvm.x86.sse41.blendvpd(<2 x double> %a0, <2 x double> %a1, <2 x double> %a2) ; <<2 x double>> [#uses=1]
  ret <2 x double> %res
}
declare <2 x double> @llvm.x86.sse41.blendvpd(<2 x double>, <2 x double>, <2 x double>) nounwind readnone


define <4 x float> @test_x86_sse41_blendvps(<4 x float> %a0, <4 x float> %a1, <4 x float> %a2) {
; CHECK-LABEL: test_x86_sse41_blendvps:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vblendvps %xmm2, %xmm1, %xmm0, %xmm0 ## encoding: [0xc4,0xe3,0x79,0x4a,0xc1,0x20]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <4 x float> @llvm.x86.sse41.blendvps(<4 x float> %a0, <4 x float> %a1, <4 x float> %a2) ; <<4 x float>> [#uses=1]
  ret <4 x float> %res
}
declare <4 x float> @llvm.x86.sse41.blendvps(<4 x float>, <4 x float>, <4 x float>) nounwind readnone


define <2 x double> @test_x86_sse41_dppd(<2 x double> %a0, <2 x double> %a1) {
; CHECK-LABEL: test_x86_sse41_dppd:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vdppd $7, %xmm1, %xmm0, %xmm0 ## encoding: [0xc4,0xe3,0x79,0x41,0xc1,0x07]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <2 x double> @llvm.x86.sse41.dppd(<2 x double> %a0, <2 x double> %a1, i8 7) ; <<2 x double>> [#uses=1]
  ret <2 x double> %res
}
declare <2 x double> @llvm.x86.sse41.dppd(<2 x double>, <2 x double>, i8) nounwind readnone


define <4 x float> @test_x86_sse41_dpps(<4 x float> %a0, <4 x float> %a1) {
; CHECK-LABEL: test_x86_sse41_dpps:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vdpps $7, %xmm1, %xmm0, %xmm0 ## encoding: [0xc4,0xe3,0x79,0x40,0xc1,0x07]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <4 x float> @llvm.x86.sse41.dpps(<4 x float> %a0, <4 x float> %a1, i8 7) ; <<4 x float>> [#uses=1]
  ret <4 x float> %res
}
declare <4 x float> @llvm.x86.sse41.dpps(<4 x float>, <4 x float>, i8) nounwind readnone


define <4 x float> @test_x86_sse41_insertps(<4 x float> %a0, <4 x float> %a1) {
; AVX-LABEL: test_x86_sse41_insertps:
; AVX:       ## BB#0:
; AVX-NEXT:    vinsertps $21, %xmm1, %xmm0, %xmm0 ## encoding: [0xc4,0xe3,0x79,0x21,0xc1,0x15]
; AVX-NEXT:    ## xmm0 = zero,xmm1[0],zero,xmm0[3]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse41_insertps:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vinsertps $21, %xmm1, %xmm0, %xmm0 ## encoding: [0x62,0xf3,0x7d,0x08,0x21,0xc1,0x15]
; AVX512VL-NEXT:    ## xmm0 = zero,xmm1[0],zero,xmm0[3]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <4 x float> @llvm.x86.sse41.insertps(<4 x float> %a0, <4 x float> %a1, i8 21) ; <<4 x float>> [#uses=1]
  ret <4 x float> %res
}
declare <4 x float> @llvm.x86.sse41.insertps(<4 x float>, <4 x float>, i8) nounwind readnone



define <8 x i16> @test_x86_sse41_mpsadbw(<16 x i8> %a0, <16 x i8> %a1) {
; CHECK-LABEL: test_x86_sse41_mpsadbw:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vmpsadbw $7, %xmm1, %xmm0, %xmm0 ## encoding: [0xc4,0xe3,0x79,0x42,0xc1,0x07]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <8 x i16> @llvm.x86.sse41.mpsadbw(<16 x i8> %a0, <16 x i8> %a1, i8 7) ; <<8 x i16>> [#uses=1]
  ret <8 x i16> %res
}
declare <8 x i16> @llvm.x86.sse41.mpsadbw(<16 x i8>, <16 x i8>, i8) nounwind readnone


define <8 x i16> @test_x86_sse41_packusdw(<4 x i32> %a0, <4 x i32> %a1) {
; AVX-LABEL: test_x86_sse41_packusdw:
; AVX:       ## BB#0:
; AVX-NEXT:    vpackusdw %xmm1, %xmm0, %xmm0 ## encoding: [0xc4,0xe2,0x79,0x2b,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse41_packusdw:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpackusdw %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc4,0xe2,0x79,0x2b,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <8 x i16> @llvm.x86.sse41.packusdw(<4 x i32> %a0, <4 x i32> %a1) ; <<8 x i16>> [#uses=1]
  ret <8 x i16> %res
}
declare <8 x i16> @llvm.x86.sse41.packusdw(<4 x i32>, <4 x i32>) nounwind readnone


define <16 x i8> @test_x86_sse41_pblendvb(<16 x i8> %a0, <16 x i8> %a1, <16 x i8> %a2) {
; CHECK-LABEL: test_x86_sse41_pblendvb:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vpblendvb %xmm2, %xmm1, %xmm0, %xmm0 ## encoding: [0xc4,0xe3,0x79,0x4c,0xc1,0x20]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <16 x i8> @llvm.x86.sse41.pblendvb(<16 x i8> %a0, <16 x i8> %a1, <16 x i8> %a2) ; <<16 x i8>> [#uses=1]
  ret <16 x i8> %res
}
declare <16 x i8> @llvm.x86.sse41.pblendvb(<16 x i8>, <16 x i8>, <16 x i8>) nounwind readnone


define <8 x i16> @test_x86_sse41_phminposuw(<8 x i16> %a0) {
; CHECK-LABEL: test_x86_sse41_phminposuw:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vphminposuw %xmm0, %xmm0 ## encoding: [0xc4,0xe2,0x79,0x41,0xc0]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <8 x i16> @llvm.x86.sse41.phminposuw(<8 x i16> %a0) ; <<8 x i16>> [#uses=1]
  ret <8 x i16> %res
}
declare <8 x i16> @llvm.x86.sse41.phminposuw(<8 x i16>) nounwind readnone


define <16 x i8> @test_x86_sse41_pmaxsb(<16 x i8> %a0, <16 x i8> %a1) {
; AVX-LABEL: test_x86_sse41_pmaxsb:
; AVX:       ## BB#0:
; AVX-NEXT:    vpmaxsb %xmm1, %xmm0, %xmm0 ## encoding: [0xc4,0xe2,0x79,0x3c,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse41_pmaxsb:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpmaxsb %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc4,0xe2,0x79,0x3c,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <16 x i8> @llvm.x86.sse41.pmaxsb(<16 x i8> %a0, <16 x i8> %a1) ; <<16 x i8>> [#uses=1]
  ret <16 x i8> %res
}
declare <16 x i8> @llvm.x86.sse41.pmaxsb(<16 x i8>, <16 x i8>) nounwind readnone


define <4 x i32> @test_x86_sse41_pmaxsd(<4 x i32> %a0, <4 x i32> %a1) {
; AVX-LABEL: test_x86_sse41_pmaxsd:
; AVX:       ## BB#0:
; AVX-NEXT:    vpmaxsd %xmm1, %xmm0, %xmm0 ## encoding: [0xc4,0xe2,0x79,0x3d,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse41_pmaxsd:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpmaxsd %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc4,0xe2,0x79,0x3d,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <4 x i32> @llvm.x86.sse41.pmaxsd(<4 x i32> %a0, <4 x i32> %a1) ; <<4 x i32>> [#uses=1]
  ret <4 x i32> %res
}
declare <4 x i32> @llvm.x86.sse41.pmaxsd(<4 x i32>, <4 x i32>) nounwind readnone


define <4 x i32> @test_x86_sse41_pmaxud(<4 x i32> %a0, <4 x i32> %a1) {
; AVX-LABEL: test_x86_sse41_pmaxud:
; AVX:       ## BB#0:
; AVX-NEXT:    vpmaxud %xmm1, %xmm0, %xmm0 ## encoding: [0xc4,0xe2,0x79,0x3f,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse41_pmaxud:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpmaxud %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc4,0xe2,0x79,0x3f,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <4 x i32> @llvm.x86.sse41.pmaxud(<4 x i32> %a0, <4 x i32> %a1) ; <<4 x i32>> [#uses=1]
  ret <4 x i32> %res
}
declare <4 x i32> @llvm.x86.sse41.pmaxud(<4 x i32>, <4 x i32>) nounwind readnone


define <8 x i16> @test_x86_sse41_pmaxuw(<8 x i16> %a0, <8 x i16> %a1) {
; AVX-LABEL: test_x86_sse41_pmaxuw:
; AVX:       ## BB#0:
; AVX-NEXT:    vpmaxuw %xmm1, %xmm0, %xmm0 ## encoding: [0xc4,0xe2,0x79,0x3e,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse41_pmaxuw:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpmaxuw %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc4,0xe2,0x79,0x3e,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <8 x i16> @llvm.x86.sse41.pmaxuw(<8 x i16> %a0, <8 x i16> %a1) ; <<8 x i16>> [#uses=1]
  ret <8 x i16> %res
}
declare <8 x i16> @llvm.x86.sse41.pmaxuw(<8 x i16>, <8 x i16>) nounwind readnone


define <16 x i8> @test_x86_sse41_pminsb(<16 x i8> %a0, <16 x i8> %a1) {
; AVX-LABEL: test_x86_sse41_pminsb:
; AVX:       ## BB#0:
; AVX-NEXT:    vpminsb %xmm1, %xmm0, %xmm0 ## encoding: [0xc4,0xe2,0x79,0x38,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse41_pminsb:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpminsb %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc4,0xe2,0x79,0x38,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <16 x i8> @llvm.x86.sse41.pminsb(<16 x i8> %a0, <16 x i8> %a1) ; <<16 x i8>> [#uses=1]
  ret <16 x i8> %res
}
declare <16 x i8> @llvm.x86.sse41.pminsb(<16 x i8>, <16 x i8>) nounwind readnone


define <4 x i32> @test_x86_sse41_pminsd(<4 x i32> %a0, <4 x i32> %a1) {
; AVX-LABEL: test_x86_sse41_pminsd:
; AVX:       ## BB#0:
; AVX-NEXT:    vpminsd %xmm1, %xmm0, %xmm0 ## encoding: [0xc4,0xe2,0x79,0x39,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse41_pminsd:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpminsd %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc4,0xe2,0x79,0x39,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <4 x i32> @llvm.x86.sse41.pminsd(<4 x i32> %a0, <4 x i32> %a1) ; <<4 x i32>> [#uses=1]
  ret <4 x i32> %res
}
declare <4 x i32> @llvm.x86.sse41.pminsd(<4 x i32>, <4 x i32>) nounwind readnone


define <4 x i32> @test_x86_sse41_pminud(<4 x i32> %a0, <4 x i32> %a1) {
; AVX-LABEL: test_x86_sse41_pminud:
; AVX:       ## BB#0:
; AVX-NEXT:    vpminud %xmm1, %xmm0, %xmm0 ## encoding: [0xc4,0xe2,0x79,0x3b,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse41_pminud:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpminud %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc4,0xe2,0x79,0x3b,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <4 x i32> @llvm.x86.sse41.pminud(<4 x i32> %a0, <4 x i32> %a1) ; <<4 x i32>> [#uses=1]
  ret <4 x i32> %res
}
declare <4 x i32> @llvm.x86.sse41.pminud(<4 x i32>, <4 x i32>) nounwind readnone


define <8 x i16> @test_x86_sse41_pminuw(<8 x i16> %a0, <8 x i16> %a1) {
; AVX-LABEL: test_x86_sse41_pminuw:
; AVX:       ## BB#0:
; AVX-NEXT:    vpminuw %xmm1, %xmm0, %xmm0 ## encoding: [0xc4,0xe2,0x79,0x3a,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse41_pminuw:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpminuw %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc4,0xe2,0x79,0x3a,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <8 x i16> @llvm.x86.sse41.pminuw(<8 x i16> %a0, <8 x i16> %a1) ; <<8 x i16>> [#uses=1]
  ret <8 x i16> %res
}
declare <8 x i16> @llvm.x86.sse41.pminuw(<8 x i16>, <8 x i16>) nounwind readnone


define <2 x i64> @test_x86_sse41_pmuldq(<4 x i32> %a0, <4 x i32> %a1) {
; AVX-LABEL: test_x86_sse41_pmuldq:
; AVX:       ## BB#0:
; AVX-NEXT:    vpmuldq %xmm1, %xmm0, %xmm0 ## encoding: [0xc4,0xe2,0x79,0x28,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse41_pmuldq:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpmuldq %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc4,0xe2,0x79,0x28,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <2 x i64> @llvm.x86.sse41.pmuldq(<4 x i32> %a0, <4 x i32> %a1) ; <<2 x i64>> [#uses=1]
  ret <2 x i64> %res
}
declare <2 x i64> @llvm.x86.sse41.pmuldq(<4 x i32>, <4 x i32>) nounwind readnone


define i32 @test_x86_sse41_ptestc(<2 x i64> %a0, <2 x i64> %a1) {
; CHECK-LABEL: test_x86_sse41_ptestc:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vptest %xmm1, %xmm0 ## encoding: [0xc4,0xe2,0x79,0x17,0xc1]
; CHECK-NEXT:    sbbl %eax, %eax ## encoding: [0x19,0xc0]
; CHECK-NEXT:    andl $1, %eax ## encoding: [0x83,0xe0,0x01]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call i32 @llvm.x86.sse41.ptestc(<2 x i64> %a0, <2 x i64> %a1) ; <i32> [#uses=1]
  ret i32 %res
}
declare i32 @llvm.x86.sse41.ptestc(<2 x i64>, <2 x i64>) nounwind readnone


define i32 @test_x86_sse41_ptestnzc(<2 x i64> %a0, <2 x i64> %a1) {
; CHECK-LABEL: test_x86_sse41_ptestnzc:
; CHECK:       ## BB#0:
; CHECK-NEXT:    xorl %eax, %eax ## encoding: [0x31,0xc0]
; CHECK-NEXT:    vptest %xmm1, %xmm0 ## encoding: [0xc4,0xe2,0x79,0x17,0xc1]
; CHECK-NEXT:    seta %al ## encoding: [0x0f,0x97,0xc0]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call i32 @llvm.x86.sse41.ptestnzc(<2 x i64> %a0, <2 x i64> %a1) ; <i32> [#uses=1]
  ret i32 %res
}
declare i32 @llvm.x86.sse41.ptestnzc(<2 x i64>, <2 x i64>) nounwind readnone


define i32 @test_x86_sse41_ptestz(<2 x i64> %a0, <2 x i64> %a1) {
; CHECK-LABEL: test_x86_sse41_ptestz:
; CHECK:       ## BB#0:
; CHECK-NEXT:    xorl %eax, %eax ## encoding: [0x31,0xc0]
; CHECK-NEXT:    vptest %xmm1, %xmm0 ## encoding: [0xc4,0xe2,0x79,0x17,0xc1]
; CHECK-NEXT:    sete %al ## encoding: [0x0f,0x94,0xc0]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call i32 @llvm.x86.sse41.ptestz(<2 x i64> %a0, <2 x i64> %a1) ; <i32> [#uses=1]
  ret i32 %res
}
declare i32 @llvm.x86.sse41.ptestz(<2 x i64>, <2 x i64>) nounwind readnone


define <2 x double> @test_x86_sse41_round_pd(<2 x double> %a0) {
; CHECK-LABEL: test_x86_sse41_round_pd:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vroundpd $7, %xmm0, %xmm0 ## encoding: [0xc4,0xe3,0x79,0x09,0xc0,0x07]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <2 x double> @llvm.x86.sse41.round.pd(<2 x double> %a0, i32 7) ; <<2 x double>> [#uses=1]
  ret <2 x double> %res
}
declare <2 x double> @llvm.x86.sse41.round.pd(<2 x double>, i32) nounwind readnone


define <4 x float> @test_x86_sse41_round_ps(<4 x float> %a0) {
; CHECK-LABEL: test_x86_sse41_round_ps:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vroundps $7, %xmm0, %xmm0 ## encoding: [0xc4,0xe3,0x79,0x08,0xc0,0x07]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <4 x float> @llvm.x86.sse41.round.ps(<4 x float> %a0, i32 7) ; <<4 x float>> [#uses=1]
  ret <4 x float> %res
}
declare <4 x float> @llvm.x86.sse41.round.ps(<4 x float>, i32) nounwind readnone


define <2 x double> @test_x86_sse41_round_sd(<2 x double> %a0, <2 x double> %a1) {
; CHECK-LABEL: test_x86_sse41_round_sd:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vroundsd $7, %xmm1, %xmm0, %xmm0 ## encoding: [0xc4,0xe3,0x79,0x0b,0xc1,0x07]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <2 x double> @llvm.x86.sse41.round.sd(<2 x double> %a0, <2 x double> %a1, i32 7) ; <<2 x double>> [#uses=1]
  ret <2 x double> %res
}
declare <2 x double> @llvm.x86.sse41.round.sd(<2 x double>, <2 x double>, i32) nounwind readnone


define <4 x float> @test_x86_sse41_round_ss(<4 x float> %a0, <4 x float> %a1) {
; CHECK-LABEL: test_x86_sse41_round_ss:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vroundss $7, %xmm1, %xmm0, %xmm0 ## encoding: [0xc4,0xe3,0x79,0x0a,0xc1,0x07]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <4 x float> @llvm.x86.sse41.round.ss(<4 x float> %a0, <4 x float> %a1, i32 7) ; <<4 x float>> [#uses=1]
  ret <4 x float> %res
}
declare <4 x float> @llvm.x86.sse41.round.ss(<4 x float>, <4 x float>, i32) nounwind readnone


define i32 @test_x86_sse42_pcmpestri128(<16 x i8> %a0, <16 x i8> %a2) {
; CHECK-LABEL: test_x86_sse42_pcmpestri128:
; CHECK:       ## BB#0:
; CHECK-NEXT:    movl $7, %eax ## encoding: [0xb8,0x07,0x00,0x00,0x00]
; CHECK-NEXT:    movl $7, %edx ## encoding: [0xba,0x07,0x00,0x00,0x00]
; CHECK-NEXT:    vpcmpestri $7, %xmm1, %xmm0 ## encoding: [0xc4,0xe3,0x79,0x61,0xc1,0x07]
; CHECK-NEXT:    movl %ecx, %eax ## encoding: [0x89,0xc8]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call i32 @llvm.x86.sse42.pcmpestri128(<16 x i8> %a0, i32 7, <16 x i8> %a2, i32 7, i8 7) ; <i32> [#uses=1]
  ret i32 %res
}
declare i32 @llvm.x86.sse42.pcmpestri128(<16 x i8>, i32, <16 x i8>, i32, i8) nounwind readnone


define i32 @test_x86_sse42_pcmpestri128_load(<16 x i8>* %a0, <16 x i8>* %a2) {
; AVX-LABEL: test_x86_sse42_pcmpestri128_load:
; AVX:       ## BB#0:
; AVX-NEXT:    movl {{[0-9]+}}(%esp), %ecx ## encoding: [0x8b,0x4c,0x24,0x08]
; AVX-NEXT:    movl {{[0-9]+}}(%esp), %eax ## encoding: [0x8b,0x44,0x24,0x04]
; AVX-NEXT:    vmovdqa (%eax), %xmm0 ## encoding: [0xc5,0xf9,0x6f,0x00]
; AVX-NEXT:    movl $7, %eax ## encoding: [0xb8,0x07,0x00,0x00,0x00]
; AVX-NEXT:    movl $7, %edx ## encoding: [0xba,0x07,0x00,0x00,0x00]
; AVX-NEXT:    vpcmpestri $7, (%ecx), %xmm0 ## encoding: [0xc4,0xe3,0x79,0x61,0x01,0x07]
; AVX-NEXT:    movl %ecx, %eax ## encoding: [0x89,0xc8]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse42_pcmpestri128_load:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    movl {{[0-9]+}}(%esp), %ecx ## encoding: [0x8b,0x4c,0x24,0x08]
; AVX512VL-NEXT:    movl {{[0-9]+}}(%esp), %eax ## encoding: [0x8b,0x44,0x24,0x04]
; AVX512VL-NEXT:    vmovdqu (%eax), %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xfa,0x6f,0x00]
; AVX512VL-NEXT:    movl $7, %eax ## encoding: [0xb8,0x07,0x00,0x00,0x00]
; AVX512VL-NEXT:    movl $7, %edx ## encoding: [0xba,0x07,0x00,0x00,0x00]
; AVX512VL-NEXT:    vpcmpestri $7, (%ecx), %xmm0 ## encoding: [0xc4,0xe3,0x79,0x61,0x01,0x07]
; AVX512VL-NEXT:    movl %ecx, %eax ## encoding: [0x89,0xc8]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %1 = load <16 x i8>, <16 x i8>* %a0
  %2 = load <16 x i8>, <16 x i8>* %a2
  %res = call i32 @llvm.x86.sse42.pcmpestri128(<16 x i8> %1, i32 7, <16 x i8> %2, i32 7, i8 7) ; <i32> [#uses=1]
  ret i32 %res
}


define i32 @test_x86_sse42_pcmpestria128(<16 x i8> %a0, <16 x i8> %a2) nounwind {
; CHECK-LABEL: test_x86_sse42_pcmpestria128:
; CHECK:       ## BB#0:
; CHECK-NEXT:    pushl %ebx ## encoding: [0x53]
; CHECK-NEXT:    movl $7, %eax ## encoding: [0xb8,0x07,0x00,0x00,0x00]
; CHECK-NEXT:    movl $7, %edx ## encoding: [0xba,0x07,0x00,0x00,0x00]
; CHECK-NEXT:    xorl %ebx, %ebx ## encoding: [0x31,0xdb]
; CHECK-NEXT:    vpcmpestri $7, %xmm1, %xmm0 ## encoding: [0xc4,0xe3,0x79,0x61,0xc1,0x07]
; CHECK-NEXT:    seta %bl ## encoding: [0x0f,0x97,0xc3]
; CHECK-NEXT:    movl %ebx, %eax ## encoding: [0x89,0xd8]
; CHECK-NEXT:    popl %ebx ## encoding: [0x5b]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call i32 @llvm.x86.sse42.pcmpestria128(<16 x i8> %a0, i32 7, <16 x i8> %a2, i32 7, i8 7) ; <i32> [#uses=1]
  ret i32 %res
}
declare i32 @llvm.x86.sse42.pcmpestria128(<16 x i8>, i32, <16 x i8>, i32, i8) nounwind readnone


define i32 @test_x86_sse42_pcmpestric128(<16 x i8> %a0, <16 x i8> %a2) {
; CHECK-LABEL: test_x86_sse42_pcmpestric128:
; CHECK:       ## BB#0:
; CHECK-NEXT:    movl $7, %eax ## encoding: [0xb8,0x07,0x00,0x00,0x00]
; CHECK-NEXT:    movl $7, %edx ## encoding: [0xba,0x07,0x00,0x00,0x00]
; CHECK-NEXT:    vpcmpestri $7, %xmm1, %xmm0 ## encoding: [0xc4,0xe3,0x79,0x61,0xc1,0x07]
; CHECK-NEXT:    sbbl %eax, %eax ## encoding: [0x19,0xc0]
; CHECK-NEXT:    andl $1, %eax ## encoding: [0x83,0xe0,0x01]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call i32 @llvm.x86.sse42.pcmpestric128(<16 x i8> %a0, i32 7, <16 x i8> %a2, i32 7, i8 7) ; <i32> [#uses=1]
  ret i32 %res
}
declare i32 @llvm.x86.sse42.pcmpestric128(<16 x i8>, i32, <16 x i8>, i32, i8) nounwind readnone


define i32 @test_x86_sse42_pcmpestrio128(<16 x i8> %a0, <16 x i8> %a2) nounwind {
; CHECK-LABEL: test_x86_sse42_pcmpestrio128:
; CHECK:       ## BB#0:
; CHECK-NEXT:    pushl %ebx ## encoding: [0x53]
; CHECK-NEXT:    movl $7, %eax ## encoding: [0xb8,0x07,0x00,0x00,0x00]
; CHECK-NEXT:    movl $7, %edx ## encoding: [0xba,0x07,0x00,0x00,0x00]
; CHECK-NEXT:    xorl %ebx, %ebx ## encoding: [0x31,0xdb]
; CHECK-NEXT:    vpcmpestri $7, %xmm1, %xmm0 ## encoding: [0xc4,0xe3,0x79,0x61,0xc1,0x07]
; CHECK-NEXT:    seto %bl ## encoding: [0x0f,0x90,0xc3]
; CHECK-NEXT:    movl %ebx, %eax ## encoding: [0x89,0xd8]
; CHECK-NEXT:    popl %ebx ## encoding: [0x5b]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call i32 @llvm.x86.sse42.pcmpestrio128(<16 x i8> %a0, i32 7, <16 x i8> %a2, i32 7, i8 7) ; <i32> [#uses=1]
  ret i32 %res
}
declare i32 @llvm.x86.sse42.pcmpestrio128(<16 x i8>, i32, <16 x i8>, i32, i8) nounwind readnone


define i32 @test_x86_sse42_pcmpestris128(<16 x i8> %a0, <16 x i8> %a2) nounwind {
; CHECK-LABEL: test_x86_sse42_pcmpestris128:
; CHECK:       ## BB#0:
; CHECK-NEXT:    pushl %ebx ## encoding: [0x53]
; CHECK-NEXT:    movl $7, %eax ## encoding: [0xb8,0x07,0x00,0x00,0x00]
; CHECK-NEXT:    movl $7, %edx ## encoding: [0xba,0x07,0x00,0x00,0x00]
; CHECK-NEXT:    xorl %ebx, %ebx ## encoding: [0x31,0xdb]
; CHECK-NEXT:    vpcmpestri $7, %xmm1, %xmm0 ## encoding: [0xc4,0xe3,0x79,0x61,0xc1,0x07]
; CHECK-NEXT:    sets %bl ## encoding: [0x0f,0x98,0xc3]
; CHECK-NEXT:    movl %ebx, %eax ## encoding: [0x89,0xd8]
; CHECK-NEXT:    popl %ebx ## encoding: [0x5b]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call i32 @llvm.x86.sse42.pcmpestris128(<16 x i8> %a0, i32 7, <16 x i8> %a2, i32 7, i8 7) ; <i32> [#uses=1]
  ret i32 %res
}
declare i32 @llvm.x86.sse42.pcmpestris128(<16 x i8>, i32, <16 x i8>, i32, i8) nounwind readnone


define i32 @test_x86_sse42_pcmpestriz128(<16 x i8> %a0, <16 x i8> %a2) nounwind {
; CHECK-LABEL: test_x86_sse42_pcmpestriz128:
; CHECK:       ## BB#0:
; CHECK-NEXT:    pushl %ebx ## encoding: [0x53]
; CHECK-NEXT:    movl $7, %eax ## encoding: [0xb8,0x07,0x00,0x00,0x00]
; CHECK-NEXT:    movl $7, %edx ## encoding: [0xba,0x07,0x00,0x00,0x00]
; CHECK-NEXT:    xorl %ebx, %ebx ## encoding: [0x31,0xdb]
; CHECK-NEXT:    vpcmpestri $7, %xmm1, %xmm0 ## encoding: [0xc4,0xe3,0x79,0x61,0xc1,0x07]
; CHECK-NEXT:    sete %bl ## encoding: [0x0f,0x94,0xc3]
; CHECK-NEXT:    movl %ebx, %eax ## encoding: [0x89,0xd8]
; CHECK-NEXT:    popl %ebx ## encoding: [0x5b]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call i32 @llvm.x86.sse42.pcmpestriz128(<16 x i8> %a0, i32 7, <16 x i8> %a2, i32 7, i8 7) ; <i32> [#uses=1]
  ret i32 %res
}
declare i32 @llvm.x86.sse42.pcmpestriz128(<16 x i8>, i32, <16 x i8>, i32, i8) nounwind readnone


define <16 x i8> @test_x86_sse42_pcmpestrm128(<16 x i8> %a0, <16 x i8> %a2) {
; CHECK-LABEL: test_x86_sse42_pcmpestrm128:
; CHECK:       ## BB#0:
; CHECK-NEXT:    movl $7, %eax ## encoding: [0xb8,0x07,0x00,0x00,0x00]
; CHECK-NEXT:    movl $7, %edx ## encoding: [0xba,0x07,0x00,0x00,0x00]
; CHECK-NEXT:    vpcmpestrm $7, %xmm1, %xmm0 ## encoding: [0xc4,0xe3,0x79,0x60,0xc1,0x07]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <16 x i8> @llvm.x86.sse42.pcmpestrm128(<16 x i8> %a0, i32 7, <16 x i8> %a2, i32 7, i8 7) ; <<16 x i8>> [#uses=1]
  ret <16 x i8> %res
}
declare <16 x i8> @llvm.x86.sse42.pcmpestrm128(<16 x i8>, i32, <16 x i8>, i32, i8) nounwind readnone


define <16 x i8> @test_x86_sse42_pcmpestrm128_load(<16 x i8> %a0, <16 x i8>* %a2) {
; CHECK-LABEL: test_x86_sse42_pcmpestrm128_load:
; CHECK:       ## BB#0:
; CHECK-NEXT:    movl {{[0-9]+}}(%esp), %ecx ## encoding: [0x8b,0x4c,0x24,0x04]
; CHECK-NEXT:    movl $7, %eax ## encoding: [0xb8,0x07,0x00,0x00,0x00]
; CHECK-NEXT:    movl $7, %edx ## encoding: [0xba,0x07,0x00,0x00,0x00]
; CHECK-NEXT:    vpcmpestrm $7, (%ecx), %xmm0 ## encoding: [0xc4,0xe3,0x79,0x60,0x01,0x07]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %1 = load <16 x i8>, <16 x i8>* %a2
  %res = call <16 x i8> @llvm.x86.sse42.pcmpestrm128(<16 x i8> %a0, i32 7, <16 x i8> %1, i32 7, i8 7) ; <<16 x i8>> [#uses=1]
  ret <16 x i8> %res
}


define i32 @test_x86_sse42_pcmpistri128(<16 x i8> %a0, <16 x i8> %a1) {
; CHECK-LABEL: test_x86_sse42_pcmpistri128:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vpcmpistri $7, %xmm1, %xmm0 ## encoding: [0xc4,0xe3,0x79,0x63,0xc1,0x07]
; CHECK-NEXT:    movl %ecx, %eax ## encoding: [0x89,0xc8]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call i32 @llvm.x86.sse42.pcmpistri128(<16 x i8> %a0, <16 x i8> %a1, i8 7) ; <i32> [#uses=1]
  ret i32 %res
}
declare i32 @llvm.x86.sse42.pcmpistri128(<16 x i8>, <16 x i8>, i8) nounwind readnone


define i32 @test_x86_sse42_pcmpistri128_load(<16 x i8>* %a0, <16 x i8>* %a1) {
; AVX-LABEL: test_x86_sse42_pcmpistri128_load:
; AVX:       ## BB#0:
; AVX-NEXT:    movl {{[0-9]+}}(%esp), %eax ## encoding: [0x8b,0x44,0x24,0x08]
; AVX-NEXT:    movl {{[0-9]+}}(%esp), %ecx ## encoding: [0x8b,0x4c,0x24,0x04]
; AVX-NEXT:    vmovdqa (%ecx), %xmm0 ## encoding: [0xc5,0xf9,0x6f,0x01]
; AVX-NEXT:    vpcmpistri $7, (%eax), %xmm0 ## encoding: [0xc4,0xe3,0x79,0x63,0x00,0x07]
; AVX-NEXT:    movl %ecx, %eax ## encoding: [0x89,0xc8]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_sse42_pcmpistri128_load:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    movl {{[0-9]+}}(%esp), %eax ## encoding: [0x8b,0x44,0x24,0x08]
; AVX512VL-NEXT:    movl {{[0-9]+}}(%esp), %ecx ## encoding: [0x8b,0x4c,0x24,0x04]
; AVX512VL-NEXT:    vmovdqu (%ecx), %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xfa,0x6f,0x01]
; AVX512VL-NEXT:    vpcmpistri $7, (%eax), %xmm0 ## encoding: [0xc4,0xe3,0x79,0x63,0x00,0x07]
; AVX512VL-NEXT:    movl %ecx, %eax ## encoding: [0x89,0xc8]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %1 = load <16 x i8>, <16 x i8>* %a0
  %2 = load <16 x i8>, <16 x i8>* %a1
  %res = call i32 @llvm.x86.sse42.pcmpistri128(<16 x i8> %1, <16 x i8> %2, i8 7) ; <i32> [#uses=1]
  ret i32 %res
}


define i32 @test_x86_sse42_pcmpistria128(<16 x i8> %a0, <16 x i8> %a1) {
; CHECK-LABEL: test_x86_sse42_pcmpistria128:
; CHECK:       ## BB#0:
; CHECK-NEXT:    xorl %eax, %eax ## encoding: [0x31,0xc0]
; CHECK-NEXT:    vpcmpistri $7, %xmm1, %xmm0 ## encoding: [0xc4,0xe3,0x79,0x63,0xc1,0x07]
; CHECK-NEXT:    seta %al ## encoding: [0x0f,0x97,0xc0]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call i32 @llvm.x86.sse42.pcmpistria128(<16 x i8> %a0, <16 x i8> %a1, i8 7) ; <i32> [#uses=1]
  ret i32 %res
}
declare i32 @llvm.x86.sse42.pcmpistria128(<16 x i8>, <16 x i8>, i8) nounwind readnone


define i32 @test_x86_sse42_pcmpistric128(<16 x i8> %a0, <16 x i8> %a1) {
; CHECK-LABEL: test_x86_sse42_pcmpistric128:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vpcmpistri $7, %xmm1, %xmm0 ## encoding: [0xc4,0xe3,0x79,0x63,0xc1,0x07]
; CHECK-NEXT:    sbbl %eax, %eax ## encoding: [0x19,0xc0]
; CHECK-NEXT:    andl $1, %eax ## encoding: [0x83,0xe0,0x01]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call i32 @llvm.x86.sse42.pcmpistric128(<16 x i8> %a0, <16 x i8> %a1, i8 7) ; <i32> [#uses=1]
  ret i32 %res
}
declare i32 @llvm.x86.sse42.pcmpistric128(<16 x i8>, <16 x i8>, i8) nounwind readnone


define i32 @test_x86_sse42_pcmpistrio128(<16 x i8> %a0, <16 x i8> %a1) {
; CHECK-LABEL: test_x86_sse42_pcmpistrio128:
; CHECK:       ## BB#0:
; CHECK-NEXT:    xorl %eax, %eax ## encoding: [0x31,0xc0]
; CHECK-NEXT:    vpcmpistri $7, %xmm1, %xmm0 ## encoding: [0xc4,0xe3,0x79,0x63,0xc1,0x07]
; CHECK-NEXT:    seto %al ## encoding: [0x0f,0x90,0xc0]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call i32 @llvm.x86.sse42.pcmpistrio128(<16 x i8> %a0, <16 x i8> %a1, i8 7) ; <i32> [#uses=1]
  ret i32 %res
}
declare i32 @llvm.x86.sse42.pcmpistrio128(<16 x i8>, <16 x i8>, i8) nounwind readnone


define i32 @test_x86_sse42_pcmpistris128(<16 x i8> %a0, <16 x i8> %a1) {
; CHECK-LABEL: test_x86_sse42_pcmpistris128:
; CHECK:       ## BB#0:
; CHECK-NEXT:    xorl %eax, %eax ## encoding: [0x31,0xc0]
; CHECK-NEXT:    vpcmpistri $7, %xmm1, %xmm0 ## encoding: [0xc4,0xe3,0x79,0x63,0xc1,0x07]
; CHECK-NEXT:    sets %al ## encoding: [0x0f,0x98,0xc0]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call i32 @llvm.x86.sse42.pcmpistris128(<16 x i8> %a0, <16 x i8> %a1, i8 7) ; <i32> [#uses=1]
  ret i32 %res
}
declare i32 @llvm.x86.sse42.pcmpistris128(<16 x i8>, <16 x i8>, i8) nounwind readnone


define i32 @test_x86_sse42_pcmpistriz128(<16 x i8> %a0, <16 x i8> %a1) {
; CHECK-LABEL: test_x86_sse42_pcmpistriz128:
; CHECK:       ## BB#0:
; CHECK-NEXT:    xorl %eax, %eax ## encoding: [0x31,0xc0]
; CHECK-NEXT:    vpcmpistri $7, %xmm1, %xmm0 ## encoding: [0xc4,0xe3,0x79,0x63,0xc1,0x07]
; CHECK-NEXT:    sete %al ## encoding: [0x0f,0x94,0xc0]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call i32 @llvm.x86.sse42.pcmpistriz128(<16 x i8> %a0, <16 x i8> %a1, i8 7) ; <i32> [#uses=1]
  ret i32 %res
}
declare i32 @llvm.x86.sse42.pcmpistriz128(<16 x i8>, <16 x i8>, i8) nounwind readnone


define <16 x i8> @test_x86_sse42_pcmpistrm128(<16 x i8> %a0, <16 x i8> %a1) {
; CHECK-LABEL: test_x86_sse42_pcmpistrm128:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vpcmpistrm $7, %xmm1, %xmm0 ## encoding: [0xc4,0xe3,0x79,0x62,0xc1,0x07]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <16 x i8> @llvm.x86.sse42.pcmpistrm128(<16 x i8> %a0, <16 x i8> %a1, i8 7) ; <<16 x i8>> [#uses=1]
  ret <16 x i8> %res
}
declare <16 x i8> @llvm.x86.sse42.pcmpistrm128(<16 x i8>, <16 x i8>, i8) nounwind readnone


define <16 x i8> @test_x86_sse42_pcmpistrm128_load(<16 x i8> %a0, <16 x i8>* %a1) {
; CHECK-LABEL: test_x86_sse42_pcmpistrm128_load:
; CHECK:       ## BB#0:
; CHECK-NEXT:    movl {{[0-9]+}}(%esp), %eax ## encoding: [0x8b,0x44,0x24,0x04]
; CHECK-NEXT:    vpcmpistrm $7, (%eax), %xmm0 ## encoding: [0xc4,0xe3,0x79,0x62,0x00,0x07]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %1 = load <16 x i8>, <16 x i8>* %a1
  %res = call <16 x i8> @llvm.x86.sse42.pcmpistrm128(<16 x i8> %a0, <16 x i8> %1, i8 7) ; <<16 x i8>> [#uses=1]
  ret <16 x i8> %res
}


define <16 x i8> @test_x86_ssse3_pabs_b_128(<16 x i8> %a0) {
; AVX-LABEL: test_x86_ssse3_pabs_b_128:
; AVX:       ## BB#0:
; AVX-NEXT:    vpabsb %xmm0, %xmm0 ## encoding: [0xc4,0xe2,0x79,0x1c,0xc0]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_ssse3_pabs_b_128:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpabsb %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc4,0xe2,0x79,0x1c,0xc0]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <16 x i8> @llvm.x86.ssse3.pabs.b.128(<16 x i8> %a0) ; <<16 x i8>> [#uses=1]
  ret <16 x i8> %res
}
declare <16 x i8> @llvm.x86.ssse3.pabs.b.128(<16 x i8>) nounwind readnone


define <4 x i32> @test_x86_ssse3_pabs_d_128(<4 x i32> %a0) {
; AVX-LABEL: test_x86_ssse3_pabs_d_128:
; AVX:       ## BB#0:
; AVX-NEXT:    vpabsd %xmm0, %xmm0 ## encoding: [0xc4,0xe2,0x79,0x1e,0xc0]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_ssse3_pabs_d_128:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpabsd %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc4,0xe2,0x79,0x1e,0xc0]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <4 x i32> @llvm.x86.ssse3.pabs.d.128(<4 x i32> %a0) ; <<4 x i32>> [#uses=1]
  ret <4 x i32> %res
}
declare <4 x i32> @llvm.x86.ssse3.pabs.d.128(<4 x i32>) nounwind readnone


define <8 x i16> @test_x86_ssse3_pabs_w_128(<8 x i16> %a0) {
; AVX-LABEL: test_x86_ssse3_pabs_w_128:
; AVX:       ## BB#0:
; AVX-NEXT:    vpabsw %xmm0, %xmm0 ## encoding: [0xc4,0xe2,0x79,0x1d,0xc0]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_ssse3_pabs_w_128:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpabsw %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc4,0xe2,0x79,0x1d,0xc0]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <8 x i16> @llvm.x86.ssse3.pabs.w.128(<8 x i16> %a0) ; <<8 x i16>> [#uses=1]
  ret <8 x i16> %res
}
declare <8 x i16> @llvm.x86.ssse3.pabs.w.128(<8 x i16>) nounwind readnone


define <4 x i32> @test_x86_ssse3_phadd_d_128(<4 x i32> %a0, <4 x i32> %a1) {
; CHECK-LABEL: test_x86_ssse3_phadd_d_128:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vphaddd %xmm1, %xmm0, %xmm0 ## encoding: [0xc4,0xe2,0x79,0x02,0xc1]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <4 x i32> @llvm.x86.ssse3.phadd.d.128(<4 x i32> %a0, <4 x i32> %a1) ; <<4 x i32>> [#uses=1]
  ret <4 x i32> %res
}
declare <4 x i32> @llvm.x86.ssse3.phadd.d.128(<4 x i32>, <4 x i32>) nounwind readnone


define <8 x i16> @test_x86_ssse3_phadd_sw_128(<8 x i16> %a0, <8 x i16> %a1) {
; CHECK-LABEL: test_x86_ssse3_phadd_sw_128:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vphaddsw %xmm1, %xmm0, %xmm0 ## encoding: [0xc4,0xe2,0x79,0x03,0xc1]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <8 x i16> @llvm.x86.ssse3.phadd.sw.128(<8 x i16> %a0, <8 x i16> %a1) ; <<8 x i16>> [#uses=1]
  ret <8 x i16> %res
}
declare <8 x i16> @llvm.x86.ssse3.phadd.sw.128(<8 x i16>, <8 x i16>) nounwind readnone


define <8 x i16> @test_x86_ssse3_phadd_w_128(<8 x i16> %a0, <8 x i16> %a1) {
; CHECK-LABEL: test_x86_ssse3_phadd_w_128:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vphaddw %xmm1, %xmm0, %xmm0 ## encoding: [0xc4,0xe2,0x79,0x01,0xc1]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <8 x i16> @llvm.x86.ssse3.phadd.w.128(<8 x i16> %a0, <8 x i16> %a1) ; <<8 x i16>> [#uses=1]
  ret <8 x i16> %res
}
declare <8 x i16> @llvm.x86.ssse3.phadd.w.128(<8 x i16>, <8 x i16>) nounwind readnone


define <4 x i32> @test_x86_ssse3_phsub_d_128(<4 x i32> %a0, <4 x i32> %a1) {
; CHECK-LABEL: test_x86_ssse3_phsub_d_128:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vphsubd %xmm1, %xmm0, %xmm0 ## encoding: [0xc4,0xe2,0x79,0x06,0xc1]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <4 x i32> @llvm.x86.ssse3.phsub.d.128(<4 x i32> %a0, <4 x i32> %a1) ; <<4 x i32>> [#uses=1]
  ret <4 x i32> %res
}
declare <4 x i32> @llvm.x86.ssse3.phsub.d.128(<4 x i32>, <4 x i32>) nounwind readnone


define <8 x i16> @test_x86_ssse3_phsub_sw_128(<8 x i16> %a0, <8 x i16> %a1) {
; CHECK-LABEL: test_x86_ssse3_phsub_sw_128:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vphsubsw %xmm1, %xmm0, %xmm0 ## encoding: [0xc4,0xe2,0x79,0x07,0xc1]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <8 x i16> @llvm.x86.ssse3.phsub.sw.128(<8 x i16> %a0, <8 x i16> %a1) ; <<8 x i16>> [#uses=1]
  ret <8 x i16> %res
}
declare <8 x i16> @llvm.x86.ssse3.phsub.sw.128(<8 x i16>, <8 x i16>) nounwind readnone


define <8 x i16> @test_x86_ssse3_phsub_w_128(<8 x i16> %a0, <8 x i16> %a1) {
; CHECK-LABEL: test_x86_ssse3_phsub_w_128:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vphsubw %xmm1, %xmm0, %xmm0 ## encoding: [0xc4,0xe2,0x79,0x05,0xc1]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <8 x i16> @llvm.x86.ssse3.phsub.w.128(<8 x i16> %a0, <8 x i16> %a1) ; <<8 x i16>> [#uses=1]
  ret <8 x i16> %res
}
declare <8 x i16> @llvm.x86.ssse3.phsub.w.128(<8 x i16>, <8 x i16>) nounwind readnone


define <8 x i16> @test_x86_ssse3_pmadd_ub_sw_128(<16 x i8> %a0, <16 x i8> %a1) {
; AVX-LABEL: test_x86_ssse3_pmadd_ub_sw_128:
; AVX:       ## BB#0:
; AVX-NEXT:    vpmaddubsw %xmm1, %xmm0, %xmm0 ## encoding: [0xc4,0xe2,0x79,0x04,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_ssse3_pmadd_ub_sw_128:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpmaddubsw %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc4,0xe2,0x79,0x04,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <8 x i16> @llvm.x86.ssse3.pmadd.ub.sw.128(<16 x i8> %a0, <16 x i8> %a1) ; <<8 x i16>> [#uses=1]
  ret <8 x i16> %res
}
declare <8 x i16> @llvm.x86.ssse3.pmadd.ub.sw.128(<16 x i8>, <16 x i8>) nounwind readnone


; Make sure we don't commute this operation.
define <8 x i16> @test_x86_ssse3_pmadd_ub_sw_128_load_op0(<16 x i8>* %ptr, <16 x i8> %a1) {
; AVX-LABEL: test_x86_ssse3_pmadd_ub_sw_128_load_op0:
; AVX:       ## BB#0:
; AVX-NEXT:    movl {{[0-9]+}}(%esp), %eax ## encoding: [0x8b,0x44,0x24,0x04]
; AVX-NEXT:    vmovdqa (%eax), %xmm1 ## encoding: [0xc5,0xf9,0x6f,0x08]
; AVX-NEXT:    vpmaddubsw %xmm0, %xmm1, %xmm0 ## encoding: [0xc4,0xe2,0x71,0x04,0xc0]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_ssse3_pmadd_ub_sw_128_load_op0:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    movl {{[0-9]+}}(%esp), %eax ## encoding: [0x8b,0x44,0x24,0x04]
; AVX512VL-NEXT:    vmovdqu (%eax), %xmm1 ## EVEX TO VEX Compression encoding: [0xc5,0xfa,0x6f,0x08]
; AVX512VL-NEXT:    vpmaddubsw %xmm0, %xmm1, %xmm0 ## EVEX TO VEX Compression encoding: [0xc4,0xe2,0x71,0x04,0xc0]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %a0 = load <16 x i8>, <16 x i8>* %ptr
  %res = call <8 x i16> @llvm.x86.ssse3.pmadd.ub.sw.128(<16 x i8> %a0, <16 x i8> %a1) ; <<8 x i16>> [#uses=1]
  ret <8 x i16> %res
}


define <8 x i16> @test_x86_ssse3_pmul_hr_sw_128(<8 x i16> %a0, <8 x i16> %a1) {
; AVX-LABEL: test_x86_ssse3_pmul_hr_sw_128:
; AVX:       ## BB#0:
; AVX-NEXT:    vpmulhrsw %xmm1, %xmm0, %xmm0 ## encoding: [0xc4,0xe2,0x79,0x0b,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_ssse3_pmul_hr_sw_128:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpmulhrsw %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc4,0xe2,0x79,0x0b,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <8 x i16> @llvm.x86.ssse3.pmul.hr.sw.128(<8 x i16> %a0, <8 x i16> %a1) ; <<8 x i16>> [#uses=1]
  ret <8 x i16> %res
}
declare <8 x i16> @llvm.x86.ssse3.pmul.hr.sw.128(<8 x i16>, <8 x i16>) nounwind readnone


define <16 x i8> @test_x86_ssse3_pshuf_b_128(<16 x i8> %a0, <16 x i8> %a1) {
; AVX-LABEL: test_x86_ssse3_pshuf_b_128:
; AVX:       ## BB#0:
; AVX-NEXT:    vpshufb %xmm1, %xmm0, %xmm0 ## encoding: [0xc4,0xe2,0x79,0x00,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_ssse3_pshuf_b_128:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpshufb %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc4,0xe2,0x79,0x00,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %a0, <16 x i8> %a1) ; <<16 x i8>> [#uses=1]
  ret <16 x i8> %res
}
declare <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8>, <16 x i8>) nounwind readnone


define <16 x i8> @test_x86_ssse3_psign_b_128(<16 x i8> %a0, <16 x i8> %a1) {
; CHECK-LABEL: test_x86_ssse3_psign_b_128:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vpsignb %xmm1, %xmm0, %xmm0 ## encoding: [0xc4,0xe2,0x79,0x08,0xc1]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <16 x i8> @llvm.x86.ssse3.psign.b.128(<16 x i8> %a0, <16 x i8> %a1) ; <<16 x i8>> [#uses=1]
  ret <16 x i8> %res
}
declare <16 x i8> @llvm.x86.ssse3.psign.b.128(<16 x i8>, <16 x i8>) nounwind readnone


define <4 x i32> @test_x86_ssse3_psign_d_128(<4 x i32> %a0, <4 x i32> %a1) {
; CHECK-LABEL: test_x86_ssse3_psign_d_128:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vpsignd %xmm1, %xmm0, %xmm0 ## encoding: [0xc4,0xe2,0x79,0x0a,0xc1]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <4 x i32> @llvm.x86.ssse3.psign.d.128(<4 x i32> %a0, <4 x i32> %a1) ; <<4 x i32>> [#uses=1]
  ret <4 x i32> %res
}
declare <4 x i32> @llvm.x86.ssse3.psign.d.128(<4 x i32>, <4 x i32>) nounwind readnone


define <8 x i16> @test_x86_ssse3_psign_w_128(<8 x i16> %a0, <8 x i16> %a1) {
; CHECK-LABEL: test_x86_ssse3_psign_w_128:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vpsignw %xmm1, %xmm0, %xmm0 ## encoding: [0xc4,0xe2,0x79,0x09,0xc1]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <8 x i16> @llvm.x86.ssse3.psign.w.128(<8 x i16> %a0, <8 x i16> %a1) ; <<8 x i16>> [#uses=1]
  ret <8 x i16> %res
}
declare <8 x i16> @llvm.x86.ssse3.psign.w.128(<8 x i16>, <8 x i16>) nounwind readnone


define <4 x double> @test_x86_avx_addsub_pd_256(<4 x double> %a0, <4 x double> %a1) {
; CHECK-LABEL: test_x86_avx_addsub_pd_256:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vaddsubpd %ymm1, %ymm0, %ymm0 ## encoding: [0xc5,0xfd,0xd0,0xc1]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <4 x double> @llvm.x86.avx.addsub.pd.256(<4 x double> %a0, <4 x double> %a1) ; <<4 x double>> [#uses=1]
  ret <4 x double> %res
}
declare <4 x double> @llvm.x86.avx.addsub.pd.256(<4 x double>, <4 x double>) nounwind readnone


define <8 x float> @test_x86_avx_addsub_ps_256(<8 x float> %a0, <8 x float> %a1) {
; CHECK-LABEL: test_x86_avx_addsub_ps_256:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vaddsubps %ymm1, %ymm0, %ymm0 ## encoding: [0xc5,0xff,0xd0,0xc1]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <8 x float> @llvm.x86.avx.addsub.ps.256(<8 x float> %a0, <8 x float> %a1) ; <<8 x float>> [#uses=1]
  ret <8 x float> %res
}
declare <8 x float> @llvm.x86.avx.addsub.ps.256(<8 x float>, <8 x float>) nounwind readnone


define <4 x double> @test_x86_avx_blendv_pd_256(<4 x double> %a0, <4 x double> %a1, <4 x double> %a2) {
; CHECK-LABEL: test_x86_avx_blendv_pd_256:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vblendvpd %ymm2, %ymm1, %ymm0, %ymm0 ## encoding: [0xc4,0xe3,0x7d,0x4b,0xc1,0x20]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <4 x double> @llvm.x86.avx.blendv.pd.256(<4 x double> %a0, <4 x double> %a1, <4 x double> %a2) ; <<4 x double>> [#uses=1]
  ret <4 x double> %res
}
declare <4 x double> @llvm.x86.avx.blendv.pd.256(<4 x double>, <4 x double>, <4 x double>) nounwind readnone


define <8 x float> @test_x86_avx_blendv_ps_256(<8 x float> %a0, <8 x float> %a1, <8 x float> %a2) {
; CHECK-LABEL: test_x86_avx_blendv_ps_256:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vblendvps %ymm2, %ymm1, %ymm0, %ymm0 ## encoding: [0xc4,0xe3,0x7d,0x4a,0xc1,0x20]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <8 x float> @llvm.x86.avx.blendv.ps.256(<8 x float> %a0, <8 x float> %a1, <8 x float> %a2) ; <<8 x float>> [#uses=1]
  ret <8 x float> %res
}
declare <8 x float> @llvm.x86.avx.blendv.ps.256(<8 x float>, <8 x float>, <8 x float>) nounwind readnone


define <4 x double> @test_x86_avx_cmp_pd_256(<4 x double> %a0, <4 x double> %a1) {
; CHECK-LABEL: test_x86_avx_cmp_pd_256:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vcmpordpd %ymm1, %ymm0, %ymm0 ## encoding: [0xc5,0xfd,0xc2,0xc1,0x07]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <4 x double> @llvm.x86.avx.cmp.pd.256(<4 x double> %a0, <4 x double> %a1, i8 7) ; <<4 x double>> [#uses=1]
  ret <4 x double> %res
}
declare <4 x double> @llvm.x86.avx.cmp.pd.256(<4 x double>, <4 x double>, i8) nounwind readnone


define <8 x float> @test_x86_avx_cmp_ps_256(<8 x float> %a0, <8 x float> %a1) {
; CHECK-LABEL: test_x86_avx_cmp_ps_256:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vcmpordps %ymm1, %ymm0, %ymm0 ## encoding: [0xc5,0xfc,0xc2,0xc1,0x07]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <8 x float> @llvm.x86.avx.cmp.ps.256(<8 x float> %a0, <8 x float> %a1, i8 7) ; <<8 x float>> [#uses=1]
  ret <8 x float> %res
}

define <8 x float> @test_x86_avx_cmp_ps_256_pseudo_op(<8 x float> %a0, <8 x float> %a1) {
; CHECK-LABEL: test_x86_avx_cmp_ps_256_pseudo_op:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vcmpeqps %ymm1, %ymm0, %ymm1 ## encoding: [0xc5,0xfc,0xc2,0xc9,0x00]
; CHECK-NEXT:    vcmpltps %ymm1, %ymm0, %ymm1 ## encoding: [0xc5,0xfc,0xc2,0xc9,0x01]
; CHECK-NEXT:    vcmpleps %ymm1, %ymm0, %ymm1 ## encoding: [0xc5,0xfc,0xc2,0xc9,0x02]
; CHECK-NEXT:    vcmpunordps %ymm1, %ymm0, %ymm1 ## encoding: [0xc5,0xfc,0xc2,0xc9,0x03]
; CHECK-NEXT:    vcmpneqps %ymm1, %ymm0, %ymm1 ## encoding: [0xc5,0xfc,0xc2,0xc9,0x04]
; CHECK-NEXT:    vcmpnltps %ymm1, %ymm0, %ymm1 ## encoding: [0xc5,0xfc,0xc2,0xc9,0x05]
; CHECK-NEXT:    vcmpnleps %ymm1, %ymm0, %ymm1 ## encoding: [0xc5,0xfc,0xc2,0xc9,0x06]
; CHECK-NEXT:    vcmpordps %ymm1, %ymm0, %ymm1 ## encoding: [0xc5,0xfc,0xc2,0xc9,0x07]
; CHECK-NEXT:    vcmpeq_uqps %ymm1, %ymm0, %ymm1 ## encoding: [0xc5,0xfc,0xc2,0xc9,0x08]
; CHECK-NEXT:    vcmpngeps %ymm1, %ymm0, %ymm1 ## encoding: [0xc5,0xfc,0xc2,0xc9,0x09]
; CHECK-NEXT:    vcmpngtps %ymm1, %ymm0, %ymm1 ## encoding: [0xc5,0xfc,0xc2,0xc9,0x0a]
; CHECK-NEXT:    vcmpfalseps %ymm1, %ymm0, %ymm1 ## encoding: [0xc5,0xfc,0xc2,0xc9,0x0b]
; CHECK-NEXT:    vcmpneq_oqps %ymm1, %ymm0, %ymm1 ## encoding: [0xc5,0xfc,0xc2,0xc9,0x0c]
; CHECK-NEXT:    vcmpgeps %ymm1, %ymm0, %ymm1 ## encoding: [0xc5,0xfc,0xc2,0xc9,0x0d]
; CHECK-NEXT:    vcmpgtps %ymm1, %ymm0, %ymm1 ## encoding: [0xc5,0xfc,0xc2,0xc9,0x0e]
; CHECK-NEXT:    vcmptrueps %ymm1, %ymm0, %ymm1 ## encoding: [0xc5,0xfc,0xc2,0xc9,0x0f]
; CHECK-NEXT:    vcmpeq_osps %ymm1, %ymm0, %ymm1 ## encoding: [0xc5,0xfc,0xc2,0xc9,0x10]
; CHECK-NEXT:    vcmplt_oqps %ymm1, %ymm0, %ymm1 ## encoding: [0xc5,0xfc,0xc2,0xc9,0x11]
; CHECK-NEXT:    vcmple_oqps %ymm1, %ymm0, %ymm1 ## encoding: [0xc5,0xfc,0xc2,0xc9,0x12]
; CHECK-NEXT:    vcmpunord_sps %ymm1, %ymm0, %ymm1 ## encoding: [0xc5,0xfc,0xc2,0xc9,0x13]
; CHECK-NEXT:    vcmpneq_usps %ymm1, %ymm0, %ymm1 ## encoding: [0xc5,0xfc,0xc2,0xc9,0x14]
; CHECK-NEXT:    vcmpnlt_uqps %ymm1, %ymm0, %ymm1 ## encoding: [0xc5,0xfc,0xc2,0xc9,0x15]
; CHECK-NEXT:    vcmpnle_uqps %ymm1, %ymm0, %ymm1 ## encoding: [0xc5,0xfc,0xc2,0xc9,0x16]
; CHECK-NEXT:    vcmpord_sps %ymm1, %ymm0, %ymm1 ## encoding: [0xc5,0xfc,0xc2,0xc9,0x17]
; CHECK-NEXT:    vcmpeq_usps %ymm1, %ymm0, %ymm1 ## encoding: [0xc5,0xfc,0xc2,0xc9,0x18]
; CHECK-NEXT:    vcmpnge_uqps %ymm1, %ymm0, %ymm1 ## encoding: [0xc5,0xfc,0xc2,0xc9,0x19]
; CHECK-NEXT:    vcmpngt_uqps %ymm1, %ymm0, %ymm1 ## encoding: [0xc5,0xfc,0xc2,0xc9,0x1a]
; CHECK-NEXT:    vcmpfalse_osps %ymm1, %ymm0, %ymm1 ## encoding: [0xc5,0xfc,0xc2,0xc9,0x1b]
; CHECK-NEXT:    vcmpneq_osps %ymm1, %ymm0, %ymm1 ## encoding: [0xc5,0xfc,0xc2,0xc9,0x1c]
; CHECK-NEXT:    vcmpge_oqps %ymm1, %ymm0, %ymm1 ## encoding: [0xc5,0xfc,0xc2,0xc9,0x1d]
; CHECK-NEXT:    vcmpgt_oqps %ymm1, %ymm0, %ymm1 ## encoding: [0xc5,0xfc,0xc2,0xc9,0x1e]
; CHECK-NEXT:    vcmptrue_usps %ymm1, %ymm0, %ymm0 ## encoding: [0xc5,0xfc,0xc2,0xc1,0x1f]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %a2 = call <8 x float> @llvm.x86.avx.cmp.ps.256(<8 x float> %a0, <8 x float> %a1, i8 0) ; <<8 x float>> [#uses=1]
  %a3 = call <8 x float> @llvm.x86.avx.cmp.ps.256(<8 x float> %a0, <8 x float> %a2, i8 1) ; <<8 x float>> [#uses=1]
  %a4 = call <8 x float> @llvm.x86.avx.cmp.ps.256(<8 x float> %a0, <8 x float> %a3, i8 2) ; <<8 x float>> [#uses=1]
  %a5 = call <8 x float> @llvm.x86.avx.cmp.ps.256(<8 x float> %a0, <8 x float> %a4, i8 3) ; <<8 x float>> [#uses=1]
  %a6 = call <8 x float> @llvm.x86.avx.cmp.ps.256(<8 x float> %a0, <8 x float> %a5, i8 4) ; <<8 x float>> [#uses=1]
  %a7 = call <8 x float> @llvm.x86.avx.cmp.ps.256(<8 x float> %a0, <8 x float> %a6, i8 5) ; <<8 x float>> [#uses=1]
  %a8 = call <8 x float> @llvm.x86.avx.cmp.ps.256(<8 x float> %a0, <8 x float> %a7, i8 6) ; <<8 x float>> [#uses=1]
  %a9 = call <8 x float> @llvm.x86.avx.cmp.ps.256(<8 x float> %a0, <8 x float> %a8, i8 7) ; <<8 x float>> [#uses=1]
  %a10 = call <8 x float> @llvm.x86.avx.cmp.ps.256(<8 x float> %a0, <8 x float> %a9, i8 8) ; <<8 x float>> [#uses=1]
  %a11 = call <8 x float> @llvm.x86.avx.cmp.ps.256(<8 x float> %a0, <8 x float> %a10, i8 9) ; <<8 x float>> [#uses=1]
  %a12 = call <8 x float> @llvm.x86.avx.cmp.ps.256(<8 x float> %a0, <8 x float> %a11, i8 10) ; <<8 x float>> [#uses=1]
  %a13 = call <8 x float> @llvm.x86.avx.cmp.ps.256(<8 x float> %a0, <8 x float> %a12, i8 11) ; <<8 x float>> [#uses=1]
  %a14 = call <8 x float> @llvm.x86.avx.cmp.ps.256(<8 x float> %a0, <8 x float> %a13, i8 12) ; <<8 x float>> [#uses=1]
  %a15 = call <8 x float> @llvm.x86.avx.cmp.ps.256(<8 x float> %a0, <8 x float> %a14, i8 13) ; <<8 x float>> [#uses=1]
  %a16 = call <8 x float> @llvm.x86.avx.cmp.ps.256(<8 x float> %a0, <8 x float> %a15, i8 14) ; <<8 x float>> [#uses=1]
  %a17 = call <8 x float> @llvm.x86.avx.cmp.ps.256(<8 x float> %a0, <8 x float> %a16, i8 15) ; <<8 x float>> [#uses=1]
  %a18 = call <8 x float> @llvm.x86.avx.cmp.ps.256(<8 x float> %a0, <8 x float> %a17, i8 16) ; <<8 x float>> [#uses=1]
  %a19 = call <8 x float> @llvm.x86.avx.cmp.ps.256(<8 x float> %a0, <8 x float> %a18, i8 17) ; <<8 x float>> [#uses=1]
  %a20 = call <8 x float> @llvm.x86.avx.cmp.ps.256(<8 x float> %a0, <8 x float> %a19, i8 18) ; <<8 x float>> [#uses=1]
  %a21 = call <8 x float> @llvm.x86.avx.cmp.ps.256(<8 x float> %a0, <8 x float> %a20, i8 19) ; <<8 x float>> [#uses=1]
  %a22 = call <8 x float> @llvm.x86.avx.cmp.ps.256(<8 x float> %a0, <8 x float> %a21, i8 20) ; <<8 x float>> [#uses=1]
  %a23 = call <8 x float> @llvm.x86.avx.cmp.ps.256(<8 x float> %a0, <8 x float> %a22, i8 21) ; <<8 x float>> [#uses=1]
  %a24 = call <8 x float> @llvm.x86.avx.cmp.ps.256(<8 x float> %a0, <8 x float> %a23, i8 22) ; <<8 x float>> [#uses=1]
  %a25 = call <8 x float> @llvm.x86.avx.cmp.ps.256(<8 x float> %a0, <8 x float> %a24, i8 23) ; <<8 x float>> [#uses=1]
  %a26 = call <8 x float> @llvm.x86.avx.cmp.ps.256(<8 x float> %a0, <8 x float> %a25, i8 24) ; <<8 x float>> [#uses=1]
  %a27 = call <8 x float> @llvm.x86.avx.cmp.ps.256(<8 x float> %a0, <8 x float> %a26, i8 25) ; <<8 x float>> [#uses=1]
  %a28 = call <8 x float> @llvm.x86.avx.cmp.ps.256(<8 x float> %a0, <8 x float> %a27, i8 26) ; <<8 x float>> [#uses=1]
  %a29 = call <8 x float> @llvm.x86.avx.cmp.ps.256(<8 x float> %a0, <8 x float> %a28, i8 27) ; <<8 x float>> [#uses=1]
  %a30 = call <8 x float> @llvm.x86.avx.cmp.ps.256(<8 x float> %a0, <8 x float> %a29, i8 28) ; <<8 x float>> [#uses=1]
  %a31 = call <8 x float> @llvm.x86.avx.cmp.ps.256(<8 x float> %a0, <8 x float> %a30, i8 29) ; <<8 x float>> [#uses=1]
  %a32 = call <8 x float> @llvm.x86.avx.cmp.ps.256(<8 x float> %a0, <8 x float> %a31, i8 30) ; <<8 x float>> [#uses=1]
  %res = call <8 x float> @llvm.x86.avx.cmp.ps.256(<8 x float> %a0, <8 x float> %a32, i8 31) ; <<8 x float>> [#uses=1]
  ret <8 x float> %res
}
declare <8 x float> @llvm.x86.avx.cmp.ps.256(<8 x float>, <8 x float>, i8) nounwind readnone


define <4 x float> @test_x86_avx_cvt_pd2_ps_256(<4 x double> %a0) {
; AVX-LABEL: test_x86_avx_cvt_pd2_ps_256:
; AVX:       ## BB#0:
; AVX-NEXT:    vcvtpd2ps %ymm0, %xmm0 ## encoding: [0xc5,0xfd,0x5a,0xc0]
; AVX-NEXT:    vzeroupper ## encoding: [0xc5,0xf8,0x77]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_avx_cvt_pd2_ps_256:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vcvtpd2ps %ymm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xfd,0x5a,0xc0]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <4 x float> @llvm.x86.avx.cvt.pd2.ps.256(<4 x double> %a0) ; <<4 x float>> [#uses=1]
  ret <4 x float> %res
}
declare <4 x float> @llvm.x86.avx.cvt.pd2.ps.256(<4 x double>) nounwind readnone


define <4 x i32> @test_x86_avx_cvt_pd2dq_256(<4 x double> %a0) {
; AVX-LABEL: test_x86_avx_cvt_pd2dq_256:
; AVX:       ## BB#0:
; AVX-NEXT:    vcvtpd2dq %ymm0, %xmm0 ## encoding: [0xc5,0xff,0xe6,0xc0]
; AVX-NEXT:    vzeroupper ## encoding: [0xc5,0xf8,0x77]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_avx_cvt_pd2dq_256:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vcvtpd2dq %ymm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xff,0xe6,0xc0]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <4 x i32> @llvm.x86.avx.cvt.pd2dq.256(<4 x double> %a0) ; <<4 x i32>> [#uses=1]
  ret <4 x i32> %res
}
declare <4 x i32> @llvm.x86.avx.cvt.pd2dq.256(<4 x double>) nounwind readnone


define <8 x i32> @test_x86_avx_cvt_ps2dq_256(<8 x float> %a0) {
; CHECK-LABEL: test_x86_avx_cvt_ps2dq_256:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vcvtps2dq %ymm0, %ymm0 ## encoding: [0xc5,0xfd,0x5b,0xc0]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <8 x i32> @llvm.x86.avx.cvt.ps2dq.256(<8 x float> %a0) ; <<8 x i32>> [#uses=1]
  ret <8 x i32> %res
}
declare <8 x i32> @llvm.x86.avx.cvt.ps2dq.256(<8 x float>) nounwind readnone


define <8 x float> @test_x86_avx_cvtdq2_ps_256(<8 x i32> %a0) {
; AVX-LABEL: test_x86_avx_cvtdq2_ps_256:
; AVX:       ## BB#0:
; AVX-NEXT:    vcvtdq2ps %ymm0, %ymm0 ## encoding: [0xc5,0xfc,0x5b,0xc0]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_avx_cvtdq2_ps_256:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vcvtdq2ps %ymm0, %ymm0 ## EVEX TO VEX Compression encoding: [0xc5,0xfc,0x5b,0xc0]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <8 x float> @llvm.x86.avx.cvtdq2.ps.256(<8 x i32> %a0) ; <<8 x float>> [#uses=1]
  ret <8 x float> %res
}
declare <8 x float> @llvm.x86.avx.cvtdq2.ps.256(<8 x i32>) nounwind readnone


define <4 x i32> @test_x86_avx_cvtt_pd2dq_256(<4 x double> %a0) {
; AVX-LABEL: test_x86_avx_cvtt_pd2dq_256:
; AVX:       ## BB#0:
; AVX-NEXT:    vcvttpd2dq %ymm0, %xmm0 ## encoding: [0xc5,0xfd,0xe6,0xc0]
; AVX-NEXT:    vzeroupper ## encoding: [0xc5,0xf8,0x77]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_avx_cvtt_pd2dq_256:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vcvttpd2dq %ymm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xfd,0xe6,0xc0]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <4 x i32> @llvm.x86.avx.cvtt.pd2dq.256(<4 x double> %a0) ; <<4 x i32>> [#uses=1]
  ret <4 x i32> %res
}
declare <4 x i32> @llvm.x86.avx.cvtt.pd2dq.256(<4 x double>) nounwind readnone


define <8 x i32> @test_x86_avx_cvtt_ps2dq_256(<8 x float> %a0) {
; AVX-LABEL: test_x86_avx_cvtt_ps2dq_256:
; AVX:       ## BB#0:
; AVX-NEXT:    vcvttps2dq %ymm0, %ymm0 ## encoding: [0xc5,0xfe,0x5b,0xc0]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_avx_cvtt_ps2dq_256:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vcvttps2dq %ymm0, %ymm0 ## EVEX TO VEX Compression encoding: [0xc5,0xfe,0x5b,0xc0]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <8 x i32> @llvm.x86.avx.cvtt.ps2dq.256(<8 x float> %a0) ; <<8 x i32>> [#uses=1]
  ret <8 x i32> %res
}
declare <8 x i32> @llvm.x86.avx.cvtt.ps2dq.256(<8 x float>) nounwind readnone


define <8 x float> @test_x86_avx_dp_ps_256(<8 x float> %a0, <8 x float> %a1) {
; CHECK-LABEL: test_x86_avx_dp_ps_256:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vdpps $7, %ymm1, %ymm0, %ymm0 ## encoding: [0xc4,0xe3,0x7d,0x40,0xc1,0x07]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <8 x float> @llvm.x86.avx.dp.ps.256(<8 x float> %a0, <8 x float> %a1, i8 7) ; <<8 x float>> [#uses=1]
  ret <8 x float> %res
}
declare <8 x float> @llvm.x86.avx.dp.ps.256(<8 x float>, <8 x float>, i8) nounwind readnone


define <4 x double> @test_x86_avx_hadd_pd_256(<4 x double> %a0, <4 x double> %a1) {
; CHECK-LABEL: test_x86_avx_hadd_pd_256:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vhaddpd %ymm1, %ymm0, %ymm0 ## encoding: [0xc5,0xfd,0x7c,0xc1]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <4 x double> @llvm.x86.avx.hadd.pd.256(<4 x double> %a0, <4 x double> %a1) ; <<4 x double>> [#uses=1]
  ret <4 x double> %res
}
declare <4 x double> @llvm.x86.avx.hadd.pd.256(<4 x double>, <4 x double>) nounwind readnone


define <8 x float> @test_x86_avx_hadd_ps_256(<8 x float> %a0, <8 x float> %a1) {
; CHECK-LABEL: test_x86_avx_hadd_ps_256:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vhaddps %ymm1, %ymm0, %ymm0 ## encoding: [0xc5,0xff,0x7c,0xc1]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <8 x float> @llvm.x86.avx.hadd.ps.256(<8 x float> %a0, <8 x float> %a1) ; <<8 x float>> [#uses=1]
  ret <8 x float> %res
}
declare <8 x float> @llvm.x86.avx.hadd.ps.256(<8 x float>, <8 x float>) nounwind readnone


define <4 x double> @test_x86_avx_hsub_pd_256(<4 x double> %a0, <4 x double> %a1) {
; CHECK-LABEL: test_x86_avx_hsub_pd_256:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vhsubpd %ymm1, %ymm0, %ymm0 ## encoding: [0xc5,0xfd,0x7d,0xc1]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <4 x double> @llvm.x86.avx.hsub.pd.256(<4 x double> %a0, <4 x double> %a1) ; <<4 x double>> [#uses=1]
  ret <4 x double> %res
}
declare <4 x double> @llvm.x86.avx.hsub.pd.256(<4 x double>, <4 x double>) nounwind readnone


define <8 x float> @test_x86_avx_hsub_ps_256(<8 x float> %a0, <8 x float> %a1) {
; CHECK-LABEL: test_x86_avx_hsub_ps_256:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vhsubps %ymm1, %ymm0, %ymm0 ## encoding: [0xc5,0xff,0x7d,0xc1]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <8 x float> @llvm.x86.avx.hsub.ps.256(<8 x float> %a0, <8 x float> %a1) ; <<8 x float>> [#uses=1]
  ret <8 x float> %res
}
declare <8 x float> @llvm.x86.avx.hsub.ps.256(<8 x float>, <8 x float>) nounwind readnone


define <32 x i8> @test_x86_avx_ldu_dq_256(i8* %a0) {
; CHECK-LABEL: test_x86_avx_ldu_dq_256:
; CHECK:       ## BB#0:
; CHECK-NEXT:    movl {{[0-9]+}}(%esp), %eax ## encoding: [0x8b,0x44,0x24,0x04]
; CHECK-NEXT:    vlddqu (%eax), %ymm0 ## encoding: [0xc5,0xff,0xf0,0x00]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <32 x i8> @llvm.x86.avx.ldu.dq.256(i8* %a0) ; <<32 x i8>> [#uses=1]
  ret <32 x i8> %res
}
declare <32 x i8> @llvm.x86.avx.ldu.dq.256(i8*) nounwind readonly


define <2 x double> @test_x86_avx_maskload_pd(i8* %a0, <2 x i64> %mask) {
; CHECK-LABEL: test_x86_avx_maskload_pd:
; CHECK:       ## BB#0:
; CHECK-NEXT:    movl {{[0-9]+}}(%esp), %eax ## encoding: [0x8b,0x44,0x24,0x04]
; CHECK-NEXT:    vmaskmovpd (%eax), %xmm0, %xmm0 ## encoding: [0xc4,0xe2,0x79,0x2d,0x00]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <2 x double> @llvm.x86.avx.maskload.pd(i8* %a0, <2 x i64> %mask) ; <<2 x double>> [#uses=1]
  ret <2 x double> %res
}
declare <2 x double> @llvm.x86.avx.maskload.pd(i8*, <2 x i64>) nounwind readonly


define <4 x double> @test_x86_avx_maskload_pd_256(i8* %a0, <4 x i64> %mask) {
; CHECK-LABEL: test_x86_avx_maskload_pd_256:
; CHECK:       ## BB#0:
; CHECK-NEXT:    movl {{[0-9]+}}(%esp), %eax ## encoding: [0x8b,0x44,0x24,0x04]
; CHECK-NEXT:    vmaskmovpd (%eax), %ymm0, %ymm0 ## encoding: [0xc4,0xe2,0x7d,0x2d,0x00]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <4 x double> @llvm.x86.avx.maskload.pd.256(i8* %a0, <4 x i64> %mask) ; <<4 x double>> [#uses=1]
  ret <4 x double> %res
}
declare <4 x double> @llvm.x86.avx.maskload.pd.256(i8*, <4 x i64>) nounwind readonly


define <4 x float> @test_x86_avx_maskload_ps(i8* %a0, <4 x i32> %mask) {
; CHECK-LABEL: test_x86_avx_maskload_ps:
; CHECK:       ## BB#0:
; CHECK-NEXT:    movl {{[0-9]+}}(%esp), %eax ## encoding: [0x8b,0x44,0x24,0x04]
; CHECK-NEXT:    vmaskmovps (%eax), %xmm0, %xmm0 ## encoding: [0xc4,0xe2,0x79,0x2c,0x00]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <4 x float> @llvm.x86.avx.maskload.ps(i8* %a0, <4 x i32> %mask) ; <<4 x float>> [#uses=1]
  ret <4 x float> %res
}
declare <4 x float> @llvm.x86.avx.maskload.ps(i8*, <4 x i32>) nounwind readonly


define <8 x float> @test_x86_avx_maskload_ps_256(i8* %a0, <8 x i32> %mask) {
; CHECK-LABEL: test_x86_avx_maskload_ps_256:
; CHECK:       ## BB#0:
; CHECK-NEXT:    movl {{[0-9]+}}(%esp), %eax ## encoding: [0x8b,0x44,0x24,0x04]
; CHECK-NEXT:    vmaskmovps (%eax), %ymm0, %ymm0 ## encoding: [0xc4,0xe2,0x7d,0x2c,0x00]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <8 x float> @llvm.x86.avx.maskload.ps.256(i8* %a0, <8 x i32> %mask) ; <<8 x float>> [#uses=1]
  ret <8 x float> %res
}
declare <8 x float> @llvm.x86.avx.maskload.ps.256(i8*, <8 x i32>) nounwind readonly


define void @test_x86_avx_maskstore_pd(i8* %a0, <2 x i64> %mask, <2 x double> %a2) {
; CHECK-LABEL: test_x86_avx_maskstore_pd:
; CHECK:       ## BB#0:
; CHECK-NEXT:    movl {{[0-9]+}}(%esp), %eax ## encoding: [0x8b,0x44,0x24,0x04]
; CHECK-NEXT:    vmaskmovpd %xmm1, %xmm0, (%eax) ## encoding: [0xc4,0xe2,0x79,0x2f,0x08]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  call void @llvm.x86.avx.maskstore.pd(i8* %a0, <2 x i64> %mask, <2 x double> %a2)
  ret void
}
declare void @llvm.x86.avx.maskstore.pd(i8*, <2 x i64>, <2 x double>) nounwind


define void @test_x86_avx_maskstore_pd_256(i8* %a0, <4 x i64> %mask, <4 x double> %a2) {
; AVX-LABEL: test_x86_avx_maskstore_pd_256:
; AVX:       ## BB#0:
; AVX-NEXT:    movl {{[0-9]+}}(%esp), %eax ## encoding: [0x8b,0x44,0x24,0x04]
; AVX-NEXT:    vmaskmovpd %ymm1, %ymm0, (%eax) ## encoding: [0xc4,0xe2,0x7d,0x2f,0x08]
; AVX-NEXT:    vzeroupper ## encoding: [0xc5,0xf8,0x77]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_avx_maskstore_pd_256:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    movl {{[0-9]+}}(%esp), %eax ## encoding: [0x8b,0x44,0x24,0x04]
; AVX512VL-NEXT:    vmaskmovpd %ymm1, %ymm0, (%eax) ## encoding: [0xc4,0xe2,0x7d,0x2f,0x08]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  call void @llvm.x86.avx.maskstore.pd.256(i8* %a0, <4 x i64> %mask, <4 x double> %a2)
  ret void
}
declare void @llvm.x86.avx.maskstore.pd.256(i8*, <4 x i64>, <4 x double>) nounwind


define void @test_x86_avx_maskstore_ps(i8* %a0, <4 x i32> %mask, <4 x float> %a2) {
; CHECK-LABEL: test_x86_avx_maskstore_ps:
; CHECK:       ## BB#0:
; CHECK-NEXT:    movl {{[0-9]+}}(%esp), %eax ## encoding: [0x8b,0x44,0x24,0x04]
; CHECK-NEXT:    vmaskmovps %xmm1, %xmm0, (%eax) ## encoding: [0xc4,0xe2,0x79,0x2e,0x08]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  call void @llvm.x86.avx.maskstore.ps(i8* %a0, <4 x i32> %mask, <4 x float> %a2)
  ret void
}
declare void @llvm.x86.avx.maskstore.ps(i8*, <4 x i32>, <4 x float>) nounwind


define void @test_x86_avx_maskstore_ps_256(i8* %a0, <8 x i32> %mask, <8 x float> %a2) {
; AVX-LABEL: test_x86_avx_maskstore_ps_256:
; AVX:       ## BB#0:
; AVX-NEXT:    movl {{[0-9]+}}(%esp), %eax ## encoding: [0x8b,0x44,0x24,0x04]
; AVX-NEXT:    vmaskmovps %ymm1, %ymm0, (%eax) ## encoding: [0xc4,0xe2,0x7d,0x2e,0x08]
; AVX-NEXT:    vzeroupper ## encoding: [0xc5,0xf8,0x77]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_avx_maskstore_ps_256:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    movl {{[0-9]+}}(%esp), %eax ## encoding: [0x8b,0x44,0x24,0x04]
; AVX512VL-NEXT:    vmaskmovps %ymm1, %ymm0, (%eax) ## encoding: [0xc4,0xe2,0x7d,0x2e,0x08]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  call void @llvm.x86.avx.maskstore.ps.256(i8* %a0, <8 x i32> %mask, <8 x float> %a2)
  ret void
}
declare void @llvm.x86.avx.maskstore.ps.256(i8*, <8 x i32>, <8 x float>) nounwind


define <4 x double> @test_x86_avx_max_pd_256(<4 x double> %a0, <4 x double> %a1) {
; AVX-LABEL: test_x86_avx_max_pd_256:
; AVX:       ## BB#0:
; AVX-NEXT:    vmaxpd %ymm1, %ymm0, %ymm0 ## encoding: [0xc5,0xfd,0x5f,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_avx_max_pd_256:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vmaxpd %ymm1, %ymm0, %ymm0 ## EVEX TO VEX Compression encoding: [0xc5,0xfd,0x5f,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <4 x double> @llvm.x86.avx.max.pd.256(<4 x double> %a0, <4 x double> %a1) ; <<4 x double>> [#uses=1]
  ret <4 x double> %res
}
declare <4 x double> @llvm.x86.avx.max.pd.256(<4 x double>, <4 x double>) nounwind readnone


define <8 x float> @test_x86_avx_max_ps_256(<8 x float> %a0, <8 x float> %a1) {
; AVX-LABEL: test_x86_avx_max_ps_256:
; AVX:       ## BB#0:
; AVX-NEXT:    vmaxps %ymm1, %ymm0, %ymm0 ## encoding: [0xc5,0xfc,0x5f,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_avx_max_ps_256:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vmaxps %ymm1, %ymm0, %ymm0 ## EVEX TO VEX Compression encoding: [0xc5,0xfc,0x5f,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <8 x float> @llvm.x86.avx.max.ps.256(<8 x float> %a0, <8 x float> %a1) ; <<8 x float>> [#uses=1]
  ret <8 x float> %res
}
declare <8 x float> @llvm.x86.avx.max.ps.256(<8 x float>, <8 x float>) nounwind readnone


define <4 x double> @test_x86_avx_min_pd_256(<4 x double> %a0, <4 x double> %a1) {
; AVX-LABEL: test_x86_avx_min_pd_256:
; AVX:       ## BB#0:
; AVX-NEXT:    vminpd %ymm1, %ymm0, %ymm0 ## encoding: [0xc5,0xfd,0x5d,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_avx_min_pd_256:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vminpd %ymm1, %ymm0, %ymm0 ## EVEX TO VEX Compression encoding: [0xc5,0xfd,0x5d,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <4 x double> @llvm.x86.avx.min.pd.256(<4 x double> %a0, <4 x double> %a1) ; <<4 x double>> [#uses=1]
  ret <4 x double> %res
}
declare <4 x double> @llvm.x86.avx.min.pd.256(<4 x double>, <4 x double>) nounwind readnone


define <8 x float> @test_x86_avx_min_ps_256(<8 x float> %a0, <8 x float> %a1) {
; AVX-LABEL: test_x86_avx_min_ps_256:
; AVX:       ## BB#0:
; AVX-NEXT:    vminps %ymm1, %ymm0, %ymm0 ## encoding: [0xc5,0xfc,0x5d,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_avx_min_ps_256:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vminps %ymm1, %ymm0, %ymm0 ## EVEX TO VEX Compression encoding: [0xc5,0xfc,0x5d,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <8 x float> @llvm.x86.avx.min.ps.256(<8 x float> %a0, <8 x float> %a1) ; <<8 x float>> [#uses=1]
  ret <8 x float> %res
}
declare <8 x float> @llvm.x86.avx.min.ps.256(<8 x float>, <8 x float>) nounwind readnone


define i32 @test_x86_avx_movmsk_pd_256(<4 x double> %a0) {
; AVX-LABEL: test_x86_avx_movmsk_pd_256:
; AVX:       ## BB#0:
; AVX-NEXT:    vmovmskpd %ymm0, %eax ## encoding: [0xc5,0xfd,0x50,0xc0]
; AVX-NEXT:    vzeroupper ## encoding: [0xc5,0xf8,0x77]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_avx_movmsk_pd_256:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vmovmskpd %ymm0, %eax ## encoding: [0xc5,0xfd,0x50,0xc0]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call i32 @llvm.x86.avx.movmsk.pd.256(<4 x double> %a0) ; <i32> [#uses=1]
  ret i32 %res
}
declare i32 @llvm.x86.avx.movmsk.pd.256(<4 x double>) nounwind readnone


define i32 @test_x86_avx_movmsk_ps_256(<8 x float> %a0) {
; AVX-LABEL: test_x86_avx_movmsk_ps_256:
; AVX:       ## BB#0:
; AVX-NEXT:    vmovmskps %ymm0, %eax ## encoding: [0xc5,0xfc,0x50,0xc0]
; AVX-NEXT:    vzeroupper ## encoding: [0xc5,0xf8,0x77]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_avx_movmsk_ps_256:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vmovmskps %ymm0, %eax ## encoding: [0xc5,0xfc,0x50,0xc0]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call i32 @llvm.x86.avx.movmsk.ps.256(<8 x float> %a0) ; <i32> [#uses=1]
  ret i32 %res
}
declare i32 @llvm.x86.avx.movmsk.ps.256(<8 x float>) nounwind readnone







define i32 @test_x86_avx_ptestc_256(<4 x i64> %a0, <4 x i64> %a1) {
; AVX-LABEL: test_x86_avx_ptestc_256:
; AVX:       ## BB#0:
; AVX-NEXT:    vptest %ymm1, %ymm0 ## encoding: [0xc4,0xe2,0x7d,0x17,0xc1]
; AVX-NEXT:    sbbl %eax, %eax ## encoding: [0x19,0xc0]
; AVX-NEXT:    andl $1, %eax ## encoding: [0x83,0xe0,0x01]
; AVX-NEXT:    vzeroupper ## encoding: [0xc5,0xf8,0x77]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_avx_ptestc_256:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vptest %ymm1, %ymm0 ## encoding: [0xc4,0xe2,0x7d,0x17,0xc1]
; AVX512VL-NEXT:    sbbl %eax, %eax ## encoding: [0x19,0xc0]
; AVX512VL-NEXT:    andl $1, %eax ## encoding: [0x83,0xe0,0x01]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call i32 @llvm.x86.avx.ptestc.256(<4 x i64> %a0, <4 x i64> %a1) ; <i32> [#uses=1]
  ret i32 %res
}
declare i32 @llvm.x86.avx.ptestc.256(<4 x i64>, <4 x i64>) nounwind readnone


define i32 @test_x86_avx_ptestnzc_256(<4 x i64> %a0, <4 x i64> %a1) {
; AVX-LABEL: test_x86_avx_ptestnzc_256:
; AVX:       ## BB#0:
; AVX-NEXT:    xorl %eax, %eax ## encoding: [0x31,0xc0]
; AVX-NEXT:    vptest %ymm1, %ymm0 ## encoding: [0xc4,0xe2,0x7d,0x17,0xc1]
; AVX-NEXT:    seta %al ## encoding: [0x0f,0x97,0xc0]
; AVX-NEXT:    vzeroupper ## encoding: [0xc5,0xf8,0x77]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_avx_ptestnzc_256:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    xorl %eax, %eax ## encoding: [0x31,0xc0]
; AVX512VL-NEXT:    vptest %ymm1, %ymm0 ## encoding: [0xc4,0xe2,0x7d,0x17,0xc1]
; AVX512VL-NEXT:    seta %al ## encoding: [0x0f,0x97,0xc0]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call i32 @llvm.x86.avx.ptestnzc.256(<4 x i64> %a0, <4 x i64> %a1) ; <i32> [#uses=1]
  ret i32 %res
}
declare i32 @llvm.x86.avx.ptestnzc.256(<4 x i64>, <4 x i64>) nounwind readnone


define i32 @test_x86_avx_ptestz_256(<4 x i64> %a0, <4 x i64> %a1) {
; AVX-LABEL: test_x86_avx_ptestz_256:
; AVX:       ## BB#0:
; AVX-NEXT:    xorl %eax, %eax ## encoding: [0x31,0xc0]
; AVX-NEXT:    vptest %ymm1, %ymm0 ## encoding: [0xc4,0xe2,0x7d,0x17,0xc1]
; AVX-NEXT:    sete %al ## encoding: [0x0f,0x94,0xc0]
; AVX-NEXT:    vzeroupper ## encoding: [0xc5,0xf8,0x77]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_avx_ptestz_256:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    xorl %eax, %eax ## encoding: [0x31,0xc0]
; AVX512VL-NEXT:    vptest %ymm1, %ymm0 ## encoding: [0xc4,0xe2,0x7d,0x17,0xc1]
; AVX512VL-NEXT:    sete %al ## encoding: [0x0f,0x94,0xc0]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call i32 @llvm.x86.avx.ptestz.256(<4 x i64> %a0, <4 x i64> %a1) ; <i32> [#uses=1]
  ret i32 %res
}
declare i32 @llvm.x86.avx.ptestz.256(<4 x i64>, <4 x i64>) nounwind readnone


define <8 x float> @test_x86_avx_rcp_ps_256(<8 x float> %a0) {
; AVX-LABEL: test_x86_avx_rcp_ps_256:
; AVX:       ## BB#0:
; AVX-NEXT:    vrcpps %ymm0, %ymm0 ## encoding: [0xc5,0xfc,0x53,0xc0]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_avx_rcp_ps_256:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vrcp14ps %ymm0, %ymm0 ## encoding: [0x62,0xf2,0x7d,0x28,0x4c,0xc0]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <8 x float> @llvm.x86.avx.rcp.ps.256(<8 x float> %a0) ; <<8 x float>> [#uses=1]
  ret <8 x float> %res
}
declare <8 x float> @llvm.x86.avx.rcp.ps.256(<8 x float>) nounwind readnone


define <4 x double> @test_x86_avx_round_pd_256(<4 x double> %a0) {
; CHECK-LABEL: test_x86_avx_round_pd_256:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vroundpd $7, %ymm0, %ymm0 ## encoding: [0xc4,0xe3,0x7d,0x09,0xc0,0x07]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <4 x double> @llvm.x86.avx.round.pd.256(<4 x double> %a0, i32 7) ; <<4 x double>> [#uses=1]
  ret <4 x double> %res
}
declare <4 x double> @llvm.x86.avx.round.pd.256(<4 x double>, i32) nounwind readnone


define <8 x float> @test_x86_avx_round_ps_256(<8 x float> %a0) {
; CHECK-LABEL: test_x86_avx_round_ps_256:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vroundps $7, %ymm0, %ymm0 ## encoding: [0xc4,0xe3,0x7d,0x08,0xc0,0x07]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <8 x float> @llvm.x86.avx.round.ps.256(<8 x float> %a0, i32 7) ; <<8 x float>> [#uses=1]
  ret <8 x float> %res
}
declare <8 x float> @llvm.x86.avx.round.ps.256(<8 x float>, i32) nounwind readnone


define <8 x float> @test_x86_avx_rsqrt_ps_256(<8 x float> %a0) {
; AVX-LABEL: test_x86_avx_rsqrt_ps_256:
; AVX:       ## BB#0:
; AVX-NEXT:    vrsqrtps %ymm0, %ymm0 ## encoding: [0xc5,0xfc,0x52,0xc0]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_avx_rsqrt_ps_256:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vrsqrt14ps %ymm0, %ymm0 ## encoding: [0x62,0xf2,0x7d,0x28,0x4e,0xc0]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <8 x float> @llvm.x86.avx.rsqrt.ps.256(<8 x float> %a0) ; <<8 x float>> [#uses=1]
  ret <8 x float> %res
}
declare <8 x float> @llvm.x86.avx.rsqrt.ps.256(<8 x float>) nounwind readnone


define <4 x double> @test_x86_avx_sqrt_pd_256(<4 x double> %a0) {
; CHECK-LABEL: test_x86_avx_sqrt_pd_256:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vsqrtpd %ymm0, %ymm0 ## encoding: [0xc5,0xfd,0x51,0xc0]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <4 x double> @llvm.x86.avx.sqrt.pd.256(<4 x double> %a0) ; <<4 x double>> [#uses=1]
  ret <4 x double> %res
}
declare <4 x double> @llvm.x86.avx.sqrt.pd.256(<4 x double>) nounwind readnone


define <8 x float> @test_x86_avx_sqrt_ps_256(<8 x float> %a0) {
; CHECK-LABEL: test_x86_avx_sqrt_ps_256:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vsqrtps %ymm0, %ymm0 ## encoding: [0xc5,0xfc,0x51,0xc0]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <8 x float> @llvm.x86.avx.sqrt.ps.256(<8 x float> %a0) ; <<8 x float>> [#uses=1]
  ret <8 x float> %res
}
declare <8 x float> @llvm.x86.avx.sqrt.ps.256(<8 x float>) nounwind readnone


define <4 x double> @test_x86_avx_vperm2f128_pd_256(<4 x double> %a0, <4 x double> %a1) {
; CHECK-LABEL: test_x86_avx_vperm2f128_pd_256:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vperm2f128 $7, %ymm1, %ymm0, %ymm0 ## encoding: [0xc4,0xe3,0x7d,0x06,0xc1,0x07]
; CHECK-NEXT:    ## ymm0 = ymm1[2,3],ymm0[0,1]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <4 x double> @llvm.x86.avx.vperm2f128.pd.256(<4 x double> %a0, <4 x double> %a1, i8 7) ; <<4 x double>> [#uses=1]
  ret <4 x double> %res
}
declare <4 x double> @llvm.x86.avx.vperm2f128.pd.256(<4 x double>, <4 x double>, i8) nounwind readnone


define <8 x float> @test_x86_avx_vperm2f128_ps_256(<8 x float> %a0, <8 x float> %a1) {
; CHECK-LABEL: test_x86_avx_vperm2f128_ps_256:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vperm2f128 $7, %ymm1, %ymm0, %ymm0 ## encoding: [0xc4,0xe3,0x7d,0x06,0xc1,0x07]
; CHECK-NEXT:    ## ymm0 = ymm1[2,3],ymm0[0,1]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <8 x float> @llvm.x86.avx.vperm2f128.ps.256(<8 x float> %a0, <8 x float> %a1, i8 7) ; <<8 x float>> [#uses=1]
  ret <8 x float> %res
}
declare <8 x float> @llvm.x86.avx.vperm2f128.ps.256(<8 x float>, <8 x float>, i8) nounwind readnone


define <8 x i32> @test_x86_avx_vperm2f128_si_256(<8 x i32> %a0, <8 x i32> %a1) {
; CHECK-LABEL: test_x86_avx_vperm2f128_si_256:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vperm2f128 $7, %ymm1, %ymm0, %ymm0 ## encoding: [0xc4,0xe3,0x7d,0x06,0xc1,0x07]
; CHECK-NEXT:    ## ymm0 = ymm1[2,3],ymm0[0,1]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <8 x i32> @llvm.x86.avx.vperm2f128.si.256(<8 x i32> %a0, <8 x i32> %a1, i8 7) ; <<8 x i32>> [#uses=1]
  ret <8 x i32> %res
}
declare <8 x i32> @llvm.x86.avx.vperm2f128.si.256(<8 x i32>, <8 x i32>, i8) nounwind readnone


define <2 x double> @test_x86_avx_vpermilvar_pd(<2 x double> %a0, <2 x i64> %a1) {
; AVX-LABEL: test_x86_avx_vpermilvar_pd:
; AVX:       ## BB#0:
; AVX-NEXT:    vpermilpd %xmm1, %xmm0, %xmm0 ## encoding: [0xc4,0xe2,0x79,0x0d,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_avx_vpermilvar_pd:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpermilpd %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc4,0xe2,0x79,0x0d,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <2 x double> @llvm.x86.avx.vpermilvar.pd(<2 x double> %a0, <2 x i64> %a1) ; <<2 x double>> [#uses=1]
  ret <2 x double> %res
}
declare <2 x double> @llvm.x86.avx.vpermilvar.pd(<2 x double>, <2 x i64>) nounwind readnone


define <4 x double> @test_x86_avx_vpermilvar_pd_256(<4 x double> %a0, <4 x i64> %a1) {
; AVX-LABEL: test_x86_avx_vpermilvar_pd_256:
; AVX:       ## BB#0:
; AVX-NEXT:    vpermilpd %ymm1, %ymm0, %ymm0 ## encoding: [0xc4,0xe2,0x7d,0x0d,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_avx_vpermilvar_pd_256:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpermilpd %ymm1, %ymm0, %ymm0 ## EVEX TO VEX Compression encoding: [0xc4,0xe2,0x7d,0x0d,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <4 x double> @llvm.x86.avx.vpermilvar.pd.256(<4 x double> %a0, <4 x i64> %a1) ; <<4 x double>> [#uses=1]
  ret <4 x double> %res
}
declare <4 x double> @llvm.x86.avx.vpermilvar.pd.256(<4 x double>, <4 x i64>) nounwind readnone

define <4 x double> @test_x86_avx_vpermilvar_pd_256_2(<4 x double> %a0) {
; AVX-LABEL: test_x86_avx_vpermilvar_pd_256_2:
; AVX:       ## BB#0:
; AVX-NEXT:    vpermilpd $9, %ymm0, %ymm0 ## encoding: [0xc4,0xe3,0x7d,0x05,0xc0,0x09]
; AVX-NEXT:    ## ymm0 = ymm0[1,0,2,3]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_avx_vpermilvar_pd_256_2:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpermilpd $9, %ymm0, %ymm0 ## EVEX TO VEX Compression encoding: [0xc4,0xe3,0x7d,0x05,0xc0,0x09]
; AVX512VL-NEXT:    ## ymm0 = ymm0[1,0,2,3]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <4 x double> @llvm.x86.avx.vpermilvar.pd.256(<4 x double> %a0, <4 x i64> <i64 2, i64 0, i64 0, i64 2>) ; <<4 x double>> [#uses=1]
  ret <4 x double> %res
}

define <4 x float> @test_x86_avx_vpermilvar_ps(<4 x float> %a0, <4 x i32> %a1) {
; AVX-LABEL: test_x86_avx_vpermilvar_ps:
; AVX:       ## BB#0:
; AVX-NEXT:    vpermilps %xmm1, %xmm0, %xmm0 ## encoding: [0xc4,0xe2,0x79,0x0c,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_avx_vpermilvar_ps:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpermilps %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc4,0xe2,0x79,0x0c,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <4 x float> @llvm.x86.avx.vpermilvar.ps(<4 x float> %a0, <4 x i32> %a1) ; <<4 x float>> [#uses=1]
  ret <4 x float> %res
}
define <4 x float> @test_x86_avx_vpermilvar_ps_load(<4 x float> %a0, <4 x i32>* %a1) {
; AVX-LABEL: test_x86_avx_vpermilvar_ps_load:
; AVX:       ## BB#0:
; AVX-NEXT:    movl {{[0-9]+}}(%esp), %eax ## encoding: [0x8b,0x44,0x24,0x04]
; AVX-NEXT:    vpermilps (%eax), %xmm0, %xmm0 ## encoding: [0xc4,0xe2,0x79,0x0c,0x00]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_avx_vpermilvar_ps_load:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    movl {{[0-9]+}}(%esp), %eax ## encoding: [0x8b,0x44,0x24,0x04]
; AVX512VL-NEXT:    vpermilps (%eax), %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc4,0xe2,0x79,0x0c,0x00]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %a2 = load <4 x i32>, <4 x i32>* %a1
  %res = call <4 x float> @llvm.x86.avx.vpermilvar.ps(<4 x float> %a0, <4 x i32> %a2) ; <<4 x float>> [#uses=1]
  ret <4 x float> %res
}
declare <4 x float> @llvm.x86.avx.vpermilvar.ps(<4 x float>, <4 x i32>) nounwind readnone


define <8 x float> @test_x86_avx_vpermilvar_ps_256(<8 x float> %a0, <8 x i32> %a1) {
; AVX-LABEL: test_x86_avx_vpermilvar_ps_256:
; AVX:       ## BB#0:
; AVX-NEXT:    vpermilps %ymm1, %ymm0, %ymm0 ## encoding: [0xc4,0xe2,0x7d,0x0c,0xc1]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_avx_vpermilvar_ps_256:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vpermilps %ymm1, %ymm0, %ymm0 ## EVEX TO VEX Compression encoding: [0xc4,0xe2,0x7d,0x0c,0xc1]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call <8 x float> @llvm.x86.avx.vpermilvar.ps.256(<8 x float> %a0, <8 x i32> %a1) ; <<8 x float>> [#uses=1]
  ret <8 x float> %res
}
declare <8 x float> @llvm.x86.avx.vpermilvar.ps.256(<8 x float>, <8 x i32>) nounwind readnone


define i32 @test_x86_avx_vtestc_pd(<2 x double> %a0, <2 x double> %a1) {
; CHECK-LABEL: test_x86_avx_vtestc_pd:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vtestpd %xmm1, %xmm0 ## encoding: [0xc4,0xe2,0x79,0x0f,0xc1]
; CHECK-NEXT:    sbbl %eax, %eax ## encoding: [0x19,0xc0]
; CHECK-NEXT:    andl $1, %eax ## encoding: [0x83,0xe0,0x01]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call i32 @llvm.x86.avx.vtestc.pd(<2 x double> %a0, <2 x double> %a1) ; <i32> [#uses=1]
  ret i32 %res
}
declare i32 @llvm.x86.avx.vtestc.pd(<2 x double>, <2 x double>) nounwind readnone


define i32 @test_x86_avx_vtestc_pd_256(<4 x double> %a0, <4 x double> %a1) {
; AVX-LABEL: test_x86_avx_vtestc_pd_256:
; AVX:       ## BB#0:
; AVX-NEXT:    vtestpd %ymm1, %ymm0 ## encoding: [0xc4,0xe2,0x7d,0x0f,0xc1]
; AVX-NEXT:    sbbl %eax, %eax ## encoding: [0x19,0xc0]
; AVX-NEXT:    andl $1, %eax ## encoding: [0x83,0xe0,0x01]
; AVX-NEXT:    vzeroupper ## encoding: [0xc5,0xf8,0x77]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_avx_vtestc_pd_256:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vtestpd %ymm1, %ymm0 ## encoding: [0xc4,0xe2,0x7d,0x0f,0xc1]
; AVX512VL-NEXT:    sbbl %eax, %eax ## encoding: [0x19,0xc0]
; AVX512VL-NEXT:    andl $1, %eax ## encoding: [0x83,0xe0,0x01]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call i32 @llvm.x86.avx.vtestc.pd.256(<4 x double> %a0, <4 x double> %a1) ; <i32> [#uses=1]
  ret i32 %res
}
declare i32 @llvm.x86.avx.vtestc.pd.256(<4 x double>, <4 x double>) nounwind readnone


define i32 @test_x86_avx_vtestc_ps(<4 x float> %a0, <4 x float> %a1) {
; CHECK-LABEL: test_x86_avx_vtestc_ps:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vtestps %xmm1, %xmm0 ## encoding: [0xc4,0xe2,0x79,0x0e,0xc1]
; CHECK-NEXT:    sbbl %eax, %eax ## encoding: [0x19,0xc0]
; CHECK-NEXT:    andl $1, %eax ## encoding: [0x83,0xe0,0x01]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call i32 @llvm.x86.avx.vtestc.ps(<4 x float> %a0, <4 x float> %a1) ; <i32> [#uses=1]
  ret i32 %res
}
declare i32 @llvm.x86.avx.vtestc.ps(<4 x float>, <4 x float>) nounwind readnone


define i32 @test_x86_avx_vtestc_ps_256(<8 x float> %a0, <8 x float> %a1) {
; AVX-LABEL: test_x86_avx_vtestc_ps_256:
; AVX:       ## BB#0:
; AVX-NEXT:    vtestps %ymm1, %ymm0 ## encoding: [0xc4,0xe2,0x7d,0x0e,0xc1]
; AVX-NEXT:    sbbl %eax, %eax ## encoding: [0x19,0xc0]
; AVX-NEXT:    andl $1, %eax ## encoding: [0x83,0xe0,0x01]
; AVX-NEXT:    vzeroupper ## encoding: [0xc5,0xf8,0x77]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_avx_vtestc_ps_256:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    vtestps %ymm1, %ymm0 ## encoding: [0xc4,0xe2,0x7d,0x0e,0xc1]
; AVX512VL-NEXT:    sbbl %eax, %eax ## encoding: [0x19,0xc0]
; AVX512VL-NEXT:    andl $1, %eax ## encoding: [0x83,0xe0,0x01]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call i32 @llvm.x86.avx.vtestc.ps.256(<8 x float> %a0, <8 x float> %a1) ; <i32> [#uses=1]
  ret i32 %res
}
declare i32 @llvm.x86.avx.vtestc.ps.256(<8 x float>, <8 x float>) nounwind readnone


define i32 @test_x86_avx_vtestnzc_pd(<2 x double> %a0, <2 x double> %a1) {
; CHECK-LABEL: test_x86_avx_vtestnzc_pd:
; CHECK:       ## BB#0:
; CHECK-NEXT:    xorl %eax, %eax ## encoding: [0x31,0xc0]
; CHECK-NEXT:    vtestpd %xmm1, %xmm0 ## encoding: [0xc4,0xe2,0x79,0x0f,0xc1]
; CHECK-NEXT:    seta %al ## encoding: [0x0f,0x97,0xc0]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call i32 @llvm.x86.avx.vtestnzc.pd(<2 x double> %a0, <2 x double> %a1) ; <i32> [#uses=1]
  ret i32 %res
}
declare i32 @llvm.x86.avx.vtestnzc.pd(<2 x double>, <2 x double>) nounwind readnone


define i32 @test_x86_avx_vtestnzc_pd_256(<4 x double> %a0, <4 x double> %a1) {
; AVX-LABEL: test_x86_avx_vtestnzc_pd_256:
; AVX:       ## BB#0:
; AVX-NEXT:    xorl %eax, %eax ## encoding: [0x31,0xc0]
; AVX-NEXT:    vtestpd %ymm1, %ymm0 ## encoding: [0xc4,0xe2,0x7d,0x0f,0xc1]
; AVX-NEXT:    seta %al ## encoding: [0x0f,0x97,0xc0]
; AVX-NEXT:    vzeroupper ## encoding: [0xc5,0xf8,0x77]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_avx_vtestnzc_pd_256:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    xorl %eax, %eax ## encoding: [0x31,0xc0]
; AVX512VL-NEXT:    vtestpd %ymm1, %ymm0 ## encoding: [0xc4,0xe2,0x7d,0x0f,0xc1]
; AVX512VL-NEXT:    seta %al ## encoding: [0x0f,0x97,0xc0]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call i32 @llvm.x86.avx.vtestnzc.pd.256(<4 x double> %a0, <4 x double> %a1) ; <i32> [#uses=1]
  ret i32 %res
}
declare i32 @llvm.x86.avx.vtestnzc.pd.256(<4 x double>, <4 x double>) nounwind readnone


define i32 @test_x86_avx_vtestnzc_ps(<4 x float> %a0, <4 x float> %a1) {
; CHECK-LABEL: test_x86_avx_vtestnzc_ps:
; CHECK:       ## BB#0:
; CHECK-NEXT:    xorl %eax, %eax ## encoding: [0x31,0xc0]
; CHECK-NEXT:    vtestps %xmm1, %xmm0 ## encoding: [0xc4,0xe2,0x79,0x0e,0xc1]
; CHECK-NEXT:    seta %al ## encoding: [0x0f,0x97,0xc0]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call i32 @llvm.x86.avx.vtestnzc.ps(<4 x float> %a0, <4 x float> %a1) ; <i32> [#uses=1]
  ret i32 %res
}
declare i32 @llvm.x86.avx.vtestnzc.ps(<4 x float>, <4 x float>) nounwind readnone


define i32 @test_x86_avx_vtestnzc_ps_256(<8 x float> %a0, <8 x float> %a1) {
; AVX-LABEL: test_x86_avx_vtestnzc_ps_256:
; AVX:       ## BB#0:
; AVX-NEXT:    xorl %eax, %eax ## encoding: [0x31,0xc0]
; AVX-NEXT:    vtestps %ymm1, %ymm0 ## encoding: [0xc4,0xe2,0x7d,0x0e,0xc1]
; AVX-NEXT:    seta %al ## encoding: [0x0f,0x97,0xc0]
; AVX-NEXT:    vzeroupper ## encoding: [0xc5,0xf8,0x77]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_avx_vtestnzc_ps_256:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    xorl %eax, %eax ## encoding: [0x31,0xc0]
; AVX512VL-NEXT:    vtestps %ymm1, %ymm0 ## encoding: [0xc4,0xe2,0x7d,0x0e,0xc1]
; AVX512VL-NEXT:    seta %al ## encoding: [0x0f,0x97,0xc0]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call i32 @llvm.x86.avx.vtestnzc.ps.256(<8 x float> %a0, <8 x float> %a1) ; <i32> [#uses=1]
  ret i32 %res
}
declare i32 @llvm.x86.avx.vtestnzc.ps.256(<8 x float>, <8 x float>) nounwind readnone


define i32 @test_x86_avx_vtestz_pd(<2 x double> %a0, <2 x double> %a1) {
; CHECK-LABEL: test_x86_avx_vtestz_pd:
; CHECK:       ## BB#0:
; CHECK-NEXT:    xorl %eax, %eax ## encoding: [0x31,0xc0]
; CHECK-NEXT:    vtestpd %xmm1, %xmm0 ## encoding: [0xc4,0xe2,0x79,0x0f,0xc1]
; CHECK-NEXT:    sete %al ## encoding: [0x0f,0x94,0xc0]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call i32 @llvm.x86.avx.vtestz.pd(<2 x double> %a0, <2 x double> %a1) ; <i32> [#uses=1]
  ret i32 %res
}
declare i32 @llvm.x86.avx.vtestz.pd(<2 x double>, <2 x double>) nounwind readnone


define i32 @test_x86_avx_vtestz_pd_256(<4 x double> %a0, <4 x double> %a1) {
; AVX-LABEL: test_x86_avx_vtestz_pd_256:
; AVX:       ## BB#0:
; AVX-NEXT:    xorl %eax, %eax ## encoding: [0x31,0xc0]
; AVX-NEXT:    vtestpd %ymm1, %ymm0 ## encoding: [0xc4,0xe2,0x7d,0x0f,0xc1]
; AVX-NEXT:    sete %al ## encoding: [0x0f,0x94,0xc0]
; AVX-NEXT:    vzeroupper ## encoding: [0xc5,0xf8,0x77]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_avx_vtestz_pd_256:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    xorl %eax, %eax ## encoding: [0x31,0xc0]
; AVX512VL-NEXT:    vtestpd %ymm1, %ymm0 ## encoding: [0xc4,0xe2,0x7d,0x0f,0xc1]
; AVX512VL-NEXT:    sete %al ## encoding: [0x0f,0x94,0xc0]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call i32 @llvm.x86.avx.vtestz.pd.256(<4 x double> %a0, <4 x double> %a1) ; <i32> [#uses=1]
  ret i32 %res
}
declare i32 @llvm.x86.avx.vtestz.pd.256(<4 x double>, <4 x double>) nounwind readnone


define i32 @test_x86_avx_vtestz_ps(<4 x float> %a0, <4 x float> %a1) {
; CHECK-LABEL: test_x86_avx_vtestz_ps:
; CHECK:       ## BB#0:
; CHECK-NEXT:    xorl %eax, %eax ## encoding: [0x31,0xc0]
; CHECK-NEXT:    vtestps %xmm1, %xmm0 ## encoding: [0xc4,0xe2,0x79,0x0e,0xc1]
; CHECK-NEXT:    sete %al ## encoding: [0x0f,0x94,0xc0]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call i32 @llvm.x86.avx.vtestz.ps(<4 x float> %a0, <4 x float> %a1) ; <i32> [#uses=1]
  ret i32 %res
}
declare i32 @llvm.x86.avx.vtestz.ps(<4 x float>, <4 x float>) nounwind readnone


define i32 @test_x86_avx_vtestz_ps_256(<8 x float> %a0, <8 x float> %a1) {
; AVX-LABEL: test_x86_avx_vtestz_ps_256:
; AVX:       ## BB#0:
; AVX-NEXT:    xorl %eax, %eax ## encoding: [0x31,0xc0]
; AVX-NEXT:    vtestps %ymm1, %ymm0 ## encoding: [0xc4,0xe2,0x7d,0x0e,0xc1]
; AVX-NEXT:    sete %al ## encoding: [0x0f,0x94,0xc0]
; AVX-NEXT:    vzeroupper ## encoding: [0xc5,0xf8,0x77]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: test_x86_avx_vtestz_ps_256:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    xorl %eax, %eax ## encoding: [0x31,0xc0]
; AVX512VL-NEXT:    vtestps %ymm1, %ymm0 ## encoding: [0xc4,0xe2,0x7d,0x0e,0xc1]
; AVX512VL-NEXT:    sete %al ## encoding: [0x0f,0x94,0xc0]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %res = call i32 @llvm.x86.avx.vtestz.ps.256(<8 x float> %a0, <8 x float> %a1) ; <i32> [#uses=1]
  ret i32 %res
}
declare i32 @llvm.x86.avx.vtestz.ps.256(<8 x float>, <8 x float>) nounwind readnone


define void @test_x86_avx_vzeroall() {
; CHECK-LABEL: test_x86_avx_vzeroall:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vzeroall ## encoding: [0xc5,0xfc,0x77]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  call void @llvm.x86.avx.vzeroall()
  ret void
}
declare void @llvm.x86.avx.vzeroall() nounwind


define void @test_x86_avx_vzeroupper() {
; CHECK-LABEL: test_x86_avx_vzeroupper:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vzeroupper ## encoding: [0xc5,0xf8,0x77]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  call void @llvm.x86.avx.vzeroupper()
  ret void
}
declare void @llvm.x86.avx.vzeroupper() nounwind

; Make sure instructions with no AVX equivalents, but are associated with SSEX feature flags still work

define void @monitor(i8* %P, i32 %E, i32 %H) nounwind {
; CHECK-LABEL: monitor:
; CHECK:       ## BB#0:
; CHECK-NEXT:    movl {{[0-9]+}}(%esp), %edx ## encoding: [0x8b,0x54,0x24,0x0c]
; CHECK-NEXT:    movl {{[0-9]+}}(%esp), %ecx ## encoding: [0x8b,0x4c,0x24,0x08]
; CHECK-NEXT:    movl {{[0-9]+}}(%esp), %eax ## encoding: [0x8b,0x44,0x24,0x04]
; CHECK-NEXT:    leal (%eax), %eax ## encoding: [0x8d,0x00]
; CHECK-NEXT:    monitor ## encoding: [0x0f,0x01,0xc8]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  tail call void @llvm.x86.sse3.monitor(i8* %P, i32 %E, i32 %H)
  ret void
}
declare void @llvm.x86.sse3.monitor(i8*, i32, i32) nounwind

define void @mwait(i32 %E, i32 %H) nounwind {
; CHECK-LABEL: mwait:
; CHECK:       ## BB#0:
; CHECK-NEXT:    movl {{[0-9]+}}(%esp), %ecx ## encoding: [0x8b,0x4c,0x24,0x04]
; CHECK-NEXT:    movl {{[0-9]+}}(%esp), %eax ## encoding: [0x8b,0x44,0x24,0x08]
; CHECK-NEXT:    mwait ## encoding: [0x0f,0x01,0xc9]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  tail call void @llvm.x86.sse3.mwait(i32 %E, i32 %H)
  ret void
}
declare void @llvm.x86.sse3.mwait(i32, i32) nounwind

define void @lfence() nounwind {
; CHECK-LABEL: lfence:
; CHECK:       ## BB#0:
; CHECK-NEXT:    lfence ## encoding: [0x0f,0xae,0xe8]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  tail call void @llvm.x86.sse2.lfence()
  ret void
}
declare void @llvm.x86.sse2.lfence() nounwind

define void @mfence() nounwind {
; CHECK-LABEL: mfence:
; CHECK:       ## BB#0:
; CHECK-NEXT:    mfence ## encoding: [0x0f,0xae,0xf0]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  tail call void @llvm.x86.sse2.mfence()
  ret void
}
declare void @llvm.x86.sse2.mfence() nounwind

define void @clflush(i8* %p) nounwind {
; CHECK-LABEL: clflush:
; CHECK:       ## BB#0:
; CHECK-NEXT:    movl {{[0-9]+}}(%esp), %eax ## encoding: [0x8b,0x44,0x24,0x04]
; CHECK-NEXT:    clflush (%eax) ## encoding: [0x0f,0xae,0x38]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  tail call void @llvm.x86.sse2.clflush(i8* %p)
  ret void
}
declare void @llvm.x86.sse2.clflush(i8*) nounwind

define i32 @crc32_32_8(i32 %a, i8 %b) nounwind {
; CHECK-LABEL: crc32_32_8:
; CHECK:       ## BB#0:
; CHECK-NEXT:    movl {{[0-9]+}}(%esp), %eax ## encoding: [0x8b,0x44,0x24,0x04]
; CHECK-NEXT:    crc32b {{[0-9]+}}(%esp), %eax ## encoding: [0xf2,0x0f,0x38,0xf0,0x44,0x24,0x08]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %tmp = call i32 @llvm.x86.sse42.crc32.32.8(i32 %a, i8 %b)
  ret i32 %tmp
}
declare i32 @llvm.x86.sse42.crc32.32.8(i32, i8) nounwind

define i32 @crc32_32_16(i32 %a, i16 %b) nounwind {
; CHECK-LABEL: crc32_32_16:
; CHECK:       ## BB#0:
; CHECK-NEXT:    movl {{[0-9]+}}(%esp), %eax ## encoding: [0x8b,0x44,0x24,0x04]
; CHECK-NEXT:    crc32w {{[0-9]+}}(%esp), %eax ## encoding: [0x66,0xf2,0x0f,0x38,0xf1,0x44,0x24,0x08]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %tmp = call i32 @llvm.x86.sse42.crc32.32.16(i32 %a, i16 %b)
  ret i32 %tmp
}
declare i32 @llvm.x86.sse42.crc32.32.16(i32, i16) nounwind

define i32 @crc32_32_32(i32 %a, i32 %b) nounwind {
; CHECK-LABEL: crc32_32_32:
; CHECK:       ## BB#0:
; CHECK-NEXT:    movl {{[0-9]+}}(%esp), %eax ## encoding: [0x8b,0x44,0x24,0x04]
; CHECK-NEXT:    crc32l {{[0-9]+}}(%esp), %eax ## encoding: [0xf2,0x0f,0x38,0xf1,0x44,0x24,0x08]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %tmp = call i32 @llvm.x86.sse42.crc32.32.32(i32 %a, i32 %b)
  ret i32 %tmp
}
declare i32 @llvm.x86.sse42.crc32.32.32(i32, i32) nounwind

define void @movnt_dq(i8* %p, <2 x i64> %a1) nounwind {
; AVX-LABEL: movnt_dq:
; AVX:       ## BB#0:
; AVX-NEXT:    movl {{[0-9]+}}(%esp), %eax ## encoding: [0x8b,0x44,0x24,0x04]
; AVX-NEXT:    vpaddq LCPI216_0, %xmm0, %xmm0 ## encoding: [0xc5,0xf9,0xd4,0x05,A,A,A,A]
; AVX-NEXT:    ## fixup A - offset: 4, value: LCPI216_0, kind: FK_Data_4
; AVX-NEXT:    vmovntdq %ymm0, (%eax) ## encoding: [0xc5,0xfd,0xe7,0x00]
; AVX-NEXT:    vzeroupper ## encoding: [0xc5,0xf8,0x77]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: movnt_dq:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    movl {{[0-9]+}}(%esp), %eax ## encoding: [0x8b,0x44,0x24,0x04]
; AVX512VL-NEXT:    vpaddq LCPI216_0, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0xd4,0x05,A,A,A,A]
; AVX512VL-NEXT:    ## fixup A - offset: 4, value: LCPI216_0, kind: FK_Data_4
; AVX512VL-NEXT:    vmovntdq %ymm0, (%eax) ## EVEX TO VEX Compression encoding: [0xc5,0xfd,0xe7,0x00]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %a2 = add <2 x i64> %a1, <i64 1, i64 1>
  %a3 = shufflevector <2 x i64> %a2, <2 x i64> undef, <4 x i32> <i32 0, i32 1, i32 undef, i32 undef>
  tail call void @llvm.x86.avx.movnt.dq.256(i8* %p, <4 x i64> %a3) nounwind
  ret void
}
declare void @llvm.x86.avx.movnt.dq.256(i8*, <4 x i64>) nounwind

define void @movnt_ps(i8* %p, <8 x float> %a) nounwind {
; AVX-LABEL: movnt_ps:
; AVX:       ## BB#0:
; AVX-NEXT:    movl {{[0-9]+}}(%esp), %eax ## encoding: [0x8b,0x44,0x24,0x04]
; AVX-NEXT:    vmovntps %ymm0, (%eax) ## encoding: [0xc5,0xfc,0x2b,0x00]
; AVX-NEXT:    vzeroupper ## encoding: [0xc5,0xf8,0x77]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: movnt_ps:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    movl {{[0-9]+}}(%esp), %eax ## encoding: [0x8b,0x44,0x24,0x04]
; AVX512VL-NEXT:    vmovntps %ymm0, (%eax) ## EVEX TO VEX Compression encoding: [0xc5,0xfc,0x2b,0x00]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  tail call void @llvm.x86.avx.movnt.ps.256(i8* %p, <8 x float> %a) nounwind
  ret void
}
declare void @llvm.x86.avx.movnt.ps.256(i8*, <8 x float>) nounwind

define void @movnt_pd(i8* %p, <4 x double> %a1) nounwind {
  ; add operation forces the execution domain.
; AVX-LABEL: movnt_pd:
; AVX:       ## BB#0:
; AVX-NEXT:    movl {{[0-9]+}}(%esp), %eax ## encoding: [0x8b,0x44,0x24,0x04]
; AVX-NEXT:    vxorpd %ymm1, %ymm1, %ymm1 ## encoding: [0xc5,0xf5,0x57,0xc9]
; AVX-NEXT:    vaddpd %ymm1, %ymm0, %ymm0 ## encoding: [0xc5,0xfd,0x58,0xc1]
; AVX-NEXT:    vmovntpd %ymm0, (%eax) ## encoding: [0xc5,0xfd,0x2b,0x00]
; AVX-NEXT:    vzeroupper ## encoding: [0xc5,0xf8,0x77]
; AVX-NEXT:    retl ## encoding: [0xc3]
;
; AVX512VL-LABEL: movnt_pd:
; AVX512VL:       ## BB#0:
; AVX512VL-NEXT:    movl {{[0-9]+}}(%esp), %eax ## encoding: [0x8b,0x44,0x24,0x04]
; AVX512VL-NEXT:    vxorpd %ymm1, %ymm1, %ymm1 ## EVEX TO VEX Compression encoding: [0xc5,0xf5,0x57,0xc9]
; AVX512VL-NEXT:    vaddpd %ymm1, %ymm0, %ymm0 ## EVEX TO VEX Compression encoding: [0xc5,0xfd,0x58,0xc1]
; AVX512VL-NEXT:    vmovntpd %ymm0, (%eax) ## EVEX TO VEX Compression encoding: [0xc5,0xfd,0x2b,0x00]
; AVX512VL-NEXT:    retl ## encoding: [0xc3]
  %a2 = fadd <4 x double> %a1, <double 0x0, double 0x0, double 0x0, double 0x0>
  tail call void @llvm.x86.avx.movnt.pd.256(i8* %p, <4 x double> %a2) nounwind
  ret void
}
declare void @llvm.x86.avx.movnt.pd.256(i8*, <4 x double>) nounwind


; Check for pclmulqdq
define <2 x i64> @test_x86_pclmulqdq(<2 x i64> %a0, <2 x i64> %a1) {
; CHECK-LABEL: test_x86_pclmulqdq:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vpclmulqdq $0, %xmm1, %xmm0, %xmm0 ## encoding: [0xc4,0xe3,0x79,0x44,0xc1,0x00]
; CHECK-NEXT:    retl ## encoding: [0xc3]
  %res = call <2 x i64> @llvm.x86.pclmulqdq(<2 x i64> %a0, <2 x i64> %a1, i8 0) ; <<2 x i64>> [#uses=1]
  ret <2 x i64> %res
}
declare <2 x i64> @llvm.x86.pclmulqdq(<2 x i64>, <2 x i64>, i8) nounwind readnone
