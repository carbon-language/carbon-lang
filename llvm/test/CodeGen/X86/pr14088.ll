; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=x86_64-linux -mcpu=core2 -verify-machineinstrs | FileCheck %s

; We were miscompiling this and using %ax instead of %cx in the movw
; in the following sequence:
;	movswl	%cx, %ecx
;	movw	%cx, (%rsi)
;	movslq	%ecx, %rcx
;
; We can't produce the above sequence without special SD-level
; heuristics. Now we produce this:

define i32 @f(i1 %foo, i16* %tm_year2, i8* %bar, i16 %zed, i32 %zed2) {
; CHECK-LABEL: f:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movl $-1, %eax
; CHECK-NEXT:    testb $1, %dil
; CHECK-NEXT:    jne .LBB0_2
; CHECK-NEXT:  # %bb.1: # %if.end
; CHECK-NEXT:    movslq %r8d, %rax
; CHECK-NEXT:    imulq $1374389535, %rax, %rcx # imm = 0x51EB851F
; CHECK-NEXT:    movq %rcx, %rdi
; CHECK-NEXT:    shrq $63, %rdi
; CHECK-NEXT:    sarq $37, %rcx
; CHECK-NEXT:    addl %edi, %ecx
; CHECK-NEXT:    imull $100, %ecx, %ecx
; CHECK-NEXT:    subl %ecx, %eax
; CHECK-NEXT:    movw %ax, (%rsi)
; CHECK-NEXT:    cwtl
; CHECK-NEXT:    cltq
; CHECK-NEXT:    imulq $1717986919, %rax, %rax # imm = 0x66666667
; CHECK-NEXT:    movq %rax, %rcx
; CHECK-NEXT:    shrq $63, %rcx
; CHECK-NEXT:    shrq $34, %rax
; CHECK-NEXT:    addl %ecx, %eax
; CHECK-NEXT:    movb %al, (%rdx)
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:  .LBB0_2: # %return
; CHECK-NEXT:    retq
entry:
  br i1 %foo, label %return, label %if.end

if.end:
  %rem = srem i32 %zed2, 100
  %conv3 = trunc i32 %rem to i16
  store i16 %conv3, i16* %tm_year2
  %sext = shl i32 %rem, 16
  %conv5 = ashr exact i32 %sext, 16
  %div = sdiv i32 %conv5, 10
  %conv6 = trunc i32 %div to i8
  store i8 %conv6, i8* %bar
  br label %return

return:
  %retval.0 = phi i32 [ 0, %if.end ], [ -1, %entry ]
  ret i32 %retval.0
}
