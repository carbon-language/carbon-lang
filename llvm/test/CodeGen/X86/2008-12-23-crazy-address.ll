; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=i686-- -relocation-model=static | FileCheck %s

@X = external dso_local global [0 x i32]

define void @foo() nounwind {
; CHECK-LABEL: foo:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    pushl %eax
; CHECK-NEXT:    movl %esp, %eax
; CHECK-NEXT:    pushl %eax
; CHECK-NEXT:    calll frob
; CHECK-NEXT:    addl $4, %esp
; CHECK-NEXT:    leal X(%esp), %eax
; CHECK-NEXT:    pushl %eax
; CHECK-NEXT:    calll borf
; CHECK-NEXT:    addl $4, %esp
; CHECK-NEXT:    popl %eax
; CHECK-NEXT:    retl
entry:
	%Y = alloca i32
	call void @frob(i32* %Y) nounwind
	%Y3 = bitcast i32* %Y to i8*
	%ctg2 = getelementptr i8, i8* %Y3, i32 ptrtoint ([0 x i32]* @X to i32)
	%0 = ptrtoint i8* %ctg2 to i32
	call void @borf(i32 %0) nounwind
	ret void
}

define void @bar(i32 %i) nounwind {
; CHECK-LABEL: bar:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    pushl %esi
; CHECK-NEXT:    subl $40, %esp
; CHECK-NEXT:    movl {{[0-9]+}}(%esp), %esi
; CHECK-NEXT:    movl %esp, %eax
; CHECK-NEXT:    pushl %eax
; CHECK-NEXT:    calll frob
; CHECK-NEXT:    addl $4, %esp
; CHECK-NEXT:    leal X(%esp,%esi,4), %eax
; CHECK-NEXT:    pushl %eax
; CHECK-NEXT:    calll borf
; CHECK-NEXT:    addl $44, %esp
; CHECK-NEXT:    popl %esi
; CHECK-NEXT:    retl
entry:
	%Y = alloca [10 x i32]
	%0 = getelementptr [10 x i32], [10 x i32]* %Y, i32 0, i32 0
	call void @frob(i32* %0) nounwind
	%1 = getelementptr [0 x i32], [0 x i32]* @X, i32 0, i32 %i
	%2 = getelementptr [10 x i32], [10 x i32]* %Y, i32 0, i32 0
	%3 = ptrtoint i32* %2 to i32
	%4 = bitcast i32* %1 to i8*
	%ctg2 = getelementptr i8, i8* %4, i32 %3
	%5 = ptrtoint i8* %ctg2 to i32
	call void @borf(i32 %5) nounwind
	ret void
}

declare void @frob(i32*)

declare void @borf(i32)
