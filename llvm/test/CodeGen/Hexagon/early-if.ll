; RUN: llc -O2 -march=hexagon -mcpu=hexagonv5 < %s | FileCheck %s
; Rely on the comments generated by llc. Check that "if.then" was predicated.
; CHECK: while.body13
; CHECK: if{{.*}}memd
; CHECK: while.end

%struct.1 = type { i32, i32 }
%struct.2 = type { [24 x i32], [24 x i32], [24 x i32], [24 x i32], [24 x i32], [24 x i32], [24 x i32], [24 x i32], [24 x i32], [24 x i32], [24 x i32], [24 x i32], [24 x i32], [24 x i32], [24 x i32], [24 x i32], [24 x i32], [3 x i32], [24 x i32], [8 x %struct.1], [5 x i32] }

@A1 = global i64 zeroinitializer
@A2 = global i64 zeroinitializer
@B1 = global i32 zeroinitializer
@B2 = global i32 zeroinitializer
@C1 = global i8 zeroinitializer

declare i32 @llvm.hexagon.S2.cl0(i32) nounwind readnone
declare i32 @llvm.hexagon.S2.setbit.r(i32, i32) nounwind readnone
declare i64 @llvm.hexagon.M2.vmpy2s.s0(i32, i32) nounwind readnone
declare i64 @llvm.hexagon.M2.vmac2s.s0(i64, i32, i32) nounwind readnone
declare i64 @llvm.hexagon.A2.vaddws(i64, i64) nounwind readnone
declare i64 @llvm.hexagon.A2.vsubws(i64, i64) nounwind readnone
declare i32 @llvm.hexagon.A4.modwrapu(i32, i32) nounwind readnone

define void @foo(i32 %n, i64* %ptr) nounwind {
entry:
  br label %while.body

while.body:
  %count = phi i32 [ 0, %entry ], [ %next, %while.end ]
  %idx = phi i32 [ 0, %entry ], [ %15, %while.end ]
  %0 = load i32, i32* @B1, align 4
  %1 = load i32, i32* @B2, align 8
  %2 = and i32 %1, %0
  br label %while.body13

while.body13:                                     ; preds = %while.body, %if.end
  %3 = phi i64 [ %13, %if.end ], [ 0, %while.body ]
  %4 = phi i64 [ %14, %if.end ], [ 0, %while.body ]
  %m = phi i32 [ %6, %if.end ], [ %2, %while.body ]
  %5 = tail call i32 @llvm.hexagon.S2.cl0(i32 %m)
  %6 = tail call i32 @llvm.hexagon.S2.setbit.r(i32 %m, i32 %5)
  %cgep85 = getelementptr [10 x %struct.2], [10 x %struct.2]* inttoptr (i32 -121502345 to [10 x %struct.2]*), i32 0, i32 %idx
  %cgep90 = getelementptr %struct.2, %struct.2* %cgep85, i32 0, i32 12, i32 %5
  %7 = load i32, i32* %cgep90, align 4
  %8 = tail call i64 @llvm.hexagon.M2.vmpy2s.s0(i32 %7, i32 %7)
  %cgep91 = getelementptr %struct.2, %struct.2* %cgep85, i32 0, i32 13, i32 %5
  %9 = load i32, i32* %cgep91, align 4
  %10 = tail call i64 @llvm.hexagon.M2.vmac2s.s0(i64 %8, i32 %9, i32 %9)
  %11 = load i8, i8* @C1, align 1
  %and24 = and i8 %11, 1
  %cmp = icmp eq i8 %and24, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %while.body13
  %12 = tail call i64 @llvm.hexagon.A2.vaddws(i64 %3, i64 %10)
  store i64 %12, i64* %ptr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body13
  %13 = phi i64 [ %12, %if.then ], [ %3, %while.body13 ]
  %14 = tail call i64 @llvm.hexagon.A2.vsubws(i64 %4, i64 %10)
  %tobool12 = icmp eq i32 %6, 0
  br i1 %tobool12, label %while.end, label %while.body13

while.end:
  %add40 = add i32 %idx, 1
  %15 = tail call i32 @llvm.hexagon.A4.modwrapu(i32 %add40, i32 10) nounwind
  %next = add i32 %count, 1
  %cc = icmp eq i32 %next, %n
  br i1 %cc, label %end, label %while.body

end:
  store i64 %10, i64* @A2, align 8
  ret void
}
