# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
# RUN: llc -O0 -mtriple=mipsel-linux-gnu -run-pass=legalizer -verify-machineinstrs %s -o - | FileCheck %s -check-prefixes=MIPS32
--- |

  declare i32 @puts(i8*)
  declare void @llvm.memset.p0i8.i32(i8*, i8, i32, i1)

  define void @Print_c_N_times(i8 %c, i32 %N) {
  entry:
    %add = add i32 %N, 1
    %vla = alloca i8, i32 %add, align 1
    call void @llvm.memset.p0i8.i32(i8* align 1 %vla, i8 %c, i32 %N, i1 false)
    %arrayidx = getelementptr inbounds i8, i8* %vla, i32 %N
    store i8 0, i8* %arrayidx, align 1
    %call = call i32 @puts(i8* %vla)
    ret void
  }

...
---
name:            Print_c_N_times
alignment:       4
tracksRegLiveness: true
stack:
  - { id: 0, name: vla, type: variable-sized, alignment: 1 }
body:             |
  bb.1.entry:
    liveins: $a0, $a1

    ; MIPS32-LABEL: name: Print_c_N_times
    ; MIPS32: liveins: $a0, $a1
    ; MIPS32: [[COPY:%[0-9]+]]:_(s32) = COPY $a0
    ; MIPS32: [[COPY1:%[0-9]+]]:_(s32) = COPY $a1
    ; MIPS32: [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 1
    ; MIPS32: [[C1:%[0-9]+]]:_(s32) = G_CONSTANT i32 0
    ; MIPS32: [[ADD:%[0-9]+]]:_(s32) = G_ADD [[COPY1]], [[C]]
    ; MIPS32: [[MUL:%[0-9]+]]:_(s32) = G_MUL [[ADD]], [[C]]
    ; MIPS32: [[C2:%[0-9]+]]:_(s32) = G_CONSTANT i32 7
    ; MIPS32: [[ADD1:%[0-9]+]]:_(s32) = nuw G_ADD [[MUL]], [[C2]]
    ; MIPS32: [[C3:%[0-9]+]]:_(s32) = G_CONSTANT i32 -8
    ; MIPS32: [[AND:%[0-9]+]]:_(s32) = G_AND [[ADD1]], [[C3]]
    ; MIPS32: [[COPY2:%[0-9]+]]:_(p0) = COPY $sp
    ; MIPS32: [[PTRTOINT:%[0-9]+]]:_(s32) = G_PTRTOINT [[COPY2]](p0)
    ; MIPS32: [[SUB:%[0-9]+]]:_(s32) = G_SUB [[PTRTOINT]], [[AND]]
    ; MIPS32: [[INTTOPTR:%[0-9]+]]:_(p0) = G_INTTOPTR [[SUB]](s32)
    ; MIPS32: $sp = COPY [[INTTOPTR]](p0)
    ; MIPS32: [[COPY3:%[0-9]+]]:_(p0) = COPY [[INTTOPTR]](p0)
    ; MIPS32: ADJCALLSTACKDOWN 16, 0, implicit-def $sp, implicit $sp
    ; MIPS32: $a0 = COPY [[COPY3]](p0)
    ; MIPS32: $a1 = COPY [[COPY]](s32)
    ; MIPS32: $a2 = COPY [[COPY1]](s32)
    ; MIPS32: JAL &memset, csr_o32, implicit-def $ra, implicit-def $sp, implicit $a0, implicit $a1, implicit $a2
    ; MIPS32: ADJCALLSTACKUP 16, 0, implicit-def $sp, implicit $sp
    ; MIPS32: [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY3]], [[COPY1]](s32)
    ; MIPS32: [[COPY4:%[0-9]+]]:_(p0) = COPY [[PTR_ADD]](p0)
    ; MIPS32: G_STORE [[C1]](s32), [[COPY4]](p0) :: (store (s8) into %ir.arrayidx)
    ; MIPS32: ADJCALLSTACKDOWN 16, 0, implicit-def $sp, implicit $sp
    ; MIPS32: $a0 = COPY [[COPY3]](p0)
    ; MIPS32: JAL @puts, csr_o32, implicit-def $ra, implicit-def $sp, implicit $a0, implicit-def $v0
    ; MIPS32: ADJCALLSTACKUP 16, 0, implicit-def $sp, implicit $sp
    ; MIPS32: RetRA
    %2:_(s32) = COPY $a0
    %0:_(s8) = G_TRUNC %2(s32)
    %1:_(s32) = COPY $a1
    %3:_(s32) = G_CONSTANT i32 1
    %13:_(s8) = G_CONSTANT i8 0
    %4:_(s32) = G_ADD %1, %3
    %5:_(s32) = G_MUL %4, %3
    %6:_(s32) = G_CONSTANT i32 7
    %7:_(s32) = nuw G_ADD %5, %6
    %8:_(s32) = G_CONSTANT i32 -8
    %9:_(s32) = G_AND %7, %8
    %10:_(p0) = G_DYN_STACKALLOC %9(s32), 0
    G_MEMSET %10(p0), %0(s8), %1(s32), 0 :: (store (s8) into %ir.vla)
    %11:_(p0) = G_PTR_ADD %10, %1(s32)
    %12:_(p0) = COPY %11(p0)
    G_STORE %13(s8), %12(p0) :: (store (s8) into %ir.arrayidx)
    ADJCALLSTACKDOWN 16, 0, implicit-def $sp, implicit $sp
    $a0 = COPY %10(p0)
    JAL @puts, csr_o32, implicit-def $ra, implicit-def $sp, implicit $a0, implicit-def $v0
    ADJCALLSTACKUP 16, 0, implicit-def $sp, implicit $sp
    RetRA

...
