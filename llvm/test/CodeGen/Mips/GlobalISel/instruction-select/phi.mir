# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
# RUN: llc -O0 -mtriple=mipsel-linux-gnu -run-pass=instruction-select -verify-machineinstrs %s -o - | FileCheck %s -check-prefixes=MIPS32FP32
# RUN: llc -O0 -mtriple=mipsel-linux-gnu -mattr=+fp64,+mips32r2 -run-pass=instruction-select -verify-machineinstrs %s -o - | FileCheck %s -check-prefixes=MIPS32FP64
--- |

  define i32 @phi_i32(i1 %cnd, i32 %a, i32 %b) {
  entry:
    br i1 %cnd, label %cond.true, label %cond.false

  cond.true:                                        ; preds = %entry
    br label %cond.end

  cond.false:                                       ; preds = %entry
    br label %cond.end

  cond.end:                                         ; preds = %cond.false, %cond.true
    %cond = phi i32 [ %a, %cond.true ], [ %b, %cond.false ]
    ret i32 %cond
  }

  define i64 @phi_i64(i1 %cnd, i64 %a, i64 %b) {
  entry:
    br i1 %cnd, label %cond.true, label %cond.false

  cond.true:                                        ; preds = %entry
    br label %cond.end

  cond.false:                                       ; preds = %entry
    br label %cond.end

  cond.end:                                         ; preds = %cond.false, %cond.true
    %cond = phi i64 [ %a, %cond.true ], [ %b, %cond.false ]
    ret i64 %cond
  }

  define float @phi_float(i1 %cnd, float %a, float %b) {
  entry:
    br i1 %cnd, label %cond.true, label %cond.false

  cond.true:                                        ; preds = %entry
    br label %cond.end

  cond.false:                                       ; preds = %entry
    br label %cond.end

  cond.end:                                         ; preds = %cond.false, %cond.true
    %cond = phi float [ %a, %cond.true ], [ %b, %cond.false ]
    ret float %cond
  }

  define double @phi_double(double %a, double %b, i1 %cnd) {
  entry:
    br i1 %cnd, label %cond.true, label %cond.false

  cond.true:                                        ; preds = %entry
    br label %cond.end

  cond.false:                                       ; preds = %entry
    br label %cond.end

  cond.end:                                         ; preds = %cond.false, %cond.true
    %cond = phi double [ %a, %cond.true ], [ %b, %cond.false ]
    ret double %cond
  }

...
---
name:            phi_i32
alignment:       4
legalized:       true
regBankSelected: true
tracksRegLiveness: true
body:             |
  ; MIPS32FP32-LABEL: name: phi_i32
  ; MIPS32FP32: bb.0.entry:
  ; MIPS32FP32:   successors: %bb.1(0x40000000), %bb.2(0x40000000)
  ; MIPS32FP32:   liveins: $a0, $a1, $a2
  ; MIPS32FP32:   [[COPY:%[0-9]+]]:gpr32 = COPY $a0
  ; MIPS32FP32:   [[COPY1:%[0-9]+]]:gpr32 = COPY $a1
  ; MIPS32FP32:   [[COPY2:%[0-9]+]]:gpr32 = COPY $a2
  ; MIPS32FP32:   [[ANDi:%[0-9]+]]:gpr32 = ANDi [[COPY]], 1
  ; MIPS32FP32:   BNE [[ANDi]], $zero, %bb.1, implicit-def $at
  ; MIPS32FP32:   J %bb.2, implicit-def $at
  ; MIPS32FP32: bb.1.cond.true:
  ; MIPS32FP32:   successors: %bb.3(0x80000000)
  ; MIPS32FP32:   J %bb.3, implicit-def $at
  ; MIPS32FP32: bb.2.cond.false:
  ; MIPS32FP32:   successors: %bb.3(0x80000000)
  ; MIPS32FP32: bb.3.cond.end:
  ; MIPS32FP32:   [[PHI:%[0-9]+]]:gpr32 = PHI [[COPY1]], %bb.1, [[COPY2]], %bb.2
  ; MIPS32FP32:   $v0 = COPY [[PHI]]
  ; MIPS32FP32:   RetRA implicit $v0
  ; MIPS32FP64-LABEL: name: phi_i32
  ; MIPS32FP64: bb.0.entry:
  ; MIPS32FP64:   successors: %bb.1(0x40000000), %bb.2(0x40000000)
  ; MIPS32FP64:   liveins: $a0, $a1, $a2
  ; MIPS32FP64:   [[COPY:%[0-9]+]]:gpr32 = COPY $a0
  ; MIPS32FP64:   [[COPY1:%[0-9]+]]:gpr32 = COPY $a1
  ; MIPS32FP64:   [[COPY2:%[0-9]+]]:gpr32 = COPY $a2
  ; MIPS32FP64:   [[ANDi:%[0-9]+]]:gpr32 = ANDi [[COPY]], 1
  ; MIPS32FP64:   BNE [[ANDi]], $zero, %bb.1, implicit-def $at
  ; MIPS32FP64:   J %bb.2, implicit-def $at
  ; MIPS32FP64: bb.1.cond.true:
  ; MIPS32FP64:   successors: %bb.3(0x80000000)
  ; MIPS32FP64:   J %bb.3, implicit-def $at
  ; MIPS32FP64: bb.2.cond.false:
  ; MIPS32FP64:   successors: %bb.3(0x80000000)
  ; MIPS32FP64: bb.3.cond.end:
  ; MIPS32FP64:   [[PHI:%[0-9]+]]:gpr32 = PHI [[COPY1]], %bb.1, [[COPY2]], %bb.2
  ; MIPS32FP64:   $v0 = COPY [[PHI]]
  ; MIPS32FP64:   RetRA implicit $v0
  bb.1.entry:
    liveins: $a0, $a1, $a2

    %3:gprb(s32) = COPY $a0
    %1:gprb(s32) = COPY $a1
    %2:gprb(s32) = COPY $a2
    %6:gprb(s32) = G_CONSTANT i32 1
    %7:gprb(s32) = COPY %3(s32)
    %5:gprb(s32) = G_AND %7, %6
    G_BRCOND %5(s32), %bb.2
    G_BR %bb.3

  bb.2.cond.true:
    G_BR %bb.4

  bb.3.cond.false:

  bb.4.cond.end:
    %4:gprb(s32) = G_PHI %1(s32), %bb.2, %2(s32), %bb.3
    $v0 = COPY %4(s32)
    RetRA implicit $v0

...
---
name:            phi_i64
alignment:       4
legalized:       true
regBankSelected: true
tracksRegLiveness: true
fixedStack:
  - { id: 0, offset: 20, size: 4, alignment: 4, isImmutable: true }
  - { id: 1, offset: 16, size: 4, alignment: 8, isImmutable: true }
body:             |
  ; MIPS32FP32-LABEL: name: phi_i64
  ; MIPS32FP32: bb.0.entry:
  ; MIPS32FP32:   successors: %bb.1(0x40000000), %bb.2(0x40000000)
  ; MIPS32FP32:   liveins: $a0, $a2, $a3
  ; MIPS32FP32:   [[COPY:%[0-9]+]]:gpr32 = COPY $a0
  ; MIPS32FP32:   [[COPY1:%[0-9]+]]:gpr32 = COPY $a2
  ; MIPS32FP32:   [[COPY2:%[0-9]+]]:gpr32 = COPY $a3
  ; MIPS32FP32:   [[ADDiu:%[0-9]+]]:gpr32 = ADDiu %fixed-stack.0, 0
  ; MIPS32FP32:   [[LW:%[0-9]+]]:gpr32 = LW [[ADDiu]], 0 :: (load 4 from %fixed-stack.0, align 8)
  ; MIPS32FP32:   [[ADDiu1:%[0-9]+]]:gpr32 = ADDiu %fixed-stack.1, 0
  ; MIPS32FP32:   [[LW1:%[0-9]+]]:gpr32 = LW [[ADDiu1]], 0 :: (load 4 from %fixed-stack.1)
  ; MIPS32FP32:   [[ANDi:%[0-9]+]]:gpr32 = ANDi [[COPY]], 1
  ; MIPS32FP32:   BNE [[ANDi]], $zero, %bb.1, implicit-def $at
  ; MIPS32FP32:   J %bb.2, implicit-def $at
  ; MIPS32FP32: bb.1.cond.true:
  ; MIPS32FP32:   successors: %bb.3(0x80000000)
  ; MIPS32FP32:   J %bb.3, implicit-def $at
  ; MIPS32FP32: bb.2.cond.false:
  ; MIPS32FP32:   successors: %bb.3(0x80000000)
  ; MIPS32FP32: bb.3.cond.end:
  ; MIPS32FP32:   [[PHI:%[0-9]+]]:gpr32 = PHI [[COPY1]], %bb.1, [[LW]], %bb.2
  ; MIPS32FP32:   [[PHI1:%[0-9]+]]:gpr32 = PHI [[COPY2]], %bb.1, [[LW1]], %bb.2
  ; MIPS32FP32:   $v0 = COPY [[PHI]]
  ; MIPS32FP32:   $v1 = COPY [[PHI1]]
  ; MIPS32FP32:   RetRA implicit $v0, implicit $v1
  ; MIPS32FP64-LABEL: name: phi_i64
  ; MIPS32FP64: bb.0.entry:
  ; MIPS32FP64:   successors: %bb.1(0x40000000), %bb.2(0x40000000)
  ; MIPS32FP64:   liveins: $a0, $a2, $a3
  ; MIPS32FP64:   [[COPY:%[0-9]+]]:gpr32 = COPY $a0
  ; MIPS32FP64:   [[COPY1:%[0-9]+]]:gpr32 = COPY $a2
  ; MIPS32FP64:   [[COPY2:%[0-9]+]]:gpr32 = COPY $a3
  ; MIPS32FP64:   [[ADDiu:%[0-9]+]]:gpr32 = ADDiu %fixed-stack.0, 0
  ; MIPS32FP64:   [[LW:%[0-9]+]]:gpr32 = LW [[ADDiu]], 0 :: (load 4 from %fixed-stack.0, align 8)
  ; MIPS32FP64:   [[ADDiu1:%[0-9]+]]:gpr32 = ADDiu %fixed-stack.1, 0
  ; MIPS32FP64:   [[LW1:%[0-9]+]]:gpr32 = LW [[ADDiu1]], 0 :: (load 4 from %fixed-stack.1)
  ; MIPS32FP64:   [[ANDi:%[0-9]+]]:gpr32 = ANDi [[COPY]], 1
  ; MIPS32FP64:   BNE [[ANDi]], $zero, %bb.1, implicit-def $at
  ; MIPS32FP64:   J %bb.2, implicit-def $at
  ; MIPS32FP64: bb.1.cond.true:
  ; MIPS32FP64:   successors: %bb.3(0x80000000)
  ; MIPS32FP64:   J %bb.3, implicit-def $at
  ; MIPS32FP64: bb.2.cond.false:
  ; MIPS32FP64:   successors: %bb.3(0x80000000)
  ; MIPS32FP64: bb.3.cond.end:
  ; MIPS32FP64:   [[PHI:%[0-9]+]]:gpr32 = PHI [[COPY1]], %bb.1, [[LW]], %bb.2
  ; MIPS32FP64:   [[PHI1:%[0-9]+]]:gpr32 = PHI [[COPY2]], %bb.1, [[LW1]], %bb.2
  ; MIPS32FP64:   $v0 = COPY [[PHI]]
  ; MIPS32FP64:   $v1 = COPY [[PHI1]]
  ; MIPS32FP64:   RetRA implicit $v0, implicit $v1
  bb.1.entry:
    liveins: $a0, $a2, $a3

    %3:gprb(s32) = COPY $a0
    %4:gprb(s32) = COPY $a2
    %5:gprb(s32) = COPY $a3
    %8:gprb(p0) = G_FRAME_INDEX %fixed-stack.1
    %6:gprb(s32) = G_LOAD %8(p0) :: (load 4 from %fixed-stack.1, align 8)
    %9:gprb(p0) = G_FRAME_INDEX %fixed-stack.0
    %7:gprb(s32) = G_LOAD %9(p0) :: (load 4 from %fixed-stack.0)
    %14:gprb(s32) = G_CONSTANT i32 1
    %15:gprb(s32) = COPY %3(s32)
    %13:gprb(s32) = G_AND %15, %14
    G_BRCOND %13(s32), %bb.2
    G_BR %bb.3

  bb.2.cond.true:
    G_BR %bb.4

  bb.3.cond.false:

  bb.4.cond.end:
    %20:gprb(s32) = G_PHI %4(s32), %bb.2, %6(s32), %bb.3
    %21:gprb(s32) = G_PHI %5(s32), %bb.2, %7(s32), %bb.3
    $v0 = COPY %20(s32)
    $v1 = COPY %21(s32)
    RetRA implicit $v0, implicit $v1

...
---
name:            phi_float
alignment:       4
legalized:       true
regBankSelected: true
tracksRegLiveness: true
body:             |
  ; MIPS32FP32-LABEL: name: phi_float
  ; MIPS32FP32: bb.0.entry:
  ; MIPS32FP32:   successors: %bb.1(0x40000000), %bb.2(0x40000000)
  ; MIPS32FP32:   liveins: $a0, $a1, $a2
  ; MIPS32FP32:   [[COPY:%[0-9]+]]:gpr32 = COPY $a0
  ; MIPS32FP32:   [[MTC1_:%[0-9]+]]:fgr32 = MTC1 $a1
  ; MIPS32FP32:   [[MTC1_1:%[0-9]+]]:fgr32 = MTC1 $a2
  ; MIPS32FP32:   [[ANDi:%[0-9]+]]:gpr32 = ANDi [[COPY]], 1
  ; MIPS32FP32:   BNE [[ANDi]], $zero, %bb.1, implicit-def $at
  ; MIPS32FP32:   J %bb.2, implicit-def $at
  ; MIPS32FP32: bb.1.cond.true:
  ; MIPS32FP32:   successors: %bb.3(0x80000000)
  ; MIPS32FP32:   J %bb.3, implicit-def $at
  ; MIPS32FP32: bb.2.cond.false:
  ; MIPS32FP32:   successors: %bb.3(0x80000000)
  ; MIPS32FP32: bb.3.cond.end:
  ; MIPS32FP32:   [[PHI:%[0-9]+]]:fgr32 = PHI [[MTC1_]], %bb.1, [[MTC1_1]], %bb.2
  ; MIPS32FP32:   $f0 = COPY [[PHI]]
  ; MIPS32FP32:   RetRA implicit $f0
  ; MIPS32FP64-LABEL: name: phi_float
  ; MIPS32FP64: bb.0.entry:
  ; MIPS32FP64:   successors: %bb.1(0x40000000), %bb.2(0x40000000)
  ; MIPS32FP64:   liveins: $a0, $a1, $a2
  ; MIPS32FP64:   [[COPY:%[0-9]+]]:gpr32 = COPY $a0
  ; MIPS32FP64:   [[MTC1_:%[0-9]+]]:fgr32 = MTC1 $a1
  ; MIPS32FP64:   [[MTC1_1:%[0-9]+]]:fgr32 = MTC1 $a2
  ; MIPS32FP64:   [[ANDi:%[0-9]+]]:gpr32 = ANDi [[COPY]], 1
  ; MIPS32FP64:   BNE [[ANDi]], $zero, %bb.1, implicit-def $at
  ; MIPS32FP64:   J %bb.2, implicit-def $at
  ; MIPS32FP64: bb.1.cond.true:
  ; MIPS32FP64:   successors: %bb.3(0x80000000)
  ; MIPS32FP64:   J %bb.3, implicit-def $at
  ; MIPS32FP64: bb.2.cond.false:
  ; MIPS32FP64:   successors: %bb.3(0x80000000)
  ; MIPS32FP64: bb.3.cond.end:
  ; MIPS32FP64:   [[PHI:%[0-9]+]]:fgr32 = PHI [[MTC1_]], %bb.1, [[MTC1_1]], %bb.2
  ; MIPS32FP64:   $f0 = COPY [[PHI]]
  ; MIPS32FP64:   RetRA implicit $f0
  bb.1.entry:
    liveins: $a0, $a1, $a2

    %3:gprb(s32) = COPY $a0
    %1:fgr32(s32) = MTC1 $a1
    %2:fgr32(s32) = MTC1 $a2
    %6:gprb(s32) = G_CONSTANT i32 1
    %7:gprb(s32) = COPY %3(s32)
    %5:gprb(s32) = G_AND %7, %6
    G_BRCOND %5(s32), %bb.2
    G_BR %bb.3

  bb.2.cond.true:
    G_BR %bb.4

  bb.3.cond.false:

  bb.4.cond.end:
    %4:fprb(s32) = G_PHI %1(s32), %bb.2, %2(s32), %bb.3
    $f0 = COPY %4(s32)
    RetRA implicit $f0

...
---
name:            phi_double
alignment:       4
legalized:       true
regBankSelected: true
tracksRegLiveness: true
fixedStack:
  - { id: 0, offset: 16, size: 4, alignment: 8, isImmutable: true }
body:             |
  ; MIPS32FP32-LABEL: name: phi_double
  ; MIPS32FP32: bb.0.entry:
  ; MIPS32FP32:   successors: %bb.1(0x40000000), %bb.2(0x40000000)
  ; MIPS32FP32:   liveins: $d6, $d7
  ; MIPS32FP32:   [[COPY:%[0-9]+]]:afgr64 = COPY $d6
  ; MIPS32FP32:   [[COPY1:%[0-9]+]]:afgr64 = COPY $d7
  ; MIPS32FP32:   [[ADDiu:%[0-9]+]]:gpr32 = ADDiu %fixed-stack.0, 0
  ; MIPS32FP32:   [[LW:%[0-9]+]]:gpr32 = LW [[ADDiu]], 0 :: (load 4 from %fixed-stack.0, align 8)
  ; MIPS32FP32:   [[ANDi:%[0-9]+]]:gpr32 = ANDi [[LW]], 1
  ; MIPS32FP32:   BNE [[ANDi]], $zero, %bb.1, implicit-def $at
  ; MIPS32FP32:   J %bb.2, implicit-def $at
  ; MIPS32FP32: bb.1.cond.true:
  ; MIPS32FP32:   successors: %bb.3(0x80000000)
  ; MIPS32FP32:   J %bb.3, implicit-def $at
  ; MIPS32FP32: bb.2.cond.false:
  ; MIPS32FP32:   successors: %bb.3(0x80000000)
  ; MIPS32FP32: bb.3.cond.end:
  ; MIPS32FP32:   [[PHI:%[0-9]+]]:afgr64 = PHI [[COPY]], %bb.1, [[COPY1]], %bb.2
  ; MIPS32FP32:   $d0 = COPY [[PHI]]
  ; MIPS32FP32:   RetRA implicit $d0
  ; MIPS32FP64-LABEL: name: phi_double
  ; MIPS32FP64: bb.0.entry:
  ; MIPS32FP64:   successors: %bb.1(0x40000000), %bb.2(0x40000000)
  ; MIPS32FP64:   liveins: $d6, $d7
  ; MIPS32FP64:   [[COPY:%[0-9]+]]:fgr64 = COPY $d6
  ; MIPS32FP64:   [[COPY1:%[0-9]+]]:fgr64 = COPY $d7
  ; MIPS32FP64:   [[ADDiu:%[0-9]+]]:gpr32 = ADDiu %fixed-stack.0, 0
  ; MIPS32FP64:   [[LW:%[0-9]+]]:gpr32 = LW [[ADDiu]], 0 :: (load 4 from %fixed-stack.0, align 8)
  ; MIPS32FP64:   [[ANDi:%[0-9]+]]:gpr32 = ANDi [[LW]], 1
  ; MIPS32FP64:   BNE [[ANDi]], $zero, %bb.1, implicit-def $at
  ; MIPS32FP64:   J %bb.2, implicit-def $at
  ; MIPS32FP64: bb.1.cond.true:
  ; MIPS32FP64:   successors: %bb.3(0x80000000)
  ; MIPS32FP64:   J %bb.3, implicit-def $at
  ; MIPS32FP64: bb.2.cond.false:
  ; MIPS32FP64:   successors: %bb.3(0x80000000)
  ; MIPS32FP64: bb.3.cond.end:
  ; MIPS32FP64:   [[PHI:%[0-9]+]]:fgr64 = PHI [[COPY]], %bb.1, [[COPY1]], %bb.2
  ; MIPS32FP64:   $d0 = COPY [[PHI]]
  ; MIPS32FP64:   RetRA implicit $d0
  bb.1.entry:
    liveins: $d6, $d7

    %0:fprb(s64) = COPY $d6
    %1:fprb(s64) = COPY $d7
    %4:gprb(p0) = G_FRAME_INDEX %fixed-stack.0
    %3:gprb(s32) = G_LOAD %4(p0) :: (load 4 from %fixed-stack.0, align 8)
    %7:gprb(s32) = G_CONSTANT i32 1
    %8:gprb(s32) = COPY %3(s32)
    %6:gprb(s32) = G_AND %8, %7
    G_BRCOND %6(s32), %bb.2
    G_BR %bb.3

  bb.2.cond.true:
    G_BR %bb.4

  bb.3.cond.false:

  bb.4.cond.end:
    %5:fprb(s64) = G_PHI %0(s64), %bb.2, %1(s64), %bb.3
    $d0 = COPY %5(s64)
    RetRA implicit $d0

...
