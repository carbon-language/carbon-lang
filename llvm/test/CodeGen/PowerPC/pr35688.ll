; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -enable-mssa-loop-dependency=false -verify-machineinstrs -mtriple=powerpc64le-unknown-unknown < %s  | \
; RUN:   FileCheck %s
; RUN: llc -enable-mssa-loop-dependency=true -verify-machineinstrs -mtriple=powerpc64le-unknown-unknown < %s  | \
; RUN:   FileCheck %s --check-prefix=MSSA
; Function Attrs: nounwind
define void @ec_GFp_nistp256_points_mul() {
; CHECK-LABEL: ec_GFp_nistp256_points_mul:
; CHECK:    ld 4, 0(3)
; CHECK:    li 3, 0
; CHECK:    subfic 5, 4, 0
; CHECK:    subfze 5, 3
; CHECK:    sradi 5, 5, 63
; CHECK:    subfc 4, 4, 5
; CHECK:    subfe 4, 3, 5
; CHECK:    sradi 4, 4, 63

; With MemorySSA, everything is taken out of the loop by licm.
; Loads and stores to undef are treated as non-aliasing.
; MSSA-LABEL: ec_GFp_nistp256_points_mul
; MSSA:     ld 3, 0(3)
; MSSA:     li 4, 0
; MSSA:     subfic 5, 3, 0
; MSSA:     subfze 5, 4
; MSSA:     sradi 5, 5, 63
; MSSA:     subfc 3, 3, 5
; MSSA:     subfe 3, 4, 5
; MSSA:     sradi 3, 3, 63
; MSSA:     std 3, 0(3)
entry:
  br label %fe_cmovznz.exit.i534.i.15

fe_cmovznz.exit.i534.i.15:                        ; preds = %fe_cmovznz.exit.i534.i.15, %entry
  %0 = load i64, i64* undef, align 8
  %1 = load i64, i64* undef, align 8
  %conv.i69.i.i = zext i64 %0 to i128
  %sub.i72.i.i = sub nsw i128 0, %conv.i69.i.i
  %conv.i63.i.i = zext i64 %1 to i128
  %add.neg.i.i.i = ashr i128 %sub.i72.i.i, 127
  %sub.i65.i.i = sub nsw i128 %add.neg.i.i.i, %conv.i63.i.i
  %sub.i65.lobit.i.i = ashr i128 %sub.i65.i.i, 127
  %conv1.i58.i.i = and i128 %sub.i65.lobit.i.i, 18446744073709551615
  %add3.i59.i.i = add nuw nsw i128 %conv1.i58.i.i, 0
  %conv4.i60.i.i = trunc i128 %add3.i59.i.i to i64
  store i64 %conv4.i60.i.i, i64* undef, align 16
  br label %fe_cmovznz.exit.i534.i.15
}

