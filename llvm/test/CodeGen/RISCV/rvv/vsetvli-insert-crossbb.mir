# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
# RUN: llc %s -o - -mtriple=riscv64 -mattr=experimental-v \
# RUN:     -run-pass=riscv-insert-vsetvli | FileCheck %s

--- |
  ; ModuleID = 'vsetvli-insert.ll'
  source_filename = "vsetvli-insert.ll"
  target datalayout = "e-m:e-p:64:64-i64:64-i128:128-n64-S128"
  target triple = "riscv64"

  define <vscale x 1 x i64> @load_add_or_sub(i8 zeroext %cond, <vscale x 1 x i64>* %0, <vscale x 1 x i64> %1, i64 %2) #0 {
  entry:
    %a = call <vscale x 1 x i64> @llvm.riscv.vle.nxv1i64.i64(<vscale x 1 x i64>* %0, i64 %2)
    %tobool = icmp eq i8 %cond, 0
    br i1 %tobool, label %if.else, label %if.then

  if.then:                                          ; preds = %entry
    %b = call <vscale x 1 x i64> @llvm.riscv.vadd.nxv1i64.nxv1i64.i64(<vscale x 1 x i64> %a, <vscale x 1 x i64> %1, i64 %2)
    br label %if.end

  if.else:                                          ; preds = %entry
    %c = call <vscale x 1 x i64> @llvm.riscv.vsub.nxv1i64.nxv1i64.i64(<vscale x 1 x i64> %a, <vscale x 1 x i64> %1, i64 %2)
    br label %if.end

  if.end:                                           ; preds = %if.else, %if.then
    %d = phi <vscale x 1 x i64> [ %b, %if.then ], [ %c, %if.else ]
    ret <vscale x 1 x i64> %d
  }

  define void @load_zext_or_sext(i8 zeroext %cond, <vscale x 1 x i32>* %0, <vscale x 1 x i64>* %1, i64 %2) #0 {
  entry:
    %a = call <vscale x 1 x i32> @llvm.riscv.vle.nxv1i32.i64(<vscale x 1 x i32>* %0, i64 %2)
    %tobool = icmp eq i8 %cond, 0
    br i1 %tobool, label %if.else, label %if.then

  if.then:                                          ; preds = %entry
    %b = call <vscale x 1 x i64> @llvm.riscv.vzext.nxv1i64.nxv1i32.i64(<vscale x 1 x i32> %a, i64 %2)
    br label %if.end

  if.else:                                          ; preds = %entry
    %c = call <vscale x 1 x i64> @llvm.riscv.vsext.nxv1i64.nxv1i32.i64(<vscale x 1 x i32> %a, i64 %2)
    br label %if.end

  if.end:                                           ; preds = %if.else, %if.then
    %d = phi <vscale x 1 x i64> [ %b, %if.then ], [ %c, %if.else ]
    call void @llvm.riscv.vse.nxv1i64.i64(<vscale x 1 x i64> %d, <vscale x 1 x i64>* %1, i64 %2)
    ret void
  }

  ; Function Attrs: nounwind readnone
  declare i64 @llvm.riscv.vmv.x.s.nxv1i64(<vscale x 1 x i64>) #1

  define i64 @vmv_x_s(i8 zeroext %cond, <vscale x 1 x i64> %0, <vscale x 1 x i64> %1, i64 %2) #0 {
  entry:
    %tobool = icmp eq i8 %cond, 0
    br i1 %tobool, label %if.else, label %if.then

  if.then:                                          ; preds = %entry
    %a = call <vscale x 1 x i64> @llvm.riscv.vadd.nxv1i64.nxv1i64.i64(<vscale x 1 x i64> %0, <vscale x 1 x i64> %1, i64 %2)
    br label %if.end

  if.else:                                          ; preds = %entry
    %b = call <vscale x 1 x i64> @llvm.riscv.vsub.nxv1i64.nxv1i64.i64(<vscale x 1 x i64> %1, <vscale x 1 x i64> %1, i64 %2)
    br label %if.end

  if.end:                                           ; preds = %if.else, %if.then
    %c = phi <vscale x 1 x i64> [ %a, %if.then ], [ %b, %if.else ]
    %d = call i64 @llvm.riscv.vmv.x.s.nxv1i64(<vscale x 1 x i64> %c)
    ret i64 %d
  }

  ; Function Attrs: nounwind
  declare i64 @llvm.riscv.vsetvli.i64(i64, i64 immarg, i64 immarg) #2

  define <vscale x 1 x i64> @vsetvli_add_or_sub(i8 zeroext %cond, <vscale x 1 x i64> %0, <vscale x 1 x i64> %1, i64 %avl) #0 {
  entry:
    %vl = call i64 @llvm.riscv.vsetvli.i64(i64 %avl, i64 3, i64 0)
    %tobool = icmp eq i8 %cond, 0
    br i1 %tobool, label %if.else, label %if.then

  if.then:                                          ; preds = %entry
    %b = call <vscale x 1 x i64> @llvm.riscv.vadd.nxv1i64.nxv1i64.i64(<vscale x 1 x i64> %0, <vscale x 1 x i64> %1, i64 %vl)
    br label %if.end

  if.else:                                          ; preds = %entry
    %c = call <vscale x 1 x i64> @llvm.riscv.vsub.nxv1i64.nxv1i64.i64(<vscale x 1 x i64> %0, <vscale x 1 x i64> %1, i64 %vl)
    br label %if.end

  if.end:                                           ; preds = %if.else, %if.then
    %d = phi <vscale x 1 x i64> [ %b, %if.then ], [ %c, %if.else ]
    ret <vscale x 1 x i64> %d
  }

  ; Function Attrs: nounwind readnone
  declare <vscale x 1 x i64> @llvm.riscv.vadd.nxv1i64.nxv1i64.i64(<vscale x 1 x i64>, <vscale x 1 x i64>, i64) #1

  ; Function Attrs: nounwind readnone
  declare <vscale x 1 x i64> @llvm.riscv.vsub.nxv1i64.nxv1i64.i64(<vscale x 1 x i64>, <vscale x 1 x i64>, i64) #1

  ; Function Attrs: nounwind readonly
  declare <vscale x 1 x i64> @llvm.riscv.vle.nxv1i64.i64(<vscale x 1 x i64>* nocapture, i64) #3

  ; Function Attrs: nounwind readonly
  declare <vscale x 1 x i32> @llvm.riscv.vle.nxv1i32.i64(<vscale x 1 x i32>* nocapture, i64) #3

  ; Function Attrs: nounwind writeonly
  declare void @llvm.riscv.vse.nxv1i64.i64(<vscale x 1 x i64>, <vscale x 1 x i64>* nocapture, i64) #4

  ; Function Attrs: nounwind readnone
  declare <vscale x 1 x i64> @llvm.riscv.vzext.nxv1i64.nxv1i32.i64(<vscale x 1 x i32>, i64) #1

  ; Function Attrs: nounwind readnone
  declare <vscale x 1 x i64> @llvm.riscv.vsext.nxv1i64.nxv1i32.i64(<vscale x 1 x i32>, i64) #1

  attributes #0 = { "target-features"="+experimental-v" }
  attributes #1 = { nounwind readnone }
  attributes #2 = { nounwind }
  attributes #3 = { nounwind readonly }
  attributes #4 = { nounwind writeonly }

...
---
name:            load_add_or_sub
alignment:       4
tracksRegLiveness: true
registers:
  - { id: 0, class: vr }
  - { id: 1, class: vr }
  - { id: 2, class: vr }
  - { id: 3, class: vr }
  - { id: 4, class: gpr }
  - { id: 5, class: gpr }
  - { id: 6, class: vr }
  - { id: 7, class: gpr }
  - { id: 8, class: gpr }
liveins:
  - { reg: '$x10', virtual-reg: '%4' }
  - { reg: '$x11', virtual-reg: '%5' }
  - { reg: '$v8', virtual-reg: '%6' }
  - { reg: '$x12', virtual-reg: '%7' }
frameInfo:
  maxAlignment:    1
machineFunctionInfo: {}
body:             |
  ; CHECK-LABEL: name: load_add_or_sub
  ; CHECK: bb.0.entry:
  ; CHECK:   successors: %bb.2(0x30000000), %bb.1(0x50000000)
  ; CHECK:   liveins: $x10, $x11, $v8, $x12
  ; CHECK:   [[COPY:%[0-9]+]]:gpr = COPY $x12
  ; CHECK:   [[COPY1:%[0-9]+]]:vr = COPY $v8
  ; CHECK:   [[COPY2:%[0-9]+]]:gpr = COPY $x11
  ; CHECK:   [[COPY3:%[0-9]+]]:gpr = COPY $x10
  ; CHECK:   dead $x0 = PseudoVSETVLI [[COPY]], 88, implicit-def $vl, implicit-def $vtype
  ; CHECK:   [[PseudoVLE64_V_M1_:%[0-9]+]]:vr = PseudoVLE64_V_M1 [[COPY2]], $noreg, 6, implicit $vl, implicit $vtype
  ; CHECK:   [[COPY4:%[0-9]+]]:gpr = COPY $x0
  ; CHECK:   BEQ [[COPY3]], [[COPY4]], %bb.2
  ; CHECK:   PseudoBR %bb.1
  ; CHECK: bb.1.if.then:
  ; CHECK:   successors: %bb.3(0x80000000)
  ; CHECK:   [[PseudoVADD_VV_M1_:%[0-9]+]]:vr = PseudoVADD_VV_M1 [[PseudoVLE64_V_M1_]], [[COPY1]], $noreg, 6, implicit $vl, implicit $vtype
  ; CHECK:   PseudoBR %bb.3
  ; CHECK: bb.2.if.else:
  ; CHECK:   successors: %bb.3(0x80000000)
  ; CHECK:   [[PseudoVSUB_VV_M1_:%[0-9]+]]:vr = PseudoVSUB_VV_M1 [[PseudoVLE64_V_M1_]], [[COPY1]], $noreg, 6, implicit $vl, implicit $vtype
  ; CHECK: bb.3.if.end:
  ; CHECK:   [[PHI:%[0-9]+]]:vr = PHI [[PseudoVADD_VV_M1_]], %bb.1, [[PseudoVSUB_VV_M1_]], %bb.2
  ; CHECK:   $v8 = COPY [[PHI]]
  ; CHECK:   PseudoRET implicit $v8
  bb.0.entry:
    successors: %bb.2(0x30000000), %bb.1(0x50000000)
    liveins: $x10, $x11, $v8, $x12

    %7:gpr = COPY $x12
    %6:vr = COPY $v8
    %5:gpr = COPY $x11
    %4:gpr = COPY $x10
    %0:vr = PseudoVLE64_V_M1 %5, %7, 6
    %8:gpr = COPY $x0
    BEQ %4, %8, %bb.2
    PseudoBR %bb.1

  bb.1.if.then:
    %1:vr = PseudoVADD_VV_M1 %0, %6, %7, 6
    PseudoBR %bb.3

  bb.2.if.else:
    %2:vr = PseudoVSUB_VV_M1 %0, %6, %7, 6

  bb.3.if.end:
    %3:vr = PHI %1, %bb.1, %2, %bb.2
    $v8 = COPY %3
    PseudoRET implicit $v8

...
---
name:            load_zext_or_sext
alignment:       4
tracksRegLiveness: true
registers:
  - { id: 0, class: vr }
  - { id: 1, class: vr }
  - { id: 2, class: vr }
  - { id: 3, class: vr }
  - { id: 4, class: gpr }
  - { id: 5, class: gpr }
  - { id: 6, class: gpr }
  - { id: 7, class: gpr }
  - { id: 8, class: gpr }
liveins:
  - { reg: '$x10', virtual-reg: '%4' }
  - { reg: '$x11', virtual-reg: '%5' }
  - { reg: '$x12', virtual-reg: '%6' }
  - { reg: '$x13', virtual-reg: '%7' }
frameInfo:
  maxAlignment:    1
machineFunctionInfo: {}
body:             |
  ; CHECK-LABEL: name: load_zext_or_sext
  ; CHECK: bb.0.entry:
  ; CHECK:   successors: %bb.2(0x30000000), %bb.1(0x50000000)
  ; CHECK:   liveins: $x10, $x11, $x12, $x13
  ; CHECK:   [[COPY:%[0-9]+]]:gpr = COPY $x13
  ; CHECK:   [[COPY1:%[0-9]+]]:gpr = COPY $x12
  ; CHECK:   [[COPY2:%[0-9]+]]:gpr = COPY $x11
  ; CHECK:   [[COPY3:%[0-9]+]]:gpr = COPY $x10
  ; CHECK:   dead $x0 = PseudoVSETVLI [[COPY]], 87, implicit-def $vl, implicit-def $vtype
  ; CHECK:   [[PseudoVLE32_V_MF2_:%[0-9]+]]:vr = PseudoVLE32_V_MF2 [[COPY2]], $noreg, 5, implicit $vl, implicit $vtype
  ; CHECK:   [[COPY4:%[0-9]+]]:gpr = COPY $x0
  ; CHECK:   BEQ [[COPY3]], [[COPY4]], %bb.2
  ; CHECK:   PseudoBR %bb.1
  ; CHECK: bb.1.if.then:
  ; CHECK:   successors: %bb.3(0x80000000)
  ; CHECK:   dead $x0 = PseudoVSETVLI killed $x0, 88, implicit-def $vl, implicit-def $vtype, implicit $vl
  ; CHECK:   early-clobber %1:vr = PseudoVZEXT_VF2_M1 [[PseudoVLE32_V_MF2_]], $noreg, 6, implicit $vl, implicit $vtype
  ; CHECK:   PseudoBR %bb.3
  ; CHECK: bb.2.if.else:
  ; CHECK:   successors: %bb.3(0x80000000)
  ; CHECK:   dead $x0 = PseudoVSETVLI killed $x0, 88, implicit-def $vl, implicit-def $vtype, implicit $vl
  ; CHECK:   early-clobber %2:vr = PseudoVSEXT_VF2_M1 [[PseudoVLE32_V_MF2_]], $noreg, 6, implicit $vl, implicit $vtype
  ; CHECK: bb.3.if.end:
  ; CHECK:   [[PHI:%[0-9]+]]:vr = PHI %1, %bb.1, %2, %bb.2
  ; CHECK:   PseudoVSE64_V_M1 [[PHI]], [[COPY1]], $noreg, 6, implicit $vl, implicit $vtype
  ; CHECK:   PseudoRET
  bb.0.entry:
    successors: %bb.2(0x30000000), %bb.1(0x50000000)
    liveins: $x10, $x11, $x12, $x13

    %7:gpr = COPY $x13
    %6:gpr = COPY $x12
    %5:gpr = COPY $x11
    %4:gpr = COPY $x10
    %0:vr = PseudoVLE32_V_MF2 %5, %7, 5
    %8:gpr = COPY $x0
    BEQ %4, %8, %bb.2
    PseudoBR %bb.1

  bb.1.if.then:
    early-clobber %1:vr = PseudoVZEXT_VF2_M1 %0, %7, 6
    PseudoBR %bb.3

  bb.2.if.else:
    early-clobber %2:vr = PseudoVSEXT_VF2_M1 %0, %7, 6

  bb.3.if.end:
    %3:vr = PHI %1, %bb.1, %2, %bb.2
    PseudoVSE64_V_M1 %3, %6, %7, 6
    PseudoRET

...
---
name:            vmv_x_s
alignment:       4
tracksRegLiveness: true
registers:
  - { id: 0, class: vr }
  - { id: 1, class: vr }
  - { id: 2, class: vr }
  - { id: 3, class: gpr }
  - { id: 4, class: vr }
  - { id: 5, class: vr }
  - { id: 6, class: gpr }
  - { id: 7, class: gpr }
  - { id: 8, class: gpr }
liveins:
  - { reg: '$x10', virtual-reg: '%3' }
  - { reg: '$v8', virtual-reg: '%4' }
  - { reg: '$v9', virtual-reg: '%5' }
  - { reg: '$x11', virtual-reg: '%6' }
frameInfo:
  maxAlignment:    1
machineFunctionInfo: {}
body:             |
  ; CHECK-LABEL: name: vmv_x_s
  ; CHECK: bb.0.entry:
  ; CHECK:   successors: %bb.2(0x30000000), %bb.1(0x50000000)
  ; CHECK:   liveins: $x10, $v8, $v9, $x11
  ; CHECK:   [[COPY:%[0-9]+]]:gpr = COPY $x11
  ; CHECK:   [[COPY1:%[0-9]+]]:vr = COPY $v9
  ; CHECK:   [[COPY2:%[0-9]+]]:vr = COPY $v8
  ; CHECK:   [[COPY3:%[0-9]+]]:gpr = COPY $x10
  ; CHECK:   [[COPY4:%[0-9]+]]:gpr = COPY $x0
  ; CHECK:   BEQ [[COPY3]], [[COPY4]], %bb.2
  ; CHECK:   PseudoBR %bb.1
  ; CHECK: bb.1.if.then:
  ; CHECK:   successors: %bb.3(0x80000000)
  ; CHECK:   dead $x0 = PseudoVSETVLI [[COPY]], 88, implicit-def $vl, implicit-def $vtype
  ; CHECK:   [[PseudoVADD_VV_M1_:%[0-9]+]]:vr = PseudoVADD_VV_M1 [[COPY2]], [[COPY1]], $noreg, 6, implicit $vl, implicit $vtype
  ; CHECK:   PseudoBR %bb.3
  ; CHECK: bb.2.if.else:
  ; CHECK:   successors: %bb.3(0x80000000)
  ; CHECK:   dead $x0 = PseudoVSETVLI [[COPY]], 88, implicit-def $vl, implicit-def $vtype
  ; CHECK:   [[PseudoVSUB_VV_M1_:%[0-9]+]]:vr = PseudoVSUB_VV_M1 [[COPY1]], [[COPY1]], $noreg, 6, implicit $vl, implicit $vtype
  ; CHECK: bb.3.if.end:
  ; CHECK:   [[PHI:%[0-9]+]]:vr = PHI [[PseudoVADD_VV_M1_]], %bb.1, [[PseudoVSUB_VV_M1_]], %bb.2
  ; CHECK:   [[PseudoVMV_X_S_M1_:%[0-9]+]]:gpr = PseudoVMV_X_S_M1 [[PHI]], 6, implicit $vtype
  ; CHECK:   $x10 = COPY [[PseudoVMV_X_S_M1_]]
  ; CHECK:   PseudoRET implicit $x10
  bb.0.entry:
    successors: %bb.2(0x30000000), %bb.1(0x50000000)
    liveins: $x10, $v8, $v9, $x11

    %6:gpr = COPY $x11
    %5:vr = COPY $v9
    %4:vr = COPY $v8
    %3:gpr = COPY $x10
    %7:gpr = COPY $x0
    BEQ %3, %7, %bb.2
    PseudoBR %bb.1

  bb.1.if.then:
    %0:vr = PseudoVADD_VV_M1 %4, %5, %6, 6
    PseudoBR %bb.3

  bb.2.if.else:
    %1:vr = PseudoVSUB_VV_M1 %5, %5, %6, 6

  bb.3.if.end:
    %2:vr = PHI %0, %bb.1, %1, %bb.2
    %8:gpr = PseudoVMV_X_S_M1 %2, 6
    $x10 = COPY %8
    PseudoRET implicit $x10

...
---
name:            vsetvli_add_or_sub
alignment:       4
tracksRegLiveness: true
registers:
  - { id: 0, class: gpr }
  - { id: 1, class: vr }
  - { id: 2, class: vr }
  - { id: 3, class: vr }
  - { id: 4, class: gpr }
  - { id: 5, class: vr }
  - { id: 6, class: vr }
  - { id: 7, class: gpr }
  - { id: 8, class: gpr }
liveins:
  - { reg: '$x10', virtual-reg: '%4' }
  - { reg: '$v8', virtual-reg: '%5' }
  - { reg: '$v9', virtual-reg: '%6' }
  - { reg: '$x11', virtual-reg: '%7' }
frameInfo:
  maxAlignment:    1
machineFunctionInfo: {}
body:             |
  ; CHECK-LABEL: name: vsetvli_add_or_sub
  ; CHECK: bb.0.entry:
  ; CHECK:   successors: %bb.2(0x30000000), %bb.1(0x50000000)
  ; CHECK:   liveins: $x10, $v8, $v9, $x11
  ; CHECK:   [[COPY:%[0-9]+]]:gpr = COPY $x11
  ; CHECK:   [[COPY1:%[0-9]+]]:vr = COPY $v9
  ; CHECK:   [[COPY2:%[0-9]+]]:vr = COPY $v8
  ; CHECK:   [[COPY3:%[0-9]+]]:gpr = COPY $x10
  ; CHECK:   [[PseudoVSETVLI:%[0-9]+]]:gpr = PseudoVSETVLI [[COPY]], 88, implicit-def $vl, implicit-def $vtype
  ; CHECK:   [[COPY4:%[0-9]+]]:gpr = COPY $x0
  ; CHECK:   BEQ [[COPY3]], [[COPY4]], %bb.2
  ; CHECK:   PseudoBR %bb.1
  ; CHECK: bb.1.if.then:
  ; CHECK:   successors: %bb.3(0x80000000)
  ; CHECK:   [[PseudoVADD_VV_M1_:%[0-9]+]]:vr = PseudoVADD_VV_M1 [[COPY2]], [[COPY1]], $noreg, 6, implicit $vl, implicit $vtype
  ; CHECK:   PseudoBR %bb.3
  ; CHECK: bb.2.if.else:
  ; CHECK:   successors: %bb.3(0x80000000)
  ; CHECK:   [[PseudoVSUB_VV_M1_:%[0-9]+]]:vr = PseudoVSUB_VV_M1 [[COPY2]], [[COPY1]], $noreg, 6, implicit $vl, implicit $vtype
  ; CHECK: bb.3.if.end:
  ; CHECK:   [[PHI:%[0-9]+]]:vr = PHI [[PseudoVADD_VV_M1_]], %bb.1, [[PseudoVSUB_VV_M1_]], %bb.2
  ; CHECK:   $v8 = COPY [[PHI]]
  ; CHECK:   PseudoRET implicit $v8
  bb.0.entry:
    successors: %bb.2(0x30000000), %bb.1(0x50000000)
    liveins: $x10, $v8, $v9, $x11

    %7:gpr = COPY $x11
    %6:vr = COPY $v9
    %5:vr = COPY $v8
    %4:gpr = COPY $x10
    %0:gpr = PseudoVSETVLI %7, 88, implicit-def dead $vl, implicit-def dead $vtype
    %8:gpr = COPY $x0
    BEQ %4, %8, %bb.2
    PseudoBR %bb.1

  bb.1.if.then:
    %1:vr = PseudoVADD_VV_M1 %5, %6, %0, 6
    PseudoBR %bb.3

  bb.2.if.else:
    %2:vr = PseudoVSUB_VV_M1 %5, %6, %0, 6

  bb.3.if.end:
    %3:vr = PHI %1, %bb.1, %2, %bb.2
    $v8 = COPY %3
    PseudoRET implicit $v8

...
