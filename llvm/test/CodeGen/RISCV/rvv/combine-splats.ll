; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=riscv32 -mattr=+m,+v < %s | FileCheck %s
; RUN: llc -mtriple=riscv64 -mattr=+m,+v < %s | FileCheck %s

; fold (and (or x, C), D) -> D if (C & D) == D

define <vscale x 4 x i32> @and_or_nxv4i32(<vscale x 4 x i32> %A) {
; CHECK-LABEL: and_or_nxv4i32:
; CHECK:       # %bb.0:
; CHECK-NEXT:    vsetvli a0, zero, e32, m2, ta, mu
; CHECK-NEXT:    vmv.v.i v8, 8
; CHECK-NEXT:    ret
  %ins1 = insertelement <vscale x 4 x i32> poison, i32 255, i32 0
  %splat1 = shufflevector <vscale x 4 x i32> %ins1, <vscale x 4 x i32> poison, <vscale x 4 x i32> zeroinitializer
  %ins2 = insertelement <vscale x 4 x i32> poison, i32 8, i32 0
  %splat2 = shufflevector <vscale x 4 x i32> %ins2, <vscale x 4 x i32> poison, <vscale x 4 x i32> zeroinitializer
  %v1 = or <vscale x 4 x i32> %A, %splat1
  %v2 = and <vscale x 4 x i32> %v1, %splat2
  ret <vscale x 4 x i32> %v2
}

; (or (and X, c1), c2) -> (and (or X, c2), c1|c2) iff (c1 & c2) != 0

define <vscale x 2 x i64> @or_and_nxv2i64(<vscale x 2 x i64> %a0) {
; CHECK-LABEL: or_and_nxv2i64:
; CHECK:       # %bb.0:
; CHECK-NEXT:    vsetvli a0, zero, e64, m2, ta, mu
; CHECK-NEXT:    vor.vi v8, v8, 3
; CHECK-NEXT:    vand.vi v8, v8, 7
; CHECK-NEXT:    ret
  %ins1 = insertelement <vscale x 2 x i64> poison, i64 7, i32 0
  %splat1 = shufflevector <vscale x 2 x i64> %ins1, <vscale x 2 x i64> poison, <vscale x 2 x i32> zeroinitializer
  %ins2 = insertelement <vscale x 2 x i64> poison, i64 3, i32 0
  %splat2 = shufflevector <vscale x 2 x i64> %ins2, <vscale x 2 x i64> poison, <vscale x 2 x i32> zeroinitializer
  %v1 = and <vscale x 2 x i64> %a0, %splat1
  %v2 = or <vscale x 2 x i64> %v1, %splat2
  ret <vscale x 2 x i64> %v2
}

; If all masked bits are going to be set, that's a constant fold.

define <vscale x 2 x i64> @or_and_nxv2i64_fold(<vscale x 2 x i64> %a0) {
; CHECK-LABEL: or_and_nxv2i64_fold:
; CHECK:       # %bb.0:
; CHECK-NEXT:    vsetvli a0, zero, e64, m2, ta, mu
; CHECK-NEXT:    vmv.v.i v8, 3
; CHECK-NEXT:    ret
  %ins1 = insertelement <vscale x 2 x i64> poison, i64 1, i32 0
  %splat1 = shufflevector <vscale x 2 x i64> %ins1, <vscale x 2 x i64> poison, <vscale x 2 x i32> zeroinitializer
  %ins2 = insertelement <vscale x 2 x i64> poison, i64 3, i32 0
  %splat2 = shufflevector <vscale x 2 x i64> %ins2, <vscale x 2 x i64> poison, <vscale x 2 x i32> zeroinitializer
  %v1 = and <vscale x 2 x i64> %a0, %splat1
  %v2 = or <vscale x 2 x i64> %v1, %splat2
  ret <vscale x 2 x i64> %v2
}

; fold (shl (shl x, c1), c2) -> (shl x, (add c1, c2))

define <vscale x 4 x i32> @combine_vec_shl_shl(<vscale x 4 x i32> %x) {
; CHECK-LABEL: combine_vec_shl_shl:
; CHECK:       # %bb.0:
; CHECK-NEXT:    li a0, 2
; CHECK-NEXT:    vsetvli a1, zero, e32, m2, ta, mu
; CHECK-NEXT:    vmv.s.x v10, a0
; CHECK-NEXT:    li a0, 4
; CHECK-NEXT:    vmv.s.x v12, a0
; CHECK-NEXT:    vsll.vv v8, v8, v10
; CHECK-NEXT:    vsll.vv v8, v8, v12
; CHECK-NEXT:    ret
  %ins1 = insertelement <vscale x 4 x i32> poison, i32 2, i32 0
  %splat1 = shufflevector <vscale x 4 x i32> %ins1, <vscale x 4 x i32> poison, <vscale x 4 x i32> zeroinitializer
  %ins2 = insertelement <vscale x 4 x i32> poison, i32 4, i32 0
  %splat2 = shufflevector <vscale x 4 x i32> %ins2, <vscale x 4 x i32> poison, <vscale x 4 x i32> zeroinitializer
  %v1 = shl <vscale x 4 x i32> %x, %ins1
  %v2 = shl <vscale x 4 x i32> %v1, %ins2
  ret <vscale x 4 x i32> %v2
}

; fold (sra (sra x, c1), c2) -> (sra x, (add c1, c2))

define <vscale x 2 x i32> @combine_vec_ashr_ashr(<vscale x 2 x i32> %x) {
; CHECK-LABEL: combine_vec_ashr_ashr:
; CHECK:       # %bb.0:
; CHECK-NEXT:    vsetvli a0, zero, e32, m1, ta, mu
; CHECK-NEXT:    vsra.vi v8, v8, 6
; CHECK-NEXT:    ret
  %ins1 = insertelement <vscale x 2 x i32> poison, i32 2, i32 0
  %splat1 = shufflevector <vscale x 2 x i32> %ins1, <vscale x 2 x i32> poison, <vscale x 2 x i32> zeroinitializer
  %ins2 = insertelement <vscale x 2 x i32> poison, i32 4, i32 0
  %splat2 = shufflevector <vscale x 2 x i32> %ins2, <vscale x 2 x i32> poison, <vscale x 2 x i32> zeroinitializer
  %v1 = ashr <vscale x 2 x i32> %x, %splat1
  %v2 = ashr <vscale x 2 x i32> %v1, %splat2
  ret <vscale x 2 x i32> %v2
}

; fold (srl (srl x, c1), c2) -> (srl x, (add c1, c2))

define <vscale x 8 x i16> @combine_vec_lshr_lshr(<vscale x 8 x i16> %x) {
; CHECK-LABEL: combine_vec_lshr_lshr:
; CHECK:       # %bb.0:
; CHECK-NEXT:    vsetvli a0, zero, e16, m2, ta, mu
; CHECK-NEXT:    vsrl.vi v8, v8, 8
; CHECK-NEXT:    ret
  %ins1 = insertelement <vscale x 8 x i16> poison, i16 2, i32 0
  %splat1 = shufflevector <vscale x 8 x i16> %ins1, <vscale x 8 x i16> poison, <vscale x 8 x i32> zeroinitializer
  %ins2 = insertelement <vscale x 8 x i16> poison, i16 4, i32 0
  %splat2 = shufflevector <vscale x 8 x i16> %ins2, <vscale x 8 x i16> poison, <vscale x 8 x i32> zeroinitializer
  %v1 = lshr <vscale x 8 x i16> %x, %splat2
  %v2 = lshr <vscale x 8 x i16> %v1, %splat2
  ret <vscale x 8 x i16> %v2
}
