# RUN: llc -run-pass regallocfast %s -o - | FileCheck %s

# This test examines register allocation and spilling with Fast Register
# Allocator. The test uses inline assembler that requests an input variable to
# be loaded in a high register but at the same time has r12 marked as clobbered.
# The allocator initially satisfies the load request by selecting r12 but then
# needs to spill this register when it reaches the INLINEASM instruction and
# notices its clobber definition.
#
# The test checks that the compiler is able to spill a register from the hGPR
# class in Thumb2 by inserting the t2STRi12/t2LDRi12 instructions.

--- |
  ; ModuleID = 'test.ll'
  source_filename = "test.c"
  target datalayout = "e-m:e-p:32:32-i64:64-v128:64:128-a:0:32-n32-S64"
  target triple = "thumbv7m-none-unknown-eabi"

  define dso_local void @constraint_h() {
  entry:
    %i = alloca i32, align 4
    %0 = load i32, i32* %i, align 4
    call void asm sideeffect "@ $0", "h,~{r12}"(i32 %0)
    ret void
  }

...
---
name:            constraint_h
tracksRegLiveness: true
registers:
  - { id: 0, class: hgpr }
  - { id: 1, class: tgpr }
stack:
  - { id: 0, name: i, size: 4, alignment: 4, stack-id: 0, local-offset: -4 }
body:             |
  bb.0.entry:
    %1:tgpr = tLDRspi %stack.0.i, 0, 14, $noreg :: (dereferenceable load 4 from %ir.i)
    %0:hgpr = COPY %1
    INLINEASM &"@ $0", 1, 589833, %0, 12, implicit-def early-clobber $r12
    tBX_RET 14, $noreg

...
# CHECK: bb.0.entry:
# CHECK-NEXT: renamable $r0 = tLDRspi %stack.0.i, 0, 14, $noreg :: (dereferenceable load 4 from %ir.i)
# CHECK-NEXT: renamable $r12 = COPY killed renamable $r0
# CHECK-NEXT: t2STRi12 killed $r12, %stack.1, 0, 14, $noreg :: (store 4 into %stack.1)
# CHECK-NEXT: $r8 = t2LDRi12 %stack.1, 0, 14, $noreg :: (load 4 from %stack.1)
# CHECK-NEXT: INLINEASM &"@ $0", 1, 589833, killed renamable $r8, 12, implicit-def early-clobber $r12
# CHECK-NEXT: tBX_RET 14, $noreg
