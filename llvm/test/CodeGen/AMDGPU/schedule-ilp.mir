# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
# RUN: llc -mtriple=amdgcn-amd-amdhsa -mcpu=gfx906 -verify-machineinstrs  -run-pass=machine-scheduler -verify-misched -o - %s | FileCheck %s

--- |
  define amdgpu_kernel void @schedule_ilp(i32 addrspace(1)* noalias %out, i32 addrspace(1)* noalias %in) { ret void }

  !0 = distinct !{!0}
  !1 = !{!1, !0}
...

# Check that the load that defines %4 and its user are scheduled as far apart
# as possible. In this example, the generic machine scheduler's default latency
# heuristic will not be triggered early enough. Verify that our backend handles
# this properly.

---
name: schedule_ilp
tracksRegLiveness: true
machineFunctionInfo:
	stackPtrOffsetReg: $sgpr32
stack:
	-	{ id: 0, type: default, offset: 0, size: 4, alignment: 4 }
	-	{ id: 1, type: default, offset: 0, size: 4, alignment: 4 }
body:             |
  bb.0:
    liveins: $sgpr0_sgpr1_sgpr2_sgpr3

    ; CHECK-LABEL: name: schedule_ilp
    ; CHECK: liveins: $sgpr0_sgpr1_sgpr2_sgpr3
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: [[DEF:%[0-9]+]]:sreg_64 = IMPLICIT_DEF
    ; CHECK-NEXT: [[DEF1:%[0-9]+]]:vgpr_32 = IMPLICIT_DEF
    ; CHECK-NEXT: [[DEF2:%[0-9]+]]:vgpr_32 = IMPLICIT_DEF
    ; CHECK-NEXT: [[DEF3:%[0-9]+]]:vreg_64 = IMPLICIT_DEF
    ; CHECK-NEXT: $exec = S_OR_B64 $exec, [[DEF]], implicit-def $scc
    ; CHECK-NEXT: [[GLOBAL_LOAD_DWORD:%[0-9]+]]:vgpr_32 = GLOBAL_LOAD_DWORD [[DEF3]], 0, 0, implicit $exec :: (load (s32) from %ir.in, !alias.scope !0, addrspace 1)
    ; CHECK-NEXT: [[GLOBAL_LOAD_DWORD1:%[0-9]+]]:vgpr_32 = GLOBAL_LOAD_DWORD [[DEF3]], 4, 0, implicit $exec :: (load (s32) from %ir.in, !alias.scope !0, addrspace 1)
    ; CHECK-NEXT: [[GLOBAL_LOAD_DWORD2:%[0-9]+]]:vgpr_32 = GLOBAL_LOAD_DWORD [[DEF3]], 8, 0, implicit $exec :: (load (s32) from %ir.in, !alias.scope !0, addrspace 1)
    ; CHECK-NEXT: BUFFER_STORE_DWORD_OFFEN [[DEF1]], %stack.0, $sgpr0_sgpr1_sgpr2_sgpr3, 0, 0, 0, 0, 0, implicit $exec :: (store (s32) into %ir.out, !noalias !0, addrspace 1)
    ; CHECK-NEXT: BUFFER_STORE_DWORD_OFFEN [[DEF2]], %stack.0, $sgpr0_sgpr1_sgpr2_sgpr3, 0, 4, 0, 0, 0, implicit $exec :: (store (s32) into %ir.out, !noalias !0, addrspace 1)
    ; CHECK-NEXT: [[V_MOV_B:%[0-9]+]]:vreg_64 = V_MOV_B64_PSEUDO 0, implicit $exec
    ; CHECK-NEXT: [[V_CMP_NE_U32_e64_:%[0-9]+]]:sreg_64 = V_CMP_NE_U32_e64 -1, [[GLOBAL_LOAD_DWORD]], implicit $exec
    ; CHECK-NEXT: [[COPY:%[0-9]+]]:sreg_64 = COPY $exec, implicit-def $exec
    ; CHECK-NEXT: [[S_AND_B64_:%[0-9]+]]:sreg_64 = S_AND_B64 [[COPY]], [[V_CMP_NE_U32_e64_]], implicit-def dead $scc
    ; CHECK-NEXT: $exec = S_MOV_B64_term [[S_AND_B64_]]
    ; CHECK-NEXT: S_ENDPGM 0, implicit [[GLOBAL_LOAD_DWORD1]], implicit [[GLOBAL_LOAD_DWORD2]], implicit [[V_MOV_B]]
    %0:sreg_64 = IMPLICIT_DEF
    %1:vgpr_32 = IMPLICIT_DEF
    %2:vgpr_32 = IMPLICIT_DEF
    %3:vreg_64 = IMPLICIT_DEF
    $exec = S_OR_B64 $exec, %0, implicit-def $scc
    BUFFER_STORE_DWORD_OFFEN %1:vgpr_32, %stack.0, $sgpr0_sgpr1_sgpr2_sgpr3, 0, 0, 0, 0, 0, implicit $exec :: (store (s32) into %ir.out, !noalias !0)
    BUFFER_STORE_DWORD_OFFEN %2:vgpr_32, %stack.0, $sgpr0_sgpr1_sgpr2_sgpr3, 0, 4, 0, 0, 0, implicit $exec :: (store (s32) into %ir.out, !noalias !0)
    %4:vgpr_32 = GLOBAL_LOAD_DWORD %3, 0, 0, implicit $exec :: (load (s32) from %ir.in, !alias.scope !0)
    %5:vgpr_32 = GLOBAL_LOAD_DWORD %3, 4, 0, implicit $exec :: (load (s32) from %ir.in, !alias.scope !0)
    %6:vgpr_32 = GLOBAL_LOAD_DWORD %3, 8, 0, implicit $exec :: (load (s32) from %ir.in, !alias.scope !0)
    %7:sreg_64 = V_CMP_NE_U32_e64 -1, %4, implicit $exec
    %8:vreg_64 = V_MOV_B64_PSEUDO 0, implicit $exec
    %9:sreg_64 = COPY $exec, implicit-def $exec
    %10:sreg_64 = S_AND_B64 %9:sreg_64, %7:sreg_64, implicit-def dead $scc
    $exec = S_MOV_B64_term %10
    S_ENDPGM 0, implicit %5, implicit %6, implicit %8
...
