# RUN: llc -march=amdgcn -run-pass=si-memory-legalizer  %s -o - | FileCheck %s

--- |
  declare i32 @llvm.amdgcn.workitem.id.x() #0

  define amdgpu_kernel void @atomic_max_i32_noret(
      i32 addrspace(1)* %out,
      i32 addrspace(1)* addrspace(1)* %in,
      i32 addrspace(1)* %x,
      i32 %y) #1 {
    %tid = call i32 @llvm.amdgcn.workitem.id.x()
    %idxprom = sext i32 %tid to i64
    %tid.gep = getelementptr i32 addrspace(1)*, i32 addrspace(1)* addrspace(1)* %in, i64 %idxprom
    %ptr = load volatile i32 addrspace(1)*, i32 addrspace(1)* addrspace(1)* %tid.gep
    %xor = xor i32 %tid, 1
    %cmp = icmp ne i32 %xor, 0
    %1 = call { i1, i64 } @llvm.amdgcn.if(i1 %cmp)
    %2 = extractvalue { i1, i64 } %1, 0
    %3 = extractvalue { i1, i64 } %1, 1
    br i1 %2, label %atomic, label %exit

  atomic:                                           ; preds = %0
    %gep = getelementptr i32, i32 addrspace(1)* %ptr, i32 100
    %ret = atomicrmw max i32 addrspace(1)* %gep, i32 %y seq_cst
    br label %exit

  exit:                                             ; preds = %atomic, %0
    call void @llvm.amdgcn.end.cf(i64 %3)
    ret void
  }

  declare { i1, i64 } @llvm.amdgcn.if(i1)

  declare void @llvm.amdgcn.end.cf(i64)

  attributes #0 = { nounwind readnone }
  attributes #1 = { nounwind "target-cpu"="gfx803" }

...
---

# CHECK-LABEL: name: atomic_max_i32_noret

# CHECK-LABEL: bb.1.atomic:
# CHECK:       BUFFER_ATOMIC_SMAX_ADDR64
# CHECK-NEXT:  S_WAITCNT 3952
# CHECK-NEXT:  BUFFER_WBINVL1_VOL

name:            atomic_max_i32_noret
alignment:       1
exposesReturnsTwice: false
legalized:       false
regBankSelected: false
selected:        false
tracksRegLiveness: true
liveins:
  - { reg: '$sgpr0_sgpr1' }
  - { reg: '$vgpr0' }
frameInfo:
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    0
  adjustsStack:    false
  hasCalls:        false
  maxCallFrameSize: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
body:             |
  bb.0 (%ir-block.0):
    successors: %bb.1.atomic(0x40000000), %bb.2.exit(0x40000000)
    liveins: $vgpr0, $sgpr0_sgpr1

    $sgpr4_sgpr5 = S_LOAD_DWORDX2_IMM $sgpr0_sgpr1, 11, 0 :: (non-temporal dereferenceable invariant load (s64) from `i64 addrspace(4)* undef`)
    $vgpr1 = V_ASHRREV_I32_e32 31, $vgpr0, implicit $exec
    $vgpr1_vgpr2 = V_LSHL_B64_e64 $vgpr0_vgpr1, 3, implicit $exec
    $sgpr7 = S_MOV_B32 61440
    $sgpr6 = S_MOV_B32 0
    S_WAITCNT 127
    $vgpr1_vgpr2 = BUFFER_LOAD_DWORDX2_ADDR64 killed $vgpr1_vgpr2, $sgpr4_sgpr5_sgpr6_sgpr7, 0, 0, 0, 0, 0, implicit $exec :: (volatile load (s64) from %ir.tid.gep)
    $vgpr0 = V_XOR_B32_e32 1, killed $vgpr0, implicit $exec
    V_CMP_NE_U32_e32 0, killed $vgpr0, implicit-def $vcc, implicit $exec
    $sgpr2_sgpr3 = S_AND_SAVEEXEC_B64 killed $vcc, implicit-def $exec, implicit-def $scc, implicit $exec
    $sgpr2_sgpr3 = S_XOR_B64 $exec, killed $sgpr2_sgpr3, implicit-def dead $scc
    S_CBRANCH_EXECZ %bb.2.exit, implicit $exec

  bb.1.atomic:
    successors: %bb.2.exit(0x80000000)
    liveins: $sgpr4_sgpr5_sgpr6_sgpr7:0x0000000C, $sgpr0_sgpr1, $sgpr2_sgpr3, $vgpr1_vgpr2_vgpr3_vgpr4:0x00000003

    $sgpr0 = S_LOAD_DWORD_IMM killed $sgpr0_sgpr1, 15, 0 :: (non-temporal dereferenceable invariant load (s32) from `i32 addrspace(4)* undef`)
    dead $vgpr0 = V_MOV_B32_e32 -1, implicit $exec
    dead $vgpr0 = V_MOV_B32_e32 61440, implicit $exec
    $sgpr4_sgpr5 = S_MOV_B64 0
    S_WAITCNT 127
    $vgpr0 = V_MOV_B32_e32 killed $sgpr0, implicit $exec, implicit $exec
    S_WAITCNT 3952
    BUFFER_ATOMIC_SMAX_ADDR64 killed $vgpr0, killed $vgpr1_vgpr2, killed $sgpr4_sgpr5_sgpr6_sgpr7, 0, 400, 0, implicit $exec :: (volatile load syncscope("one-as") seq_cst (s32) from %ir.gep)

  bb.2.exit:
    liveins: $sgpr2_sgpr3

    $exec = S_OR_B64 $exec, killed $sgpr2_sgpr3, implicit-def $scc
    S_ENDPGM 0

...

