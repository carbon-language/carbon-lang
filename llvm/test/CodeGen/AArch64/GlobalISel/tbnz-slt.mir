# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
# RUN: llc -mtriple aarch64-unknown-unknown -run-pass=instruction-select -verify-machineinstrs %s -o - | FileCheck %s
#
# Test that we can produce a TBNZ when we have a slt compare against 0.
#
# The bit tested should be the size of the test register minus 1.
#

...
---
name:            tbnzx_slt
alignment:       4
legalized:       true
regBankSelected: true
body:             |
  ; CHECK-LABEL: name: tbnzx_slt
  ; CHECK: bb.0:
  ; CHECK-NEXT:   successors: %bb.0(0x40000000), %bb.1(0x40000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   %copy:gpr64 = COPY $x0
  ; CHECK-NEXT:   TBNZX %copy, 63, %bb.1
  ; CHECK-NEXT:   B %bb.0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1:
  ; CHECK-NEXT:   RET_ReallyLR
  bb.0:
    successors: %bb.0, %bb.1
    liveins: $x0
    %copy:gpr(s64) = COPY $x0
    %zero:gpr(s64) = G_CONSTANT i64 0
    %cmp:gpr(s32) = G_ICMP intpred(slt), %copy(s64), %zero
    %cmp_trunc:gpr(s1) = G_TRUNC %cmp(s32)
    G_BRCOND %cmp_trunc(s1), %bb.1
    G_BR %bb.0
  bb.1:
    RET_ReallyLR

...
---
name:            tbnzw_slt
alignment:       4
legalized:       true
regBankSelected: true
body:             |
  ; CHECK-LABEL: name: tbnzw_slt
  ; CHECK: bb.0:
  ; CHECK-NEXT:   successors: %bb.0(0x40000000), %bb.1(0x40000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   %copy:gpr32 = COPY $w0
  ; CHECK-NEXT:   TBNZW %copy, 31, %bb.1
  ; CHECK-NEXT:   B %bb.0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1:
  ; CHECK-NEXT:   RET_ReallyLR
  bb.0:
    successors: %bb.0, %bb.1
    liveins: $x0
    %copy:gpr(s32) = COPY $w0
    %zero:gpr(s32) = G_CONSTANT i32 0
    %cmp:gpr(s32) = G_ICMP intpred(slt), %copy(s32), %zero
    %cmp_trunc:gpr(s1) = G_TRUNC %cmp(s32)
    G_BRCOND %cmp_trunc(s1), %bb.1
    G_BR %bb.0
  bb.1:
    RET_ReallyLR

...
---
name:            no_tbnz_not_zero
alignment:       4
legalized:       true
regBankSelected: true
body:             |
  ; CHECK-LABEL: name: no_tbnz_not_zero
  ; CHECK: bb.0:
  ; CHECK-NEXT:   successors: %bb.0(0x40000000), %bb.1(0x40000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   %copy:gpr32sp = COPY $w0
  ; CHECK-NEXT:   [[SUBSWri:%[0-9]+]]:gpr32 = SUBSWri %copy, 1, 0, implicit-def $nzcv
  ; CHECK-NEXT:   Bcc 11, %bb.1, implicit $nzcv
  ; CHECK-NEXT:   B %bb.0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1:
  ; CHECK-NEXT:   RET_ReallyLR
  bb.0:
    successors: %bb.0, %bb.1
    liveins: $x0
    %copy:gpr(s32) = COPY $w0
    %one:gpr(s32) = G_CONSTANT i32 1
    %cmp:gpr(s32) = G_ICMP intpred(slt), %copy(s32), %one
    %cmp_trunc:gpr(s1) = G_TRUNC %cmp(s32)
    G_BRCOND %cmp_trunc(s1), %bb.1
    G_BR %bb.0
  bb.1:
    RET_ReallyLR

...
---
name:            dont_fold_and
alignment:       4
legalized:       true
regBankSelected: true
body:             |
  ; CHECK-LABEL: name: dont_fold_and
  ; CHECK: bb.0:
  ; CHECK-NEXT:   successors: %bb.0(0x40000000), %bb.1(0x40000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   %copy:gpr64 = COPY $x0
  ; CHECK-NEXT:   [[ANDSXri:%[0-9]+]]:gpr64 = ANDSXri %copy, 8000, implicit-def $nzcv
  ; CHECK-NEXT:   Bcc 11, %bb.1, implicit $nzcv
  ; CHECK-NEXT:   B %bb.0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1:
  ; CHECK-NEXT:   RET_ReallyLR
  bb.0:
    successors: %bb.0, %bb.1
    liveins: $x0
    %copy:gpr(s64) = COPY $x0
    %bit:gpr(s64) = G_CONSTANT i64 8
    %zero:gpr(s64) = G_CONSTANT i64 0
    %c:gpr(s64) = G_CONSTANT i64 8
    %and:gpr(s64) = G_AND %copy, %bit
    %cmp:gpr(s32) = G_ICMP intpred(slt), %and(s64), %zero
    %cmp_trunc:gpr(s1) = G_TRUNC %cmp(s32)
    G_BRCOND %cmp_trunc(s1), %bb.1
    G_BR %bb.0
  bb.1:
    RET_ReallyLR

...
---
name:            dont_commute
alignment:       4
legalized:       true
regBankSelected: true
body:             |
  ; CHECK-LABEL: name: dont_commute
  ; CHECK: bb.0:
  ; CHECK-NEXT:   successors: %bb.0(0x40000000), %bb.1(0x40000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   %copy:gpr64 = COPY $x0
  ; CHECK-NEXT:   %zero:gpr64 = COPY $xzr
  ; CHECK-NEXT:   [[SUBSXrr:%[0-9]+]]:gpr64 = SUBSXrr %zero, %copy, implicit-def $nzcv
  ; CHECK-NEXT:   Bcc 11, %bb.1, implicit $nzcv
  ; CHECK-NEXT:   B %bb.0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1:
  ; CHECK-NEXT:   RET_ReallyLR
  bb.0:
    successors: %bb.0, %bb.1
    liveins: $x0
    %copy:gpr(s64) = COPY $x0
    %zero:gpr(s64) = G_CONSTANT i64 0
    %cmp:gpr(s32) = G_ICMP intpred(slt), %zero, %copy(s64)
    %cmp_trunc:gpr(s1) = G_TRUNC %cmp(s32)
    G_BRCOND %cmp_trunc(s1), %bb.1
    G_BR %bb.0
  bb.1:
    RET_ReallyLR
