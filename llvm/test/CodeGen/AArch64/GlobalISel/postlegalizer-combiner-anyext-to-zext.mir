# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
# RUN: llc -mtriple aarch64 -run-pass=aarch64-postlegalizer-combiner --aarch64postlegalizercombinerhelper-only-enable-rule="mutate_anyext_to_zext" -verify-machineinstrs %s -o - | FileCheck %s
# REQUIRES: asserts

...
---
name:            scalar_icmp
legalized:       true
tracksRegLiveness: true
body:             |
  bb.0:
    liveins: $x0
    ; Scalars have 0 or 1, so we want a ZExt.

    ; CHECK-LABEL: name: scalar_icmp
    ; CHECK: liveins: $x0
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: %copy:_(s64) = COPY $x0
    ; CHECK-NEXT: %cst_1:_(s64) = G_CONSTANT i64 1
    ; CHECK-NEXT: %icmp:_(s32) = G_ICMP intpred(eq), %copy(s64), %cst_1
    ; CHECK-NEXT: %ext:_(s64) = G_ZEXT %icmp(s32)
    ; CHECK-NEXT: $x0 = COPY %ext(s64)
    ; CHECK-NEXT: RET_ReallyLR implicit $x0
    %copy:_(s64) = COPY $x0
    %cst_1:_(s64) = G_CONSTANT i64 1
    %icmp:_(s32) = G_ICMP intpred(eq), %copy(s64), %cst_1
    %ext:_(s64) = G_ANYEXT %icmp(s32)
    $x0 = COPY %ext(s64)
    RET_ReallyLR implicit $x0


...
---
name:            vector_icmp
legalized:       true
tracksRegLiveness: true
body:             |
  bb.0:
    liveins: $x0, $d0
    ; Vectors have 0 or negative 1, so we don't produce a zext.

    ; CHECK-LABEL: name: vector_icmp
    ; CHECK: liveins: $x0, $d0
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: %copy:_(<2 x s32>) = COPY $d0
    ; CHECK-NEXT: %cst_1:_(s32) = G_CONSTANT i32 1
    ; CHECK-NEXT: %vec_cst_1:_(<2 x s32>) = G_BUILD_VECTOR %cst_1(s32), %cst_1(s32)
    ; CHECK-NEXT: %icmp:_(<2 x s32>) = G_ICMP intpred(eq), %copy(<2 x s32>), %vec_cst_1
    ; CHECK-NEXT: %ext:_(<2 x s64>) = G_ANYEXT %icmp(<2 x s32>)
    ; CHECK-NEXT: $q0 = COPY %ext(<2 x s64>)
    ; CHECK-NEXT: RET_ReallyLR implicit $q0
    %copy:_(<2 x s32>) = COPY $d0
    %cst_1:_(s32) = G_CONSTANT i32 1
    %vec_cst_1:_(<2 x s32>) = G_BUILD_VECTOR %cst_1, %cst_1
    %icmp:_(<2 x s32>) = G_ICMP intpred(eq), %copy(<2 x s32>), %vec_cst_1
    %ext:_(<2 x s64>) = G_ANYEXT %icmp(<2 x s32>)
    $q0 = COPY %ext(<2 x s64>)
    RET_ReallyLR implicit $q0

...
---
name:            scalar_fcmp
legalized:       true
tracksRegLiveness: true
body:             |
  bb.0:
    liveins: $x0, $d0
    ; Scalars have 0 or 1, so we want a ZExt.

    ; CHECK-LABEL: name: scalar_fcmp
    ; CHECK: liveins: $x0, $d0
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: %copy:_(s64) = COPY $d0
    ; CHECK-NEXT: %cst_1:_(s64) = G_FCONSTANT double 1.000000e+00
    ; CHECK-NEXT: %fcmp:_(s32) = G_FCMP intpred(eq), %copy(s64), %cst_1
    ; CHECK-NEXT: %ext:_(s64) = G_ZEXT %fcmp(s32)
    ; CHECK-NEXT: $x0 = COPY %ext(s64)
    ; CHECK-NEXT: RET_ReallyLR implicit $x0
    %copy:_(s64) = COPY $d0
    %cst_1:_(s64) = G_FCONSTANT double 1.0
    %fcmp:_(s32) = G_FCMP intpred(eq), %copy(s64), %cst_1
    %ext:_(s64) = G_ANYEXT %fcmp(s32)
    $x0 = COPY %ext(s64)
    RET_ReallyLR implicit $x0
