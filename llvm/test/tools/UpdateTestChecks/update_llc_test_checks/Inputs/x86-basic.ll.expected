; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
;; Check that we accept functions with '$' in the name.
; RUN: llc -mtriple=x86_64 < %s | FileCheck %s

;; Check that we accept .Ldsolocal$local: below the function label.
; RUN: llc -mtriple=x86_64 -relocation-model=pic < %s | FileCheck %s --check-prefix=PIC

;; Check that we accept .seh_proc below the function label.
; RUN: llc -mtriple=x86_64-windows -relocation-model=pic < %s | FileCheck %s --check-prefix=WIN

@gv0 = dso_local global i32 0, align 4
@gv1 = dso_preemptable global i32 0, align 4

define hidden i32 @"_Z54bar$ompvariant$bar"() {
; CHECK-LABEL: _Z54bar$ompvariant$bar:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movl $2, %eax
; CHECK-NEXT:    retq
;
; PIC-LABEL: _Z54bar$ompvariant$bar:
; PIC:       # %bb.0: # %entry
; PIC-NEXT:    movl $2, %eax
; PIC-NEXT:    retq
;
; WIN-LABEL: _Z54bar$ompvariant$bar:
; WIN:       # %bb.0: # %entry
; WIN-NEXT:    movl $2, %eax
; WIN-NEXT:    retq
entry:
  ret i32 2
}

define dso_local i32 @dsolocal() {
; CHECK-LABEL: dsolocal:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    pushq %rax
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    callq ext@PLT
; CHECK-NEXT:    movl $2, %eax
; CHECK-NEXT:    popq %rcx
; CHECK-NEXT:    .cfi_def_cfa_offset 8
; CHECK-NEXT:    retq
;
; PIC-LABEL: dsolocal:
; PIC:       # %bb.0: # %entry
; PIC-NEXT:    pushq %rax
; PIC-NEXT:    .cfi_def_cfa_offset 16
; PIC-NEXT:    callq ext@PLT
; PIC-NEXT:    movl $2, %eax
; PIC-NEXT:    popq %rcx
; PIC-NEXT:    .cfi_def_cfa_offset 8
; PIC-NEXT:    retq
;
; WIN-LABEL: dsolocal:
; WIN:       # %bb.0: # %entry
; WIN-NEXT:    subq $40, %rsp
; WIN-NEXT:    .seh_stackalloc 40
; WIN-NEXT:    .seh_endprologue
; WIN-NEXT:    callq ext
; WIN-NEXT:    movl $2, %eax
; WIN-NEXT:    addq $40, %rsp
; WIN-NEXT:    retq
; WIN-NEXT:    .seh_endproc
entry:
  call void @ext()
  ret i32 2
}

declare void @ext()

define i32 @load() {
; CHECK-LABEL: load:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movl gv0(%rip), %eax
; CHECK-NEXT:    movq gv1@GOTPCREL(%rip), %rcx
; CHECK-NEXT:    addl (%rcx), %eax
; CHECK-NEXT:    retq
;
; PIC-LABEL: load:
; PIC:       # %bb.0: # %entry
; PIC-NEXT:    movl .Lgv0$local(%rip), %eax
; PIC-NEXT:    movq gv1@GOTPCREL(%rip), %rcx
; PIC-NEXT:    addl (%rcx), %eax
; PIC-NEXT:    retq
;
; WIN-LABEL: load:
; WIN:       # %bb.0: # %entry
; WIN-NEXT:    movl gv0(%rip), %eax
; WIN-NEXT:    addl gv1(%rip), %eax
; WIN-NEXT:    retq
entry:
  %a = load i32, i32* @gv0
  %b = load i32, i32* @gv1
  %c = add i32 %a, %b
  ret i32 %c
}
