; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
;RUN: opt  -loop-unswitch -enable-new-pm=0 -simplifycfg -simplifycfg-require-and-preserve-domtree=1 -S < %s | FileCheck %s

define i32 @foo(i32 %a, i32 %b) {
; CHECK-LABEL: @foo(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP0:%.*]] = icmp sgt i32 [[B:%.*]], 0
; CHECK-NEXT:    br i1 [[CMP0]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; CHECK:       for.body.preheader:
; CHECK-NEXT:    [[CMP1:%.*]] = icmp eq i32 [[A:%.*]], 12345
; CHECK-NEXT:    br i1 [[CMP1]], label [[FOR_BODY_US:%.*]], label [[FOR_BODY:%.*]], !prof [[PROF0:![0-9]+]]
; CHECK:       for.body.us:
; CHECK-NEXT:    [[INC_I_US:%.*]] = phi i32 [ [[INC_US:%.*]], [[FOR_BODY_US]] ], [ 0, [[FOR_BODY_PREHEADER]] ]
; CHECK-NEXT:    [[MUL_I_US:%.*]] = phi i32 [ [[B]], [[FOR_BODY_US]] ], [ 3, [[FOR_BODY_PREHEADER]] ]
; CHECK-NEXT:    [[ADD_I_US:%.*]] = phi i32 [ [[ADD_US:%.*]], [[FOR_BODY_US]] ], [ [[A]], [[FOR_BODY_PREHEADER]] ]
; CHECK-NEXT:    [[ADD_US]] = add nsw i32 [[ADD_I_US]], 123
; CHECK-NEXT:    [[INC_US]] = add nuw nsw i32 [[INC_I_US]], 1
; CHECK-NEXT:    [[EXITCOND_US:%.*]] = icmp eq i32 [[INC_US]], [[B]]
; CHECK-NEXT:    br i1 [[EXITCOND_US]], label [[FOR_COND_CLEANUP]], label [[FOR_BODY_US]]
; CHECK:       for.body:
; CHECK-NEXT:    [[INC_I:%.*]] = phi i32 [ [[INC:%.*]], [[FOR_BODY]] ], [ 0, [[FOR_BODY_PREHEADER]] ]
; CHECK-NEXT:    [[MUL_I:%.*]] = phi i32 [ [[MUL:%.*]], [[FOR_BODY]] ], [ 3, [[FOR_BODY_PREHEADER]] ]
; CHECK-NEXT:    [[ADD_I:%.*]] = phi i32 [ [[A]], [[FOR_BODY]] ], [ [[A]], [[FOR_BODY_PREHEADER]] ]
; CHECK-NEXT:    [[MUL]] = mul nsw i32 [[MUL_I]], [[B]]
; CHECK-NEXT:    [[INC]] = add nuw nsw i32 [[INC_I]], 1
; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp eq i32 [[INC]], [[B]]
; CHECK-NEXT:    br i1 [[EXITCOND]], label [[FOR_COND_CLEANUP]], label [[FOR_BODY]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    [[T2:%.*]] = phi i32 [ [[B]], [[ENTRY:%.*]] ], [ [[B]], [[FOR_BODY_US]] ], [ [[MUL]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[T1:%.*]] = phi i32 [ [[A]], [[ENTRY]] ], [ [[ADD_US]], [[FOR_BODY_US]] ], [ [[A]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[ADD3:%.*]] = add nsw i32 [[T2]], [[T1]]
; CHECK-NEXT:    ret i32 [[ADD3]]
;
entry:
  br label %for.body.lr.ph

for.body.lr.ph:                                   ; preds = %entry
  %cmp0 = icmp sgt i32 %b, 0
  br i1 %cmp0, label %for.body, label %for.cond.cleanup

for.body:                                         ; preds = %for.inc, %for.body.lr.ph
  %inc.i = phi i32 [ 0, %for.body.lr.ph ], [ %inc, %for.inc ]
  %mul.i = phi i32 [ 3, %for.body.lr.ph ], [ %mul.p, %for.inc ]
  %add.i = phi i32 [ %a, %for.body.lr.ph ], [ %add.p, %for.inc ]
  %cmp1 = icmp eq i32 %a, 12345
  br i1 %cmp1, label %if.then, label %if.else, !prof !0
if.then:                                          ; preds = %for.body
  %add = add nsw i32 %add.i, 123
  br label %for.inc

if.else:                                          ; preds = %for.body
  %mul = mul nsw i32 %mul.i, %b
  br label %for.inc
for.inc:                                          ; preds = %if.then, %if.else
  %mul.p = phi i32 [ %b, %if.then ], [ %mul, %if.else ]
  %add.p = phi i32 [ %add, %if.then ], [ %a, %if.else ]
  %inc = add nuw nsw i32 %inc.i, 1
  %exitcond = icmp eq i32 %inc, %b
  br i1 %exitcond, label %for.cond.cleanup, label %for.body

for.cond.cleanup:                                 ; preds = %for.inc, %for.body.lr.ph
  %t2 = phi i32 [ %b, %for.body.lr.ph ], [ %mul.p, %for.inc ]
  %t1 = phi i32 [ %a, %for.body.lr.ph ], [ %add.p, %for.inc ]
  %add3 = add nsw i32 %t2, %t1
  ret i32 %add3
}

define void @foo_swapped(i32 %a, i32 %b) {
; CHECK-LABEL: @foo_swapped(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP1:%.*]] = icmp eq i32 1, 2
; CHECK-NEXT:    br i1 [[CMP1]], label [[FOR_BODY:%.*]], label [[FOR_COND_CLEANUP_SPLIT:%.*]], !prof [[PROF1:![0-9]+]]
; CHECK:       for.body:
; CHECK-NEXT:    [[INC_I:%.*]] = phi i32 [ [[INC:%.*]], [[FOR_BODY]] ], [ 0, [[ENTRY:%.*]] ]
; CHECK-NEXT:    [[ADD_I:%.*]] = phi i32 [ [[ADD:%.*]], [[FOR_BODY]] ], [ 100, [[ENTRY]] ]
; CHECK-NEXT:    [[INC]] = add nuw nsw i32 [[INC_I]], 1
; CHECK-NEXT:    [[ADD]] = add nsw i32 [[A:%.*]], [[ADD_I]]
; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp eq i32 [[INC]], [[B:%.*]]
; CHECK-NEXT:    br i1 [[EXITCOND]], label [[FOR_COND_CLEANUP_SPLIT]], label [[FOR_BODY]]
; CHECK:       for.cond.cleanup.split:
; CHECK-NEXT:    ret void
;
entry:
  br label %for.body
for.body:                                         ; preds = %for.inc, %entry
  %inc.i = phi i32 [ 0, %entry ], [ %inc, %if.then ]
  %add.i = phi i32 [ 100, %entry ], [ %add, %if.then ]
  %inc = add nuw nsw i32 %inc.i, 1
  %cmp1 = icmp eq i32 1, 2
  br i1 %cmp1, label %if.then, label  %for.cond.cleanup, !prof !0

if.then:                                          ; preds = %for.body
  %add = add nsw i32 %a, %add.i

  %exitcond = icmp eq i32 %inc, %b
  br i1 %exitcond, label %for.cond.cleanup, label %for.body

for.cond.cleanup:                                 ; preds = %for.inc, %for.body.lr.ph, %for.body
  ret void
}
!0 = !{!"branch_weights", i32 64, i32 4}

;CHECK: !0 = !{!"branch_weights", i32 64, i32 4}
;CHECK: !1 = !{!"branch_weights", i32 4, i32 64}
