; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -memcpyopt -S -enable-memcpyopt-memoryssa=0 | FileCheck %s --check-prefixes=CHECK,NO_MSSA
; RUN: opt < %s -memcpyopt -S -enable-memcpyopt-memoryssa=1 -verify-memoryssa | FileCheck %s --check-prefixes=CHECK,MSSA

; Test memcpy-memcpy dependencies across invoke edges.

; Test that memcpyopt works across the non-unwind edge of an invoke.
; TODO: Not supported yet.

define hidden void @test_normal(i8* noalias %dst, i8* %src) personality i8* bitcast (i32 (...)* @__gxx_personality_v0 to i8*) {
; NO_MSSA-LABEL: @test_normal(
; NO_MSSA-NEXT:  entry:
; NO_MSSA-NEXT:    [[TEMP:%.*]] = alloca i8, i32 64, align 1
; NO_MSSA-NEXT:    call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 [[TEMP]], i8* nonnull align 8 [[SRC:%.*]], i64 64, i1 false)
; NO_MSSA-NEXT:    invoke void @invoke_me()
; NO_MSSA-NEXT:    to label [[TRY_CONT:%.*]] unwind label [[LPAD:%.*]]
; NO_MSSA:       lpad:
; NO_MSSA-NEXT:    [[TMP0:%.*]] = landingpad { i8*, i32 }
; NO_MSSA-NEXT:    catch i8* null
; NO_MSSA-NEXT:    ret void
; NO_MSSA:       try.cont:
; NO_MSSA-NEXT:    call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 [[DST:%.*]], i8* align 8 [[TEMP]], i64 64, i1 false)
; NO_MSSA-NEXT:    ret void
;
; MSSA-LABEL: @test_normal(
; MSSA-NEXT:  entry:
; MSSA-NEXT:    [[TEMP:%.*]] = alloca i8, i32 64, align 1
; MSSA-NEXT:    call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 [[TEMP]], i8* nonnull align 8 [[SRC:%.*]], i64 64, i1 false)
; MSSA-NEXT:    invoke void @invoke_me()
; MSSA-NEXT:    to label [[TRY_CONT:%.*]] unwind label [[LPAD:%.*]]
; MSSA:       lpad:
; MSSA-NEXT:    [[TMP0:%.*]] = landingpad { i8*, i32 }
; MSSA-NEXT:    catch i8* null
; MSSA-NEXT:    ret void
; MSSA:       try.cont:
; MSSA-NEXT:    call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 [[DST:%.*]], i8* align 8 [[SRC]], i64 64, i1 false)
; MSSA-NEXT:    ret void
;
entry:
  %temp = alloca i8, i32 64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %temp, i8* nonnull align 8 %src, i64 64, i1 false)
  invoke void @invoke_me()
  to label %try.cont unwind label %lpad

lpad:
  landingpad { i8*, i32 }
  catch i8* null
  ret void

try.cont:
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %dst, i8* align 8 %temp, i64 64, i1 false)
  ret void
}

; Test that memcpyopt works across the unwind edge of an invoke.
; TODO: Not supported yet.

define hidden void @test_unwind(i8* noalias %dst, i8* %src) personality i8* bitcast (i32 (...)* @__gxx_personality_v0 to i8*) {
; NO_MSSA-LABEL: @test_unwind(
; NO_MSSA-NEXT:  entry:
; NO_MSSA-NEXT:    [[TEMP:%.*]] = alloca i8, i32 64, align 1
; NO_MSSA-NEXT:    call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 [[TEMP]], i8* nonnull align 8 [[SRC:%.*]], i64 64, i1 false)
; NO_MSSA-NEXT:    invoke void @invoke_me()
; NO_MSSA-NEXT:    to label [[TRY_CONT:%.*]] unwind label [[LPAD:%.*]]
; NO_MSSA:       lpad:
; NO_MSSA-NEXT:    [[TMP0:%.*]] = landingpad { i8*, i32 }
; NO_MSSA-NEXT:    catch i8* null
; NO_MSSA-NEXT:    call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 [[DST:%.*]], i8* align 8 [[TEMP]], i64 64, i1 false)
; NO_MSSA-NEXT:    ret void
; NO_MSSA:       try.cont:
; NO_MSSA-NEXT:    ret void
;
; MSSA-LABEL: @test_unwind(
; MSSA-NEXT:  entry:
; MSSA-NEXT:    [[TEMP:%.*]] = alloca i8, i32 64, align 1
; MSSA-NEXT:    call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 [[TEMP]], i8* nonnull align 8 [[SRC:%.*]], i64 64, i1 false)
; MSSA-NEXT:    invoke void @invoke_me()
; MSSA-NEXT:    to label [[TRY_CONT:%.*]] unwind label [[LPAD:%.*]]
; MSSA:       lpad:
; MSSA-NEXT:    [[TMP0:%.*]] = landingpad { i8*, i32 }
; MSSA-NEXT:    catch i8* null
; MSSA-NEXT:    call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 [[DST:%.*]], i8* align 8 [[SRC]], i64 64, i1 false)
; MSSA-NEXT:    ret void
; MSSA:       try.cont:
; MSSA-NEXT:    ret void
;
entry:
  %temp = alloca i8, i32 64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %temp, i8* nonnull align 8 %src, i64 64, i1 false)
  invoke void @invoke_me()
  to label %try.cont unwind label %lpad

lpad:
  landingpad { i8*, i32 }
  catch i8* null
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %dst, i8* align 8 %temp, i64 64, i1 false)
  ret void

try.cont:
  ret void
}

declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i1)
declare i32 @__gxx_personality_v0(...)
declare void @invoke_me() readnone
