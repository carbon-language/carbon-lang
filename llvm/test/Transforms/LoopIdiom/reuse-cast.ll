; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -loop-idiom -S %s | FileCheck %s

define void @reuse_cast_1(float** %ptr, i1 %c) {
; CHECK-LABEL: @reuse_cast_1(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP_0:%.*]]
; CHECK:       loop.0:
; CHECK-NEXT:    [[TMP:%.*]] = load float*, float** [[PTR:%.*]], align 8
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast float* [[TMP]] to i8*
; CHECK-NEXT:    br i1 [[C:%.*]], label [[LOOP_2_PREHEADER:%.*]], label [[LOOP_1_PREHEADER:%.*]]
; CHECK:       loop.1.preheader:
; CHECK-NEXT:    call void @llvm.memset.p0i8.i64(i8* align 4 [[TMP2]], i8 0, i64 400, i1 false)
; CHECK-NEXT:    br label [[LOOP_1:%.*]]
; CHECK:       loop.2.preheader:
; CHECK-NEXT:    br label [[LOOP_2:%.*]]
; CHECK:       loop.1:
; CHECK-NEXT:    [[IV_1:%.*]] = phi i64 [ [[IV_1_NEXT:%.*]], [[LOOP_1]] ], [ 0, [[LOOP_1_PREHEADER]] ]
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr inbounds float, float* [[TMP]], i64 [[IV_1]]
; CHECK-NEXT:    [[IV_1_NEXT]] = add nuw nsw i64 [[IV_1]], 1
; CHECK-NEXT:    [[C_1:%.*]] = icmp ne i64 [[IV_1_NEXT]], 100
; CHECK-NEXT:    br i1 [[C_1]], label [[LOOP_1]], label [[LOOP_0_LATCH_LOOPEXIT1:%.*]]
; CHECK:       loop.2:
; CHECK-NEXT:    [[IV_2:%.*]] = phi i64 [ [[IV_2_NEXT:%.*]], [[LOOP_2]] ], [ 0, [[LOOP_2_PREHEADER]] ]
; CHECK-NEXT:    [[TMP10:%.*]] = getelementptr inbounds float, float* [[TMP]], i64 [[IV_2]]
; CHECK-NEXT:    store float 0.000000e+00, float* [[TMP10]], align 4
; CHECK-NEXT:    [[TMP11:%.*]] = load float*, float** [[PTR]], align 8
; CHECK-NEXT:    [[TMP12:%.*]] = getelementptr inbounds float, float* [[TMP11]], i64 [[IV_2]]
; CHECK-NEXT:    [[TMP13:%.*]] = load float, float* [[TMP12]], align 4
; CHECK-NEXT:    [[IV_2_NEXT]] = add nuw nsw i64 [[IV_2]], 1
; CHECK-NEXT:    [[C_2:%.*]] = icmp ne i64 [[IV_2_NEXT]], 100
; CHECK-NEXT:    br i1 [[C_2]], label [[LOOP_2]], label [[LOOP_0_LATCH_LOOPEXIT:%.*]]
; CHECK:       loop.0.latch.loopexit:
; CHECK-NEXT:    br label [[LOOP_0_LATCH:%.*]]
; CHECK:       loop.0.latch.loopexit1:
; CHECK-NEXT:    br label [[LOOP_0_LATCH]]
; CHECK:       loop.0.latch:
; CHECK-NEXT:    [[C_0:%.*]] = call i1 @cond()
; CHECK-NEXT:    br i1 [[C_0]], label [[LOOP_0]], label [[END:%.*]]
; CHECK:       end:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop.0

loop.0:                                           ; preds = %loop.0.latch, %entry
  %tmp = load float*, float** %ptr, align 8
  br i1 %c, label %loop.2, label %loop.1

loop.1:                                           ; preds = %loop.1, %loop.0
  %iv.1 = phi i64 [ %iv.1.next, %loop.1 ], [ 0, %loop.0 ]
  %tmp4 = getelementptr inbounds float, float* %tmp, i64 %iv.1
  store float 0.000000e+00, float* %tmp4, align 4
  %iv.1.next = add nuw nsw i64 %iv.1, 1
  %c.1 = icmp ne i64 %iv.1.next, 100
  br i1 %c.1, label %loop.1, label %loop.0.latch

loop.2:                                           ; preds = %loop.2, %loop.0
  %iv.2 = phi i64 [ %iv.2.next, %loop.2 ], [ 0, %loop.0 ]
  %tmp10 = getelementptr inbounds float, float* %tmp, i64 %iv.2
  store float 0.000000e+00, float* %tmp10, align 4
  %tmp11 = load float*, float** %ptr, align 8
  %tmp12 = getelementptr inbounds float, float* %tmp11, i64 %iv.2
  %tmp13 = load float, float* %tmp12, align 4
  %iv.2.next = add nuw nsw i64 %iv.2, 1
  %c.2 = icmp ne i64 %iv.2.next, 100
  br i1 %c.2, label %loop.2, label %loop.0.latch

loop.0.latch:                                     ; preds = %loop.2, %loop.1
  %c.0 = call i1 @cond()
  br i1 %c.0, label %loop.0, label %end

end:                                              ; preds = %loop.0.latch
  ret void
}

declare i1 @cond()

declare void @use.i8(i8*)

declare void @use.i1(i1)

define void @reuse_cast_2(i32 %x, i32* %ptr.1.start) {
; CHECK-LABEL: @reuse_cast_2(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[STACK:%.*]] = alloca [2 x i32], align 4
; CHECK-NEXT:    [[CAST_TO_REUSE:%.*]] = bitcast [2 x i32]* [[STACK]] to i8*
; CHECK-NEXT:    [[C_0:%.*]] = icmp sgt i32 [[X:%.*]], 0
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast [2 x i32]* [[STACK]] to i8*
; CHECK-NEXT:    [[PTR_2_START:%.*]] = getelementptr inbounds [2 x i32], [2 x i32]* [[STACK]], i64 0, i64 0
; CHECK-NEXT:    call void @use.i8(i8* [[CAST_TO_REUSE]])
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[IV:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[IV_NEXT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[PTR_1:%.*]] = phi i32* [ [[PTR_1_START:%.*]], [[ENTRY]] ], [ [[PTR_1_NEXT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[PTR_2:%.*]] = phi i32* [ [[PTR_2_START]], [[ENTRY]] ], [ [[PTR_2_NEXT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[PTR_1_NEXT]] = getelementptr inbounds i32, i32* [[PTR_1]], i64 1
; CHECK-NEXT:    [[LV:%.*]] = load i32, i32* [[PTR_1]], align 4
; CHECK-NEXT:    [[PTR_2_NEXT]] = getelementptr inbounds i32, i32* [[PTR_2]], i64 1
; CHECK-NEXT:    store i32 [[LV]], i32* [[PTR_2]], align 4
; CHECK-NEXT:    [[IV_NEXT]] = add nuw nsw i32 [[IV]], 1
; CHECK-NEXT:    [[C_1:%.*]] = icmp eq i32 [[IV]], 0
; CHECK-NEXT:    br i1 [[C_1]], label [[LOOP]], label [[EXIT:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    call void @use.i1(i1 [[C_0]])
; CHECK-NEXT:    ret void
;
entry:
  %stack = alloca [2 x i32], align 4
  %c.0 = icmp sgt i32 %x, 0
  %cast.to.reuse = bitcast [2 x i32]* %stack to i8*
  %ptr.2.start = getelementptr inbounds [2 x i32], [2 x i32]* %stack, i64 0, i64 0
  call void @use.i8(i8* %cast.to.reuse)
  br label %loop

loop:                                             ; preds = %loop, %entry
  %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop ]
  %ptr.1 = phi i32* [ %ptr.1.start, %entry ], [ %ptr.1.next, %loop ]
  %ptr.2 = phi i32* [ %ptr.2.start, %entry ], [ %ptr.2.next, %loop ]
  %ptr.1.next = getelementptr inbounds i32, i32* %ptr.1, i64 1
  %lv = load i32, i32* %ptr.1, align 4
  %ptr.2.next = getelementptr inbounds i32, i32* %ptr.2, i64 1
  store i32 %lv, i32* %ptr.2, align 4
  %iv.next = add nuw nsw i32 %iv, 1
  %c.1 = icmp eq i32 %iv, 0
  br i1 %c.1, label %loop, label %exit

exit:                                             ; preds = %loop
  call void @use.i1(i1 %c.0)
  ret void
}
