; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -S -jump-threading -jump-threading-threshold=3 < %s | FileCheck %s

; TODO: In this test case, only the stores in %join should cound towards
; the jump threading threshold, as everything else are free instructions.
define i32 @free_instructions(i1 %c, i32* %p) {
; CHECK-LABEL: @free_instructions(
; CHECK-NEXT:    br i1 [[C:%.*]], label [[IF2:%.*]], label [[ELSE2:%.*]]
; CHECK:       if2:
; CHECK-NEXT:    store i32 -1, i32* [[P:%.*]], align 4
; CHECK-NEXT:    call void @llvm.experimental.noalias.scope.decl(metadata [[META0:![0-9]+]])
; CHECK-NEXT:    store i32 1, i32* [[P]], align 4, !noalias !0
; CHECK-NEXT:    call void @llvm.assume(i1 true) [ "align"(i32* [[P]], i64 32) ]
; CHECK-NEXT:    store i32 2, i32* [[P]], align 4
; CHECK-NEXT:    [[P21:%.*]] = bitcast i32* [[P]] to i8*
; CHECK-NEXT:    [[P32:%.*]] = call i8* @llvm.launder.invariant.group.p0i8(i8* [[P21]])
; CHECK-NEXT:    [[P43:%.*]] = bitcast i8* [[P32]] to i32*
; CHECK-NEXT:    store i32 3, i32* [[P43]], align 4, !invariant.group !3
; CHECK-NEXT:    ret i32 0
; CHECK:       else2:
; CHECK-NEXT:    store i32 -2, i32* [[P]], align 4
; CHECK-NEXT:    call void @llvm.experimental.noalias.scope.decl(metadata [[META4:![0-9]+]])
; CHECK-NEXT:    store i32 1, i32* [[P]], align 4, !noalias !4
; CHECK-NEXT:    call void @llvm.assume(i1 true) [ "align"(i32* [[P]], i64 32) ]
; CHECK-NEXT:    store i32 2, i32* [[P]], align 4
; CHECK-NEXT:    [[P2:%.*]] = bitcast i32* [[P]] to i8*
; CHECK-NEXT:    [[P3:%.*]] = call i8* @llvm.launder.invariant.group.p0i8(i8* [[P2]])
; CHECK-NEXT:    [[P4:%.*]] = bitcast i8* [[P3]] to i32*
; CHECK-NEXT:    store i32 3, i32* [[P4]], align 4, !invariant.group !3
; CHECK-NEXT:    ret i32 1
;
  br i1 %c, label %if, label %else

if:
  store i32 -1, i32* %p
  br label %join

else:
  store i32 -2, i32* %p
  br label %join

join:
  call void @llvm.experimental.noalias.scope.decl(metadata !0)
  store i32 1, i32* %p, !noalias !0
  call void @llvm.assume(i1 true) ["align"(i32* %p, i64 32)]
  store i32 2, i32* %p
  %p2 = bitcast i32* %p to i8*
  %p3 = call i8* @llvm.launder.invariant.group.p0i8(i8* %p2)
  %p4 = bitcast i8* %p3 to i32*
  store i32 3, i32* %p4, !invariant.group !{}
  br i1 %c, label %if2, label %else2

if2:
  ret i32 0

else2:
  ret i32 1
}

declare void @llvm.assume(i1)
declare void @llvm.experimental.noalias.scope.decl(metadata)
declare i8* @llvm.launder.invariant.group.p0i8(i8*)

!0 = !{!1}
!1 = distinct !{!1, !2, !"scope"}
!2 = distinct !{!2, !"domain"}
