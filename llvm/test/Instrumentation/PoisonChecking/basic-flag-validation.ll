; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -passes=poison-checking -S -poison-checking-function-local < %s | FileCheck %s

; This file contains tests to exercise the custom flag validation rules

define i32 @add_noflags(i32 %a, i32 %b) {
; CHECK-LABEL: @add_noflags(
; CHECK-NEXT:    [[RES:%.*]] = add i32 [[A:%.*]], [[B:%.*]]
; CHECK-NEXT:    ret i32 [[RES]]
;
  %res = add i32 %a, %b
  ret i32 %res
}

define i32 @add_nsw(i32 %a, i32 %b) {
; CHECK-LABEL: @add_nsw(
; CHECK-NEXT:    [[TMP1:%.*]] = call { i32, i1 } @llvm.sadd.with.overflow.i32(i32 [[A:%.*]], i32 [[B:%.*]])
; CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { i32, i1 } [[TMP1]], 1
; CHECK-NEXT:    [[RES:%.*]] = add nsw i32 [[A]], [[B]]
; CHECK-NEXT:    [[TMP3:%.*]] = xor i1 [[TMP2]], true
; CHECK-NEXT:    call void @__poison_checker_assert(i1 [[TMP3]])
; CHECK-NEXT:    ret i32 [[RES]]
;
  %res = add nsw i32 %a, %b
  ret i32 %res
}

define i32 @add_nuw(i32 %a, i32 %b) {
; CHECK-LABEL: @add_nuw(
; CHECK-NEXT:    [[TMP1:%.*]] = call { i32, i1 } @llvm.uadd.with.overflow.i32(i32 [[A:%.*]], i32 [[B:%.*]])
; CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { i32, i1 } [[TMP1]], 1
; CHECK-NEXT:    [[RES:%.*]] = add nuw i32 [[A]], [[B]]
; CHECK-NEXT:    [[TMP3:%.*]] = xor i1 [[TMP2]], true
; CHECK-NEXT:    call void @__poison_checker_assert(i1 [[TMP3]])
; CHECK-NEXT:    ret i32 [[RES]]
;
  %res = add nuw i32 %a, %b
  ret i32 %res
}

define i32 @add_nsw_nuw(i32 %a, i32 %b) {
; CHECK-LABEL: @add_nsw_nuw(
; CHECK-NEXT:    [[TMP1:%.*]] = call { i32, i1 } @llvm.sadd.with.overflow.i32(i32 [[A:%.*]], i32 [[B:%.*]])
; CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { i32, i1 } [[TMP1]], 1
; CHECK-NEXT:    [[TMP3:%.*]] = call { i32, i1 } @llvm.uadd.with.overflow.i32(i32 [[A]], i32 [[B]])
; CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { i32, i1 } [[TMP3]], 1
; CHECK-NEXT:    [[TMP5:%.*]] = or i1 [[TMP2]], [[TMP4]]
; CHECK-NEXT:    [[RES:%.*]] = add nuw nsw i32 [[A]], [[B]]
; CHECK-NEXT:    [[TMP6:%.*]] = xor i1 [[TMP5]], true
; CHECK-NEXT:    call void @__poison_checker_assert(i1 [[TMP6]])
; CHECK-NEXT:    ret i32 [[RES]]
;
  %res = add nsw nuw i32 %a, %b
  ret i32 %res
}

define i32 @sub_noflags(i32 %a, i32 %b) {
; CHECK-LABEL: @sub_noflags(
; CHECK-NEXT:    [[RES:%.*]] = sub i32 [[A:%.*]], [[B:%.*]]
; CHECK-NEXT:    ret i32 [[RES]]
;
  %res = sub i32 %a, %b
  ret i32 %res
}

define i32 @sub_nsw(i32 %a, i32 %b) {
; CHECK-LABEL: @sub_nsw(
; CHECK-NEXT:    [[TMP1:%.*]] = call { i32, i1 } @llvm.ssub.with.overflow.i32(i32 [[A:%.*]], i32 [[B:%.*]])
; CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { i32, i1 } [[TMP1]], 1
; CHECK-NEXT:    [[RES:%.*]] = sub nsw i32 [[A]], [[B]]
; CHECK-NEXT:    [[TMP3:%.*]] = xor i1 [[TMP2]], true
; CHECK-NEXT:    call void @__poison_checker_assert(i1 [[TMP3]])
; CHECK-NEXT:    ret i32 [[RES]]
;
  %res = sub nsw i32 %a, %b
  ret i32 %res
}

define i32 @sub_nuw(i32 %a, i32 %b) {
; CHECK-LABEL: @sub_nuw(
; CHECK-NEXT:    [[TMP1:%.*]] = call { i32, i1 } @llvm.usub.with.overflow.i32(i32 [[A:%.*]], i32 [[B:%.*]])
; CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { i32, i1 } [[TMP1]], 1
; CHECK-NEXT:    [[RES:%.*]] = sub nuw i32 [[A]], [[B]]
; CHECK-NEXT:    [[TMP3:%.*]] = xor i1 [[TMP2]], true
; CHECK-NEXT:    call void @__poison_checker_assert(i1 [[TMP3]])
; CHECK-NEXT:    ret i32 [[RES]]
;
  %res = sub nuw i32 %a, %b
  ret i32 %res
}

define i32 @sub_nsw_nuw(i32 %a, i32 %b) {
; CHECK-LABEL: @sub_nsw_nuw(
; CHECK-NEXT:    [[TMP1:%.*]] = call { i32, i1 } @llvm.ssub.with.overflow.i32(i32 [[A:%.*]], i32 [[B:%.*]])
; CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { i32, i1 } [[TMP1]], 1
; CHECK-NEXT:    [[TMP3:%.*]] = call { i32, i1 } @llvm.usub.with.overflow.i32(i32 [[A]], i32 [[B]])
; CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { i32, i1 } [[TMP3]], 1
; CHECK-NEXT:    [[TMP5:%.*]] = or i1 [[TMP2]], [[TMP4]]
; CHECK-NEXT:    [[RES:%.*]] = sub nuw nsw i32 [[A]], [[B]]
; CHECK-NEXT:    [[TMP6:%.*]] = xor i1 [[TMP5]], true
; CHECK-NEXT:    call void @__poison_checker_assert(i1 [[TMP6]])
; CHECK-NEXT:    ret i32 [[RES]]
;
  %res = sub nsw nuw i32 %a, %b
  ret i32 %res
}

define i32 @mul_noflags(i32 %a, i32 %b) {
; CHECK-LABEL: @mul_noflags(
; CHECK-NEXT:    [[RES:%.*]] = mul i32 [[A:%.*]], [[B:%.*]]
; CHECK-NEXT:    ret i32 [[RES]]
;
  %res = mul i32 %a, %b
  ret i32 %res
}

define i32 @mul_nsw(i32 %a, i32 %b) {
; CHECK-LABEL: @mul_nsw(
; CHECK-NEXT:    [[TMP1:%.*]] = call { i32, i1 } @llvm.smul.with.overflow.i32(i32 [[A:%.*]], i32 [[B:%.*]])
; CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { i32, i1 } [[TMP1]], 1
; CHECK-NEXT:    [[RES:%.*]] = mul nsw i32 [[A]], [[B]]
; CHECK-NEXT:    [[TMP3:%.*]] = xor i1 [[TMP2]], true
; CHECK-NEXT:    call void @__poison_checker_assert(i1 [[TMP3]])
; CHECK-NEXT:    ret i32 [[RES]]
;
  %res = mul nsw i32 %a, %b
  ret i32 %res
}

define i32 @mul_nuw(i32 %a, i32 %b) {
; CHECK-LABEL: @mul_nuw(
; CHECK-NEXT:    [[TMP1:%.*]] = call { i32, i1 } @llvm.umul.with.overflow.i32(i32 [[A:%.*]], i32 [[B:%.*]])
; CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { i32, i1 } [[TMP1]], 1
; CHECK-NEXT:    [[RES:%.*]] = mul nuw i32 [[A]], [[B]]
; CHECK-NEXT:    [[TMP3:%.*]] = xor i1 [[TMP2]], true
; CHECK-NEXT:    call void @__poison_checker_assert(i1 [[TMP3]])
; CHECK-NEXT:    ret i32 [[RES]]
;
  %res = mul nuw i32 %a, %b
  ret i32 %res
}

define i32 @mul_nsw_nuw(i32 %a, i32 %b) {
; CHECK-LABEL: @mul_nsw_nuw(
; CHECK-NEXT:    [[TMP1:%.*]] = call { i32, i1 } @llvm.smul.with.overflow.i32(i32 [[A:%.*]], i32 [[B:%.*]])
; CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { i32, i1 } [[TMP1]], 1
; CHECK-NEXT:    [[TMP3:%.*]] = call { i32, i1 } @llvm.umul.with.overflow.i32(i32 [[A]], i32 [[B]])
; CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { i32, i1 } [[TMP3]], 1
; CHECK-NEXT:    [[TMP5:%.*]] = or i1 [[TMP2]], [[TMP4]]
; CHECK-NEXT:    [[RES:%.*]] = mul nuw nsw i32 [[A]], [[B]]
; CHECK-NEXT:    [[TMP6:%.*]] = xor i1 [[TMP5]], true
; CHECK-NEXT:    call void @__poison_checker_assert(i1 [[TMP6]])
; CHECK-NEXT:    ret i32 [[RES]]
;
  %res = mul nsw nuw i32 %a, %b
  ret i32 %res
}

define i32 @sdiv_noflags(i32 %a, i32 %b) {
; CHECK-LABEL: @sdiv_noflags(
; CHECK-NEXT:    [[RES:%.*]] = sdiv i32 [[A:%.*]], [[B:%.*]]
; CHECK-NEXT:    ret i32 [[RES]]
;
  %res = sdiv i32 %a, %b
  ret i32 %res
}

define i32 @sdiv_exact(i32 %a, i32 %b) {
; CHECK-LABEL: @sdiv_exact(
; CHECK-NEXT:    [[TMP1:%.*]] = srem i32 [[A:%.*]], [[B:%.*]]
; CHECK-NEXT:    [[TMP2:%.*]] = icmp ne i32 [[TMP1]], 0
; CHECK-NEXT:    [[RES:%.*]] = sdiv exact i32 [[A]], [[B]]
; CHECK-NEXT:    [[TMP3:%.*]] = xor i1 [[TMP2]], true
; CHECK-NEXT:    call void @__poison_checker_assert(i1 [[TMP3]])
; CHECK-NEXT:    ret i32 [[RES]]
;
  %res = sdiv exact i32 %a, %b
  ret i32 %res
}

define i32 @udiv_noflags(i32 %a, i32 %b) {
; CHECK-LABEL: @udiv_noflags(
; CHECK-NEXT:    [[RES:%.*]] = udiv i32 [[A:%.*]], [[B:%.*]]
; CHECK-NEXT:    ret i32 [[RES]]
;
  %res = udiv i32 %a, %b
  ret i32 %res
}

define i32 @udiv_exact(i32 %a, i32 %b) {
; CHECK-LABEL: @udiv_exact(
; CHECK-NEXT:    [[TMP1:%.*]] = urem i32 [[A:%.*]], [[B:%.*]]
; CHECK-NEXT:    [[TMP2:%.*]] = icmp ne i32 [[TMP1]], 0
; CHECK-NEXT:    [[RES:%.*]] = udiv exact i32 [[A]], [[B]]
; CHECK-NEXT:    [[TMP3:%.*]] = xor i1 [[TMP2]], true
; CHECK-NEXT:    call void @__poison_checker_assert(i1 [[TMP3]])
; CHECK-NEXT:    ret i32 [[RES]]
;
  %res = udiv exact i32 %a, %b
  ret i32 %res
}
