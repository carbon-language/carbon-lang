#!/bin/bash
#
#  findmisopt
#
#      This is a quick and dirty hack to potentially find a misoptimization
#      problem. Mostly its to work around problems in bugpoint that prevent
#      it from finding a problem unless the set of failing optimizations are
#      known and given to it on the command line.
#
#      Given a bytecode file that produces correct output (or return code), 
#      this script will run through all the optimizations passes that gccas
#      uses (in the same order) and will narrow down which optimizations
#      cause the program either generate different output or return a 
#      different result code. When the passes have been narrowed down, 
#      bugpoint is invoked to further refine the problem to its origin. If a
#      release version of bugpoint is available it will be used, otherwise 
#      debug.
#
#   Usage:
#      findmisopt bcfile outdir progargs [match]
#
#   Where:
#      bcfile 
#          is the bytecode file input (the unoptimized working case)
#      outdir
#          is a directory into which intermediate results are placed
#      progargs
#          is a single argument containing all the arguments the program needs
#      match
#          if specified to any value causes the result code of the program to
#          be used to determine success/fail. If not specified success/fail is
#          determined by diffing the program's output with the non-optimized
#          output.
#       
if [ "$#" -lt 3 ] ; then
  echo "usage: findmisopt bcfile outdir progargs [match]"
  exit 1
fi

dir="${0%%/utils/findmisopt}"
if [ -x "$dir/Release/bin/bugpoint" ] ; then
  bugpoint="$dir/Release/bin/bugpoint"
elif [ -x "$dir/Debug/bin/bugpoint" ] ; then
  bugpoint="$dir/Debug/bin/bugpoint"
else
  echo "findmisopt: bugpoint not found"
  exit 1
fi

bcfile="$1"
outdir="$2"
args="$3"
match="$4"
name=`basename $bcfile .bc`
ll="$outdir/${name}.ll"
s="$outdir/${name}.s"
prog="$outdir/${name}"
out="$outdir/${name}.out"
optbc="$outdir/${name}.opt.bc"
optll="$outdir/${name}.opt.ll"
opts="$outdir/${name}.opt.s"
optprog="$outdir/${name}.opt"
optout="$outdir/${name}.opt.out"

echo "Test Name: $name"
echo "Unoptimized program: $prog"
echo "  Optimized program: $optprog"

# Create output directory if it doesn't exist
if [ -f "$outdir" ] ; then
  echo "$outdir is not a directory"
  exit 1
fi

if [ ! -d "$outdir" ] ; then
  mkdir "$outdir" || exit 1
fi

# Generate the disassembly
llvm-dis "$bcfile" -o "$ll" -f || exit 1

# Generate the non-optimized program
llc "$bcfile" -o "$s" -f || exit 1
gcc "$s" -o "$prog" -lstdc++ -lc -lm || exit 1

# Define the list of optimizations to run. This comprises the same set of 
# optimizations that gccas and gccld run, in the same order.
all_switches="-verify -lowersetjmp -funcresolve -raiseallocs -simplifycfg -mem2reg -globalopt -globaldce -ipconstprop -deadargelim -instcombine -simplifycfg -prune-eh -inline -simplify-libcalls -argpromotion -raise -tailduplicate -simplifycfg -scalarrepl -instcombine -predsimplify -condprop -tailcallelim -simplifycfg -reassociate -licm -loop-unswitch -instcombine -indvars -loop-unroll -instcombine -load-vn -gcse -sccp -instcombine -condprop -dse -dce -simplifycfg -deadtypeelim -constmerge -funcresolve -internalize -ipsccp -globalopt -constmerge -deadargelim -inline -prune-eh -globalopt -globaldce -argpromotion -instcombine -predsimplify -scalarrepl -globalsmodref-aa -licm -load-vn -gcse -dse -instcombine -simplifycfg -verify"
# Here's an alternative list of optimizations comprising just the ones that 
# gccld uses. To use, just comment out the line above, and uncomment this one
#all_switches="-funcresolve -internalize -ipsccp -globalopt -constmerge -deadargelim -inline -prune-eh -globalopt -globaldce -argpromotion -instcombine -predsimplify -scalarrepl -globalsmodref-aa -licm -load-vn -gcse -dse -instcombine -simplifycfg -verify"

# Current set of switches is empty
function tryit {
  switches_to_use="$1"
  opt $switches_to_use "$bcfile" -o "$optbc" -f || exit
  llvm-dis "$optbc" -o "$optll" -f || exit
  llc "$optbc" -o "$opts" -f || exit
  gcc "$opts" -o "$optprog" -lstdc++ -lc -lm || exit
  "$prog" $args > "$out" 2>&1
  ex1=$?
  "$optprog" $args > "$optout" 2>&1
  ex2=$?

  if [ -n "$match" ] ; then
    if [ "$ex1" -ne "$ex2" ] ; then
      echo "Return code not the same with these switches:"
      echo $switches
      echo "Unoptimized returned: $ex1"
      echo "Optimized   returned: $ex2"
      return 0
    fi
  else
    diff "$out" "$optout" > /dev/null
    if [ $? -ne 0 ] ; then
      echo "Diff fails with these switches:"
      echo $switches
      echo "Differences:"
      diff "$out" "$optout" | head
      return 0;
    fi
  fi
  return 1
}

echo "Trying to find optimization that breaks program:"
for sw in $all_switches ; do
  echo -n " $sw"
  switches="$switches $sw"
  if tryit "$switches" ; then
    break;
  fi
done

# Terminate the previous output with a newline
echo ""

# Determine if we're done because none of the optimizations broke the program
if [ "$switches" == " $all_switches" ] ; then
  echo "The program did not miscompile"
  exit 0
fi

final=""
while [ ! -z "$switches" ] ; do
  trimmed=`echo "$switches" | sed -e 's/^ *\(-[^ ]*\).*/\1/'`
  switches=`echo "$switches" | sed -e 's/^ *-[^ ]* *//'`
  echo "Trimmed $trimmed from left"
  tryit "$final $switches"
  if [ "$?" -eq "0" ] ; then
    echo "Still Failing .. continuing ..."
    continue
  else
    echo "Found required early pass: $trimmed"
    final="$final $trimmed"
    continue
  fi
  echo "Next Loop"
done

if [ "$final" == " $all_switches" ] ; then
  echo "findmisopt: All optimizations pass. Perhaps this isn't a misopt?"
  exit 0
fi
echo "Smallest Optimization list=$final"

bpcmd="$bugpoint -run-llc -disable-loop-extraction --output "$out" --input /dev/null $bcfile $final --args $args"

echo "Running: $bpcmd"
$bpcmd
echo "findmisopt finished."
