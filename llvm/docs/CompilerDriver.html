<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.5: http://docutils.sourceforge.net/" />
<title>Customizing LLVMC: Reference Manual</title>
<link rel="stylesheet" href="llvm.css" type="text/css" />
</head>
<body>
<div class="document" id="customizing-llvmc-reference-manual">
<h1 class="title">Customizing LLVMC: Reference Manual</h1>

<!-- This file was automatically generated by rst2html.
Please do not edit directly!
The ReST source lives in the directory 'tools/llvmc/doc'. -->
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#introduction" id="id4">Introduction</a></li>
<li><a class="reference internal" href="#compiling-with-llvmc" id="id5">Compiling with LLVMC</a></li>
<li><a class="reference internal" href="#predefined-options" id="id6">Predefined options</a></li>
<li><a class="reference internal" href="#compiling-llvmc-plugins" id="id7">Compiling LLVMC plugins</a></li>
<li><a class="reference internal" href="#compiling-standalone-llvmc-based-drivers" id="id8">Compiling standalone LLVMC-based drivers</a></li>
<li><a class="reference internal" href="#customizing-llvmc-the-compilation-graph" id="id9">Customizing LLVMC: the compilation graph</a></li>
<li><a class="reference internal" href="#describing-options" id="id10">Describing options</a><ul>
<li><a class="reference internal" href="#external-options" id="id11">External options</a></li>
</ul>
</li>
<li><a class="reference internal" href="#conditional-evaluation" id="id12">Conditional evaluation</a></li>
<li><a class="reference internal" href="#writing-a-tool-description" id="id13">Writing a tool description</a><ul>
<li><a class="reference internal" href="#actions" id="id14">Actions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#language-map" id="id15">Language map</a></li>
<li><a class="reference internal" href="#more-advanced-topics" id="id16">More advanced topics</a><ul>
<li><a class="reference internal" href="#hooks-and-environment-variables" id="id17">Hooks and environment variables</a></li>
<li><a class="reference internal" href="#how-plugins-are-loaded" id="id18">How plugins are loaded</a></li>
<li><a class="reference internal" href="#debugging" id="id19">Debugging</a></li>
<li><a class="reference internal" href="#conditioning-on-the-executable-name" id="id20">Conditioning on the executable name</a></li>
</ul>
</li>
</ul>
</div>
<div class="doc_author">
<p>Written by <a href="mailto:foldr@codedgers.com">Mikhail Glushenkov</a></p>
</div><div class="section" id="introduction">
<h1><a class="toc-backref" href="#id4">Introduction</a></h1>
<p>LLVMC is a generic compiler driver, designed to be customizable and
extensible. It plays the same role for LLVM as the <tt class="docutils literal"><span class="pre">gcc</span></tt> program
does for GCC - LLVMC's job is essentially to transform a set of input
files into a set of targets depending on configuration rules and user
options. What makes LLVMC different is that these transformation rules
are completely customizable - in fact, LLVMC knows nothing about the
specifics of transformation (even the command-line options are mostly
not hard-coded) and regards the transformation structure as an
abstract graph. The structure of this graph is completely determined
by plugins, which can be either statically or dynamically linked. This
makes it possible to easily adapt LLVMC for other purposes - for
example, as a build tool for game resources.</p>
<p>Because LLVMC employs <a class="reference external" href="http://llvm.org/docs/TableGenFundamentals.html">TableGen</a> as its configuration language, you
need to be familiar with it to customize LLVMC.</p>
</div>
<div class="section" id="compiling-with-llvmc">
<h1><a class="toc-backref" href="#id5">Compiling with LLVMC</a></h1>
<p>LLVMC tries hard to be as compatible with <tt class="docutils literal"><span class="pre">gcc</span></tt> as possible,
although there are some small differences. Most of the time, however,
you shouldn't be able to notice them:</p>
<pre class="literal-block">
$ # This works as expected:
$ llvmc -O3 -Wall hello.cpp
$ ./a.out
hello
</pre>
<p>One nice feature of LLVMC is that one doesn't have to distinguish between
different compilers for different languages (think <tt class="docutils literal"><span class="pre">g++</span></tt> vs.  <tt class="docutils literal"><span class="pre">gcc</span></tt>) - the
right toolchain is chosen automatically based on input language names (which
are, in turn, determined from file extensions). If you want to force files
ending with &quot;.c&quot; to compile as C++, use the <tt class="docutils literal"><span class="pre">-x</span></tt> option, just like you would
do it with <tt class="docutils literal"><span class="pre">gcc</span></tt>:</p>
<pre class="literal-block">
$ # hello.c is really a C++ file
$ llvmc -x c++ hello.c
$ ./a.out
hello
</pre>
<p>On the other hand, when using LLVMC as a linker to combine several C++
object files you should provide the <tt class="docutils literal"><span class="pre">--linker</span></tt> option since it's
impossible for LLVMC to choose the right linker in that case:</p>
<pre class="literal-block">
$ llvmc -c hello.cpp
$ llvmc hello.o
[A lot of link-time errors skipped]
$ llvmc --linker=c++ hello.o
$ ./a.out
hello
</pre>
<p>By default, LLVMC uses <tt class="docutils literal"><span class="pre">llvm-gcc</span></tt> to compile the source code. It is also
possible to choose the <tt class="docutils literal"><span class="pre">clang</span></tt> compiler with the <tt class="docutils literal"><span class="pre">-clang</span></tt> option.</p>
</div>
<div class="section" id="predefined-options">
<h1><a class="toc-backref" href="#id6">Predefined options</a></h1>
<p>LLVMC has some built-in options that can't be overridden in the
configuration libraries:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">-o</span> <span class="pre">FILE</span></tt> - Output file name.</li>
<li><tt class="docutils literal"><span class="pre">-x</span> <span class="pre">LANGUAGE</span></tt> - Specify the language of the following input files
until the next -x option.</li>
<li><tt class="docutils literal"><span class="pre">-load</span> <span class="pre">PLUGIN_NAME</span></tt> - Load the specified plugin DLL. Example:
<tt class="docutils literal"><span class="pre">-load</span> <span class="pre">$LLVM_DIR/Release/lib/LLVMCSimple.so</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">-v</span></tt> - Enable verbose mode, i.e. print out all executed commands.</li>
<li><tt class="docutils literal"><span class="pre">--save-temps</span></tt> - Write temporary files to the current directory and do not
delete them on exit. This option can also take an argument: the
<tt class="docutils literal"><span class="pre">--save-temps=obj</span></tt> switch will write files into the directory specified with
the <tt class="docutils literal"><span class="pre">-o</span></tt> option. The <tt class="docutils literal"><span class="pre">--save-temps=cwd</span></tt> and <tt class="docutils literal"><span class="pre">--save-temps</span></tt> switches are
both synonyms for the default behaviour.</li>
<li><tt class="docutils literal"><span class="pre">--temp-dir</span> <span class="pre">DIRECTORY</span></tt> - Store temporary files in the given directory. This
directory is deleted on exit unless <tt class="docutils literal"><span class="pre">--save-temps</span></tt> is specified. If
<tt class="docutils literal"><span class="pre">--save-temps=obj</span></tt> is also specified, <tt class="docutils literal"><span class="pre">--temp-dir</span></tt> is given the
precedence.</li>
<li><tt class="docutils literal"><span class="pre">--check-graph</span></tt> - Check the compilation for common errors like mismatched
output/input language names, multiple default edges and cycles. Because of
plugins, these checks can't be performed at compile-time. Exit with code zero
if no errors were found, and return the number of found errors
otherwise. Hidden option, useful for debugging LLVMC plugins.</li>
<li><tt class="docutils literal"><span class="pre">--view-graph</span></tt> - Show a graphical representation of the compilation graph
and exit. Requires that you have <tt class="docutils literal"><span class="pre">dot</span></tt> and <tt class="docutils literal"><span class="pre">gv</span></tt> programs installed. Hidden
option, useful for debugging LLVMC plugins.</li>
<li><tt class="docutils literal"><span class="pre">--write-graph</span></tt> - Write a <tt class="docutils literal"><span class="pre">compilation-graph.dot</span></tt> file in the current
directory with the compilation graph description in Graphviz format (identical
to the file used by the <tt class="docutils literal"><span class="pre">--view-graph</span></tt> option). The <tt class="docutils literal"><span class="pre">-o</span></tt> option can be
used to set the output file name. Hidden option, useful for debugging LLVMC
plugins.</li>
<li><tt class="docutils literal"><span class="pre">--help</span></tt>, <tt class="docutils literal"><span class="pre">--help-hidden</span></tt>, <tt class="docutils literal"><span class="pre">--version</span></tt> - These options have
their standard meaning.</li>
</ul>
</div>
<div class="section" id="compiling-llvmc-plugins">
<h1><a class="toc-backref" href="#id7">Compiling LLVMC plugins</a></h1>
<p>It's easiest to start working on your own LLVMC plugin by copying the
skeleton project which lives under <tt class="docutils literal"><span class="pre">$LLVMC_DIR/plugins/Simple</span></tt>:</p>
<pre class="literal-block">
$ cd $LLVMC_DIR/plugins
$ cp -r Simple MyPlugin
$ cd MyPlugin
$ ls
Makefile PluginMain.cpp Simple.td
</pre>
<p>As you can see, our basic plugin consists of only two files (not
counting the build script). <tt class="docutils literal"><span class="pre">Simple.td</span></tt> contains TableGen
description of the compilation graph; its format is documented in the
following sections. <tt class="docutils literal"><span class="pre">PluginMain.cpp</span></tt> is just a helper file used to
compile the auto-generated C++ code produced from TableGen source. It
can also contain hook definitions (see <a class="reference internal" href="#hooks">below</a>).</p>
<p>The first thing that you should do is to change the <tt class="docutils literal"><span class="pre">LLVMC_PLUGIN</span></tt>
variable in the <tt class="docutils literal"><span class="pre">Makefile</span></tt> to avoid conflicts (since this variable
is used to name the resulting library):</p>
<pre class="literal-block">
LLVMC_PLUGIN=MyPlugin
</pre>
<p>It is also a good idea to rename <tt class="docutils literal"><span class="pre">Simple.td</span></tt> to something less
generic:</p>
<pre class="literal-block">
$ mv Simple.td MyPlugin.td
</pre>
<p>To build your plugin as a dynamic library, just <tt class="docutils literal"><span class="pre">cd</span></tt> to its source
directory and run <tt class="docutils literal"><span class="pre">make</span></tt>. The resulting file will be called
<tt class="docutils literal"><span class="pre">plugin_llvmc_$(LLVMC_PLUGIN).$(DLL_EXTENSION)</span></tt> (in our case,
<tt class="docutils literal"><span class="pre">plugin_llvmc_MyPlugin.so</span></tt>). This library can be then loaded in with the
<tt class="docutils literal"><span class="pre">-load</span></tt> option. Example:</p>
<pre class="literal-block">
$ cd $LLVMC_DIR/plugins/Simple
$ make
$ llvmc -load $LLVM_DIR/Release/lib/plugin_llvmc_Simple.so
</pre>
</div>
<div class="section" id="compiling-standalone-llvmc-based-drivers">
<h1><a class="toc-backref" href="#id8">Compiling standalone LLVMC-based drivers</a></h1>
<p>By default, the <tt class="docutils literal"><span class="pre">llvmc</span></tt> executable consists of a driver core plus several
statically linked plugins (<tt class="docutils literal"><span class="pre">Base</span></tt> and <tt class="docutils literal"><span class="pre">Clang</span></tt> at the moment). You can
produce a standalone LLVMC-based driver executable by linking the core with your
own plugins. The recommended way to do this is by starting with the provided
<tt class="docutils literal"><span class="pre">Skeleton</span></tt> example (<tt class="docutils literal"><span class="pre">$LLVMC_DIR/example/Skeleton</span></tt>):</p>
<pre class="literal-block">
$ cd $LLVMC_DIR/example/
$ cp -r Skeleton mydriver
$ cd mydriver
$ vim Makefile
[...]
$ make
</pre>
<p>If you're compiling LLVM with different source and object directories, then you
must perform the following additional steps before running <tt class="docutils literal"><span class="pre">make</span></tt>:</p>
<pre class="literal-block">
# LLVMC_SRC_DIR = $LLVM_SRC_DIR/tools/llvmc/
# LLVMC_OBJ_DIR = $LLVM_OBJ_DIR/tools/llvmc/
$ cp $LLVMC_SRC_DIR/example/mydriver/Makefile \
  $LLVMC_OBJ_DIR/example/mydriver/
$ cd $LLVMC_OBJ_DIR/example/mydriver
$ make
</pre>
<p>Another way to do the same thing is by using the following command:</p>
<pre class="literal-block">
$ cd $LLVMC_DIR
$ make LLVMC_BUILTIN_PLUGINS=MyPlugin LLVMC_BASED_DRIVER_NAME=mydriver
</pre>
<p>This works with both srcdir == objdir and srcdir != objdir, but assumes that the
plugin source directory was placed under <tt class="docutils literal"><span class="pre">$LLVMC_DIR/plugins</span></tt>.</p>
<p>Sometimes, you will want a 'bare-bones' version of LLVMC that has no
built-in plugins. It can be compiled with the following command:</p>
<pre class="literal-block">
$ cd $LLVMC_DIR
$ make LLVMC_BUILTIN_PLUGINS=&quot;&quot;
</pre>
</div>
<div class="section" id="customizing-llvmc-the-compilation-graph">
<h1><a class="toc-backref" href="#id9">Customizing LLVMC: the compilation graph</a></h1>
<p>Each TableGen configuration file should include the common
definitions:</p>
<pre class="literal-block">
include &quot;llvm/CompilerDriver/Common.td&quot;
</pre>
<p>Internally, LLVMC stores information about possible source
transformations in form of a graph. Nodes in this graph represent
tools, and edges between two nodes represent a transformation path. A
special &quot;root&quot; node is used to mark entry points for the
transformations. LLVMC also assigns a weight to each edge (more on
this later) to choose between several alternative edges.</p>
<p>The definition of the compilation graph (see file
<tt class="docutils literal"><span class="pre">plugins/Base/Base.td</span></tt> for an example) is just a list of edges:</p>
<pre class="literal-block">
def CompilationGraph : CompilationGraph&lt;[
    Edge&lt;&quot;root&quot;, &quot;llvm_gcc_c&quot;&gt;,
    Edge&lt;&quot;root&quot;, &quot;llvm_gcc_assembler&quot;&gt;,
    ...

    Edge&lt;&quot;llvm_gcc_c&quot;, &quot;llc&quot;&gt;,
    Edge&lt;&quot;llvm_gcc_cpp&quot;, &quot;llc&quot;&gt;,
    ...

    OptionalEdge&lt;&quot;llvm_gcc_c&quot;, &quot;opt&quot;, (case (switch_on &quot;opt&quot;),
                                      (inc_weight))&gt;,
    OptionalEdge&lt;&quot;llvm_gcc_cpp&quot;, &quot;opt&quot;, (case (switch_on &quot;opt&quot;),
                                              (inc_weight))&gt;,
    ...

    OptionalEdge&lt;&quot;llvm_gcc_assembler&quot;, &quot;llvm_gcc_cpp_linker&quot;,
        (case (input_languages_contain &quot;c++&quot;), (inc_weight),
              (or (parameter_equals &quot;linker&quot;, &quot;g++&quot;),
                  (parameter_equals &quot;linker&quot;, &quot;c++&quot;)), (inc_weight))&gt;,
    ...

    ]&gt;;
</pre>
<p>As you can see, the edges can be either default or optional, where
optional edges are differentiated by an additional <tt class="docutils literal"><span class="pre">case</span></tt> expression
used to calculate the weight of this edge. Notice also that we refer
to tools via their names (as strings). This makes it possible to add
edges to an existing compilation graph in plugins without having to
know about all tool definitions used in the graph.</p>
<p>The default edges are assigned a weight of 1, and optional edges get a
weight of 0 + 2*N where N is the number of tests that evaluated to
true in the <tt class="docutils literal"><span class="pre">case</span></tt> expression. It is also possible to provide an
integer parameter to <tt class="docutils literal"><span class="pre">inc_weight</span></tt> and <tt class="docutils literal"><span class="pre">dec_weight</span></tt> - in this case,
the weight is increased (or decreased) by the provided value instead
of the default 2. It is also possible to change the default weight of
an optional edge by using the <tt class="docutils literal"><span class="pre">default</span></tt> clause of the <tt class="docutils literal"><span class="pre">case</span></tt>
construct.</p>
<p>When passing an input file through the graph, LLVMC picks the edge
with the maximum weight. To avoid ambiguity, there should be only one
default edge between two nodes (with the exception of the root node,
which gets a special treatment - there you are allowed to specify one
default edge <em>per language</em>).</p>
<p>When multiple plugins are loaded, their compilation graphs are merged
together. Since multiple edges that have the same end nodes are not
allowed (i.e. the graph is not a multigraph), an edge defined in
several plugins will be replaced by the definition from the plugin
that was loaded last. Plugin load order can be controlled by using the
plugin priority feature described above.</p>
<p>To get a visual representation of the compilation graph (useful for
debugging), run <tt class="docutils literal"><span class="pre">llvmc</span> <span class="pre">--view-graph</span></tt>. You will need <tt class="docutils literal"><span class="pre">dot</span></tt> and
<tt class="docutils literal"><span class="pre">gsview</span></tt> installed for this to work properly.</p>
</div>
<div class="section" id="describing-options">
<h1><a class="toc-backref" href="#id10">Describing options</a></h1>
<p>Command-line options that the plugin supports are defined by using an
<tt class="docutils literal"><span class="pre">OptionList</span></tt>:</p>
<pre class="literal-block">
def Options : OptionList&lt;[
(switch_option &quot;E&quot;, (help &quot;Help string&quot;)),
(alias_option &quot;quiet&quot;, &quot;q&quot;)
...
]&gt;;
</pre>
<p>As you can see, the option list is just a list of DAGs, where each DAG
is an option description consisting of the option name and some
properties. A plugin can define more than one option list (they are
all merged together in the end), which can be handy if one wants to
separate option groups syntactically.</p>
<ul>
<li><p class="first">Possible option types:</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">switch_option</span></tt> - a simple boolean switch without arguments, for example
<tt class="docutils literal"><span class="pre">-O2</span></tt> or <tt class="docutils literal"><span class="pre">-time</span></tt>. At most one occurrence is allowed.</li>
<li><tt class="docutils literal"><span class="pre">parameter_option</span></tt> - option that takes one argument, for example
<tt class="docutils literal"><span class="pre">-std=c99</span></tt>. It is also allowed to use spaces instead of the equality
sign: <tt class="docutils literal"><span class="pre">-std</span> <span class="pre">c99</span></tt>. At most one occurrence is allowed.</li>
<li><tt class="docutils literal"><span class="pre">parameter_list_option</span></tt> - same as the above, but more than one option
occurrence is allowed.</li>
<li><tt class="docutils literal"><span class="pre">prefix_option</span></tt> - same as the parameter_option, but the option name and
argument do not have to be separated. Example: <tt class="docutils literal"><span class="pre">-ofile</span></tt>. This can be also
specified as <tt class="docutils literal"><span class="pre">-o</span> <span class="pre">file</span></tt>; however, <tt class="docutils literal"><span class="pre">-o=file</span></tt> will be parsed incorrectly
(<tt class="docutils literal"><span class="pre">=file</span></tt> will be interpreted as option value). At most one occurrence is
allowed.</li>
<li><tt class="docutils literal"><span class="pre">prefix_list_option</span></tt> - same as the above, but more than one occurrence of
the option is allowed; example: <tt class="docutils literal"><span class="pre">-lm</span> <span class="pre">-lpthread</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">alias_option</span></tt> - a special option type for creating aliases. Unlike other
option types, aliases are not allowed to have any properties besides the
aliased option name. Usage example: <tt class="docutils literal"><span class="pre">(alias_option</span> <span class="pre">&quot;preprocess&quot;,</span> <span class="pre">&quot;E&quot;)</span></tt></li>
</ul>
</blockquote>
</li>
<li><p class="first">Possible option properties:</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">help</span></tt> - help string associated with this option. Used for <tt class="docutils literal"><span class="pre">--help</span></tt>
output.</li>
<li><tt class="docutils literal"><span class="pre">required</span></tt> - this option must be specified exactly once (or, in case of
the list options without the <tt class="docutils literal"><span class="pre">multi_val</span></tt> property, at least
once). Incompatible with <tt class="docutils literal"><span class="pre">zero_or_one</span></tt> and <tt class="docutils literal"><span class="pre">one_or_more</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">one_or_more</span></tt> - the option must be specified at least one time. Useful
only for list options in conjunction with <tt class="docutils literal"><span class="pre">multi_val</span></tt>; for ordinary lists
it is synonymous with <tt class="docutils literal"><span class="pre">required</span></tt>. Incompatible with <tt class="docutils literal"><span class="pre">required</span></tt> and
<tt class="docutils literal"><span class="pre">zero_or_one</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">zero_or_one</span></tt> - the option can be specified zero or one times. Useful
only for list options in conjunction with <tt class="docutils literal"><span class="pre">multi_val</span></tt>. Incompatible with
<tt class="docutils literal"><span class="pre">required</span></tt> and <tt class="docutils literal"><span class="pre">one_or_more</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">hidden</span></tt> - the description of this option will not appear in
the <tt class="docutils literal"><span class="pre">--help</span></tt> output (but will appear in the <tt class="docutils literal"><span class="pre">--help-hidden</span></tt>
output).</li>
<li><tt class="docutils literal"><span class="pre">really_hidden</span></tt> - the option will not be mentioned in any help
output.</li>
<li><tt class="docutils literal"><span class="pre">multi_val</span> <span class="pre">n</span></tt> - this option takes <em>n</em> arguments (can be useful in some
special cases). Usage example: <tt class="docutils literal"><span class="pre">(parameter_list_option</span> <span class="pre">&quot;foo&quot;,</span> <span class="pre">(multi_val</span>
<span class="pre">3))</span></tt>. Only list options can have this attribute; you can, however, use
the <tt class="docutils literal"><span class="pre">one_or_more</span></tt> and <tt class="docutils literal"><span class="pre">zero_or_one</span></tt> properties.</li>
<li><tt class="docutils literal"><span class="pre">init</span></tt> - this option has a default value, either a string (if it is a
parameter), or a boolean (if it is a switch; boolean constants are called
<tt class="docutils literal"><span class="pre">true</span></tt> and <tt class="docutils literal"><span class="pre">false</span></tt>). List options can't have this attribute. Usage
examples: <tt class="docutils literal"><span class="pre">(switch_option</span> <span class="pre">&quot;foo&quot;,</span> <span class="pre">(init</span> <span class="pre">true))</span></tt>; <tt class="docutils literal"><span class="pre">(prefix_option</span> <span class="pre">&quot;bar&quot;,</span>
<span class="pre">(init</span> <span class="pre">&quot;baz&quot;))</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">extern</span></tt> - this option is defined in some other plugin, see below.</li>
</ul>
</blockquote>
</li>
</ul>
<div class="section" id="external-options">
<h2><a class="toc-backref" href="#id11">External options</a></h2>
<p>Sometimes, when linking several plugins together, one plugin needs to
access options defined in some other plugin. Because of the way
options are implemented, such options must be marked as
<tt class="docutils literal"><span class="pre">extern</span></tt>. This is what the <tt class="docutils literal"><span class="pre">extern</span></tt> option property is
for. Example:</p>
<pre class="literal-block">
...
(switch_option &quot;E&quot;, (extern))
...
</pre>
<p>If an external option has additional attributes besides 'extern', they are
ignored. See also the section on plugin <a class="reference internal" href="#priorities">priorities</a>.</p>
</div>
</div>
<div class="section" id="conditional-evaluation">
<span id="case"></span><h1><a class="toc-backref" href="#id12">Conditional evaluation</a></h1>
<p>The 'case' construct is the main means by which programmability is
achieved in LLVMC. It can be used to calculate edge weights, program
actions and modify the shell commands to be executed. The 'case'
expression is designed after the similarly-named construct in
functional languages and takes the form <tt class="docutils literal"><span class="pre">(case</span> <span class="pre">(test_1),</span> <span class="pre">statement_1,</span>
<span class="pre">(test_2),</span> <span class="pre">statement_2,</span> <span class="pre">...</span> <span class="pre">(test_N),</span> <span class="pre">statement_N)</span></tt>. The statements
are evaluated only if the corresponding tests evaluate to true.</p>
<p>Examples:</p>
<pre class="literal-block">
// Edge weight calculation

// Increases edge weight by 5 if &quot;-A&quot; is provided on the
// command-line, and by 5 more if &quot;-B&quot; is also provided.
(case
    (switch_on &quot;A&quot;), (inc_weight 5),
    (switch_on &quot;B&quot;), (inc_weight 5))


// Tool command line specification

// Evaluates to &quot;cmdline1&quot; if the option &quot;-A&quot; is provided on the
// command line; to &quot;cmdline2&quot; if &quot;-B&quot; is provided;
// otherwise to &quot;cmdline3&quot;.

(case
    (switch_on &quot;A&quot;), &quot;cmdline1&quot;,
    (switch_on &quot;B&quot;), &quot;cmdline2&quot;,
    (default), &quot;cmdline3&quot;)
</pre>
<p>Note the slight difference in 'case' expression handling in contexts
of edge weights and command line specification - in the second example
the value of the <tt class="docutils literal"><span class="pre">&quot;B&quot;</span></tt> switch is never checked when switch <tt class="docutils literal"><span class="pre">&quot;A&quot;</span></tt> is
enabled, and the whole expression always evaluates to <tt class="docutils literal"><span class="pre">&quot;cmdline1&quot;</span></tt> in
that case.</p>
<p>Case expressions can also be nested, i.e. the following is legal:</p>
<pre class="literal-block">
(case (switch_on &quot;E&quot;), (case (switch_on &quot;o&quot;), ..., (default), ...)
      (default), ...)
</pre>
<p>You should, however, try to avoid doing that because it hurts
readability. It is usually better to split tool descriptions and/or
use TableGen inheritance instead.</p>
<ul class="simple">
<li>Possible tests are:<ul>
<li><tt class="docutils literal"><span class="pre">switch_on</span></tt> - Returns true if a given command-line switch is
provided by the user. Example: <tt class="docutils literal"><span class="pre">(switch_on</span> <span class="pre">&quot;opt&quot;)</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">parameter_equals</span></tt> - Returns true if a command-line parameter equals
a given value.
Example: <tt class="docutils literal"><span class="pre">(parameter_equals</span> <span class="pre">&quot;W&quot;,</span> <span class="pre">&quot;all&quot;)</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">element_in_list</span></tt> - Returns true if a command-line parameter
list contains a given value.
Example: <tt class="docutils literal"><span class="pre">(parameter_in_list</span> <span class="pre">&quot;l&quot;,</span> <span class="pre">&quot;pthread&quot;)</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">input_languages_contain</span></tt> - Returns true if a given language
belongs to the current input language set.
Example: <tt class="docutils literal"><span class="pre">(input_languages_contain</span> <span class="pre">&quot;c++&quot;)</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">in_language</span></tt> - Evaluates to true if the input file language
equals to the argument. At the moment works only with <tt class="docutils literal"><span class="pre">cmd_line</span></tt>
and <tt class="docutils literal"><span class="pre">actions</span></tt> (on non-join nodes).
Example: <tt class="docutils literal"><span class="pre">(in_language</span> <span class="pre">&quot;c++&quot;)</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">not_empty</span></tt> - Returns true if a given option (which should be
either a parameter or a parameter list) is set by the
user.
Example: <tt class="docutils literal"><span class="pre">(not_empty</span> <span class="pre">&quot;o&quot;)</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">empty</span></tt> - The opposite of <tt class="docutils literal"><span class="pre">not_empty</span></tt>. Equivalent to <tt class="docutils literal"><span class="pre">(not</span> <span class="pre">(not_empty</span>
<span class="pre">X))</span></tt>. Provided for convenience.</li>
<li><tt class="docutils literal"><span class="pre">single_input_file</span></tt> - Returns true if there was only one input file
provided on the command-line. Used without arguments:
<tt class="docutils literal"><span class="pre">(single_input_file)</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">multiple_input_files</span></tt> - Equivalent to <tt class="docutils literal"><span class="pre">(not</span> <span class="pre">(single_input_file))</span></tt> (the
case of zero input files is considered an error).</li>
<li><tt class="docutils literal"><span class="pre">default</span></tt> - Always evaluates to true. Should always be the last
test in the <tt class="docutils literal"><span class="pre">case</span></tt> expression.</li>
<li><tt class="docutils literal"><span class="pre">and</span></tt> - A standard binary logical combinator that returns true iff all of
its arguments return true. Used like this: <tt class="docutils literal"><span class="pre">(and</span> <span class="pre">(test1),</span> <span class="pre">(test2),</span>
<span class="pre">...</span> <span class="pre">(testN))</span></tt>. Nesting of <tt class="docutils literal"><span class="pre">and</span></tt> and <tt class="docutils literal"><span class="pre">or</span></tt> is allowed, but not
encouraged.</li>
<li><tt class="docutils literal"><span class="pre">or</span></tt> - A binary logical combinator that returns true iff any of its
arguments returns true. Example: <tt class="docutils literal"><span class="pre">(or</span> <span class="pre">(test1),</span> <span class="pre">(test2),</span> <span class="pre">...</span> <span class="pre">(testN))</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">not</span></tt> - Standard unary logical combinator that negates its
argument. Example: <tt class="docutils literal"><span class="pre">(not</span> <span class="pre">(or</span> <span class="pre">(test1),</span> <span class="pre">(test2),</span> <span class="pre">...</span> <span class="pre">(testN)))</span></tt>.</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="writing-a-tool-description">
<h1><a class="toc-backref" href="#id13">Writing a tool description</a></h1>
<p>As was said earlier, nodes in the compilation graph represent tools,
which are described separately. A tool definition looks like this
(taken from the <tt class="docutils literal"><span class="pre">include/llvm/CompilerDriver/Tools.td</span></tt> file):</p>
<pre class="literal-block">
def llvm_gcc_cpp : Tool&lt;[
    (in_language &quot;c++&quot;),
    (out_language &quot;llvm-assembler&quot;),
    (output_suffix &quot;bc&quot;),
    (cmd_line &quot;llvm-g++ -c $INFILE -o $OUTFILE -emit-llvm&quot;),
    (sink)
    ]&gt;;
</pre>
<p>This defines a new tool called <tt class="docutils literal"><span class="pre">llvm_gcc_cpp</span></tt>, which is an alias for
<tt class="docutils literal"><span class="pre">llvm-g++</span></tt>. As you can see, a tool definition is just a list of
properties; most of them should be self-explanatory. The <tt class="docutils literal"><span class="pre">sink</span></tt>
property means that this tool should be passed all command-line
options that aren't mentioned in the option list.</p>
<p>The complete list of all currently implemented tool properties follows.</p>
<ul class="simple">
<li>Possible tool properties:<ul>
<li><tt class="docutils literal"><span class="pre">in_language</span></tt> - input language name. Can be either a string or a
list, in case the tool supports multiple input languages.</li>
<li><tt class="docutils literal"><span class="pre">out_language</span></tt> - output language name. Tools are not allowed to
have multiple output languages.</li>
<li><tt class="docutils literal"><span class="pre">output_suffix</span></tt> - output file suffix. Can also be changed
dynamically, see documentation on actions.</li>
<li><tt class="docutils literal"><span class="pre">cmd_line</span></tt> - the actual command used to run the tool. You can
use <tt class="docutils literal"><span class="pre">$INFILE</span></tt> and <tt class="docutils literal"><span class="pre">$OUTFILE</span></tt> variables, output redirection
with <tt class="docutils literal"><span class="pre">&gt;</span></tt>, hook invocations (<tt class="docutils literal"><span class="pre">$CALL</span></tt>), environment variables
(via <tt class="docutils literal"><span class="pre">$ENV</span></tt>) and the <tt class="docutils literal"><span class="pre">case</span></tt> construct.</li>
<li><tt class="docutils literal"><span class="pre">join</span></tt> - this tool is a &quot;join node&quot; in the graph, i.e. it gets a
list of input files and joins them together. Used for linkers.</li>
<li><tt class="docutils literal"><span class="pre">sink</span></tt> - all command-line options that are not handled by other
tools are passed to this tool.</li>
<li><tt class="docutils literal"><span class="pre">actions</span></tt> - A single big <tt class="docutils literal"><span class="pre">case</span></tt> expression that specifies how
this tool reacts on command-line options (described in more detail
below).</li>
</ul>
</li>
</ul>
<div class="section" id="actions">
<h2><a class="toc-backref" href="#id14">Actions</a></h2>
<p>A tool often needs to react to command-line options, and this is
precisely what the <tt class="docutils literal"><span class="pre">actions</span></tt> property is for. The next example
illustrates this feature:</p>
<pre class="literal-block">
def llvm_gcc_linker : Tool&lt;[
    (in_language &quot;object-code&quot;),
    (out_language &quot;executable&quot;),
    (output_suffix &quot;out&quot;),
    (cmd_line &quot;llvm-gcc $INFILE -o $OUTFILE&quot;),
    (join),
    (actions (case (not_empty &quot;L&quot;), (forward &quot;L&quot;),
                   (not_empty &quot;l&quot;), (forward &quot;l&quot;),
                   (not_empty &quot;dummy&quot;),
                             [(append_cmd &quot;-dummy1&quot;), (append_cmd &quot;-dummy2&quot;)])
    ]&gt;;
</pre>
<p>The <tt class="docutils literal"><span class="pre">actions</span></tt> tool property is implemented on top of the omnipresent
<tt class="docutils literal"><span class="pre">case</span></tt> expression. It associates one or more different <em>actions</em>
with given conditions - in the example, the actions are <tt class="docutils literal"><span class="pre">forward</span></tt>,
which forwards a given option unchanged, and <tt class="docutils literal"><span class="pre">append_cmd</span></tt>, which
appends a given string to the tool execution command. Multiple actions
can be associated with a single condition by using a list of actions
(used in the example to append some dummy options). The same <tt class="docutils literal"><span class="pre">case</span></tt>
construct can also be used in the <tt class="docutils literal"><span class="pre">cmd_line</span></tt> property to modify the
tool command line.</p>
<p>The &quot;join&quot; property used in the example means that this tool behaves
like a linker.</p>
<p>The list of all possible actions follows.</p>
<ul>
<li><p class="first">Possible actions:</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">append_cmd</span></tt> - append a string to the tool invocation
command.
Example: <tt class="docutils literal"><span class="pre">(case</span> <span class="pre">(switch_on</span> <span class="pre">&quot;pthread&quot;),</span> <span class="pre">(append_cmd</span>
<span class="pre">&quot;-lpthread&quot;))</span></tt></li>
<li><tt class="docutils literal"><span class="pre">error`</span> <span class="pre">-</span> <span class="pre">exit</span> <span class="pre">with</span> <span class="pre">error.</span>
<span class="pre">Example:</span> <span class="pre">``(error</span> <span class="pre">&quot;Mixing</span> <span class="pre">-c</span> <span class="pre">and</span> <span class="pre">-S</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">allowed!&quot;)</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">forward</span></tt> - forward an option unchanged.
Example: <tt class="docutils literal"><span class="pre">(forward</span> <span class="pre">&quot;Wall&quot;)</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">forward_as</span></tt> - Change the name of an option, but forward the
argument unchanged.
Example: <tt class="docutils literal"><span class="pre">(forward_as</span> <span class="pre">&quot;O0&quot;,</span> <span class="pre">&quot;--disable-optimization&quot;)</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">output_suffix</span></tt> - modify the output suffix of this
tool.
Example: <tt class="docutils literal"><span class="pre">(output_suffix</span> <span class="pre">&quot;i&quot;)</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">stop_compilation</span></tt> - stop compilation after this tool processes
its input. Used without arguments.</li>
<li><tt class="docutils literal"><span class="pre">unpack_values</span></tt> - used for for splitting and forwarding
comma-separated lists of options, e.g. <tt class="docutils literal"><span class="pre">-Wa,-foo=bar,-baz</span></tt> is
converted to <tt class="docutils literal"><span class="pre">-foo=bar</span> <span class="pre">-baz</span></tt> and appended to the tool invocation
command.
Example: <tt class="docutils literal"><span class="pre">(unpack_values</span> <span class="pre">&quot;Wa,&quot;)</span></tt>.</li>
</ul>
</blockquote>
</li>
</ul>
</div>
</div>
<div class="section" id="language-map">
<h1><a class="toc-backref" href="#id15">Language map</a></h1>
<p>If you are adding support for a new language to LLVMC, you'll need to
modify the language map, which defines mappings from file extensions
to language names. It is used to choose the proper toolchain(s) for a
given input file set. Language map definition looks like this:</p>
<pre class="literal-block">
def LanguageMap : LanguageMap&lt;
    [LangToSuffixes&lt;&quot;c++&quot;, [&quot;cc&quot;, &quot;cp&quot;, &quot;cxx&quot;, &quot;cpp&quot;, &quot;CPP&quot;, &quot;c++&quot;, &quot;C&quot;]&gt;,
     LangToSuffixes&lt;&quot;c&quot;, [&quot;c&quot;]&gt;,
     ...
    ]&gt;;
</pre>
<p>For example, without those definitions the following command wouldn't work:</p>
<pre class="literal-block">
$ llvmc hello.cpp
llvmc: Unknown suffix: cpp
</pre>
<p>The language map entries should be added only for tools that are
linked with the root node. Since tools are not allowed to have
multiple output languages, for nodes &quot;inside&quot; the graph the input and
output languages should match. This is enforced at compile-time.</p>
</div>
<div class="section" id="more-advanced-topics">
<h1><a class="toc-backref" href="#id16">More advanced topics</a></h1>
<div class="section" id="hooks-and-environment-variables">
<span id="hooks"></span><h2><a class="toc-backref" href="#id17">Hooks and environment variables</a></h2>
<p>Normally, LLVMC executes programs from the system <tt class="docutils literal"><span class="pre">PATH</span></tt>. Sometimes,
this is not sufficient: for example, we may want to specify tool paths
or names in the configuration file. This can be easily achieved via
the hooks mechanism. To write your own hooks, just add their
definitions to the <tt class="docutils literal"><span class="pre">PluginMain.cpp</span></tt> or drop a <tt class="docutils literal"><span class="pre">.cpp</span></tt> file into the
your plugin directory. Hooks should live in the <tt class="docutils literal"><span class="pre">hooks</span></tt> namespace
and have the signature <tt class="docutils literal"><span class="pre">std::string</span> <span class="pre">hooks::MyHookName</span> <span class="pre">([const</span> <span class="pre">char*</span>
<span class="pre">Arg0</span> <span class="pre">[</span> <span class="pre">const</span> <span class="pre">char*</span> <span class="pre">Arg2</span> <span class="pre">[,</span> <span class="pre">...]]])</span></tt>. They can be used from the
<tt class="docutils literal"><span class="pre">cmd_line</span></tt> tool property:</p>
<pre class="literal-block">
(cmd_line &quot;$CALL(MyHook)/path/to/file -o $CALL(AnotherHook)&quot;)
</pre>
<p>To pass arguments to hooks, use the following syntax:</p>
<pre class="literal-block">
(cmd_line &quot;$CALL(MyHook, 'Arg1', 'Arg2', 'Arg # 3')/path/to/file -o1 -o2&quot;)
</pre>
<p>It is also possible to use environment variables in the same manner:</p>
<pre class="literal-block">
(cmd_line &quot;$ENV(VAR1)/path/to/file -o $ENV(VAR2)&quot;)
</pre>
<p>To change the command line string based on user-provided options use
the <tt class="docutils literal"><span class="pre">case</span></tt> expression (documented <a class="reference internal" href="#case">above</a>):</p>
<pre class="literal-block">
(cmd_line
  (case
    (switch_on &quot;E&quot;),
       &quot;llvm-g++ -E -x c $INFILE -o $OUTFILE&quot;,
    (default),
       &quot;llvm-g++ -c -x c $INFILE -o $OUTFILE -emit-llvm&quot;))
</pre>
</div>
<div class="section" id="how-plugins-are-loaded">
<span id="priorities"></span><h2><a class="toc-backref" href="#id18">How plugins are loaded</a></h2>
<p>It is possible for LLVMC plugins to depend on each other. For example,
one can create edges between nodes defined in some other plugin. To
make this work, however, that plugin should be loaded first. To
achieve this, the concept of plugin priority was introduced. By
default, every plugin has priority zero; to specify the priority
explicitly, put the following line in your plugin's TableGen file:</p>
<pre class="literal-block">
def Priority : PluginPriority&lt;$PRIORITY_VALUE&gt;;
# Where PRIORITY_VALUE is some integer &gt; 0
</pre>
<p>Plugins are loaded in order of their (increasing) priority, starting
with 0. Therefore, the plugin with the highest priority value will be
loaded last.</p>
</div>
<div class="section" id="debugging">
<h2><a class="toc-backref" href="#id19">Debugging</a></h2>
<p>When writing LLVMC plugins, it can be useful to get a visual view of
the resulting compilation graph. This can be achieved via the command
line option <tt class="docutils literal"><span class="pre">--view-graph</span></tt>. This command assumes that <a class="reference external" href="http://www.graphviz.org/">Graphviz</a> and
<a class="reference external" href="http://pages.cs.wisc.edu/~ghost/">Ghostview</a> are installed. There is also a <tt class="docutils literal"><span class="pre">--write-graph</span></tt> option that
creates a Graphviz source file (<tt class="docutils literal"><span class="pre">compilation-graph.dot</span></tt>) in the
current directory.</p>
<p>Another useful <tt class="docutils literal"><span class="pre">llvmc</span></tt> option is <tt class="docutils literal"><span class="pre">--check-graph</span></tt>. It checks the
compilation graph for common errors like mismatched output/input
language names, multiple default edges and cycles. These checks can't
be performed at compile-time because the plugins can load code
dynamically. When invoked with <tt class="docutils literal"><span class="pre">--check-graph</span></tt>, <tt class="docutils literal"><span class="pre">llvmc</span></tt> doesn't
perform any compilation tasks and returns the number of encountered
errors as its status code.</p>
</div>
<div class="section" id="conditioning-on-the-executable-name">
<h2><a class="toc-backref" href="#id20">Conditioning on the executable name</a></h2>
<p>For now, the executable name (the value passed to the driver in <tt class="docutils literal"><span class="pre">argv[0]</span></tt>) is
accessible only in the C++ code (i.e. hooks). Use the following code:</p>
<pre class="literal-block">
namespace llvmc {
extern const char* ProgramName;
}

std::string MyHook() {
//...
if (strcmp(ProgramName, &quot;mydriver&quot;) == 0) {
   //...

}
</pre>
<p>In general, you're encouraged not to make the behaviour dependent on the
executable file name, and use command-line switches instead. See for example how
the <tt class="docutils literal"><span class="pre">Base</span></tt> plugin behaves when it needs to choose the correct linker options
(think <tt class="docutils literal"><span class="pre">g++</span></tt> vs. <tt class="docutils literal"><span class="pre">gcc</span></tt>).</p>
<hr />
<address>
<a href="http://jigsaw.w3.org/css-validator/check/referer">
<img src="http://jigsaw.w3.org/css-validator/images/vcss-blue"
   alt="Valid CSS" /></a>
<a href="http://validator.w3.org/check?uri=referer">
<img src="http://www.w3.org/Icons/valid-xhtml10-blue"
   alt="Valid XHTML 1.0 Transitional"/></a>

<a href="mailto:foldr@codedgers.com">Mikhail Glushenkov</a><br />
<a href="http://llvm.org">LLVM Compiler Infrastructure</a><br />

Last modified: $Date$
</address></div>
</div>
</div>
</body>
</html>
