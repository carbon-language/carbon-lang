<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.6: http://docutils.sourceforge.net/" />
<title>Customizing LLVMC: Reference Manual</title>
<link rel="stylesheet" href="llvm.css" type="text/css" />
</head>
<body>
<div class="document" id="customizing-llvmc-reference-manual">
<h1 class="title">Customizing LLVMC: Reference Manual</h1>

<!-- This file was automatically generated by rst2html.
Please do not edit directly!
The ReST source lives in the directory 'tools/llvmc/doc'. -->
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#introduction" id="id7">Introduction</a></li>
<li><a class="reference internal" href="#compiling-with-llvmc" id="id8">Compiling with <tt class="docutils literal">llvmc</tt></a></li>
<li><a class="reference internal" href="#predefined-options" id="id9">Predefined options</a></li>
<li><a class="reference internal" href="#compiling-llvmc-based-drivers" id="id10">Compiling LLVMC-based drivers</a></li>
<li><a class="reference internal" href="#customizing-llvmc-the-compilation-graph" id="id11">Customizing LLVMC: the compilation graph</a></li>
<li><a class="reference internal" href="#describing-options" id="id12">Describing options</a></li>
<li><a class="reference internal" href="#conditional-evaluation" id="id13">Conditional evaluation</a></li>
<li><a class="reference internal" href="#writing-a-tool-description" id="id14">Writing a tool description</a><ul>
<li><a class="reference internal" href="#id4" id="id15">Actions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#language-map" id="id16">Language map</a></li>
<li><a class="reference internal" href="#option-preprocessor" id="id17">Option preprocessor</a></li>
<li><a class="reference internal" href="#more-advanced-topics" id="id18">More advanced topics</a><ul>
<li><a class="reference internal" href="#hooks-and-environment-variables" id="id19">Hooks and environment variables</a></li>
<li><a class="reference internal" href="#debugging" id="id20">Debugging</a></li>
<li><a class="reference internal" href="#conditioning-on-the-executable-name" id="id21">Conditioning on the executable name</a></li>
</ul>
</li>
</ul>
</div>
<div class="doc_author">
<p>Written by <a href="mailto:foldr@codedgers.com">Mikhail Glushenkov</a></p>
</div><div class="section" id="introduction">
<h1><a class="toc-backref" href="#id7">Introduction</a></h1>
<p>LLVMC is a generic compiler driver, designed to be customizable and
extensible. It plays the same role for LLVM as the <tt class="docutils literal">gcc</tt> program does for
GCC - LLVMC's job is essentially to transform a set of input files into a set of
targets depending on configuration rules and user options. What makes LLVMC
different is that these transformation rules are completely customizable - in
fact, LLVMC knows nothing about the specifics of transformation (even the
command-line options are mostly not hard-coded) and regards the transformation
structure as an abstract graph. The structure of this graph is described in
high-level TableGen code, from which an efficient C++ representation is
automatically derived. This makes it possible to adapt LLVMC for other
purposes - for example, as a build tool for game resources.</p>
<p>Because LLVMC employs <a class="reference external" href="http://llvm.org/docs/TableGenFundamentals.html">TableGen</a> as its configuration language, you
need to be familiar with it to customize LLVMC.</p>
</div>
<div class="section" id="compiling-with-llvmc">
<h1><a class="toc-backref" href="#id8">Compiling with <tt class="docutils literal">llvmc</tt></a></h1>
<p>LLVMC tries hard to be as compatible with <tt class="docutils literal">gcc</tt> as possible,
although there are some small differences. Most of the time, however,
you shouldn't be able to notice them:</p>
<pre class="literal-block">
$ # This works as expected:
$ llvmc -O3 -Wall hello.cpp
$ ./a.out
hello
</pre>
<p>One nice feature of LLVMC is that one doesn't have to distinguish between
different compilers for different languages (think <tt class="docutils literal">g++</tt> vs.  <tt class="docutils literal">gcc</tt>) - the
right toolchain is chosen automatically based on input language names (which
are, in turn, determined from file extensions). If you want to force files
ending with &quot;.c&quot; to compile as C++, use the <tt class="docutils literal"><span class="pre">-x</span></tt> option, just like you would
do it with <tt class="docutils literal">gcc</tt>:</p>
<pre class="literal-block">
$ # hello.c is really a C++ file
$ llvmc -x c++ hello.c
$ ./a.out
hello
</pre>
<p>On the other hand, when using LLVMC as a linker to combine several C++
object files you should provide the <tt class="docutils literal"><span class="pre">--linker</span></tt> option since it's
impossible for LLVMC to choose the right linker in that case:</p>
<pre class="literal-block">
$ llvmc -c hello.cpp
$ llvmc hello.o
[A lot of link-time errors skipped]
$ llvmc --linker=c++ hello.o
$ ./a.out
hello
</pre>
<p>By default, LLVMC uses <tt class="docutils literal"><span class="pre">llvm-gcc</span></tt> to compile the source code. It is also
possible to choose the <tt class="docutils literal">clang</tt> compiler with the <tt class="docutils literal"><span class="pre">-clang</span></tt> option.</p>
</div>
<div class="section" id="predefined-options">
<h1><a class="toc-backref" href="#id9">Predefined options</a></h1>
<p>LLVMC has some built-in options that can't be overridden in the TableGen code:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">-o</span> FILE</tt> - Output file name.</li>
<li><tt class="docutils literal"><span class="pre">-x</span> LANGUAGE</tt> - Specify the language of the following input files
until the next -x option.</li>
<li><tt class="docutils literal"><span class="pre">-v</span></tt> - Enable verbose mode, i.e. print out all executed commands.</li>
<li><tt class="docutils literal"><span class="pre">--save-temps</span></tt> - Write temporary files to the current directory and do not
delete them on exit. This option can also take an argument: the
<tt class="docutils literal"><span class="pre">--save-temps=obj</span></tt> switch will write files into the directory specified with
the <tt class="docutils literal"><span class="pre">-o</span></tt> option. The <tt class="docutils literal"><span class="pre">--save-temps=cwd</span></tt> and <tt class="docutils literal"><span class="pre">--save-temps</span></tt> switches are
both synonyms for the default behaviour.</li>
<li><tt class="docutils literal"><span class="pre">--temp-dir</span> DIRECTORY</tt> - Store temporary files in the given directory. This
directory is deleted on exit unless <tt class="docutils literal"><span class="pre">--save-temps</span></tt> is specified. If
<tt class="docutils literal"><span class="pre">--save-temps=obj</span></tt> is also specified, <tt class="docutils literal"><span class="pre">--temp-dir</span></tt> is given the
precedence.</li>
<li><tt class="docutils literal"><span class="pre">--check-graph</span></tt> - Check the compilation for common errors like mismatched
output/input language names, multiple default edges and cycles. Exit with code
zero if no errors were found, and return the number of found errors
otherwise. Hidden option, useful for debugging.</li>
<li><tt class="docutils literal"><span class="pre">--view-graph</span></tt> - Show a graphical representation of the compilation graph
and exit. Requires that you have <tt class="docutils literal">dot</tt> and <tt class="docutils literal">gv</tt> programs installed. Hidden
option, useful for debugging.</li>
<li><tt class="docutils literal"><span class="pre">--write-graph</span></tt> - Write a <tt class="docutils literal"><span class="pre">compilation-graph.dot</span></tt> file in the current
directory with the compilation graph description in Graphviz format (identical
to the file used by the <tt class="docutils literal"><span class="pre">--view-graph</span></tt> option). The <tt class="docutils literal"><span class="pre">-o</span></tt> option can be
used to set the output file name. Hidden option, useful for debugging.</li>
<li><tt class="docutils literal"><span class="pre">--help</span></tt>, <tt class="docutils literal"><span class="pre">--help-hidden</span></tt>, <tt class="docutils literal"><span class="pre">--version</span></tt> - These options have
their standard meaning.</li>
</ul>
</div>
<div class="section" id="compiling-llvmc-based-drivers">
<h1><a class="toc-backref" href="#id10">Compiling LLVMC-based drivers</a></h1>
<p>It's easiest to start working on your own LLVMC driver by copying the skeleton
project which lives under <tt class="docutils literal">$LLVMC_DIR/examples/Skeleton</tt>:</p>
<pre class="literal-block">
$ cd $LLVMC_DIR/examples
$ cp -r Skeleton MyDriver
$ cd MyDriver
$ ls
AutoGenerated.td  Hooks.cpp  Main.cpp  Makefile
</pre>
<p>As you can see, our basic driver consists of only three files (not counting the
build script). <tt class="docutils literal">AutoGenerated.td</tt> contains TableGen description of the
compilation graph; its format is documented in the following
sections. <tt class="docutils literal">Hooks.cpp</tt> is an empty file that should be used for hook
definitions (see <a class="reference internal" href="#hooks">below</a>). <tt class="docutils literal">Main.cpp</tt> is just a helper used to compile the
auto-generated C++ code produced from TableGen source.</p>
<p>The first thing that you should do is to change the <tt class="docutils literal">LLVMC_BASED_DRIVER</tt>
variable in the <tt class="docutils literal">Makefile</tt>:</p>
<pre class="literal-block">
LLVMC_BASED_DRIVER=MyDriver
</pre>
<p>It can also be a good idea to put your TableGen code into a file with a less
generic name:</p>
<pre class="literal-block">
$ touch MyDriver.td
$ vim AutoGenerated.td
[...]
include &quot;MyDriver.td&quot;
</pre>
<p>If you have more than one TableGen source file, they all should be included from
<tt class="docutils literal">AutoGenerated.td</tt>, since this file is used by the build system to generate
C++ code.</p>
<p>To build your driver, just <tt class="docutils literal">cd</tt> to its source directory and run <tt class="docutils literal">make</tt>. The
resulting executable will be put into <tt class="docutils literal"><span class="pre">$LLVM_OBJ_DIR/$(BuildMode)/bin</span></tt>.</p>
<p>If you're compiling LLVM with different source and object directories, then you
must perform the following additional steps before running <tt class="docutils literal">make</tt>:</p>
<pre class="literal-block">
# LLVMC_SRC_DIR = $LLVM_SRC_DIR/tools/llvmc/
# LLVMC_OBJ_DIR = $LLVM_OBJ_DIR/tools/llvmc/
$ mkdir $LLVMC_OBJ_DIR/examples/MyDriver/
$ cp $LLVMC_SRC_DIR/examples/MyDriver/Makefile \
  $LLVMC_OBJ_DIR/examples/MyDriver/
$ cd $LLVMC_OBJ_DIR/examples/MyDriver
$ make
</pre>
</div>
<div class="section" id="customizing-llvmc-the-compilation-graph">
<h1><a class="toc-backref" href="#id11">Customizing LLVMC: the compilation graph</a></h1>
<p>Each TableGen configuration file should include the common definitions:</p>
<pre class="literal-block">
include &quot;llvm/CompilerDriver/Common.td&quot;
</pre>
<p>Internally, LLVMC stores information about possible source transformations in
form of a graph. Nodes in this graph represent tools, and edges between two
nodes represent a transformation path. A special &quot;root&quot; node is used to mark
entry points for the transformations. LLVMC also assigns a weight to each edge
(more on this later) to choose between several alternative edges.</p>
<p>The definition of the compilation graph (see file <tt class="docutils literal">llvmc/src/Base.td</tt> for an
example) is just a list of edges:</p>
<pre class="literal-block">
def CompilationGraph : CompilationGraph&lt;[
    Edge&lt;&quot;root&quot;, &quot;llvm_gcc_c&quot;&gt;,
    Edge&lt;&quot;root&quot;, &quot;llvm_gcc_assembler&quot;&gt;,
    ...

    Edge&lt;&quot;llvm_gcc_c&quot;, &quot;llc&quot;&gt;,
    Edge&lt;&quot;llvm_gcc_cpp&quot;, &quot;llc&quot;&gt;,
    ...

    OptionalEdge&lt;&quot;llvm_gcc_c&quot;, &quot;opt&quot;, (case (switch_on &quot;opt&quot;),
                                      (inc_weight))&gt;,
    OptionalEdge&lt;&quot;llvm_gcc_cpp&quot;, &quot;opt&quot;, (case (switch_on &quot;opt&quot;),
                                              (inc_weight))&gt;,
    ...

    OptionalEdge&lt;&quot;llvm_gcc_assembler&quot;, &quot;llvm_gcc_cpp_linker&quot;,
        (case (input_languages_contain &quot;c++&quot;), (inc_weight),
              (or (parameter_equals &quot;linker&quot;, &quot;g++&quot;),
                  (parameter_equals &quot;linker&quot;, &quot;c++&quot;)), (inc_weight))&gt;,
    ...

    ]&gt;;
</pre>
<p>As you can see, the edges can be either default or optional, where optional
edges are differentiated by an additional <tt class="docutils literal">case</tt> expression used to calculate
the weight of this edge. Notice also that we refer to tools via their names (as
strings). This makes it possible to add edges to an existing compilation graph
without having to know about all tool definitions used in the graph.</p>
<p>The default edges are assigned a weight of 1, and optional edges get a weight of
0 + 2*N where N is the number of tests that evaluated to true in the <tt class="docutils literal">case</tt>
expression. It is also possible to provide an integer parameter to
<tt class="docutils literal">inc_weight</tt> and <tt class="docutils literal">dec_weight</tt> - in this case, the weight is increased (or
decreased) by the provided value instead of the default 2. Default weight of an
optional edge can be changed by using the <tt class="docutils literal">default</tt> clause of the <tt class="docutils literal">case</tt>
construct.</p>
<p>When passing an input file through the graph, LLVMC picks the edge with the
maximum weight. To avoid ambiguity, there should be only one default edge
between two nodes (with the exception of the root node, which gets a special
treatment - there you are allowed to specify one default edge <em>per language</em>).</p>
<p>When multiple compilation graphs are defined, they are merged together. Multiple
edges with the same end nodes are not allowed (i.e. the graph is not a
multigraph), and will lead to a compile-time error.</p>
<p>To get a visual representation of the compilation graph (useful for debugging),
run <tt class="docutils literal">llvmc <span class="pre">--view-graph</span></tt>. You will need <tt class="docutils literal">dot</tt> and <tt class="docutils literal">gsview</tt> installed for
this to work properly.</p>
</div>
<div class="section" id="describing-options">
<h1><a class="toc-backref" href="#id12">Describing options</a></h1>
<p>Command-line options supported by the driver are defined by using an
<tt class="docutils literal">OptionList</tt>:</p>
<pre class="literal-block">
def Options : OptionList&lt;[
(switch_option &quot;E&quot;, (help &quot;Help string&quot;)),
(alias_option &quot;quiet&quot;, &quot;q&quot;)
...
]&gt;;
</pre>
<p>As you can see, the option list is just a list of DAGs, where each DAG is an
option description consisting of the option name and some properties. More than
one option list can be defined (they are all merged together in the end), which
can be handy if one wants to separate option groups syntactically.</p>
<ul>
<li><p class="first">Possible option types:</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal">switch_option</tt> - a simple boolean switch without arguments, for example
<tt class="docutils literal"><span class="pre">-O2</span></tt> or <tt class="docutils literal"><span class="pre">-time</span></tt>. At most one occurrence is allowed by default.</li>
<li><tt class="docutils literal">parameter_option</tt> - option that takes one argument, for example
<tt class="docutils literal"><span class="pre">-std=c99</span></tt>. It is also allowed to use spaces instead of the equality
sign: <tt class="docutils literal"><span class="pre">-std</span> c99</tt>. At most one occurrence is allowed.</li>
<li><tt class="docutils literal">parameter_list_option</tt> - same as the above, but more than one option
occurrence is allowed.</li>
<li><tt class="docutils literal">prefix_option</tt> - same as the parameter_option, but the option name and
argument do not have to be separated. Example: <tt class="docutils literal"><span class="pre">-ofile</span></tt>. This can be also
specified as <tt class="docutils literal"><span class="pre">-o</span> file</tt>; however, <tt class="docutils literal"><span class="pre">-o=file</span></tt> will be parsed incorrectly
(<tt class="docutils literal">=file</tt> will be interpreted as option value). At most one occurrence is
allowed.</li>
<li><tt class="docutils literal">prefix_list_option</tt> - same as the above, but more than one occurrence of
the option is allowed; example: <tt class="docutils literal"><span class="pre">-lm</span> <span class="pre">-lpthread</span></tt>.</li>
<li><tt class="docutils literal">alias_option</tt> - a special option type for creating aliases. Unlike other
option types, aliases are not allowed to have any properties besides the
aliased option name.
Usage example: <tt class="docutils literal">(alias_option &quot;preprocess&quot;, &quot;E&quot;)</tt></li>
<li><tt class="docutils literal">switch_list_option</tt> - like <tt class="docutils literal">switch_option</tt> with the <tt class="docutils literal">zero_or_more</tt>
property, but remembers how many times the switch was turned on. Useful
mostly for forwarding. Example: when <tt class="docutils literal"><span class="pre">-foo</span></tt> is a switch option (with the
<tt class="docutils literal">zero_or_more</tt> property), the command <tt class="docutils literal">driver <span class="pre">-foo</span> <span class="pre">-foo</span></tt> is forwarded
as <tt class="docutils literal"><span class="pre">some-tool</span> <span class="pre">-foo</span></tt>, but when <tt class="docutils literal"><span class="pre">-foo</span></tt> is a switch list, the same command
is forwarded as <tt class="docutils literal"><span class="pre">some-tool</span> <span class="pre">-foo</span> <span class="pre">-foo</span></tt>.</li>
</ul>
</blockquote>
</li>
<li><p class="first">Possible option properties:</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal">help</tt> - help string associated with this option. Used for <tt class="docutils literal"><span class="pre">--help</span></tt>
output.</li>
<li><tt class="docutils literal">required</tt> - this option must be specified exactly once (or, in case of
the list options without the <tt class="docutils literal">multi_val</tt> property, at least
once). Incompatible with <tt class="docutils literal">optional</tt> and <tt class="docutils literal">one_or_more</tt>.</li>
<li><tt class="docutils literal">optional</tt> - the option can be specified either zero times or exactly
once. The default for switch options. Useful only for list options in
conjunction with <tt class="docutils literal">multi_val</tt>. Incompatible with <tt class="docutils literal">required</tt>,
<tt class="docutils literal">zero_or_more</tt> and <tt class="docutils literal">one_or_more</tt>.</li>
<li><tt class="docutils literal">one_or_more</tt> - the option must be specified at least once. Can be useful
to allow switch options be both obligatory and be specified multiple
times. For list options is useful only in conjunction with <tt class="docutils literal">multi_val</tt>;
for ordinary it is synonymous with <tt class="docutils literal">required</tt>. Incompatible with
<tt class="docutils literal">required</tt>, <tt class="docutils literal">optional</tt> and <tt class="docutils literal">zero_or_more</tt>.</li>
<li><tt class="docutils literal">zero_or_more</tt> - the option can be specified zero or more times. Useful
to allow a single switch option to be specified more than
once. Incompatible with <tt class="docutils literal">required</tt>, <tt class="docutils literal">optional</tt> and <tt class="docutils literal">one_or_more</tt>.</li>
<li><tt class="docutils literal">hidden</tt> - the description of this option will not appear in
the <tt class="docutils literal"><span class="pre">--help</span></tt> output (but will appear in the <tt class="docutils literal"><span class="pre">--help-hidden</span></tt>
output).</li>
<li><tt class="docutils literal">really_hidden</tt> - the option will not be mentioned in any help
output.</li>
<li><tt class="docutils literal">comma_separated</tt> - Indicates that any commas specified for an option's
value should be used to split the value up into multiple values for the
option. This property is valid only for list options. In conjunction with
<tt class="docutils literal">forward_value</tt> can be used to implement option forwarding in style of
gcc's <tt class="docutils literal"><span class="pre">-Wa,</span></tt>.</li>
<li><tt class="docutils literal">multi_val n</tt> - this option takes <em>n</em> arguments (can be useful in some
special cases). Usage example: <tt class="docutils literal">(parameter_list_option &quot;foo&quot;, (multi_val
3))</tt>; the command-line syntax is '-foo a b c'. Only list options can have
this attribute; you can, however, use the <tt class="docutils literal">one_or_more</tt>, <tt class="docutils literal">optional</tt>
and <tt class="docutils literal">required</tt> properties.</li>
<li><tt class="docutils literal">init</tt> - this option has a default value, either a string (if it is a
parameter), or a boolean (if it is a switch; as in C++, boolean constants
are called <tt class="docutils literal">true</tt> and <tt class="docutils literal">false</tt>). List options can't have <tt class="docutils literal">init</tt>
attribute.
Usage examples: <tt class="docutils literal">(switch_option &quot;foo&quot;, (init true))</tt>; <tt class="docutils literal">(prefix_option
&quot;bar&quot;, (init <span class="pre">&quot;baz&quot;))</span></tt>.</li>
</ul>
</blockquote>
</li>
</ul>
</div>
<div class="section" id="conditional-evaluation">
<span id="case"></span><h1><a class="toc-backref" href="#id13">Conditional evaluation</a></h1>
<p>The 'case' construct is the main means by which programmability is achieved in
LLVMC. It can be used to calculate edge weights, program actions and modify the
shell commands to be executed. The 'case' expression is designed after the
similarly-named construct in functional languages and takes the form <tt class="docutils literal">(case
(test_1), statement_1, (test_2), statement_2, ... (test_N), statement_N)</tt>. The
statements are evaluated only if the corresponding tests evaluate to true.</p>
<p>Examples:</p>
<pre class="literal-block">
// Edge weight calculation

// Increases edge weight by 5 if &quot;-A&quot; is provided on the
// command-line, and by 5 more if &quot;-B&quot; is also provided.
(case
    (switch_on &quot;A&quot;), (inc_weight 5),
    (switch_on &quot;B&quot;), (inc_weight 5))


// Tool command line specification

// Evaluates to &quot;cmdline1&quot; if the option &quot;-A&quot; is provided on the
// command line; to &quot;cmdline2&quot; if &quot;-B&quot; is provided;
// otherwise to &quot;cmdline3&quot;.

(case
    (switch_on &quot;A&quot;), &quot;cmdline1&quot;,
    (switch_on &quot;B&quot;), &quot;cmdline2&quot;,
    (default), &quot;cmdline3&quot;)
</pre>
<p>Note the slight difference in 'case' expression handling in contexts of edge
weights and command line specification - in the second example the value of the
<tt class="docutils literal">&quot;B&quot;</tt> switch is never checked when switch <tt class="docutils literal">&quot;A&quot;</tt> is enabled, and the whole
expression always evaluates to <tt class="docutils literal">&quot;cmdline1&quot;</tt> in that case.</p>
<p>Case expressions can also be nested, i.e. the following is legal:</p>
<pre class="literal-block">
(case (switch_on &quot;E&quot;), (case (switch_on &quot;o&quot;), ..., (default), ...)
      (default), ...)
</pre>
<p>You should, however, try to avoid doing that because it hurts readability. It is
usually better to split tool descriptions and/or use TableGen inheritance
instead.</p>
<ul class="simple">
<li>Possible tests are:<ul>
<li><tt class="docutils literal">switch_on</tt> - Returns true if a given command-line switch is provided by
the user. Can be given multiple arguments, in that case <tt class="docutils literal">(switch_on &quot;foo&quot;,
&quot;bar&quot;, &quot;baz&quot;)</tt> is equivalent to <tt class="docutils literal">(and (switch_on <span class="pre">&quot;foo&quot;),</span> (switch_on
<span class="pre">&quot;bar&quot;),</span> (switch_on <span class="pre">&quot;baz&quot;))</span></tt>.
Example: <tt class="docutils literal">(switch_on &quot;opt&quot;)</tt>.</li>
<li><tt class="docutils literal">any_switch_on</tt> - Given a number of switch options, returns true if any of
the switches is turned on.
Example: <tt class="docutils literal">(any_switch_on &quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;)</tt> is equivalent to <tt class="docutils literal">(or
(switch_on <span class="pre">&quot;foo&quot;),</span> (switch_on <span class="pre">&quot;bar&quot;),</span> (switch_on <span class="pre">&quot;baz&quot;))</span></tt>.</li>
<li><tt class="docutils literal">parameter_equals</tt> - Returns true if a command-line parameter (first
argument) equals a given value (second argument).
Example: <tt class="docutils literal">(parameter_equals &quot;W&quot;, &quot;all&quot;)</tt>.</li>
<li><tt class="docutils literal">element_in_list</tt> - Returns true if a command-line parameter list (first
argument) contains a given value (second argument).
Example: <tt class="docutils literal">(element_in_list &quot;l&quot;, &quot;pthread&quot;)</tt>.</li>
<li><tt class="docutils literal">input_languages_contain</tt> - Returns true if a given language
belongs to the current input language set.
Example: <tt class="docutils literal">(input_languages_contain <span class="pre">&quot;c++&quot;)</span></tt>.</li>
<li><tt class="docutils literal">in_language</tt> - Evaluates to true if the input file language is equal to
the argument. At the moment works only with <tt class="docutils literal">command</tt> and <tt class="docutils literal">actions</tt> (on
non-join nodes).
Example: <tt class="docutils literal">(in_language <span class="pre">&quot;c++&quot;)</span></tt>.</li>
<li><tt class="docutils literal">not_empty</tt> - Returns true if a given option (which should be either a
parameter or a parameter list) is set by the user. Like <tt class="docutils literal">switch_on</tt>, can
be also given multiple arguments.
Examples: <tt class="docutils literal">(not_empty &quot;o&quot;)</tt>, <tt class="docutils literal">(not_empty &quot;o&quot;, &quot;l&quot;)</tt>.</li>
<li><tt class="docutils literal">any_not_empty</tt> - Returns true if <tt class="docutils literal">not_empty</tt> returns true for any of
the provided options.
Example: <tt class="docutils literal">(any_not_empty &quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;)</tt> is equivalent to <tt class="docutils literal">(or
(not_empty <span class="pre">&quot;foo&quot;),</span> (not_empty <span class="pre">&quot;bar&quot;),</span> (not_empty <span class="pre">&quot;baz&quot;))</span></tt>.</li>
<li><tt class="docutils literal">empty</tt> - The opposite of <tt class="docutils literal">not_empty</tt>. Equivalent to <tt class="docutils literal">(not (not_empty
X))</tt>. Can be given multiple arguments.</li>
<li><tt class="docutils literal">any_not_empty</tt> - Returns true if <tt class="docutils literal">not_empty</tt> returns true for any of
the provided options.
Example: <tt class="docutils literal">(any_empty &quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;)</tt> is equivalent to <tt class="docutils literal">(or
(not_empty <span class="pre">&quot;foo&quot;),</span> (not_empty <span class="pre">&quot;bar&quot;),</span> (not_empty <span class="pre">&quot;baz&quot;))</span></tt>.</li>
<li><tt class="docutils literal">single_input_file</tt> - Returns true if there was only one input file
provided on the command-line. Used without arguments:
<tt class="docutils literal">(single_input_file)</tt>.</li>
<li><tt class="docutils literal">multiple_input_files</tt> - Equivalent to <tt class="docutils literal">(not (single_input_file))</tt> (the
case of zero input files is considered an error).</li>
<li><tt class="docutils literal">default</tt> - Always evaluates to true. Should always be the last
test in the <tt class="docutils literal">case</tt> expression.</li>
<li><tt class="docutils literal">and</tt> - A standard logical combinator that returns true iff all of
its arguments return true. Used like this: <tt class="docutils literal">(and (test1), (test2),
... (testN))</tt>. Nesting of <tt class="docutils literal">and</tt> and <tt class="docutils literal">or</tt> is allowed, but not
encouraged.</li>
<li><tt class="docutils literal">or</tt> - A logical combinator that returns true iff any of its arguments
return true.
Example: <tt class="docutils literal">(or (test1), (test2), ... (testN))</tt>.</li>
<li><tt class="docutils literal">not</tt> - Standard unary logical combinator that negates its
argument.
Example: <tt class="docutils literal">(not (or (test1), (test2), ... <span class="pre">(testN)))</span></tt>.</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="writing-a-tool-description">
<h1><a class="toc-backref" href="#id14">Writing a tool description</a></h1>
<p>As was said earlier, nodes in the compilation graph represent tools, which are
described separately. A tool definition looks like this (taken from the
<tt class="docutils literal">llvmc/src/Base.td</tt> file):</p>
<pre class="literal-block">
def llvm_gcc_cpp : Tool&lt;[
    (in_language &quot;c++&quot;),
    (out_language &quot;llvm-assembler&quot;),
    (output_suffix &quot;bc&quot;),
    (command &quot;llvm-g++ -c -emit-llvm&quot;),
    (sink)
    ]&gt;;
</pre>
<p>This defines a new tool called <tt class="docutils literal">llvm_gcc_cpp</tt>, which is an alias for
<tt class="docutils literal"><span class="pre">llvm-g++</span></tt>. As you can see, a tool definition is just a list of properties;
most of them should be self-explanatory. The <tt class="docutils literal">sink</tt> property means that this
tool should be passed all command-line options that aren't mentioned in the
option list.</p>
<p>The complete list of all currently implemented tool properties follows.</p>
<ul class="simple">
<li>Possible tool properties:<ul>
<li><tt class="docutils literal">in_language</tt> - input language name. Can be given multiple arguments, in
case the tool supports multiple input languages. Used for typechecking and
mapping file extensions to tools.</li>
<li><tt class="docutils literal">out_language</tt> - output language name. Multiple output languages are
allowed. Used for typechecking the compilation graph.</li>
<li><tt class="docutils literal">output_suffix</tt> - output file suffix. Can also be changed dynamically, see
documentation on <a class="reference internal" href="#actions">actions</a>.</li>
</ul>
</li>
</ul>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal">command</tt> - the actual command used to run the tool. You can use output
redirection with <tt class="docutils literal">&gt;</tt>, hook invocations (<tt class="docutils literal">$CALL</tt>), environment variables
(via <tt class="docutils literal">$ENV</tt>) and the <tt class="docutils literal">case</tt> construct.</li>
<li><tt class="docutils literal">join</tt> - this tool is a &quot;join node&quot; in the graph, i.e. it gets a list of
input files and joins them together. Used for linkers.</li>
<li><tt class="docutils literal">sink</tt> - all command-line options that are not handled by other tools are
passed to this tool.</li>
<li><tt class="docutils literal">actions</tt> - A single big <tt class="docutils literal">case</tt> expression that specifies how this tool
reacts on command-line options (described in more detail <a class="reference internal" href="#actions">below</a>).</li>
</ul>
</blockquote>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal">out_file_option</tt>, <tt class="docutils literal">in_file_option</tt> - Options appended to the
<tt class="docutils literal">command</tt> string to designate output and input files. Default values are
<tt class="docutils literal"><span class="pre">&quot;-o&quot;</span></tt> and <tt class="docutils literal">&quot;&quot;</tt>, respectively.</li>
</ul>
</blockquote>
<div class="section" id="id4">
<span id="actions"></span><h2><a class="toc-backref" href="#id15">Actions</a></h2>
<p>A tool often needs to react to command-line options, and this is precisely what
the <tt class="docutils literal">actions</tt> property is for. The next example illustrates this feature:</p>
<pre class="literal-block">
def llvm_gcc_linker : Tool&lt;[
    (in_language &quot;object-code&quot;),
    (out_language &quot;executable&quot;),
    (output_suffix &quot;out&quot;),
    (command &quot;llvm-gcc&quot;),
    (join),
    (actions (case (not_empty &quot;L&quot;), (forward &quot;L&quot;),
                   (not_empty &quot;l&quot;), (forward &quot;l&quot;),
                   (not_empty &quot;dummy&quot;),
                             [(append_cmd &quot;-dummy1&quot;), (append_cmd &quot;-dummy2&quot;)])
    ]&gt;;
</pre>
<p>The <tt class="docutils literal">actions</tt> tool property is implemented on top of the omnipresent <tt class="docutils literal">case</tt>
expression. It associates one or more different <em>actions</em> with given
conditions - in the example, the actions are <tt class="docutils literal">forward</tt>, which forwards a given
option unchanged, and <tt class="docutils literal">append_cmd</tt>, which appends a given string to the tool
execution command. Multiple actions can be associated with a single condition by
using a list of actions (used in the example to append some dummy options). The
same <tt class="docutils literal">case</tt> construct can also be used in the <tt class="docutils literal">cmd_line</tt> property to modify
the tool command line.</p>
<p>The &quot;join&quot; property used in the example means that this tool behaves like a
linker.</p>
<p>The list of all possible actions follows.</p>
<ul>
<li><p class="first">Possible actions:</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal">append_cmd</tt> - Append a string to the tool invocation command.
Example: <tt class="docutils literal">(case (switch_on <span class="pre">&quot;pthread&quot;),</span> (append_cmd <span class="pre">&quot;-lpthread&quot;))</span></tt>.</li>
<li><tt class="docutils literal">error</tt> - Exit with error.
Example: <tt class="docutils literal">(error &quot;Mixing <span class="pre">-c</span> and <span class="pre">-S</span> is not <span class="pre">allowed!&quot;)</span></tt>.</li>
<li><tt class="docutils literal">warning</tt> - Print a warning.
Example: <tt class="docutils literal">(warning &quot;Specifying both <span class="pre">-O1</span> and <span class="pre">-O2</span> is <span class="pre">meaningless!&quot;)</span></tt>.</li>
<li><tt class="docutils literal">forward</tt> - Forward the option unchanged.
Example: <tt class="docutils literal">(forward &quot;Wall&quot;)</tt>.</li>
<li><tt class="docutils literal">forward_as</tt> - Change the option's name, but forward the argument
unchanged.
Example: <tt class="docutils literal">(forward_as &quot;O0&quot;, <span class="pre">&quot;--disable-optimization&quot;)</span></tt>.</li>
<li><tt class="docutils literal">forward_value</tt> - Forward only option's value. Cannot be used with switch
options (since they don't have values), but works fine with lists.
Example: <tt class="docutils literal">(forward_value <span class="pre">&quot;Wa,&quot;)</span></tt>.</li>
<li><tt class="docutils literal">forward_transformed_value</tt> - As above, but applies a hook to the
option's value before forwarding (see <a class="reference internal" href="#hooks">below</a>). When
<tt class="docutils literal">forward_transformed_value</tt> is applied to a list
option, the hook must have signature
<tt class="docutils literal"><span class="pre">std::string</span> <span class="pre">hooks::HookName</span> (const <span class="pre">std::vector&lt;std::string&gt;&amp;)</span></tt>.
Example: <tt class="docutils literal">(forward_transformed_value &quot;m&quot;, &quot;ConvertToMAttr&quot;)</tt>.</li>
<li><tt class="docutils literal">output_suffix</tt> - Modify the output suffix of this tool.
Example: <tt class="docutils literal">(output_suffix &quot;i&quot;)</tt>.</li>
<li><tt class="docutils literal">stop_compilation</tt> - Stop compilation after this tool processes its
input. Used without arguments.
Example: <tt class="docutils literal">(stop_compilation)</tt>.</li>
</ul>
</blockquote>
</li>
</ul>
</div>
</div>
<div class="section" id="language-map">
<h1><a class="toc-backref" href="#id16">Language map</a></h1>
<p>If you are adding support for a new language to LLVMC, you'll need to modify the
language map, which defines mappings from file extensions to language names. It
is used to choose the proper toolchain(s) for a given input file set. Language
map definition looks like this:</p>
<pre class="literal-block">
def LanguageMap : LanguageMap&lt;
    [LangToSuffixes&lt;&quot;c++&quot;, [&quot;cc&quot;, &quot;cp&quot;, &quot;cxx&quot;, &quot;cpp&quot;, &quot;CPP&quot;, &quot;c++&quot;, &quot;C&quot;]&gt;,
     LangToSuffixes&lt;&quot;c&quot;, [&quot;c&quot;]&gt;,
     ...
    ]&gt;;
</pre>
<p>For example, without those definitions the following command wouldn't work:</p>
<pre class="literal-block">
$ llvmc hello.cpp
llvmc: Unknown suffix: cpp
</pre>
<p>The language map entries are needed only for the tools that are linked from the
root node. A tool can have multiple output languages.</p>
</div>
<div class="section" id="option-preprocessor">
<h1><a class="toc-backref" href="#id17">Option preprocessor</a></h1>
<p>It is sometimes useful to run error-checking code before processing the
compilation graph. For example, if optimization options &quot;-O1&quot; and &quot;-O2&quot; are
implemented as switches, we might want to output a warning if the user invokes
the driver with both of these options enabled.</p>
<p>The <tt class="docutils literal">OptionPreprocessor</tt> feature is reserved specially for these
occasions. Example (adapted from <tt class="docutils literal">llvm/src/Base.td.in</tt>):</p>
<pre class="literal-block">
def Preprocess : OptionPreprocessor&lt;
(case (not (any_switch_on &quot;O0&quot;, &quot;O1&quot;, &quot;O2&quot;, &quot;O3&quot;)),
           (set_option &quot;O2&quot;),
      (and (switch_on &quot;O3&quot;), (any_switch_on &quot;O0&quot;, &quot;O1&quot;, &quot;O2&quot;)),
           (unset_option &quot;O0&quot;, &quot;O1&quot;, &quot;O2&quot;),
      (and (switch_on &quot;O2&quot;), (any_switch_on &quot;O0&quot;, &quot;O1&quot;)),
           (unset_option &quot;O0&quot;, &quot;O1&quot;),
      (and (switch_on &quot;O1&quot;), (switch_on &quot;O0&quot;)),
           (unset_option &quot;O0&quot;))
&gt;;
</pre>
<p>Here, <tt class="docutils literal">OptionPreprocessor</tt> is used to unset all spurious <tt class="docutils literal"><span class="pre">-O</span></tt> options so
that they are not forwarded to the compiler. If no optimization options are
specified, <tt class="docutils literal"><span class="pre">-O2</span></tt> is enabled.</p>
<p><tt class="docutils literal">OptionPreprocessor</tt> is basically a single big <tt class="docutils literal">case</tt> expression, which is
evaluated only once right after the driver is started. The only allowed actions
in <tt class="docutils literal">OptionPreprocessor</tt> are <tt class="docutils literal">error</tt>, <tt class="docutils literal">warning</tt>, and two special actions:
<tt class="docutils literal">unset_option</tt> and <tt class="docutils literal">set_option</tt>. As their names suggest, they can be used to
set or unset a given option. To set an option with <tt class="docutils literal">set_option</tt>, use the
two-argument form: <tt class="docutils literal">(set_option &quot;parameter&quot;, VALUE)</tt>. Here, <tt class="docutils literal">VALUE</tt> can be
either a string, a string list, or a boolean constant.</p>
<p>For convenience, <tt class="docutils literal">set_option</tt> and <tt class="docutils literal">unset_option</tt> also work with multiple
arguments. That is, instead of <tt class="docutils literal">[(unset_option <span class="pre">&quot;A&quot;),</span> (unset_option <span class="pre">&quot;B&quot;)]</span></tt> you
can use <tt class="docutils literal">(unset_option &quot;A&quot;, &quot;B&quot;)</tt>. Obviously, <tt class="docutils literal">(set_option &quot;A&quot;, &quot;B&quot;)</tt> is
only valid if both <tt class="docutils literal">A</tt> and <tt class="docutils literal">B</tt> are switches.</p>
</div>
<div class="section" id="more-advanced-topics">
<h1><a class="toc-backref" href="#id18">More advanced topics</a></h1>
<div class="section" id="hooks-and-environment-variables">
<span id="hooks"></span><h2><a class="toc-backref" href="#id19">Hooks and environment variables</a></h2>
<p>Normally, LLVMC searches for programs in the system <tt class="docutils literal">PATH</tt>. Sometimes, this is
not sufficient: for example, we may want to specify tool paths or names in the
configuration file. This can be achieved via the hooks mechanism. To write your
own hooks, add their definitions to the <tt class="docutils literal">Hooks.cpp</tt> or drop a <tt class="docutils literal">.cpp</tt> file
into your driver directory. Hooks should live in the <tt class="docutils literal">hooks</tt> namespace and
have the signature <tt class="docutils literal"><span class="pre">std::string</span> <span class="pre">hooks::MyHookName</span> ([const char* Arg0 [ const
char* Arg2 [, <span class="pre">...]]])</span></tt>. They can be used from the <tt class="docutils literal">command</tt> tool property:</p>
<pre class="literal-block">
(command &quot;$CALL(MyHook)/path/to/file -o $CALL(AnotherHook)&quot;)
</pre>
<p>To pass arguments to hooks, use the following syntax:</p>
<pre class="literal-block">
(command &quot;$CALL(MyHook, 'Arg1', 'Arg2', 'Arg # 3')/path/to/file -o1 -o2&quot;)
</pre>
<p>It is also possible to use environment variables in the same manner:</p>
<pre class="literal-block">
(command &quot;$ENV(VAR1)/path/to/file -o $ENV(VAR2)&quot;)
</pre>
<p>To change the command line string based on user-provided options use
the <tt class="docutils literal">case</tt> expression (documented <a class="reference internal" href="#case">above</a>):</p>
<pre class="literal-block">
(command
  (case
    (switch_on &quot;E&quot;),
       &quot;llvm-g++ -E -x c $INFILE -o $OUTFILE&quot;,
    (default),
       &quot;llvm-g++ -c -x c $INFILE -o $OUTFILE -emit-llvm&quot;))
</pre>
</div>
<div class="section" id="debugging">
<h2><a class="toc-backref" href="#id20">Debugging</a></h2>
<p>When writing LLVMC-based drivers, it can be useful to get a visual view of the
resulting compilation graph. This can be achieved via the command line option
<tt class="docutils literal"><span class="pre">--view-graph</span></tt> (which assumes that <a class="reference external" href="http://www.graphviz.org/">Graphviz</a> and <a class="reference external" href="http://pages.cs.wisc.edu/~ghost/">Ghostview</a> are
installed). There is also a <tt class="docutils literal"><span class="pre">--write-graph</span></tt> option that creates a Graphviz
source file (<tt class="docutils literal"><span class="pre">compilation-graph.dot</span></tt>) in the current directory.</p>
<p>Another useful <tt class="docutils literal">llvmc</tt> option is <tt class="docutils literal"><span class="pre">--check-graph</span></tt>. It checks the compilation
graph for common errors like mismatched output/input language names, multiple
default edges and cycles. When invoked with <tt class="docutils literal"><span class="pre">--check-graph</span></tt>, <tt class="docutils literal">llvmc</tt> doesn't
perform any compilation tasks and returns the number of encountered errors as
its status code. In the future, these checks will be performed at compile-time
and this option will disappear.</p>
</div>
<div class="section" id="conditioning-on-the-executable-name">
<h2><a class="toc-backref" href="#id21">Conditioning on the executable name</a></h2>
<p>For now, the executable name (the value passed to the driver in <tt class="docutils literal">argv[0]</tt>) is
accessible only in the C++ code (i.e. hooks). Use the following code:</p>
<pre class="literal-block">
namespace llvmc {
extern const char* ProgramName;
}

namespace hooks {

std::string MyHook() {
//...
if (strcmp(ProgramName, &quot;mydriver&quot;) == 0) {
   //...

}

} // end namespace hooks
</pre>
<p>In general, you're encouraged not to make the behaviour dependent on the
executable file name, and use command-line switches instead. See for example how
the <tt class="docutils literal">llvmc</tt> program behaves when it needs to choose the correct linker options
(think <tt class="docutils literal">g++</tt> vs. <tt class="docutils literal">gcc</tt>).</p>
<hr />
<address>
<a href="http://jigsaw.w3.org/css-validator/check/referer">
<img src="http://jigsaw.w3.org/css-validator/images/vcss-blue"
   alt="Valid CSS" /></a>
<a href="http://validator.w3.org/check?uri=referer">
<img src="http://www.w3.org/Icons/valid-xhtml10-blue"
   alt="Valid XHTML 1.0 Transitional"/></a>

<a href="mailto:foldr@codedgers.com">Mikhail Glushenkov</a><br />
<a href="http://llvm.org">LLVM Compiler Infrastructure</a><br />

Last modified: $Date: 2008-12-11 11:34:48 -0600 (Thu, 11 Dec 2008) $
</address></div>
</div>
</div>
</body>
</html>
