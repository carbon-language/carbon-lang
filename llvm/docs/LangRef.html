<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>llvm Assembly Language Reference Manual</title></head>
<body bgcolor=white>

<table width="100%" bgcolor="#330077" border=0 cellpadding=4 cellspacing=0>
<tr><td>&nbsp; <font size=+5 color="#EEEEFF" face="Georgia,Palatino,Times,Roman"><b>llvm Assembly Language Reference Manual</b></font></td>
</tr></table>

<ol>
  <li><a href="#abstract">Abstract</a>
  <li><a href="#introduction">Introduction</a>
  <li><a href="#identifiers">Identifiers</a>
  <li><a href="#typesystem">Type System</a>
    <ol>
      <li><a href="#t_primitive">Primitive Types</a>
	<ol>
          <li><a href="#t_classifications">Type Classifications</a>
        </ol>
      <li><a href="#t_derived">Derived Types</a>
        <ol>
          <li><a href="#t_array"  >Array Type</a>
          <li><a href="#t_function">Function Type</a>
          <li><a href="#t_pointer">Pointer Type</a>
          <li><a href="#t_struct" >Structure Type</a>
          <li><a href="#t_packed" >Packed Type</a>
        </ol>
    </ol>
  <li><a href="#highlevel">High Level Structure</a>
    <ol>
      <li><a href="#modulestructure">Module Structure</a>
      <li><a href="#functionstructure">Function Structure</a>
    </ol>
  <li><a href="#instref">Instruction Reference</a>
    <ol>
      <li><a href="#terminators">Terminator Instructions</a>
        <ol>
          <li><a href="#i_ret"   >'<tt>ret</tt>' Instruction</a>
          <li><a href="#i_br"    >'<tt>br</tt>' Instruction</a>
          <li><a href="#i_switch">'<tt>switch</tt>' Instruction</a>
          <li><a href="#i_invoke">'<tt>invoke</tt>' Instruction</a>
        </ol>
      <li><a href="#unaryops">Unary Operations</a>
        <ol>
          <li><a href="#i_not" >'<tt>not</tt>' Instruction</a>
        </ol>
      <li><a href="#binaryops">Binary Operations</a>
        <ol>
          <li><a href="#i_add"  >'<tt>add</tt>' Instruction</a>
          <li><a href="#i_sub"  >'<tt>sub</tt>' Instruction</a>
          <li><a href="#i_mul"  >'<tt>mul</tt>' Instruction</a>
          <li><a href="#i_div"  >'<tt>div</tt>' Instruction</a>
          <li><a href="#i_rem"  >'<tt>rem</tt>' Instruction</a>
          <li><a href="#i_setcc">'<tt>set<i>cc</i></tt>' Instructions</a>
        </ol>
      <li><a href="#bitwiseops">Bitwise Binary Operations</a>
        <ol>
          <li><a href="#i_and">'<tt>and</tt>' Instruction</a>
          <li><a href="#i_or" >'<tt>or</tt>'  Instruction</a>
          <li><a href="#i_xor">'<tt>xor</tt>' Instruction</a>
          <li><a href="#i_shl">'<tt>shl</tt>' Instruction</a>
          <li><a href="#i_shr">'<tt>shr</tt>' Instruction</a>
        </ol>
      <li><a href="#memoryops">Memory Access Operations</a>
        <ol>
          <li><a href="#i_malloc"  >'<tt>malloc</tt>'   Instruction</a>
          <li><a href="#i_free"    >'<tt>free</tt>'     Instruction</a>
          <li><a href="#i_alloca"  >'<tt>alloca</tt>'   Instruction</a>
	  <li><a href="#i_getelementptr">'<tt>getelementptr</tt>' Instruction</a>
	  <li><a href="#i_load"    >'<tt>load</tt>'     Instruction</a>
	  <li><a href="#i_store"   >'<tt>store</tt>'    Instruction</a>
        </ol>
      <li><a href="#otherops">Other Operations</a>
        <ol>
          <li><a href="#i_cast">'<tt>cast .. to</tt>' Instruction</a>
          <li><a href="#i_call" >'<tt>call</tt>'  Instruction</a>
          <li><a href="#i_icall">'<tt>icall</tt>' Instruction</a>
          <li><a href="#i_phi"  >'<tt>phi</tt>'   Instruction</a>
        </ol>
      <li><a href="#builtinfunc">Builtin Functions</a>
    </ol>
  <li><a href="#todo">TODO List</a>
    <ol>
      <li><a href="#exception">Exception Handling Instructions</a>
      <li><a href="#synchronization">Synchronization Instructions</a>
    </ol>
  <li><a href="#extensions">Possible Extensions</a>
    <ol>
      <li><a href="#i_tailcall">'<tt>tailcall</tt>' Instruction</a>
      <li><a href="#globalvars">Global Variables</a>
      <li><a href="#explicitparrellelism">Explicit Parrellelism</a>
    </ol>
  <li><a href="#related">Related Work</a>
</ol>


<!-- *********************************************************************** -->
<p><table width="100%" bgcolor="#330077" border=0 cellpadding=4 cellspacing=0><tr><td align=center><font color="#EEEEFF" size=+2 face="Georgia,Palatino"><b>
<a name="abstract">Abstract
</b></font></td></tr></table><ul>
<!-- *********************************************************************** -->

<blockquote>
  This document describes the LLVM assembly language.  LLVM is an SSA based
  representation that is a useful midlevel IR, providing type safety, low level
  operations, flexibility, and the capability to represent 'all' high level
  languages cleanly.
</blockquote>




<!-- *********************************************************************** -->
</ul><table width="100%" bgcolor="#330077" border=0 cellpadding=4 cellspacing=0><tr><td align=center><font color="#EEEEFF" size=+2 face="Georgia,Palatino"><b>
<a name="introduction">Introduction
</b></font></td></tr></table><ul>
<!-- *********************************************************************** -->

The LLVM code representation is designed to be used in three different forms: as
an in-memory compiler IR, as an on-disk bytecode representation, suitable for
fast loading by a dynamic compiler, and as a human readable assembly language
representation.  This allows LLVM to provide a powerful intermediate
representation for efficient compiler transformations and analysis, while
providing a natural means to debug and visualize the transformations.  The three
different forms of LLVM are all equivalent.  This document describes the human
readable representation and notation.<p>

The LLVM representation aims to be a light weight and low level while being
expressive, type safe, and extensible at the same time.  It aims to be a
"universal IR" of sorts, by being at a low enough level that high level ideas
may be cleanly mapped to it (similar to how microprocessors are "universal
IR's", allowing many source languages to be mapped to them).  By providing type
safety, LLVM can be used as the target of optimizations: for example, through
pointer analysis, it can be proven that a C automatic variable is never accessed
outside of the current function... allowing it to be promoted to a simple SSA
value instead of a memory location.<p>

<!-- _______________________________________________________________________ -->
</ul><a name="wellformed"><h4><hr size=0>Well Formedness</h4><ul>

It is important to note that this document describes 'well formed' llvm assembly
language.  There is a difference between what the parser accepts and what is
considered 'well formed'.  For example, the following instruction is
syntactically okay, but not well formed:<p>

<pre>
  %x = <a href="#i_add">add</a> int 1, %x
</pre>

...because only a <tt><a href="#i_phi">phi</a></tt> node may refer to itself.
The LLVM api provides a verification pass (created by the
<tt>createVerifierPass</tt> function) that may be used to verify that an LLVM
module is well formed.  This pass is automatically run by the parser after
parsing input assembly, and by the optimizer before it outputs bytecode.  Often,
violations pointed out by the verifier pass indicate bugs in transformation
passes.<p>


Describe the typesetting conventions here. 


<!-- *********************************************************************** -->
</ul><table width="100%" bgcolor="#330077" border=0 cellpadding=4 cellspacing=0><tr><td align=center><font color="#EEEEFF" size=+2 face="Georgia,Palatino"><b>
<a name="identifiers">Identifiers
</b></font></td></tr></table><ul>
<!-- *********************************************************************** -->

LLVM uses three different forms of identifiers, for different purposes:<p>

<ol>
<li>Numeric constants are represented as you would expect: 12, -3 123.421, etc.
<li>Named values are represented as a string of characters with a '%' prefix.  For example, %foo, %DivisionByZero, %a.really.long.identifier.  The actual regular expression used is '<tt>%[a-zA-Z$._][a-zA-Z$._0-9]*</tt>'.
<li>Unnamed values are represented as an unsigned numeric value with a '%' prefix.  For example, %12, %2, %44.
</ol><p>

LLVM requires the values start with a '%' sign for two reasons: Compilers don't
need to worry about name clashes with reserved words, and the set of reserved
words may be expanded in the future without penalty.  Additionally, unnamed
identifiers allow a compiler to quickly come up with a temporary variable
without having to avoid symbol table conflicts.<p>

Reserved words in LLVM are very similar to reserved words in other languages.
There are keywords for different opcodes ('<tt><a href="#i_add">add</a></tt>',
'<tt><a href="#i_cast">cast</a></tt>', '<tt><a href="#i_ret">ret</a></tt>',
etc...), for primitive type names ('<tt><a href="#t_void">void</a></tt>',
'<tt><a href="#t_uint">uint</a></tt>', etc...), and others.  These reserved
words cannot conflict with variable names, because none of them start with a '%'
character.<p>

Here is an example of LLVM code to multiply the integer variable '<tt>%X</tt>'
by 8:<p>

The easy way:
<pre>
  %result = <a href="#i_mul">mul</a> int %X, 8
</pre>

After strength reduction:
<pre>
  %result = <a href="#i_shl">shl</a> int %X, ubyte 3
</pre>

And the hard way:
<pre>
  <a href="#i_add">add</a> int %X, %X           <i>; yields {int}:%0</i>
  <a href="#i_add">add</a> int %0, %0           <i>; yields {int}:%1</i>
  %result = <a href="#i_add">add</a> int %1, %1
</pre>

This last way of multiplying <tt>%X</tt> by 8 illustrates several important lexical features of LLVM:<p>

<ol>
<li>Comments are delimited with a '<tt>;</tt>' and go until the end of line.
<li>Unnamed temporaries are created when the result of a computation is not
    assigned to a named value.
<li>Unnamed temporaries are numbered sequentially
</ol><p>

...and it also show a convention that we follow in this document.  When
demonstrating instructions, we will follow an instruction with a comment that
defines the type and name of value produced.  Comments are shown in italic
text.<p>



<!-- *********************************************************************** -->
</ul><table width="100%" bgcolor="#330077" border=0 cellpadding=4 cellspacing=0><tr><td align=center><font color="#EEEEFF" size=+2 face="Georgia,Palatino"><b>
<a name="typesystem">Type System
</b></font></td></tr></table><ul>
<!-- *********************************************************************** -->

The LLVM type system is critical to the overall usefulness of the language and
runtime.  Being strongly typed enables a number of optimizations to be performed
on the IR directly, without having to do extra analyses on the side before the
transformation.  A strong type system makes it easier to read the generated code
and enables novel analyses and transformations that are not feasible to perform
on normal three address code representations.<p>

The assembly language form for the type system was heavily influenced by the
type problems in the C language<sup><a href="#rw_stroustrup">1</a></sup>.<p>



<!-- ======================================================================= -->
</ul><table width="100%" bgcolor="#441188" border=0 cellpadding=4 cellspacing=0><tr><td>&nbsp;</td><td width="100%">&nbsp; <font color="#EEEEFF" face="Georgia,Palatino"><b>
<a name="t_primitive">Primitive Types
</b></font></td></tr></table><ul>

The primitive types are the fundemental building blocks of the LLVM system.  The
current set of primitive types are as follows:<p>

<table border=0 align=center><tr><td>

<table border=1 cellspacing=0 cellpadding=4 align=center>
<tr><td><tt>void</tt></td>  <td>No value</td></tr>
<tr><td><tt>ubyte</tt></td> <td>Unsigned 8 bit value</td></tr>
<tr><td><tt>ushort</tt></td><td>Unsigned 16 bit value</td></tr>
<tr><td><tt>uint</tt></td>  <td>Unsigned 32 bit value</td></tr>
<tr><td><tt>ulong</tt></td> <td>Unsigned 64 bit value</td></tr>
<tr><td><tt>float</tt></td> <td>32 bit floating point value</td></tr>
<tr><td><tt>label</tt></td> <td>Branch destination</td></tr>
</table>

</td><td valign=top>

<table border=1 cellspacing=0 cellpadding=4 align=center>
<tr><td><tt>bool</tt></td>  <td>True or False value</td></tr>
<tr><td><tt>sbyte</tt></td> <td>Signed 8 bit value</td></tr>
<tr><td><tt>short</tt></td> <td>Signed 16 bit value</td></tr>
<tr><td><tt>int</tt></td>   <td>Signed 32 bit value</td></tr>
<tr><td><tt>long</tt></td>  <td>Signed 64 bit value</td></tr>
<tr><td><tt>double</tt></td><td>64 bit floating point value</td></tr>
</table>

</td></tr></table><p>



<!-- _______________________________________________________________________ -->
</ul><a name="t_classifications"><h4><hr size=0>Type Classifications</h4><ul>

These different primitive types fall into a few useful classifications:<p>

<table border=1 cellspacing=0 cellpadding=4 align=center>
<tr><td><a name="t_signed">signed</td>    <td><tt>sbyte, short, int, long, float, double</tt></td></tr>
<tr><td><a name="t_unsigned">unsigned</td><td><tt>ubyte, ushort, uint, ulong</tt></td></tr>
<tr><td><a name="t_integral">integral</td><td><tt>ubyte, sbyte, ushort, short, uint, int, ulong, long</tt></td></tr>
<tr><td><a name="t_floating">floating point</td><td><tt>float, double</tt></td></tr>
<tr><td><a name="t_firstclass">first class</td><td><tt>bool, ubyte, sbyte, ushort, short,<br> uint, int, ulong, long, float, double</tt></td></tr>
</table><p>





<!-- ======================================================================= -->
</ul><table width="100%" bgcolor="#441188" border=0 cellpadding=4 cellspacing=0><tr><td>&nbsp;</td><td width="100%">&nbsp; <font color="#EEEEFF" face="Georgia,Palatino"><b>
<a name="t_derived">Derived Types
</b></font></td></tr></table><ul>

The real power in LLVM comes from the derived types in the system.  This is what
allows a programmer to represent arrays, functions, pointers, and other useful
types.  Note that these derived types may be recursive: For example, it is
possible to have a two dimensional array.<p>



<!-- _______________________________________________________________________ -->
</ul><a name="t_array"><h4><hr size=0>Array Type</h4><ul>

<h5>Overview:</h5>

The array type is a very simple derived type that arranges elements sequentially
in memory.  The array type requires a size (number of elements) and an
underlying data type.<p>

<h5>Syntax:</h5>
<pre>
  [&lt;# elements&gt; x &lt;elementtype&gt;]
</pre>

The number of elements is a constant integer value, elementtype may be any time
with a size.<p>

<h5>Examples:</h5>
<ul>
   <tt>[40 x int ]</tt>: Array of 40 integer values.<br>
   <tt>[41 x int ]</tt>: Array of 41 integer values.<br>
   <tt>[40 x uint]</tt>: Array of 40 unsigned integer values.<p>
</ul>

Here are some examples of multidimensional arrays:<p>
<ul>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>[3 x [4 x int]]</tt></td><td>: 3x4 array integer values.</td></tr>
<tr><td><tt>[12 x [10 x float]]</tt></td><td>: 2x10 array of single precision floating point values.</td></tr>
<tr><td><tt>[2 x [3 x [4 x uint]]]</tt></td><td>: 2x3x4 array of unsigned integer values.</td></tr>
</table>
</ul>


<!-- _______________________________________________________________________ -->
</ul><a name="t_function"><h4><hr size=0>Function Type</h4><ul>

<h5>Overview:</h5>

The function type can be thought of as a function signature.  It consists of a
return type and a list of formal parameter types.  Function types are usually
used when to build virtual function tables (which are structures of pointers to
functions), for indirect function calls, and when defining a function.<p>

<h5>Syntax:</h5>
<pre>
  &lt;returntype&gt; (&lt;parameter list&gt;)
</pre>

Where '<tt>&lt;parameter list&gt;</tt>' is a comma seperated list of type
specifiers.  Optionally, the parameter list may include a type <tt>...</tt>,
which indicates that the function takes a variable number of arguments.  Note
that there currently is no way to define a function in LLVM that takes a
variable number of arguments, but it is possible to <b>call</b> a function that
is vararg.<p>

<h5>Examples:</h5>
<ul>
<table border=0 cellpadding=0 cellspacing=0>

<tr><td><tt>int (int)</tt></td><td>: function taking an <tt>int</tt>, returning
an <tt>int</tt></td></tr>

<tr><td><tt>float (int, int *) *</tt></td><td>: <a href="#t_pointer">Pointer</a>
to a function that takes an <tt>int</tt> and a <a href="#t_pointer">pointer</a>
to <tt>int</tt>, returning <tt>float</tt>.</td></tr>

<tr><td><tt>int (sbyte *, ...)</tt></td><td>: A vararg function that takes at
least one <a href="#t_pointer">pointer</a> to <tt>sbyte</tt> (signed char in C),
which returns an integer.  This is the signature for <tt>printf</tt> in
LLVM.</td></tr>

</table>
</ul>



<!-- _______________________________________________________________________ -->
</ul><a name="t_struct"><h4><hr size=0>Structure Type</h4><ul>

<h5>Overview:</h5>

The structure type is used to represent a collection of data members together in memory.  Although the runtime is allowed to lay out the data members any way that it would like, they are guaranteed to be "close" to each other.<p>

Structures are accessed using '<tt><a href="#i_load">load</a></tt> and '<tt><a href="#i_store">store</a></tt>' by getting a pointer to a field with the '<tt><a href="#i_getelementptr">getelementptr</a></tt>' instruction.<p>

<h5>Syntax:</h5>
<pre>
  { &lt;type list&gt; }
</pre>


<h5>Examples:</h5>
<table border=0 cellpadding=0 cellspacing=0>

<tr><td><tt>{ int, int, int }</tt></td><td>: a triple of three <tt>int</tt>
values</td></tr>

<tr><td><tt>{ float, int (int *) * }</tt></td><td>: A pair, where the first
element is a <tt>float</tt> and the second element is a <a
href="#t_pointer">pointer</a> to a <a href="t_function">function</a> that takes
an <tt>int</tt>, returning an <tt>int</tt>.</td></tr>

</table>


<!-- _______________________________________________________________________ -->
</ul><a name="t_pointer"><h4><hr size=0>Pointer Type</h4><ul>

<h5>Overview:</h5>

As in many languages, the pointer type represents a pointer or reference to
another object, which must live in memory.<p>

<h5>Syntax:</h5>
<pre>
  &lt;type&gt; *
</pre>

<h5>Examples:</h5>

<table border=0 cellpadding=0 cellspacing=0>

<tr><td><tt>[4x int]*</tt></td><td>: <a href="#t_pointer">pointer</a> to <a
href="#t_array">array</a> of four <tt>int</tt> values</td></tr>

<tr><td><tt>int (int *) *</tt></td><td>: A <a href="#t_pointer">pointer</a> to a
<a href="t_function">function</a> that takes an <tt>int</tt>, returning an
<tt>int</tt>.</td></tr>

</table>
<p>


<!-- _______________________________________________________________________ -->
<!--
</ul><a name="t_packed"><h4><hr size=0>Packed Type</h4><ul>

Mention/decide that packed types work with saturation or not. Maybe have a packed+saturated type in addition to just a packed type.<p>

Packed types should be 'nonsaturated' because standard data types are not saturated.  Maybe have a saturated packed type?<p>

-->


<!-- *********************************************************************** -->
</ul><table width="100%" bgcolor="#330077" border=0 cellpadding=4 cellspacing=0><tr><td align=center><font color="#EEEEFF" size=+2 face="Georgia,Palatino"><b>
<a name="highlevel">High Level Structure
</b></font></td></tr></table><ul>
<!-- *********************************************************************** -->


<!-- ======================================================================= -->
</ul><table width="100%" bgcolor="#441188" border=0 cellpadding=4 cellspacing=0><tr><td>&nbsp;</td><td width="100%">&nbsp; <font color="#EEEEFF" face="Georgia,Palatino"><b>
<a name="modulestructure">Module Structure
</b></font></td></tr></table><ul>


talk about the elements of a module: constant pool and function list.<p>


<!-- ======================================================================= -->
</ul><table width="100%" bgcolor="#441188" border=0 cellpadding=4 cellspacing=0><tr><td>&nbsp;</td><td width="100%">&nbsp; <font color="#EEEEFF" face="Georgia,Palatino"><b>
<a name="functionstructure">Function Structure
</b></font></td></tr></table><ul>


talk about the optional constant pool<p>
talk about how basic blocks delinate labels<p>
talk about how basic blocks end with terminators<p>


<!-- *********************************************************************** -->
</ul><table width="100%" bgcolor="#330077" border=0 cellpadding=4 cellspacing=0><tr><td align=center><font color="#EEEEFF" size=+2 face="Georgia,Palatino"><b>
<a name="instref">Instruction Reference
</b></font></td></tr></table><ul>
<!-- *********************************************************************** -->

List all of the instructions, list valid types that they accept. Tell what they
do and stuff also.

<!-- ======================================================================= -->
</ul><table width="100%" bgcolor="#441188" border=0 cellpadding=4 cellspacing=0><tr><td>&nbsp;</td><td width="100%">&nbsp; <font color="#EEEEFF" face="Georgia,Palatino"><b>
<a name="terminators">Terminator Instructions
</b></font></td></tr></table><ul>



As was mentioned <a href="#functionstructure">previously</a>, every basic block
in a program ends with a "Terminator" instruction.  All of these terminator
instructions yield a '<tt>void</tt>' value: they produce control flow, not
values.<p>

There are four different terminator instructions: the '<a
href="#i_ret"><tt>ret</tt></a>' instruction, the '<a
href="#i_br"><tt>br</tt></a>' instruction, the '<a
href="#i_switch"><tt>switch</tt></a>' instruction, and the '<a
href="#i_invoke"><tt>invoke</tt></a>' instruction.<p>


<!-- _______________________________________________________________________ -->
</ul><a name="i_ret"><h4><hr size=0>'<tt>ret</tt>' Instruction</h4><ul>

<h5>Syntax:</h5>
<pre>
  ret &lt;type&gt; &lt;value&gt;       <i>; Return a value from a non-void function</i>
  ret void                 <i>; Return from void function</i>
</pre>

<h5>Overview:</h5>

 The '<tt>ret</tt>' instruction is used to return control flow (and optionally a
 value) from a function, back to the caller.<p>

There are two forms of the '<tt>ret</tt>' instructruction: one that returns a
value and then causes control flow, and one that just causes control flow to
occur.<p>

<h5>Arguments:</h5>

The '<tt>ret</tt>' instruction may return any '<a href="#t_firstclass">first
class</a>' type.  Notice that a function is not <a href="#wellformed">well
formed</a> if there exists a '<tt>ret</tt>' instruction inside of the function
that returns a value that does not match the return type of the function.<p>

<h5>Semantics:</h5>

When the '<tt>ret</tt>' instruction is executed, control flow returns back to
the calling function's context.  If the instruction returns a value, that value
shall be propogated into the calling function's data space.<p>

<h5>Example:</h5>
<pre>
  ret int 5                       <i>; Return an integer value of 5</i>
  ret void                        <i>; Return from a void function</i>
</pre>


<!-- _______________________________________________________________________ -->
</ul><a name="i_br"><h4><hr size=0>'<tt>br</tt>' Instruction</h4><ul>

<h5>Syntax:</h5>
<pre>
  br bool &lt;cond&gt;, label &lt;iftrue&gt;, label &lt;iffalse&gt;
  br label &lt;dest&gt;          <i>; Unconditional branch</i>
</pre>

<h5>Overview:</h5>

The '<tt>br</tt>' instruction is used to cause control flow to transfer to a
different basic block in the current function.  There are two forms of this
instruction, corresponding to a conditional branch and an unconditional
branch.<p>

<h5>Arguments:</h5>

The conditional branch form of the '<tt>br</tt>' instruction takes a single
'<tt>bool</tt>' value and two '<tt>label</tt>' values.  The unconditional form
of the '<tt>br</tt>' instruction takes a single '<tt>label</tt>' value as a
target.<p>

<h5>Semantics:</h5>

Upon execution of a conditional '<tt>br</tt>' instruction, the '<tt>bool</tt>'
argument is evaluated.  If the value is <tt>true</tt>, control flows to the
'<tt>iftrue</tt>' '<tt>label</tt>' argument.  If "cond" is <tt>false</tt>,
control flows to the '<tt>iffalse</tt>' '<tt>label</tt>' argument.<p>

<h5>Example:</h5>
<pre>
Test:
  %cond = <a href="#i_setcc">seteq</a> int %a, %b
  br bool %cond, label %IfEqual, label %IfUnequal
IfEqual:
  <a href="#i_ret">ret</a> bool true
IfUnequal:
  <a href="#i_ret">ret</a> bool false
</pre>


<!-- _______________________________________________________________________ -->
</ul><a name="i_switch"><h4><hr size=0>'<tt>switch</tt>' Instruction</h4><ul>

<h5>Syntax:</h5>
<pre>
  <i>; Definitions for lookup indirect branch</i>
  %switchtype = type [&lt;anysize&gt; x { uint, label }]

  <i>; Lookup indirect branch</i>
  switch uint &lt;value&gt;, label &lt;defaultdest&gt;, %switchtype &lt;switchtable&gt;

  <i>; Indexed indirect branch</i>
  switch uint &lt;idxvalue&gt;, label &lt;defaultdest&gt;, [&lt;anysize&gt; x label] &lt;desttable&gt;
</pre>

<h5>Overview:</h5>

The '<tt>switch</tt>' instruction is used to transfer control flow to one of
several different places.  It is a generalization of the '<tt>br</tt>'
instruction, allowing a branch to occur to one of many possible destinations.<p>

The '<tt>switch</tt>' statement supports two different styles of indirect
branching: lookup branching and indexed branching.  Lookup branching is
generally useful if the values to switch on are spread far appart, where index
branching is useful if the values to switch on are generally dense.<p>

The two different forms of the '<tt>switch</tt>' statement are simple hints to
the underlying virtual machine implementation.  For example, a virtual machine
may choose to implement a small indirect branch table as a series of predicated
comparisons: if it is faster for the target architecture.<p>

<h5>Arguments:</h5>

The lookup form of the '<tt>switch</tt>' instruction uses three parameters: a
'<tt>uint</tt>' comparison value '<tt>value</tt>', a default '<tt>label</tt>'
destination, and an array of pairs of comparison value constants and
'<tt>label</tt>'s.  The sized array must be a constant value.<p>

The indexed form of the '<tt>switch</tt>' instruction uses three parameters: an
'<tt>uint</tt>' index value, a default '<tt>label</tt>' and a sized array of
'<tt>label</tt>'s.  The '<tt>dests</tt>' array must be a constant array.

<h5>Semantics:</h5>

The lookup style switch statement specifies a table of values and destinations.
When the '<tt>switch</tt>' instruction is executed, this table is searched for
the given value.  If the value is found, the corresponding destination is
branched to. <p>

The index branch form simply looks up a label element directly in a table and
branches to it.<p>

In either case, the compiler knows the static size of the array, because it is
provided as part of the constant values type.<p>

<h5>Example:</h5>
<pre>
  <i>; Emulate a conditional br instruction</i>
  %Val = <a href="#i_cast">cast</a> bool %value to uint
  switch uint %Val, label %truedest, [1 x label] [label %falsedest ]

  <i>; Emulate an unconditional br instruction</i>
  switch uint 0, label %dest, [ 0 x label] [ ]

  <i>; Implement a jump table using the constant pool:</i>
  void "testmeth"(int %arg0)
    %switchdests = [3 x label] [ label %onzero, label %onone, label %ontwo ]
  begin
  ...
    switch uint %val, label %otherwise, [3 x label] %switchdests...
  ...
  end

  <i>; Implement the equivilent jump table directly:</i>
  switch uint %val, label %otherwise, [3 x label] [ label %onzero, 
                                                    label %onone, 
                                                    label %ontwo ]

</pre>



<!-- _______________________________________________________________________ -->
</ul><a name="i_invoke"><h4><hr size=0>'<tt>invoke</tt>' Instruction</h4><ul>

<h5>Syntax:</h5>
<pre>
  &lt;result&gt; = invoke &lt;ptr to function ty&gt; %&lt;function ptr val&gt;(&lt;function args&gt;)
                 to label &lt;normal label&gt; except label &lt;exception label&gt;
</pre>

<h5>Overview:</h5> The '<tt>invoke</tt>' instruction is used to cause control
flow to transfer to a specified function, with the possibility of control flow
transfer to either the '<tt>normal label</tt>' label or the '<tt>exception
label</tt>'.  The '<tt><a href="#i_call">call</a></tt>' instruction is closely
related, but guarantees that control flow either never returns from the called
function, or that it returns to the instruction succeeding the '<tt><a
href="#i_call">call</a></tt>' instruction.<p>

<h5>Arguments:</h5>

This instruction requires several arguments:<p>
<ol>

<li>'<tt>ptr to function ty</tt>': shall be the signature of the pointer to
function value being invoked.  In most cases, this is a direct method
invocation, but indirect <tt>invoke</tt>'s are just as possible, branching off
an arbitrary pointer to function value.<p>

<li>'<tt>function ptr val</tt>': An LLVM value containing a pointer to a
function to be invoked.

<li>'<tt>function args</tt>': argument list whose types match the function
signature argument types.

<li>'<tt>normal label</tt>': the label reached when the called function executes
a '<tt><a href="#i_ret">ret</a></tt>' instruction.

<li>'<tt>exception label</tt>': the label reached when an exception is thrown.
</ol>

<h5>Semantics:</h5>

This instruction is designed to operate as a standard '<tt><a href="#i_call">call</a></tt>' instruction in most regards.  The primary difference is that it assiciates a label with the function invocation that may be accessed via the runtime library provided by the execution environment.  This instruction is used in languages with destructors to ensure that proper cleanup is performed in the case of either a <tt>longjmp</tt> or a thrown exception.  Additionally, this is important for implementation of '<tt>catch</tt>' clauses in high-level languages that support them.<p>

For a more comprehensive explanation of this instruction look in the llvm/docs/2001-05-18-ExceptionHandling.txt document.<p>

<h5>Example:</h5>
<pre>
  %retval = invoke int %Test(int 15)
              to label %Continue except label %TestCleanup     <i>; {int}:retval set</i>
</pre>



<!-- ======================================================================= -->
</ul><table width="100%" bgcolor="#441188" border=0 cellpadding=4 cellspacing=0><tr><td>&nbsp;</td><td width="100%">&nbsp; <font color="#EEEEFF" face="Georgia,Palatino"><b>
<a name="unaryops">Unary Operations
</b></font></td></tr></table><ul>

Unary operators are used to do a simple operation to a single value.<p>

There is only one unary operator: the '<a href="#i_not"><tt>not</tt></a>' instruction.<p>


<!-- _______________________________________________________________________ -->
</ul><a name="i_not"><h4><hr size=0>'<tt>not</tt>' Instruction</h4><ul>

<h5>Syntax:</h5>
<pre>
  &lt;result&gt; = not &lt;ty&gt; &lt;var&gt;       <i>; yields {ty}:result</i>
</pre>

<h5>Overview:</h5>
The  '<tt>not</tt>' instruction returns the <a href="#logical_integrals">logical</a> inverse of its operand.<p>

<h5>Arguments:</h5>
The single argument to '<tt>not</tt>' must be of of <a href="#t_integral">integral</a> type.<p>


<h5>Semantics:</h5>
The '<tt>not</tt>' instruction returns the <a href="#logical_integrals">logical</a> inverse of an <a href="#t_integral">integral</a> type.<p>

<pre>
  &lt;result&gt; = xor bool true, &lt;var&gt; <i>; yields {bool}:result</i>
</pre>

<h5>Example:</h5>
<pre>
  %x = not int 1                  <i>; {int}:x is now equal to 0</i>
  %x = not bool true              <i>; {bool}:x is now equal to false</i>
</pre>



<!-- ======================================================================= -->
</ul><table width="100%" bgcolor="#441188" border=0 cellpadding=4 cellspacing=0><tr><td>&nbsp;</td><td width="100%">&nbsp; <font color="#EEEEFF" face="Georgia,Palatino"><b>
<a name="binaryops">Binary Operations
</b></font></td></tr></table><ul>

Binary operators are used to do most of the computation in a program.  They
require two operands, execute an operation on them, and produce a single value.
The result value of a binary operator is not neccesarily the same type as its
operands.<p>

There are several different binary operators:<p>


<!-- _______________________________________________________________________ -->
</ul><a name="i_add"><h4><hr size=0>'<tt>add</tt>' Instruction</h4><ul>

<h5>Syntax:</h5>
<pre>
  &lt;result&gt; = add &lt;ty&gt; &lt;var1&gt;, &lt;var2&gt;   <i>; yields {ty}:result</i>
</pre>

<h5>Overview:</h5>
The '<tt>add</tt>' instruction returns the sum of its two operands.<p>

<h5>Arguments:</h5>
The two arguments to the '<tt>add</tt>' instruction must be either <a href="#t_integral">integral</a> or <a href="#t_floating">floating point</a> values.  Both arguments must have identical types.<p>

<h5>Semantics:</h5>
...<p>

<h5>Example:</h5>
<pre>
  &lt;result&gt; = add int 4, %var          <i>; yields {int}:result = 4 + %var</i>
</pre>


<!-- _______________________________________________________________________ -->
</ul><a name="i_sub"><h4><hr size=0>'<tt>sub</tt>' Instruction</h4><ul>

<h5>Syntax:</h5>
<pre>
  &lt;result&gt; = sub &lt;ty&gt; &lt;var1&gt;, &lt;var2&gt;   <i>; yields {ty}:result</i>
</pre>

<h5>Overview:</h5>

The '<tt>sub</tt>' instruction returns the difference of its two operands.<p>

Note that the '<tt>sub</tt>' instruction is used to represent the '<tt>neg</tt>'
instruction present in most other intermediate representations.<p>

<h5>Arguments:</h5>

The two arguments to the '<tt>sub</tt>' instruction must be either <a
href="#t_integral">integral</a> or <a href="#t_floating">floating point</a>
values.  Both arguments must have identical types.<p>

<h5>Semantics:</h5>
...<p>

<h5>Example:</h5>
<pre>
  &lt;result&gt; = sub int 4, %var          <i>; yields {int}:result = 4 - %var</i>
  &lt;result&gt; = sub int 0, %val          <i>; yields {int}:result = -%var</i>
</pre>

<!-- _______________________________________________________________________ -->
</ul><a name="i_mul"><h4><hr size=0>'<tt>mul</tt>' Instruction</h4><ul>

<h5>Syntax:</h5>
<pre>
  &lt;result&gt; = mul &lt;ty&gt; &lt;var1&gt;, &lt;var2&gt;   <i>; yields {ty}:result</i>
</pre>

<h5>Overview:</h5>
The  '<tt>mul</tt>' instruction returns the product of its two operands.<p>

<h5>Arguments:</h5>
The two arguments to the '<tt>mul</tt>' instruction must be either <a href="#t_integral">integral</a> or <a href="#t_floating">floating point</a> values.  Both arguments must have identical types.<p>

<h5>Semantics:</h5>
...<p>

There is no signed vs unsigned multiplication.  The appropriate action is taken
based on the type of the operand. <p>


<h5>Example:</h5>
<pre>
  &lt;result&gt; = mul int 4, %var          <i>; yields {int}:result = 4 * %var</i>
</pre>


<!-- _______________________________________________________________________ -->
</ul><a name="i_div"><h4><hr size=0>'<tt>div</tt>' Instruction</h4><ul>

<h5>Syntax:</h5>
<pre>
  &lt;result&gt; = div &lt;ty&gt; &lt;var1&gt;, &lt;var2&gt;   <i>; yields {ty}:result</i>
</pre>

<h5>Overview:</h5>

The  '<tt>div</tt>' instruction returns the quotient of its two operands.<p>

<h5>Arguments:</h5>

The two arguments to the '<tt>div</tt>' instruction must be either <a
href="#t_integral">integral</a> or <a href="#t_floating">floating point</a>
values.  Both arguments must have identical types.<p>

<h5>Semantics:</h5>
...<p>

<h5>Example:</h5>
<pre>
  &lt;result&gt; = div int 4, %var          <i>; yields {int}:result = 4 / %var</i>
</pre>


<!-- _______________________________________________________________________ -->
</ul><a name="i_rem"><h4><hr size=0>'<tt>rem</tt>' Instruction</h4><ul>

<h5>Syntax:</h5>
<pre>
  &lt;result&gt; = rem &lt;ty&gt; &lt;var1&gt;, &lt;var2&gt;   <i>; yields {ty}:result</i>
</pre>

<h5>Overview:</h5>
The  '<tt>rem</tt>' instruction returns the remainder from the division of its two operands.<p>

<h5>Arguments:</h5>
The two arguments to the '<tt>rem</tt>' instruction must be either <a href="#t_integral">integral</a> or <a href="#t_floating">floating point</a> values.  Both arguments must have identical types.<p>

<h5>Semantics:</h5>
TODO: remainder or modulus?<p>
...<p>

<h5>Example:</h5>
<pre>
  &lt;result&gt; = rem int 4, %var          <i>; yields {int}:result = 4 % %var</i>
</pre>


<!-- _______________________________________________________________________ -->
</ul><a name="i_setcc"><h4><hr size=0>'<tt>set<i>cc</i></tt>' Instructions</h4><ul>

<h5>Syntax:</h5>
<pre>
  &lt;result&gt; = seteq &lt;ty&gt; &lt;var1&gt;, &lt;var2&gt;   <i>; yields {bool}:result</i>
  &lt;result&gt; = setne &lt;ty&gt; &lt;var1&gt;, &lt;var2&gt;   <i>; yields {bool}:result</i>
  &lt;result&gt; = setlt &lt;ty&gt; &lt;var1&gt;, &lt;var2&gt;   <i>; yields {bool}:result</i>
  &lt;result&gt; = setgt &lt;ty&gt; &lt;var1&gt;, &lt;var2&gt;   <i>; yields {bool}:result</i>
  &lt;result&gt; = setle &lt;ty&gt; &lt;var1&gt;, &lt;var2&gt;   <i>; yields {bool}:result</i>
  &lt;result&gt; = setge &lt;ty&gt; &lt;var1&gt;, &lt;var2&gt;   <i>; yields {bool}:result</i>
</pre>

<h5>Overview:</h5>
The '<tt>set<i>cc</i></tt>' family of instructions returns a boolean value based on a comparison of their two operands.<p>

<h5>Arguments:</h5> The two arguments to the '<tt>set<i>cc</i></tt>'
instructions must be of <a href="#t_firstclass">first class</a> or <a
href="#t_pointer">pointer</a> type (it is not possible to compare
'<tt>label</tt>'s, '<tt>array</tt>'s, '<tt>structure</tt>' or '<tt>void</tt>'
values).  Both arguments must have identical types.<p>

The '<tt>setlt</tt>', '<tt>setgt</tt>', '<tt>setle</tt>', and '<tt>setge</tt>' instructions do not operate on '<tt>bool</tt>' typed arguments.<p>

<h5>Semantics:</h5>
The '<tt>seteq</tt>' instruction yields a <tt>true</tt> '<tt>bool</tt>' value if both operands are equal.<br>
The '<tt>setne</tt>' instruction yields a <tt>true</tt> '<tt>bool</tt>' value if both operands are unequal.<br>
The '<tt>setlt</tt>' instruction yields a <tt>true</tt> '<tt>bool</tt>' value if the first operand is less than the second operand.<br>
The '<tt>setgt</tt>' instruction yields a <tt>true</tt> '<tt>bool</tt>' value if the first operand is greater than the second operand.<br>
The '<tt>setle</tt>' instruction yields a <tt>true</tt> '<tt>bool</tt>' value if the first operand is less than or equal to the second operand.<br>
The '<tt>setge</tt>' instruction yields a <tt>true</tt> '<tt>bool</tt>' value if the first operand is greater than or equal to the second operand.<p>

<h5>Example:</h5>
<pre>
  &lt;result&gt; = seteq int   4, 5        <i>; yields {bool}:result = false</i>
  &lt;result&gt; = setne float 4, 5        <i>; yields {bool}:result = true</i>
  &lt;result&gt; = setlt uint  4, 5        <i>; yields {bool}:result = true</i>
  &lt;result&gt; = setgt sbyte 4, 5        <i>; yields {bool}:result = false</i>
  &lt;result&gt; = setle sbyte 4, 5        <i>; yields {bool}:result = true</i>
  &lt;result&gt; = setge sbyte 4, 5        <i>; yields {bool}:result = false</i>
</pre>



<!-- ======================================================================= -->
</ul><table width="100%" bgcolor="#441188" border=0 cellpadding=4 cellspacing=0><tr><td>&nbsp;</td><td width="100%">&nbsp; <font color="#EEEEFF" face="Georgia,Palatino"><b>
<a name="bitwiseops">Bitwise Binary Operations
</b></font></td></tr></table><ul>

Bitwise binary operators are used to do various forms of bit-twiddling in a program.  They are generally very efficient instructions, and can commonly be strength reduced from other instructions.  They require two operands, execute an operation on them, and produce a single value.  The resulting value of the bitwise binary operators is always the same type as its first operand.<p>

<!-- _______________________________________________________________________ -->
</ul><a name="i_and"><h4><hr size=0>'<tt>and</tt>' Instruction</h4><ul>

<h5>Syntax:</h5>
<pre>
  &lt;result&gt; = and &lt;ty&gt; &lt;var1&gt;, &lt;var2&gt;   <i>; yields {ty}:result</i>
</pre>

<h5>Overview:</h5>
The '<tt>and</tt>' instruction returns the bitwise logical and of its two operands.<p>

<h5>Arguments:</h5>
The two arguments to the '<tt>and</tt>' instruction must be either <a href="#t_integral">integral</a> or <a href="#t_bool"><tt>bool</tt></a> values.  Both arguments must have identical types.<p>


<h5>Semantics:</h5>
...<p>


<h5>Example:</h5>
<pre>
  &lt;result&gt; = and int 4, %var         <i>; yields {int}:result = 4 & %var</i>
  &lt;result&gt; = and int 15, 40          <i>; yields {int}:result = 8</i>
  &lt;result&gt; = and int 4, 8            <i>; yields {int}:result = 0</i>
</pre>



<!-- _______________________________________________________________________ -->
</ul><a name="i_or"><h4><hr size=0>'<tt>or</tt>' Instruction</h4><ul>

<h5>Syntax:</h5>
<pre>
  &lt;result&gt; = or &lt;ty&gt; &lt;var1&gt;, &lt;var2&gt;   <i>; yields {ty}:result</i>
</pre>

<h5>Overview:</h5> The '<tt>or</tt>' instruction returns the bitwise logical
inclusive or of its two operands.<p>

<h5>Arguments:</h5>

The two arguments to the '<tt>or</tt>' instruction must be either <a
href="#t_integral">integral</a> or <a href="#t_bool"><tt>bool</tt></a> values.
Both arguments must have identical types.<p>


<h5>Semantics:</h5>
...<p>


<h5>Example:</h5>
<pre>
  &lt;result&gt; = or int 4, %var         <i>; yields {int}:result = 4 | %var</i>
  &lt;result&gt; = or int 15, 40          <i>; yields {int}:result = 47</i>
  &lt;result&gt; = or int 4, 8            <i>; yields {int}:result = 12</i>
</pre>


<!-- _______________________________________________________________________ -->
</ul><a name="i_xor"><h4><hr size=0>'<tt>xor</tt>' Instruction</h4><ul>

<h5>Syntax:</h5>
<pre>
  &lt;result&gt; = xor &lt;ty&gt; &lt;var1&gt;, &lt;var2&gt;   <i>; yields {ty}:result</i>
</pre>

<h5>Overview:</h5>

The '<tt>xor</tt>' instruction returns the bitwise logical exclusive or of its
two operands.<p>

<h5>Arguments:</h5>

The two arguments to the '<tt>xor</tt>' instruction must be either <a
href="#t_integral">integral</a> or <a href="#t_bool"><tt>bool</tt></a> values.
Both arguments must have identical types.<p>


<h5>Semantics:</h5>
...<p>


<h5>Example:</h5>
<pre>
  &lt;result&gt; = xor int 4, %var         <i>; yields {int}:result = 4 ^ %var</i>
  &lt;result&gt; = xor int 15, 40          <i>; yields {int}:result = 39</i>
  &lt;result&gt; = xor int 4, 8            <i>; yields {int}:result = 12</i>
</pre>


<!-- _______________________________________________________________________ -->
</ul><a name="i_shl"><h4><hr size=0>'<tt>shl</tt>' Instruction</h4><ul>

<h5>Syntax:</h5>
<pre>
  &lt;result&gt; = shl &lt;ty&gt; &lt;var1&gt;, ubyte &lt;var2&gt;   <i>; yields {ty}:result</i>
</pre>

<h5>Overview:</h5>

The '<tt>shl</tt>' instruction returns the first operand shifted to the left a
specified number of bits.

<h5>Arguments:</h5>

The first argument to the '<tt>shl</tt>' instruction must be an <a
href="#t_integral">integral</a> type.  The second argument must be an
'<tt>ubyte</tt>' type.<p>

<h5>Semantics:</h5>
... 0 bits are shifted into the emptied bit positions...<p>


<h5>Example:</h5>
<pre>
  &lt;result&gt; = shl int 4, ubyte %var   <i>; yields {int}:result = 4 << %var</i>
  &lt;result&gt; = shl int 4, ubyte 2      <i>; yields {int}:result = 16</i>
  &lt;result&gt; = shl int 1, ubyte 10     <i>; yields {int}:result = 1024</i>
</pre>


<!-- _______________________________________________________________________ -->
</ul><a name="i_shr"><h4><hr size=0>'<tt>shr</tt>' Instruction</h4><ul>


<h5>Syntax:</h5>
<pre>
  &lt;result&gt; = shr &lt;ty&gt; &lt;var1&gt;, ubyte &lt;var2&gt;   <i>; yields {ty}:result</i>
</pre>

<h5>Overview:</h5>
The '<tt>shr</tt>' instruction returns the first operand shifted to the right a specified number of bits.

<h5>Arguments:</h5>
The first argument to the '<tt>shr</tt>' instruction must be an  <a href="#t_integral">integral</a> type.  The second argument must be an '<tt>ubyte</tt>' type.<p>

<h5>Semantics:</h5>
... if the first argument is a <a href="#t_signed">signed</a> type, the most significant bit is duplicated in the newly free'd bit positions.  If the first argument is unsigned, zeros shall fill the empty positions...<p>

<h5>Example:</h5>
<pre>
  &lt;result&gt; = shr int 4, ubyte %var   <i>; yields {int}:result = 4 >> %var</i>
  &lt;result&gt; = shr int 4, ubyte 1      <i>; yields {int}:result = 2</i>
  &lt;result&gt; = shr int 4, ubyte 2      <i>; yields {int}:result = 1</i>
  &lt;result&gt; = shr int 4, ubyte 3      <i>; yields {int}:result = 0</i>
</pre>





<!-- ======================================================================= -->
</ul><table width="100%" bgcolor="#441188" border=0 cellpadding=4 cellspacing=0><tr><td>&nbsp;</td><td width="100%">&nbsp; <font color="#EEEEFF" face="Georgia,Palatino"><b>
<a name="memoryops">Memory Access Operations
</b></font></td></tr></table><ul>

Accessing memory in SSA form is, well, sticky at best.  This section describes how to read and write memory in LLVM.<p>


<!-- _______________________________________________________________________ -->
</ul><a name="i_malloc"><h4><hr size=0>'<tt>malloc</tt>' Instruction</h4><ul>

<h5>Syntax:</h5>
<pre>
  &lt;result&gt; = malloc &lt;type&gt;, uint &lt;NumElements&gt;     <i>; yields {type*}:result</i>
  &lt;result&gt; = malloc &lt;type&gt;                         <i>; yields {type*}:result</i>
</pre>

<h5>Overview:</h5>
The '<tt>malloc</tt>' instruction allocates memory from the system heap and returns a pointer to it.<p>

<h5>Arguments:</h5>

The the '<tt>malloc</tt>' instruction allocates
<tt>sizeof(&lt;type&gt;)*NumElements</tt> bytes of memory from the operating
system, and returns a pointer of the appropriate type to the program.  The
second form of the instruction is a shorter version of the first instruction
that defaults to allocating one element.<p>

'<tt>type</tt>' must be a sized type<p>

<h5>Semantics:</h5>
Memory is allocated, a pointer is returned.<p>

<h5>Example:</h5>
<pre>
  %array  = malloc [4 x ubyte ]                    <i>; yields {[%4 x ubyte]*}:array</i>

  %size   = <a href="#i_add">add</a> uint 2, 2                          <i>; yields {uint}:size = uint 4</i>
  %array1 = malloc ubyte, uint 4                   <i>; yields {ubyte*}:array1</i>
  %array2 = malloc [12 x ubyte], uint %size        <i>; yields {[12 x ubyte]*}:array2</i>
</pre>


<!-- _______________________________________________________________________ -->
</ul><a name="i_free"><h4><hr size=0>'<tt>free</tt>' Instruction</h4><ul>

<h5>Syntax:</h5>
<pre>
  free &lt;type&gt; &lt;value&gt;                              <i>; yields {void}</i>
</pre>


<h5>Overview:</h5>
The '<tt>free</tt>' instruction returns memory back to the unused memory heap, to be reallocated in the future.<p>


<h5>Arguments:</h5>

'<tt>value</tt>' shall be a pointer value that points to a value that was allocated with the '<tt><a href="#i_malloc">malloc</a></tt>' instruction.<p>


<h5>Semantics:</h5>
Memory is available for use after this point.  The contents of the '<tt>value</tt>' pointer are undefined after this instruction.<p>


<h5>Example:</h5>
<pre>
  %array  = <a href="#i_malloc">malloc</a> [4 x ubyte]                    <i>; yields {[4 x ubyte]*}:array</i>
            free   [4 x ubyte]* %array
</pre>


<!-- _______________________________________________________________________ -->
</ul><a name="i_alloca"><h4><hr size=0>'<tt>alloca</tt>' Instruction</h4><ul>

<h5>Syntax:</h5>
<pre>
  &lt;result&gt; = alloca &lt;type&gt;, uint &lt;NumElements&gt;  <i>; yields {type*}:result</i>
  &lt;result&gt; = alloca &lt;type&gt;                      <i>; yields {type*}:result</i>
</pre>

<h5>Overview:</h5>

The '<tt>alloca</tt>' instruction allocates memory on the current stack frame of
the procedure that is live until the current function returns to its caller.<p>

<h5>Arguments:</h5>

The the '<tt>alloca</tt>' instruction allocates
<tt>sizeof(&lt;type&gt;)*NumElements</tt> bytes of memory on the runtime stack,
returning a pointer of the appropriate type to the program.  The second form of
the instruction is a shorter version of the first that defaults to allocating
one element.<p>

'<tt>type</tt>' may be any sized type.<p>

<h5>Semantics:</h5>

Memory is allocated, a pointer is returned.  '<tt>alloca</tt>'d memory is
automatically released when the function returns.  The '<tt>alloca</tt>'
instruction is commonly used to represent automatic variables that must have an
address available, as well as spilled variables.<p>

<h5>Example:</h5>
<pre>
  %ptr = alloca int                              <i>; yields {int*}:ptr</i>
  %ptr = alloca int, uint 4                      <i>; yields {int*}:ptr</i>
</pre>


<!-- _______________________________________________________________________ -->
</ul><a name="i_getelementptr"><h4><hr size=0>'<tt>getelementptr</tt>' Instruction</h4><ul>

<h5>Syntax:</h5>
<pre>
  &lt;result&gt; = getelementptr &lt;ty&gt;* &lt;ptrval&gt;{, uint &lt;aidx&gt;|, ubyte &lt;sidx&gt;}*
</pre>

<h5>Overview:</h5>

The '<tt>getelementptr</tt>' instruction is used to get the address of a
subelement of an aggregate data structure.  In addition to being present as an
explicit instruction, the '<tt>getelementptr</tt>' functionality is present in
both the '<tt><a href="#i_load">load</a></tt>' and '<tt><a
href="#i_store">store</a></tt>' instructions to allow more compact specification
of common expressions.<p>

<h5>Arguments:</h5>

This instruction takes a list of <tt>uint</tt> values and <tt>ubyte</tt>
constants that indicate what form of addressing to perform.  The actual types of
the arguments provided depend on the type of the first pointer argument.  The
'<tt>getelementptr</tt>' instruction is used to index down through the type
levels of a structure.<p>

TODO.

<h5>Semantics:</h5>


<h5>Example:</h5>
<pre>
  %aptr = getelementptr {int, [12 x ubyte]}* %sptr, 1   <i>; yields {[12 x ubyte]*}:aptr</i>
  %ub   = load [12x ubyte]* %aptr, 4                    <i>;yields {ubyte}:ub</i>
</pre>



<!-- _______________________________________________________________________ -->
</ul><a name="i_load"><h4><hr size=0>'<tt>load</tt>' Instruction</h4><ul>

<h5>Syntax:</h5>
<pre>
  &lt;result&gt; = load &lt;ty&gt;* &lt;pointer&gt;
  &lt;result&gt; = load &lt;ty&gt;* &lt;pointer&gt; &lt;index list&gt;
</pre>

<h5>Overview:</h5>
The '<tt>load</tt>' instruction is used to read from memory.<p>

<h5>Arguments:</h5>

There are three forms of the '<tt>load</tt>' instruction: one for reading from a general pointer, one for reading from a pointer to an array, and one for reading from a pointer to a structure.<p>

In the first form, '<tt>&lt;ty&gt;</tt>' must be a pointer to a simple type (a primitive type or another pointer).<p>

In the second form, '<tt>&lt;ty&gt;</tt>' must be a pointer to an array, and a list of one or more indices is provided as indexes into the (possibly multidimensional) array.  No bounds checking is performed on array reads.<p>

In the third form, the pointer must point to a (possibly nested) structure.  There shall be one ubyte argument for each level of dereferencing involved.<p>

<h5>Semantics:</h5>
...

<h5>Examples:</h5>
<pre>
  %ptr = <a href="#i_alloca">alloca</a> int                               <i>; yields {int*}:ptr</i>
  <a href="#i_store">store</a> int 3, int* %ptr                          <i>; yields {void}</i>
  %val = load int* %ptr                           <i>; yields {int}:val = int 3</i>

  %array = <a href="#i_malloc">malloc</a> [4 x ubyte]                     <i>; yields {[4 x ubyte]*}:array</i>
  <a href="#i_store">store</a> ubyte 124, [4 x ubyte]* %array, uint 4
  %val   = load [4 x ubyte]* %array, uint 4       <i>; yields {ubyte}:val = ubyte 124</i>
  %val   = load {{int, float}}* %stptr, 0, 1      <i>; yields {float}:val</i>
</pre>




<!-- _______________________________________________________________________ -->
</ul><a name="i_store"><h4><hr size=0>'<tt>store</tt>' Instruction</h4><ul>

<h5>Syntax:</h5>
<pre>
  store &lt;ty&gt; &lt;value&gt;, &lt;ty&gt;* &lt;pointer&gt;                   <i>; yields {void}</i>
  store &lt;ty&gt; &lt;value&gt;, &lt;ty&gt;* &lt;arrayptr&gt;{, uint &lt;idx&gt;}+   <i>; yields {void}</i>
  store &lt;ty&gt; &lt;value&gt;, &lt;ty&gt;* &lt;structptr&gt;{, ubyte &lt;idx&gt;}+ <i>; yields {void}e</i>
</pre>

<h5>Overview:</h5>
The '<tt>store</tt>' instruction is used to write to memory.<p>

<h5>Arguments:</h5>
There are three forms of the '<tt>store</tt>' instruction: one for writing through a general pointer, one for writing through a pointer to a (possibly multidimensional) array, and one for writing to an element of a (potentially nested) structure.<p>

The semantics of this instruction closely match that of the <a href="#i_load">load</a> instruction, except that memory is written to, not read from.

<h5>Semantics:</h5>
...

<h5>Example:</h5>
<pre>
  %ptr = <a href="#i_alloca">alloca</a> int                               <i>; yields {int*}:ptr</i>
  <a href="#i_store">store</a> int 3, int* %ptr                          <i>; yields {void}</i>
  %val = load int* %ptr                           <i>; yields {int}:val = int 3</i>

  %array = <a href="#i_malloc">malloc</a> [4 x ubyte]                     <i>; yields {[4 x ubyte]*}:array</i>
  <a href="#i_store">store</a> ubyte 124, [4 x ubyte]* %array, uint 4
  %val   = load [4 x ubyte]* %array, uint 4       <i>; yields {ubyte}:val = ubyte 124</i>
  %val   = load {{int, float}}* %stptr, 0, 1      <i>; yields {float}:val</i>
</pre>




<!-- ======================================================================= -->
</ul><table width="100%" bgcolor="#441188" border=0 cellpadding=4 cellspacing=0><tr><td>&nbsp;</td><td width="100%">&nbsp; <font color="#EEEEFF" face="Georgia,Palatino"><b>
<a name="otherops">Other Operations
</b></font></td></tr></table><ul>

The instructions in this catagory are the "miscellaneous" functions, that defy better classification.<p>


<!-- _______________________________________________________________________ -->
</ul><a name="i_cast"><h4><hr size=0>'<tt>cast .. to</tt>' Instruction</h4><ul>

<h1>TODO</h1>

<a name="logical_integrals">
  Talk about what is considered true or false for integrals.



<h5>Syntax:</h5>
<pre>
</pre>

<h5>Overview:</h5>


<h5>Arguments:</h5>


<h5>Semantics:</h5>


<h5>Example:</h5>
<pre>
</pre>



<!-- _______________________________________________________________________ -->
</ul><a name="i_call"><h4><hr size=0>'<tt>call</tt>' Instruction</h4><ul>

<h5>Syntax:</h5>
<pre>

</pre>

<h5>Overview:</h5>


<h5>Arguments:</h5>


<h5>Semantics:</h5>


<h5>Example:</h5>
<pre>
  %retval = call int %test(int %argc)
</pre>


<!-- _______________________________________________________________________ --></ul><a name="i_icall"><h3><hr size=0>'<tt>icall</tt>' Instruction</h3><ul>

Indirect calls are desperately needed to implement virtual function tables (C++, java) and function pointers (C, C++, ...).<p>

A new instruction <tt>icall</tt> or similar should be introduced to represent an indirect call.<p>

Example:
<pre>
  %retval = icall int %funcptr(int %arg1)          <i>; yields {int}:%retval</i>
</pre>



<!-- _______________________________________________________________________ -->
</ul><a name="i_phi"><h4><hr size=0>'<tt>phi</tt>' Instruction</h4><ul>

<h5>Syntax:</h5>
<pre>
</pre>

<h5>Overview:</h5>


<h5>Arguments:</h5>


<h5>Semantics:</h5>


<h5>Example:</h5>
<pre>
</pre>


<!-- ======================================================================= -->
</ul><table width="100%" bgcolor="#441188" border=0 cellpadding=4 cellspacing=0><tr><td>&nbsp;</td><td width="100%">&nbsp; <font color="#EEEEFF" face="Georgia,Palatino"><b>
<a name="builtinfunc">Builtin Functions
</b></font></td></tr></table><ul>

<b>Notice:</b> Preliminary idea!<p>

Builtin functions are very similar to normal functions, except they are defined by the implementation.  Invocations of these functions are very similar to function invocations, except that the syntax is a little less verbose.<p>

Builtin functions are useful to implement semi-high level ideas like a '<tt>min</tt>' or '<tt>max</tt>' operation that can have important properties when doing program analysis.  For example:

<ul>
<li>Some optimizations can make use of identities defined over the functions, 
    for example a parrallelizing compiler could make use of '<tt>min</tt>' 
    identities to parrellelize a loop.
<li>Builtin functions would have polymorphic types, where normal function calls
    may only have a single type.
<li>Builtin functions would be known to not have side effects, simplifying 
    analysis over straight function calls.
<li>The syntax of the builtin are cleaner than the syntax of the 
    '<a href="#i_call"><tt>call</tt></a>' instruction (very minor point).
</ul>

Because these invocations are explicit in the representation, the runtime can choose to implement these builtin functions any way that they want, including:

<ul>
<li>Inlining the code directly into the invocation
<li>Implementing the functions in some sort of Runtime class, convert invocation
    to a standard function call.
<li>Implementing the functions in some sort of Runtime class, and perform 
    standard inlining optimizations on it.
</ul>

Note that these builtins do not use quoted identifiers: the name of the builtin effectively becomes an identifier in the language.<p>

Example:
<pre>
  ; Example of a normal function call
  %maximum = call int %maximum(int %arg1, int %arg2)   <i>; yields {int}:%maximum</i>

  ; Examples of potential builtin functions
  %max = max(int %arg1, int %arg2)                     <i>; yields {int}:%max</i>
  %min = min(int %arg1, int %arg2)                     <i>; yields {int}:%min</i>
  %sin = sin(double %arg)                              <i>; yields {double}:%sin</i>
  %cos = cos(double %arg)                              <i>; yields {double}:%cos</i>

  ; Show that builtin's are polymorphic, like instructions
  %max = max(float %arg1, float %arg2)                 <i>; yields {float}:%max</i>
  %cos = cos(float %arg)                               <i>; yields {float}:%cos</i>
</pre>

The '<tt>maximum</tt>' vs '<tt>max</tt>' example illustrates the difference in calling semantics between a '<a href="#i_call"><tt>call</tt></a>' instruction and a builtin function invocation.  Notice that the '<tt>maximum</tt>' example assumes that the function is defined local to the caller.<p>




<!-- *********************************************************************** -->
</ul><table width="100%" bgcolor="#330077" border=0 cellpadding=4 cellspacing=0><tr><td align=center><font color="#EEEEFF" size=+2 face="Georgia,Palatino"><b>
<a name="todo">TODO List
</b></font></td></tr></table><ul>
<!-- *********************************************************************** -->

This list of random topics includes things that will <b>need</b> to be addressed before the llvm may be used to implement a java like langauge.  Right now, it is pretty much useless for any language, given to unavailable of structure types<p>

<!-- _______________________________________________________________________ -->
</ul><a name="synchronization"><h3><hr size=0>Synchronization Instructions</h3><ul>

We will need some type of synchronization instructions to be able to implement stuff in Java well.  The way I currently envision doing this is to introduce a '<tt>lock</tt>' type, and then add two (builtin or instructions) operations to lock and unlock the lock.<p>


<!-- *********************************************************************** -->
</ul><table width="100%" bgcolor="#330077" border=0 cellpadding=4 cellspacing=0><tr><td align=center><font color="#EEEEFF" size=+2 face="Georgia,Palatino"><b>
<a name="extensions">Possible Extensions
</b></font></td></tr></table><ul>
<!-- *********************************************************************** -->

These extensions are distinct from the TODO list, as they are mostly "interesting" ideas that could be implemented in the future by someone so motivated.  They are not directly required to get <a href="#rw_java">Java</a> like languages working.<p>

<!-- _______________________________________________________________________ -->
</ul><a name="i_tailcall"><h3><hr size=0>'<tt>tailcall</tt>' Instruction</h3><ul>

This could be useful.  Who knows.  '.net' does it, but is the optimization really worth the extra hassle?  Using strong typing would make this trivial to implement and a runtime could always callback to using downconverting this to a normal '<a href="#i_call"><tt>call</tt></a>' instruction.<p>


<!-- _______________________________________________________________________ -->
</ul><a name="globalvars"><h3><hr size=0>Global Variables</h3><ul>

In order to represent programs written in languages like C, we need to be able to support variables at the module (global) scope.  Perhaps they should be written outside of the module definition even.  Maybe global functions should be handled like this as well.<p>


<!-- _______________________________________________________________________ -->
</ul><a name="explicitparrellelism"><h3><hr size=0>Explicit Parrellelism</h3><ul>

With the rise of massively parrellel architectures (like <a href="#rw_ia64">the IA64 architecture</a>, multithreaded CPU cores, and SIMD data sets) it is becoming increasingly more important to extract all of the ILP from a code stream possible.  It would be interesting to research encoding functions that can explicitly represent this.  One straightforward way to do this would be to introduce a "stop" instruction that is equilivent to the IA64 stop bit.<p>



<!-- *********************************************************************** -->
</ul><table width="100%" bgcolor="#330077" border=0 cellpadding=4 cellspacing=0><tr><td align=center><font color="#EEEEFF" size=+2 face="Georgia,Palatino"><b>
<a name="related">Related Work
</b></font></td></tr></table><ul>
<!-- *********************************************************************** -->


Codesigned virtual machines.<p>

<dl>
<a name="rw_safetsa">
<dt>SafeTSA
<DD>Description here<p>

<a name="rw_java">
<dt><a href="http://www.javasoft.com">Java</a>
<DD>Desciption here<p>

<a name="rw_net">
<dt><a href="http://www.microsoft.com/net">Microsoft .net</a>
<DD>Desciption here<p>

<a name="rw_gccrtl">
<dt><a href="http://www.math.umn.edu/systems_guide/gcc-2.95.1/gcc_15.html">GNU RTL Intermediate Representation</a>
<DD>Desciption here<p>

<a name="rw_ia64">
<dt><a href="http://developer.intel.com/design/ia-64/index.htm">IA64 Architecture &amp; Instruction Set</a>
<DD>Desciption here<p>

<a name="rw_mmix">
<dt><a href="http://www-cs-faculty.stanford.edu/~knuth/mmix-news.html">MMIX Instruction Set</a>
<DD>Desciption here<p>

<a name="rw_stroustrup">
<dt><a href="http://www.research.att.com/~bs/devXinterview.html">"Interview With Bjarne Stroustrup"</a>
<DD>This interview influenced the design and thought process behind LLVM in several ways, most notably the way that derived types are written in text format. See the question that starts with "you defined the C declarator syntax as an experiment that failed".<p>
</dl>

<!-- _______________________________________________________________________ -->
</ul><a name="rw_vectorization"><h3><hr size=0>Vectorized Architectures</h3><ul>

<dl>
<a name="rw_intel_simd">
<dt>Intel MMX, MMX2, SSE, SSE2
<DD>Description here<p>

<a name="rw_amd_simd">
<dt><a href="http://www.nondot.org/~sabre/os/H1ChipFeatures/3DNow!TechnologyManual.pdf">AMD 3Dnow!, 3Dnow! 2</a>
<DD>Desciption here<p>

<a name="rw_sun_simd">
<dt><a href="http://www.nondot.org/~sabre/os/H1ChipFeatures/VISInstructionSetUsersManual.pdf">Sun VIS ISA</a>
<DD>Desciption here<p>


</dl>

more...

<!-- *********************************************************************** -->
</ul>
<!-- *********************************************************************** -->


<hr>
<font size=-1>
<address><a href="mailto:sabre@nondot.org">Chris Lattner</a></address>
<!-- Created: Tue Jan 23 15:19:28 CST 2001 -->
<!-- hhmts start -->
Last modified: Sun Apr 14 01:12:55 CDT 2002
<!-- hhmts end -->
</font>
</body></html>
