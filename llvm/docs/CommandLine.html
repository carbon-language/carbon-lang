<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
                      "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <title>CommandLine 2.0 Library Manual</title>
  <link rel="stylesheet" href="llvm.css" type="text/css">
</head>
<body>

<div class="doc_title">
  CommandLine 2.0 Library Manual
</div>

<ol>
  <li><a href="#introduction">Introduction</a></li>

  <li><a href="#quickstart">Quick Start Guide</a>
    <ol>
      <li><a href="#bool">Boolean Arguments</a></li>
      <li><a href="#alias">Argument Aliases</a></li>
      <li><a href="#onealternative">Selecting an alternative from a
                                    set of possibilities</a></li>
      <li><a href="#namedalternatives">Named alternatives</a></li>
      <li><a href="#list">Parsing a list of options</a></li>
      <li><a href="#description">Adding freeform text to help output</a></li>
    </ol></li>

  <li><a href="#referenceguide">Reference Guide</a>
    <ol>
      <li><a href="#positional">Positional Arguments</a>
        <ul>
        <li><a href="#--">Specifying positional options with hyphens</a></li>
        <li><a href="#cl::ConsumeAfter">The <tt>cl::ConsumeAfter</tt>
             modifier</a></li>
        </ul></li>

      <li><a href="#storage">Internal vs External Storage</a></li>

      <li><a href="#attributes">Option Attributes</a></li>

      <li><a href="#modifiers">Option Modifiers</a>
        <ul>
        <li><a href="#hiding">Hiding an option from <tt>--help</tt> 
            output</a></li>
        <li><a href="#numoccurrences">Controlling the number of occurrences
                                     required and allowed</a></li>
        <li><a href="#valrequired">Controlling whether or not a value must be
                                   specified</a></li>
        <li><a href="#formatting">Controlling other formatting options</a></li>
        <li><a href="#misc">Miscellaneous option modifiers</a></li>
        </ul></li>

      <li><a href="#toplevel">Top-Level Classes and Functions</a>
        <ul>
        <li><a href="#cl::ParseCommandLineOptions">The 
            <tt>cl::ParseCommandLineOptions</tt> function</a></li>
        <li><a href="#cl::ParseEnvironmentOptions">The 
            <tt>cl::ParseEnvironmentOptions</tt> function</a></li>
        <li><a href="#cl::opt">The <tt>cl::opt</tt> class</a></li>
        <li><a href="#cl::list">The <tt>cl::list</tt> class</a></li>
        <li><a href="#cl::alias">The <tt>cl::alias</tt> class</a></li>
        </ul></li>

      <li><a href="#builtinparsers">Builtin parsers</a>
        <ul>
        <li><a href="#genericparser">The Generic <tt>parser&lt;t&gt;</tt>
            parser</a></li>
        <li><a href="#boolparser">The <tt>parser&lt;bool&gt;</tt>
            specialization</a></li>
        <li><a href="#stringparser">The <tt>parser&lt;string&gt;</tt>
            specialization</a></li>
        <li><a href="#intparser">The <tt>parser&lt;int&gt;</tt>
            specialization</a></li>
        <li><a href="#doubleparser">The <tt>parser&lt;double&gt;</tt> and
            <tt>parser&lt;float&gt;</tt> specializations</a></li>
        </ul></li>
    </ol></li>
  <li><a href="#extensionguide">Extension Guide</a>
    <ol>
      <li><a href="#customparser">Writing a custom parser</a></li>
      <li><a href="#explotingexternal">Exploiting external storage</a></li>
      <li><a href="#dynamicopts">Dynamically adding command line 
          options</a></li>
    </ol></li>
</ol>

<div class="doc_text">
  <p><b>Written by <a href="mailto:sabre@nondot.org">Chris Lattner</a></b></p>
</div>

<!-- *********************************************************************** -->
<div class="doc_section">
  <a name="introduction">Introduction</a>
</div>
<!-- *********************************************************************** -->

<div class="doc_text">

<p>This document describes the CommandLine argument processing library.  It will
show you how to use it, and what it can do.  The CommandLine library uses a
declarative approach to specifying the command line options that your program
takes.  By default, these options declarations implicitly hold the value parsed
for the option declared (of course this <a href="#storage">can be
changed</a>).</p>

<p>Although there are a <b>lot</b> of command line argument parsing libraries
out there in many different languages, none of them fit well with what I needed.
By looking at the features and problems of other libraries, I designed the
CommandLine library to have the following features:</p>

<ol>
<li>Speed: The CommandLine library is very quick and uses little resources.  The
parsing time of the library is directly proportional to the number of arguments
parsed, not the the number of options recognized.  Additionally, command line
argument values are captured transparently into user defined global variables,
which can be accessed like any other variable (and with the same
performance).</li>

<li>Type Safe: As a user of CommandLine, you don't have to worry about
remembering the type of arguments that you want (is it an int?  a string? a
bool? an enum?) and keep casting it around.  Not only does this help prevent
error prone constructs, it also leads to dramatically cleaner source code.</li>

<li>No subclasses required: To use CommandLine, you instantiate variables that
correspond to the arguments that you would like to capture, you don't subclass a
parser.  This means that you don't have to write <b>any</b> boilerplate
code.</li>

<li>Globally accessible: Libraries can specify command line arguments that are
automatically enabled in any tool that links to the library.  This is possible
because the application doesn't have to keep a "list" of arguments to pass to
the parser.  This also makes supporting <a href="#dynamicopts">dynamically
loaded options</a> trivial.</li>

<li>Cleaner: CommandLine supports enum and other types directly, meaning that
there is less error and more security built into the library.  You don't have to
worry about whether your integral command line argument accidentally got
assigned a value that is not valid for your enum type.</li>

<li>Powerful: The CommandLine library supports many different types of
arguments, from simple <a href="#boolparser">boolean flags</a> to <a
href="#cl::opt">scalars arguments</a> (<a href="#stringparser">strings</a>, <a
href="#intparser">integers</a>, <a href="#genericparser">enums</a>, <a
href="#doubleparser">doubles</a>), to <a href="#cl::list">lists of
arguments</a>.  This is possible because CommandLine is...</li>

<li>Extensible: It is very simple to add a new argument type to CommandLine.
Simply specify the parser that you want to use with the command line option when
you declare it.  <a href="#customparser">Custom parsers</a> are no problem.</li>

<li>Labor Saving: The CommandLine library cuts down on the amount of grunt work
that you, the user, have to do.  For example, it automatically provides a
<tt>--help</tt> option that shows the available command line options for your
tool.  Additionally, it does most of the basic correctness checking for
you.</li>

<li>Capable: The CommandLine library can handle lots of different forms of
options often found in real programs.  For example, <a
href="#positional">positional</a> arguments, <tt>ls</tt> style <a
href="#cl::Grouping">grouping</a> options (to allow processing '<tt>ls
-lad</tt>' naturally), <tt>ld</tt> style <a href="#cl::Prefix">prefix</a>
options (to parse '<tt>-lmalloc -L/usr/lib</tt>'), and <a
href="#cl::ConsumeAfter">interpreter style options</a>.</li>

</ol>

<p>This document will hopefully let you jump in and start using CommandLine in
your utility quickly and painlessly.  Additionally it should be a simple
reference manual to figure out how stuff works.  If it is failing in some area
(or you want an extension to the library), nag the author, <a
href="mailto:sabre@nondot.org">Chris Lattner</a>.</p>

</div>

<!-- *********************************************************************** -->
<div class="doc_section">
  <a name="quickstart">Quick Start Guide</a>
</div>
<!-- *********************************************************************** -->

<div class="doc_text">

<p>This section of the manual runs through a simple CommandLine'ification of a
basic compiler tool.  This is intended to show you how to jump into using the
CommandLine library in your own program, and show you some of the cool things it
can do.</p>

<p>To start out, you need to include the CommandLine header file into your
program:</p>

<pre>
  #include "Support/CommandLine.h"
</pre>

<p>Additionally, you need to add this as the first line of your main
program:</p>

<pre>
int main(int argc, char **argv) {
  <a href="#cl::ParseCommandLineOptions">cl::ParseCommandLineOptions</a>(argc, argv);
  ...
}
</pre>

<p>... which actually parses the arguments and fills in the variable
declarations.</p>

<p>Now that you are ready to support command line arguments, we need to tell the
system which ones we want, and what type of argument they are.  The CommandLine
library uses a declarative syntax to model command line arguments with the
global variable declarations that capture the parsed values.  This means that
for every command line option that you would like to support, there should be a
global variable declaration to capture the result.  For example, in a compiler,
we would like to support the unix standard '<tt>-o &lt;filename&gt;</tt>' option
to specify where to put the output.  With the CommandLine library, this is
represented like this:</p>

<p><tt>
<a name="value_desc_example">
<a href="#cl::opt">cl::opt</a>&lt;string&gt; OutputFilename("<i>o</i>", <a href="#cl::desc">cl::desc</a>("<i>Specify output filename</i>"), <a href="#cl::value_desc">cl::value_desc</a>("<i>filename</i>"));</a>
</tt></p>

<p>This declares a global variable "<tt>OutputFilename</tt>" that is used to
capture the result of the "<tt>o</tt>" argument (first parameter).  We specify
that this is a simple scalar option by using the "<tt><a
href="#cl::opt">cl::opt</a></tt>" template (as opposed to the <a
href="#list">"<tt>cl::list</tt> template</a>), and tell the CommandLine library
that the data type that we are parsing is a string.</p>

<p>The second and third parameters (which are optional) are used to specify what
to output for the "<tt>--help</tt>" option.  In this case, we get a line that
looks like this:</p>

<pre>
USAGE: compiler [options]

OPTIONS:
  -help             - display available options (--help-hidden for more)
  <b>-o &lt;filename&gt;     - Specify output filename</b>
</pre>

<p>Because we specified that the command line option should parse using the
<tt>string</tt> data type, the variable declared is automatically usable as a
real string in all contexts that a normal C++ string object may be used.  For
example:</p>

<pre>
  ...
  ofstream Output(OutputFilename.c_str());
  if (Out.good()) ...
  ...
</pre>

<p>There are many different options that you can use to customize the command
line option handling library, but the above example shows the general interface
to these options.  The options can be specified in any order, and are specified
with helper functions like <a href="#cl::desc"><tt>cl::desc(...)</tt></a>, so
there are no positional dependencies to remember.  The available options are
discussed in detail in the <a href="#referenceguide">Reference Guide</a>.</p>

<p>Continuing the example, we would like to have our compiler take an input
filename as well as an output filename, but we do not want the input filename to
be specified with a hyphen (ie, not <tt>-filename.c</tt>).  To support this
style of argument, the CommandLine library allows for <a
href="#positional">positional</a> arguments to be specified for the program.
These positional arguments are filled with command line parameters that are not
in option form.  We use this feature like this:</p>

<pre>
<a href="#cl::opt">cl::opt</a>&lt;string&gt; InputFilename(<a href="#cl::Positional">cl::Positional</a>, <a href="#cl::desc">cl::desc</a>("<i>&lt;input file&gt;</i>"), <a href="#cl::init">cl::init</a>("<i>-</i>"));
</pre>

<p>This declaration indicates that the first positional argument should be
treated as the input filename.  Here we use the <tt><a
href="#cl::init">cl::init</a></tt> option to specify an initial value for the
command line option, which is used if the option is not specified (if you do not
specify a <tt><a href="#cl::init">cl::init</a></tt> modifier for an option, then
the default constructor for the data type is used to initialize the value).
Command line options default to being optional, so if we would like to require
that the user always specify an input filename, we would add the <tt><a
href="#cl::Required">cl::Required</a></tt> flag, and we could eliminate the
<tt><a href="#cl::init">cl::init</a></tt> modifier, like this:</p>

<pre>
<a href="#cl::opt">cl::opt</a>&lt;string&gt; InputFilename(<a href="#cl::Positional">cl::Positional</a>, <a href="#cl::desc">cl::desc</a>("<i>&lt;input file&gt;</i>"), <b><a href="#cl::Required">cl::Required</a></b>);
</pre>

<p>Again, the CommandLine library does not require the options to be specified
in any particular order, so the above declaration is equivalent to:</p>

<pre>
<a href="#cl::opt">cl::opt</a>&lt;string&gt; InputFilename(<a href="#cl::Positional">cl::Positional</a>, <a href="#cl::Required">cl::Required</a>, <a href="#cl::desc">cl::desc</a>("<i>&lt;input file&gt;</i>"));
</pre>

<p>By simply adding the <tt><a href="#cl::Required">cl::Required</a></tt> flag,
the CommandLine library will automatically issue an error if the argument is not
specified, which shifts all of the command line option verification code out of
your application into the library.  This is just one example of how using flags
can alter the default behaviour of the library, on a per-option basis.  By
adding one of the declarations above, the <tt>--help</tt> option synopsis is now
extended to:</p>

<pre>
USAGE: compiler [options] <b>&lt;input file&gt;</b>

OPTIONS:
  -help             - display available options (--help-hidden for more)
  -o &lt;filename&gt;     - Specify output filename
</pre>

<p>... indicating that an input filename is expected.</p>

</div>

<!-- ======================================================================= -->
<div class="doc_subsection">
  <a name="bool">Boolean Arguments</a>
</div>

<div class="doc_text">

<p>In addition to input and output filenames, we would like the compiler example
to support three boolean flags: "<tt>-f</tt>" to force overwriting of the output
file, "<tt>--quiet</tt>" to enable quiet mode, and "<tt>-q</tt>" for backwards
compatibility with some of our users.  We can support these by declaring options
of boolean type like this:</p>

<pre>
<a href="#cl::opt">cl::opt</a>&lt;bool&gt; Force ("<i>f</i>", <a href="#cl::desc">cl::desc</a>("<i>Overwrite output files</i>"));
<a href="#cl::opt">cl::opt</a>&lt;bool&gt; Quiet ("<i>quiet</i>", <a href="#cl::desc">cl::desc</a>("<i>Don't print informational messages</i>"));
<a href="#cl::opt">cl::opt</a>&lt;bool&gt; Quiet2("<i>q</i>", <a href="#cl::desc">cl::desc</a>("<i>Don't print informational messages</i>"), <a href="#cl::Hidden">cl::Hidden</a>);
</pre>

<p>This does what you would expect: it declares three boolean variables
("<tt>Force</tt>", "<tt>Quiet</tt>", and "<tt>Quiet2</tt>") to recognize these
options.  Note that the "<tt>-q</tt>" option is specified with the "<a
href="#cl::Hidden"><tt>cl::Hidden</tt></a>" flag.  This modifier prevents it
from being shown by the standard "<tt>--help</tt>" output (note that it is still
shown in the "<tt>--help-hidden</tt>" output).</p>

<p>The CommandLine library uses a <a href="#builtinparsers">different parser</a>
for different data types.  For example, in the string case, the argument passed
to the option is copied literally into the content of the string variable... we
obviously cannot do that in the boolean case, however, so we must use a smarter
parser.  In the case of the boolean parser, it allows no options (in which case
it assigns the value of true to the variable), or it allows the values
"<tt>true</tt>" or "<tt>false</tt>" to be specified, allowing any of the
following inputs:</p>

<pre>
 compiler -f          # No value, 'Force' == true
 compiler -f=true     # Value specified, 'Force' == true
 compiler -f=TRUE     # Value specified, 'Force' == true
 compiler -f=FALSE    # Value specified, 'Force' == false
</pre>

<p>... you get the idea.  The <a href="#boolparser">bool parser</a> just turns
the string values into boolean values, and rejects things like '<tt>compiler
-f=foo</tt>'.  Similarly, the <a href="#doubleparser">float</a>, <a
href="#doubleparser">double</a>, and <a href="#intparser">int</a> parsers work
like you would expect, using the '<tt>strtol</tt>' and '<tt>strtod</tt>' C
library calls to parse the string value into the specified data type.</p>

<p>With the declarations above, "<tt>compiler --help</tt>" emits this:</p>

<pre>
USAGE: compiler [options] &lt;input file&gt;

OPTIONS:
  <b>-f     - Overwrite output files</b>
  -o     - Override output filename
  <b>-quiet - Don't print informational messages</b>
  -help  - display available options (--help-hidden for more)
</pre>

<p>and "<tt>opt --help-hidden</tt>" prints this:</p>

<pre>
USAGE: compiler [options] &lt;input file&gt;

OPTIONS:
  -f     - Overwrite output files
  -o     - Override output filename
  <b>-q     - Don't print informational messages</b>
  -quiet - Don't print informational messages
  -help  - display available options (--help-hidden for more)
</pre>

<p>This brief example has shown you how to use the '<tt><a
href="#cl::opt">cl::opt</a></tt>' class to parse simple scalar command line
arguments.  In addition to simple scalar arguments, the CommandLine library also
provides primitives to support CommandLine option <a href="#alias">aliases</a>,
and <a href="#list">lists</a> of options.</p>

</div>

<!-- ======================================================================= -->
<div class="doc_subsection">
  <a name="alias">Argument Aliases</a>
</div>

<div class="doc_text">

<p>So far, the example works well, except for the fact that we need to check the
quiet condition like this now:</p>

<pre>
...
  if (!Quiet &amp;&amp; !Quiet2) printInformationalMessage(...);
...
</pre>

<p>... which is a real pain!  Instead of defining two values for the same
condition, we can use the "<tt><a href="#cl::alias">cl::alias</a></tt>" class to make the "<tt>-q</tt>"
option an <b>alias</b> for the "<tt>-quiet</tt>" option, instead of providing
a value itself:</p>

<pre>
<a href="#cl::opt">cl::opt</a>&lt;bool&gt; Force ("<i>f</i>", <a href="#cl::desc">cl::desc</a>("<i>Overwrite output files</i>"));
<a href="#cl::opt">cl::opt</a>&lt;bool&gt; Quiet ("<i>quiet</i>", <a href="#cl::desc">cl::desc</a>("<i>Don't print informational messages</i>"));
<a href="#cl::alias">cl::alias</a>     QuietA("<i>q</i>", <a href="#cl::desc">cl::desc</a>("<i>Alias for -quiet</i>"), <a href="#cl::aliasopt">cl::aliasopt</a>(Quiet));
</pre>

<p>The third line (which is the only one we modified from above) defines a
"<tt>-q</tt> alias that updates the "<tt>Quiet</tt>" variable (as specified by
the <tt><a href="#cl::aliasopt">cl::aliasopt</a></tt> modifier) whenever it is
specified.  Because aliases do not hold state, the only thing the program has to
query is the <tt>Quiet</tt> variable now.  Another nice feature of aliases is
that they automatically hide themselves from the <tt>-help</tt> output
(although, again, they are still visible in the <tt>--help-hidden
output</tt>).</p>

<p>Now the application code can simply use:</p>

<pre>
...
  if (!Quiet) printInformationalMessage(...);
...
</pre>

<p>... which is much nicer!  The "<tt><a href="#cl::alias">cl::alias</a></tt>"
can be used to specify an alternative name for any variable type, and has many
uses.</p>

</div>

<!-- ======================================================================= -->
<div class="doc_subsection">
  <a name="onealternative">Selecting an alternative from a set of
  possibilities</a>
</div>

<div class="doc_text">

<p>So far, we have seen how the CommandLine library handles builtin types like
<tt>std::string</tt>, <tt>bool</tt> and <tt>int</tt>, but how does it handle
things it doesn't know about, like enums or '<tt>int*</tt>'s?</p>

<p>The answer is that it uses a table driven generic parser (unless you specify
your own parser, as described in the <a href="#extensionguide">Extension
Guide</a>).  This parser maps literal strings to whatever type is required, are
requires you to tell it what this mapping should be.</p>

<p>Lets say that we would like to add four optimizations levels to our
optimizer, using the standard flags "<tt>-g</tt>", "<tt>-O0</tt>",
"<tt>-O1</tt>", and "<tt>-O2</tt>".  We could easily implement this with boolean
options like above, but there are several problems with this strategy:</p>

<ol>
<li>A user could specify more than one of the options at a time, for example,
"<tt>opt -O3 -O2</tt>".  The CommandLine library would not be able to catch this
erroneous input for us.</li>

<li>We would have to test 4 different variables to see which ones are set.</li>

<li>This doesn't map to the numeric levels that we want... so we cannot easily
see if some level &gt;= "<tt>-O1</tt>" is enabled.</li>

</ol>

<p>To cope with these problems, we can use an enum value, and have the
CommandLine library fill it in with the appropriate level directly, which is
used like this:</p>

<pre>
enum OptLevel {
  g, O1, O2, O3
};

<a href="#cl::opt">cl::opt</a>&lt;OptLevel&gt; OptimizationLevel(<a href="#cl::desc">cl::desc</a>("<i>Choose optimization level:</i>"),
  <a href="#cl::values">cl::values</a>(
    clEnumVal(g , "<i>No optimizations, enable debugging</i>"),
    clEnumVal(O1, "<i>Enable trivial optimizations</i>"),
    clEnumVal(O2, "<i>Enable default optimizations</i>"),
    clEnumVal(O3, "<i>Enable expensive optimizations</i>"),
   0));

...
  if (OptimizationLevel &gt;= O2) doPartialRedundancyElimination(...);
...
</pre>

<p>This declaration defines a variable "<tt>OptimizationLevel</tt>" of the
"<tt>OptLevel</tt>" enum type.  This variable can be assigned any of the values
that are listed in the declaration (Note that the declaration list must be
terminated with the "<tt>0</tt>" argument!).  The CommandLine library enforces
that the user can only specify one of the options, and it ensure that only valid
enum values can be specified.  The "<tt>clEnumVal</tt>" macros ensure that the
command line arguments matched the enum values.  With this option added, our
help output now is:</p>

<pre>
USAGE: compiler [options] &lt;input file&gt;

OPTIONS:
  <b>Choose optimization level:
    -g          - No optimizations, enable debugging
    -O1         - Enable trivial optimizations
    -O2         - Enable default optimizations
    -O3         - Enable expensive optimizations</b>
  -f            - Overwrite output files
  -help         - display available options (--help-hidden for more)
  -o &lt;filename&gt; - Specify output filename
  -quiet        - Don't print informational messages
</pre>

<p>In this case, it is sort of awkward that flag names correspond directly to
enum names, because we probably don't want a enum definition named "<tt>g</tt>"
in our program.  Because of this, we can alternatively write this example like
this:</p>

<pre>
enum OptLevel {
  Debug, O1, O2, O3
};

<a href="#cl::opt">cl::opt</a>&lt;OptLevel&gt; OptimizationLevel(<a href="#cl::desc">cl::desc</a>("<i>Choose optimization level:</i>"),
  <a href="#cl::values">cl::values</a>(
   clEnumValN(Debug, "g", "<i>No optimizations, enable debugging</i>"),
    clEnumVal(O1        , "<i>Enable trivial optimizations</i>"),
    clEnumVal(O2        , "<i>Enable default optimizations</i>"),
    clEnumVal(O3        , "<i>Enable expensive optimizations</i>"),
   0));

...
  if (OptimizationLevel == Debug) outputDebugInfo(...);
...
</pre>

<p>By using the "<tt>clEnumValN</tt>" macro instead of "<tt>clEnumVal</tt>", we
can directly specify the name that the flag should get.  In general a direct
mapping is nice, but sometimes you can't or don't want to preserve the mapping,
which is when you would use it.</p>

</div>

<!-- ======================================================================= -->
<div class="doc_subsection">
  <a name="namedalternatives">Named Alternatives</a>
</div>

<div class="doc_text">

<p>Another useful argument form is a named alternative style.  We shall use this
style in our compiler to specify different debug levels that can be used.
Instead of each debug level being its own switch, we want to support the
following options, of which only one can be specified at a time:
"<tt>--debug-level=none</tt>", "<tt>--debug-level=quick</tt>",
"<tt>--debug-level=detailed</tt>".  To do this, we use the exact same format as
our optimization level flags, but we also specify an option name.  For this
case, the code looks like this:</p>

<pre>
enum DebugLev {
  nodebuginfo, quick, detailed
};

// Enable Debug Options to be specified on the command line
<a href="#cl::opt">cl::opt</a>&lt;DebugLev&gt; DebugLevel("<i>debug_level</i>", <a href="#cl::desc">cl::desc</a>("<i>Set the debugging level:</i>"),
  <a href="#cl::values">cl::values</a>(
    clEnumValN(nodebuginfo, "none", "<i>disable debug information</i>"),
     clEnumVal(quick,               "<i>enable quick debug information</i>"),
     clEnumVal(detailed,            "<i>enable detailed debug information</i>"),
    0));
</pre>

<p>This definition defines an enumerated command line variable of type "<tt>enum
DebugLev</tt>", which works exactly the same way as before.  The difference here
is just the interface exposed to the user of your program and the help output by
the "<tt>--help</tt>" option:</p>

<pre>
USAGE: compiler [options] &lt;input file&gt;

OPTIONS:
  Choose optimization level:
    -g          - No optimizations, enable debugging
    -O1         - Enable trivial optimizations
    -O2         - Enable default optimizations
    -O3         - Enable expensive optimizations
  <b>-debug_level  - Set the debugging level:
    =none       - disable debug information
    =quick      - enable quick debug information
    =detailed   - enable detailed debug information</b>
  -f            - Overwrite output files
  -help         - display available options (--help-hidden for more)
  -o &lt;filename&gt; - Specify output filename
  -quiet        - Don't print informational messages
</pre>

<p>Again, the only structural difference between the debug level declaration and
the optimiation level declaration is that the debug level declaration includes
an option name (<tt>"debug_level"</tt>), which automatically changes how the
library processes the argument.  The CommandLine library supports both forms so
that you can choose the form most appropriate for your application.</p>

</div>

<!-- ======================================================================= -->
<div class="doc_subsection">
  <a name="list">Parsing a list of options</a>
</div>

<div class="doc_text">

<p>Now that we have the standard run of the mill argument types out of the way,
lets get a little wild and crazy.  Lets say that we want our optimizer to accept
a <b>list</b> of optimizations to perform, allowing duplicates.  For example, we
might want to run: "<tt>compiler -dce -constprop -inline -dce -strip</tt>".  In
this case, the order of the arguments and the number of appearances is very
important.  This is what the "<tt><a href="#cl::list">cl::list</a></tt>"
template is for.  First, start by defining an enum of the optimizations that you
would like to perform:</p>

<pre>
enum Opts {
  // 'inline' is a C++ keyword, so name it 'inlining'
  dce, constprop, inlining, strip
};
</pre>

<p>Then define your "<tt><a href="#cl::list">cl::list</a></tt>" variable:</p>

<pre>
<a href="#cl::list">cl::list</a>&lt;Opts&gt; OptimizationList(<a href="#cl::desc">cl::desc</a>("<i>Available Optimizations:</i>"),
  <a href="#cl::values">cl::values</a>(
    clEnumVal(dce               , "<i>Dead Code Elimination</i>"),
    clEnumVal(constprop         , "<i>Constant Propagation</i>"),
   clEnumValN(inlining, "<i>inline</i>", "<i>Procedure Integration</i>"),
    clEnumVal(strip             , "<i>Strip Symbols</i>"),
  0));
</pre>

<p>This defines a variable that is conceptually of the type
"<tt>std::vector&lt;enum Opts&gt;</tt>".  Thus, you can access it with standard
vector methods:</p>

<pre>
  for (unsigned i = 0; i != OptimizationList.size(); ++i)
    switch (OptimizationList[i])
       ...
</pre>

<p>... to iterate through the list of options specified.</p>

<p>Note that the "<tt><a href="#cl::list">cl::list</a></tt>" template is
completely general and may be used with any data types or other arguments that
you can use with the "<tt><a href="#cl::opt">cl::opt</a></tt>" template.  One
especially useful way to use a list is to capture all of the positional
arguments together if there may be more than one specified.  In the case of a
linker, for example, the linker takes several '<tt>.o</tt>' files, and needs to
capture them into a list.  This is naturally specified as:</p>

<pre>
...
<a href="#cl::list">cl::list</a>&lt;std::string&gt; InputFilenames(<a href="#cl::Positional">cl::Positional</a>, <a href="#cl::desc">cl::desc</a>("&lt;Input files&gt;"), <a href="#cl::OneOrMore">cl::OneOrMore</a>);
...
</pre>

<p>This variable works just like a "<tt>vector&lt;string&gt;</tt>" object.  As
such, accessing the list is simple, just like above.  In this example, we used
the <tt><a href="#cl::OneOrMore">cl::OneOrMore</a></tt> modifier to inform the
CommandLine library that it is an error if the user does not specify any
<tt>.o</tt> files on our command line.  Again, this just reduces the amount of
checking we have to do.</p>

</div>

<!-- ======================================================================= -->
<div class="doc_subsection">
  <a name="description">Adding freeform text to help output</a>
</div>

<div class="doc_text">

<p>As our program grows and becomes more mature, we may decide to put summary
information about what it does into the help output.  The help output is styled
to look similar to a Unix <tt>man</tt> page, providing concise information about
a program.  Unix <tt>man</tt> pages, however often have a description about what
the program does.  To add this to your CommandLine program, simply pass a third
argument to the <a
href="#cl::ParseCommandLineOptions"><tt>cl::ParseCommandLineOptions</tt></a>
call in main.  This additional argument is then printed as the overview
information for your program, allowing you to include any additional information
that you want.  For example:</p>

<pre>
int main(int argc, char **argv) {
  <a href="#cl::ParseCommandLineOptions">cl::ParseCommandLineOptions</a>(argc, argv, " CommandLine compiler example\n\n"
                              "  This program blah blah blah...\n");
  ...
}
</pre>

<p>Would yield the help output:</p>

<pre>
<b>OVERVIEW: CommandLine compiler example

  This program blah blah blah...</b>

USAGE: compiler [options] &lt;input file&gt;

OPTIONS:
  ...
  -help             - display available options (--help-hidden for more)
  -o &lt;filename&gt;     - Specify output filename
</pre>

</div>


<!-- *********************************************************************** -->
<div class="doc_section">
  <a name="referenceguide">Reference Guide</a>
</div>
<!-- *********************************************************************** -->

<div class="doc_text">

<p>Now that you know the basics of how to use the CommandLine library, this
section will give you the detailed information you need to tune how command line
options work, as well as information on more "advanced" command line option
processing capabilities.</p>

</div>

<!-- ======================================================================= -->
<div class="doc_subsection">
  <a name="positional">Positional Arguments</a>
</div>

<div class="doc_text">

<p>Positional arguments are those arguments that are not named, and are not
specified with a hyphen.  Positional arguments should be used when an option is
specified by its position alone.  For example, the standard Unix <tt>grep</tt>
tool takes a regular expression argument, and an optional filename to search
through (which defaults to standard input if a filename is not specified).
Using the CommandLine library, this would be specified as:</p>

<pre>
<a href="#cl::opt">cl::opt</a>&lt;string&gt; Regex   (<a href="#cl::Positional">cl::Positional</a>, <a href="#cl::desc">cl::desc</a>("<i>&lt;regular expression&gt;</i>"), <a href="#cl::Required">cl::Required</a>);
<a href="#cl::opt">cl::opt</a>&lt;string&gt; Filename(<a href="#cl::Positional">cl::Positional</a>, <a href="#cl::desc">cl::desc</a>("<i>&lt;input file&gt;</i>"), <a href="#cl::init">cl::init</a>("<i>-</i>"));
</pre>

<p>Given these two option declarations, the <tt>--help</tt> output for our grep
replacement would look like this:</p>

<pre>
USAGE: spiffygrep [options] <b>&lt;regular expression&gt; &lt;input file&gt;</b>

OPTIONS:
  -help - display available options (--help-hidden for more)
</pre>

<p>... and the resultant program could be used just like the standard
<tt>grep</tt> tool.</p>

<p>Positional arguments are sorted by their order of construction.  This means
that command line options will be ordered according to how they are listed in a
.cpp file, but will not have an ordering defined if they positional arguments
are defined in multiple .cpp files.  The fix for this problem is simply to
define all of your positional arguments in one .cpp file.</p>

</div>


<!-- _______________________________________________________________________ -->
<div class="doc_subsubsection">
  <a name="--">Specifying positional options with hyphens</a>
</div>

<div class="doc_text">

<p>Sometimes you may want to specify a value to your positional argument that
starts with a hyphen (for example, searching for '<tt>-foo</tt>' in a file).  At
first, you will have trouble doing this, because it will try to find an argument
named '<tt>-foo</tt>', and will fail (and single quotes will not save you).
Note that the system <tt>grep</tt> has the same problem:</p>

<pre>
  $ spiffygrep '-foo' test.txt
  Unknown command line argument '-foo'.  Try: spiffygrep --help'

  $ grep '-foo' test.txt
  grep: illegal option -- f
  grep: illegal option -- o
  grep: illegal option -- o
  Usage: grep -hblcnsviw pattern file . . .
</pre>

<p>The solution for this problem is the same for both your tool and the system
version: use the '<tt>--</tt>' marker.  When the user specifies '<tt>--</tt>' on
the command line, it is telling the program that all options after the
'<tt>--</tt>' should be treated as positional arguments, not options.  Thus, we
can use it like this:</p>

<pre>
  $ spiffygrep -- -foo test.txt
    ...output...
</pre>

</div>

<!-- _______________________________________________________________________ -->
<div class="doc_subsubsection">
  <a name="cl::ConsumeAfter">The <tt>cl::ConsumeAfter</tt> modifier</a>
</div>

<div class="doc_text">

<p>The <tt>cl::ConsumeAfter</tt> <a href="#formatting">formatting option</a> is
used to construct programs that use "interpreter style" option processing.  With
this style of option processing, all arguments specified after the last
positional argument are treated as special interpreter arguments that are not
interpreted by the command line argument.</p>

<p>As a concrete example, lets say we are developing a replacement for the
standard Unix Bourne shell (<tt>/bin/sh</tt>).  To run <tt>/bin/sh</tt>, first
you specify options to the shell itself (like <tt>-x</tt> which turns on trace
output), then you specify the name of the script to run, then you specify
arguments to the script.  These arguments to the script are parsed by the bourne
shell command line option processor, but are not interpreted as options to the
shell itself.  Using the CommandLine library, we would specify this as:</p>

<pre>
<a href="#cl::opt">cl::opt</a>&lt;string&gt; Script(<a href="#cl::Positional">cl::Positional</a>, <a href="#cl::desc">cl::desc</a>("<i>&lt;input script&gt;</i>"), <a href="#cl::init">cl::init</a>("-"));
<a href="#cl::list">cl::list</a>&lt;string&gt;  Argv(<a href="#cl::ConsumeAfter">cl::ConsumeAfter</a>, <a href="#cl::desc">cl::desc</a>("<i>&lt;program arguments&gt;...</i>"));
<a href="#cl::opt">cl::opt</a>&lt;bool&gt;    Trace("<i>x</i>", <a href="#cl::desc">cl::desc</a>("<i>Enable trace output</i>"));
</pre>

<p>which automatically provides the help output:</p>

<pre>
USAGE: spiffysh [options] <b>&lt;input script&gt; &lt;program arguments&gt;...</b>

OPTIONS:
  -help - display available options (--help-hidden for more)
  <b>-x    - Enable trace output</b>
</pre>

<p>At runtime, if we run our new shell replacement as '<tt>spiffysh -x test.sh
-a -x -y bar</tt>', the <tt>Trace</tt> variable will be set to true, the
<tt>Script</tt> variable will be set to "<tt>test.sh</tt>", and the
<tt>Argv</tt> list will contain <tt>["-a", "-x", "-y", "bar"]</tt>, because they
were specified after the last positional argument (which is the script
name).</p>

<p>There are several limitations to when <tt>cl::ConsumeAfter</tt> options can
be specified.  For example, only one <tt>cl::ConsumeAfter</tt> can be specified
per program, there must be at least one <a href="#positional">positional
argument</a> specified, and the <tt>cl::ConsumeAfter</tt> option should be a <a
href="#cl::list">cl::list</a> option.</p>

</div>

<!-- ======================================================================= -->
<div class="subsection">
  <a name="storage">Internal vs External Storage</a>
</div>

<div class="doc_text">

<p>By default, all command line options automatically hold the value that they
parse from the command line.  This is very convenient in the common case,
especially when combined with the ability to define command line options in the
files that use them.  This is called the internal storage model.</p>

<p>Sometimes, however, it is nice to separate the command line option processing
code from the storage of the value parsed.  For example, lets say that we have a
'<tt>-debug</tt>' option that we would like to use to enable debug information
across the entire body of our program.  In this case, the boolean value
controlling the debug code should be globally accessable (in a header file, for
example) yet the command line option processing code should not be exposed to
all of these clients (requiring lots of .cpp files to #include
<tt>CommandLine.h</tt>).</p>

<p>To do this, set up your .h file with your option, like this for example:</p>

<pre>
<i>// DebugFlag.h - Get access to the '-debug' command line option
//

// DebugFlag - This boolean is set to true if the '-debug' command line option
// is specified.  This should probably not be referenced directly, instead, use
// the DEBUG macro below.
//</i>
extern bool DebugFlag;

<i>// DEBUG macro - This macro should be used by code to emit debug information.
// In the '-debug' option is specified on the command line, and if this is a
// debug build, then the code specified as the option to the macro will be
// executed.  Otherwise it will not be.  Example:
//
// DEBUG(cerr << "Bitset contains: " << Bitset << "\n");
//</i>
<span class="doc_red">#ifdef NDEBUG
#define DEBUG(X)
#else
#define DEBUG(X)</span> \
  do { if (DebugFlag) { X; } } while (0)
<span class="doc_red">#endif</span>
</pre>

<p>This allows clients to blissfully use the <tt>DEBUG()</tt> macro, or the
<tt>DebugFlag</tt> explicitly if they want to.  Now we just need to be able to
set the <tt>DebugFlag</tt> boolean when the option is set.  To do this, we pass
an additial argument to our command line argument processor, and we specify
where to fill in with the <a href="#cl::location">cl::location</a>
attribute:</p>

<pre>
bool DebugFlag;      <i>// the actual value</i>
static <a href="#cl::opt">cl::opt</a>&lt;bool, true&gt;       <i>// The parser</i>
Debug("<i>debug</i>", <a href="#cl::desc">cl::desc</a>("<i>Enable debug output</i>")</a>, <a href="#cl::Hidden">cl::Hidden</a>,
      <a href="#cl::location">cl::location</a>(DebugFlag));
</pre>

<p>In the above example, we specify "<tt>true</tt>" as the second argument to
the <a href="#cl::opt">cl::opt</a> template, indicating that the template should
not maintain a copy of the value itself.  In addition to this, we specify the <a
href="#cl::location">cl::location</a> attribute, so that <tt>DebugFlag</tt> is
automatically set.</p>

</div>

<!-- ======================================================================= -->
<div class="doc_subsection">
  <a name="attributes">Option Attributes</a>
</div>

<div class="doc_text">

<p>This section describes the basic attributes that you can specify on
options.</p>

<ul>

<li>The option name attribute (which is required for all options, except <a
href="#positional">positional options</a>) specifies what the option name is.
This option is specified in simple double quotes:

<pre>
<a href="#cl::opt">cl::opt</a>&lt;<b>bool</b>&gt; Quiet("<i>quiet</i>");
</pre>

</li>

<li><a name="cl::desc">The <b><tt>cl::desc</tt></b></a> attribute specifies a
description for the option to be shown in the <tt>--help</tt> output for the
program.</li>

<li><a name="cl::value_desc">The <b><tt>cl::value_desc</tt></b></a> attribute
specifies a string that can be used to fine tune the <tt>--help</tt> output for
a command line option.  Look <a href="#value_desc_example">here</a> for an
example.</li>

<li><a name="cl::init">The <b><tt>cl::init</tt></b></a> attribute specifies an
inital value for a <a href="#cl::opt">scalar</a> option.  If this attribute is
not specified then the command line option value defaults to the value created
by the default constructor for the type. <b>Warning</b>: If you specify both
<b><tt>cl::init</tt></b> and <b><tt>cl::location</tt></b> for an option,
you must specify <b><tt>cl::location</tt></b> first, so that when the
command-line parser sees <b><tt>cl::init</tt></b>, it knows where to put the
initial value. (You will get an error at runtime if you don't put them in
the right order.)</li>

<li><a name="cl::location">The <b><tt>cl::location</tt></b></a> attribute where to
store the value for a parsed command line option if using external storage.  See
the section on <a href="#storage">Internal vs External Storage</a> for more
information.</li>

<li><a name="cl::aliasopt">The <b><tt>cl::aliasopt</tt></b></a> attribute
specifies which option a <a href="#cl::alias">cl::alias</a> option is an alias
for.</li>

<li><a name="cl::values">The <b><tt>cl::values</tt></b></a> attribute specifies
the string-to-value mapping to be used by the generic parser.  It takes a
<b>null terminated</b> list of (option, value, description) triplets that
specify the option name, the value mapped to, and the description shown in the
<tt>--help</tt> for the tool.  Because the generic parser is used most
frequently with enum values, two macros are often useful:

<ol>

<li><a name="clEnumVal">The <b><tt>clEnumVal</tt></b></a> macro is used as a
nice simple way to specify a triplet for an enum.  This macro automatically
makes the option name be the same as the enum name.  The first option to the
macro is the enum, the second is the description for the command line
option.</li>

<li><a name="clEnumValN">The <b><tt>clEnumValN</tt></b></a> macro is used to
specify macro options where the option name doesn't equal the enum name.  For
this macro, the first argument is the enum value, the second is the flag name,
and the second is the description.</li>

</ol>

You will get a compile time error if you try to use cl::values with a parser
that does not support it.</li>

</ul>

</div>

<!-- ======================================================================= -->
<div class="doc_subsection">
  <a name="modifiers">Option Modifiers</a>
</div>

<div class="doc_text">

<p>Option modifiers are the flags and expressions that you pass into the
constructors for <tt><a href="#cl::opt">cl::opt</a></tt> and <tt><a
href="#cl::list">cl::list</a></tt>.  These modifiers give you the ability to
tweak how options are parsed and how <tt>--help</tt> output is generated to fit
your application well.</p>

<p>These options fall into five main catagories:</p>

<ol>
<li><a href="#hiding">Hiding an option from <tt>--help</tt> output</a></li>
<li><a href="#numoccurrences">Controlling the number of occurrences
                             required and allowed</a></li>
<li><a href="#valrequired">Controlling whether or not a value must be
                           specified</a></li>
<li><a href="#formatting">Controlling other formatting options</a></li>
<li><a href="#misc">Miscellaneous option modifiers</a></li>
</ol>

<p>It is not possible to specify two options from the same catagory (you'll get
a runtime error) to a single option, except for options in the miscellaneous
catagory.  The CommandLine library specifies defaults for all of these settings
that are the most useful in practice and the most common, which mean that you
usually shouldn't have to worry about these.</p>

</div>

<!-- _______________________________________________________________________ -->
<div class="doc_subsubsection">
  <a name="hiding">Hiding an option from <tt>--help</tt> output</a>
</div>

<div class="doc_text">

<p>The <tt>cl::NotHidden</tt>, <tt>cl::Hidden</tt>, and
<tt>cl::ReallyHidden</tt> modifiers are used to control whether or not an option
appears in the <tt>--help</tt> and <tt>--help-hidden</tt> output for the
compiled program:</p>

<ul>

<li><a name="cl::NotHidden">The <b><tt>cl::NotHidden</tt></b></a> modifier
(which is the default for <tt><a href="#cl::opt">cl::opt</a></tt> and <tt><a
href="#cl::list">cl::list</a></tt> options), indicates the option is to appear
in both help listings.</li>

<li><a name="cl::Hidden">The <b><tt>cl::Hidden</tt></b></a> modifier (which is the
default for <tt><a href="#cl::alias">cl::alias</a></tt> options), indicates that
the option should not appear in the <tt>--help</tt> output, but should appear in
the <tt>--help-hidden</tt> output.</li>

<li><a name="cl::ReallyHidden">The <b><tt>cl::ReallyHidden</tt></b></a> modifier,
indicates that the option should not appear in any help output.</li>

</ul>

</div>

<!-- _______________________________________________________________________ -->
<div class="doc_subsubsection">
  <a name="numoccurrences">Controlling the number of occurrences required and
  allowed</a>
</div>

<div class="doc_text">

<p>This group of options is used to control how many time an option is allowed
(or required) to be specified on the command line of your program.  Specifying a
value for this setting allows the CommandLine library to do error checking for
you.</p>

<p>The allowed values for this option group are:</p>

<ul>

<li><a name="cl::Optional">The <b><tt>cl::Optional</tt></b></a> modifier (which
is the default for the <tt><a href="#cl::opt">cl::opt</a></tt> and <tt><a
href="#cl::alias">cl::alias</a></tt> classes) indicates that your program will
allow either zero or one occurrence of the option to be specified.</li>

<li><a name="cl::ZeroOrMore">The <b><tt>cl::ZeroOrMore</tt></b></a> modifier
(which is the default for the <tt><a href="#cl::list">cl::list</a></tt> class)
indicates that your program will allow the option to be specified zero or more
times.</li>

<li><a name="cl::Required">The <b><tt>cl::Required</tt></b></a> modifier
indicates that the specified option must be specified exactly one time.</li>

<li><a name="cl::OneOrMore">The <b><tt>cl::OneOrMore</tt></b></a> modifier
indicates that the option must be specified at least one time.</li>

<li>The <b><tt>cl::ConsumeAfter</tt></b> modifier is described in the <a
href="#positional">Positional arguments section</a></li>

</ul>

<p>If an option is not specified, then the value of the option is equal to the
value specified by the <tt><a href="#cl::init">cl::init</a></tt> attribute.  If
the <tt><a href="#cl::init">cl::init</a></tt> attribute is not specified, the
option value is initialized with the default constructor for the data type.</p>

<p>If an option is specified multiple times for an option of the <tt><a
href="#cl::opt">cl::opt</a></tt> class, only the last value will be
retained.</p>

</div>

<!-- _______________________________________________________________________ -->
<div class="doc_subsubsection">
  <a name="valrequired">Controlling whether or not a value must be specified</a>
</div>

<div class="doc_text">

<p>This group of options is used to control whether or not the option allows a
value to be present.  In the case of the CommandLine library, a value is either
specified with an equal sign (e.g. '<tt>-index-depth=17</tt>') or as a trailing
string (e.g. '<tt>-o a.out</tt>').</p>

<p>The allowed values for this option group are:</p>

<ul>

<li><a name="cl::ValueOptional">The <b><tt>cl::ValueOptional</tt></b></a> modifier
(which is the default for <tt>bool</tt> typed options) specifies that it is
acceptable to have a value, or not.  A boolean argument can be enabled just by
appearing on the command line, or it can have an explicit '<tt>-foo=true</tt>'.
If an option is specified with this mode, it is illegal for the value to be
provided without the equal sign.  Therefore '<tt>-foo true</tt>' is illegal.  To
get this behavior, you must use the <a
href="#cl::ValueRequired">cl::ValueRequired</a> modifier.</li>

<li><a name="cl::ValueRequired">The <b><tt>cl::ValueRequired</tt></b></a> modifier
(which is the default for all other types except for <a
href="#onealternative">unnamed alternatives using the generic parser</a>)
specifies that a value must be provided.  This mode informs the command line
library that if an option is not provides with an equal sign, that the next
argument provided must be the value.  This allows things like '<tt>-o
a.out</tt>' to work.</li>

<li><a name="cl::ValueDisallowed">The <b><tt>cl::ValueDisallowed</tt></b></a>
modifier (which is the default for <a href="#onealternative">unnamed
alternatives using the generic parser</a>) indicates that it is a runtime error
for the user to specify a value.  This can be provided to disallow users from
providing options to boolean options (like '<tt>-foo=true</tt>').</li>

</ul>

<p>In general, the default values for this option group work just like you would
want them to.  As mentioned above, you can specify the <a
href="#cl::ValueDisallowed">cl::ValueDisallowed</a> modifier to a boolean
argument to restrict your command line parser.  These options are mostly useful
when <a href="#extensionguide">extending the library</a>.</p>

</div>

<!-- _______________________________________________________________________ -->
<div class="doc_subsubsection">
  <a name="formatting">Controlling other formatting options</a>
</div>

<div class="doc_text">

<p>The formatting option group is used to specify that the command line option
has special abilities and is otherwise different from other command line
arguments.  As usual, you can only specify at most one of these arguments.</p>

<ul>

<li><a name="cl::NormalFormatting">The <b><tt>cl::NormalFormatting</tt></b></a>
modifier (which is the default all options) specifies that this option is
"normal".</li>

<li><a name="cl::Positional">The <b><tt>cl::Positional</tt></b></a> modifier
specifies that this is a positional argument, that does not have a command line
option associated with it.  See the <a href="#positional">Positional
Arguments</a> section for more information.</li>

<li>The <b><a href="#cl::ConsumeAfter"><tt>cl::ConsumeAfter</tt></a></b> modifier
specifies that this option is used to capture "interpreter style" arguments.  See <a href="#cl::ConsumeAfter">this section for more information</a>.</li>

<li><a name="cl::Prefix">The <b><tt>cl::Prefix</tt></b></a> modifier specifies
that this option prefixes its value.  With 'Prefix' options, there is no equal
sign that separates the value from the option name specified.  This is useful
for processing odd arguments like '<tt>-lmalloc -L/usr/lib'</tt> in a linker
tool.  Here, the '<tt>l</tt>' and '<tt>L</tt>' options are normal string (list)
options, that have the <a href="#cl::Prefix">cl::Prefix</a> modifier added to
allow the CommandLine library to recognize them.  Note that <a
href="#cl::Prefix">cl::Prefix</a> options must not have the <a
href="#cl::ValueDisallowed">cl::ValueDisallowed</a> modifier specified.</li>

<li><a name="cl::Grouping">The <b><tt>cl::Grouping</tt></b></a> modifier is used
to implement unix style tools (like <tt>ls</tt>) that have lots of single letter
arguments, but only require a single dash.  For example, the '<tt>ls -labF</tt>'
command actually enables four different options, all of which are single
letters.  Note that <a href="#cl::Grouping">cl::Grouping</a> options cannot have
values.</li>

</ul>

<p>The CommandLine library does not restrict how you use the <a
href="#cl::Prefix">cl::Prefix</a> or <a href="#cl::Grouping">cl::Grouping</a>
modifiers, but it is possible to specify ambiguous argument settings.  Thus, it
is possible to have multiple letter options that are prefix or grouping options,
and they will still work as designed.</p>

<p>To do this, the CommandLine library uses a greedy algorithm to parse the
input option into (potentially multiple) prefix and grouping options.  The
strategy basically looks like this:</p>

<p><tt>parse(string OrigInput) {</tt>
<ol>
<li><tt>string input = OrigInput;</tt>
<li><tt>if (isOption(input)) return getOption(input).parse();</tt>&nbsp;&nbsp;&nbsp;&nbsp;<i>// Normal option</i>
<li><tt>while (!isOption(input) &amp;&amp; !input.empty()) input.pop_back();</tt>&nbsp;&nbsp;&nbsp;&nbsp;<i>// Remove the last letter</i>
<li><tt>if (input.empty()) return error();</tt>&nbsp;&nbsp;&nbsp;&nbsp;<i>// No matching option</i>
<li><tt>if (getOption(input).isPrefix())<br>
&nbsp;&nbsp;return getOption(input).parse(input);</tt>
<li><tt>while (!input.empty()) {&nbsp;&nbsp;&nbsp;&nbsp;<i>// Must be grouping options</i><br>
&nbsp;&nbsp;getOption(input).parse();<br>
&nbsp;&nbsp;OrigInput.erase(OrigInput.begin(), OrigInput.begin()+input.length());<br>
&nbsp;&nbsp;input = OrigInput;<br>
&nbsp;&nbsp;while (!isOption(input) &amp;&amp; !input.empty()) input.pop_back();<br>
}</tt>
<li><tt>if (!OrigInput.empty()) error();</tt>
</tt>

</ol>
<tt>}</tt></p>

</div>

<!-- _______________________________________________________________________ -->
<div class="doc_subsubsection">
  <a name="misc">Miscellaneous option modifiers</a>
</div>

<div class="doc_text">

<p>The miscellaneous option modifiers are the only flags where you can specify
more than one flag from the set: they are not mutually exclusive.  These flags
specify boolean properties that modify the option.</p>

<ul>

<li><a name="cl::CommaSeparated">The <b><tt>cl::CommaSeparated</tt></b></a> modifier
indicates that any commas specified for an option's value should be used to
split the value up into multiple values for the option.  For example, these two
options are equivalent when <tt>cl::CommaSeparated</tt> is specified:
"<tt>-foo=a -foo=b -foo=c</tt>" and "<tt>-foo=a,b,c</tt>".  This option only
makes sense to be used in a case where the option is allowed to accept one or
more values (i.e. it is a <a href="#cl::list">cl::list</a> option).</li>

</ul>

<p>So far, the only miscellaneous option modifier is the
<tt>cl::CommaSeparated</tt> modifier.</p>

</div>

<!-- ======================================================================= -->
<div class="doc_subsection">
  <a name="toplevel">Top-Level Classes and Functions</a>
</div>

<div class="doc_text">

<p>Despite all of the built-in flexibility, the CommandLine option library
really only consists of one function (<a
href="#cl::ParseCommandLineOptions"><tt>cl::ParseCommandLineOptions</tt></a>)
and three main classes: <a href="#cl::opt"><tt>cl::opt</tt></a>, <a
href="#cl::list"><tt>cl::list</tt></a>, and <a
href="#cl::alias"><tt>cl::alias</tt></a>.  This section describes these three
classes in detail.</p>

</div>

<!-- _______________________________________________________________________ -->
<div class="doc_subsubsection">
  <a name="cl::ParseCommandLineOptions">The <tt>cl::ParseCommandLineOptions</tt>
  function</a>
</div>

<div class="doc_text">

<p>The <tt>cl::ParseCommandLineOptions</tt> function is designed to be called
directly from <tt>main</tt>, and is used to fill in the values of all of the
command line option variables once <tt>argc</tt> and <tt>argv</tt> are
available.</p>

<p>The <tt>cl::ParseCommandLineOptions</tt> function requires two parameters
(<tt>argc</tt> and <tt>argv</tt>), but may also take an optional third parameter
which holds <a href="#description">additional extra text</a> to emit when the
<tt>--help</tt> option is invoked.</p>

</div>

<!-- _______________________________________________________________________ -->
<div class="doc_subsubsection">
  <a name="cl::ParseEnvironmentOptions">The <tt>cl::ParseEnvironmentOptions</tt>
  function</a>
</div>

<div class="doc_text">

<p>The <tt>cl::ParseEnvironmentOptions</tt> function has mostly the same effects
as <a
href="#cl::ParseCommandLineOptions"><tt>cl::ParseCommandLineOptions</tt></a>,
except that it is designed to take values for options from an environment
variable, for those cases in which reading the command line is not convenient or
not desired. It fills in the values of all the command line option variables
just like <a
href="#cl::ParseCommandLineOptions"><tt>cl::ParseCommandLineOptions</tt></a>
does.</p>

<p>It takes three parameters: first, the name of the program (since
<tt>argv</tt> may not be available, it can't just look in <tt>argv[0]</tt>),
second, the name of the environment variable to examine, and third, the optional
<a href="#description">additional extra text</a> to emit when the
<tt>--help</tt> option is invoked.</p>

<p><tt>cl::ParseEnvironmentOptions</tt> will break the environment
variable's value up into words and then process them using
<a href="#cl::ParseCommandLineOptions"><tt>cl::ParseCommandLineOptions</tt></a>.
<b>Note:</b> Currently <tt>cl::ParseEnvironmentOptions</tt> does not support
quoting, so an environment variable containing <tt>-option "foo bar"</tt> will
be parsed as three words, <tt>-option</tt>, <tt>"foo</tt>, and <tt>bar"</tt>,
which is different from what you would get from the shell with the same
input.</p>

</div>

<!-- _______________________________________________________________________ -->
<div class="doc_subsubsection">
  <a name="cl::opt">The <tt>cl::opt</tt> class</a>
</div>

<div class="doc_text">

<p>The <tt>cl::opt</tt> class is the class used to represent scalar command line
options, and is the one used most of the time.  It is a templated class which
can take up to three arguments (all except for the first have default values
though):</p>

<pre>
<b>namespace</b> cl {
  <b>template</b> &lt;<b>class</b> DataType, <b>bool</b> ExternalStorage = <b>false</b>,
            <b>class</b> ParserClass = parser&lt;DataType&gt; &gt;
  <b>class</b> opt;
}
</pre>

<p>The first template argument specifies what underlying data type the command
line argument is, and is used to select a default parser implementation.  The
second template argument is used to specify whether the option should contain
the storage for the option (the default) or whether external storage should be
used to contain the value parsed for the option (see <a href="#storage">Internal
vs External Storage</a> for more information).</p>

<p>The third template argument specifies which parser to use.  The default value
selects an instantiation of the <tt>parser</tt> class based on the underlying
data type of the option.  In general, this default works well for most
applications, so this option is only used when using a <a
href="#customparser">custom parser</a>.</p>

</div>

<!-- _______________________________________________________________________ -->
<div class="doc_subsubsection">
  <a name="cl::list">The <tt>cl::list</tt> class</a>
</div>

<div class="doc_text">

<p>The <tt>cl::list</tt> class is the class used to represent a list of command
line options.  It too is a templated class which can take up to three
arguments:</p>

<pre>
<b>namespace</b> cl {
  <b>template</b> &lt;<b>class</b> DataType, <b>class</b> Storage = <b>bool</b>,
            <b>class</b> ParserClass = parser&lt;DataType&gt; &gt;
  <b>class</b> list;
}
</pre>

<p>This class works the exact same as the <a
href="#cl::opt"><tt>cl::opt</tt></a> class, except that the second argument is
the <b>type</b> of the external storage, not a boolean value.  For this class,
the marker type '<tt>bool</tt>' is used to indicate that internal storage should
be used.</p>

</div>

<!-- _______________________________________________________________________ -->
<div class="doc_subsubsection">
  <a name="cl::alias">The <tt>cl::alias</tt> class</a>
</div>

<div class="doc_text">

<p>The <tt>cl::alias</tt> class is a nontemplated class that is used to form
aliases for other arguments.</p>

<pre>
<b>namespace</b> cl {
  <b>class</b> alias;
}
</pre>

<p>The <a href="#cl::aliasopt"><tt>cl::aliasopt</tt></a> attribute should be
used to specify which option this is an alias for.  Alias arguments default to
being <a href="#cl::Hidden">Hidden</a>, and use the aliased options parser to do
the conversion from string to data.</p>

</div>

<!-- ======================================================================= -->
<div class="doc_subsection">
  <a name="builtinparsers">Builtin parsers</a>
</div>

<div class="doc_text">

<p>Parsers control how the string value taken from the command line is
translated into a typed value, suitable for use in a C++ program.  By default,
the CommandLine library uses an instance of <tt>parser&lt;type&gt;</tt> if the
command line option specifies that it uses values of type '<tt>type</tt>'.
Because of this, custom option processing is specified with specializations of
the '<tt>parser</tt>' class.</p>

<p>The CommandLine library provides the following builtin parser
specializations, which are sufficient for most applications. It can, however,
also be extended to work with new data types and new ways of interpreting the
same data.  See the <a href="#customparser">Writing a Custom Parser</a> for more
details on this type of library extension.</p>

<ul>

<li><a name="genericparser">The <b>generic <tt>parser&lt;t&gt;</tt> parser</b></a>
can be used to map strings values to any data type, through the use of the <a
href="#cl::values">cl::values</a> property, which specifies the mapping
information.  The most common use of this parser is for parsing enum values,
which allows you to use the CommandLine library for all of the error checking to
make sure that only valid enum values are specified (as opposed to accepting
arbitrary strings).  Despite this, however, the generic parser class can be used
for any data type.</li>

<li><a name="boolparser">The <b><tt>parser&lt;bool&gt;</tt> specialization</b></a>
is used to convert boolean strings to a boolean value.  Currently accepted
strings are "<tt>true</tt>", "<tt>TRUE</tt>", "<tt>True</tt>", "<tt>1</tt>",
"<tt>false</tt>", "<tt>FALSE</tt>", "<tt>False</tt>", and "<tt>0</tt>".</li>

<li><a name="stringparser">The <b><tt>parser&lt;string&gt;</tt>
specialization</b></a> simply stores the parsed string into the string value
specified.  No conversion or modification of the data is performed.</li>

<li><a name="intparser">The <b><tt>parser&lt;int&gt;</tt> specialization</b></a>
uses the C <tt>strtol</tt> function to parse the string input.  As such, it will
accept a decimal number (with an optional '+' or '-' prefix) which must start
with a non-zero digit.  It accepts octal numbers, which are identified with a
'<tt>0</tt>' prefix digit, and hexadecimal numbers with a prefix of
'<tt>0x</tt>' or '<tt>0X</tt>'.</li>

<li><a name="doubleparser">The <b><tt>parser&lt;double&gt;</tt></b></a> and
<b><tt>parser&lt;float&gt;</tt> specializations</b> use the standard C
<tt>strtod</tt> function to convert floating point strings into floating point
values.  As such, a broad range of string formats is supported, including
exponential notation (ex: <tt>1.7e15</tt>) and properly supports locales.
</li>

</ul>

</div>

<!-- *********************************************************************** -->
<div class="doc_section">
  <a name="extensionguide">Extension Guide</a>
</div>
<!-- *********************************************************************** -->

<div class="doc_text">

<p>Although the CommandLine library has a lot of functionality built into it
already (as discussed previously), one of its true strengths lie in its
extensibility.  This section discusses how the CommandLine library works under
the covers and illustrates how to do some simple, common, extensions.</p>

</div>

<!-- ======================================================================= -->
<div class="doc_subsection">
  <a name="customparser">Writing a custom parser</a>
</div>

<div class="doc_text">

<p>One of the simplest and most common extensions is the use of a custom parser.
As <a href="#builtinparsers">discussed previously</a>, parsers are the portion
of the CommandLine library that turns string input from the user into a
particular parsed data type, validating the input in the process.</p>

<p>There are two ways to use a new parser:</p>

<ol>

<li>

<p>Specialize the <a href="#genericparser"><tt>cl::parser</tt></a> template for
your custom data type.<p>

<p>This approach has the advantage that users of your custom data type will
automatically use your custom parser whenever they define an option with a value
type of your data type.  The disadvantage of this approach is that it doesn't
work if your fundemental data type is something that is already supported.</p>

</li>

<li>

<p>Write an independent class, using it explicitly from options that need
it.</p>

<p>This approach works well in situations where you would line to parse an
option using special syntax for a not-very-special data-type.  The drawback of
this approach is that users of your parser have to be aware that they are using
your parser, instead of the builtin ones.</p>

</li>

</ol>

<p>To guide the discussion, we will discuss a custom parser that accepts file
sizes, specified with an optional unit after the numeric size.  For example, we
would like to parse "102kb", "41M", "1G" into the appropriate integer value.  In
this case, the underlying data type we want to parse into is
'<tt>unsigned</tt>'.  We choose approach #2 above because we don't want to make
this the default for all <tt>unsigned</tt> options.</p>

<p>To start out, we declare our new <tt>FileSizeParser</tt> class:</p>

<pre>
<b>struct</b> FileSizeParser : <b>public</b> cl::basic_parser&lt;<b>unsigned</b>&gt; {
  <i>// parse - Return true on error.</i>
  <b>bool</b> parse(cl::Option &amp;O, <b>const char</b> *ArgName, <b>const</b> std::string &amp;ArgValue,
             <b>unsigned</b> &amp;Val);
};
</pre>

<p>Our new class inherits from the <tt>cl::basic_parser</tt> template class to
fill in the default, boiler plate, code for us.  We give it the data type that
we parse into (the last argument to the <tt>parse</tt> method so that clients of
our custom parser know what object type to pass in to the parse method (here we
declare that we parse into '<tt>unsigned</tt>' variables.</p>

<p>For most purposes, the only method that must be implemented in a custom
parser is the <tt>parse</tt> method.  The <tt>parse</tt> method is called
whenever the option is invoked, passing in the option itself, the option name,
the string to parse, and a reference to a return value.  If the string to parse
is not well formed, the parser should output an error message and return true.
Otherwise it should return false and set '<tt>Val</tt>' to the parsed value.  In
our example, we implement <tt>parse</tt> as:</p>

<pre>
<b>bool</b> FileSizeParser::parse(cl::Option &amp;O, <b>const char</b> *ArgName,
                           <b>const</b> std::string &amp;Arg, <b>unsigned</b> &amp;Val) {
  <b>const char</b> *ArgStart = Arg.c_str();
  <b>char</b> *End;
 
  <i>// Parse integer part, leaving 'End' pointing to the first non-integer char</i>
  Val = (unsigned)strtol(ArgStart, &amp;End, 0);

  <b>while</b> (1) {
    <b>switch</b> (*End++) {
    <b>case</b> 0: <b>return</b> false;   <i>// No error</i>
    <b>case</b> 'i':               <i>// Ignore the 'i' in KiB if people use that</i>
    <b>case</b> 'b': <b>case</b> 'B':     <i>// Ignore B suffix</i>
      <b>break</b>;

    <b>case</b> 'g': <b>case</b> 'G': Val *= 1024*1024*1024; <b>break</b>;
    <b>case</b> 'm': <b>case</b> 'M': Val *= 1024*1024;      <b>break</b>;
    <b>case</b> 'k': <b>case</b> 'K': Val *= 1024;           <b>break</b>;

    default:
      <i>// Print an error message if unrecognized character!</i>
      <b>return</b> O.error(": '" + Arg + "' value invalid for file size argument!");
    }
  }
}
</pre>

<p>This function implements a very simple parser for the kinds of strings we are
interested in.  Although it has some holes (it allows "<tt>123KKK</tt>" for
example), it is good enough for this example.  Note that we use the option
itself to print out the error message (the <tt>error</tt> method always returns
true) in order to get a nice error message (shown below).  Now that we have our
parser class, we can use it like this:</p>

<pre>
<b>static</b> <a href="#cl::opt">cl::opt</a>&lt;<b>unsigned</b>, <b>false</b>, FileSizeParser&gt;
MFS(<i>"max-file-size"</i>, <a href="#cl::desc">cl::desc</a>(<i>"Maximum file size to accept"</i>),
    <a href="#cl::value_desc">cl::value_desc</a>("<i>size</i>"));
</pre>

<p>Which adds this to the output of our program:</p>

<pre>
OPTIONS:
  -help                 - display available options (--help-hidden for more)
  ...
  <b>-max-file-size=&lt;size&gt; - Maximum file size to accept</b>
</pre>

<p>And we can test that our parse works correctly now (the test program just
prints out the max-file-size argument value):</p>

<pre>
$ ./test
MFS: 0
$ ./test -max-file-size=123MB
MFS: 128974848
$ ./test -max-file-size=3G
MFS: 3221225472
$ ./test -max-file-size=dog
-max-file-size option: 'dog' value invalid for file size argument!
</pre>

<p>It looks like it works.  The error message that we get is nice and helpful,
and we seem to accept reasonable file sizes.  This wraps up the "custom parser"
tutorial.</p>

</div>

<!-- ======================================================================= -->
<div class="doc_subsection">
  <a name="explotingexternal">Exploiting external storage</a>
</div>

<div class="doc_text">

<p>TODO: fill in this section</p>

</div>

<!-- ======================================================================= -->
<div class="doc_subsection">
  <a name="dynamicopts">Dynamically adding command line options</a>
</div>

<div class="doc_text">

<p>TODO: fill in this section</p>

</div>

<!-- *********************************************************************** -->

<hr>
<div class="doc_footer">
  <address><a href="mailto:sabre@nondot.org">Chris Lattner</a></address>
  <a href="http://llvm.cs.uiuc.edu">The LLVM Compiler Infrastructure</a>
  <br>
  Last modified: $Date$
</div>

</body>
</html>
