<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
                      "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
  <title>LLVM Programmer's Manual</title>
  <link rel="stylesheet" href="llvm.css" type="text/css">
</head>
<body>

<h1>
  LLVM Programmer's Manual
</h1>

<ol>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#general">General Information</a>
    <ul>
      <li><a href="#stl">The C++ Standard Template Library</a></li>
<!--
      <li>The <tt>-time-passes</tt> option</li>
      <li>How to use the LLVM Makefile system</li>
      <li>How to write a regression test</li>

--> 
    </ul>
  </li>
  <li><a href="#apis">Important and useful LLVM APIs</a>
    <ul>
      <li><a href="#isa">The <tt>isa&lt;&gt;</tt>, <tt>cast&lt;&gt;</tt>
and <tt>dyn_cast&lt;&gt;</tt> templates</a> </li>
      <li><a href="#string_apis">Passing strings (the <tt>StringRef</tt>
and <tt>Twine</tt> classes)</a>
        <ul>
          <li><a href="#StringRef">The <tt>StringRef</tt> class</a> </li>
          <li><a href="#Twine">The <tt>Twine</tt> class</a> </li>
        </ul>
      </li>
      <li><a href="#DEBUG">The <tt>DEBUG()</tt> macro and <tt>-debug</tt>
option</a>
        <ul>
          <li><a href="#DEBUG_TYPE">Fine grained debug info with <tt>DEBUG_TYPE</tt>
and the <tt>-debug-only</tt> option</a> </li>
        </ul>
      </li>
      <li><a href="#Statistic">The <tt>Statistic</tt> class &amp; <tt>-stats</tt>
option</a></li>
<!--
      <li>The <tt>InstVisitor</tt> template
      <li>The general graph API
--> 
      <li><a href="#ViewGraph">Viewing graphs while debugging code</a></li>
    </ul>
  </li>
  <li><a href="#datastructure">Picking the Right Data Structure for a Task</a>
    <ul>
    <li><a href="#ds_sequential">Sequential Containers (std::vector, std::list, etc)</a>
    <ul>
      <li><a href="#dss_arrayref">llvm/ADT/ArrayRef.h</a></li>
      <li><a href="#dss_fixedarrays">Fixed Size Arrays</a></li>
      <li><a href="#dss_heaparrays">Heap Allocated Arrays</a></li>
      <li><a href="#dss_tinyptrvector">"llvm/ADT/TinyPtrVector.h"</a></li>
      <li><a href="#dss_smallvector">"llvm/ADT/SmallVector.h"</a></li>
      <li><a href="#dss_vector">&lt;vector&gt;</a></li>
      <li><a href="#dss_deque">&lt;deque&gt;</a></li>
      <li><a href="#dss_list">&lt;list&gt;</a></li>
      <li><a href="#dss_ilist">llvm/ADT/ilist.h</a></li>
      <li><a href="#dss_packedvector">llvm/ADT/PackedVector.h</a></li>
      <li><a href="#dss_other">Other Sequential Container Options</a></li>
    </ul></li>
    <li><a href="#ds_string">String-like containers</a>
    <ul>
      <li><a href="#dss_stringref">llvm/ADT/StringRef.h</a></li>
      <li><a href="#dss_twine">llvm/ADT/Twine.h</a></li>
      <li><a href="#dss_smallstring">llvm/ADT/SmallString.h</a></li>
      <li><a href="#dss_stdstring">std::string</a></li>
    </ul></li>
    <li><a href="#ds_set">Set-Like Containers (std::set, SmallSet, SetVector, etc)</a>
    <ul>
      <li><a href="#dss_sortedvectorset">A sorted 'vector'</a></li>
      <li><a href="#dss_smallset">"llvm/ADT/SmallSet.h"</a></li>
      <li><a href="#dss_smallptrset">"llvm/ADT/SmallPtrSet.h"</a></li>
      <li><a href="#dss_denseset">"llvm/ADT/DenseSet.h"</a></li>
      <li><a href="#dss_sparseset">"llvm/ADT/SparseSet.h"</a></li>
      <li><a href="#dss_FoldingSet">"llvm/ADT/FoldingSet.h"</a></li>
      <li><a href="#dss_set">&lt;set&gt;</a></li>
      <li><a href="#dss_setvector">"llvm/ADT/SetVector.h"</a></li>
      <li><a href="#dss_uniquevector">"llvm/ADT/UniqueVector.h"</a></li>
      <li><a href="#dss_immutableset">"llvm/ADT/ImmutableSet.h"</a></li>
      <li><a href="#dss_otherset">Other Set-Like Container Options</a></li>
    </ul></li>
    <li><a href="#ds_map">Map-Like Containers (std::map, DenseMap, etc)</a>
    <ul>
      <li><a href="#dss_sortedvectormap">A sorted 'vector'</a></li>
      <li><a href="#dss_stringmap">"llvm/ADT/StringMap.h"</a></li>
      <li><a href="#dss_indexedmap">"llvm/ADT/IndexedMap.h"</a></li>
      <li><a href="#dss_densemap">"llvm/ADT/DenseMap.h"</a></li>
      <li><a href="#dss_valuemap">"llvm/ADT/ValueMap.h"</a></li>
      <li><a href="#dss_intervalmap">"llvm/ADT/IntervalMap.h"</a></li>
      <li><a href="#dss_map">&lt;map&gt;</a></li>
      <li><a href="#dss_inteqclasses">"llvm/ADT/IntEqClasses.h"</a></li>
      <li><a href="#dss_immutablemap">"llvm/ADT/ImmutableMap.h"</a></li>
      <li><a href="#dss_othermap">Other Map-Like Container Options</a></li>
    </ul></li>
    <li><a href="#ds_bit">BitVector-like containers</a>
    <ul>
      <li><a href="#dss_bitvector">A dense bitvector</a></li>
      <li><a href="#dss_smallbitvector">A "small" dense bitvector</a></li>
      <li><a href="#dss_sparsebitvector">A sparse bitvector</a></li>
    </ul></li>
  </ul>
  </li>
  <li><a href="#common">Helpful Hints for Common Operations</a>
    <ul>
      <li><a href="#inspection">Basic Inspection and Traversal Routines</a>
        <ul>
          <li><a href="#iterate_function">Iterating over the <tt>BasicBlock</tt>s
in a <tt>Function</tt></a> </li>
          <li><a href="#iterate_basicblock">Iterating over the <tt>Instruction</tt>s
in a <tt>BasicBlock</tt></a> </li>
          <li><a href="#iterate_institer">Iterating over the <tt>Instruction</tt>s
in a <tt>Function</tt></a> </li>
          <li><a href="#iterate_convert">Turning an iterator into a
class pointer</a> </li>
          <li><a href="#iterate_complex">Finding call sites: a more
complex example</a> </li>
          <li><a href="#calls_and_invokes">Treating calls and invokes
the same way</a> </li>
          <li><a href="#iterate_chains">Iterating over def-use &amp;
use-def chains</a> </li>
          <li><a href="#iterate_preds">Iterating over predecessors &amp;
successors of blocks</a></li>
        </ul>
      </li>
      <li><a href="#simplechanges">Making simple changes</a>
        <ul>
          <li><a href="#schanges_creating">Creating and inserting new
		 <tt>Instruction</tt>s</a> </li>
          <li><a href="#schanges_deleting">Deleting 		 <tt>Instruction</tt>s</a> </li>
          <li><a href="#schanges_replacing">Replacing an 		 <tt>Instruction</tt>
with another <tt>Value</tt></a> </li>
          <li><a href="#schanges_deletingGV">Deleting <tt>GlobalVariable</tt>s</a> </li>  
        </ul>
      </li>
      <li><a href="#create_types">How to Create Types</a></li>
<!--
    <li>Working with the Control Flow Graph
    <ul>
      <li>Accessing predecessors and successors of a <tt>BasicBlock</tt>
      <li>
      <li>
    </ul>
--> 
    </ul>
  </li>

  <li><a href="#threading">Threads and LLVM</a>
  <ul>
    <li><a href="#startmultithreaded">Entering and Exiting Multithreaded Mode
        </a></li>
    <li><a href="#shutdown">Ending execution with <tt>llvm_shutdown()</tt></a></li>
    <li><a href="#managedstatic">Lazy initialization with <tt>ManagedStatic</tt></a></li>
    <li><a href="#llvmcontext">Achieving Isolation with <tt>LLVMContext</tt></a></li>
    <li><a href="#jitthreading">Threads and the JIT</a></li>
  </ul>
  </li>

  <li><a href="#advanced">Advanced Topics</a>
  <ul>

  <li><a href="#SymbolTable">The <tt>ValueSymbolTable</tt> class</a></li>
  <li><a href="#UserLayout">The <tt>User</tt> and owned <tt>Use</tt> classes' memory layout</a></li>
  </ul></li>

  <li><a href="#coreclasses">The Core LLVM Class Hierarchy Reference</a>
    <ul>
      <li><a href="#Type">The <tt>Type</tt> class</a> </li>
      <li><a href="#Module">The <tt>Module</tt> class</a></li>
      <li><a href="#Value">The <tt>Value</tt> class</a>
      <ul>
        <li><a href="#User">The <tt>User</tt> class</a>
        <ul>
          <li><a href="#Instruction">The <tt>Instruction</tt> class</a></li>
          <li><a href="#Constant">The <tt>Constant</tt> class</a>
          <ul>
            <li><a href="#GlobalValue">The <tt>GlobalValue</tt> class</a>
            <ul>
              <li><a href="#Function">The <tt>Function</tt> class</a></li>
              <li><a href="#GlobalVariable">The <tt>GlobalVariable</tt> class</a></li>
            </ul>
            </li>
          </ul>
          </li>
        </ul>
        </li>
        <li><a href="#BasicBlock">The <tt>BasicBlock</tt> class</a></li>
        <li><a href="#Argument">The <tt>Argument</tt> class</a></li>
      </ul>
      </li>
    </ul>
  </li>
</ol>

<div class="doc_author">    
  <p>Written by <a href="mailto:sabre@nondot.org">Chris Lattner</a>, 
                <a href="mailto:dhurjati@cs.uiuc.edu">Dinakar Dhurjati</a>, 
                <a href="mailto:ggreif@gmail.com">Gabor Greif</a>, 
                <a href="mailto:jstanley@cs.uiuc.edu">Joel Stanley</a>,
                <a href="mailto:rspencer@x10sys.com">Reid Spencer</a> and
                <a href="mailto:owen@apple.com">Owen Anderson</a></p>
</div>

<!-- *********************************************************************** -->
<h2>
  <a name="introduction">Introduction </a>
</h2>
<!-- *********************************************************************** -->

<div>

<p>This document is meant to highlight some of the important classes and
interfaces available in the LLVM source-base.  This manual is not
intended to explain what LLVM is, how it works, and what LLVM code looks
like.  It assumes that you know the basics of LLVM and are interested
in writing transformations or otherwise analyzing or manipulating the
code.</p>

<p>This document should get you oriented so that you can find your
way in the continuously growing source code that makes up the LLVM
infrastructure. Note that this manual is not intended to serve as a
replacement for reading the source code, so if you think there should be
a method in one of these classes to do something, but it's not listed,
check the source.  Links to the <a href="/doxygen/">doxygen</a> sources
are provided to make this as easy as possible.</p>

<p>The first section of this document describes general information that is
useful to know when working in the LLVM infrastructure, and the second describes
the Core LLVM classes.  In the future this manual will be extended with
information describing how to use extension libraries, such as dominator
information, CFG traversal routines, and useful utilities like the <tt><a
href="/doxygen/InstVisitor_8h-source.html">InstVisitor</a></tt> template.</p>

</div>

<!-- *********************************************************************** -->
<h2>
  <a name="general">General Information</a>
</h2>
<!-- *********************************************************************** -->

<div>

<p>This section contains general information that is useful if you are working
in the LLVM source-base, but that isn't specific to any particular API.</p>

<!-- ======================================================================= -->
<h3>
  <a name="stl">The C++ Standard Template Library</a>
</h3>

<div>

<p>LLVM makes heavy use of the C++ Standard Template Library (STL),
perhaps much more than you are used to, or have seen before.  Because of
this, you might want to do a little background reading in the
techniques used and capabilities of the library.  There are many good
pages that discuss the STL, and several books on the subject that you
can get, so it will not be discussed in this document.</p>

<p>Here are some useful links:</p>

<ol>

<li><a href="http://www.dinkumware.com/manuals/#Standard C++ Library">Dinkumware
C++ Library reference</a> - an excellent reference for the STL and other parts
of the standard C++ library.</li>

<li><a href="http://www.tempest-sw.com/cpp/">C++ In a Nutshell</a> - This is an
O'Reilly book in the making.  It has a decent Standard Library
Reference that rivals Dinkumware's, and is unfortunately no longer free since the
book has been published.</li>

<li><a href="http://www.parashift.com/c++-faq-lite/">C++ Frequently Asked
Questions</a></li>

<li><a href="http://www.sgi.com/tech/stl/">SGI's STL Programmer's Guide</a> -
Contains a useful <a
href="http://www.sgi.com/tech/stl/stl_introduction.html">Introduction to the
STL</a>.</li>

<li><a href="http://www.research.att.com/%7Ebs/C++.html">Bjarne Stroustrup's C++
Page</a></li>

<li><a href="http://64.78.49.204/">
Bruce Eckel's Thinking in C++, 2nd ed. Volume 2 Revision 4.0 (even better, get
the book).</a></li>

</ol>
  
<p>You are also encouraged to take a look at the <a
href="CodingStandards.html">LLVM Coding Standards</a> guide which focuses on how
to write maintainable code more than where to put your curly braces.</p>

</div>

<!-- ======================================================================= -->
<h3>
  <a name="stl">Other useful references</a>
</h3>

<div>

<ol>
<li><a href="http://www.fortran-2000.com/ArnaudRecipes/sharedlib.html">Using
static and shared libraries across platforms</a></li>
</ol>

</div>

</div>

<!-- *********************************************************************** -->
<h2>
  <a name="apis">Important and useful LLVM APIs</a>
</h2>
<!-- *********************************************************************** -->

<div>

<p>Here we highlight some LLVM APIs that are generally useful and good to
know about when writing transformations.</p>

<!-- ======================================================================= -->
<h3>
  <a name="isa">The <tt>isa&lt;&gt;</tt>, <tt>cast&lt;&gt;</tt> and
  <tt>dyn_cast&lt;&gt;</tt> templates</a>
</h3>

<div>

<p>The LLVM source-base makes extensive use of a custom form of RTTI.
These templates have many similarities to the C++ <tt>dynamic_cast&lt;&gt;</tt>
operator, but they don't have some drawbacks (primarily stemming from
the fact that <tt>dynamic_cast&lt;&gt;</tt> only works on classes that
have a v-table). Because they are used so often, you must know what they
do and how they work. All of these templates are defined in the <a
 href="/doxygen/Casting_8h-source.html"><tt>llvm/Support/Casting.h</tt></a>
file (note that you very rarely have to include this file directly).</p>

<dl>
  <dt><tt>isa&lt;&gt;</tt>: </dt>

  <dd><p>The <tt>isa&lt;&gt;</tt> operator works exactly like the Java
  "<tt>instanceof</tt>" operator.  It returns true or false depending on whether
  a reference or pointer points to an instance of the specified class.  This can
  be very useful for constraint checking of various sorts (example below).</p>
  </dd>

  <dt><tt>cast&lt;&gt;</tt>: </dt>

  <dd><p>The <tt>cast&lt;&gt;</tt> operator is a "checked cast" operation. It
  converts a pointer or reference from a base class to a derived class, causing
  an assertion failure if it is not really an instance of the right type.  This
  should be used in cases where you have some information that makes you believe
  that something is of the right type.  An example of the <tt>isa&lt;&gt;</tt>
  and <tt>cast&lt;&gt;</tt> template is:</p>

<div class="doc_code">
<pre>
static bool isLoopInvariant(const <a href="#Value">Value</a> *V, const Loop *L) {
  if (isa&lt;<a href="#Constant">Constant</a>&gt;(V) || isa&lt;<a href="#Argument">Argument</a>&gt;(V) || isa&lt;<a href="#GlobalValue">GlobalValue</a>&gt;(V))
    return true;

  // <i>Otherwise, it must be an instruction...</i>
  return !L-&gt;contains(cast&lt;<a href="#Instruction">Instruction</a>&gt;(V)-&gt;getParent());
}
</pre>
</div>

  <p>Note that you should <b>not</b> use an <tt>isa&lt;&gt;</tt> test followed
  by a <tt>cast&lt;&gt;</tt>, for that use the <tt>dyn_cast&lt;&gt;</tt>
  operator.</p>

  </dd>

  <dt><tt>dyn_cast&lt;&gt;</tt>:</dt>

  <dd><p>The <tt>dyn_cast&lt;&gt;</tt> operator is a "checking cast" operation.
  It checks to see if the operand is of the specified type, and if so, returns a
  pointer to it (this operator does not work with references). If the operand is
  not of the correct type, a null pointer is returned.  Thus, this works very
  much like the <tt>dynamic_cast&lt;&gt;</tt> operator in C++, and should be
  used in the same circumstances.  Typically, the <tt>dyn_cast&lt;&gt;</tt>
  operator is used in an <tt>if</tt> statement or some other flow control
  statement like this:</p>

<div class="doc_code">
<pre>
if (<a href="#AllocationInst">AllocationInst</a> *AI = dyn_cast&lt;<a href="#AllocationInst">AllocationInst</a>&gt;(Val)) {
  // <i>...</i>
}
</pre>
</div>
   
  <p>This form of the <tt>if</tt> statement effectively combines together a call
  to <tt>isa&lt;&gt;</tt> and a call to <tt>cast&lt;&gt;</tt> into one
  statement, which is very convenient.</p>

  <p>Note that the <tt>dyn_cast&lt;&gt;</tt> operator, like C++'s
  <tt>dynamic_cast&lt;&gt;</tt> or Java's <tt>instanceof</tt> operator, can be
  abused.  In particular, you should not use big chained <tt>if/then/else</tt>
  blocks to check for lots of different variants of classes.  If you find
  yourself wanting to do this, it is much cleaner and more efficient to use the
  <tt>InstVisitor</tt> class to dispatch over the instruction type directly.</p>

  </dd>

  <dt><tt>cast_or_null&lt;&gt;</tt>: </dt>
  
  <dd><p>The <tt>cast_or_null&lt;&gt;</tt> operator works just like the
  <tt>cast&lt;&gt;</tt> operator, except that it allows for a null pointer as an
  argument (which it then propagates).  This can sometimes be useful, allowing
  you to combine several null checks into one.</p></dd>

  <dt><tt>dyn_cast_or_null&lt;&gt;</tt>: </dt>

  <dd><p>The <tt>dyn_cast_or_null&lt;&gt;</tt> operator works just like the
  <tt>dyn_cast&lt;&gt;</tt> operator, except that it allows for a null pointer
  as an argument (which it then propagates).  This can sometimes be useful,
  allowing you to combine several null checks into one.</p></dd>

</dl>

<p>These five templates can be used with any classes, whether they have a
v-table or not.  To add support for these templates, you simply need to add
<tt>classof</tt> static methods to the class you are interested casting
to. Describing this is currently outside the scope of this document, but there
are lots of examples in the LLVM source base.</p>

</div>


<!-- ======================================================================= -->
<h3>
  <a name="string_apis">Passing strings (the <tt>StringRef</tt>
and <tt>Twine</tt> classes)</a>
</h3>

<div>

<p>Although LLVM generally does not do much string manipulation, we do have
several important APIs which take strings.  Two important examples are the
Value class -- which has names for instructions, functions, etc. -- and the
StringMap class which is used extensively in LLVM and Clang.</p>

<p>These are generic classes, and they need to be able to accept strings which
may have embedded null characters.  Therefore, they cannot simply take
a <tt>const char *</tt>, and taking a <tt>const std::string&amp;</tt> requires
clients to perform a heap allocation which is usually unnecessary.  Instead,
many LLVM APIs use a <tt>StringRef</tt> or a <tt>const Twine&amp;</tt> for
passing strings efficiently.</p>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="StringRef">The <tt>StringRef</tt> class</a>
</h4>

<div>

<p>The <tt>StringRef</tt> data type represents a reference to a constant string
(a character array and a length) and supports the common operations available
on <tt>std:string</tt>, but does not require heap allocation.</p>

<p>It can be implicitly constructed using a C style null-terminated string,
an <tt>std::string</tt>, or explicitly with a character pointer and length.
For example, the <tt>StringRef</tt> find function is declared as:</p>

<pre class="doc_code">
  iterator find(StringRef Key);
</pre>

<p>and clients can call it using any one of:</p>

<pre class="doc_code">
  Map.find("foo");                 <i>// Lookup "foo"</i>
  Map.find(std::string("bar"));    <i>// Lookup "bar"</i>
  Map.find(StringRef("\0baz", 4)); <i>// Lookup "\0baz"</i>
</pre>

<p>Similarly, APIs which need to return a string may return a <tt>StringRef</tt>
instance, which can be used directly or converted to an <tt>std::string</tt>
using the <tt>str</tt> member function.  See 
"<tt><a href="/doxygen/classllvm_1_1StringRef_8h-source.html">llvm/ADT/StringRef.h</a></tt>"
for more information.</p>

<p>You should rarely use the <tt>StringRef</tt> class directly, because it contains
pointers to external memory it is not generally safe to store an instance of the
class (unless you know that the external storage will not be freed). StringRef is
small and pervasive enough in LLVM that it should always be passed by value.</p>

</div>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="Twine">The <tt>Twine</tt> class</a>
</h4>

<div>

<p>The <tt>Twine</tt> class is an efficient way for APIs to accept concatenated
strings.  For example, a common LLVM paradigm is to name one instruction based on
the name of another instruction with a suffix, for example:</p>

<div class="doc_code">
<pre>
    New = CmpInst::Create(<i>...</i>, SO->getName() + ".cmp");
</pre>
</div>

<p>The <tt>Twine</tt> class is effectively a
lightweight <a href="http://en.wikipedia.org/wiki/Rope_(computer_science)">rope</a>
which points to temporary (stack allocated) objects.  Twines can be implicitly
constructed as the result of the plus operator applied to strings (i.e., a C
strings, an <tt>std::string</tt>, or a <tt>StringRef</tt>).  The twine delays the
actual concatenation of strings until it is actually required, at which point
it can be efficiently rendered directly into a character array.  This avoids
unnecessary heap allocation involved in constructing the temporary results of
string concatenation. See
"<tt><a href="/doxygen/classllvm_1_1Twine_8h-source.html">llvm/ADT/Twine.h</a></tt>"
for more information.</p>

<p>As with a <tt>StringRef</tt>, <tt>Twine</tt> objects point to external memory
and should almost never be stored or mentioned directly.  They are intended
solely for use when defining a function which should be able to efficiently
accept concatenated strings.</p>

</div>

</div>

<!-- ======================================================================= -->
<h3>
  <a name="DEBUG">The <tt>DEBUG()</tt> macro and <tt>-debug</tt> option</a>
</h3>

<div>

<p>Often when working on your pass you will put a bunch of debugging printouts
and other code into your pass.  After you get it working, you want to remove
it, but you may need it again in the future (to work out new bugs that you run
across).</p>

<p> Naturally, because of this, you don't want to delete the debug printouts,
but you don't want them to always be noisy.  A standard compromise is to comment
them out, allowing you to enable them if you need them in the future.</p>

<p>The "<tt><a href="/doxygen/Debug_8h-source.html">llvm/Support/Debug.h</a></tt>"
file provides a macro named <tt>DEBUG()</tt> that is a much nicer solution to
this problem.  Basically, you can put arbitrary code into the argument of the
<tt>DEBUG</tt> macro, and it is only executed if '<tt>opt</tt>' (or any other
tool) is run with the '<tt>-debug</tt>' command line argument:</p>

<div class="doc_code">
<pre>
DEBUG(errs() &lt;&lt; "I am here!\n");
</pre>
</div>

<p>Then you can run your pass like this:</p>

<div class="doc_code">
<pre>
$ opt &lt; a.bc &gt; /dev/null -mypass
<i>&lt;no output&gt;</i>
$ opt &lt; a.bc &gt; /dev/null -mypass -debug
I am here!
</pre>
</div>

<p>Using the <tt>DEBUG()</tt> macro instead of a home-brewed solution allows you
to not have to create "yet another" command line option for the debug output for
your pass.  Note that <tt>DEBUG()</tt> macros are disabled for optimized builds,
so they do not cause a performance impact at all (for the same reason, they
should also not contain side-effects!).</p>

<p>One additional nice thing about the <tt>DEBUG()</tt> macro is that you can
enable or disable it directly in gdb.  Just use "<tt>set DebugFlag=0</tt>" or
"<tt>set DebugFlag=1</tt>" from the gdb if the program is running.  If the
program hasn't been started yet, you can always just run it with
<tt>-debug</tt>.</p>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="DEBUG_TYPE">Fine grained debug info with <tt>DEBUG_TYPE</tt> and
  the <tt>-debug-only</tt> option</a>
</h4>

<div>

<p>Sometimes you may find yourself in a situation where enabling <tt>-debug</tt>
just turns on <b>too much</b> information (such as when working on the code
generator).  If you want to enable debug information with more fine-grained
control, you define the <tt>DEBUG_TYPE</tt> macro and the <tt>-debug</tt> only
option as follows:</p>

<div class="doc_code">
<pre>
#undef  DEBUG_TYPE
DEBUG(errs() &lt;&lt; "No debug type\n");
#define DEBUG_TYPE "foo"
DEBUG(errs() &lt;&lt; "'foo' debug type\n");
#undef  DEBUG_TYPE
#define DEBUG_TYPE "bar"
DEBUG(errs() &lt;&lt; "'bar' debug type\n"));
#undef  DEBUG_TYPE
#define DEBUG_TYPE ""
DEBUG(errs() &lt;&lt; "No debug type (2)\n");
</pre>
</div>

<p>Then you can run your pass like this:</p>

<div class="doc_code">
<pre>
$ opt &lt; a.bc &gt; /dev/null -mypass
<i>&lt;no output&gt;</i>
$ opt &lt; a.bc &gt; /dev/null -mypass -debug
No debug type
'foo' debug type
'bar' debug type
No debug type (2)
$ opt &lt; a.bc &gt; /dev/null -mypass -debug-only=foo
'foo' debug type
$ opt &lt; a.bc &gt; /dev/null -mypass -debug-only=bar
'bar' debug type
</pre>
</div>

<p>Of course, in practice, you should only set <tt>DEBUG_TYPE</tt> at the top of
a file, to specify the debug type for the entire module (if you do this before
you <tt>#include "llvm/Support/Debug.h"</tt>, you don't have to insert the ugly
<tt>#undef</tt>'s).  Also, you should use names more meaningful than "foo" and
"bar", because there is no system in place to ensure that names do not
conflict. If two different modules use the same string, they will all be turned
on when the name is specified. This allows, for example, all debug information
for instruction scheduling to be enabled with <tt>-debug-type=InstrSched</tt>,
even if the source lives in multiple files.</p>

<p>The <tt>DEBUG_WITH_TYPE</tt> macro is also available for situations where you
would like to set <tt>DEBUG_TYPE</tt>, but only for one specific <tt>DEBUG</tt>
statement. It takes an additional first parameter, which is the type to use. For
example, the preceding example could be written as:</p>


<div class="doc_code">
<pre>
DEBUG_WITH_TYPE("", errs() &lt;&lt; "No debug type\n");
DEBUG_WITH_TYPE("foo", errs() &lt;&lt; "'foo' debug type\n");
DEBUG_WITH_TYPE("bar", errs() &lt;&lt; "'bar' debug type\n"));
DEBUG_WITH_TYPE("", errs() &lt;&lt; "No debug type (2)\n");
</pre>
</div>

</div>

</div>

<!-- ======================================================================= -->
<h3>
  <a name="Statistic">The <tt>Statistic</tt> class &amp; <tt>-stats</tt>
  option</a>
</h3>

<div>

<p>The "<tt><a
href="/doxygen/Statistic_8h-source.html">llvm/ADT/Statistic.h</a></tt>" file
provides a class named <tt>Statistic</tt> that is used as a unified way to
keep track of what the LLVM compiler is doing and how effective various
optimizations are.  It is useful to see what optimizations are contributing to
making a particular program run faster.</p>

<p>Often you may run your pass on some big program, and you're interested to see
how many times it makes a certain transformation.  Although you can do this with
hand inspection, or some ad-hoc method, this is a real pain and not very useful
for big programs.  Using the <tt>Statistic</tt> class makes it very easy to
keep track of this information, and the calculated information is presented in a
uniform manner with the rest of the passes being executed.</p>

<p>There are many examples of <tt>Statistic</tt> uses, but the basics of using
it are as follows:</p>

<ol>
    <li><p>Define your statistic like this:</p>

<div class="doc_code">
<pre>
#define <a href="#DEBUG_TYPE">DEBUG_TYPE</a> "mypassname"   <i>// This goes before any #includes.</i>
STATISTIC(NumXForms, "The # of times I did stuff");
</pre>
</div>

  <p>The <tt>STATISTIC</tt> macro defines a static variable, whose name is
    specified by the first argument.  The pass name is taken from the DEBUG_TYPE
    macro, and the description is taken from the second argument.  The variable
    defined ("NumXForms" in this case) acts like an unsigned integer.</p></li>

    <li><p>Whenever you make a transformation, bump the counter:</p>

<div class="doc_code">
<pre>
++NumXForms;   // <i>I did stuff!</i>
</pre>
</div>

    </li>
  </ol>

  <p>That's all you have to do.  To get '<tt>opt</tt>' to print out the
  statistics gathered, use the '<tt>-stats</tt>' option:</p>

<div class="doc_code">
<pre>
$ opt -stats -mypassname &lt; program.bc &gt; /dev/null
<i>... statistics output ...</i>
</pre>
</div>

  <p> When running <tt>opt</tt> on a C file from the SPEC benchmark
suite, it gives a report that looks like this:</p>

<div class="doc_code">
<pre>
   7646 bitcodewriter   - Number of normal instructions
    725 bitcodewriter   - Number of oversized instructions
 129996 bitcodewriter   - Number of bitcode bytes written
   2817 raise           - Number of insts DCEd or constprop'd
   3213 raise           - Number of cast-of-self removed
   5046 raise           - Number of expression trees converted
     75 raise           - Number of other getelementptr's formed
    138 raise           - Number of load/store peepholes
     42 deadtypeelim    - Number of unused typenames removed from symtab
    392 funcresolve     - Number of varargs functions resolved
     27 globaldce       - Number of global variables removed
      2 adce            - Number of basic blocks removed
    134 cee             - Number of branches revectored
     49 cee             - Number of setcc instruction eliminated
    532 gcse            - Number of loads removed
   2919 gcse            - Number of instructions removed
     86 indvars         - Number of canonical indvars added
     87 indvars         - Number of aux indvars removed
     25 instcombine     - Number of dead inst eliminate
    434 instcombine     - Number of insts combined
    248 licm            - Number of load insts hoisted
   1298 licm            - Number of insts hoisted to a loop pre-header
      3 licm            - Number of insts hoisted to multiple loop preds (bad, no loop pre-header)
     75 mem2reg         - Number of alloca's promoted
   1444 cfgsimplify     - Number of blocks simplified
</pre>
</div>

<p>Obviously, with so many optimizations, having a unified framework for this
stuff is very nice.  Making your pass fit well into the framework makes it more
maintainable and useful.</p>

</div>

<!-- ======================================================================= -->
<h3>
  <a name="ViewGraph">Viewing graphs while debugging code</a>
</h3>

<div>

<p>Several of the important data structures in LLVM are graphs: for example
CFGs made out of LLVM <a href="#BasicBlock">BasicBlock</a>s, CFGs made out of
LLVM <a href="CodeGenerator.html#machinebasicblock">MachineBasicBlock</a>s, and
<a href="CodeGenerator.html#selectiondag_intro">Instruction Selection
DAGs</a>.  In many cases, while debugging various parts of the compiler, it is
nice to instantly visualize these graphs.</p>

<p>LLVM provides several callbacks that are available in a debug build to do
exactly that.  If you call the <tt>Function::viewCFG()</tt> method, for example,
the current LLVM tool will pop up a window containing the CFG for the function
where each basic block is a node in the graph, and each node contains the
instructions in the block.  Similarly, there also exists 
<tt>Function::viewCFGOnly()</tt> (does not include the instructions), the
<tt>MachineFunction::viewCFG()</tt> and <tt>MachineFunction::viewCFGOnly()</tt>,
and the <tt>SelectionDAG::viewGraph()</tt> methods.  Within GDB, for example,
you can usually use something like <tt>call DAG.viewGraph()</tt> to pop
up a window.  Alternatively, you can sprinkle calls to these functions in your
code in places you want to debug.</p>

<p>Getting this to work requires a small amount of configuration.  On Unix
systems with X11, install the <a href="http://www.graphviz.org">graphviz</a>
toolkit, and make sure 'dot' and 'gv' are in your path.  If you are running on
Mac OS/X, download and install the Mac OS/X <a 
href="http://www.pixelglow.com/graphviz/">Graphviz program</a>, and add
<tt>/Applications/Graphviz.app/Contents/MacOS/</tt> (or wherever you install
it) to your path.  Once in your system and path are set up, rerun the LLVM
configure script and rebuild LLVM to enable this functionality.</p>

<p><tt>SelectionDAG</tt> has been extended to make it easier to locate
<i>interesting</i> nodes in large complex graphs.  From gdb, if you
<tt>call DAG.setGraphColor(<i>node</i>, "<i>color</i>")</tt>, then the
next <tt>call DAG.viewGraph()</tt> would highlight the node in the
specified color (choices of colors can be found at <a
href="http://www.graphviz.org/doc/info/colors.html">colors</a>.) More
complex node attributes can be provided with <tt>call
DAG.setGraphAttrs(<i>node</i>, "<i>attributes</i>")</tt> (choices can be
found at <a href="http://www.graphviz.org/doc/info/attrs.html">Graph
Attributes</a>.)  If you want to restart and clear all the current graph
attributes, then you can <tt>call DAG.clearGraphAttrs()</tt>. </p>

<p>Note that graph visualization features are compiled out of Release builds
to reduce file size.  This means that you need a Debug+Asserts or 
Release+Asserts build to use these features.</p>

</div>

</div>

<!-- *********************************************************************** -->
<h2>
  <a name="datastructure">Picking the Right Data Structure for a Task</a>
</h2>
<!-- *********************************************************************** -->

<div>

<p>LLVM has a plethora of data structures in the <tt>llvm/ADT/</tt> directory,
 and we commonly use STL data structures.  This section describes the trade-offs
 you should consider when you pick one.</p>

<p>
The first step is a choose your own adventure: do you want a sequential
container, a set-like container, or a map-like container?  The most important
thing when choosing a container is the algorithmic properties of how you plan to
access the container.  Based on that, you should use:</p>

<ul>
<li>a <a href="#ds_map">map-like</a> container if you need efficient look-up
    of an value based on another value.  Map-like containers also support
    efficient queries for containment (whether a key is in the map).  Map-like
    containers generally do not support efficient reverse mapping (values to
    keys).  If you need that, use two maps.  Some map-like containers also
    support efficient iteration through the keys in sorted order.  Map-like
    containers are the most expensive sort, only use them if you need one of
    these capabilities.</li>

<li>a <a href="#ds_set">set-like</a> container if you need to put a bunch of
    stuff into a container that automatically eliminates duplicates.  Some
    set-like containers support efficient iteration through the elements in
    sorted order.  Set-like containers are more expensive than sequential
    containers.
</li>

<li>a <a href="#ds_sequential">sequential</a> container provides
    the most efficient way to add elements and keeps track of the order they are
    added to the collection.  They permit duplicates and support efficient
    iteration, but do not support efficient look-up based on a key.
</li>

<li>a <a href="#ds_string">string</a> container is a specialized sequential
    container or reference structure that is used for character or byte
    arrays.</li>

<li>a <a href="#ds_bit">bit</a> container provides an efficient way to store and
    perform set operations on sets of numeric id's, while automatically
    eliminating duplicates.  Bit containers require a maximum of 1 bit for each
    identifier you want to store.
</li>
</ul>

<p>
Once the proper category of container is determined, you can fine tune the
memory use, constant factors, and cache behaviors of access by intelligently
picking a member of the category.  Note that constant factors and cache behavior
can be a big deal.  If you have a vector that usually only contains a few
elements (but could contain many), for example, it's much better to use
<a href="#dss_smallvector">SmallVector</a> than <a href="#dss_vector">vector</a>
.  Doing so avoids (relatively) expensive malloc/free calls, which dwarf the
cost of adding the elements to the container. </p>

<!-- ======================================================================= -->
<h3>
  <a name="ds_sequential">Sequential Containers (std::vector, std::list, etc)</a>
</h3>

<div>
There are a variety of sequential containers available for you, based on your
needs.  Pick the first in this section that will do what you want.
  
<!-- _______________________________________________________________________ -->
<h4>
  <a name="dss_arrayref">llvm/ADT/ArrayRef.h</a>
</h4>

<div>
<p>The llvm::ArrayRef class is the preferred class to use in an interface that
   accepts a sequential list of elements in memory and just reads from them.  By
   taking an ArrayRef, the API can be passed a fixed size array, an std::vector,
   an llvm::SmallVector and anything else that is contiguous in memory.
</p>
</div>


  
<!-- _______________________________________________________________________ -->
<h4>
  <a name="dss_fixedarrays">Fixed Size Arrays</a>
</h4>

<div>
<p>Fixed size arrays are very simple and very fast.  They are good if you know
exactly how many elements you have, or you have a (low) upper bound on how many
you have.</p>
</div>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="dss_heaparrays">Heap Allocated Arrays</a>
</h4>

<div>
<p>Heap allocated arrays (new[] + delete[]) are also simple.  They are good if
the number of elements is variable, if you know how many elements you will need
before the array is allocated, and if the array is usually large (if not,
consider a <a href="#dss_smallvector">SmallVector</a>).  The cost of a heap
allocated array is the cost of the new/delete (aka malloc/free).  Also note that
if you are allocating an array of a type with a constructor, the constructor and
destructors will be run for every element in the array (re-sizable vectors only
construct those elements actually used).</p>
</div>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="dss_tinyptrvector">"llvm/ADT/TinyPtrVector.h"</a>
</h4>


<div>
<p><tt>TinyPtrVector&lt;Type&gt;</tt> is a highly specialized collection class
that is optimized to avoid allocation in the case when a vector has zero or one
elements.  It has two major restrictions: 1) it can only hold values of pointer
type, and 2) it cannot hold a null pointer.</p>
  
<p>Since this container is highly specialized, it is rarely used.</p>
  
</div>
    
<!-- _______________________________________________________________________ -->
<h4>
  <a name="dss_smallvector">"llvm/ADT/SmallVector.h"</a>
</h4>

<div>
<p><tt>SmallVector&lt;Type, N&gt;</tt> is a simple class that looks and smells
just like <tt>vector&lt;Type&gt;</tt>:
it supports efficient iteration, lays out elements in memory order (so you can
do pointer arithmetic between elements), supports efficient push_back/pop_back
operations, supports efficient random access to its elements, etc.</p>

<p>The advantage of SmallVector is that it allocates space for
some number of elements (N) <b>in the object itself</b>.  Because of this, if
the SmallVector is dynamically smaller than N, no malloc is performed.  This can
be a big win in cases where the malloc/free call is far more expensive than the
code that fiddles around with the elements.</p>

<p>This is good for vectors that are "usually small" (e.g. the number of
predecessors/successors of a block is usually less than 8).  On the other hand,
this makes the size of the SmallVector itself large, so you don't want to
allocate lots of them (doing so will waste a lot of space).  As such,
SmallVectors are most useful when on the stack.</p>

<p>SmallVector also provides a nice portable and efficient replacement for
<tt>alloca</tt>.</p>

</div>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="dss_vector">&lt;vector&gt;</a>
</h4>

<div>
<p>
std::vector is well loved and respected.  It is useful when SmallVector isn't:
when the size of the vector is often large (thus the small optimization will
rarely be a benefit) or if you will be allocating many instances of the vector
itself (which would waste space for elements that aren't in the container).
vector is also useful when interfacing with code that expects vectors :).
</p>

<p>One worthwhile note about std::vector: avoid code like this:</p>

<div class="doc_code">
<pre>
for ( ... ) {
   std::vector&lt;foo&gt; V;
   // make use of V.
}
</pre>
</div>

<p>Instead, write this as:</p>

<div class="doc_code">
<pre>
std::vector&lt;foo&gt; V;
for ( ... ) {
   // make use of V.
   V.clear();
}
</pre>
</div>

<p>Doing so will save (at least) one heap allocation and free per iteration of
the loop.</p>

</div>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="dss_deque">&lt;deque&gt;</a>
</h4>

<div>
<p>std::deque is, in some senses, a generalized version of std::vector.  Like
std::vector, it provides constant time random access and other similar
properties, but it also provides efficient access to the front of the list.  It
does not guarantee continuity of elements within memory.</p>

<p>In exchange for this extra flexibility, std::deque has significantly higher
constant factor costs than std::vector.  If possible, use std::vector or
something cheaper.</p>
</div>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="dss_list">&lt;list&gt;</a>
</h4>

<div>
<p>std::list is an extremely inefficient class that is rarely useful.
It performs a heap allocation for every element inserted into it, thus having an
extremely high constant factor, particularly for small data types.  std::list
also only supports bidirectional iteration, not random access iteration.</p>

<p>In exchange for this high cost, std::list supports efficient access to both
ends of the list (like std::deque, but unlike std::vector or SmallVector).  In
addition, the iterator invalidation characteristics of std::list are stronger
than that of a vector class: inserting or removing an element into the list does
not invalidate iterator or pointers to other elements in the list.</p>
</div>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="dss_ilist">llvm/ADT/ilist.h</a>
</h4>

<div>
<p><tt>ilist&lt;T&gt;</tt> implements an 'intrusive' doubly-linked list.  It is
intrusive, because it requires the element to store and provide access to the
prev/next pointers for the list.</p>

<p><tt>ilist</tt> has the same drawbacks as <tt>std::list</tt>, and additionally
requires an <tt>ilist_traits</tt> implementation for the element type, but it
provides some novel characteristics.  In particular, it can efficiently store
polymorphic objects, the traits class is informed when an element is inserted or
removed from the list, and <tt>ilist</tt>s are guaranteed to support a
constant-time splice operation.</p>

<p>These properties are exactly what we want for things like
<tt>Instruction</tt>s and basic blocks, which is why these are implemented with
<tt>ilist</tt>s.</p>

Related classes of interest are explained in the following subsections:
    <ul>
      <li><a href="#dss_ilist_traits">ilist_traits</a></li>
      <li><a href="#dss_iplist">iplist</a></li>
      <li><a href="#dss_ilist_node">llvm/ADT/ilist_node.h</a></li>
      <li><a href="#dss_ilist_sentinel">Sentinels</a></li>
    </ul>
</div>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="dss_packedvector">llvm/ADT/PackedVector.h</a>
</h4>

<div>
<p>
Useful for storing a vector of values using only a few number of bits for each
value. Apart from the standard operations of a vector-like container, it can
also perform an 'or' set operation. 
</p>

<p>For example:</p>

<div class="doc_code">
<pre>
enum State {
    None = 0x0,
    FirstCondition = 0x1,
    SecondCondition = 0x2,
    Both = 0x3
};

State get() {
    PackedVector&lt;State, 2&gt; Vec1;
    Vec1.push_back(FirstCondition);

    PackedVector&lt;State, 2&gt; Vec2;
    Vec2.push_back(SecondCondition);

    Vec1 |= Vec2;
    return Vec1[0]; // returns 'Both'.
}
</pre>
</div>

</div>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="dss_ilist_traits">ilist_traits</a>
</h4>

<div>
<p><tt>ilist_traits&lt;T&gt;</tt> is <tt>ilist&lt;T&gt;</tt>'s customization
mechanism. <tt>iplist&lt;T&gt;</tt> (and consequently <tt>ilist&lt;T&gt;</tt>)
publicly derive from this traits class.</p>
</div>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="dss_iplist">iplist</a>
</h4>

<div>
<p><tt>iplist&lt;T&gt;</tt> is <tt>ilist&lt;T&gt;</tt>'s base and as such
supports a slightly narrower interface. Notably, inserters from
<tt>T&amp;</tt> are absent.</p>

<p><tt>ilist_traits&lt;T&gt;</tt> is a public base of this class and can be
used for a wide variety of customizations.</p>
</div>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="dss_ilist_node">llvm/ADT/ilist_node.h</a>
</h4>

<div>
<p><tt>ilist_node&lt;T&gt;</tt> implements a the forward and backward links
that are expected by the <tt>ilist&lt;T&gt;</tt> (and analogous containers)
in the default manner.</p>

<p><tt>ilist_node&lt;T&gt;</tt>s are meant to be embedded in the node type
<tt>T</tt>, usually <tt>T</tt> publicly derives from
<tt>ilist_node&lt;T&gt;</tt>.</p>
</div>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="dss_ilist_sentinel">Sentinels</a>
</h4>

<div>
<p><tt>ilist</tt>s have another specialty that must be considered. To be a good
citizen in the C++ ecosystem, it needs to support the standard container
operations, such as <tt>begin</tt> and <tt>end</tt> iterators, etc. Also, the
<tt>operator--</tt> must work correctly on the <tt>end</tt> iterator in the
case of non-empty <tt>ilist</tt>s.</p>

<p>The only sensible solution to this problem is to allocate a so-called
<i>sentinel</i> along with the intrusive list, which serves as the <tt>end</tt>
iterator, providing the back-link to the last element. However conforming to the
C++ convention it is illegal to <tt>operator++</tt> beyond the sentinel and it
also must not be dereferenced.</p>

<p>These constraints allow for some implementation freedom to the <tt>ilist</tt>
how to allocate and store the sentinel. The corresponding policy is dictated
by <tt>ilist_traits&lt;T&gt;</tt>. By default a <tt>T</tt> gets heap-allocated
whenever the need for a sentinel arises.</p>

<p>While the default policy is sufficient in most cases, it may break down when
<tt>T</tt> does not provide a default constructor. Also, in the case of many
instances of <tt>ilist</tt>s, the memory overhead of the associated sentinels
is wasted. To alleviate the situation with numerous and voluminous
<tt>T</tt>-sentinels, sometimes a trick is employed, leading to <i>ghostly
sentinels</i>.</p>

<p>Ghostly sentinels are obtained by specially-crafted <tt>ilist_traits&lt;T&gt;</tt>
which superpose the sentinel with the <tt>ilist</tt> instance in memory. Pointer
arithmetic is used to obtain the sentinel, which is relative to the
<tt>ilist</tt>'s <tt>this</tt> pointer. The <tt>ilist</tt> is augmented by an
extra pointer, which serves as the back-link of the sentinel. This is the only
field in the ghostly sentinel which can be legally accessed.</p>
</div>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="dss_other">Other Sequential Container options</a>
</h4>

<div>
<p>Other STL containers are available, such as std::string.</p>

<p>There are also various STL adapter classes such as std::queue,
std::priority_queue, std::stack, etc.  These provide simplified access to an
underlying container but don't affect the cost of the container itself.</p>

</div>
</div>

<!-- ======================================================================= -->
<h3>
  <a name="ds_string">String-like containers</a>
</h3>

<div>

<p>
There are a variety of ways to pass around and use strings in C and C++, and
LLVM adds a few new options to choose from.  Pick the first option on this list
that will do what you need, they are ordered according to their relative cost.
</p>
<p>
Note that is is generally preferred to <em>not</em> pass strings around as 
"<tt>const char*</tt>"'s.  These have a number of problems, including the fact
that they cannot represent embedded nul ("\0") characters, and do not have a
length available efficiently.  The general replacement for '<tt>const 
char*</tt>' is StringRef.
</p>
  
<p>For more information on choosing string containers for APIs, please see
<a href="#string_apis">Passing strings</a>.</p>
  
  
<!-- _______________________________________________________________________ -->
<h4>
  <a name="dss_stringref">llvm/ADT/StringRef.h</a>
</h4>

<div>
<p>
The StringRef class is a simple value class that contains a pointer to a
character and a length, and is quite related to the <a 
href="#dss_arrayref">ArrayRef</a> class (but specialized for arrays of
characters).  Because StringRef carries a length with it, it safely handles
strings with embedded nul characters in it, getting the length does not require
a strlen call, and it even has very convenient APIs for slicing and dicing the
character range that it represents.
</p>
  
<p>
StringRef is ideal for passing simple strings around that are known to be live,
either because they are C string literals, std::string, a C array, or a
SmallVector.  Each of these cases has an efficient implicit conversion to
StringRef, which doesn't result in a dynamic strlen being executed.
</p>
  
<p>StringRef has a few major limitations which make more powerful string
containers useful:</p>
  
<ol>
<li>You cannot directly convert a StringRef to a 'const char*' because there is
no way to add a trailing nul (unlike the .c_str() method on various stronger
classes).</li>

  
<li>StringRef doesn't own or keep alive the underlying string bytes.
As such it can easily lead to dangling pointers, and is not suitable for
embedding in datastructures in most cases (instead, use an std::string or
something like that).</li>
  
<li>For the same reason, StringRef cannot be used as the return value of a
method if the method "computes" the result string.  Instead, use
std::string.</li>
    
<li>StringRef's do not allow you to mutate the pointed-to string bytes and it
doesn't allow you to insert or remove bytes from the range.  For editing 
operations like this, it interoperates with the <a 
href="#dss_twine">Twine</a> class.</li>
</ol>
  
<p>Because of its strengths and limitations, it is very common for a function to
take a StringRef and for a method on an object to return a StringRef that
points into some string that it owns.</p>
  
</div>
  
<!-- _______________________________________________________________________ -->
<h4>
  <a name="dss_twine">llvm/ADT/Twine.h</a>
</h4>

<div>
  <p>
  The Twine class is used as an intermediary datatype for APIs that want to take
  a string that can be constructed inline with a series of concatenations.
  Twine works by forming recursive instances of the Twine datatype (a simple
  value object) on the stack as temporary objects, linking them together into a
  tree which is then linearized when the Twine is consumed.  Twine is only safe
  to use as the argument to a function, and should always be a const reference,
  e.g.:
  </p>
  
  <pre>
    void foo(const Twine &amp;T);
    ...
    StringRef X = ...
    unsigned i = ...
    foo(X + "." + Twine(i));
  </pre>
  
  <p>This example forms a string like "blarg.42" by concatenating the values
  together, and does not form intermediate strings containing "blarg" or
  "blarg.".
  </p>
  
  <p>Because Twine is constructed with temporary objects on the stack, and
  because these instances are destroyed at the end of the current statement,
  it is an inherently dangerous API.  For example, this simple variant contains
  undefined behavior and will probably crash:</p>
  
  <pre>
    void foo(const Twine &amp;T);
    ...
    StringRef X = ...
    unsigned i = ...
    const Twine &amp;Tmp = X + "." + Twine(i);
    foo(Tmp);
  </pre>

  <p>... because the temporaries are destroyed before the call.  That said,
  Twine's are much more efficient than intermediate std::string temporaries, and
  they work really well with StringRef.  Just be aware of their limitations.</p>
  
</div>

  
<!-- _______________________________________________________________________ -->
<h4>
  <a name="dss_smallstring">llvm/ADT/SmallString.h</a>
</h4>

<div>
  
<p>SmallString is a subclass of <a href="#dss_smallvector">SmallVector</a> that
adds some convenience APIs like += that takes StringRef's.  SmallString avoids
allocating memory in the case when the preallocated space is enough to hold its
data, and it calls back to general heap allocation when required.  Since it owns
its data, it is very safe to use and supports full mutation of the string.</p>
  
<p>Like SmallVector's, the big downside to SmallString is their sizeof.  While
they are optimized for small strings, they themselves are not particularly
small.  This means that they work great for temporary scratch buffers on the
stack, but should not generally be put into the heap: it is very rare to 
see a SmallString as the member of a frequently-allocated heap data structure
or returned by-value.
</p>

</div>
  
<!-- _______________________________________________________________________ -->
<h4>
  <a name="dss_stdstring">std::string</a>
</h4>

<div>
  
  <p>The standard C++ std::string class is a very general class that (like
  SmallString) owns its underlying data.  sizeof(std::string) is very reasonable
  so it can be embedded into heap data structures and returned by-value.
  On the other hand, std::string is highly inefficient for inline editing (e.g.
  concatenating a bunch of stuff together) and because it is provided by the
  standard library, its performance characteristics depend a lot of the host
  standard library (e.g. libc++ and MSVC provide a highly optimized string
  class, GCC contains a really slow implementation).
  </p>

  <p>The major disadvantage of std::string is that almost every operation that
  makes them larger can allocate memory, which is slow.  As such, it is better
  to use SmallVector or Twine as a scratch buffer, but then use std::string to
  persist the result.</p>

  
</div>
  
<!-- end of strings -->
</div>

  
<!-- ======================================================================= -->
<h3>
  <a name="ds_set">Set-Like Containers (std::set, SmallSet, SetVector, etc)</a>
</h3>

<div>

<p>Set-like containers are useful when you need to canonicalize multiple values
into a single representation.  There are several different choices for how to do
this, providing various trade-offs.</p>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="dss_sortedvectorset">A sorted 'vector'</a>
</h4>

<div>

<p>If you intend to insert a lot of elements, then do a lot of queries, a
great approach is to use a vector (or other sequential container) with
std::sort+std::unique to remove duplicates.  This approach works really well if
your usage pattern has these two distinct phases (insert then query), and can be
coupled with a good choice of <a href="#ds_sequential">sequential container</a>.
</p>

<p>
This combination provides the several nice properties: the result data is
contiguous in memory (good for cache locality), has few allocations, is easy to
address (iterators in the final vector are just indices or pointers), and can be
efficiently queried with a standard binary or radix search.</p>

</div>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="dss_smallset">"llvm/ADT/SmallSet.h"</a>
</h4>

<div>

<p>If you have a set-like data structure that is usually small and whose elements
are reasonably small, a <tt>SmallSet&lt;Type, N&gt;</tt> is a good choice.  This set
has space for N elements in place (thus, if the set is dynamically smaller than
N, no malloc traffic is required) and accesses them with a simple linear search.
When the set grows beyond 'N' elements, it allocates a more expensive representation that
guarantees efficient access (for most types, it falls back to std::set, but for
pointers it uses something far better, <a
href="#dss_smallptrset">SmallPtrSet</a>).</p>

<p>The magic of this class is that it handles small sets extremely efficiently,
but gracefully handles extremely large sets without loss of efficiency.  The
drawback is that the interface is quite small: it supports insertion, queries
and erasing, but does not support iteration.</p>

</div>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="dss_smallptrset">"llvm/ADT/SmallPtrSet.h"</a>
</h4>

<div>

<p>SmallPtrSet has all the advantages of <tt>SmallSet</tt> (and a <tt>SmallSet</tt> of pointers is 
transparently implemented with a <tt>SmallPtrSet</tt>), but also supports iterators.  If
more than 'N' insertions are performed, a single quadratically
probed hash table is allocated and grows as needed, providing extremely
efficient access (constant time insertion/deleting/queries with low constant
factors) and is very stingy with malloc traffic.</p>

<p>Note that, unlike <tt>std::set</tt>, the iterators of <tt>SmallPtrSet</tt> are invalidated
whenever an insertion occurs.  Also, the values visited by the iterators are not
visited in sorted order.</p>

</div>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="dss_denseset">"llvm/ADT/DenseSet.h"</a>
</h4>

<div>

<p>
DenseSet is a simple quadratically probed hash table.  It excels at supporting
small values: it uses a single allocation to hold all of the pairs that
are currently inserted in the set.  DenseSet is a great way to unique small
values that are not simple pointers (use <a 
href="#dss_smallptrset">SmallPtrSet</a> for pointers).  Note that DenseSet has
the same requirements for the value type that <a 
href="#dss_densemap">DenseMap</a> has.
</p>

</div>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="dss_sparseset">"llvm/ADT/SparseSet.h"</a>
</h4>

<div>

<p>SparseSet holds a small number of objects identified by unsigned keys of
moderate size. It uses a lot of memory, but provides operations that are
almost as fast as a vector. Typical keys are physical registers, virtual
registers, or numbered basic blocks.</p>

<p>SparseSet is useful for algorithms that need very fast clear/find/insert/erase
and fast iteration over small sets.  It is not intended for building composite
data structures.</p>

</div>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="dss_FoldingSet">"llvm/ADT/FoldingSet.h"</a>
</h4>

<div>

<p>
FoldingSet is an aggregate class that is really good at uniquing
expensive-to-create or polymorphic objects.  It is a combination of a chained
hash table with intrusive links (uniqued objects are required to inherit from
FoldingSetNode) that uses <a href="#dss_smallvector">SmallVector</a> as part of
its ID process.</p>

<p>Consider a case where you want to implement a "getOrCreateFoo" method for
a complex object (for example, a node in the code generator).  The client has a
description of *what* it wants to generate (it knows the opcode and all the
operands), but we don't want to 'new' a node, then try inserting it into a set
only to find out it already exists, at which point we would have to delete it
and return the node that already exists.
</p>

<p>To support this style of client, FoldingSet perform a query with a
FoldingSetNodeID (which wraps SmallVector) that can be used to describe the
element that we want to query for.  The query either returns the element
matching the ID or it returns an opaque ID that indicates where insertion should
take place.  Construction of the ID usually does not require heap traffic.</p>

<p>Because FoldingSet uses intrusive links, it can support polymorphic objects
in the set (for example, you can have SDNode instances mixed with LoadSDNodes).
Because the elements are individually allocated, pointers to the elements are
stable: inserting or removing elements does not invalidate any pointers to other
elements.
</p>

</div>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="dss_set">&lt;set&gt;</a>
</h4>

<div>

<p><tt>std::set</tt> is a reasonable all-around set class, which is decent at
many things but great at nothing.  std::set allocates memory for each element
inserted (thus it is very malloc intensive) and typically stores three pointers
per element in the set (thus adding a large amount of per-element space
overhead).  It offers guaranteed log(n) performance, which is not particularly
fast from a complexity standpoint (particularly if the elements of the set are
expensive to compare, like strings), and has extremely high constant factors for
lookup, insertion and removal.</p>

<p>The advantages of std::set are that its iterators are stable (deleting or
inserting an element from the set does not affect iterators or pointers to other
elements) and that iteration over the set is guaranteed to be in sorted order.
If the elements in the set are large, then the relative overhead of the pointers
and malloc traffic is not a big deal, but if the elements of the set are small,
std::set is almost never a good choice.</p>

</div>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="dss_setvector">"llvm/ADT/SetVector.h"</a>
</h4>

<div>
<p>LLVM's SetVector&lt;Type&gt; is an adapter class that combines your choice of
a set-like container along with a <a href="#ds_sequential">Sequential 
Container</a>.  The important property
that this provides is efficient insertion with uniquing (duplicate elements are
ignored) with iteration support.  It implements this by inserting elements into
both a set-like container and the sequential container, using the set-like
container for uniquing and the sequential container for iteration.
</p>

<p>The difference between SetVector and other sets is that the order of
iteration is guaranteed to match the order of insertion into the SetVector.
This property is really important for things like sets of pointers.  Because
pointer values are non-deterministic (e.g. vary across runs of the program on
different machines), iterating over the pointers in the set will
not be in a well-defined order.</p>

<p>
The drawback of SetVector is that it requires twice as much space as a normal
set and has the sum of constant factors from the set-like container and the 
sequential container that it uses.  Use it *only* if you need to iterate over 
the elements in a deterministic order.  SetVector is also expensive to delete
elements out of (linear time), unless you use it's "pop_back" method, which is
faster.
</p>

<p><tt>SetVector</tt> is an adapter class that defaults to
   using <tt>std::vector</tt> and a size 16 <tt>SmallSet</tt> for the underlying
   containers, so it is quite expensive. However,
   <tt>"llvm/ADT/SetVector.h"</tt> also provides a <tt>SmallSetVector</tt>
   class, which defaults to using a <tt>SmallVector</tt> and <tt>SmallSet</tt>
   of a specified size. If you use this, and if your sets are dynamically
   smaller than <tt>N</tt>, you will save a lot of heap traffic.</p>

</div>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="dss_uniquevector">"llvm/ADT/UniqueVector.h"</a>
</h4>

<div>

<p>
UniqueVector is similar to <a href="#dss_setvector">SetVector</a>, but it
retains a unique ID for each element inserted into the set.  It internally
contains a map and a vector, and it assigns a unique ID for each value inserted
into the set.</p>

<p>UniqueVector is very expensive: its cost is the sum of the cost of
maintaining both the map and vector, it has high complexity, high constant
factors, and produces a lot of malloc traffic.  It should be avoided.</p>

</div>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="dss_immutableset">"llvm/ADT/ImmutableSet.h"</a>
</h4>

<div>

<p>
ImmutableSet is an immutable (functional) set implementation based on an AVL
tree.
Adding or removing elements is done through a Factory object and results in the
creation of a new ImmutableSet object.
If an ImmutableSet already exists with the given contents, then the existing one
is returned; equality is compared with a FoldingSetNodeID.
The time and space complexity of add or remove operations is logarithmic in the
size of the original set.

<p>
There is no method for returning an element of the set, you can only check for
membership.

</div>


<!-- _______________________________________________________________________ -->
<h4>
  <a name="dss_otherset">Other Set-Like Container Options</a>
</h4>

<div>

<p>
The STL provides several other options, such as std::multiset and the various 
"hash_set" like containers (whether from C++ TR1 or from the SGI library). We
never use hash_set and unordered_set because they are generally very expensive 
(each insertion requires a malloc) and very non-portable.
</p>

<p>std::multiset is useful if you're not interested in elimination of
duplicates, but has all the drawbacks of std::set.  A sorted vector (where you 
don't delete duplicate entries) or some other approach is almost always
better.</p>

</div>

</div>

<!-- ======================================================================= -->
<h3>
  <a name="ds_map">Map-Like Containers (std::map, DenseMap, etc)</a>
</h3>

<div>
Map-like containers are useful when you want to associate data to a key.  As
usual, there are a lot of different ways to do this. :)

<!-- _______________________________________________________________________ -->
<h4>
  <a name="dss_sortedvectormap">A sorted 'vector'</a>
</h4>

<div>

<p>
If your usage pattern follows a strict insert-then-query approach, you can
trivially use the same approach as <a href="#dss_sortedvectorset">sorted vectors
for set-like containers</a>.  The only difference is that your query function
(which uses std::lower_bound to get efficient log(n) lookup) should only compare
the key, not both the key and value.  This yields the same advantages as sorted
vectors for sets.
</p>
</div>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="dss_stringmap">"llvm/ADT/StringMap.h"</a>
</h4>

<div>

<p>
Strings are commonly used as keys in maps, and they are difficult to support
efficiently: they are variable length, inefficient to hash and compare when
long, expensive to copy, etc.  StringMap is a specialized container designed to
cope with these issues.  It supports mapping an arbitrary range of bytes to an
arbitrary other object.</p>

<p>The StringMap implementation uses a quadratically-probed hash table, where
the buckets store a pointer to the heap allocated entries (and some other
stuff).  The entries in the map must be heap allocated because the strings are
variable length.  The string data (key) and the element object (value) are
stored in the same allocation with the string data immediately after the element
object.  This container guarantees the "<tt>(char*)(&amp;Value+1)</tt>" points
to the key string for a value.</p>

<p>The StringMap is very fast for several reasons: quadratic probing is very
cache efficient for lookups, the hash value of strings in buckets is not
recomputed when looking up an element, StringMap rarely has to touch the
memory for unrelated objects when looking up a value (even when hash collisions
happen), hash table growth does not recompute the hash values for strings
already in the table, and each pair in the map is store in a single allocation
(the string data is stored in the same allocation as the Value of a pair).</p>

<p>StringMap also provides query methods that take byte ranges, so it only ever
copies a string if a value is inserted into the table.</p>

<p>StringMap iteratation order, however, is not guaranteed to be deterministic,
so any uses which require that should instead use a std::map.</p>
</div>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="dss_indexedmap">"llvm/ADT/IndexedMap.h"</a>
</h4>

<div>
<p>
IndexedMap is a specialized container for mapping small dense integers (or
values that can be mapped to small dense integers) to some other type.  It is
internally implemented as a vector with a mapping function that maps the keys to
the dense integer range.
</p>

<p>
This is useful for cases like virtual registers in the LLVM code generator: they
have a dense mapping that is offset by a compile-time constant (the first
virtual register ID).</p>

</div>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="dss_densemap">"llvm/ADT/DenseMap.h"</a>
</h4>

<div>

<p>
DenseMap is a simple quadratically probed hash table.  It excels at supporting
small keys and values: it uses a single allocation to hold all of the pairs that
are currently inserted in the map.  DenseMap is a great way to map pointers to
pointers, or map other small types to each other.
</p>

<p>
There are several aspects of DenseMap that you should be aware of, however.  The
iterators in a DenseMap are invalidated whenever an insertion occurs, unlike
map.  Also, because DenseMap allocates space for a large number of key/value
pairs (it starts with 64 by default), it will waste a lot of space if your keys
or values are large.  Finally, you must implement a partial specialization of
DenseMapInfo for the key that you want, if it isn't already supported.  This
is required to tell DenseMap about two special marker values (which can never be
inserted into the map) that it needs internally.</p>

<p>
DenseMap's find_as() method supports lookup operations using an alternate key
type. This is useful in cases where the normal key type is expensive to
construct, but cheap to compare against. The DenseMapInfo is responsible for
defining the appropriate comparison and hashing methods for each alternate
key type used.
</p>

</div>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="dss_valuemap">"llvm/ADT/ValueMap.h"</a>
</h4>

<div>

<p>
ValueMap is a wrapper around a <a href="#dss_densemap">DenseMap</a> mapping
Value*s (or subclasses) to another type.  When a Value is deleted or RAUW'ed,
ValueMap will update itself so the new version of the key is mapped to the same
value, just as if the key were a WeakVH.  You can configure exactly how this
happens, and what else happens on these two events, by passing
a <code>Config</code> parameter to the ValueMap template.</p>

</div>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="dss_intervalmap">"llvm/ADT/IntervalMap.h"</a>
</h4>

<div>

<p> IntervalMap is a compact map for small keys and values. It maps key
intervals instead of single keys, and it will automatically coalesce adjacent
intervals. When then map only contains a few intervals, they are stored in the
map object itself to avoid allocations.</p>

<p> The IntervalMap iterators are quite big, so they should not be passed around
as STL iterators. The heavyweight iterators allow a smaller data structure.</p>

</div>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="dss_map">&lt;map&gt;</a>
</h4>

<div>

<p>
std::map has similar characteristics to <a href="#dss_set">std::set</a>: it uses
a single allocation per pair inserted into the map, it offers log(n) lookup with
an extremely large constant factor, imposes a space penalty of 3 pointers per
pair in the map, etc.</p>

<p>std::map is most useful when your keys or values are very large, if you need
to iterate over the collection in sorted order, or if you need stable iterators
into the map (i.e. they don't get invalidated if an insertion or deletion of
another element takes place).</p>

</div>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="dss_inteqclasses">"llvm/ADT/IntEqClasses.h"</a>
</h4>

<div>

<p>IntEqClasses provides a compact representation of equivalence classes of
small integers. Initially, each integer in the range 0..n-1 has its own
equivalence class. Classes can be joined by passing two class representatives to
the join(a, b) method. Two integers are in the same class when findLeader()
returns the same representative.</p>

<p>Once all equivalence classes are formed, the map can be compressed so each
integer 0..n-1 maps to an equivalence class number in the range 0..m-1, where m
is the total number of equivalence classes. The map must be uncompressed before
it can be edited again.</p>

</div>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="dss_immutablemap">"llvm/ADT/ImmutableMap.h"</a>
</h4>

<div>

<p>
ImmutableMap is an immutable (functional) map implementation based on an AVL
tree.
Adding or removing elements is done through a Factory object and results in the
creation of a new ImmutableMap object.
If an ImmutableMap already exists with the given key set, then the existing one
is returned; equality is compared with a FoldingSetNodeID.
The time and space complexity of add or remove operations is logarithmic in the
size of the original map.

</div>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="dss_othermap">Other Map-Like Container Options</a>
</h4>

<div>

<p>
The STL provides several other options, such as std::multimap and the various 
"hash_map" like containers (whether from C++ TR1 or from the SGI library). We
never use hash_set and unordered_set because they are generally very expensive 
(each insertion requires a malloc) and very non-portable.</p>

<p>std::multimap is useful if you want to map a key to multiple values, but has
all the drawbacks of std::map.  A sorted vector or some other approach is almost
always better.</p>

</div>

</div>

<!-- ======================================================================= -->
<h3>
  <a name="ds_bit">Bit storage containers (BitVector, SparseBitVector)</a>
</h3>

<div>
<p>Unlike the other containers, there are only two bit storage containers, and 
choosing when to use each is relatively straightforward.</p>

<p>One additional option is 
<tt>std::vector&lt;bool&gt;</tt>: we discourage its use for two reasons 1) the
implementation in many common compilers (e.g. commonly available versions of 
GCC) is extremely inefficient and 2) the C++ standards committee is likely to
deprecate this container and/or change it significantly somehow.  In any case,
please don't use it.</p>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="dss_bitvector">BitVector</a>
</h4>

<div>
<p> The BitVector container provides a dynamic size set of bits for manipulation.
It supports individual bit setting/testing, as well as set operations.  The set
operations take time O(size of bitvector), but operations are performed one word
at a time, instead of one bit at a time.  This makes the BitVector very fast for
set operations compared to other containers.  Use the BitVector when you expect
the number of set bits to be high (IE a dense set).
</p>
</div>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="dss_smallbitvector">SmallBitVector</a>
</h4>

<div>
<p> The SmallBitVector container provides the same interface as BitVector, but
it is optimized for the case where only a small number of bits, less than
25 or so, are needed. It also transparently supports larger bit counts, but
slightly less efficiently than a plain BitVector, so SmallBitVector should
only be used when larger counts are rare.
</p>

<p>
At this time, SmallBitVector does not support set operations (and, or, xor),
and its operator[] does not provide an assignable lvalue.
</p>
</div>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="dss_sparsebitvector">SparseBitVector</a>
</h4>

<div>
<p> The SparseBitVector container is much like BitVector, with one major
difference: Only the bits that are set, are stored.  This makes the
SparseBitVector much more space efficient than BitVector when the set is sparse,
as well as making set operations O(number of set bits) instead of O(size of
universe).  The downside to the SparseBitVector is that setting and testing of random bits is O(N), and on large SparseBitVectors, this can be slower than BitVector. In our implementation, setting or testing bits in sorted order
(either forwards or reverse) is O(1) worst case.  Testing and setting bits within 128 bits (depends on size) of the current bit is also O(1).  As a general statement, testing/setting bits in a SparseBitVector is O(distance away from last set bit).
</p>
</div>

</div>

</div>

<!-- *********************************************************************** -->
<h2>
  <a name="common">Helpful Hints for Common Operations</a>
</h2>
<!-- *********************************************************************** -->

<div>

<p>This section describes how to perform some very simple transformations of
LLVM code.  This is meant to give examples of common idioms used, showing the
practical side of LLVM transformations.  <p> Because this is a "how-to" section,
you should also read about the main classes that you will be working with.  The
<a href="#coreclasses">Core LLVM Class Hierarchy Reference</a> contains details
and descriptions of the main classes that you should know about.</p>

<!-- NOTE: this section should be heavy on example code -->
<!-- ======================================================================= -->
<h3>
  <a name="inspection">Basic Inspection and Traversal Routines</a>
</h3>

<div>

<p>The LLVM compiler infrastructure have many different data structures that may
be traversed.  Following the example of the C++ standard template library, the
techniques used to traverse these various data structures are all basically the
same.  For a enumerable sequence of values, the <tt>XXXbegin()</tt> function (or
method) returns an iterator to the start of the sequence, the <tt>XXXend()</tt>
function returns an iterator pointing to one past the last valid element of the
sequence, and there is some <tt>XXXiterator</tt> data type that is common
between the two operations.</p>

<p>Because the pattern for iteration is common across many different aspects of
the program representation, the standard template library algorithms may be used
on them, and it is easier to remember how to iterate. First we show a few common
examples of the data structures that need to be traversed.  Other data
structures are traversed in very similar ways.</p>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="iterate_function">Iterating over the </a><a
  href="#BasicBlock"><tt>BasicBlock</tt></a>s in a <a
  href="#Function"><tt>Function</tt></a>
</h4>

<div>

<p>It's quite common to have a <tt>Function</tt> instance that you'd like to
transform in some way; in particular, you'd like to manipulate its
<tt>BasicBlock</tt>s.  To facilitate this, you'll need to iterate over all of
the <tt>BasicBlock</tt>s that constitute the <tt>Function</tt>. The following is
an example that prints the name of a <tt>BasicBlock</tt> and the number of
<tt>Instruction</tt>s it contains:</p>

<div class="doc_code">
<pre>
// <i>func is a pointer to a Function instance</i>
for (Function::iterator i = func-&gt;begin(), e = func-&gt;end(); i != e; ++i)
  // <i>Print out the name of the basic block if it has one, and then the</i>
  // <i>number of instructions that it contains</i>
  errs() &lt;&lt; "Basic block (name=" &lt;&lt; i-&gt;getName() &lt;&lt; ") has "
             &lt;&lt; i-&gt;size() &lt;&lt; " instructions.\n";
</pre>
</div>

<p>Note that i can be used as if it were a pointer for the purposes of
invoking member functions of the <tt>Instruction</tt> class.  This is
because the indirection operator is overloaded for the iterator
classes.  In the above code, the expression <tt>i-&gt;size()</tt> is
exactly equivalent to <tt>(*i).size()</tt> just like you'd expect.</p>

</div>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="iterate_basicblock">Iterating over the </a><a
  href="#Instruction"><tt>Instruction</tt></a>s in a <a
  href="#BasicBlock"><tt>BasicBlock</tt></a>
</h4>

<div>

<p>Just like when dealing with <tt>BasicBlock</tt>s in <tt>Function</tt>s, it's
easy to iterate over the individual instructions that make up
<tt>BasicBlock</tt>s. Here's a code snippet that prints out each instruction in
a <tt>BasicBlock</tt>:</p>

<div class="doc_code">
<pre>
// <i>blk is a pointer to a BasicBlock instance</i>
for (BasicBlock::iterator i = blk-&gt;begin(), e = blk-&gt;end(); i != e; ++i)
   // <i>The next statement works since operator&lt;&lt;(ostream&amp;,...)</i>
   // <i>is overloaded for Instruction&amp;</i>
   errs() &lt;&lt; *i &lt;&lt; "\n";
</pre>
</div>

<p>However, this isn't really the best way to print out the contents of a
<tt>BasicBlock</tt>!  Since the ostream operators are overloaded for virtually
anything you'll care about, you could have just invoked the print routine on the
basic block itself: <tt>errs() &lt;&lt; *blk &lt;&lt; "\n";</tt>.</p>

</div>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="iterate_institer">Iterating over the </a><a
  href="#Instruction"><tt>Instruction</tt></a>s in a <a
  href="#Function"><tt>Function</tt></a>
</h4>

<div>

<p>If you're finding that you commonly iterate over a <tt>Function</tt>'s
<tt>BasicBlock</tt>s and then that <tt>BasicBlock</tt>'s <tt>Instruction</tt>s,
<tt>InstIterator</tt> should be used instead. You'll need to include <a
href="/doxygen/InstIterator_8h-source.html"><tt>llvm/Support/InstIterator.h</tt></a>,
and then instantiate <tt>InstIterator</tt>s explicitly in your code.  Here's a
small example that shows how to dump all instructions in a function to the standard error stream:<p>

<div class="doc_code">
<pre>
#include "<a href="/doxygen/InstIterator_8h-source.html">llvm/Support/InstIterator.h</a>"

// <i>F is a pointer to a Function instance</i>
for (inst_iterator I = inst_begin(F), E = inst_end(F); I != E; ++I)
  errs() &lt;&lt; *I &lt;&lt; "\n";
</pre>
</div>

<p>Easy, isn't it?  You can also use <tt>InstIterator</tt>s to fill a
work list with its initial contents.  For example, if you wanted to
initialize a work list to contain all instructions in a <tt>Function</tt>
F, all you would need to do is something like:</p>

<div class="doc_code">
<pre>
std::set&lt;Instruction*&gt; worklist;
// or better yet, SmallPtrSet&lt;Instruction*, 64&gt; worklist;

for (inst_iterator I = inst_begin(F), E = inst_end(F); I != E; ++I)
   worklist.insert(&amp;*I);
</pre>
</div>

<p>The STL set <tt>worklist</tt> would now contain all instructions in the
<tt>Function</tt> pointed to by F.</p>

</div>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="iterate_convert">Turning an iterator into a class pointer (and
  vice-versa)</a>
</h4>

<div>

<p>Sometimes, it'll be useful to grab a reference (or pointer) to a class
instance when all you've got at hand is an iterator.  Well, extracting
a reference or a pointer from an iterator is very straight-forward.
Assuming that <tt>i</tt> is a <tt>BasicBlock::iterator</tt> and <tt>j</tt>
is a <tt>BasicBlock::const_iterator</tt>:</p>

<div class="doc_code">
<pre>
Instruction&amp; inst = *i;   // <i>Grab reference to instruction reference</i>
Instruction* pinst = &amp;*i; // <i>Grab pointer to instruction reference</i>
const Instruction&amp; inst = *j;
</pre>
</div>

<p>However, the iterators you'll be working with in the LLVM framework are
special: they will automatically convert to a ptr-to-instance type whenever they
need to.  Instead of dereferencing the iterator and then taking the address of
the result, you can simply assign the iterator to the proper pointer type and
you get the dereference and address-of operation as a result of the assignment
(behind the scenes, this is a result of overloading casting mechanisms).  Thus
the last line of the last example,</p>

<div class="doc_code">
<pre>
Instruction *pinst = &amp;*i;
</pre>
</div>

<p>is semantically equivalent to</p>

<div class="doc_code">
<pre>
Instruction *pinst = i;
</pre>
</div>

<p>It's also possible to turn a class pointer into the corresponding iterator,
and this is a constant time operation (very efficient).  The following code
snippet illustrates use of the conversion constructors provided by LLVM
iterators.  By using these, you can explicitly grab the iterator of something
without actually obtaining it via iteration over some structure:</p>

<div class="doc_code">
<pre>
void printNextInstruction(Instruction* inst) {
  BasicBlock::iterator it(inst);
  ++it; // <i>After this line, it refers to the instruction after *inst</i>
  if (it != inst-&gt;getParent()-&gt;end()) errs() &lt;&lt; *it &lt;&lt; "\n";
}
</pre>
</div>

<p>Unfortunately, these implicit conversions come at a cost; they prevent
these iterators from conforming to standard iterator conventions, and thus
from being usable with standard algorithms and containers. For example, they
prevent the following code, where <tt>B</tt> is a <tt>BasicBlock</tt>,
from compiling:</p>

<div class="doc_code">
<pre>
  llvm::SmallVector&lt;llvm::Instruction *, 16&gt;(B-&gt;begin(), B-&gt;end());
</pre>
</div>

<p>Because of this, these implicit conversions may be removed some day,
and <tt>operator*</tt> changed to return a pointer instead of a reference.</p>

</div>

<!--_______________________________________________________________________-->
<h4>
  <a name="iterate_complex">Finding call sites: a slightly more complex
  example</a>
</h4>

<div>

<p>Say that you're writing a FunctionPass and would like to count all the
locations in the entire module (that is, across every <tt>Function</tt>) where a
certain function (i.e., some <tt>Function</tt>*) is already in scope.  As you'll
learn later, you may want to use an <tt>InstVisitor</tt> to accomplish this in a
much more straight-forward manner, but this example will allow us to explore how
you'd do it if you didn't have <tt>InstVisitor</tt> around. In pseudo-code, this
is what we want to do:</p>

<div class="doc_code">
<pre>
initialize callCounter to zero
for each Function f in the Module
  for each BasicBlock b in f
    for each Instruction i in b
      if (i is a CallInst and calls the given function)
        increment callCounter
</pre>
</div>

<p>And the actual code is (remember, because we're writing a
<tt>FunctionPass</tt>, our <tt>FunctionPass</tt>-derived class simply has to
override the <tt>runOnFunction</tt> method):</p>

<div class="doc_code">
<pre>
Function* targetFunc = ...;

class OurFunctionPass : public FunctionPass {
  public:
    OurFunctionPass(): callCounter(0) { }

    virtual runOnFunction(Function&amp; F) {
      for (Function::iterator b = F.begin(), be = F.end(); b != be; ++b) {
        for (BasicBlock::iterator i = b-&gt;begin(), ie = b-&gt;end(); i != ie; ++i) {
          if (<a href="#CallInst">CallInst</a>* callInst = <a href="#isa">dyn_cast</a>&lt;<a
 href="#CallInst">CallInst</a>&gt;(&amp;*i)) {
            // <i>We know we've encountered a call instruction, so we</i>
            // <i>need to determine if it's a call to the</i>
            // <i>function pointed to by m_func or not.</i>
            if (callInst-&gt;getCalledFunction() == targetFunc)
              ++callCounter;
          }
        }
      }
    }

  private:
    unsigned callCounter;
};
</pre>
</div>

</div>

<!--_______________________________________________________________________-->
<h4>
  <a name="calls_and_invokes">Treating calls and invokes the same way</a>
</h4>

<div>

<p>You may have noticed that the previous example was a bit oversimplified in
that it did not deal with call sites generated by 'invoke' instructions. In
this, and in other situations, you may find that you want to treat
<tt>CallInst</tt>s and <tt>InvokeInst</tt>s the same way, even though their
most-specific common base class is <tt>Instruction</tt>, which includes lots of
less closely-related things. For these cases, LLVM provides a handy wrapper
class called <a
href="http://llvm.org/doxygen/classllvm_1_1CallSite.html"><tt>CallSite</tt></a>.
It is essentially a wrapper around an <tt>Instruction</tt> pointer, with some
methods that provide functionality common to <tt>CallInst</tt>s and
<tt>InvokeInst</tt>s.</p>

<p>This class has "value semantics": it should be passed by value, not by
reference and it should not be dynamically allocated or deallocated using
<tt>operator new</tt> or <tt>operator delete</tt>. It is efficiently copyable,
assignable and constructable, with costs equivalents to that of a bare pointer.
If you look at its definition, it has only a single pointer member.</p>

</div>

<!--_______________________________________________________________________-->
<h4>
  <a name="iterate_chains">Iterating over def-use &amp; use-def chains</a>
</h4>

<div>

<p>Frequently, we might have an instance of the <a
href="/doxygen/classllvm_1_1Value.html">Value Class</a> and we want to
determine which <tt>User</tt>s use the <tt>Value</tt>.  The list of all
<tt>User</tt>s of a particular <tt>Value</tt> is called a <i>def-use</i> chain.
For example, let's say we have a <tt>Function*</tt> named <tt>F</tt> to a
particular function <tt>foo</tt>. Finding all of the instructions that
<i>use</i> <tt>foo</tt> is as simple as iterating over the <i>def-use</i> chain
of <tt>F</tt>:</p>

<div class="doc_code">
<pre>
Function *F = ...;

for (Value::use_iterator i = F-&gt;use_begin(), e = F-&gt;use_end(); i != e; ++i)
  if (Instruction *Inst = dyn_cast&lt;Instruction&gt;(*i)) {
    errs() &lt;&lt; "F is used in instruction:\n";
    errs() &lt;&lt; *Inst &lt;&lt; "\n";
  }
</pre>
</div>

<p>Note that dereferencing a <tt>Value::use_iterator</tt> is not a very cheap
operation. Instead of performing <tt>*i</tt> above several times, consider
doing it only once in the loop body and reusing its result.</p>

<p>Alternatively, it's common to have an instance of the <a
href="/doxygen/classllvm_1_1User.html">User Class</a> and need to know what
<tt>Value</tt>s are used by it.  The list of all <tt>Value</tt>s used by a
<tt>User</tt> is known as a <i>use-def</i> chain.  Instances of class
<tt>Instruction</tt> are common <tt>User</tt>s, so we might want to iterate over
all of the values that a particular instruction uses (that is, the operands of
the particular <tt>Instruction</tt>):</p>

<div class="doc_code">
<pre>
Instruction *pi = ...;

for (User::op_iterator i = pi-&gt;op_begin(), e = pi-&gt;op_end(); i != e; ++i) {
  Value *v = *i;
  // <i>...</i>
}
</pre>
</div>

<p>Declaring objects as <tt>const</tt> is an important tool of enforcing
mutation free algorithms (such as analyses, etc.). For this purpose above
iterators come in constant flavors as <tt>Value::const_use_iterator</tt>
and <tt>Value::const_op_iterator</tt>.  They automatically arise when
calling <tt>use/op_begin()</tt> on <tt>const Value*</tt>s or
<tt>const User*</tt>s respectively.  Upon dereferencing, they return
<tt>const Use*</tt>s. Otherwise the above patterns remain unchanged.</p>

</div>

<!--_______________________________________________________________________-->
<h4>
  <a name="iterate_preds">Iterating over predecessors &amp;
successors of blocks</a>
</h4>

<div>

<p>Iterating over the predecessors and successors of a block is quite easy
with the routines defined in <tt>"llvm/Support/CFG.h"</tt>.  Just use code like
this to iterate over all predecessors of BB:</p>

<div class="doc_code">
<pre>
#include "llvm/Support/CFG.h"
BasicBlock *BB = ...;

for (pred_iterator PI = pred_begin(BB), E = pred_end(BB); PI != E; ++PI) {
  BasicBlock *Pred = *PI;
  // <i>...</i>
}
</pre>
</div>

<p>Similarly, to iterate over successors use
succ_iterator/succ_begin/succ_end.</p>

</div>

</div>

<!-- ======================================================================= -->
<h3>
  <a name="simplechanges">Making simple changes</a>
</h3>

<div>

<p>There are some primitive transformation operations present in the LLVM
infrastructure that are worth knowing about.  When performing
transformations, it's fairly common to manipulate the contents of basic
blocks. This section describes some of the common methods for doing so
and gives example code.</p>

<!--_______________________________________________________________________-->
<h4>
  <a name="schanges_creating">Creating and inserting new
  <tt>Instruction</tt>s</a>
</h4>

<div>

<p><i>Instantiating Instructions</i></p>

<p>Creation of <tt>Instruction</tt>s is straight-forward: simply call the
constructor for the kind of instruction to instantiate and provide the necessary
parameters. For example, an <tt>AllocaInst</tt> only <i>requires</i> a
(const-ptr-to) <tt>Type</tt>. Thus:</p> 

<div class="doc_code">
<pre>
AllocaInst* ai = new AllocaInst(Type::Int32Ty);
</pre>
</div>

<p>will create an <tt>AllocaInst</tt> instance that represents the allocation of
one integer in the current stack frame, at run time. Each <tt>Instruction</tt>
subclass is likely to have varying default parameters which change the semantics
of the instruction, so refer to the <a
href="/doxygen/classllvm_1_1Instruction.html">doxygen documentation for the subclass of
Instruction</a> that you're interested in instantiating.</p>

<p><i>Naming values</i></p>

<p>It is very useful to name the values of instructions when you're able to, as
this facilitates the debugging of your transformations.  If you end up looking
at generated LLVM machine code, you definitely want to have logical names
associated with the results of instructions!  By supplying a value for the
<tt>Name</tt> (default) parameter of the <tt>Instruction</tt> constructor, you
associate a logical name with the result of the instruction's execution at
run time.  For example, say that I'm writing a transformation that dynamically
allocates space for an integer on the stack, and that integer is going to be
used as some kind of index by some other code.  To accomplish this, I place an
<tt>AllocaInst</tt> at the first point in the first <tt>BasicBlock</tt> of some
<tt>Function</tt>, and I'm intending to use it within the same
<tt>Function</tt>. I might do:</p>

<div class="doc_code">
<pre>
AllocaInst* pa = new AllocaInst(Type::Int32Ty, 0, "indexLoc");
</pre>
</div>

<p>where <tt>indexLoc</tt> is now the logical name of the instruction's
execution value, which is a pointer to an integer on the run time stack.</p>

<p><i>Inserting instructions</i></p>

<p>There are essentially two ways to insert an <tt>Instruction</tt>
into an existing sequence of instructions that form a <tt>BasicBlock</tt>:</p>

<ul>
  <li>Insertion into an explicit instruction list

    <p>Given a <tt>BasicBlock* pb</tt>, an <tt>Instruction* pi</tt> within that
    <tt>BasicBlock</tt>, and a newly-created instruction we wish to insert
    before <tt>*pi</tt>, we do the following: </p>

<div class="doc_code">
<pre>
BasicBlock *pb = ...;
Instruction *pi = ...;
Instruction *newInst = new Instruction(...);

pb-&gt;getInstList().insert(pi, newInst); // <i>Inserts newInst before pi in pb</i>
</pre>
</div>

    <p>Appending to the end of a <tt>BasicBlock</tt> is so common that
    the <tt>Instruction</tt> class and <tt>Instruction</tt>-derived
    classes provide constructors which take a pointer to a
    <tt>BasicBlock</tt> to be appended to. For example code that
    looked like: </p>

<div class="doc_code">
<pre>
BasicBlock *pb = ...;
Instruction *newInst = new Instruction(...);

pb-&gt;getInstList().push_back(newInst); // <i>Appends newInst to pb</i>
</pre>
</div>

    <p>becomes: </p>

<div class="doc_code">
<pre>
BasicBlock *pb = ...;
Instruction *newInst = new Instruction(..., pb);
</pre>
</div>

    <p>which is much cleaner, especially if you are creating
    long instruction streams.</p></li>

  <li>Insertion into an implicit instruction list

    <p><tt>Instruction</tt> instances that are already in <tt>BasicBlock</tt>s
    are implicitly associated with an existing instruction list: the instruction
    list of the enclosing basic block. Thus, we could have accomplished the same
    thing as the above code without being given a <tt>BasicBlock</tt> by doing:
    </p>

<div class="doc_code">
<pre>
Instruction *pi = ...;
Instruction *newInst = new Instruction(...);

pi-&gt;getParent()-&gt;getInstList().insert(pi, newInst);
</pre>
</div>

    <p>In fact, this sequence of steps occurs so frequently that the
    <tt>Instruction</tt> class and <tt>Instruction</tt>-derived classes provide
    constructors which take (as a default parameter) a pointer to an
    <tt>Instruction</tt> which the newly-created <tt>Instruction</tt> should
    precede.  That is, <tt>Instruction</tt> constructors are capable of
    inserting the newly-created instance into the <tt>BasicBlock</tt> of a
    provided instruction, immediately before that instruction.  Using an
    <tt>Instruction</tt> constructor with a <tt>insertBefore</tt> (default)
    parameter, the above code becomes:</p>

<div class="doc_code">
<pre>
Instruction* pi = ...;
Instruction* newInst = new Instruction(..., pi);
</pre>
</div>

    <p>which is much cleaner, especially if you're creating a lot of
    instructions and adding them to <tt>BasicBlock</tt>s.</p></li>
</ul>

</div>

<!--_______________________________________________________________________-->
<h4>
  <a name="schanges_deleting">Deleting <tt>Instruction</tt>s</a>
</h4>

<div>

<p>Deleting an instruction from an existing sequence of instructions that form a
<a href="#BasicBlock"><tt>BasicBlock</tt></a> is very straight-forward: just
call the instruction's eraseFromParent() method.  For example:</p>

<div class="doc_code">
<pre>
<a href="#Instruction">Instruction</a> *I = .. ;
I-&gt;eraseFromParent();
</pre>
</div>

<p>This unlinks the instruction from its containing basic block and deletes 
it.  If you'd just like to unlink the instruction from its containing basic
block but not delete it, you can use the <tt>removeFromParent()</tt> method.</p>

</div>

<!--_______________________________________________________________________-->
<h4>
  <a name="schanges_replacing">Replacing an <tt>Instruction</tt> with another
  <tt>Value</tt></a>
</h4>

<div>

<h5><i>Replacing individual instructions</i></h5>

<p>Including "<a href="/doxygen/BasicBlockUtils_8h-source.html">llvm/Transforms/Utils/BasicBlockUtils.h</a>"
permits use of two very useful replace functions: <tt>ReplaceInstWithValue</tt>
and <tt>ReplaceInstWithInst</tt>.</p>

<h5><a name="schanges_deleting">Deleting <tt>Instruction</tt>s</a></h5>

<div>
<ul>
  <li><tt>ReplaceInstWithValue</tt>

    <p>This function replaces all uses of a given instruction with a value,
    and then removes the original instruction. The following example
    illustrates the replacement of the result of a particular
    <tt>AllocaInst</tt> that allocates memory for a single integer with a null
    pointer to an integer.</p>

<div class="doc_code">
<pre>
AllocaInst* instToReplace = ...;
BasicBlock::iterator ii(instToReplace);

ReplaceInstWithValue(instToReplace-&gt;getParent()-&gt;getInstList(), ii,
                     Constant::getNullValue(PointerType::getUnqual(Type::Int32Ty)));
</pre></div></li>

  <li><tt>ReplaceInstWithInst</tt> 

    <p>This function replaces a particular instruction with another
    instruction, inserting the new instruction into the basic block at the
    location where the old instruction was, and replacing any uses of the old
    instruction with the new instruction. The following example illustrates
    the replacement of one <tt>AllocaInst</tt> with another.</p>

<div class="doc_code">
<pre>
AllocaInst* instToReplace = ...;
BasicBlock::iterator ii(instToReplace);

ReplaceInstWithInst(instToReplace-&gt;getParent()-&gt;getInstList(), ii,
                    new AllocaInst(Type::Int32Ty, 0, "ptrToReplacedInt"));
</pre></div></li>
</ul>

</div>

<h5><i>Replacing multiple uses of <tt>User</tt>s and <tt>Value</tt>s</i></h5>

<p>You can use <tt>Value::replaceAllUsesWith</tt> and
<tt>User::replaceUsesOfWith</tt> to change more than one use at a time.  See the
doxygen documentation for the <a href="/doxygen/classllvm_1_1Value.html">Value Class</a>
and <a href="/doxygen/classllvm_1_1User.html">User Class</a>, respectively, for more
information.</p>

<!-- Value::replaceAllUsesWith User::replaceUsesOfWith Point out:
include/llvm/Transforms/Utils/ especially BasicBlockUtils.h with:
ReplaceInstWithValue, ReplaceInstWithInst -->

</div>

<!--_______________________________________________________________________-->
<h4>
  <a name="schanges_deletingGV">Deleting <tt>GlobalVariable</tt>s</a>
</h4>

<div>

<p>Deleting a global variable from a module is just as easy as deleting an 
Instruction. First, you must have a pointer to the global variable that you wish
 to delete.  You use this pointer to erase it from its parent, the module.
 For example:</p>

<div class="doc_code">
<pre>
<a href="#GlobalVariable">GlobalVariable</a> *GV = .. ;

GV-&gt;eraseFromParent();
</pre>
</div>

</div>

</div>

<!-- ======================================================================= -->
<h3>
  <a name="create_types">How to Create Types</a>
</h3>

<div>

<p>In generating IR, you may need some complex types.  If you know these types
statically, you can use <tt>TypeBuilder&lt;...&gt;::get()</tt>, defined
in <tt>llvm/Support/TypeBuilder.h</tt>, to retrieve them.  <tt>TypeBuilder</tt>
has two forms depending on whether you're building types for cross-compilation
or native library use.  <tt>TypeBuilder&lt;T, true&gt;</tt> requires
that <tt>T</tt> be independent of the host environment, meaning that it's built
out of types from
the <a href="/doxygen/namespacellvm_1_1types.html"><tt>llvm::types</tt></a>
namespace and pointers, functions, arrays, etc. built of
those.  <tt>TypeBuilder&lt;T, false&gt;</tt> additionally allows native C types
whose size may depend on the host compiler.  For example,</p>

<div class="doc_code">
<pre>
FunctionType *ft = TypeBuilder&lt;types::i&lt;8&gt;(types::i&lt;32&gt;*), true&gt;::get();
</pre>
</div>

<p>is easier to read and write than the equivalent</p>

<div class="doc_code">
<pre>
std::vector&lt;const Type*&gt; params;
params.push_back(PointerType::getUnqual(Type::Int32Ty));
FunctionType *ft = FunctionType::get(Type::Int8Ty, params, false);
</pre>
</div>

<p>See the <a href="/doxygen/TypeBuilder_8h-source.html#l00001">class
comment</a> for more details.</p>

</div>

</div>

<!-- *********************************************************************** -->
<h2>
  <a name="threading">Threads and LLVM</a>
</h2>
<!-- *********************************************************************** -->

<div>
<p>
This section describes the interaction of the LLVM APIs with multithreading,
both on the part of client applications, and in the JIT, in the hosted
application.
</p>

<p>
Note that LLVM's support for multithreading is still relatively young.  Up 
through version 2.5, the execution of threaded hosted applications was
supported, but not threaded client access to the APIs.  While this use case is
now supported, clients <em>must</em> adhere to the guidelines specified below to
ensure proper operation in multithreaded mode.
</p>

<p>
Note that, on Unix-like platforms, LLVM requires the presence of GCC's atomic
intrinsics in order to support threaded operation.  If you need a
multhreading-capable LLVM on a platform without a suitably modern system
compiler, consider compiling LLVM and LLVM-GCC in single-threaded mode, and 
using the resultant compiler to build a copy of LLVM with multithreading
support.
</p>

<!-- ======================================================================= -->
<h3>
  <a name="startmultithreaded">Entering and Exiting Multithreaded Mode</a>
</h3>

<div>

<p>
In order to properly protect its internal data structures while avoiding 
excessive locking overhead in the single-threaded case, the LLVM must intialize
certain data structures necessary to provide guards around its internals.  To do
so, the client program must invoke <tt>llvm_start_multithreaded()</tt> before
making any concurrent LLVM API calls.  To subsequently tear down these
structures, use the <tt>llvm_stop_multithreaded()</tt> call.  You can also use
the <tt>llvm_is_multithreaded()</tt> call to check the status of multithreaded
mode.
</p>

<p>
Note that both of these calls must be made <em>in isolation</em>.  That is to
say that no other LLVM API calls may be executing at any time during the 
execution of <tt>llvm_start_multithreaded()</tt> or <tt>llvm_stop_multithreaded
</tt>.  It's is the client's responsibility to enforce this isolation.
</p>

<p>
The return value of <tt>llvm_start_multithreaded()</tt> indicates the success or
failure of the initialization.  Failure typically indicates that your copy of
LLVM was built without multithreading support, typically because GCC atomic
intrinsics were not found in your system compiler.  In this case, the LLVM API
will not be safe for concurrent calls.  However, it <em>will</em> be safe for
hosting threaded applications in the JIT, though <a href="#jitthreading">care
must be taken</a> to ensure that side exits and the like do not accidentally
result in concurrent LLVM API calls.
</p>
</div>

<!-- ======================================================================= -->
<h3>
  <a name="shutdown">Ending Execution with <tt>llvm_shutdown()</tt></a>
</h3>

<div>
<p>
When you are done using the LLVM APIs, you should call <tt>llvm_shutdown()</tt>
to deallocate memory used for internal structures.  This will also invoke 
<tt>llvm_stop_multithreaded()</tt> if LLVM is operating in multithreaded mode.
As such, <tt>llvm_shutdown()</tt> requires the same isolation guarantees as
<tt>llvm_stop_multithreaded()</tt>.
</p>

<p>
Note that, if you use scope-based shutdown, you can use the
<tt>llvm_shutdown_obj</tt> class, which calls <tt>llvm_shutdown()</tt> in its
destructor.
</div>

<!-- ======================================================================= -->
<h3>
  <a name="managedstatic">Lazy Initialization with <tt>ManagedStatic</tt></a>
</h3>

<div>
<p>
<tt>ManagedStatic</tt> is a utility class in LLVM used to implement static
initialization of static resources, such as the global type tables.  Before the
invocation of <tt>llvm_shutdown()</tt>, it implements a simple lazy 
initialization scheme.  Once <tt>llvm_start_multithreaded()</tt> returns,
however, it uses double-checked locking to implement thread-safe lazy
initialization.
</p>

<p>
Note that, because no other threads are allowed to issue LLVM API calls before
<tt>llvm_start_multithreaded()</tt> returns, it is possible to have 
<tt>ManagedStatic</tt>s of <tt>llvm::sys::Mutex</tt>s.
</p>

<p>
The <tt>llvm_acquire_global_lock()</tt> and <tt>llvm_release_global_lock</tt> 
APIs provide access to the global lock used to implement the double-checked
locking for lazy initialization.  These should only be used internally to LLVM,
and only if you know what you're doing!
</p>
</div>

<!-- ======================================================================= -->
<h3>
  <a name="llvmcontext">Achieving Isolation with <tt>LLVMContext</tt></a>
</h3>

<div>
<p>
<tt>LLVMContext</tt> is an opaque class in the LLVM API which clients can use
to operate multiple, isolated instances of LLVM concurrently within the same
address space.  For instance, in a hypothetical compile-server, the compilation
of an individual translation unit is conceptually independent from all the 
others, and it would be desirable to be able to compile incoming translation 
units concurrently on independent server threads.  Fortunately, 
<tt>LLVMContext</tt> exists to enable just this kind of scenario!
</p>

<p>
Conceptually, <tt>LLVMContext</tt> provides isolation.  Every LLVM entity 
(<tt>Module</tt>s, <tt>Value</tt>s, <tt>Type</tt>s, <tt>Constant</tt>s, etc.)
in LLVM's in-memory IR belongs to an <tt>LLVMContext</tt>.  Entities in 
different contexts <em>cannot</em> interact with each other: <tt>Module</tt>s in
different contexts cannot be linked together, <tt>Function</tt>s cannot be added
to <tt>Module</tt>s in different contexts, etc.  What this means is that is is
safe to compile on multiple threads simultaneously, as long as no two threads
operate on entities within the same context.
</p>

<p>
In practice, very few places in the API require the explicit specification of a
<tt>LLVMContext</tt>, other than the <tt>Type</tt> creation/lookup APIs.
Because every <tt>Type</tt> carries a reference to its owning context, most
other entities can determine what context they belong to by looking at their
own <tt>Type</tt>.  If you are adding new entities to LLVM IR, please try to
maintain this interface design.
</p>

<p>
For clients that do <em>not</em> require the benefits of isolation, LLVM 
provides a convenience API <tt>getGlobalContext()</tt>.  This returns a global,
lazily initialized <tt>LLVMContext</tt> that may be used in situations where
isolation is not a concern.
</p>
</div>

<!-- ======================================================================= -->
<h3>
  <a name="jitthreading">Threads and the JIT</a>
</h3>

<div>
<p>
LLVM's "eager" JIT compiler is safe to use in threaded programs.  Multiple
threads can call <tt>ExecutionEngine::getPointerToFunction()</tt> or
<tt>ExecutionEngine::runFunction()</tt> concurrently, and multiple threads can
run code output by the JIT concurrently.  The user must still ensure that only
one thread accesses IR in a given <tt>LLVMContext</tt> while another thread
might be modifying it.  One way to do that is to always hold the JIT lock while
accessing IR outside the JIT (the JIT <em>modifies</em> the IR by adding
<tt>CallbackVH</tt>s).  Another way is to only
call <tt>getPointerToFunction()</tt> from the <tt>LLVMContext</tt>'s thread.
</p>

<p>When the JIT is configured to compile lazily (using
<tt>ExecutionEngine::DisableLazyCompilation(false)</tt>), there is currently a
<a href="http://llvm.org/bugs/show_bug.cgi?id=5184">race condition</a> in
updating call sites after a function is lazily-jitted.  It's still possible to
use the lazy JIT in a threaded program if you ensure that only one thread at a
time can call any particular lazy stub and that the JIT lock guards any IR
access, but we suggest using only the eager JIT in threaded programs.
</p>
</div>

</div>

<!-- *********************************************************************** -->
<h2>
  <a name="advanced">Advanced Topics</a>
</h2>
<!-- *********************************************************************** -->

<div>
<p>
This section describes some of the advanced or obscure API's that most clients
do not need to be aware of.  These API's tend manage the inner workings of the
LLVM system, and only need to be accessed in unusual circumstances.
</p>

  
<!-- ======================================================================= -->
<h3>
  <a name="SymbolTable">The <tt>ValueSymbolTable</tt> class</a>
</h3>

<div>
<p>The <tt><a href="http://llvm.org/doxygen/classllvm_1_1ValueSymbolTable.html">
ValueSymbolTable</a></tt> class provides a symbol table that the <a
href="#Function"><tt>Function</tt></a> and <a href="#Module">
<tt>Module</tt></a> classes use for naming value definitions. The symbol table
can provide a name for any <a href="#Value"><tt>Value</tt></a>. 
</p>

<p>Note that the <tt>SymbolTable</tt> class should not be directly accessed 
by most clients.  It should only be used when iteration over the symbol table 
names themselves are required, which is very special purpose.  Note that not 
all LLVM
<tt><a href="#Value">Value</a></tt>s have names, and those without names (i.e. they have
an empty name) do not exist in the symbol table.
</p>

<p>Symbol tables support iteration over the values in the symbol
table with <tt>begin/end/iterator</tt> and supports querying to see if a
specific name is in the symbol table (with <tt>lookup</tt>).  The
<tt>ValueSymbolTable</tt> class exposes no public mutator methods, instead,
simply call <tt>setName</tt> on a value, which will autoinsert it into the
appropriate symbol table.</p>

</div>



<!-- ======================================================================= -->
<h3>
  <a name="UserLayout">The <tt>User</tt> and owned <tt>Use</tt> classes' memory layout</a>
</h3>

<div>
<p>The <tt><a href="http://llvm.org/doxygen/classllvm_1_1User.html">
User</a></tt> class provides a basis for expressing the ownership of <tt>User</tt>
towards other <tt><a href="http://llvm.org/doxygen/classllvm_1_1Value.html">
Value</a></tt>s. The <tt><a href="http://llvm.org/doxygen/classllvm_1_1Use.html">
Use</a></tt> helper class is employed to do the bookkeeping and to facilitate <i>O(1)</i>
addition and removal.</p>

<!-- ______________________________________________________________________ -->
<h4>
  <a name="Use2User">
    Interaction and relationship between <tt>User</tt> and <tt>Use</tt> objects
  </a>
</h4>

<div>
<p>
A subclass of <tt>User</tt> can choose between incorporating its <tt>Use</tt> objects
or refer to them out-of-line by means of a pointer. A mixed variant
(some <tt>Use</tt>s inline others hung off) is impractical and breaks the invariant
that the <tt>Use</tt> objects belonging to the same <tt>User</tt> form a contiguous array.
</p>

<p>
We have 2 different layouts in the <tt>User</tt> (sub)classes:
<ul>
<li><p>Layout a)
The <tt>Use</tt> object(s) are inside (resp. at fixed offset) of the <tt>User</tt>
object and there are a fixed number of them.</p>

<li><p>Layout b)
The <tt>Use</tt> object(s) are referenced by a pointer to an
array from the <tt>User</tt> object and there may be a variable
number of them.</p>
</ul>
<p>
As of v2.4 each layout still possesses a direct pointer to the
start of the array of <tt>Use</tt>s. Though not mandatory for layout a),
we stick to this redundancy for the sake of simplicity.
The <tt>User</tt> object also stores the number of <tt>Use</tt> objects it
has. (Theoretically this information can also be calculated
given the scheme presented below.)</p>
<p>
Special forms of allocation operators (<tt>operator new</tt>)
enforce the following memory layouts:</p>

<ul>
<li><p>Layout a) is modelled by prepending the <tt>User</tt> object by the <tt>Use[]</tt> array.</p>

<pre>
...---.---.---.---.-------...
  | P | P | P | P | User
'''---'---'---'---'-------'''
</pre>

<li><p>Layout b) is modelled by pointing at the <tt>Use[]</tt> array.</p>
<pre>
.-------...
| User
'-------'''
    |
    v
    .---.---.---.---...
    | P | P | P | P |
    '---'---'---'---'''
</pre>
</ul>
<i>(In the above figures '<tt>P</tt>' stands for the <tt>Use**</tt> that
    is stored in each <tt>Use</tt> object in the member <tt>Use::Prev</tt>)</i>

</div>

<!-- ______________________________________________________________________ -->
<h4>
  <a name="Waymarking">The waymarking algorithm</a>
</h4>

<div>
<p>
Since the <tt>Use</tt> objects are deprived of the direct (back)pointer to
their <tt>User</tt> objects, there must be a fast and exact method to
recover it. This is accomplished by the following scheme:</p>

A bit-encoding in the 2 LSBits (least significant bits) of the <tt>Use::Prev</tt> allows to find the
start of the <tt>User</tt> object:
<ul>
<li><tt>00</tt> &mdash;&gt; binary digit 0</li>
<li><tt>01</tt> &mdash;&gt; binary digit 1</li>
<li><tt>10</tt> &mdash;&gt; stop and calculate (<tt>s</tt>)</li>
<li><tt>11</tt> &mdash;&gt; full stop (<tt>S</tt>)</li>
</ul>
<p>
Given a <tt>Use*</tt>, all we have to do is to walk till we get
a stop and we either have a <tt>User</tt> immediately behind or
we have to walk to the next stop picking up digits
and calculating the offset:</p>
<pre>
.---.---.---.---.---.---.---.---.---.---.---.---.---.---.---.---.----------------
| 1 | s | 1 | 0 | 1 | 0 | s | 1 | 1 | 0 | s | 1 | 1 | s | 1 | S | User (or User*)
'---'---'---'---'---'---'---'---'---'---'---'---'---'---'---'---'----------------
    |+15                |+10            |+6         |+3     |+1
    |                   |               |           |       |__>
    |                   |               |           |__________>
    |                   |               |______________________>
    |                   |______________________________________>
    |__________________________________________________________>
</pre>
<p>
Only the significant number of bits need to be stored between the
stops, so that the <i>worst case is 20 memory accesses</i> when there are
1000 <tt>Use</tt> objects associated with a <tt>User</tt>.</p>

</div>

<!-- ______________________________________________________________________ -->
<h4>
  <a name="ReferenceImpl">Reference implementation</a>
</h4>

<div>
<p>
The following literate Haskell fragment demonstrates the concept:</p>

<div class="doc_code">
<pre>
> import Test.QuickCheck
> 
> digits :: Int -> [Char] -> [Char]
> digits 0 acc = '0' : acc
> digits 1 acc = '1' : acc
> digits n acc = digits (n `div` 2) $ digits (n `mod` 2) acc
> 
> dist :: Int -> [Char] -> [Char]
> dist 0 [] = ['S']
> dist 0 acc = acc
> dist 1 acc = let r = dist 0 acc in 's' : digits (length r) r
> dist n acc = dist (n - 1) $ dist 1 acc
> 
> takeLast n ss = reverse $ take n $ reverse ss
> 
> test = takeLast 40 $ dist 20 []
> 
</pre>
</div>
<p>
Printing &lt;test&gt; gives: <tt>"1s100000s11010s10100s1111s1010s110s11s1S"</tt></p>
<p>
The reverse algorithm computes the length of the string just by examining
a certain prefix:</p>

<div class="doc_code">
<pre>
> pref :: [Char] -> Int
> pref "S" = 1
> pref ('s':'1':rest) = decode 2 1 rest
> pref (_:rest) = 1 + pref rest
> 
> decode walk acc ('0':rest) = decode (walk + 1) (acc * 2) rest
> decode walk acc ('1':rest) = decode (walk + 1) (acc * 2 + 1) rest
> decode walk acc _ = walk + acc
> 
</pre>
</div>
<p>
Now, as expected, printing &lt;pref test&gt; gives <tt>40</tt>.</p>
<p>
We can <i>quickCheck</i> this with following property:</p>

<div class="doc_code">
<pre>
> testcase = dist 2000 []
> testcaseLength = length testcase
> 
> identityProp n = n > 0 && n <= testcaseLength ==> length arr == pref arr
>     where arr = takeLast n testcase
> 
</pre>
</div>
<p>
As expected &lt;quickCheck identityProp&gt; gives:</p>

<pre>
*Main> quickCheck identityProp
OK, passed 100 tests.
</pre>
<p>
Let's be a bit more exhaustive:</p>

<div class="doc_code">
<pre>
> 
> deepCheck p = check (defaultConfig { configMaxTest = 500 }) p
> 
</pre>
</div>
<p>
And here is the result of &lt;deepCheck identityProp&gt;:</p>

<pre>
*Main> deepCheck identityProp
OK, passed 500 tests.
</pre>

</div>

<!-- ______________________________________________________________________ -->
<h4>
  <a name="Tagging">Tagging considerations</a>
</h4>

<div>

<p>
To maintain the invariant that the 2 LSBits of each <tt>Use**</tt> in <tt>Use</tt>
never change after being set up, setters of <tt>Use::Prev</tt> must re-tag the
new <tt>Use**</tt> on every modification. Accordingly getters must strip the
tag bits.</p>
<p>
For layout b) instead of the <tt>User</tt> we find a pointer (<tt>User*</tt> with LSBit set).
Following this pointer brings us to the <tt>User</tt>. A portable trick ensures
that the first bytes of <tt>User</tt> (if interpreted as a pointer) never has
the LSBit set. (Portability is relying on the fact that all known compilers place the
<tt>vptr</tt> in the first word of the instances.)</p>

</div>

</div>

</div>

<!-- *********************************************************************** -->
<h2>
  <a name="coreclasses">The Core LLVM Class Hierarchy Reference </a>
</h2>
<!-- *********************************************************************** -->

<div>
<p><tt>#include "<a href="/doxygen/Type_8h-source.html">llvm/Type.h</a>"</tt>
<br>doxygen info: <a href="/doxygen/classllvm_1_1Type.html">Type Class</a></p>

<p>The Core LLVM classes are the primary means of representing the program
being inspected or transformed.  The core LLVM classes are defined in
header files in the <tt>include/llvm/</tt> directory, and implemented in
the <tt>lib/VMCore</tt> directory.</p>

<!-- ======================================================================= -->
<h3>
  <a name="Type">The <tt>Type</tt> class and Derived Types</a>
</h3>

<div>

  <p><tt>Type</tt> is a superclass of all type classes. Every <tt>Value</tt> has
  a <tt>Type</tt>. <tt>Type</tt> cannot be instantiated directly but only
  through its subclasses. Certain primitive types (<tt>VoidType</tt>,
  <tt>LabelType</tt>, <tt>FloatType</tt> and <tt>DoubleType</tt>) have hidden 
  subclasses. They are hidden because they offer no useful functionality beyond
  what the <tt>Type</tt> class offers except to distinguish themselves from 
  other subclasses of <tt>Type</tt>.</p>
  <p>All other types are subclasses of <tt>DerivedType</tt>.  Types can be 
  named, but this is not a requirement. There exists exactly 
  one instance of a given shape at any one time.  This allows type equality to
  be performed with address equality of the Type Instance. That is, given two 
  <tt>Type*</tt> values, the types are identical if the pointers are identical.
  </p>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="m_Type">Important Public Methods</a>
</h4>

<div>

<ul>
  <li><tt>bool isIntegerTy() const</tt>: Returns true for any integer type.</li>

  <li><tt>bool isFloatingPointTy()</tt>: Return true if this is one of the five
  floating point types.</li>

  <li><tt>bool isSized()</tt>: Return true if the type has known size. Things
  that don't have a size are abstract types, labels and void.</li>

</ul>
</div>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="derivedtypes">Important Derived Types</a>
</h4>
<div>
<dl>
  <dt><tt>IntegerType</tt></dt>
  <dd>Subclass of DerivedType that represents integer types of any bit width. 
  Any bit width between <tt>IntegerType::MIN_INT_BITS</tt> (1) and 
  <tt>IntegerType::MAX_INT_BITS</tt> (~8 million) can be represented.
  <ul>
    <li><tt>static const IntegerType* get(unsigned NumBits)</tt>: get an integer
    type of a specific bit width.</li>
    <li><tt>unsigned getBitWidth() const</tt>: Get the bit width of an integer
    type.</li>
  </ul>
  </dd>
  <dt><tt>SequentialType</tt></dt>
  <dd>This is subclassed by ArrayType, PointerType and VectorType.
    <ul>
      <li><tt>const Type * getElementType() const</tt>: Returns the type of each
      of the elements in the sequential type. </li>
    </ul>
  </dd>
  <dt><tt>ArrayType</tt></dt>
  <dd>This is a subclass of SequentialType and defines the interface for array 
  types.
    <ul>
      <li><tt>unsigned getNumElements() const</tt>: Returns the number of 
      elements in the array. </li>
    </ul>
  </dd>
  <dt><tt>PointerType</tt></dt>
  <dd>Subclass of SequentialType for pointer types.</dd>
  <dt><tt>VectorType</tt></dt>
  <dd>Subclass of SequentialType for vector types. A 
  vector type is similar to an ArrayType but is distinguished because it is 
  a first class type whereas ArrayType is not. Vector types are used for 
  vector operations and are usually small vectors of of an integer or floating 
  point type.</dd>
  <dt><tt>StructType</tt></dt>
  <dd>Subclass of DerivedTypes for struct types.</dd>
  <dt><tt><a name="FunctionType">FunctionType</a></tt></dt>
  <dd>Subclass of DerivedTypes for function types.
    <ul>
      <li><tt>bool isVarArg() const</tt>: Returns true if it's a vararg
      function</li>
      <li><tt> const Type * getReturnType() const</tt>: Returns the
      return type of the function.</li>
      <li><tt>const Type * getParamType (unsigned i)</tt>: Returns
      the type of the ith parameter.</li>
      <li><tt> const unsigned getNumParams() const</tt>: Returns the
      number of formal parameters.</li>
    </ul>
  </dd>
</dl>
</div>

</div>

<!-- ======================================================================= -->
<h3>
  <a name="Module">The <tt>Module</tt> class</a>
</h3>

<div>

<p><tt>#include "<a
href="/doxygen/Module_8h-source.html">llvm/Module.h</a>"</tt><br> doxygen info:
<a href="/doxygen/classllvm_1_1Module.html">Module Class</a></p>

<p>The <tt>Module</tt> class represents the top level structure present in LLVM
programs.  An LLVM module is effectively either a translation unit of the
original program or a combination of several translation units merged by the
linker.  The <tt>Module</tt> class keeps track of a list of <a
href="#Function"><tt>Function</tt></a>s, a list of <a
href="#GlobalVariable"><tt>GlobalVariable</tt></a>s, and a <a
href="#SymbolTable"><tt>SymbolTable</tt></a>.  Additionally, it contains a few
helpful member functions that try to make common operations easy.</p>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="m_Module">Important Public Members of the <tt>Module</tt> class</a>
</h4>

<div>

<ul>
  <li><tt>Module::Module(std::string name = "")</tt>

  <p>Constructing a <a href="#Module">Module</a> is easy. You can optionally
provide a name for it (probably based on the name of the translation unit).</p>
  </li>

  <li><tt>Module::iterator</tt> - Typedef for function list iterator<br>
    <tt>Module::const_iterator</tt> - Typedef for const_iterator.<br>

    <tt>begin()</tt>, <tt>end()</tt>
    <tt>size()</tt>, <tt>empty()</tt>

    <p>These are forwarding methods that make it easy to access the contents of
    a <tt>Module</tt> object's <a href="#Function"><tt>Function</tt></a>
    list.</p></li>

  <li><tt>Module::FunctionListType &amp;getFunctionList()</tt>

    <p> Returns the list of <a href="#Function"><tt>Function</tt></a>s.  This is
    necessary to use when you need to update the list or perform a complex
    action that doesn't have a forwarding method.</p>

    <p><!--  Global Variable --></p></li> 
</ul>

<hr>

<ul>
  <li><tt>Module::global_iterator</tt> - Typedef for global variable list iterator<br>

    <tt>Module::const_global_iterator</tt> - Typedef for const_iterator.<br>

    <tt>global_begin()</tt>, <tt>global_end()</tt>
    <tt>global_size()</tt>, <tt>global_empty()</tt>

    <p> These are forwarding methods that make it easy to access the contents of
    a <tt>Module</tt> object's <a
    href="#GlobalVariable"><tt>GlobalVariable</tt></a> list.</p></li>

  <li><tt>Module::GlobalListType &amp;getGlobalList()</tt>

    <p>Returns the list of <a
    href="#GlobalVariable"><tt>GlobalVariable</tt></a>s.  This is necessary to
    use when you need to update the list or perform a complex action that
    doesn't have a forwarding method.</p>

    <p><!--  Symbol table stuff --> </p></li>
</ul>

<hr>

<ul>
  <li><tt><a href="#SymbolTable">SymbolTable</a> *getSymbolTable()</tt>

    <p>Return a reference to the <a href="#SymbolTable"><tt>SymbolTable</tt></a>
    for this <tt>Module</tt>.</p>

    <p><!--  Convenience methods --></p></li>
</ul>

<hr>

<ul>
  <li><tt><a href="#Function">Function</a> *getFunction(const std::string
  &amp;Name, const <a href="#FunctionType">FunctionType</a> *Ty)</tt>

    <p>Look up the specified function in the <tt>Module</tt> <a
    href="#SymbolTable"><tt>SymbolTable</tt></a>. If it does not exist, return
    <tt>null</tt>.</p></li>

  <li><tt><a href="#Function">Function</a> *getOrInsertFunction(const
  std::string &amp;Name, const <a href="#FunctionType">FunctionType</a> *T)</tt>

    <p>Look up the specified function in the <tt>Module</tt> <a
    href="#SymbolTable"><tt>SymbolTable</tt></a>. If it does not exist, add an
    external declaration for the function and return it.</p></li>

  <li><tt>std::string getTypeName(const <a href="#Type">Type</a> *Ty)</tt>

    <p>If there is at least one entry in the <a
    href="#SymbolTable"><tt>SymbolTable</tt></a> for the specified <a
    href="#Type"><tt>Type</tt></a>, return it.  Otherwise return the empty
    string.</p></li>

  <li><tt>bool addTypeName(const std::string &amp;Name, const <a
  href="#Type">Type</a> *Ty)</tt>

    <p>Insert an entry in the <a href="#SymbolTable"><tt>SymbolTable</tt></a>
    mapping <tt>Name</tt> to <tt>Ty</tt>. If there is already an entry for this
    name, true is returned and the <a
    href="#SymbolTable"><tt>SymbolTable</tt></a> is not modified.</p></li>
</ul>

</div>

</div>

<!-- ======================================================================= -->
<h3>
  <a name="Value">The <tt>Value</tt> class</a>
</h3>

<div>

<p><tt>#include "<a href="/doxygen/Value_8h-source.html">llvm/Value.h</a>"</tt>
<br> 
doxygen info: <a href="/doxygen/classllvm_1_1Value.html">Value Class</a></p>

<p>The <tt>Value</tt> class is the most important class in the LLVM Source
base.  It represents a typed value that may be used (among other things) as an
operand to an instruction.  There are many different types of <tt>Value</tt>s,
such as <a href="#Constant"><tt>Constant</tt></a>s,<a
href="#Argument"><tt>Argument</tt></a>s. Even <a
href="#Instruction"><tt>Instruction</tt></a>s and <a
href="#Function"><tt>Function</tt></a>s are <tt>Value</tt>s.</p>

<p>A particular <tt>Value</tt> may be used many times in the LLVM representation
for a program.  For example, an incoming argument to a function (represented
with an instance of the <a href="#Argument">Argument</a> class) is "used" by
every instruction in the function that references the argument.  To keep track
of this relationship, the <tt>Value</tt> class keeps a list of all of the <a
href="#User"><tt>User</tt></a>s that is using it (the <a
href="#User"><tt>User</tt></a> class is a base class for all nodes in the LLVM
graph that can refer to <tt>Value</tt>s).  This use list is how LLVM represents
def-use information in the program, and is accessible through the <tt>use_</tt>*
methods, shown below.</p>

<p>Because LLVM is a typed representation, every LLVM <tt>Value</tt> is typed,
and this <a href="#Type">Type</a> is available through the <tt>getType()</tt>
method. In addition, all LLVM values can be named.  The "name" of the
<tt>Value</tt> is a symbolic string printed in the LLVM code:</p>

<div class="doc_code">
<pre>
%<b>foo</b> = add i32 1, 2
</pre>
</div>

<p><a name="nameWarning">The name of this instruction is "foo".</a> <b>NOTE</b>
that the name of any value may be missing (an empty string), so names should
<b>ONLY</b> be used for debugging (making the source code easier to read,
debugging printouts), they should not be used to keep track of values or map
between them.  For this purpose, use a <tt>std::map</tt> of pointers to the
<tt>Value</tt> itself instead.</p>

<p>One important aspect of LLVM is that there is no distinction between an SSA
variable and the operation that produces it.  Because of this, any reference to
the value produced by an instruction (or the value available as an incoming
argument, for example) is represented as a direct pointer to the instance of
the class that
represents this value.  Although this may take some getting used to, it
simplifies the representation and makes it easier to manipulate.</p>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="m_Value">Important Public Members of the <tt>Value</tt> class</a>
</h4>

<div>

<ul>
  <li><tt>Value::use_iterator</tt> - Typedef for iterator over the
use-list<br>
    <tt>Value::const_use_iterator</tt> - Typedef for const_iterator over
the use-list<br>
    <tt>unsigned use_size()</tt> - Returns the number of users of the
value.<br>
    <tt>bool use_empty()</tt> - Returns true if there are no users.<br>
    <tt>use_iterator use_begin()</tt> - Get an iterator to the start of
the use-list.<br>
    <tt>use_iterator use_end()</tt> - Get an iterator to the end of the
use-list.<br>
    <tt><a href="#User">User</a> *use_back()</tt> - Returns the last
element in the list.
    <p> These methods are the interface to access the def-use
information in LLVM.  As with all other iterators in LLVM, the naming
conventions follow the conventions defined by the <a href="#stl">STL</a>.</p>
  </li>
  <li><tt><a href="#Type">Type</a> *getType() const</tt>
    <p>This method returns the Type of the Value.</p>
  </li>
  <li><tt>bool hasName() const</tt><br>
    <tt>std::string getName() const</tt><br>
    <tt>void setName(const std::string &amp;Name)</tt>
    <p> This family of methods is used to access and assign a name to a <tt>Value</tt>,
be aware of the <a href="#nameWarning">precaution above</a>.</p>
  </li>
  <li><tt>void replaceAllUsesWith(Value *V)</tt>

    <p>This method traverses the use list of a <tt>Value</tt> changing all <a
    href="#User"><tt>User</tt>s</a> of the current value to refer to
    "<tt>V</tt>" instead.  For example, if you detect that an instruction always
    produces a constant value (for example through constant folding), you can
    replace all uses of the instruction with the constant like this:</p>

<div class="doc_code">
<pre>
Inst-&gt;replaceAllUsesWith(ConstVal);
</pre>
</div>

</ul>

</div>

</div>

<!-- ======================================================================= -->
<h3>
  <a name="User">The <tt>User</tt> class</a>
</h3>

<div>
  
<p>
<tt>#include "<a href="/doxygen/User_8h-source.html">llvm/User.h</a>"</tt><br>
doxygen info: <a href="/doxygen/classllvm_1_1User.html">User Class</a><br>
Superclass: <a href="#Value"><tt>Value</tt></a></p>

<p>The <tt>User</tt> class is the common base class of all LLVM nodes that may
refer to <a href="#Value"><tt>Value</tt></a>s.  It exposes a list of "Operands"
that are all of the <a href="#Value"><tt>Value</tt></a>s that the User is
referring to.  The <tt>User</tt> class itself is a subclass of
<tt>Value</tt>.</p>

<p>The operands of a <tt>User</tt> point directly to the LLVM <a
href="#Value"><tt>Value</tt></a> that it refers to.  Because LLVM uses Static
Single Assignment (SSA) form, there can only be one definition referred to,
allowing this direct connection.  This connection provides the use-def
information in LLVM.</p>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="m_User">Important Public Members of the <tt>User</tt> class</a>
</h4>

<div>

<p>The <tt>User</tt> class exposes the operand list in two ways: through
an index access interface and through an iterator based interface.</p>

<ul>
  <li><tt>Value *getOperand(unsigned i)</tt><br>
    <tt>unsigned getNumOperands()</tt>
    <p> These two methods expose the operands of the <tt>User</tt> in a
convenient form for direct access.</p></li>

  <li><tt>User::op_iterator</tt> - Typedef for iterator over the operand
list<br>
    <tt>op_iterator op_begin()</tt> - Get an iterator to the start of 
the operand list.<br>
    <tt>op_iterator op_end()</tt> - Get an iterator to the end of the
operand list.
    <p> Together, these methods make up the iterator based interface to
the operands of a <tt>User</tt>.</p></li>
</ul>

</div>    

</div>

<!-- ======================================================================= -->
<h3>
  <a name="Instruction">The <tt>Instruction</tt> class</a>
</h3>

<div>

<p><tt>#include "</tt><tt><a
href="/doxygen/Instruction_8h-source.html">llvm/Instruction.h</a>"</tt><br>
doxygen info: <a href="/doxygen/classllvm_1_1Instruction.html">Instruction Class</a><br>
Superclasses: <a href="#User"><tt>User</tt></a>, <a
href="#Value"><tt>Value</tt></a></p>

<p>The <tt>Instruction</tt> class is the common base class for all LLVM
instructions.  It provides only a few methods, but is a very commonly used
class.  The primary data tracked by the <tt>Instruction</tt> class itself is the
opcode (instruction type) and the parent <a
href="#BasicBlock"><tt>BasicBlock</tt></a> the <tt>Instruction</tt> is embedded
into.  To represent a specific type of instruction, one of many subclasses of
<tt>Instruction</tt> are used.</p>

<p> Because the <tt>Instruction</tt> class subclasses the <a
href="#User"><tt>User</tt></a> class, its operands can be accessed in the same
way as for other <a href="#User"><tt>User</tt></a>s (with the
<tt>getOperand()</tt>/<tt>getNumOperands()</tt> and
<tt>op_begin()</tt>/<tt>op_end()</tt> methods).</p> <p> An important file for
the <tt>Instruction</tt> class is the <tt>llvm/Instruction.def</tt> file. This
file contains some meta-data about the various different types of instructions
in LLVM.  It describes the enum values that are used as opcodes (for example
<tt>Instruction::Add</tt> and <tt>Instruction::ICmp</tt>), as well as the
concrete sub-classes of <tt>Instruction</tt> that implement the instruction (for
example <tt><a href="#BinaryOperator">BinaryOperator</a></tt> and <tt><a
href="#CmpInst">CmpInst</a></tt>).  Unfortunately, the use of macros in
this file confuses doxygen, so these enum values don't show up correctly in the
<a href="/doxygen/classllvm_1_1Instruction.html">doxygen output</a>.</p>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="s_Instruction">
    Important Subclasses of the <tt>Instruction</tt> class
  </a>
</h4>
<div>
  <ul>
    <li><tt><a name="BinaryOperator">BinaryOperator</a></tt>
    <p>This subclasses represents all two operand instructions whose operands
    must be the same type, except for the comparison instructions.</p></li>
    <li><tt><a name="CastInst">CastInst</a></tt>
    <p>This subclass is the parent of the 12 casting instructions. It provides
    common operations on cast instructions.</p>
    <li><tt><a name="CmpInst">CmpInst</a></tt>
    <p>This subclass respresents the two comparison instructions, 
    <a href="LangRef.html#i_icmp">ICmpInst</a> (integer opreands), and
    <a href="LangRef.html#i_fcmp">FCmpInst</a> (floating point operands).</p>
    <li><tt><a name="TerminatorInst">TerminatorInst</a></tt>
    <p>This subclass is the parent of all terminator instructions (those which
    can terminate a block).</p>
  </ul>
  </div>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="m_Instruction">
    Important Public Members of the <tt>Instruction</tt> class
  </a>
</h4>

<div>

<ul>
  <li><tt><a href="#BasicBlock">BasicBlock</a> *getParent()</tt>
    <p>Returns the <a href="#BasicBlock"><tt>BasicBlock</tt></a> that
this  <tt>Instruction</tt> is embedded into.</p></li>
  <li><tt>bool mayWriteToMemory()</tt>
    <p>Returns true if the instruction writes to memory, i.e. it is a
      <tt>call</tt>,<tt>free</tt>,<tt>invoke</tt>, or <tt>store</tt>.</p></li>
  <li><tt>unsigned getOpcode()</tt>
    <p>Returns the opcode for the <tt>Instruction</tt>.</p></li>
  <li><tt><a href="#Instruction">Instruction</a> *clone() const</tt>
    <p>Returns another instance of the specified instruction, identical
in all ways to the original except that the instruction has no parent
(ie it's not embedded into a <a href="#BasicBlock"><tt>BasicBlock</tt></a>),
and it has no name</p></li>
</ul>

</div>

</div>

<!-- ======================================================================= -->
<h3>
  <a name="Constant">The <tt>Constant</tt> class and subclasses</a>
</h3>

<div>

<p>Constant represents a base class for different types of constants. It
is subclassed by ConstantInt, ConstantArray, etc. for representing 
the various types of Constants.  <a href="#GlobalValue">GlobalValue</a> is also
a subclass, which represents the address of a global variable or function.
</p>

<!-- _______________________________________________________________________ -->
<h4>Important Subclasses of Constant</h4>
<div>
<ul>
  <li>ConstantInt : This subclass of Constant represents an integer constant of
  any width.
    <ul>
      <li><tt>const APInt&amp; getValue() const</tt>: Returns the underlying
      value of this constant, an APInt value.</li>
      <li><tt>int64_t getSExtValue() const</tt>: Converts the underlying APInt
      value to an int64_t via sign extension. If the value (not the bit width)
      of the APInt is too large to fit in an int64_t, an assertion will result.
      For this reason, use of this method is discouraged.</li>
      <li><tt>uint64_t getZExtValue() const</tt>: Converts the underlying APInt
      value to a uint64_t via zero extension. IF the value (not the bit width)
      of the APInt is too large to fit in a uint64_t, an assertion will result.
      For this reason, use of this method is discouraged.</li>
      <li><tt>static ConstantInt* get(const APInt&amp; Val)</tt>: Returns the
      ConstantInt object that represents the value provided by <tt>Val</tt>.
      The type is implied as the IntegerType that corresponds to the bit width
      of <tt>Val</tt>.</li>
      <li><tt>static ConstantInt* get(const Type *Ty, uint64_t Val)</tt>: 
      Returns the ConstantInt object that represents the value provided by 
      <tt>Val</tt> for integer type <tt>Ty</tt>.</li>
    </ul>
  </li>
  <li>ConstantFP : This class represents a floating point constant.
    <ul>
      <li><tt>double getValue() const</tt>: Returns the underlying value of 
      this constant. </li>
    </ul>
  </li>
  <li>ConstantArray : This represents a constant array.
    <ul>
      <li><tt>const std::vector&lt;Use&gt; &amp;getValues() const</tt>: Returns 
      a vector of component constants that makeup this array. </li>
    </ul>
  </li>
  <li>ConstantStruct : This represents a constant struct.
    <ul>
      <li><tt>const std::vector&lt;Use&gt; &amp;getValues() const</tt>: Returns 
      a vector of component constants that makeup this array. </li>
    </ul>
  </li>
  <li>GlobalValue : This represents either a global variable or a function. In 
  either case, the value is a constant fixed address (after linking). 
  </li>
</ul>
</div>

</div>

<!-- ======================================================================= -->
<h3>
  <a name="GlobalValue">The <tt>GlobalValue</tt> class</a>
</h3>

<div>

<p><tt>#include "<a
href="/doxygen/GlobalValue_8h-source.html">llvm/GlobalValue.h</a>"</tt><br>
doxygen info: <a href="/doxygen/classllvm_1_1GlobalValue.html">GlobalValue
Class</a><br>
Superclasses: <a href="#Constant"><tt>Constant</tt></a>, 
<a href="#User"><tt>User</tt></a>, <a href="#Value"><tt>Value</tt></a></p>

<p>Global values (<a href="#GlobalVariable"><tt>GlobalVariable</tt></a>s or <a
href="#Function"><tt>Function</tt></a>s) are the only LLVM values that are
visible in the bodies of all <a href="#Function"><tt>Function</tt></a>s.
Because they are visible at global scope, they are also subject to linking with
other globals defined in different translation units.  To control the linking
process, <tt>GlobalValue</tt>s know their linkage rules. Specifically,
<tt>GlobalValue</tt>s know whether they have internal or external linkage, as
defined by the <tt>LinkageTypes</tt> enumeration.</p>

<p>If a <tt>GlobalValue</tt> has internal linkage (equivalent to being
<tt>static</tt> in C), it is not visible to code outside the current translation
unit, and does not participate in linking.  If it has external linkage, it is
visible to external code, and does participate in linking.  In addition to
linkage information, <tt>GlobalValue</tt>s keep track of which <a
href="#Module"><tt>Module</tt></a> they are currently part of.</p>

<p>Because <tt>GlobalValue</tt>s are memory objects, they are always referred to
by their <b>address</b>. As such, the <a href="#Type"><tt>Type</tt></a> of a
global is always a pointer to its contents. It is important to remember this
when using the <tt>GetElementPtrInst</tt> instruction because this pointer must
be dereferenced first. For example, if you have a <tt>GlobalVariable</tt> (a
subclass of <tt>GlobalValue)</tt> that is an array of 24 ints, type <tt>[24 x
i32]</tt>, then the <tt>GlobalVariable</tt> is a pointer to that array. Although
the address of the first element of this array and the value of the
<tt>GlobalVariable</tt> are the same, they have different types. The
<tt>GlobalVariable</tt>'s type is <tt>[24 x i32]</tt>. The first element's type
is <tt>i32.</tt> Because of this, accessing a global value requires you to
dereference the pointer with <tt>GetElementPtrInst</tt> first, then its elements
can be accessed. This is explained in the <a href="LangRef.html#globalvars">LLVM
Language Reference Manual</a>.</p>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="m_GlobalValue">
    Important Public Members of the <tt>GlobalValue</tt> class
  </a>
</h4>

<div>

<ul>
  <li><tt>bool hasInternalLinkage() const</tt><br>
    <tt>bool hasExternalLinkage() const</tt><br>
    <tt>void setInternalLinkage(bool HasInternalLinkage)</tt>
    <p> These methods manipulate the linkage characteristics of the <tt>GlobalValue</tt>.</p>
    <p> </p>
  </li>
  <li><tt><a href="#Module">Module</a> *getParent()</tt>
    <p> This returns the <a href="#Module"><tt>Module</tt></a> that the
GlobalValue is currently embedded into.</p></li>
</ul>

</div>

</div>

<!-- ======================================================================= -->
<h3>
  <a name="Function">The <tt>Function</tt> class</a>
</h3>

<div>

<p><tt>#include "<a
href="/doxygen/Function_8h-source.html">llvm/Function.h</a>"</tt><br> doxygen
info: <a href="/doxygen/classllvm_1_1Function.html">Function Class</a><br>
Superclasses: <a href="#GlobalValue"><tt>GlobalValue</tt></a>, 
<a href="#Constant"><tt>Constant</tt></a>, 
<a href="#User"><tt>User</tt></a>, 
<a href="#Value"><tt>Value</tt></a></p>

<p>The <tt>Function</tt> class represents a single procedure in LLVM.  It is
actually one of the more complex classes in the LLVM hierarchy because it must
keep track of a large amount of data.  The <tt>Function</tt> class keeps track
of a list of <a href="#BasicBlock"><tt>BasicBlock</tt></a>s, a list of formal 
<a href="#Argument"><tt>Argument</tt></a>s, and a 
<a href="#SymbolTable"><tt>SymbolTable</tt></a>.</p>

<p>The list of <a href="#BasicBlock"><tt>BasicBlock</tt></a>s is the most
commonly used part of <tt>Function</tt> objects.  The list imposes an implicit
ordering of the blocks in the function, which indicate how the code will be
laid out by the backend.  Additionally, the first <a
href="#BasicBlock"><tt>BasicBlock</tt></a> is the implicit entry node for the
<tt>Function</tt>.  It is not legal in LLVM to explicitly branch to this initial
block.  There are no implicit exit nodes, and in fact there may be multiple exit
nodes from a single <tt>Function</tt>.  If the <a
href="#BasicBlock"><tt>BasicBlock</tt></a> list is empty, this indicates that
the <tt>Function</tt> is actually a function declaration: the actual body of the
function hasn't been linked in yet.</p>

<p>In addition to a list of <a href="#BasicBlock"><tt>BasicBlock</tt></a>s, the
<tt>Function</tt> class also keeps track of the list of formal <a
href="#Argument"><tt>Argument</tt></a>s that the function receives.  This
container manages the lifetime of the <a href="#Argument"><tt>Argument</tt></a>
nodes, just like the <a href="#BasicBlock"><tt>BasicBlock</tt></a> list does for
the <a href="#BasicBlock"><tt>BasicBlock</tt></a>s.</p>

<p>The <a href="#SymbolTable"><tt>SymbolTable</tt></a> is a very rarely used
LLVM feature that is only used when you have to look up a value by name.  Aside
from that, the <a href="#SymbolTable"><tt>SymbolTable</tt></a> is used
internally to make sure that there are not conflicts between the names of <a
href="#Instruction"><tt>Instruction</tt></a>s, <a
href="#BasicBlock"><tt>BasicBlock</tt></a>s, or <a
href="#Argument"><tt>Argument</tt></a>s in the function body.</p>

<p>Note that <tt>Function</tt> is a <a href="#GlobalValue">GlobalValue</a>
and therefore also a <a href="#Constant">Constant</a>. The value of the function
is its address (after linking) which is guaranteed to be constant.</p>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="m_Function">
    Important Public Members of the <tt>Function</tt> class
  </a>
</h4>

<div>

<ul>
  <li><tt>Function(const </tt><tt><a href="#FunctionType">FunctionType</a>
  *Ty, LinkageTypes Linkage, const std::string &amp;N = "", Module* Parent = 0)</tt>

    <p>Constructor used when you need to create new <tt>Function</tt>s to add
    the the program.  The constructor must specify the type of the function to
    create and what type of linkage the function should have. The <a 
    href="#FunctionType"><tt>FunctionType</tt></a> argument
    specifies the formal arguments and return value for the function. The same
    <a href="#FunctionType"><tt>FunctionType</tt></a> value can be used to
    create multiple functions. The <tt>Parent</tt> argument specifies the Module
    in which the function is defined. If this argument is provided, the function
    will automatically be inserted into that module's list of
    functions.</p></li>

  <li><tt>bool isDeclaration()</tt>

    <p>Return whether or not the <tt>Function</tt> has a body defined.  If the
    function is "external", it does not have a body, and thus must be resolved
    by linking with a function defined in a different translation unit.</p></li>

  <li><tt>Function::iterator</tt> - Typedef for basic block list iterator<br>
    <tt>Function::const_iterator</tt> - Typedef for const_iterator.<br>

    <tt>begin()</tt>, <tt>end()</tt>
    <tt>size()</tt>, <tt>empty()</tt>

    <p>These are forwarding methods that make it easy to access the contents of
    a <tt>Function</tt> object's <a href="#BasicBlock"><tt>BasicBlock</tt></a>
    list.</p></li>

  <li><tt>Function::BasicBlockListType &amp;getBasicBlockList()</tt>

    <p>Returns the list of <a href="#BasicBlock"><tt>BasicBlock</tt></a>s.  This
    is necessary to use when you need to update the list or perform a complex
    action that doesn't have a forwarding method.</p></li>

  <li><tt>Function::arg_iterator</tt> - Typedef for the argument list
iterator<br>
    <tt>Function::const_arg_iterator</tt> - Typedef for const_iterator.<br>

    <tt>arg_begin()</tt>, <tt>arg_end()</tt>
    <tt>arg_size()</tt>, <tt>arg_empty()</tt>

    <p>These are forwarding methods that make it easy to access the contents of
    a <tt>Function</tt> object's <a href="#Argument"><tt>Argument</tt></a>
    list.</p></li>

  <li><tt>Function::ArgumentListType &amp;getArgumentList()</tt>

    <p>Returns the list of <a href="#Argument"><tt>Argument</tt></a>s.  This is
    necessary to use when you need to update the list or perform a complex
    action that doesn't have a forwarding method.</p></li>

  <li><tt><a href="#BasicBlock">BasicBlock</a> &amp;getEntryBlock()</tt>

    <p>Returns the entry <a href="#BasicBlock"><tt>BasicBlock</tt></a> for the
    function.  Because the entry block for the function is always the first
    block, this returns the first block of the <tt>Function</tt>.</p></li>

  <li><tt><a href="#Type">Type</a> *getReturnType()</tt><br>
    <tt><a href="#FunctionType">FunctionType</a> *getFunctionType()</tt>

    <p>This traverses the <a href="#Type"><tt>Type</tt></a> of the
    <tt>Function</tt> and returns the return type of the function, or the <a
    href="#FunctionType"><tt>FunctionType</tt></a> of the actual
    function.</p></li>

  <li><tt><a href="#SymbolTable">SymbolTable</a> *getSymbolTable()</tt>

    <p> Return a pointer to the <a href="#SymbolTable"><tt>SymbolTable</tt></a>
    for this <tt>Function</tt>.</p></li>
</ul>

</div>

</div>

<!-- ======================================================================= -->
<h3>
  <a name="GlobalVariable">The <tt>GlobalVariable</tt> class</a>
</h3>

<div>

<p><tt>#include "<a
href="/doxygen/GlobalVariable_8h-source.html">llvm/GlobalVariable.h</a>"</tt>
<br>
doxygen info: <a href="/doxygen/classllvm_1_1GlobalVariable.html">GlobalVariable
 Class</a><br>
Superclasses: <a href="#GlobalValue"><tt>GlobalValue</tt></a>, 
<a href="#Constant"><tt>Constant</tt></a>,
<a href="#User"><tt>User</tt></a>,
<a href="#Value"><tt>Value</tt></a></p>

<p>Global variables are represented with the (surprise surprise)
<tt>GlobalVariable</tt> class. Like functions, <tt>GlobalVariable</tt>s are also
subclasses of <a href="#GlobalValue"><tt>GlobalValue</tt></a>, and as such are
always referenced by their address (global values must live in memory, so their
"name" refers to their constant address). See 
<a href="#GlobalValue"><tt>GlobalValue</tt></a> for more on this.  Global 
variables may have an initial value (which must be a 
<a href="#Constant"><tt>Constant</tt></a>), and if they have an initializer, 
they may be marked as "constant" themselves (indicating that their contents 
never change at runtime).</p>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="m_GlobalVariable">
    Important Public Members of the <tt>GlobalVariable</tt> class
  </a>
</h4>

<div>

<ul>
  <li><tt>GlobalVariable(const </tt><tt><a href="#Type">Type</a> *Ty, bool
  isConstant, LinkageTypes&amp; Linkage, <a href="#Constant">Constant</a>
  *Initializer = 0, const std::string &amp;Name = "", Module* Parent = 0)</tt>

    <p>Create a new global variable of the specified type. If
    <tt>isConstant</tt> is true then the global variable will be marked as
    unchanging for the program. The Linkage parameter specifies the type of
    linkage (internal, external, weak, linkonce, appending) for the variable.
    If the linkage is InternalLinkage, WeakAnyLinkage, WeakODRLinkage,
    LinkOnceAnyLinkage or LinkOnceODRLinkage,&nbsp; then the resultant
    global variable will have internal linkage.  AppendingLinkage concatenates
    together all instances (in different translation units) of the variable
    into a single variable but is only applicable to arrays.  &nbsp;See
    the <a href="LangRef.html#modulestructure">LLVM Language Reference</a> for
    further details on linkage types. Optionally an initializer, a name, and the
    module to put the variable into may be specified for the global variable as
    well.</p></li>

  <li><tt>bool isConstant() const</tt>

    <p>Returns true if this is a global variable that is known not to
    be modified at runtime.</p></li>

  <li><tt>bool hasInitializer()</tt>

    <p>Returns true if this <tt>GlobalVariable</tt> has an intializer.</p></li>

  <li><tt><a href="#Constant">Constant</a> *getInitializer()</tt>

    <p>Returns the initial value for a <tt>GlobalVariable</tt>.  It is not legal
    to call this method if there is no initializer.</p></li>
</ul>

</div>

</div>

<!-- ======================================================================= -->
<h3>
  <a name="BasicBlock">The <tt>BasicBlock</tt> class</a>
</h3>

<div>

<p><tt>#include "<a
href="/doxygen/BasicBlock_8h-source.html">llvm/BasicBlock.h</a>"</tt><br>
doxygen info: <a href="/doxygen/classllvm_1_1BasicBlock.html">BasicBlock
Class</a><br>
Superclass: <a href="#Value"><tt>Value</tt></a></p>

<p>This class represents a single entry single exit section of the code,
commonly known as a basic block by the compiler community.  The
<tt>BasicBlock</tt> class maintains a list of <a
href="#Instruction"><tt>Instruction</tt></a>s, which form the body of the block.
Matching the language definition, the last element of this list of instructions
is always a terminator instruction (a subclass of the <a
href="#TerminatorInst"><tt>TerminatorInst</tt></a> class).</p>

<p>In addition to tracking the list of instructions that make up the block, the
<tt>BasicBlock</tt> class also keeps track of the <a
href="#Function"><tt>Function</tt></a> that it is embedded into.</p>

<p>Note that <tt>BasicBlock</tt>s themselves are <a
href="#Value"><tt>Value</tt></a>s, because they are referenced by instructions
like branches and can go in the switch tables. <tt>BasicBlock</tt>s have type
<tt>label</tt>.</p>

<!-- _______________________________________________________________________ -->
<h4>
  <a name="m_BasicBlock">
    Important Public Members of the <tt>BasicBlock</tt> class
  </a>
</h4>

<div>
<ul>

<li><tt>BasicBlock(const std::string &amp;Name = "", </tt><tt><a
 href="#Function">Function</a> *Parent = 0)</tt>

<p>The <tt>BasicBlock</tt> constructor is used to create new basic blocks for
insertion into a function.  The constructor optionally takes a name for the new
block, and a <a href="#Function"><tt>Function</tt></a> to insert it into.  If
the <tt>Parent</tt> parameter is specified, the new <tt>BasicBlock</tt> is
automatically inserted at the end of the specified <a
href="#Function"><tt>Function</tt></a>, if not specified, the BasicBlock must be
manually inserted into the <a href="#Function"><tt>Function</tt></a>.</p></li>

<li><tt>BasicBlock::iterator</tt> - Typedef for instruction list iterator<br>
<tt>BasicBlock::const_iterator</tt> - Typedef for const_iterator.<br>
<tt>begin()</tt>, <tt>end()</tt>, <tt>front()</tt>, <tt>back()</tt>,
<tt>size()</tt>, <tt>empty()</tt>
STL-style functions for accessing the instruction list.

<p>These methods and typedefs are forwarding functions that have the same
semantics as the standard library methods of the same names.  These methods
expose the underlying instruction list of a basic block in a way that is easy to
manipulate.  To get the full complement of container operations (including
operations to update the list), you must use the <tt>getInstList()</tt>
method.</p></li>

<li><tt>BasicBlock::InstListType &amp;getInstList()</tt>

<p>This method is used to get access to the underlying container that actually
holds the Instructions.  This method must be used when there isn't a forwarding
function in the <tt>BasicBlock</tt> class for the operation that you would like
to perform.  Because there are no forwarding functions for "updating"
operations, you need to use this if you want to update the contents of a
<tt>BasicBlock</tt>.</p></li>

<li><tt><a href="#Function">Function</a> *getParent()</tt>

<p> Returns a pointer to <a href="#Function"><tt>Function</tt></a> the block is
embedded into, or a null pointer if it is homeless.</p></li>

<li><tt><a href="#TerminatorInst">TerminatorInst</a> *getTerminator()</tt>

<p> Returns a pointer to the terminator instruction that appears at the end of
the <tt>BasicBlock</tt>.  If there is no terminator instruction, or if the last
instruction in the block is not a terminator, then a null pointer is
returned.</p></li>

</ul>

</div>

</div>

<!-- ======================================================================= -->
<h3>
  <a name="Argument">The <tt>Argument</tt> class</a>
</h3>

<div>

<p>This subclass of Value defines the interface for incoming formal
arguments to a function. A Function maintains a list of its formal
arguments. An argument has a pointer to the parent Function.</p>

</div>

</div>

<!-- *********************************************************************** -->
<hr>
<address>
  <a href="http://jigsaw.w3.org/css-validator/check/referer"><img
  src="http://jigsaw.w3.org/css-validator/images/vcss-blue" alt="Valid CSS"></a>
  <a href="http://validator.w3.org/check/referer"><img
  src="http://www.w3.org/Icons/valid-html401" alt="Valid HTML 4.01 Strict"></a>

  <a href="mailto:dhurjati@cs.uiuc.edu">Dinakar Dhurjati</a> and
  <a href="mailto:sabre@nondot.org">Chris Lattner</a><br>
  <a href="http://llvm.org/">The LLVM Compiler Infrastructure</a><br>
  Last modified: $Date$
</address>

</body>
</html>
