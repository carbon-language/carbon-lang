<!--
Part of the Carbon Language, under the Apache License v2.0 with LLVM Exceptions.
See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

# Carbon: Lexical conventions

- **Authors:** Richard Smith
- **[Tracking issue](https://github.com/carbon-language/carbon-lang/issues/16)**
- **Status:** RFC
- **Created:** 2020-05-18

**_PLEASE_ DO NOT SHARE OUTSIDE CARBON FORUMS**

## Problem

This document proposes a set of rules for the initial phase of processing a
Carbon source file: interpreting the contents of the file and forming
[tokens](#tokens).

## Proposal

Carbon source files are [UTF-8](#file-contents-and-encoding) text files whose
contents are divided into [whitespace](#whitespace), [comments](#comments),
[literals](#literals), [identifiers](#identifiers), [keywords](#keywords),
[designators](#designators), [operators](#operators), and
[brackets](#brackets), as described below.

## Details

### File contents and encoding

Carbon source files are Unicode text files encoded in UTF-8. An initial UTF-8
BOM is permitted and ignored. All contents outside of [comments](#comments) and
[literals](#literals) shall be in Normalization Form C.
[[why?]](#encoding-rationale)

Carbon is currently based on Unicode 13.0, and will adopt new Unicode versions
as they are published.

### Whitespace

Characters are identified as whitespace if they have the Unicode
`Pattern_White_Space` property. These include the ASCII whitespace characters (recognized in C++):

 * Space and horizontal tab
 * Carriage return and line feed (which C++ conflates as "new line")
 * Vertical tab and form feed

As of Unicode version 13, 5 additional characters are included:

 * U+0085 NEXT LINE
 * U+200E LEFT-TO-RIGHT MARK
 * U+200F RIGHT-TO-LEFT MARK
 * U+2028 LINE SEPARATOR
 * U+2029 PARAGRAPH SEPARATOR

Space, horizontal tab, and the LTR and RTL marks are *horizontal whitespace*
characters. All other whitespace characters are *vertical whitespace*
characters.

Characters with the Unicode property `White_Space` but not
`Pattern_White_Space` are invalid outside comments and literals. Code
formatters are encouraged to convert them into recognized horizontal whitespace
characters. Implementations are encouraged to recover from the error as if
those characters were treated as horizontal whitespace.

### Comments

A *comment* in Carbon is either:

 * A *line comment*, beginning with `//` and running to the end of the line, or
 * A *block comment*, beginning with `/*` and running to the matching `*/`.

Carbon has no mechanism for physical line continuation, so a `//` comment
always ends at the next vertical whitespace character.
[[why?]](#line-continuation-rationale)

If the character after the `/*` introducing a block comment is `{`, the comment
is a *code comment*. In a code comment, the following text is tokenized until a
matching `}*/` token is formed; such a token terminates the comment. (In
particular, such a token is not recognized if it is nested within another
comment or a literal.) Otherwise, the comment ends at the first matching `*/`
character sequence.
[[why?]](#nested-comments-rationale)

Example:

```carbon
// This is a comment.
// The characters /* introduce a block comment.
This is not a comment.
/*{
  // The characters */ end a block comment.
}*/
This is not a comment.
```

If the character after the comment introducer is an exclamation mark, the
comment is a documentation comment. Documentation comments are tokens, and are
recognized by the language grammar only in specific locations, which determine
the entity to which they attach.
[[why?]](#nested-comments-rationale)

Non-documentation comments are treated equivalently to whitespace.

In addition to the cases above, a block comment introducer may be followed by
additional `*` characters. If the character after the comment introducer is not
one of those mentioned above, it shall be a whitespace character.
[[why?]](#comment-introducers-rationale)

### Literals

Carbon provides literal syntax for numbers, and for character and string data.
(Additional constants, such as `True` and `Nullptr`, are exposed as keywords or
predeclared identifiers.)

A *literal* is a numeric literal, a character literal, or a string literal, as
defined below.

A literal shall not be immediately followed by a character with property
`XID_Start`. Carbon has no literal suffixes, but the corresponding lexical
space is reserved for future extensions.

#### Numbers

Decimal integers are written as a non-zero decimal digit followed by zero or
more additional decimal digits, or as a single `0`.

Integers in other bases are written as a `0` followed by a base specifier
character, followed by a sequence of digits in the corresponding base. The
available base specifiers and corresponding bases are:

| Base specifier | Base | Digits                                |
| -------------- | ---- | ------------------------------------- |
| `b` or `B`     | 2    | `0` and `1`                           |
| `o`            | 8    | `0` ... `7`                           |
| `x` or `X`     | 16   | `0` ... `9`, `a` ... `f`, `A` ... `F` |

[TODO: This doesn't belong here.] There are no size suffixes. Each literal has
a unique type that can be converted to any sufficiently-large integer type, but
operations on it are always exact.

Real numbers are written as a sequence of one or more decimal digits followed
by a decimal point followed by a sequence of one or more decimal digits.

A real number can be followed by an `e`, an optional `+` or `-` (defaulting to
`+`), and a decimal integer *N*; the effect is to multiply the given value by
10<sup>*N*</sup>.

A *numeric literal* is an integer or real number expressed as described above.

#### Characters

A *character literal* is formed of any single character other than a backslash
(`\\`) or single quotation mark, enclosed in a pair of single quotation marks
(`'`), or an escape sequence enclosed in a pair of single quotation marks.

An escape sequence is replaced by the corresponding character sequence or
encoding, which shall fit in a single character.

TODO: Table of escape sequences.

#### Strings

A *simple string literal* is formed of a sequence of

 * characters other than backslashes, double quotation marks, and vertical
   whitespace
 * escape sequences

enclosed in double quotation marks (`"`). Each escape sequence is replaced with
the corresponding character sequence or encoding.

A *raw string literal* starts with an `r` followed by *N* `#` characters
followed by a double quotation mark, and ends with the first following
occurrence of a double quotation mark followed by *N* `#` characters. The text
in between is not interpreted in any way.

A *block string literal* starts with three double quotation marks followed by
an optional sequence of non-whitespace characters, followed by a newline. Each
following line within the literal shall start with the same initial sequence of
zero or more horizontal whitespace characters and optionally one `|` character
as were present on the first such line. The literal ends at the first instance
of three double quotation mark characters (where the first such character is
not escaped). The common initial horizontal whitespace is removed from each
line, as is the terminating newline character.  Escape sequences are expanded
as in a simple string literal. The initial sequence of characters before the
newline is ignored, but can be used to indicate the formatting rules for a code
formatter to use for the literal contents.
[[why?]](#block-strings-rationale)

A *raw block string literal* is expressed analogously to a raw string literal,
but for a block string literal. Escape sequences are ignored.

For example:

```carbon
fn f() {
  var String: x = r#"""
    This is the content of the string. The 'T' is the first character
    of the string.
    """ <-- This is not the end of the string. But this is --> """#;
  var String: y = r"Hello\"; // OK, final character is \
  var String: z = r##"Raw strings r#"nesting"#"##;

  var String: starts_with_whitespace = """
    |  int x = 1;
    |  int y = 2;""";
  var String: starts_with_pipe = r#"""
    || is a pipe.
    |\ is not a pipe."""#;

  var String: code = """c++
  const char *str = R"foo(hello)foo";
  """;

  var String: error = """
This is invalid (insufficiently indented).""";
}
```

### Identifiers

An *identifier* is a maximal sequence of characters beginning with a character
with Unicode property `XID_Start`, followed by zero or more characters with
property `XID_Continue`.

Notably, `XID_Start` does not include the underscore character. Tokens
beginning with an underscore are reserved, but are expected to be used as
pattern matching placeholders.

Additionally, a *raw identifier* can be specified by prefixing an identifier
with `r#`, such as `r#requires`. Raw identifiers can be used to introduce and
use names that are lexically identical to keywords.

All identifier tokens in all contexts are looked up using the same lexical
scoping rule.

An identifier shall not be immediately followed by a `"` or `'`.

### Keywords

A *keyword* is an identifier with predefined meaning. Carbon has a predefined
set of keywords, that will be specified separately as part of the syntax rules.

An identifier that is a keyword may also be declared explicitly in a source
file. The same identifier shall not be used as both a keyword and as a non-raw
non-keyword identifier in a single source file.
[[why?]](#keywords-rationale)

Example:

```carbon
var Int: fn = 3; // OK, variable named 'fn'
fn f() {}        // error, 'fn' is not a keyword in this source file
interface var {} // error, already used 'var' as a keyword in this source file
```

### Designators

A *designator* is a token formed by prefixing an identifier with a period
character, such as `.member`. The identifier after the period is the *member
name*, and is looked up in a context-dependent manner.
[[why?]](#designators-rationale)

### Operators

An *operator* is a maximal sequence of characters with Unicode property
`Pattern_Syntax`, excluding `"` and `'` and those characters with class `Ps` or
`Pe` (for which, see [brackets](#brackets)), which we will refer to as
*operator characters*.
[[why?]](#operators-rationale)
We do not intend to define any operators containing non-ASCII characters. The
ASCII operator characters are:

```
!  #  $  %  &  *  +  -  .  /  :  ;  <  =  >  ?  @  \  ^  `  |  ~
```

Of these, we intend to not use <code>\`</code> due to its common use to escape
code, nor `$` due to its absence from many non-US keyboards. This leaves 20
operator characters, 400 digraphs, and so on.

Bracket operators, described below, are also operators.

### Brackets

A *simple open bracket* is a character with Unicode property `Pattern_Syntax`
and character class `Ps`, such as `(` or `[`.
A *simple close bracket* is a character
with Unicode property `Pattern_Syntax` and character class `Pe`, such as `}`.
A *bracket terminator character* is one of `|` or `:`.
A *bracket continuation character* is an operator character that is not a
bracket terminator character.

A *compound open bracket* is a simple open bracket followed by zero or more
bracket continuation characters followed by a bracket terminator character,
such as `[:`.
A *compound close bracket* is a bracket terminator character followed by zero
or more bracket continuation characters followed by a simple close bracket,
such as `|=)`.
[[why?]](#compound-brackets-rationale)

An *open bracket* is either a simple open bracket or a compound open bracket.
A *close bracket* is either a simple close bracket or a compound close bracket.

The close bracket matching an open bracket is formed by reversing the character
sequence in the open bracket and replacing each caracter with class `Ps` with
the corresponding character with class `Pe`. Every open bracket is required to
have a matching close bracket such that the bracketed regions form a tree
structure.

There are 3 single-character brackets (`()`, `{}`, `[]`), 6 bracket digraphs
(`(| |)`, `{| |}`, `[| |]`, `(: :)`, `{: :}`, `[: :]`), 108 bracket trigraphs,
and so on.

For example:

```carbon
(this is within brackets {and this [this too]})
(|this is a different kind of bracket {: and another :}
   (**|lots of kinds of brackets can be built [=: this way :=]|**)
 |)
```

TODO: Indentation restrictions for bracket matching?

In addition, Carbon recognizes *bracket operators*, formed by a simple open
bracket followed by one or more operator characters followed by a matching
simple close bracket, such as `[~>]` or `(*)`. Bracket operators are operators,
not brackets.

### Tokens

A *token* is a documentation comment, a literal, an identifier, a keyword, a
designator, an operator, or a bracket. Tokens are formed by a single
left-to-right scan of the source file, using a "max munch" rule: the longest
possible next token is formed at each step.

## Rationale

### Encoding rationale

We intend to follow the Unicode Consortium's recommentations for identifiers in
programming languages as described in Unicode 13.0.0
[UAX#31](https://unicode.org/reports/tr31/) Revision 31. We do not see a reason
to be inventive in this regard, and delegating the complex considerations over
how Unicode characters should be used to a group with greater expertise in that
area seems appropriate.

We observe UAX#31's requirements as follows:

 * UAX31-R1: requirement met. Identifiers are of the form `XID_Start`
   `XID_Continue`\*.
 * UAX31-R1a: requirement not met. Format characters are not permitted in
   identifiers.
 * UAX31-R1b: requirement not met. We intend for Carbon evolution to follow
   Unicode evolution, including removing identifier characters as appropriate
   over time.
 * UAX31-R2: requirement not met. We intend for Carbon evolution to follow
   Unicode evolution, including adding identifier characters as appropriate
   over time.
 * UAX31-R3: requirement met. Carbon treats characters as whitespace if and
   only if they are `Pattern_White_Space` characters, and all operator tokens
   are formed exclusively from `Pattern_Syntax` characters.
 * UAX31-R4: requirement met. Carbon identifiers are required to be in NFC,
   so identifiers that are the same in NFC are equivalent.
 * UAX31-R5: requirement not met. Carbon identifiers are case-sensitive.
 * UAX31-R6: requirement met. No characters are excluded from normalization.
 * UAX31-R7: requirement not met. Carbon identifiers are case-sensitive.

### Line continuation rationale

Line continuation in C++ is sometimes necessary in order to combine the needs
of line-oriented parsing with the desire to meet a specific column limit or
format code nicely. For example:

```c++
#define SOME_MACRO \
  very long macro body \
  split over multiple lines
#define OTHER_MACRO \
  if (pretty_code) \
    do { wrap_lines() } while (false)
```

We do not have a commensurate need for line continuation in Carbon. We intend
to include no line-oriented syntax. In reasonable cases where an individual
token is longer than a natural column limit (such as for a long string
literal), we will provide a mechanism to wrap the token without line
continuation.

Line continuation for comments in particular is a known source of gotchas in C
and C++ programs.

## Nested comments rationale

There is a known need for nested comment syntax: it is important to be able to
comment out a block of code confident in the knowledge that all text between
the comment markers (and exactly that text) was in fact commented out.

The only facility for this in C and C++ is `#if 0` ... `#endif`, and that is
what is used in practice. As we do not want Carbon to have a textual
preprocessor, enabling nesting of some other comment scheme seems natural.

Conversely, it is valuable to have a comment syntax for human-readable
commentary that can be used within a line and can span multiple lines, and we
see no reason to invent something other than `/* ... */` for this purpose. We
cannot use the same notation as nested comment syntax without compromising its
usage for human-readable commentary. For example:

```carbon
f(1.0 / x /* can't be negative */, 2);
```

... would not be valid as a `/*{ ... }*/` comment, because it would contain an
unterminated character literal.

### Comment introducers rationale

We anticipate the possibility of adding additional kinds of comment in the
future. Reserving syntactic space in comment syntax, in a way that is easy for
programs to avoid, allows us to add such additional kinds of comment as a
non-breaking change.

### Block strings rationale

Block literals are a useful way of expressing multiline string content in a
program. It's useful to treat block literals and raw literals as distinct
concepts: even within multiline literals, explicit encoding of tab characters,
character escapes, and so forth can be useful or undesirable.

Further, separating the concepts permits us to disallow newlines in non-block
raw string literals, which prevents one class of runaway lexing problem: the
inability to find the end of a raw string literal can lead to scanning and
consuming the entirety of the source file.

Removing the initial indentation from block string literals serves two primary
purposes: it allows the lexer to intelligently abort and backtrack sooner if it
reaches the end of the indented region without seeing the end of string marker,
and it improves the readability of the code.

### Keywords rationale

One of Carbon's most important goals is to support program and language
evolution. We know that the set of keywords in Carbon will grow over time,
and the easiest kind of language change from an evolutionary perspective is one
that is known to break no programs, that lets programs migrate incrementally to
the new language rule, and that either has no migration cost or only imposes
automatable migration cost on the code that intends to use the new feature.

The proposed approach to keywords intends to support such a migration story.
Adding new keywords to Carbon is a non-breaking change. Because every
identifier is locally declared using obvious syntax before it is used, it is
straightforward to detect, using simple rules, whether a particular identifier
is a keyword or not in a particular source file.

Using a new keyword in an existing source file requires first replacing all
existing uses of that identifier with raw identifiers throughout the source
file, which is a mechanical, automatable change.

For identifiers whose scopes are constrained to a single source file, raw
identifiers are not necessary to permit such a transition. However, for
identifiers that are declared in one source file and consumed in another, we
still need a mechanism to continue declaring a name as an identifier after it
has been claimed as a keyword.

Note that while this means that adding a new keyword is cheap in terms of
migration cost, we should still think of adding a keyword as being a
significant undertaking, as each keyword will occupy space in the mind of the
Carbon programmer. However, we should not feel any pressure to reuse the same
keyword for distinct purposes.

This approach brings one important restriction: in any syntax that introduces
an identifier, there should never be an optional keyword preceding the
identifier, and nor should the identifier be optional if it can be followed by
a keyword.

### Designators rationale

We wish to have uniform scoping and name lookup rules throughout Carbon.
However, we also wish to parse expressions such as `x.y`, where `x` is looked
up as an identifier, and `y` has some other lookup rule. We also wish to use
`.y` as a designator when initializing fields.

It is reasonable to conclude that an identifier preceded by a period is a
fundamentally different kind of token from a regular identifier: it has
different name lookup rules (if it's looked up at all) and cannot simply be
immediately resolved by lookup in the environment.

Treating such tokens as special at the lexical level has other beneficial effects:

 * It avoids a special case in the rules for binary operators. This would be
   the only binary operator that affects how name lookup is performed on its
   right-hand side, and would be the only binary operator for which we do not
   expect (or perhaps require) whitespace on both sides.
 * It prohibits whitespace between the period and the identifier. This enforces
   an intended stylistic convention. As a postfix unary operator, we will also
   enforce an absence of whitespace before designators in member access syntax.
 * It frees up `.` for use as a binary operator, should we so desire.
 * It allows extremely fast lexical name lookup for all identifiers via string
   interning: the same lookup that checks whether an identifier is a keyword
   can also perform the complete lexical lookup if it's not an identifier.
 * It permits uniform typo correction, including correction to keywords, for
   all identifiers in all contexts, because we can identify typos from the
   lexing stage before we even reach the parser.

### Operators rationale

We use a strict "max munch" rule for operators, without regard for Carbon's
current operator set. This requires parentheses in code that would apply
multiple prefix or postfix operators in a row, such as `-*p`, but gives us the
advantage that adding new operators is always a non-breaking change for all
existing Carbon code.

### Compound brackets rationale

We intend for each notation in Carbon code to have exactly one meaning, and for
the language to be evolvable in new directions. However, there are only three
easily-typable sets of brackets for most Carbon programmers -- four if you
include `<>`, which introduces a host of problems. We already know of more than
this many different kinds of bracketed region we wish to support, and have
started trying to play syntactic games to treat them as the same thing in order
to get back down to only three.

Including compound brackets allows us to solve these problems: we have an
unbounded set of potential bracket pairs, without substantially increasing the
complexity of parsing Carbon code. The bracket terminator characters are chosen
such that a bracket followed by an operator can be easily visually separated by
a reader of Carbon code: even in a tricky case such as `[*|*p|*]`, the
expression `*p` within the `[*|` ... `|*]` brackets is reasonably readable. And
we will not need to resort to three-character brackets unless we exhaust our 9
kinds of two-character brackets.

Support for compound brackets requires that we make a concession: the bracket
terminator characters cannot be used within prefix or postfix operators. For
the two chosen symbols, this is unlikely to present a problem.

## Alternatives considered

TODO: Consider alternatives
