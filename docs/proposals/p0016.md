<!--
Part of the Carbon Language, under the Apache License v2.0 with LLVM Exceptions.
See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

# Carbon: Lexical conventions

- **Authors:** Richard Smith
- **[Tracking issue](https://github.com/carbon-language/carbon-lang/issues/16)**
- **Status:** RFC
- **Created:** 2020-05-18

**_PLEASE_ DO NOT SHARE OUTSIDE CARBON FORUMS**

## Problem

This document proposes a set of rules for the initial phase of processing a
Carbon source file: interpreting the contents of the file and forming
[tokens](#tokens).

## Proposal

Carbon source files are [UTF-8](#file-contents-and-encoding) text files whose
contents are divided into [whitespace](#whitespace), [comments](#comments),
[literals](#literals), [identifiers](#identifiers) (including
[keywords](#keywords)), [designators](#designators), [operators](#operators),
and [brackets](#brackets), as described below.

## Details

### File contents and encoding

Carbon source files are Unicode text files encoded in UTF-8. An initial UTF-8
BOM is permitted and ignored. All contents outside of [comments](#comments) and
[literals](#literals) shall be in Normalization Form C.
[[why?]](#encoding-rationale)

Carbon is currently based on Unicode 13.0, and will adopt new Unicode versions
as they are published.

### Whitespace

Characters are identified as whitespace if they have the Unicode
`Pattern_White_Space` property. These include the ASCII whitespace characters (recognized in C++):

 * Space and horizontal tab
 * Carriage return and line feed (which C++ conflates as "new line")
 * Vertical tab and form feed

As of Unicode version 13, 5 additional characters are included:

 * U+0085 NEXT LINE
 * U+200E LEFT-TO-RIGHT MARK
 * U+200F RIGHT-TO-LEFT MARK
 * U+2028 LINE SEPARATOR
 * U+2029 PARAGRAPH SEPARATOR

Space, horizontal tab, and the LTR and RTL marks are *horizontal whitespace*
characters. All other whitespace characters are *vertical whitespace*
characters.

Characters with the Unicode property `White_Space` but not
`Pattern_White_Space` are invalid outside comments and literals. Code
formatters are encouraged to convert them into recognized horizontal whitespace
characters. Implementations are encouraged to recover from the error as if
those characters were treated as horizontal whitespace.

A *line* is a possibly-empty sequence of characters preceded and followed by
either vertical whitespace or the beginning or end of the file. As a special
case, an empty sequence of characters preceded by a carriage return and
followed by a line feed is not treated as a line. For example, "foo\r\nbar"
contains two lines, and "foo\n\rbar" contains three, of which the middle line
is empty.

The *indentation* of a line is the sequence of horizontal whitespace characters
at the start of the line. A line *A* has more indentation than a line *B* the
indentation of *B* is a proper prefix of the indentation of *A*.

### Comments

A *comment* in Carbon is either:

 * A *line comment*, beginning with `//` and running to the end of the line, or
 * A *block comment*, beginning with `/*` and running to the matching `*/`.

Carbon has no mechanism for physical line continuation, so a `//` comment
always ends at the next vertical whitespace character.
[[why?]](#line-continuation-rationale)

If the character after the `/*` introducing a block comment is `{`, the comment
is a *code comment*. In a code comment, the following text is tokenized until a
matching `}*/` token is formed; such a token terminates the comment. (In
particular, such a token is not recognized if it is nested within another
comment or a literal.) Otherwise, the comment ends at the first matching `*/`
character sequence.
[[why?]](#nested-comments-rationale)

Example:

```carbon
// This is a comment.
// The characters /* introduce a block comment.
This is not a comment.
/*{
  // The characters */ end a block comment.
}*/
This is not a comment.
```

If the character after the comment introducer is an exclamation mark, the
comment is a documentation comment. Documentation comments are tokens, and are
recognized by the language grammar only in specific locations, which determine
the entity to which they attach.
[[why?]](#nested-comments-rationale)

Non-documentation comments are treated equivalently to whitespace.

In addition to the cases above, a block comment introducer may be followed by
additional `*` characters. If the character after the comment introducer is not
one of those mentioned above, it shall be a whitespace character.
[[why?]](#comment-introducers-rationale)

### Literals

Carbon provides literal syntax for numbers, and for character and string data.
(Additional constants, such as `True` and `Nullptr`, are exposed as keywords or
predeclared identifiers.)

A *literal* is a numeric literal, a character literal, or a string literal, as
defined below.

A literal shall not be immediately followed an [identifier continuation
character](#identifiers). Carbon has no literal suffixes, but the corresponding
lexical space is reserved for future extensions.

#### Numbers

Decimal integers are written as a non-zero decimal digit followed by zero or
more additional decimal digits, or as a single `0`.

Integers in other bases are written as a `0` followed by a base specifier
character, followed by a sequence of digits in the corresponding base. The
available base specifiers and corresponding bases are:

| Base specifier | Base | Digits                                |
| -------------- | ---- | ------------------------------------- |
| `b` or `B`     | 2    | `0` and `1`                           |
| `o`            | 8    | `0` ... `7`                           |
| `x` or `X`     | 16   | `0` ... `9`, `a` ... `f`, `A` ... `F` |

[TODO: This doesn't belong here.] There are no size suffixes. Each literal has
a unique type that can be converted to any sufficiently-large integer type, but
operations on it are always exact.

Real numbers are written as a sequence of one or more decimal digits followed
by a decimal point followed by a sequence of one or more decimal digits.

A real number can be followed by an `e`, an optional `+` or `-` (defaulting to
`+`), and a decimal integer *N*; the effect is to multiply the given value by
10<sup>&plusmn;*N*</sup>.

A *numeric literal* is an integer or real number expressed as described above.

#### Strings

[[alternatives]](#string-alternatives)

A *simple string literal* is formed of a sequence of

 * characters other than backslashes, double quotation marks, and vertical
   whitespace
 * escape sequences

enclosed in double quotation marks (`"`). Each escape sequence is replaced with
the corresponding character sequence or encoding.

TODO: Table of escape sequences.

A *raw string literal* starts with an `r` followed by *N* `#` characters
followed by a double quotation mark, and ends with the first following
occurrence of a double quotation mark followed by *N* `#` characters on the
same line. The text in between is not interpreted in any way.

A *block string literal* starts with three double quotation marks, followed by
an optional file type indicator, followed by a newline, and ends at the next
instance of three double quotation marks. The closing `"""` shall be the first
non-whitespace characters on that line. The lines between the opening line and
the new line are *content lines*. Each non-empty content line shall be [at
least as indented](#whitespace) as the line containing the closing `"""`. The
closing line shall be at least as indented as the opening line, and shall be
more indented if the opening `"""` are not the first non-whitespace characters
on the opening line. The content of the literal is formed by removing the
indentation of the closing line from each (non-empty) content line, and
concatenating the results with a line feed character added between each pair of
lines.
[[why?]](#block-strings-rationale)

A *file type indicator* is a sequence of characters that are either [identifier
continuation characters](#identifiers) or [operator characters](#operators).

A *raw block string literal* is expressed analogously to a raw string literal,
but for a block string literal. Escape sequences are ignored, but indentation
is removed and each vertical whitespace character is replaced by a line feed
as in a non-raw block string literal.

For example:

```carbon
fn f() {
  """
  This is a string literal. Its first character is 'T' and its last character
  is '.'. It contains one embedded newline, between 'character' and 'is'.
  """
  var String: x = r#"""
    This is the content of the string. The 'T' is the first character
    of the string.
    """ <-- This is not the end of the string.
    """#; // <-- But this is.
  var String: y = r"Hello\"; // OK, final character is \
  var String: z = r##"Raw strings r#"nesting"#"##;

  // This string starts and ends with two "s.
  var String: ambig1 = r#"""This is a raw string literal starting with """#;
  var String: ambig2 = r#"""This
    is a block string literal with file type 'This' and first character 'i'.
    """#;

  var String: starts_with_whitespace = """c++
      int x = 1; // This line starts with two spaces.
      int y = 2; // This line starts with two spaces.
    """;

  var String: invalid1 = """
error: insufficiently indented.
""";
  var String: invalid2 = r#"""
    error: closing """ is not on its own line."""#;
}
```

#### Characters

A *character literal* is lexically identical to a simple string literal, except
that it is enclosed in single quotation marks (`'`) instead of double quotation
marks (`"`).

### Identifiers

An *identifier* is a maximal sequence of characters beginning with a character
with Unicode property `XID_Start`, followed by zero or more *identifier
continuation characters*, which are characters that either have property
`XID_Continue` or are underscores (`_`).

Notably, `XID_Start` does not include the underscore character. Tokens
beginning with an underscore are [reserved](#reserved-tokens).
[[why?]](#underscores-rationale)

Additionally, a *raw identifier* can be specified by prefixing an identifier
with `r#`, such as `r#requires`. Raw identifiers can be used to introduce and
use names that are lexically identical to keywords.
[[why?]](#keywords-rationale)

All identifier tokens in all contexts are looked up using the same lexical
scoping rule.

An identifier shall not be immediately followed by a `"` or `'`.

#### Keywords

A *keyword* is an identifier with predefined meaning. Carbon has a predefined
set of keywords, that will be specified separately as part of the syntax rules.

An identifier that is a keyword may also be declared explicitly in a source
file. The same identifier shall not be used as both a keyword and as a non-raw
non-keyword identifier in a single source file. As a consequence of these
rules, from a lexical standpoint there is no notion of keywords -- whether a
given identifier is a keyword depends on the syntactic structure of the source
file.
[[why?]](#keywords-rationale)

Example:

```carbon
var Int: fn = 3; // OK, variable named 'fn'
fn f() {}        // error, 'fn' is not a keyword in this source file
interface var {} // error, already used 'var' as a keyword in this source file
```

### Designators

A *designator* is a token formed by prefixing an identifier with a period
character, such as `.member`. The identifier after the period is the *member
name*, and is looked up in a context-dependent manner.
[[why?]](#designators-rationale)

### Operators

An *operator* is a maximal sequence of characters with Unicode property
`Pattern_Syntax`, excluding `"` and `'` and those characters with class `Ps` or
`Pe` (for which, see [brackets](#brackets)), which we will refer to as
*operator characters*.
[[why?]](#operators-rationale)
We do not intend to define any operators containing non-ASCII characters. The
ASCII operator characters are:

```
!  #  $  %  &  *  +  -  .  /  :  ;  <  =  >  ?  @  \  ^  `  |  ~
```

Of these, we intend to not use <code>\`</code> due to its common use to escape
code, nor `$` due to its absence from many non-US keyboards. This leaves 20
operator characters, 400 digraphs, and so on.

Bracket operators, described below, are also operators.

### Brackets

A *simple open bracket* is a character with Unicode property `Pattern_Syntax`
and character class `Ps`, such as `(` or `[`.
A *simple close bracket* is a character
with Unicode property `Pattern_Syntax` and character class `Pe`, such as `}`.
A *bracket terminator character* is one of `|` or `:`.
A *bracket continuation character* is an operator character that is not a
bracket terminator character.

A *compound open bracket* is a simple open bracket followed by zero or more
bracket continuation characters followed by a bracket terminator character,
such as `[:`.
A *compound close bracket* is a bracket terminator character followed by zero
or more bracket continuation characters followed by a simple close bracket,
such as `|=)`.
[[why?]](#compound-brackets-rationale)

An *open bracket* is either a simple open bracket or a compound open bracket.
A *close bracket* is either a simple close bracket or a compound close bracket.

The close bracket matching an open bracket is formed by reversing the character
sequence in the open bracket and replacing each caracter with class `Ps` with
the corresponding character with class `Pe`. Every open bracket is required to
have a matching close bracket such that the bracketed regions form a tree
structure.

We do not intend to include any non-ASCII characters as part of Carbon's
syntax. This leaves 3 single-character brackets (`()`, `{}`, `[]`), 6 bracket
digraphs (`(| |)`, `{| |}`, `[| |]`, `(: :)`, `{: :}`, `[: :]`), 108 bracket
trigraphs, and so on.

For example:

```carbon
(this is within brackets {and this [this too]})
(|this is a different kind of bracket {: and another :}
   (**|lots of kinds of brackets can be built [=: this way :=]|**)
 |)
```

Each non-empty line from the line containing an opening bracket to the line
containing the matching closing bracket (inclusive) shall have at least as much
indentation as the line containing the opening bracket.
[[why?]](#bracket-indentation-rationale)

In addition, Carbon recognizes *bracket operators*, formed by a simple open
bracket followed by one or more operator characters followed by a matching
simple close bracket, such as `[~>]` or `(*)`. Bracket operators are operators,
not brackets.

### Tokens

A *token* is a documentation comment, a literal, an identifier (which might be
a keyword), a designator, an operator, or a bracket. Tokens are formed by a
single left-to-right scan of the source file, using a "max munch" rule: the
longest possible next token is formed at each step, after skipping whitespace
and comments.

#### Reserved tokens

It is an error if token formation (after skipping whitespace and comments) is
attempted in the following circumstances:

 * When the first character does not have property `XID_Continue` or
   `Pattern_Syntax`.
 * As a special case of the prior bullet, when the first character is an
   underscore. [[why?]](#underscores-rationale)
 * When the first two characters are `r#` and neither a raw identifier nor a
   raw string literal would be formed.

## Rationale

### Encoding rationale

We intend to follow the Unicode Consortium's recommentations for identifiers in
programming languages as described in Unicode 13.0.0
[UAX#31](https://unicode.org/reports/tr31/) Revision 33. We do not see a reason
to be inventive in this regard, and delegating the complex considerations over
how Unicode characters should be used to a group with greater expertise in that
area seems appropriate.

As an exception, Carbon permits underscore as a continuation character in
identifiers. Usage of this character is sufficiently common in C++ identifiers
that excluding it conflicts with our interoperability goal. However, leading
underscores are not permitted in Carbon identifiers.
[[why?]](#underscores-rationale)

We observe UAX#31's requirements as follows:

 * UAX31-R1: requirement met. Identifiers are of the form `XID_Start`
   `Continue`\*, using a profile in which `Continue` is `XID_Continue` plus
   U+005F LOW LINE (`_`).
 * UAX31-R1a: requirement not met. Format characters are not permitted in
   identifiers.
 * UAX31-R1b: requirement not met. We intend for Carbon evolution to follow
   Unicode evolution, including removing identifier characters as appropriate
   over time.
 * UAX31-R2: requirement not met. We intend for Carbon evolution to follow
   Unicode evolution, including adding identifier characters as appropriate
   over time.
 * UAX31-R3: requirement met. Carbon treats characters as whitespace if and
   only if they are `Pattern_White_Space` characters, and all operator tokens
   are formed exclusively from `Pattern_Syntax` characters.
 * UAX31-R4: requirement met. Carbon identifiers are required to be in NFC,
   so identifiers that are the same in NFC are equivalent.
 * UAX31-R5: requirement not met. Carbon identifiers are case-sensitive, so
   this requirement is inapplicable.
 * UAX31-R6: requirement met. No characters are excluded from normalization.
 * UAX31-R7: requirement not met. Carbon identifiers are case-sensitive, so
   this requirement is inapplicable.
 * UAX31-R8: requirement not applicable. Carbon does not have hashtag
   identifiers.

### Line continuation rationale

Line continuation in C++ is sometimes necessary in order to combine the needs
of line-oriented parsing with the desire to meet a specific column limit or
format code nicely. For example:

```c++
#define SOME_MACRO \
  very long macro body \
  split over multiple lines
#define OTHER_MACRO \
  if (pretty_code) \
    do { wrap_lines() } while (false)
```

We do not have a commensurate need for line continuation in Carbon. We intend
to include no line-oriented syntax. In reasonable cases where an individual
token is longer than a natural column limit (such as for a long string
literal), we will provide a mechanism to wrap the token without line
continuation.

Line continuation for comments in particular is a known source of gotchas in C
and C++ programs.

## Nested comments rationale

There is a known need for nested comment syntax: it is important to be able to
comment out a block of code confident in the knowledge that all text between
the comment markers (and exactly that text) was in fact commented out.

The only facility for this in C and C++ is `#if 0` ... `#endif`, and that is
what is used in practice. As we do not want Carbon to have a textual
preprocessor, enabling nesting of some other comment scheme seems natural.

Conversely, it is valuable to have a comment syntax for human-readable
commentary that can be used within a line and can span multiple lines, and we
see no reason to invent something other than `/* ... */` for this purpose. We
cannot use the same notation as nested comment syntax without compromising its
usage for human-readable commentary. For example:

```carbon
f(1.0 / x /* can't be negative */, 2);
```

... would not be valid as a `/*{ ... }*/` comment, because it would contain an
unterminated character literal.

### Comment introducers rationale

We anticipate the possibility of adding additional kinds of comment in the
future. Reserving syntactic space in comment syntax, in a way that is easy for
programs to avoid, allows us to add such additional kinds of comment as a
non-breaking change.

### Block strings rationale

Block literals are a useful way of expressing multiline string content in a
program. It's useful to treat block literals and raw literals as distinct
concepts: even within multiline literals, explicit encoding of tab characters,
character escapes, and so forth can be useful or undesirable. For example:

```carbon
var String: raw_code = r"""carbon
  var String: example = "hello\n\tworld"; // Contains two backslashes.
  """;
var String: expanded_code = """carbon
  \tvar Int: n = 123; // Starts with tab and ends with newline.\n
  """;
```

Further, separating the concepts permits us to disallow newlines in non-block
raw string literals, which prevents one class of runaway lexing problem: the
inability to find the end of a raw string literal can lead to scanning and
consuming the entirety of the source file. It is better to ask the user to
explicitly express their intent than to assume that we're in the rare case
where a missing closing double-quote indicates a multi-line string.

Removing the initial indentation from block string literals serves two primary
purposes: it allows the lexer to intelligently abort and backtrack sooner if it
reaches the end of the indented region without seeing the end of string marker
(essentially enabling detection of runaway block string literals), and it
improves the readability of the code.

### Underscores rationale

Tokens beginning with an underscore are currently reserved, but are expected to
be used to represent wildcards in pattern matching. The precise rules are not
yet determined, so we are not committing to any lexical conventions for such
tokens yet.

We could permit such tokens as identifiers for now, and claim them back as
keywords later if needed. There are some reasons not to follow that approach:

 * The semantic interpretation of such tokens may be quite different from that
   of regular identifiers: they may not be subject to regular name lookup and
   not required to be declared before being used, but also not part of a
   predefined finite set of keywords with unique meaning.
 * We may want to use different lexical rules for underscores, such as treating
   `_` as a standalone token (even when followed by an identifier) or as an
   operator character. The evolutionary path for such a change would be
   challenging.

Underscores in identifiers are common in C++ identifiers, which motivates
permitting them in Carbon to support our C++ interoperability goal. However,
leading underscores are rare in publicly-visible C++ identifiers, and result in
reserved identifiers in many contexts, so we do not have similar motivation to
permit those.

Leading underscores are used in some C++ code to distinguish member names from
non-member names. In Carbon, we anticipate all identifiers being declared
locally and found by a simple lexical lookup rule, so use of leading
underscores to avoid name collisions should generally be unnecessary. As such,
we lack a strong motivation to permit such identifiers.

### Keywords rationale

One of Carbon's most important goals is to support program and language
evolution. We know that the set of keywords in Carbon will grow over time,
and the easiest kind of language change from an evolutionary perspective is one
that is known to break no programs, that lets programs migrate incrementally to
the new language rule, and that either has no migration cost or only imposes
automatable migration cost on the code that intends to use the new feature.

The proposed approach to keywords intends to support such a migration story.
Adding new keywords to Carbon is a non-breaking change. Because every
identifier is locally declared using obvious syntax before it is used, it is
straightforward to detect, using simple rules, whether a particular identifier
is a keyword or not in a particular source file.

Using a new keyword in an existing source file requires first replacing all
existing uses of that identifier with raw identifiers throughout the source
file, which is a mechanical, automatable change.

For identifiers whose scopes are constrained to a single source file, raw
identifiers are not necessary to permit such a transition. However, for
identifiers that are declared in one source file and consumed in another, we
still need a mechanism to continue declaring a name as an identifier after it
has been claimed as a keyword.

Note that while this means that adding a new keyword is cheap in terms of
migration cost, we should still think of adding a keyword as being a
significant undertaking, as each keyword will occupy space in the mind of the
Carbon programmer. However, we should not feel any pressure to reuse the same
keyword for distinct purposes.

This approach brings one important restriction: in any syntax that introduces
an identifier, there should never be an optional keyword preceding the
identifier, and nor should the identifier be optional if it can be followed by
a keyword.

### Designators rationale

We wish to have uniform scoping and name lookup rules throughout Carbon.
However, we also wish to parse expressions such as `x.y`, where `x` is looked
up as an identifier, and `y` has some other lookup rule. We also wish to use
`.y` as a designator when initializing fields.

It is reasonable to conclude that an identifier preceded by a period is a
fundamentally different kind of token from a regular identifier: it has
different name lookup rules (if it's looked up at all) and cannot simply be
immediately resolved by lookup in the environment.

Treating such tokens as special at the lexical level has other beneficial effects:

 * It avoids a special case in the rules for binary operators. This would be
   the only binary operator that affects how name lookup is performed on its
   right-hand side, and would be the only binary operator for which we do not
   expect (or perhaps require) whitespace on both sides.
 * It prohibits whitespace between the period and the identifier. This enforces
   an intended stylistic convention. As a postfix unary operator, we will also
   enforce an absence of whitespace before designators in member access syntax.
 * It allows extremely fast lexical name lookup for all identifiers via string
   interning: the same lookup that checks whether an identifier is a keyword
   can also perform the complete lexical lookup if it's not an identifier.
 * It permits uniform typo correction, including correction to keywords, for
   all identifiers in all contexts, because we can identify typos from the
   lexing stage before we even reach the parser.
 * It frees up `.` for use as a binary operator, should we so desire.

### Operators rationale

We use a strict "max munch" rule for operators, without regard for Carbon's
current operator set. This requires parentheses in code that would apply
multiple prefix or postfix operators in a row, such as `-*p`, but gives us the
advantage that adding new operators is always a non-breaking change for all
existing Carbon code.

### Compound brackets rationale

We intend for each notation in Carbon code to have exactly one meaning, and for
the language to be evolvable in new directions. However, there are only three
easily-typable sets of brackets for most Carbon programmers -- four if you
include `<>`, which introduces a host of problems. We already know of more than
this many different kinds of bracketed region we wish to support, and have
started trying to play syntactic games to treat them as the same thing in order
to get back down to only three.

Including compound brackets allows us to solve these problems: we have an
unbounded set of potential bracket pairs, without substantially increasing the
complexity of parsing Carbon code. The bracket terminator characters are chosen
such that a bracket followed by an operator can be easily visually separated by
a reader of Carbon code: even in a tricky case such as `[*|*p|*]`, the
expression `*p` within the `[*|` ... `|*]` brackets is reasonably readable. And
we will not need to resort to three-character brackets unless we exhaust our 9
kinds of two-character brackets.

Support for compound brackets requires that we make a concession: the bracket
terminator characters cannot be used within prefix or postfix operators. For
the two chosen symbols, this is unlikely to present a problem.

### Bracket indentation rationale

We wish for Carbon to provide good error diagnosis and recovery, to support
tooling and analysis of incomplete source files, and to reject cases where we
can be confident that the intent of the programmer is not captured by the code.
To support these goals, we require that the indentation of code reflects the
logical structure of the code, and one of the ways we achieve this is by
requiring that the contents of a bracketed region are at least as indented as
the opening line of that bracketed region. For example, given:

```carbon
fn f() {
  if (cond) {
    // ...
}

fn g() {
```

we can be confident that the intention was for the closing brace on line 4 to
match the opening brace on line 1, not the opening brace on line 2. By
recognizing this early, we can produce improved diagnostics indicating that a
closing brace was missing, and tools that perform semantic analysis of
potentially-incomplete source files can recover by imagining that an additional
closing brace appeared before line 4.

This indentation rule is insufficient to fully ensure that our interpretation
of the program matches the programmer's intent and the reader's expectations.
Generally, we wish for all continuation lines of any grammatical construct to
be at least as indented as the first line in that construct.

## Alternatives considered

### String alternatives

Block string literals could use explicit characters in the body to indicate the
amount of leading whitespace to be removed:

```carbon
var String: x = """
  |  starts with two spaces.
  """;
```

This would allow the correct indentation to be determined as soon as the first
line after the opening `"""` is seen. However, this adds lexical complexity,
and most of the same benefit can be derived by simply requiring the indentation
of the string literal to be greater than that of its contents.

We could choose to include the newline before the terminating `"""` as part of
the literal contents. However, expectations for whether it should be included
vary, and appear to be somewhat evenly split between the two options. If the
terminating newline is included in the string, it would be natural to permit
the terminating `"""` to not be preceded by a newline, which removes the most
natural vehicle by which we can determine the proper indentation to remove from
each line.

### Operators alternatives

We could use a "max munch" rule for operators that is restricted to only
recognize a known set of Carbon operators. This would permit constructs such as
`-*p` or `**p` without additional brackets or whitespace. This would improve
the language ergonomics, but would make language evolution more difficult.
