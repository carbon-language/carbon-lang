// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// RUN: %clang_cc1 -triple x86_64-unknown-linux-gnu -emit-llvm %s -o - | FileCheck %s

// CHECK-LABEL: @_Z1fv(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[I:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[X:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store i32 0, i32* [[I]], align 4
// CHECK-NEXT:    br label [[FOR_COND:%.*]]
// CHECK:       for.cond:
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, i32* [[I]], align 4
// CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[TMP0]], 2
// CHECK-NEXT:    [[TMP1:%.*]] = zext i1 [[CMP]] to i64
// CHECK-NEXT:    [[COND:%.*]] = select i1 [[CMP]], i32 1, i32 0
// CHECK-NEXT:    store i32 [[COND]], i32* [[X]], align 4
// CHECK-NEXT:    [[TMP2:%.*]] = load i32, i32* [[X]], align 4
// CHECK-NEXT:    [[TOBOOL:%.*]] = icmp ne i32 [[TMP2]], 0
// CHECK-NEXT:    br i1 [[TOBOOL]], label [[FOR_BODY:%.*]], label [[FOR_END:%.*]]
// CHECK:       for.body:
// CHECK-NEXT:    [[TMP3:%.*]] = load i32, i32* [[X]], align 4
// CHECK-NEXT:    store i32 [[TMP3]], i32* [[RETVAL]], align 4
// CHECK-NEXT:    br label [[RETURN:%.*]]
// CHECK:       for.inc:
// CHECK-NEXT:    [[TMP4:%.*]] = load i32, i32* [[I]], align 4
// CHECK-NEXT:    [[INC:%.*]] = add nsw i32 [[TMP4]], 1
// CHECK-NEXT:    store i32 [[INC]], i32* [[I]], align 4
// CHECK-NEXT:    br label [[FOR_COND]], !llvm.loop [[LOOP2:![0-9]+]]
// CHECK:       for.end:
// CHECK-NEXT:    store i32 0, i32* [[RETVAL]], align 4
// CHECK-NEXT:    br label [[RETURN]]
// CHECK:       return:
// CHECK-NEXT:    [[TMP5:%.*]] = load i32, i32* [[RETVAL]], align 4
// CHECK-NEXT:    ret i32 [[TMP5]]
//
int f() {
  for (int i = 0; int x = i < 2 ? 1 : 0; i++) {
    return x;
  }
  return 0;
}

