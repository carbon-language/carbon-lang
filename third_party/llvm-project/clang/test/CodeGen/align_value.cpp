// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// RUN: %clang_cc1 -no-opaque-pointers -triple x86_64-unknown-unknown -emit-llvm -o - %s | FileCheck %s

typedef double * __attribute__((align_value(64))) aligned_double;

// CHECK-LABEL: @_Z3fooPdS_Rd(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[X_ADDR:%.*]] = alloca double*, align 8
// CHECK-NEXT:    [[Y_ADDR:%.*]] = alloca double*, align 8
// CHECK-NEXT:    [[Z_ADDR:%.*]] = alloca double*, align 8
// CHECK-NEXT:    store double* [[X:%.*]], double** [[X_ADDR]], align 8
// CHECK-NEXT:    store double* [[Y:%.*]], double** [[Y_ADDR]], align 8
// CHECK-NEXT:    store double* [[Z:%.*]], double** [[Z_ADDR]], align 8
// CHECK-NEXT:    ret void
//
void foo(aligned_double x, double * y __attribute__((align_value(32))),
         double & z __attribute__((align_value(128)))) { };

struct ad_struct {
  aligned_double a;
};

// CHECK-LABEL: @_Z3fooR9ad_struct(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[X_ADDR:%.*]] = alloca %struct.ad_struct*, align 8
// CHECK-NEXT:    store %struct.ad_struct* [[X:%.*]], %struct.ad_struct** [[X_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load %struct.ad_struct*, %struct.ad_struct** [[X_ADDR]], align 8
// CHECK-NEXT:    [[A:%.*]] = getelementptr inbounds [[STRUCT_AD_STRUCT:%.*]], %struct.ad_struct* [[TMP0]], i32 0, i32 0
// CHECK-NEXT:    [[TMP1:%.*]] = load double*, double** [[A]], align 8
// CHECK-NEXT:    call void @llvm.assume(i1 true) [ "align"(double* [[TMP1]], i64 64) ]
// CHECK-NEXT:    ret double* [[TMP1]]
//
double *foo(ad_struct& x) {

  return x.a;
}

// CHECK-LABEL: @_Z3gooP9ad_struct(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[X_ADDR:%.*]] = alloca %struct.ad_struct*, align 8
// CHECK-NEXT:    store %struct.ad_struct* [[X:%.*]], %struct.ad_struct** [[X_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load %struct.ad_struct*, %struct.ad_struct** [[X_ADDR]], align 8
// CHECK-NEXT:    [[A:%.*]] = getelementptr inbounds [[STRUCT_AD_STRUCT:%.*]], %struct.ad_struct* [[TMP0]], i32 0, i32 0
// CHECK-NEXT:    [[TMP1:%.*]] = load double*, double** [[A]], align 8
// CHECK-NEXT:    call void @llvm.assume(i1 true) [ "align"(double* [[TMP1]], i64 64) ]
// CHECK-NEXT:    ret double* [[TMP1]]
//
double *goo(ad_struct *x) {

  return x->a;
}

// CHECK-LABEL: @_Z3barPPd(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[X_ADDR:%.*]] = alloca double**, align 8
// CHECK-NEXT:    store double** [[X:%.*]], double*** [[X_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load double**, double*** [[X_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = load double*, double** [[TMP0]], align 8
// CHECK-NEXT:    call void @llvm.assume(i1 true) [ "align"(double* [[TMP1]], i64 64) ]
// CHECK-NEXT:    ret double* [[TMP1]]
//
double *bar(aligned_double *x) {

  return *x;
}

// CHECK-LABEL: @_Z3carRPd(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[X_ADDR:%.*]] = alloca double**, align 8
// CHECK-NEXT:    store double** [[X:%.*]], double*** [[X_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load double**, double*** [[X_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = load double*, double** [[TMP0]], align 8
// CHECK-NEXT:    call void @llvm.assume(i1 true) [ "align"(double* [[TMP1]], i64 64) ]
// CHECK-NEXT:    ret double* [[TMP1]]
//
double *car(aligned_double &x) {

  return x;
}

// CHECK-LABEL: @_Z3darPPd(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[X_ADDR:%.*]] = alloca double**, align 8
// CHECK-NEXT:    store double** [[X:%.*]], double*** [[X_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load double**, double*** [[X_ADDR]], align 8
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds double*, double** [[TMP0]], i64 5
// CHECK-NEXT:    [[TMP1:%.*]] = load double*, double** [[ARRAYIDX]], align 8
// CHECK-NEXT:    call void @llvm.assume(i1 true) [ "align"(double* [[TMP1]], i64 64) ]
// CHECK-NEXT:    ret double* [[TMP1]]
//
double *dar(aligned_double *x) {

  return x[5];
}

aligned_double eep();
// CHECK-LABEL: @_Z3retv(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CALL:%.*]] = call noundef double* @_Z3eepv()
// CHECK-NEXT:    call void @llvm.assume(i1 true) [ "align"(double* [[CALL]], i64 64) ]
// CHECK-NEXT:    ret double* [[CALL]]
//
double *ret() {

  return eep();
}

// CHECK-LABEL: @_Z3no1PPd(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[X_ADDR:%.*]] = alloca double**, align 8
// CHECK-NEXT:    store double** [[X:%.*]], double*** [[X_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load double**, double*** [[X_ADDR]], align 8
// CHECK-NEXT:    ret double** [[TMP0]]
//
double **no1(aligned_double *x) {
  return x;
}

// CHECK-LABEL: @_Z3no2RPd(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[X_ADDR:%.*]] = alloca double**, align 8
// CHECK-NEXT:    store double** [[X:%.*]], double*** [[X_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load double**, double*** [[X_ADDR]], align 8
// CHECK-NEXT:    ret double** [[TMP0]]
//
double *&no2(aligned_double &x) {
  return x;
}

// CHECK-LABEL: @_Z3no3RPd(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[X_ADDR:%.*]] = alloca double**, align 8
// CHECK-NEXT:    store double** [[X:%.*]], double*** [[X_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load double**, double*** [[X_ADDR]], align 8
// CHECK-NEXT:    ret double** [[TMP0]]
//
double **no3(aligned_double &x) {
  return &x;
}

// CHECK-LABEL: @_Z3no3Pd(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[X_ADDR:%.*]] = alloca double*, align 8
// CHECK-NEXT:    store double* [[X:%.*]], double** [[X_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load double*, double** [[X_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = load double, double* [[TMP0]], align 8
// CHECK-NEXT:    ret double [[TMP1]]
//
double no3(aligned_double x) {
  return *x;
}

// CHECK-LABEL: @_Z3no4Pd(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[X_ADDR:%.*]] = alloca double*, align 8
// CHECK-NEXT:    store double* [[X:%.*]], double** [[X_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load double*, double** [[X_ADDR]], align 8
// CHECK-NEXT:    ret double* [[TMP0]]
//
double *no4(aligned_double x) {
  return x;
}

