// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// RUN: %clang_cc1 %s -emit-llvm -o - -triple x86_64-unknown-unknown | FileCheck %s

#include <stdarg.h>

struct S { float a[3]; };
struct S a[5];

// CHECK-LABEL: @check(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[Z_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[ARG:%.*]] = alloca [[STRUCT_S:%.*]], align 4
// CHECK-NEXT:    [[P:%.*]] = alloca %struct.S*, align 8
// CHECK-NEXT:    [[AP:%.*]] = alloca [1 x %struct.__va_list_tag], align 16
// CHECK-NEXT:    [[J:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[K:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[I:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[TMP:%.*]] = alloca [[STRUCT_S]], align 4
// CHECK-NEXT:    store i32 [[Z:%.*]], i32* [[Z_ADDR]], align 4
// CHECK-NEXT:    store i32 0, i32* [[J]], align 4
// CHECK-NEXT:    store i32 0, i32* [[K]], align 4
// CHECK-NEXT:    [[ARRAYDECAY:%.*]] = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* [[AP]], i64 0, i64 0
// CHECK-NEXT:    [[ARRAYDECAY1:%.*]] = bitcast %struct.__va_list_tag* [[ARRAYDECAY]] to i8*
// CHECK-NEXT:    call void @llvm.va_start(i8* [[ARRAYDECAY1]])
// CHECK-NEXT:    store %struct.S* getelementptr inbounds ([5 x %struct.S], [5 x %struct.S]* @a, i64 0, i64 2), %struct.S** [[P]], align 8
// CHECK-NEXT:    [[ARRAYDECAY2:%.*]] = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* [[AP]], i64 0, i64 0
// CHECK-NEXT:    [[FP_OFFSET_P:%.*]] = getelementptr inbounds [[STRUCT___VA_LIST_TAG:%.*]], %struct.__va_list_tag* [[ARRAYDECAY2]], i32 0, i32 1
// CHECK-NEXT:    [[FP_OFFSET:%.*]] = load i32, i32* [[FP_OFFSET_P]], align 4
// CHECK-NEXT:    [[FITS_IN_FP:%.*]] = icmp ule i32 [[FP_OFFSET]], 144
// CHECK-NEXT:    br i1 [[FITS_IN_FP]], label [[VAARG_IN_REG:%.*]], label [[VAARG_IN_MEM:%.*]]
// CHECK:       vaarg.in_reg:
// CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds [[STRUCT___VA_LIST_TAG]], %struct.__va_list_tag* [[ARRAYDECAY2]], i32 0, i32 3
// CHECK-NEXT:    [[REG_SAVE_AREA:%.*]] = load i8*, i8** [[TMP0]], align 16
// CHECK-NEXT:    [[TMP1:%.*]] = getelementptr i8, i8* [[REG_SAVE_AREA]], i32 [[FP_OFFSET]]
// CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i8, i8* [[TMP1]], i64 16
// CHECK-NEXT:    [[TMP3:%.*]] = bitcast %struct.S* [[TMP]] to { <2 x float>, float }*
// CHECK-NEXT:    [[TMP4:%.*]] = bitcast i8* [[TMP1]] to <2 x float>*
// CHECK-NEXT:    [[TMP5:%.*]] = load <2 x float>, <2 x float>* [[TMP4]], align 16
// CHECK-NEXT:    [[TMP6:%.*]] = getelementptr inbounds { <2 x float>, float }, { <2 x float>, float }* [[TMP3]], i32 0, i32 0
// CHECK-NEXT:    store <2 x float> [[TMP5]], <2 x float>* [[TMP6]], align 4
// CHECK-NEXT:    [[TMP7:%.*]] = bitcast i8* [[TMP2]] to float*
// CHECK-NEXT:    [[TMP8:%.*]] = load float, float* [[TMP7]], align 16
// CHECK-NEXT:    [[TMP9:%.*]] = getelementptr inbounds { <2 x float>, float }, { <2 x float>, float }* [[TMP3]], i32 0, i32 1
// CHECK-NEXT:    store float [[TMP8]], float* [[TMP9]], align 4
// CHECK-NEXT:    [[TMP10:%.*]] = bitcast { <2 x float>, float }* [[TMP3]] to %struct.S*
// CHECK-NEXT:    [[TMP11:%.*]] = add i32 [[FP_OFFSET]], 32
// CHECK-NEXT:    store i32 [[TMP11]], i32* [[FP_OFFSET_P]], align 4
// CHECK-NEXT:    br label [[VAARG_END:%.*]]
// CHECK:       vaarg.in_mem:
// CHECK-NEXT:    [[OVERFLOW_ARG_AREA_P:%.*]] = getelementptr inbounds [[STRUCT___VA_LIST_TAG]], %struct.__va_list_tag* [[ARRAYDECAY2]], i32 0, i32 2
// CHECK-NEXT:    [[OVERFLOW_ARG_AREA:%.*]] = load i8*, i8** [[OVERFLOW_ARG_AREA_P]], align 8
// CHECK-NEXT:    [[TMP12:%.*]] = bitcast i8* [[OVERFLOW_ARG_AREA]] to %struct.S*
// CHECK-NEXT:    [[OVERFLOW_ARG_AREA_NEXT:%.*]] = getelementptr i8, i8* [[OVERFLOW_ARG_AREA]], i32 16
// CHECK-NEXT:    store i8* [[OVERFLOW_ARG_AREA_NEXT]], i8** [[OVERFLOW_ARG_AREA_P]], align 8
// CHECK-NEXT:    br label [[VAARG_END]]
// CHECK:       vaarg.end:
// CHECK-NEXT:    [[VAARG_ADDR:%.*]] = phi %struct.S* [ [[TMP10]], [[VAARG_IN_REG]] ], [ [[TMP12]], [[VAARG_IN_MEM]] ]
// CHECK-NEXT:    [[TMP13:%.*]] = bitcast %struct.S* [[ARG]] to i8*
// CHECK-NEXT:    [[TMP14:%.*]] = bitcast %struct.S* [[VAARG_ADDR]] to i8*
// CHECK-NEXT:    call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 [[TMP13]], i8* align 4 [[TMP14]], i64 12, i1 false)
// CHECK-NEXT:    [[ARRAYDECAY3:%.*]] = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* [[AP]], i64 0, i64 0
// CHECK-NEXT:    [[ARRAYDECAY34:%.*]] = bitcast %struct.__va_list_tag* [[ARRAYDECAY3]] to i8*
// CHECK-NEXT:    call void @llvm.va_end(i8* [[ARRAYDECAY34]])
// CHECK-NEXT:    [[TMP15:%.*]] = load %struct.S*, %struct.S** [[P]], align 8
// CHECK-NEXT:    [[TOBOOL:%.*]] = icmp ne %struct.S* [[TMP15]], null
// CHECK-NEXT:    br i1 [[TOBOOL]], label [[LAND_LHS_TRUE:%.*]], label [[IF_END:%.*]]
// CHECK:       land.lhs.true:
// CHECK-NEXT:    [[TMP16:%.*]] = load %struct.S*, %struct.S** [[P]], align 8
// CHECK-NEXT:    [[A:%.*]] = getelementptr inbounds [[STRUCT_S]], %struct.S* [[TMP16]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [3 x float], [3 x float]* [[A]], i64 0, i64 2
// CHECK-NEXT:    [[TMP17:%.*]] = load float, float* [[ARRAYIDX]], align 4
// CHECK-NEXT:    [[A5:%.*]] = getelementptr inbounds [[STRUCT_S]], %struct.S* [[ARG]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds [3 x float], [3 x float]* [[A5]], i64 0, i64 2
// CHECK-NEXT:    [[TMP18:%.*]] = load float, float* [[ARRAYIDX6]], align 4
// CHECK-NEXT:    [[CMP:%.*]] = fcmp une float [[TMP17]], [[TMP18]]
// CHECK-NEXT:    br i1 [[CMP]], label [[IF_THEN:%.*]], label [[IF_END]]
// CHECK:       if.then:
// CHECK-NEXT:    store i32 0, i32* [[RETVAL]], align 4
// CHECK-NEXT:    br label [[RETURN:%.*]]
// CHECK:       if.end:
// CHECK-NEXT:    store i32 1, i32* [[RETVAL]], align 4
// CHECK-NEXT:    br label [[RETURN]]
// CHECK:       return:
// CHECK-NEXT:    [[TMP19:%.*]] = load i32, i32* [[RETVAL]], align 4
// CHECK-NEXT:    ret i32 [[TMP19]]
//
int check (int z, ...)
{
  struct S arg, *p;
  va_list ap;
  int j = 0, k = 0;
  int i;
  va_start (ap, z);
  p = &a[2];
  arg = va_arg (ap, struct S);
  va_end (ap);
  if (p && p->a[2] != arg.a[2])
    return 0;
  return 1;
}
