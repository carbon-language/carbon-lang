// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// Example input for update_cc_test_checks
// RUN: %clang_cc1 -triple=x86_64-unknown-linux-gnu -emit-llvm -o - %s | FileCheck %s

// CHECK-LABEL: @test(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca i64, align 8
// CHECK-NEXT:    [[B_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store i64 [[A:%.*]], i64* [[A_ADDR]], align 8
// CHECK-NEXT:    store i32 [[B:%.*]], i32* [[B_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load i64, i64* [[A_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = load i32, i32* [[B_ADDR]], align 4
// CHECK-NEXT:    [[CONV:%.*]] = sext i32 [[TMP1]] to i64
// CHECK-NEXT:    [[ADD:%.*]] = add nsw i64 [[TMP0]], [[CONV]]
// CHECK-NEXT:    ret i64 [[ADD]]
//
long test(long a, int b) {
  return a + b;
}

// A function with a mangled name
// CHECK-LABEL: @_Z4testlii(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca i64, align 8
// CHECK-NEXT:    [[B_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[C_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store i64 [[A:%.*]], i64* [[A_ADDR]], align 8
// CHECK-NEXT:    store i32 [[B:%.*]], i32* [[B_ADDR]], align 4
// CHECK-NEXT:    store i32 [[C:%.*]], i32* [[C_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load i64, i64* [[A_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = load i32, i32* [[B_ADDR]], align 4
// CHECK-NEXT:    [[CONV:%.*]] = sext i32 [[TMP1]] to i64
// CHECK-NEXT:    [[ADD:%.*]] = add nsw i64 [[TMP0]], [[CONV]]
// CHECK-NEXT:    [[TMP2:%.*]] = load i32, i32* [[C_ADDR]], align 4
// CHECK-NEXT:    [[CONV1:%.*]] = sext i32 [[TMP2]] to i64
// CHECK-NEXT:    [[ADD2:%.*]] = add nsw i64 [[ADD]], [[CONV1]]
// CHECK-NEXT:    ret i64 [[ADD2]]
//
__attribute__((overloadable)) long test(long a, int b, int c) {
  return a + b + c;
}
