// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --include-generated-funcs --replace-value-regex "__([a-z]+)_offloading_[a-z0-9]+_[a-z0-9]+_(.*)_l[0-9]+" "somevar_[a-z0-9]+_"
// RUN: %clang_cc1 -triple x86_64-unknown-linux-gnu -fopenmp %s -emit-llvm -o - | FileCheck %s

void __test_offloading_42_abcdef_bar_l123();
void use(int);

void foo(int a)
{
    #pragma omp target
        use(a);

    __test_offloading_42_abcdef_bar_l123();
    int somevar_abc123_;
}
// CHECK-LABEL: @foo(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[A_CASTED:%.*]] = alloca i64, align 8
// CHECK-NEXT:    %{{somevar_[a-z0-9]+_}} = alloca i32, align 4
// CHECK-NEXT:    store i32 [[A:%.*]], i32* [[A_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, i32* [[A_ADDR]], align 4
// CHECK-NEXT:    [[CONV:%.*]] = bitcast i64* [[A_CASTED]] to i32*
// CHECK-NEXT:    store i32 [[TMP0]], i32* [[CONV]], align 4
// CHECK-NEXT:    [[TMP1:%.*]] = load i64, i64* [[A_CASTED]], align 8
// CHECK-NEXT:    call void @{{__omp_offloading_[a-z0-9]+_[a-z0-9]+_foo_l[0-9]+}}(i64 [[TMP1]]) #[[ATTR3:[0-9]+]]
// CHECK-NEXT:    call void (...) @{{__test_offloading_[a-z0-9]+_[a-z0-9]+_bar_l[0-9]+}}()
// CHECK-NEXT:    ret void
//
//
// CHECK-LABEL: @{{__omp_offloading_[a-z0-9]+_[a-z0-9]+_foo_l[0-9]+}}(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca i64, align 8
// CHECK-NEXT:    store i64 [[A:%.*]], i64* [[A_ADDR]], align 8
// CHECK-NEXT:    [[CONV:%.*]] = bitcast i64* [[A_ADDR]] to i32*
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, i32* [[CONV]], align 4
// CHECK-NEXT:    call void @use(i32 noundef [[TMP0]])
// CHECK-NEXT:    ret void
//
