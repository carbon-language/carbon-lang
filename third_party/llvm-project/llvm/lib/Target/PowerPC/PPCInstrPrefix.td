//-------------------------- Predicate definitions ---------------------------//
def IsPPC32 : Predicate<"!Subtarget->isPPC64()">;

// Mask immediates for MMA instructions (2, 4 and 8 bits).
def Msk2Imm : ImmLeaf<i32, [{ return isUInt<2>(Imm); }]>;
def Msk4Imm : ImmLeaf<i32, [{ return isUInt<4>(Imm); }]>;
def Msk8Imm : ImmLeaf<i32, [{ return isUInt<8>(Imm); }]>;

//===----------------------------------------------------------------------===//
// PowerPC ISA 3.1 specific type constraints.
//

def SDT_PPCSplat32 : SDTypeProfile<1, 3, [ SDTCisVT<0, v2i64>,
  SDTCisVec<1>, SDTCisInt<2>, SDTCisInt<3>
]>;
def SDT_PPCAccBuild : SDTypeProfile<1, 4, [
  SDTCisVT<0, v512i1>, SDTCisVT<1, v4i32>, SDTCisVT<2, v4i32>,
                       SDTCisVT<3, v4i32>, SDTCisVT<4, v4i32>
]>;
def SDT_PPCPairBuild : SDTypeProfile<1, 2, [
  SDTCisVT<0, v256i1>, SDTCisVT<1, v4i32>, SDTCisVT<2, v4i32>
]>;
def SDT_PPCAccExtractVsx : SDTypeProfile<1, 2, [
  SDTCisVT<0, v4i32>, SDTCisVT<1, v512i1>, SDTCisPtrTy<2>
]>;
def SDT_PPCPairExtractVsx : SDTypeProfile<1, 2, [
  SDTCisVT<0, v4i32>, SDTCisVT<1, v256i1>, SDTCisPtrTy<2>
]>;
def SDT_PPCxxmfacc : SDTypeProfile<1, 1, [
  SDTCisVT<0, v512i1>, SDTCisVT<1, v512i1>
]>;
def SDT_PPCVecInsertElt : SDTypeProfile<1, 3, [
  SDTCisVec<0>, SDTCisVec<1>, SDTCisInt<3>
]>;

//===----------------------------------------------------------------------===//
// ISA 3.1 specific PPCISD nodes.
//

def PPCxxsplti32dx : SDNode<"PPCISD::XXSPLTI32DX", SDT_PPCSplat32, []>;
def PPCAccBuild : SDNode<"PPCISD::ACC_BUILD", SDT_PPCAccBuild, []>;
def PPCPairBuild : SDNode<"PPCISD::PAIR_BUILD", SDT_PPCPairBuild, []>;
def PPCAccExtractVsx : SDNode<"PPCISD::EXTRACT_VSX_REG", SDT_PPCAccExtractVsx,
                       []>;
def PPCPairExtractVsx : SDNode<"PPCISD::EXTRACT_VSX_REG", SDT_PPCPairExtractVsx,
                        []>;
def PPCxxmfacc : SDNode<"PPCISD::XXMFACC", SDT_PPCxxmfacc, []>;
def PPCvecinsertelt : SDNode<"PPCISD::VECINSERT", SDT_PPCVecInsertElt, []>;

//===----------------------------------------------------------------------===//

// PC Relative flag (for instructions that use the address of the prefix for
// address computations).
class isPCRel { bit PCRel = 1; }

// PowerPC specific type constraints.
def SDT_PPCLXVRZX : SDTypeProfile<1, 2, [
  SDTCisVT<0, v1i128>, SDTCisPtrTy<1>, SDTCisPtrTy<2>
]>;

// PPC Specific DAG Nodes.
def PPClxvrzx : SDNode<"PPCISD::LXVRZX", SDT_PPCLXVRZX,
                       [SDNPHasChain, SDNPMayLoad]>;

// Top-level class for prefixed instructions.
class PI<bits<6> pref, bits<6> opcode, dag OOL, dag IOL, string asmstr,
         InstrItinClass itin> : Instruction {
  field bits<64> Inst;
  field bits<64> SoftFail = 0;
  bit PCRel = 0; // Default value, set by isPCRel.
  let Size = 8;

  let Namespace = "PPC";
  let OutOperandList = OOL;
  let InOperandList = IOL;
  let AsmString = asmstr;
  let Itinerary = itin;
  let Inst{0-5} = pref;
  let Inst{32-37} = opcode;

  bits<1> PPC970_First = 0;
  bits<1> PPC970_Single = 0;
  bits<1> PPC970_Cracked = 0;
  bits<3> PPC970_Unit = 0;

  /// These fields correspond to the fields in PPCInstrInfo.h.  Any changes to
  /// these must be reflected there!  See comments there for what these are.
  let TSFlags{0}   = PPC970_First;
  let TSFlags{1}   = PPC970_Single;
  let TSFlags{2}   = PPC970_Cracked;
  let TSFlags{5-3} = PPC970_Unit;

  bits<1> Prefixed = 1;  // This is a prefixed instruction.
  let TSFlags{7}  = Prefixed;

  // For cases where multiple instruction definitions really represent the
  // same underlying instruction but with one definition for 64-bit arguments
  // and one for 32-bit arguments, this bit breaks the degeneracy between
  // the two forms and allows TableGen to generate mapping tables.
  bit Interpretation64Bit = 0;

  // Fields used for relation models.
  string BaseName = "";
}

// VX-Form: [ PO VT R VB RC XO ]
class VXForm_VTB5_RC<bits<10> xo, bits<5> R, dag OOL, dag IOL, string asmstr,
                      InstrItinClass itin, list<dag> pattern>
  : I<4, OOL, IOL, asmstr, itin> {
  bits<5> VT;
  bits<5> VB;
  bit RC = 0;

  let Pattern = pattern;

  let Inst{6-10} = VT;
  let Inst{11-15} = R;
  let Inst{16-20} = VB;
  let Inst{21} = RC;
  let Inst{22-31} = xo;
}

// Multiclass definition to account for record and non-record form
// instructions of VXRForm.
multiclass VXForm_VTB5_RCr<bits<10> xo, bits<5> R, dag OOL, dag IOL,
                            string asmbase, string asmstr,
                            InstrItinClass itin, list<dag> pattern> {
  let BaseName = asmbase in {
    def NAME : VXForm_VTB5_RC<xo, R, OOL, IOL,
                               !strconcat(asmbase, !strconcat(" ", asmstr)),
                               itin, pattern>, RecFormRel;
    let Defs = [CR6] in
    def _rec : VXForm_VTB5_RC<xo, R, OOL, IOL,
                               !strconcat(asmbase, !strconcat(". ", asmstr)),
                               itin, []>, isRecordForm, RecFormRel;
  }
}

class MLS_DForm_R_SI34_RTA5_MEM<bits<6> opcode, dag OOL, dag IOL, string asmstr,
                                InstrItinClass itin, list<dag> pattern>
  : PI<1, opcode, OOL, IOL, asmstr, itin> {
  bits<5> FRS;
  bits<39> D_RA;

  let Pattern = pattern;

  // The prefix.
  let Inst{6-7} = 2;
  let Inst{8-10} = 0;
  let Inst{11} = PCRel;
  let Inst{12-13} = 0;
  let Inst{14-31} = D_RA{33-16}; // d0

  // The instruction.
  let Inst{38-42} = FRS{4-0};
  let Inst{43-47} = D_RA{38-34}; // RA
  let Inst{48-63} = D_RA{15-0}; // d1
}

class MLS_DForm_R_SI34_RTA5<bits<6> opcode, dag OOL, dag IOL, string asmstr,
                            InstrItinClass itin, list<dag> pattern>
  : PI<1, opcode, OOL, IOL, asmstr, itin> {
  bits<5> RT;
  bits<5> RA;
  bits<34> SI;

  let Pattern = pattern;

  // The prefix.
  let Inst{6-7} = 2;
  let Inst{8-10} = 0;
  let Inst{11} = PCRel;
  let Inst{12-13} = 0;
  let Inst{14-31} = SI{33-16};

  // The instruction.
  let Inst{38-42} = RT;
  let Inst{43-47} = RA;
  let Inst{48-63} = SI{15-0};
}

class MLS_DForm_SI34_RT5<bits<6> opcode, dag OOL, dag IOL, string asmstr,
                         InstrItinClass itin, list<dag> pattern>
  : PI<1, opcode, OOL, IOL, asmstr, itin> {
  bits<5> RT;
  bits<34> SI;

  let Pattern = pattern;

  // The prefix.
  let Inst{6-7} = 2;
  let Inst{8-10} = 0;
  let Inst{11} = 0;
  let Inst{12-13} = 0;
  let Inst{14-31} = SI{33-16};

  // The instruction.
  let Inst{38-42} = RT;
  let Inst{43-47} = 0;
  let Inst{48-63} = SI{15-0};
}

multiclass MLS_DForm_R_SI34_RTA5_p<bits<6> opcode, dag OOL, dag IOL,
                                   dag PCRel_IOL, string asmstr,
                                   InstrItinClass itin> {
  def NAME : MLS_DForm_R_SI34_RTA5<opcode, OOL, IOL,
                                   !strconcat(asmstr, ", 0"), itin, []>;
  def pc : MLS_DForm_R_SI34_RTA5<opcode, OOL, PCRel_IOL,
                                 !strconcat(asmstr, ", 1"), itin, []>, isPCRel;
}

class 8LS_DForm_R_SI34_RTA5<bits<6> opcode, dag OOL, dag IOL, string asmstr,
                            InstrItinClass itin, list<dag> pattern>
  : PI<1, opcode, OOL, IOL, asmstr, itin> {
  bits<5> RT;
  bits<39> D_RA;

  let Pattern = pattern;

  // The prefix.
  let Inst{6-10} = 0;
  let Inst{11} = PCRel;
  let Inst{12-13} = 0;
  let Inst{14-31} = D_RA{33-16}; // d0

  // The instruction.
  let Inst{38-42} = RT{4-0};
  let Inst{43-47} = D_RA{38-34}; // RA
  let Inst{48-63} = D_RA{15-0}; // d1
}

// 8LS:D-Form: [ 1 0 0 // R // d0
//               PO TX T RA d1 ]
class 8LS_DForm_R_SI34_XT6_RA5<bits<5> opcode, dag OOL, dag IOL, string asmstr,
                               InstrItinClass itin, list<dag> pattern>
  : PI<1, { opcode, ? }, OOL, IOL, asmstr, itin> {
  bits<6> XT;
  bits<39> D_RA;

  let Pattern = pattern;

  // The prefix.
  let Inst{6-7} = 0;
  let Inst{8} = 0;
  let Inst{9-10} = 0; // reserved
  let Inst{11} = PCRel;
  let Inst{12-13} = 0; // reserved
  let Inst{14-31} = D_RA{33-16}; // d0

  // The instruction.
  let Inst{37} = XT{5};
  let Inst{38-42} = XT{4-0};
  let Inst{43-47} = D_RA{38-34}; // RA
  let Inst{48-63} = D_RA{15-0}; // d1
}

// X-Form: [PO T IMM VRB XO TX]
class XForm_XT6_IMM5_VB5<bits<6> opcode, bits<10> xo, dag OOL, dag IOL,
                         string asmstr, InstrItinClass itin, list<dag> pattern>
  : I<opcode, OOL, IOL, asmstr, itin> {
  bits<6> XT;
  bits<5> VRB;
  bits<5> IMM;

  let Pattern = pattern;
  let Inst{6-10} = XT{4-0};
  let Inst{11-15} = IMM;
  let Inst{16-20} = VRB;
  let Inst{21-30} = xo;
  let Inst{31} = XT{5};
}

class 8RR_XX4Form_IMM8_XTAB6<bits<6> opcode, bits<2> xo,
                             dag OOL, dag IOL, string asmstr,
                             InstrItinClass itin, list<dag> pattern>
  : PI<1, opcode, OOL, IOL, asmstr, itin> {
    bits<6> XT;
    bits<6> XA;
    bits<6> XB;
    bits<6> XC;
    bits<8> IMM;

    let Pattern = pattern;

    // The prefix.
    let Inst{6-7} = 1;
    let Inst{8} = 0;
    let Inst{9-11} = 0;
    let Inst{12-13} = 0;
    let Inst{14-23} = 0;
    let Inst{24-31} = IMM;

    // The instruction.
    let Inst{38-42} = XT{4-0};
    let Inst{43-47} = XA{4-0};
    let Inst{48-52} = XB{4-0};
    let Inst{53-57} = XC{4-0};
    let Inst{58-59} = xo;
    let Inst{60} = XC{5};
    let Inst{61} = XA{5};
    let Inst{62} = XB{5};
    let Inst{63} = XT{5};
}

class VXForm_RD5_N3_VB5<bits<11> xo, dag OOL, dag IOL, string asmstr,
                        InstrItinClass itin, list<dag> pattern>
  : I<4, OOL, IOL, asmstr, itin> {
  bits<5> RD;
  bits<5> VB;
  bits<3> N;

  let Pattern = pattern;

  let Inst{6-10}  = RD;
  let Inst{11-12} = 0;
  let Inst{13-15} = N;
  let Inst{16-20} = VB;
  let Inst{21-31} = xo;
}


// VX-Form: [PO VRT RA VRB XO].
// Destructive (insert) forms are suffixed with _ins.
class VXForm_VTB5_RA5_ins<bits<11> xo, string opc, list<dag> pattern>
  : VXForm_1<xo, (outs vrrc:$vD), (ins vrrc:$vDi, gprc:$rA, vrrc:$vB),
             !strconcat(opc, " $vD, $rA, $vB"), IIC_VecGeneral, pattern>,
             RegConstraint<"$vDi = $vD">, NoEncode<"$vDi">;

// VX-Form: [PO VRT RA RB XO].
// Destructive (insert) forms are suffixed with _ins.
class VXForm_VRT5_RAB5_ins<bits<11> xo, string opc, list<dag> pattern>
  : VXForm_1<xo, (outs vrrc:$vD), (ins vrrc:$vDi, gprc:$rA, gprc:$rB),
             !strconcat(opc, " $vD, $rA, $rB"), IIC_VecGeneral, pattern>,
             RegConstraint<"$vDi = $vD">, NoEncode<"$vDi">;

// VX-Form: [ PO BF // VRA VRB XO ]
class VXForm_BF3_VAB5<bits<11> xo, dag OOL, dag IOL, string asmstr,
                      InstrItinClass itin, list<dag> pattern>
  : I<4, OOL, IOL, asmstr, itin> {
  bits<3> BF;
  bits<5> VA;
  bits<5> VB;

  let Pattern = pattern;

  let Inst{6-8} = BF;
  let Inst{9-10} = 0;
  let Inst{11-15} = VA;
  let Inst{16-20} = VB;
  let Inst{21-31} = xo;
}

// VN-Form: [PO VRT VRA VRB PS SD XO]
// SD is "Shift Direction"
class VNForm_VTAB5_SD3<bits<6> xo, bits<2> ps, dag OOL, dag IOL, string asmstr,
                       InstrItinClass itin, list<dag> pattern>
    : I<4, OOL, IOL, asmstr, itin> {
  bits<5> VRT;
  bits<5> VRA;
  bits<5> VRB;
  bits<3> SD;

  let Pattern = pattern;

  let Inst{6-10}  = VRT;
  let Inst{11-15} = VRA;
  let Inst{16-20} = VRB;
  let Inst{21-22} = ps;
  let Inst{23-25} = SD;
  let Inst{26-31} = xo;
}

class VXForm_RD5_MP_VB5<bits<11> xo, bits<4> eo, dag OOL, dag IOL,
                        string asmstr, InstrItinClass itin, list<dag> pattern>
  : I<4, OOL, IOL, asmstr, itin> {
  bits<5> RD;
  bits<5> VB;
  bit MP;

  let Pattern = pattern;

  let Inst{6-10}  = RD;
  let Inst{11-14} = eo;
  let Inst{15} = MP;
  let Inst{16-20} = VB;
  let Inst{21-31} = xo;
}

// 8RR:D-Form: [ 1 1 0 // // imm0
//               PO T XO TX imm1 ].
class 8RR_DForm_IMM32_XT6<bits<6> opcode, bits<4> xo, dag OOL, dag IOL,
                          string asmstr, InstrItinClass itin,
                          list<dag> pattern>
  : PI<1, opcode, OOL, IOL, asmstr, itin> {
  bits<6> XT;
  bits<32> IMM32;

  let Pattern = pattern;

  // The prefix.
  let Inst{6-7} = 1;
  let Inst{8-11} = 0;
  let Inst{12-13} = 0; // reserved
  let Inst{14-15} = 0; // reserved
  let Inst{16-31} = IMM32{31-16};

  // The instruction.
  let Inst{38-42} = XT{4-0};
  let Inst{43-46} = xo;
  let Inst{47} = XT{5};
  let Inst{48-63} = IMM32{15-0};
}

// 8RR:D-Form: [ 1 1 0 // // imm0
//               PO T XO IX TX imm1 ].
class 8RR_DForm_IMM32_XT6_IX<bits<6> opcode, bits<3> xo, dag OOL, dag IOL,
                             string asmstr, InstrItinClass itin,
                             list<dag> pattern>
  : PI<1, opcode, OOL, IOL, asmstr, itin> {
  bits<6> XT;
  bit IX;
  bits<32> IMM32;

  let Pattern = pattern;

  // The prefix.
  let Inst{6-7} = 1;
  let Inst{8-11} = 0;
  let Inst{12-13} = 0; // reserved
  let Inst{14-15} = 0; // reserved
  let Inst{16-31} = IMM32{31-16};

  // The instruction.
  let Inst{38-42} = XT{4-0};
  let Inst{43-45} = xo;
  let Inst{46} = IX;
  let Inst{47} = XT{5};
  let Inst{48-63} = IMM32{15-0};
}

class 8RR_XX4Form_XTABC6<bits<6> opcode, bits<2> xo, dag OOL, dag IOL,
                         string asmstr, InstrItinClass itin, list<dag> pattern>
  : PI<1, opcode, OOL, IOL, asmstr, itin> {
  bits<6> XT;
  bits<6> XA;
  bits<6> XB;
  bits<6> XC;

  let Pattern = pattern;

  // The prefix.
  let Inst{6-7} = 1;
  let Inst{8-11} = 0;
  let Inst{12-13} = 0;
  let Inst{14-31} = 0;

  // The instruction.
  let Inst{38-42} = XT{4-0};
  let Inst{43-47} = XA{4-0};
  let Inst{48-52} = XB{4-0};
  let Inst{53-57} = XC{4-0};
  let Inst{58-59} = xo;
  let Inst{60} = XC{5};
  let Inst{61} = XA{5};
  let Inst{62} = XB{5};
  let Inst{63} = XT{5};
}

class 8RR_XX4Form_IMM3_XTABC6<bits<6> opcode, bits<2> xo, dag OOL, dag IOL,
                              string asmstr, InstrItinClass itin,
                              list<dag> pattern>
  : PI<1, opcode, OOL, IOL, asmstr, itin> {
  bits<6> XT;
  bits<6> XA;
  bits<6> XB;
  bits<6> XC;
  bits<3> IMM;

  let Pattern = pattern;

  // The prefix.
  let Inst{6-7} = 1;
  let Inst{8-11} = 0;
  let Inst{12-13} = 0;
  let Inst{14-28} = 0;
  let Inst{29-31} = IMM;

  // The instruction.
  let Inst{38-42} = XT{4-0};
  let Inst{43-47} = XA{4-0};
  let Inst{48-52} = XB{4-0};
  let Inst{53-57} = XC{4-0};
  let Inst{58-59} = xo;
  let Inst{60} = XC{5};
  let Inst{61} = XA{5};
  let Inst{62} = XB{5};
  let Inst{63} = XT{5};
}

// [PO BF / XO2 B XO BX /]
class XX2_BF3_XO5_XB6_XO9<bits<6> opcode, bits<5> xo2, bits<9> xo, dag OOL,
                          dag IOL, string asmstr, InstrItinClass itin,
                          list<dag> pattern>
  : I<opcode, OOL, IOL, asmstr, itin> {
  bits<3> BF;
  bits<6> XB;

  let Pattern = pattern;

  let Inst{6-8}   = BF;
  let Inst{9-10}  = 0;
  let Inst{11-15} = xo2;
  let Inst{16-20} = XB{4-0};
  let Inst{21-29} = xo;
  let Inst{30}    = XB{5};
  let Inst{31}    = 0;
}

// X-Form: [ PO RT BI /// XO / ]
class XForm_XT5_BI5<bits<6> opcode, bits<10> xo, dag OOL, dag IOL,
                    string asmstr, InstrItinClass itin, list<dag> pattern>
  : XForm_base_r3xo<opcode, xo, OOL, IOL, asmstr, itin, pattern> {
  let B = 0;
}

multiclass MLS_DForm_R_SI34_RTA5_MEM_p<bits<6> opcode, dag OOL, dag IOL,
                                       dag PCRel_IOL, string asmstr,
                                       InstrItinClass itin> {
  def NAME : MLS_DForm_R_SI34_RTA5_MEM<opcode, OOL, IOL,
                                       !strconcat(asmstr, ", 0"), itin, []>;
  def pc : MLS_DForm_R_SI34_RTA5_MEM<opcode, OOL, PCRel_IOL,
                                     !strconcat(asmstr, ", 1"), itin, []>,
                                     isPCRel;
}

multiclass 8LS_DForm_R_SI34_RTA5_p<bits<6> opcode, dag OOL, dag IOL,
                                   dag PCRel_IOL, string asmstr,
                                   InstrItinClass itin> {
  def NAME : 8LS_DForm_R_SI34_RTA5<opcode, OOL, IOL,
                                   !strconcat(asmstr, ", 0"), itin, []>;
  def pc : 8LS_DForm_R_SI34_RTA5<opcode, OOL, PCRel_IOL,
                                 !strconcat(asmstr, ", 1"), itin, []>, isPCRel;
}

multiclass 8LS_DForm_R_SI34_XT6_RA5_p<bits<5> opcode, dag OOL, dag IOL,
                                      dag PCRel_IOL, string asmstr,
                                      InstrItinClass itin> {
  def NAME : 8LS_DForm_R_SI34_XT6_RA5<opcode, OOL, IOL,
                                      !strconcat(asmstr, ", 0"), itin, []>;
  def pc : 8LS_DForm_R_SI34_XT6_RA5<opcode, OOL, PCRel_IOL,
                                    !strconcat(asmstr, ", 1"), itin, []>,
                                    isPCRel;
}

def PPCRegVSRpRCAsmOperand : AsmOperandClass {
  let Name = "RegVSRpRC"; let PredicateMethod = "isVSRpEvenRegNumber";
}

def vsrprc : RegisterOperand<VSRpRC> {
  let ParserMatchClass = PPCRegVSRpRCAsmOperand;
}

def PPCRegVSRpEvenRCAsmOperand : AsmOperandClass {
  let Name = "RegVSRpEvenRC"; let PredicateMethod = "isVSRpEvenRegNumber";
}

def vsrpevenrc : RegisterOperand<VSRpRC> {
  let ParserMatchClass = PPCRegVSRpEvenRCAsmOperand;
  let EncoderMethod = "getVSRpEvenEncoding";
  let DecoderMethod = "decodeVSRpEvenOperands";
}

class DQForm_XTp5_RA17_MEM<bits<6> opcode, bits<4> xo, dag OOL, dag IOL,
                           string asmstr, InstrItinClass itin, list<dag> pattern>
  : I<opcode, OOL, IOL, asmstr, itin> {
  bits<5> XTp;
  bits<17> DQ_RA;
  let Pattern = pattern;

  let Inst{6-9} = XTp{3-0};
  let Inst{10} = XTp{4};
  let Inst{11-15} = DQ_RA{16-12};  // Register #
  let Inst{16-27} = DQ_RA{11-0};   // Displacement.
  let Inst{28-31} = xo;
}

class XForm_XTp5_XAB5<bits<6> opcode, bits<10> xo, dag OOL, dag IOL,
                      string asmstr, InstrItinClass itin, list<dag> pattern>
  : I<opcode, OOL, IOL, asmstr, itin>, XFormMemOp {
  bits<5> XTp;
  bits<5> A;
  bits<5> B;

  let Pattern = pattern;
  let Inst{6-9} = XTp{3-0};
  let Inst{10} = XTp{4};
  let Inst{11-15} = A;
  let Inst{16-20} = B;
  let Inst{21-30} = xo;
  let Inst{31} = 0;
}

class 8LS_DForm_R_XTp5_SI34_MEM<bits<6> opcode, dag OOL, dag IOL, string asmstr,
                                InstrItinClass itin, list<dag> pattern>
  : PI<1, opcode, OOL, IOL, asmstr, itin> {
  bits<5> XTp;
  bits<39> D_RA;

  let Pattern = pattern;

  // The prefix.
  let Inst{6-10} = 0;
  let Inst{11} = PCRel;
  let Inst{12-13} = 0;
  let Inst{14-31} = D_RA{33-16}; // Imm18

  // The instruction.
  let Inst{38-41} = XTp{3-0};
  let Inst{42}    = XTp{4};
  let Inst{43-47} = D_RA{38-34};   // Register #
  let Inst{48-63} = D_RA{15-0};    // D
}

multiclass 8LS_DForm_R_XTp5_SI34_MEM_p<bits<6> pref, bits<6> opcode, dag OOL,
                                       dag IOL, dag PCRel_IOL,
                                       string asmstr, InstrItinClass itin> {
  def NAME : 8LS_DForm_R_XTp5_SI34_MEM<opcode, OOL, IOL,
                                       !strconcat(asmstr, ", 0"), itin, []>;
  def pc : 8LS_DForm_R_XTp5_SI34_MEM<opcode, OOL, PCRel_IOL,
                                     !strconcat(asmstr, ", 1"), itin, []>,
                                     isPCRel;
}

def PPCRegACCRCAsmOperand : AsmOperandClass {
  let Name = "RegACCRC"; let PredicateMethod = "isACCRegNumber";
}

def acc : RegisterOperand<ACCRC> {
  let ParserMatchClass = PPCRegACCRCAsmOperand;
}

def uacc : RegisterOperand<UACCRC> {
  let ParserMatchClass = PPCRegACCRCAsmOperand;
}

// [PO AS XO2 XO]
class XForm_AT3<bits<6> opcode, bits<5> xo2, bits<10> xo, dag OOL, dag IOL,
                    string asmstr, InstrItinClass itin, list<dag> pattern>
  : I<opcode, OOL, IOL, asmstr, itin> {
  bits<3> AT;

  let Pattern = pattern;

  let Inst{6-8}  = AT;
  let Inst{9-10}  = 0;
  let Inst{11-15} = xo2;
  let Inst{16-20} = 0;
  let Inst{21-30} = xo;
  let Inst{31} = 0;
}

class XX3Form_AT3_XAB6<bits<6> opcode, bits<8> xo, dag OOL, dag IOL,
                           string asmstr, InstrItinClass itin,
                           list<dag> pattern>
  : I<opcode, OOL, IOL, asmstr, itin> {
  bits<3> AT;
  bits<6> XA;
  bits<6> XB;

  let Pattern = pattern;

  let Inst{6-8} = AT;
  let Inst{9-10} = 0;
  let Inst{11-15} = XA{4-0};
  let Inst{16-20} = XB{4-0};
  let Inst{21-28} = xo;
  let Inst{29}    = XA{5};
  let Inst{30}    = XB{5};
  let Inst{31} = 0;
}

class MMIRR_XX3Form_XY4P2_XAB6<bits<6> opcode, bits<8> xo, dag OOL, dag IOL,
                               string asmstr, InstrItinClass itin,
                               list<dag> pattern>
  : PI<1, opcode, OOL, IOL, asmstr, itin> {
  bits<3> AT;
  bits<6> XA;
  bits<6> XB;
  bits<4> XMSK;
  bits<4> YMSK;
  bits<2> PMSK;

  let Pattern = pattern;

  // The prefix.
  let Inst{6-7} = 3;
  let Inst{8-11} = 9;
  let Inst{12-15} = 0;
  let Inst{16-17} = PMSK;
  let Inst{18-23} = 0;
  let Inst{24-27} = XMSK;
  let Inst{28-31} = YMSK;

  // The instruction.
  let Inst{38-40} = AT;
  let Inst{41-42} = 0;
  let Inst{43-47} = XA{4-0};
  let Inst{48-52} = XB{4-0};
  let Inst{53-60} = xo;
  let Inst{61} = XA{5};
  let Inst{62} = XB{5};
  let Inst{63} = 0;
}

class MMIRR_XX3Form_XY4_XAB6<bits<6> opcode, bits<8> xo, dag OOL, dag IOL,
                             string asmstr, InstrItinClass itin,
                             list<dag> pattern>
  : PI<1, opcode, OOL, IOL, asmstr, itin> {
  bits<3> AT;
  bits<6> XA;
  bits<6> XB;
  bits<4> XMSK;
  bits<4> YMSK;

  let Pattern = pattern;

  // The prefix.
  let Inst{6-7} = 3;
  let Inst{8-11} = 9;
  let Inst{12-23} = 0;
  let Inst{24-27} = XMSK;
  let Inst{28-31} = YMSK;

  // The instruction.
  let Inst{38-40} = AT;
  let Inst{41-42} = 0;
  let Inst{43-47} = XA{4-0};
  let Inst{48-52} = XB{4-0};
  let Inst{53-60} = xo;
  let Inst{61} = XA{5};
  let Inst{62} = XB{5};
  let Inst{63} = 0;
}

class MMIRR_XX3Form_X4Y2_XAB6<bits<6> opcode, bits<8> xo, dag OOL, dag IOL,
                              string asmstr, InstrItinClass itin,
                              list<dag> pattern>
  : PI<1, opcode, OOL, IOL, asmstr, itin> {
  bits<3> AT;
  bits<6> XA;
  bits<6> XB;
  bits<4> XMSK;
  bits<2> YMSK;

  let Pattern = pattern;

  // The prefix.
  let Inst{6-7} = 3;
  let Inst{8-11} = 9;
  let Inst{12-23} = 0;
  let Inst{24-27} = XMSK;
  let Inst{28-29} = YMSK;
  let Inst{30-31} = 0;

  // The instruction.
  let Inst{38-40} = AT;
  let Inst{41-42} = 0;
  let Inst{43-47} = XA{4-0};
  let Inst{48-52} = XB{4-0};
  let Inst{53-60} = xo;
  let Inst{61} = XA{5};
  let Inst{62} = XB{5};
  let Inst{63} = 0;
}

class MMIRR_XX3Form_XY4P8_XAB6<bits<6> opcode, bits<8> xo, dag OOL, dag IOL,
                               string asmstr, InstrItinClass itin,
                               list<dag> pattern>
  : PI<1, opcode, OOL, IOL, asmstr, itin> {
  bits<3> AT;
  bits<6> XA;
  bits<6> XB;
  bits<4> XMSK;
  bits<4> YMSK;
  bits<8> PMSK;

  let Pattern = pattern;

  // The prefix.
  let Inst{6-7} = 3;
  let Inst{8-11} = 9;
  let Inst{12-15} = 0;
  let Inst{16-23} = PMSK;
  let Inst{24-27} = XMSK;
  let Inst{28-31} = YMSK;

  // The instruction.
  let Inst{38-40} = AT;
  let Inst{41-42} = 0;
  let Inst{43-47} = XA{4-0};
  let Inst{48-52} = XB{4-0};
  let Inst{53-60} = xo;
  let Inst{61} = XA{5};
  let Inst{62} = XB{5};
  let Inst{63} = 0;
}

class MMIRR_XX3Form_XYP4_XAB6<bits<6> opcode, bits<8> xo, dag OOL, dag IOL,
                              string asmstr, InstrItinClass itin,
                              list<dag> pattern>
  : PI<1, opcode, OOL, IOL, asmstr, itin> {
  bits<3> AT;
  bits<6> XA;
  bits<6> XB;
  bits<4> XMSK;
  bits<4> YMSK;
  bits<4> PMSK;

  let Pattern = pattern;

  // The prefix.
  let Inst{6-7} = 3;
  let Inst{8-11} = 9;
  let Inst{12-15} = 0;
  let Inst{16-19} = PMSK;
  let Inst{20-23} = 0;
  let Inst{24-27} = XMSK;
  let Inst{28-31} = YMSK;

  // The instruction.
  let Inst{38-40} = AT;
  let Inst{41-42} = 0;
  let Inst{43-47} = XA{4-0};
  let Inst{48-52} = XB{4-0};
  let Inst{53-60} = xo;
  let Inst{61} = XA{5};
  let Inst{62} = XB{5};
  let Inst{63} = 0;
}

def PrefixInstrs : Predicate<"Subtarget->hasPrefixInstrs()">;
def IsISA3_1 : Predicate<"Subtarget->isISA3_1()">;
def PairedVectorMemops : Predicate<"Subtarget->pairedVectorMemops()">;
def MMA : Predicate<"Subtarget->hasMMA()">;

def RCCp {
  dag AToVSRC = (COPY_TO_REGCLASS $XA, VSRC);
  dag BToVSRC = (COPY_TO_REGCLASS $XB, VSRC);
}

let Predicates = [PrefixInstrs] in {
  let Interpretation64Bit = 1, isCodeGenOnly = 1 in {
    defm PADDI8 :
      MLS_DForm_R_SI34_RTA5_p<14, (outs g8rc:$RT), (ins g8rc:$RA, s34imm:$SI),
                              (ins immZero:$RA, s34imm_pcrel:$SI),
                              "paddi $RT, $RA, $SI", IIC_LdStLFD>;
    let isReMaterializable = 1, isAsCheapAsAMove = 1, isMoveImm = 1 in {
      def PLI8 : MLS_DForm_SI34_RT5<14, (outs g8rc:$RT),
                                    (ins s34imm:$SI),
                                    "pli $RT, $SI", IIC_IntSimple, []>;
    }
  }
  defm PADDI :
    MLS_DForm_R_SI34_RTA5_p<14, (outs gprc:$RT), (ins gprc:$RA, s34imm:$SI),
                            (ins immZero:$RA, s34imm_pcrel:$SI),
                            "paddi $RT, $RA, $SI", IIC_LdStLFD>;
  let isReMaterializable = 1, isAsCheapAsAMove = 1, isMoveImm = 1 in {
    def PLI : MLS_DForm_SI34_RT5<14, (outs gprc:$RT),
                                 (ins s34imm:$SI),
                                 "pli $RT, $SI", IIC_IntSimple, []>;
  }

  let mayLoad = 1, mayStore = 0 in {
    defm PLXV :
      8LS_DForm_R_SI34_XT6_RA5_p<25, (outs vsrc:$XT), (ins memri34:$D_RA),
                                 (ins memri34_pcrel:$D_RA), "plxv $XT, $D_RA",
                                 IIC_LdStLFD>;
    defm PLFS :
      MLS_DForm_R_SI34_RTA5_MEM_p<48, (outs f4rc:$FRT), (ins memri34:$D_RA),
                                  (ins memri34_pcrel:$D_RA), "plfs $FRT, $D_RA",
                                  IIC_LdStLFD>;
    defm PLFD :
      MLS_DForm_R_SI34_RTA5_MEM_p<50, (outs f8rc:$FRT), (ins memri34:$D_RA),
                                  (ins  memri34_pcrel:$D_RA), "plfd $FRT, $D_RA",
                                  IIC_LdStLFD>;
    defm PLXSSP :
      8LS_DForm_R_SI34_RTA5_p<43, (outs vfrc:$VRT), (ins memri34:$D_RA),
                              (ins memri34_pcrel:$D_RA), "plxssp $VRT, $D_RA",
                              IIC_LdStLFD>;
    defm PLXSD :
      8LS_DForm_R_SI34_RTA5_p<42, (outs vfrc:$VRT), (ins memri34:$D_RA),
                              (ins memri34_pcrel:$D_RA), "plxsd $VRT, $D_RA",
                              IIC_LdStLFD>;
    let Interpretation64Bit = 1, isCodeGenOnly = 1 in {
      defm PLBZ8 :
        MLS_DForm_R_SI34_RTA5_MEM_p<34, (outs g8rc:$RT), (ins memri34:$D_RA),
                                    (ins memri34_pcrel:$D_RA), "plbz $RT, $D_RA",
                                    IIC_LdStLFD>;
      defm PLHZ8 :
        MLS_DForm_R_SI34_RTA5_MEM_p<40, (outs g8rc:$RT), (ins memri34:$D_RA),
                                    (ins memri34_pcrel:$D_RA), "plhz $RT, $D_RA",
                                    IIC_LdStLFD>;
      defm PLHA8 :
        MLS_DForm_R_SI34_RTA5_MEM_p<42, (outs g8rc:$RT), (ins memri34:$D_RA),
                                    (ins memri34_pcrel:$D_RA), "plha $RT, $D_RA",
                                    IIC_LdStLFD>;
      defm PLWA8 :
        8LS_DForm_R_SI34_RTA5_p<41, (outs g8rc:$RT), (ins memri34:$D_RA),
                                (ins memri34_pcrel:$D_RA), "plwa $RT, $D_RA",
                                IIC_LdStLFD>;
      defm PLWZ8 :
        MLS_DForm_R_SI34_RTA5_MEM_p<32, (outs g8rc:$RT), (ins memri34:$D_RA),
                                    (ins memri34_pcrel:$D_RA), "plwz $RT, $D_RA",
                                    IIC_LdStLFD>;
    }
    defm PLBZ :
      MLS_DForm_R_SI34_RTA5_MEM_p<34, (outs gprc:$RT), (ins memri34:$D_RA),
                                  (ins memri34_pcrel:$D_RA), "plbz $RT, $D_RA",
                                  IIC_LdStLFD>;
    defm PLHZ :
      MLS_DForm_R_SI34_RTA5_MEM_p<40, (outs gprc:$RT), (ins memri34:$D_RA),
                                  (ins memri34_pcrel:$D_RA), "plhz $RT, $D_RA",
                                  IIC_LdStLFD>;
    defm PLHA :
      MLS_DForm_R_SI34_RTA5_MEM_p<42, (outs gprc:$RT), (ins memri34:$D_RA),
                                  (ins memri34_pcrel:$D_RA), "plha $RT, $D_RA",
                                  IIC_LdStLFD>;
    defm PLWZ :
      MLS_DForm_R_SI34_RTA5_MEM_p<32, (outs gprc:$RT), (ins memri34:$D_RA),
                                  (ins memri34_pcrel:$D_RA), "plwz $RT, $D_RA",
                                  IIC_LdStLFD>;
    defm PLWA :
      8LS_DForm_R_SI34_RTA5_p<41, (outs gprc:$RT), (ins memri34:$D_RA),
                              (ins memri34_pcrel:$D_RA), "plwa $RT, $D_RA",
                              IIC_LdStLFD>;
    defm PLD :
      8LS_DForm_R_SI34_RTA5_p<57, (outs g8rc:$RT), (ins memri34:$D_RA),
                              (ins memri34_pcrel:$D_RA), "pld $RT, $D_RA",
                              IIC_LdStLFD>;
  }

  let mayStore = 1, mayLoad = 0 in {
    defm PSTXV :
      8LS_DForm_R_SI34_XT6_RA5_p<27, (outs), (ins vsrc:$XS, memri34:$D_RA),
                                 (ins vsrc:$XS, memri34_pcrel:$D_RA),
                                 "pstxv $XS, $D_RA", IIC_LdStLFD>;
    defm PSTFS :
      MLS_DForm_R_SI34_RTA5_MEM_p<52, (outs), (ins f4rc:$FRS, memri34:$D_RA),
                                  (ins f4rc:$FRS, memri34_pcrel:$D_RA),
                                  "pstfs $FRS, $D_RA", IIC_LdStLFD>;
    defm PSTFD :
      MLS_DForm_R_SI34_RTA5_MEM_p<54, (outs), (ins f8rc:$FRS, memri34:$D_RA),
                                  (ins f8rc:$FRS, memri34_pcrel:$D_RA),
                                  "pstfd $FRS, $D_RA", IIC_LdStLFD>;
    defm PSTXSSP :
      8LS_DForm_R_SI34_RTA5_p<47, (outs), (ins vfrc:$VRS, memri34:$D_RA),
                              (ins vfrc:$VRS, memri34_pcrel:$D_RA),
                              "pstxssp $VRS, $D_RA", IIC_LdStLFD>;
    defm PSTXSD :
      8LS_DForm_R_SI34_RTA5_p<46, (outs), (ins vfrc:$VRS, memri34:$D_RA),
                              (ins vfrc:$VRS, memri34_pcrel:$D_RA),
                              "pstxsd $VRS, $D_RA", IIC_LdStLFD>;
    let Interpretation64Bit = 1, isCodeGenOnly = 1 in {
      defm PSTB8 :
        MLS_DForm_R_SI34_RTA5_MEM_p<38, (outs), (ins g8rc:$RS, memri34:$D_RA),
                                    (ins g8rc:$RS, memri34_pcrel:$D_RA),
                                    "pstb $RS, $D_RA", IIC_LdStLFD>;
      defm PSTH8 :
        MLS_DForm_R_SI34_RTA5_MEM_p<44, (outs), (ins g8rc:$RS, memri34:$D_RA),
                                    (ins g8rc:$RS, memri34_pcrel:$D_RA),
                                    "psth $RS, $D_RA", IIC_LdStLFD>;
      defm PSTW8 :
        MLS_DForm_R_SI34_RTA5_MEM_p<36, (outs), (ins g8rc:$RS, memri34:$D_RA),
                                    (ins g8rc:$RS, memri34_pcrel:$D_RA),
                                    "pstw $RS, $D_RA", IIC_LdStLFD>;
    }
    defm PSTB :
      MLS_DForm_R_SI34_RTA5_MEM_p<38, (outs), (ins gprc:$RS, memri34:$D_RA),
                                  (ins gprc:$RS, memri34_pcrel:$D_RA),
                                  "pstb $RS, $D_RA", IIC_LdStLFD>;
    defm PSTH :
      MLS_DForm_R_SI34_RTA5_MEM_p<44, (outs), (ins gprc:$RS, memri34:$D_RA),
                                  (ins gprc:$RS, memri34_pcrel:$D_RA),
                                  "psth $RS, $D_RA", IIC_LdStLFD>;
    defm PSTW :
      MLS_DForm_R_SI34_RTA5_MEM_p<36, (outs), (ins gprc:$RS, memri34:$D_RA),
                                  (ins gprc:$RS, memri34_pcrel:$D_RA),
                                  "pstw $RS, $D_RA", IIC_LdStLFD>;
    defm PSTD :
      8LS_DForm_R_SI34_RTA5_p<61, (outs), (ins g8rc:$RS, memri34:$D_RA),
                              (ins g8rc:$RS, memri34_pcrel:$D_RA),
                              "pstd $RS, $D_RA", IIC_LdStLFD>;
  }
}

// Multiclass definitions for MMA accumulator instructions.
// ----------------------------------------------------------------------------

// Defines 2 unmasked instructions where the xo field for acc/non-acc version
// is even/odd.
multiclass ACC_UM_XOEO<bits<6> opcode, bits<8> xo, dag IOL, string asmbase,
                       string asmstr> {
  let Predicates = [MMA] in {
  def NAME :
    XX3Form_AT3_XAB6<opcode, !or(xo, 0x01), (outs acc:$AT), IOL,
                     !strconcat(asmbase#" ", asmstr), IIC_VecFP, []>,
    RegConstraint<"@earlyclobber $AT">;
  def PP :
    XX3Form_AT3_XAB6<opcode, xo, (outs acc:$AT), !con((ins acc:$ATi), IOL),
                     !strconcat(asmbase#"pp ", asmstr), IIC_VecFP, []>,
    RegConstraint<"$ATi = $AT">, NoEncode<"$ATi">;
  }
}

// Defines 4 instructions, masked/unmasked with masks 8, 4, 4 bits.
// The XO field for acc/non-acc version is even/odd.
multiclass ACC_UM_M844_XOEO<bits<6> opcode, bits<8> xo, dag IOL, string asmbase,
                            string asmstr> {
  defm NAME : ACC_UM_XOEO<opcode, xo, IOL, asmbase, asmstr>;
  let Predicates = [MMA, PrefixInstrs] in {
  def PM#NAME :
    MMIRR_XX3Form_XY4P8_XAB6<
      opcode, !or(xo, 0x01), (outs acc:$AT),
      !con(IOL, (ins u4imm:$XMSK, u4imm:$YMSK, u8imm:$PMSK)),
      !strconcat("pm"#asmbase#" ", asmstr#", $XMSK, $YMSK, $PMSK"),
      IIC_VecFP, []>,
    RegConstraint<"@earlyclobber $AT">;
  def PM#NAME#PP :
    MMIRR_XX3Form_XY4P8_XAB6<
      opcode, xo, (outs acc:$AT),
      !con((ins acc:$ATi),
           !con(IOL, (ins u4imm:$XMSK, u4imm:$YMSK, u8imm:$PMSK))),
      !strconcat("pm"#asmbase#"pp ", asmstr#", $XMSK, $YMSK, $PMSK"),
      IIC_VecFP, []>,
    RegConstraint<"$ATi = $AT">, NoEncode<"$ATi">;
  }
}

// Defines 4 instructions, masked/unmasked with masks 4, 4, 4 bits.
// The XO field for acc/non-acc version is even/odd.
multiclass ACC_UM_M444_XOEO<bits<6> opcode, bits<8> xo, dag IOL, string asmbase,
                            string asmstr> {
  defm NAME : ACC_UM_XOEO<opcode, xo, IOL, asmbase, asmstr>;
  let Predicates = [MMA, PrefixInstrs] in {
  def PM#NAME :
    MMIRR_XX3Form_XYP4_XAB6<
      opcode, !or(xo, 0x01), (outs acc:$AT),
      !con(IOL, (ins u4imm:$XMSK, u4imm:$YMSK, u4imm:$PMSK)),
      !strconcat("pm"#asmbase#" ", asmstr#", $XMSK, $YMSK, $PMSK"),
      IIC_VecFP, []>,
    RegConstraint<"@earlyclobber $AT">;
  def PM#NAME#PP :
    MMIRR_XX3Form_XYP4_XAB6<
      opcode, xo, (outs acc:$AT),
      !con((ins acc:$ATi),
           !con(IOL, (ins u4imm:$XMSK, u4imm:$YMSK, u4imm:$PMSK))),
      !strconcat("pm"#asmbase#"pp ", asmstr#", $XMSK, $YMSK, $PMSK"),
      IIC_VecFP, []>,
    RegConstraint<"$ATi = $AT">, NoEncode<"$ATi">;
  }
}

// Defines 4 instructions, masked/unmasked with masks 2, 4, 4 bits.
// The XO field for acc/non-acc version is even/odd.
multiclass ACC_UM_M244_XOEO<bits<6> opcode, bits<8> xo, dag IOL, string asmbase,
                            string asmstr> {
  defm NAME : ACC_UM_XOEO<opcode, xo, IOL, asmbase, asmstr>;
  let Predicates = [MMA, PrefixInstrs] in {
  def PM#NAME :
    MMIRR_XX3Form_XY4P2_XAB6<
      opcode, !or(xo, 0x01), (outs acc:$AT),
      !con(IOL, (ins u4imm:$XMSK, u4imm:$YMSK, u2imm:$PMSK)),
      !strconcat("pm"#asmbase#" ", asmstr#", $XMSK, $YMSK, $PMSK"),
      IIC_VecFP, []>,
    RegConstraint<"@earlyclobber $AT">;
  def PM#NAME#PP :
    MMIRR_XX3Form_XY4P2_XAB6<
      opcode, xo, (outs acc:$AT),
      !con((ins acc:$ATi), !con(IOL, (ins u4imm:$XMSK, u4imm:$YMSK, u2imm:$PMSK))),
      !strconcat("pm"#asmbase#"pp ", asmstr#", $XMSK, $YMSK, $PMSK"),
      IIC_VecFP, []>,
    RegConstraint<"$ATi = $AT">, NoEncode<"$ATi">;
  }
}

// Defines 4 instructions, masked/unmasked with masks 2, 4, 4 bits.
// Upper nibble of XO field for acc/non-acc version is 0x4/0x6.
multiclass ACC_UM_M244_XO46<bits<6> opcode, bits<8> xo, dag IOL, string asmbase,
                            string asmstr> {
  let Predicates = [MMA] in {
  def NAME :
    XX3Form_AT3_XAB6<opcode, xo, (outs acc:$AT), IOL,
                     !strconcat(asmbase#" ", asmstr), IIC_VecFP, []>,
    RegConstraint<"@earlyclobber $AT">;
  def PP :
    XX3Form_AT3_XAB6<
      opcode, !or(xo, 0x20), (outs acc:$AT), !con((ins acc:$ATi), IOL),
      !strconcat(asmbase#"pp ", asmstr), IIC_VecFP, []>,
    RegConstraint<"$ATi = $AT">, NoEncode<"$ATi">;
  }
  let Predicates = [MMA, PrefixInstrs] in {
  def PM#NAME :
    MMIRR_XX3Form_XY4P2_XAB6<
      opcode, xo, (outs acc:$AT),
      !con(IOL, (ins u4imm:$XMSK, u4imm:$YMSK, u2imm:$PMSK)),
      !strconcat("pm"#asmbase#" ", asmstr#", $XMSK, $YMSK, $PMSK"),
      IIC_VecFP, []>,
    RegConstraint<"@earlyclobber $AT">;
  def PM#NAME#PP :
    MMIRR_XX3Form_XY4P2_XAB6<
      opcode, !or(xo, 0x20), (outs acc:$AT),
      !con((ins acc:$ATi),
           !con(IOL, (ins u4imm:$XMSK, u4imm:$YMSK, u2imm:$PMSK))),
      !strconcat("pm"#asmbase#"pp ", asmstr#", $XMSK, $YMSK, $PMSK"),
      IIC_VecFP, []>,
    RegConstraint<"$ATi = $AT">, NoEncode<"$ATi">;
  }
}

// Defines 10 instructions, operand negating, unmasked, masked with 2, 4, 4
// bits. Upper nibble are masked with 0x8, 0x4, 0xC for negating operands.
multiclass ACC_NEG_UM_M244_XOM84C<bits<6> opcode, bits<8> xo, dag IOL,
                                  string asmbase, string asmstr> {
  defm NAME : ACC_UM_M244_XOEO<opcode, xo, IOL, asmbase, asmstr>;
  let Predicates = [MMA] in {
  def PN : XX3Form_AT3_XAB6<
             opcode, !or(xo, 0x80), (outs acc:$AT), !con((ins acc:$ATi), IOL),
             !strconcat(asmbase#"pn ", asmstr), IIC_VecFP, []>,
           RegConstraint<"$ATi = $AT">, NoEncode<"$ATi">;
  def NP : XX3Form_AT3_XAB6<
             opcode, !or(xo, 0x40), (outs acc:$AT), !con((ins acc:$ATi), IOL),
             !strconcat(asmbase#"np ", asmstr), IIC_VecFP, []>,
           RegConstraint<"$ATi = $AT">, NoEncode<"$ATi">;
  def NN : XX3Form_AT3_XAB6<
             opcode, !or(xo, 0xC0), (outs acc:$AT), !con((ins acc:$ATi), IOL),
             !strconcat(asmbase#"nn ", asmstr), IIC_VecFP, []>,
           RegConstraint<"$ATi = $AT">, NoEncode<"$ATi">;
  }
  let Predicates = [MMA, PrefixInstrs] in {
  def PM#NAME#PN :
    MMIRR_XX3Form_XY4P2_XAB6<
      opcode, !or(xo, 0x80), (outs acc:$AT),
      !con((ins acc:$ATi), !con(IOL, (ins u4imm:$XMSK, u4imm:$YMSK, u2imm:$PMSK))),
      !strconcat("pm"#asmbase#"pn ", asmstr#", $XMSK, $YMSK, $PMSK"),
      IIC_VecFP, []>,
    RegConstraint<"$ATi = $AT">, NoEncode<"$ATi">;
  def PM#NAME#NP :
    MMIRR_XX3Form_XY4P2_XAB6<
      opcode, !or(xo, 0x40), (outs acc:$AT),
      !con((ins acc:$ATi), !con(IOL, (ins u4imm:$XMSK, u4imm:$YMSK, u2imm:$PMSK))),
      !strconcat("pm"#asmbase#"np ", asmstr#", $XMSK, $YMSK, $PMSK"),
      IIC_VecFP, []>,
    RegConstraint<"$ATi = $AT">, NoEncode<"$ATi">;
  def PM#NAME#NN :
    MMIRR_XX3Form_XY4P2_XAB6<
      opcode, !or(xo, 0xC0), (outs acc:$AT),
      !con((ins acc:$ATi), !con(IOL, (ins u4imm:$XMSK, u4imm:$YMSK, u2imm:$PMSK))),
      !strconcat("pm"#asmbase#"nn ", asmstr#", $XMSK, $YMSK, $PMSK"),
      IIC_VecFP, []>,
    RegConstraint<"$ATi = $AT">, NoEncode<"$ATi">;
  }
}

// Defines 5 instructions, unmasked, operand negating.
// Upper nibble are masked with 0x8, 0x4, 0xC for negating operands.
multiclass ACC_NEG_UM_XOM84C<bits<6> opcode, bits<8> xo, dag IOL,
                             string asmbase, string asmstr> {
  defm NAME : ACC_UM_XOEO<opcode, xo, IOL, asmbase, asmstr>;
  let Predicates = [MMA] in {
  def PN : XX3Form_AT3_XAB6<opcode, !or(xo, 0x80), (outs acc:$AT),
                            !con((ins acc:$ATi), IOL),
                            !strconcat(asmbase#"pn ", asmstr), IIC_VecFP, []>,
           RegConstraint<"$ATi = $AT">, NoEncode<"$ATi">;
  def NP : XX3Form_AT3_XAB6<opcode, !or(xo, 0x40), (outs acc:$AT),
                            !con((ins acc:$ATi), IOL),
                            !strconcat(asmbase#"np ", asmstr), IIC_VecFP, []>,
           RegConstraint<"$ATi = $AT">, NoEncode<"$ATi">;
  def NN : XX3Form_AT3_XAB6<opcode, !or(xo, 0xC0), (outs acc:$AT),
                            !con((ins acc:$ATi), IOL),
                            !strconcat(asmbase#"nn ", asmstr), IIC_VecFP, []>,
           RegConstraint<"$ATi = $AT">, NoEncode<"$ATi">;
  }
}

// Defines 10 instructions, operand negating, unmasked, masked with 4, 4 bits.
// Upper nibble are masked with 0x8, 0x4, 0xC for negating operands.
multiclass ACC_NEG_UM_M44_XOM84C<bits<6> opcode, bits<8> xo, dag IOL,
                                 string asmbase, string asmstr> {
  defm NAME : ACC_NEG_UM_XOM84C<opcode, xo, IOL, asmbase, asmstr>;
  let Predicates = [MMA, PrefixInstrs] in {
  def PM#NAME :
    MMIRR_XX3Form_XY4_XAB6<
      opcode, !or(xo, 0x01), (outs acc:$AT),
      !con(IOL, (ins u4imm:$XMSK, u4imm:$YMSK)),
      !strconcat("pm"#asmbase#" ", asmstr#", $XMSK, $YMSK"),
      IIC_VecFP, []>,
    RegConstraint<"@earlyclobber $AT">;
  def PM#NAME#PP :
    MMIRR_XX3Form_XY4_XAB6<
      opcode, xo, (outs acc:$AT),
      !con((ins acc:$ATi), !con(IOL, (ins u4imm:$XMSK, u4imm:$YMSK))),
      !strconcat("pm"#asmbase#"pp ", asmstr#", $XMSK, $YMSK"),
      IIC_VecFP, []>,
    RegConstraint<"$ATi = $AT">, NoEncode<"$ATi">;
  def PM#NAME#PN :
    MMIRR_XX3Form_XY4_XAB6<
      opcode, !or(xo, 0x80), (outs acc:$AT),
      !con((ins acc:$ATi), !con(IOL, (ins u4imm:$XMSK, u4imm:$YMSK))),
      !strconcat("pm"#asmbase#"pn ", asmstr#", $XMSK, $YMSK"),
      IIC_VecFP, []>,
    RegConstraint<"$ATi = $AT">, NoEncode<"$ATi">;
  def PM#NAME#NP :
    MMIRR_XX3Form_XY4_XAB6<
      opcode, !or(xo, 0x40), (outs acc:$AT),
      !con((ins acc:$ATi), !con(IOL, (ins u4imm:$XMSK, u4imm:$YMSK))),
      !strconcat("pm"#asmbase#"np ", asmstr#", $XMSK, $YMSK"),
      IIC_VecFP, []>,
    RegConstraint<"$ATi = $AT">, NoEncode<"$ATi">;
  def PM#NAME#NN :
    MMIRR_XX3Form_XY4_XAB6<
      opcode, !or(xo, 0xC0), (outs acc:$AT),
      !con((ins acc:$ATi), !con(IOL, (ins u4imm:$XMSK, u4imm:$YMSK))),
      !strconcat("pm"#asmbase#"nn ", asmstr#", $XMSK, $YMSK"),
      IIC_VecFP, []>,
    RegConstraint<"$ATi = $AT">, NoEncode<"$ATi">;
  }
}

// Defines 10 instructions, operand negating, unmasked, masked with 4, 2 bits.
// Upper nibble are masked with 0x8, 0x4, 0xC for negating operands.
multiclass ACC_NEG_UM_M42_XOM84C<bits<6> opcode, bits<8> xo, dag IOL,
                                 string asmbase, string asmstr> {
  defm NAME : ACC_NEG_UM_XOM84C<opcode, xo, IOL, asmbase, asmstr>;
  let Predicates = [MMA, PrefixInstrs] in {
  def PM#NAME :
    MMIRR_XX3Form_X4Y2_XAB6<
      opcode, !or(xo, 0x01), (outs acc:$AT),
      !con(IOL, (ins u4imm:$XMSK, u2imm:$YMSK)),
      !strconcat("pm"#asmbase#" ", asmstr#", $XMSK, $YMSK"),
      IIC_VecFP, []>,
    RegConstraint<"@earlyclobber $AT">;
  def PM#NAME#PP :
    MMIRR_XX3Form_X4Y2_XAB6<
      opcode, xo, (outs acc:$AT),
      !con((ins acc:$ATi), !con(IOL, (ins u4imm:$XMSK, u2imm:$YMSK))),
      !strconcat("pm"#asmbase#"pp ", asmstr#", $XMSK, $YMSK"),
      IIC_VecFP, []>,
    RegConstraint<"$ATi = $AT">, NoEncode<"$ATi">;
  def PM#NAME#PN :
    MMIRR_XX3Form_X4Y2_XAB6<
      opcode, !or(xo, 0x80), (outs acc:$AT),
      !con((ins acc:$ATi), !con(IOL, (ins u4imm:$XMSK, u2imm:$YMSK))),
      !strconcat("pm"#asmbase#"pn ", asmstr#", $XMSK, $YMSK"),
      IIC_VecFP, []>,
    RegConstraint<"$ATi = $AT">, NoEncode<"$ATi">;
  def PM#NAME#NP :
    MMIRR_XX3Form_X4Y2_XAB6<
      opcode, !or(xo, 0x40), (outs acc:$AT),
      !con((ins acc:$ATi), !con(IOL, (ins u4imm:$XMSK, u2imm:$YMSK))),
      !strconcat("pm"#asmbase#"np ", asmstr#", $XMSK, $YMSK"),
      IIC_VecFP, []>,
    RegConstraint<"$ATi = $AT">, NoEncode<"$ATi">;
  def PM#NAME#NN :
    MMIRR_XX3Form_X4Y2_XAB6<
      opcode, !or(xo, 0xC0), (outs acc:$AT),
      !con((ins acc:$ATi), !con(IOL, (ins u4imm:$XMSK, u2imm:$YMSK))),
      !strconcat("pm"#asmbase#"nn ", asmstr#", $XMSK, $YMSK"),
      IIC_VecFP, []>,
    RegConstraint<"$ATi = $AT">, NoEncode<"$ATi">;
  }
}

// End of class definitions.
//-----------------------------------------------------------------------------

let Predicates = [MMA] in {
  def XXMFACC :
    XForm_AT3<31, 0, 177, (outs acc:$ASo), (ins acc:$AS), "xxmfacc $AS",
              IIC_VecGeneral,
              [(set v512i1:$ASo, (int_ppc_mma_xxmfacc v512i1:$AS))]>,
              RegConstraint<"$ASo = $AS">, NoEncode<"$ASo">;
  def XXMTACC :
    XForm_AT3<31, 1, 177, (outs acc:$AT), (ins acc:$ATi), "xxmtacc $AT",
              IIC_VecGeneral,
              [(set v512i1:$AT, (int_ppc_mma_xxmtacc v512i1:$ATi))]>,
              RegConstraint<"$ATi = $AT">, NoEncode<"$ATi">;
  def KILL_PAIR : PPCPostRAExpPseudo<(outs vsrprc:$XTp), (ins vsrprc:$XSp),
                                      "#KILL_PAIR", []>,
                                      RegConstraint<"$XTp = $XSp">;
  def BUILD_UACC : PPCPostRAExpPseudo<(outs acc:$AT), (ins uacc:$AS),
                                      "#BUILD_UACC $AT, $AS", []>;
  // We define XXSETACCZ as rematerializable to undo CSE of that intrinsic in
  // the backend. We avoid CSE here because it generates a copy of the acc
  // register and this copy is more expensive than calling the intrinsic again.
  let isAsCheapAsAMove = 1, isReMaterializable = 1 in {
    def XXSETACCZ :
      XForm_AT3<31, 3, 177, (outs acc:$AT), (ins), "xxsetaccz $AT", IIC_VecGeneral,
                [(set v512i1:$AT, (int_ppc_mma_xxsetaccz))]>;
  }
  def XVI8GER4SPP :
    XX3Form_AT3_XAB6<59, 99, (outs acc:$AT), (ins acc:$ATi, vsrc:$XA, vsrc:$XB),
                     "xvi8ger4spp $AT, $XA, $XB", IIC_VecGeneral, []>,
    RegConstraint<"$ATi = $AT">, NoEncode<"$ATi">;
  let mayStore = 1 in {
    def SPILL_ACC: PPCEmitTimePseudo<(outs), (ins acc:$AT, memrix16:$dst),
                                     "#SPILL_ACC", []>;
    def SPILL_UACC: PPCEmitTimePseudo<(outs), (ins uacc:$AT, memrix16:$dst),
                                     "#SPILL_UACC", []>;
  }
  let mayLoad = 1, hasSideEffects = 0 in {
    def RESTORE_ACC: PPCEmitTimePseudo<(outs acc:$AT), (ins memrix16:$src),
                                       "#RESTORE_ACC", []>;
    def RESTORE_UACC: PPCEmitTimePseudo<(outs uacc:$AT), (ins memrix16:$src),
                                       "#RESTORE_UACC", []>;
  }
}

let Predicates = [MMA, PrefixInstrs] in {
  def PMXVI8GER4SPP :
    MMIRR_XX3Form_XYP4_XAB6<59, 99, (outs acc:$AT),
                            (ins acc:$ATi, vsrc:$XA,vsrc:$XB, u4imm:$XMSK,
                             u4imm:$YMSK, u4imm:$PMSK),
                            "pmxvi8ger4spp $AT, $XA, $XB, $XMSK, $YMSK, $PMSK",
                            IIC_VecGeneral, []>,
    RegConstraint<"$ATi = $AT">, NoEncode<"$ATi">;
}

// MMA accumulating/non-accumulating instructions.
//------------------------------------------------------------------------------

// XVBF16GER2, XVBF16GER2PP, XVBF16GER2PN, XVBF16GER2NP, XVBF16GER2NN
// PMXVBF16GER2, PMXVBF16GER2PP, PMXVBF16GER2PN, PMXVBF16GER2NP, PMXVBF16GER2NN
defm XVBF16GER2 : ACC_NEG_UM_M244_XOM84C<59, 50, (ins vsrc:$XA, vsrc:$XB),
                                         "xvbf16ger2", "$AT, $XA, $XB">;

// XVI4GER8, XVI4GER8PP, PMXVI4GER8,  PMXVI4GER8PP
defm XVI4GER8 : ACC_UM_M844_XOEO<59, 34, (ins vsrc:$XA, vsrc:$XB),
                                 "xvi4ger8", "$AT, $XA, $XB">;

// XVI8GER4, XVI8GER4PP, PMXVI8GER4, PMXVI8GER4PP
defm XVI8GER4 : ACC_UM_M444_XOEO<59, 2, (ins vsrc:$XA, vsrc:$XB),
                                 "xvi8ger4", "$AT, $XA, $XB">;

// XVI16GER2, XVI16GER2PP, PMXVI16GER2, PMXVI16GER2PP
defm XVI16GER2 : ACC_UM_M244_XO46<59, 75, (ins vsrc:$XA, vsrc:$XB),
                                  "xvi16ger2", "$AT, $XA, $XB">;

// XVI16GER2S, XVI16GER2SPP, PMXVI16GER2S, PMXVI16GER2SPP
defm XVI16GER2S : ACC_UM_M244_XOEO<59, 42, (ins vsrc:$XA, vsrc:$XB),
                                   "xvi16ger2s", "$AT, $XA, $XB">;

// XVF16GER2, XVF16GER2PP, XVF16GER2PN, XVF16GER2NP, XVF16GER2NN
// PMXVF16GER2, PMXVF16GER2PP, PMXVF16GER2PN, PMXVF16GER2NP, PMXVF16GER2NN
defm XVF16GER2 : ACC_NEG_UM_M244_XOM84C<59, 18, (ins vsrc:$XA, vsrc:$XB),
                                        "xvf16ger2", "$AT, $XA, $XB">;

// XVF32GER, XVF32GERPP, XVF32GERPN, XVF32GERNP, XVF32GERPP
// PMXVF32GER, PMXVF32GERPP, PMXVF32GERPN, PMXVF32GERNP, PMXVF32GERPP
defm XVF32GER : ACC_NEG_UM_M44_XOM84C<59, 26, (ins vsrc:$XA, vsrc:$XB),
                                      "xvf32ger", "$AT, $XA, $XB">;

// XVF64GER, XVF64GERPP, XVF64GERPN, XVF64GERNP, XVF64GERNN
// PMXVF64GER, PMXVF64GERPP, PMXVF64GERPN, PMXVF64GERNP, PMXVF64GERNN
defm XVF64GER : ACC_NEG_UM_M42_XOM84C<59, 58, (ins vsrpevenrc:$XA, vsrc:$XB),
                                      "xvf64ger", "$AT, $XA, $XB">;
//------------------------------------------------------------------------------

// MMA Intrinsics
let Predicates = [MMA] in {
  def : Pat<(v512i1 (int_ppc_mma_xvi4ger8 v16i8:$XA, v16i8:$XB)),
            (XVI4GER8 RCCp.AToVSRC, RCCp.BToVSRC)>;
  def : Pat<(v512i1 (int_ppc_mma_xvi4ger8pp v512i1:$ATi, v16i8:$XA, v16i8:$XB)),
            (XVI4GER8PP $ATi, RCCp.AToVSRC, RCCp.BToVSRC)>;

  def : Pat<(v512i1 (int_ppc_mma_xvi8ger4 v16i8:$XA, v16i8:$XB)),
            (XVI8GER4 RCCp.AToVSRC, RCCp.BToVSRC)>;
  def : Pat<(v512i1 (int_ppc_mma_xvi8ger4pp v512i1:$ATi, v16i8:$XA, v16i8:$XB)),
            (XVI8GER4PP $ATi, RCCp.AToVSRC, RCCp.BToVSRC)>;

  def : Pat<(v512i1 (int_ppc_mma_xvi16ger2s v16i8:$XA, v16i8:$XB)),
            (XVI16GER2S RCCp.AToVSRC, RCCp.BToVSRC)>;
  def : Pat<(v512i1 (int_ppc_mma_xvi16ger2spp v512i1:$ATi, v16i8:$XA, v16i8:$XB)),
            (XVI16GER2SPP $ATi, RCCp.AToVSRC, RCCp.BToVSRC)>;

  def : Pat<(v512i1 (int_ppc_mma_xvf16ger2 v16i8:$XA, v16i8:$XB)),
            (XVF16GER2 RCCp.AToVSRC, RCCp.BToVSRC)>;
  def : Pat<(v512i1 (int_ppc_mma_xvf16ger2pp v512i1:$ATi, v16i8:$XA, v16i8:$XB)),
            (XVF16GER2PP $ATi, RCCp.AToVSRC, RCCp.BToVSRC)>;
  def : Pat<(v512i1 (int_ppc_mma_xvf16ger2pn v512i1:$ATi, v16i8:$XA, v16i8:$XB)),
            (XVF16GER2PN $ATi, RCCp.AToVSRC, RCCp.BToVSRC)>;
  def : Pat<(v512i1 (int_ppc_mma_xvf16ger2np v512i1:$ATi, v16i8:$XA, v16i8:$XB)),
            (XVF16GER2NP $ATi, RCCp.AToVSRC, RCCp.BToVSRC)>;
  def : Pat<(v512i1 (int_ppc_mma_xvf16ger2nn v512i1:$ATi, v16i8:$XA, v16i8:$XB)),
            (XVF16GER2NN $ATi, RCCp.AToVSRC, RCCp.BToVSRC)>;

  def : Pat<(v512i1 (int_ppc_mma_xvf32ger v16i8:$XA, v16i8:$XB)),
            (XVF32GER RCCp.AToVSRC, RCCp.BToVSRC)>;
  def : Pat<(v512i1 (int_ppc_mma_xvf32gerpp v512i1:$ATi, v16i8:$XA, v16i8:$XB)),
            (XVF32GERPP $ATi, RCCp.AToVSRC, RCCp.BToVSRC)>;
  def : Pat<(v512i1 (int_ppc_mma_xvf32gerpn v512i1:$ATi, v16i8:$XA, v16i8:$XB)),
            (XVF32GERPN $ATi, RCCp.AToVSRC, RCCp.BToVSRC)>;
  def : Pat<(v512i1 (int_ppc_mma_xvf32gernp v512i1:$ATi, v16i8:$XA, v16i8:$XB)),
            (XVF32GERNP $ATi, RCCp.AToVSRC, RCCp.BToVSRC)>;
  def : Pat<(v512i1 (int_ppc_mma_xvf32gernn v512i1:$ATi, v16i8:$XA, v16i8:$XB)),
            (XVF32GERNN $ATi, RCCp.AToVSRC, RCCp.BToVSRC)>;
  def : Pat<(v512i1 (int_ppc_mma_xvf64ger v256i1:$XA, v16i8:$XB)),
            (XVF64GER $XA, RCCp.BToVSRC)>;
  def : Pat<(v512i1 (int_ppc_mma_xvf64gerpp v512i1:$ATi, v256i1:$XA, v16i8:$XB)),
            (XVF64GERPP $ATi, $XA, RCCp.BToVSRC)>;
  def : Pat<(v512i1 (int_ppc_mma_xvf64gerpn v512i1:$ATi, v256i1:$XA, v16i8:$XB)),
            (XVF64GERPN $ATi, $XA, RCCp.BToVSRC)>;
  def : Pat<(v512i1 (int_ppc_mma_xvf64gernp v512i1:$ATi, v256i1:$XA, v16i8:$XB)),
            (XVF64GERNP $ATi, $XA, RCCp.BToVSRC)>;
  def : Pat<(v512i1 (int_ppc_mma_xvf64gernn v512i1:$ATi, v256i1:$XA, v16i8:$XB)),
            (XVF64GERNN $ATi, $XA, RCCp.BToVSRC)>;

  def : Pat<(v512i1 (int_ppc_mma_xvbf16ger2 v16i8:$XA, v16i8:$XB)),
            (XVBF16GER2 RCCp.AToVSRC, RCCp.BToVSRC)>;
  def : Pat<(v512i1 (int_ppc_mma_xvbf16ger2pp v512i1:$ATi, v16i8:$XA, v16i8:$XB)),
            (XVBF16GER2PP $ATi, RCCp.AToVSRC, RCCp.BToVSRC)>;
  def : Pat<(v512i1 (int_ppc_mma_xvbf16ger2pn v512i1:$ATi, v16i8:$XA, v16i8:$XB)),
            (XVBF16GER2PN $ATi, RCCp.AToVSRC, RCCp.BToVSRC)>;
  def : Pat<(v512i1 (int_ppc_mma_xvbf16ger2np v512i1:$ATi, v16i8:$XA, v16i8:$XB)),
            (XVBF16GER2NP $ATi, RCCp.AToVSRC, RCCp.BToVSRC)>;
  def : Pat<(v512i1 (int_ppc_mma_xvbf16ger2nn v512i1:$ATi, v16i8:$XA, v16i8:$XB)),
            (XVBF16GER2NN $ATi, RCCp.AToVSRC, RCCp.BToVSRC)>;
  def : Pat<(v512i1 (int_ppc_mma_xvi16ger2 v16i8:$XA, v16i8:$XB)),
            (XVI16GER2 RCCp.AToVSRC, RCCp.BToVSRC)>;
  def : Pat<(v512i1 (int_ppc_mma_xvi16ger2pp v512i1:$ATi, v16i8:$XA, v16i8:$XB)),
            (XVI16GER2PP $ATi, RCCp.AToVSRC, RCCp.BToVSRC)>;
  def : Pat<(v512i1 (int_ppc_mma_xvi8ger4spp v512i1:$ATi, v16i8:$XA, v16i8:$XB)),
            (XVI8GER4SPP $ATi, RCCp.AToVSRC, RCCp.BToVSRC)>;
}

// MMA Intrinsics
let Predicates = [MMA, PrefixInstrs] in {
  def : Pat<(v512i1 (int_ppc_mma_pmxvi4ger8 v16i8:$XA, v16i8:$XB, Msk4Imm:$XMSK,
                                            Msk4Imm:$YMSK, Msk8Imm:$PMSK)),
            (PMXVI4GER8 RCCp.AToVSRC, RCCp.BToVSRC, Msk4Imm:$XMSK,
                        Msk4Imm:$YMSK, Msk8Imm:$PMSK)>;
  def : Pat<(v512i1 (int_ppc_mma_pmxvi4ger8pp v512i1:$ATi, v16i8:$XA, v16i8:$XB,
                                              Msk4Imm:$XMSK, Msk4Imm:$YMSK,
                                              Msk8Imm:$PMSK)),
            (PMXVI4GER8PP $ATi, RCCp.AToVSRC, RCCp.BToVSRC, Msk4Imm:$XMSK,
                          Msk4Imm:$YMSK, Msk8Imm:$PMSK)>;

  def : Pat<(v512i1 (int_ppc_mma_pmxvi8ger4 v16i8:$XA, v16i8:$XB, Msk4Imm:$XMSK,
                                            Msk4Imm:$YMSK, Msk4Imm:$PMSK)),
            (PMXVI8GER4 RCCp.AToVSRC, RCCp.BToVSRC, Msk4Imm:$XMSK,
                        Msk4Imm:$YMSK, Msk4Imm:$PMSK)>;
  def : Pat<(v512i1 (int_ppc_mma_pmxvi8ger4pp v512i1:$ATi, v16i8:$XA, v16i8:$XB,
                                              Msk4Imm:$XMSK, Msk4Imm:$YMSK,
                                              Msk4Imm:$PMSK)),
            (PMXVI8GER4PP $ATi, RCCp.AToVSRC, RCCp.BToVSRC, Msk4Imm:$XMSK,
                          Msk4Imm:$YMSK, Msk4Imm:$PMSK)>;

  def : Pat<(v512i1 (int_ppc_mma_pmxvi16ger2s v16i8:$XA, v16i8:$XB, Msk4Imm:$XMSK,
                                              Msk4Imm:$YMSK, Msk2Imm:$PMSK)),
            (PMXVI16GER2S RCCp.AToVSRC, RCCp.BToVSRC, Msk4Imm:$XMSK,
                          Msk4Imm:$YMSK, Msk2Imm:$PMSK)>;
  def : Pat<(v512i1 (int_ppc_mma_pmxvi16ger2spp v512i1:$ATi, v16i8:$XA, v16i8:$XB,
                                                Msk4Imm:$XMSK, Msk4Imm:$YMSK,
                                                Msk2Imm:$PMSK)),
            (PMXVI16GER2SPP $ATi, RCCp.AToVSRC, RCCp.BToVSRC, Msk4Imm:$XMSK,
                            Msk4Imm:$YMSK, Msk2Imm:$PMSK)>;
  def : Pat<(v512i1 (int_ppc_mma_pmxvf16ger2 v16i8:$XA, v16i8:$XB, Msk4Imm:$XMSK,
                                             Msk4Imm:$YMSK, Msk2Imm:$PMSK)),
            (PMXVF16GER2 RCCp.AToVSRC, RCCp.BToVSRC, Msk4Imm:$XMSK,
                         Msk4Imm:$YMSK, Msk2Imm:$PMSK)>;
  def : Pat<(v512i1 (int_ppc_mma_pmxvf16ger2pp v512i1:$ATi, v16i8:$XA, v16i8:$XB,
                                               Msk4Imm:$XMSK, Msk4Imm:$YMSK,
                                               Msk2Imm:$PMSK)),
            (PMXVF16GER2PP $ATi, RCCp.AToVSRC, RCCp.BToVSRC, Msk4Imm:$XMSK,
                           Msk4Imm:$YMSK, Msk2Imm:$PMSK)>;
  def : Pat<(v512i1 (int_ppc_mma_pmxvf16ger2pn v512i1:$ATi, v16i8:$XA, v16i8:$XB,
                                               Msk4Imm:$XMSK, Msk4Imm:$YMSK,
                                               Msk2Imm:$PMSK)),
            (PMXVF16GER2PN $ATi, RCCp.AToVSRC, RCCp.BToVSRC, Msk4Imm:$XMSK,
                           Msk4Imm:$YMSK, Msk2Imm:$PMSK)>;
  def : Pat<(v512i1 (int_ppc_mma_pmxvf16ger2np v512i1:$ATi, v16i8:$XA, v16i8:$XB,
                                               Msk4Imm:$XMSK, Msk4Imm:$YMSK,
                                               Msk2Imm:$PMSK)),
            (PMXVF16GER2NP $ATi, RCCp.AToVSRC, RCCp.BToVSRC, Msk4Imm:$XMSK,
                           Msk4Imm:$YMSK, Msk2Imm:$PMSK)>;
  def : Pat<(v512i1 (int_ppc_mma_pmxvf16ger2pn v512i1:$ATi, v16i8:$XA, v16i8:$XB,
                                               Msk4Imm:$XMSK, Msk4Imm:$YMSK,
                                               Msk2Imm:$PMSK)),
            (PMXVF16GER2PN $ATi, RCCp.AToVSRC, RCCp.BToVSRC, Msk4Imm:$XMSK,
                           Msk4Imm:$YMSK, Msk2Imm:$PMSK)>;
  def : Pat<(v512i1 (int_ppc_mma_pmxvf16ger2np v512i1:$ATi, v16i8:$XA, v16i8:$XB,
                                               Msk4Imm:$XMSK, Msk4Imm:$YMSK,
                                               Msk2Imm:$PMSK)),
            (PMXVF16GER2NP $ATi, RCCp.AToVSRC, RCCp.BToVSRC, Msk4Imm:$XMSK,
                           Msk4Imm:$YMSK, Msk2Imm:$PMSK)>;
  def : Pat<(v512i1 (int_ppc_mma_pmxvf16ger2nn v512i1:$ATi, v16i8:$XA, v16i8:$XB,
                                               Msk4Imm:$XMSK, Msk4Imm:$YMSK,
                                               Msk2Imm:$PMSK)),
            (PMXVF16GER2NN $ATi, RCCp.AToVSRC, RCCp.BToVSRC, Msk4Imm:$XMSK,
                           Msk4Imm:$YMSK, Msk2Imm:$PMSK)>;

  def : Pat<(v512i1 (int_ppc_mma_pmxvf32ger v16i8:$XA, v16i8:$XB, Msk4Imm:$XMSK,
                                            Msk4Imm:$YMSK)),
            (PMXVF32GER RCCp.AToVSRC, RCCp.BToVSRC, Msk4Imm:$XMSK,
                        Msk4Imm:$YMSK)>;
  def : Pat<(v512i1 (int_ppc_mma_pmxvf32gerpp v512i1:$ATi, v16i8:$XA, v16i8:$XB,
                                              Msk4Imm:$XMSK, Msk4Imm:$YMSK)),
            (PMXVF32GERPP $ATi, RCCp.AToVSRC, RCCp.BToVSRC, Msk4Imm:$XMSK,
                          Msk4Imm:$YMSK)>;
  def : Pat<(v512i1 (int_ppc_mma_pmxvf32gerpn v512i1:$ATi, v16i8:$XA, v16i8:$XB,
                                              Msk4Imm:$XMSK, Msk4Imm:$YMSK)),
            (PMXVF32GERPN $ATi, RCCp.AToVSRC, RCCp.BToVSRC, Msk4Imm:$XMSK,
                          Msk4Imm:$YMSK)>;
  def : Pat<(v512i1 (int_ppc_mma_pmxvf32gernp v512i1:$ATi, v16i8:$XA, v16i8:$XB,
                                              Msk4Imm:$XMSK, Msk4Imm:$YMSK)),
            (PMXVF32GERNP $ATi, RCCp.AToVSRC, RCCp.BToVSRC, Msk4Imm:$XMSK,
                          Msk4Imm:$YMSK)>;
  def : Pat<(v512i1 (int_ppc_mma_pmxvf32gernn v512i1:$ATi, v16i8:$XA, v16i8:$XB,
                                              Msk4Imm:$XMSK, Msk4Imm:$YMSK)),
            (PMXVF32GERNN $ATi, RCCp.AToVSRC, RCCp.BToVSRC, Msk4Imm:$XMSK,
                          Msk4Imm:$YMSK)>;

  def : Pat<(v512i1 (int_ppc_mma_pmxvf64ger v256i1:$XA, v16i8:$XB, Msk4Imm:$XMSK,
                                            Msk2Imm:$YMSK)),
            (PMXVF64GER $XA, RCCp.BToVSRC, Msk4Imm:$XMSK, Msk2Imm:$YMSK)>;
  def : Pat<(v512i1 (int_ppc_mma_pmxvf64gerpp v512i1:$ATi, v256i1:$XA, v16i8:$XB,
                                              Msk4Imm:$XMSK, Msk2Imm:$YMSK)),
            (PMXVF64GERPP $ATi, $XA, RCCp.BToVSRC, Msk4Imm:$XMSK,
                          Msk2Imm:$YMSK)>;
  def : Pat<(v512i1 (int_ppc_mma_pmxvf64gerpn v512i1:$ATi, v256i1:$XA, v16i8:$XB,
                                              Msk4Imm:$XMSK, Msk2Imm:$YMSK)),
            (PMXVF64GERPN $ATi, $XA, RCCp.BToVSRC, Msk4Imm:$XMSK,
                          Msk2Imm:$YMSK)>;
  def : Pat<(v512i1 (int_ppc_mma_pmxvf64gernp v512i1:$ATi, v256i1:$XA, v16i8:$XB,
                                              Msk4Imm:$XMSK, Msk2Imm:$YMSK)),
            (PMXVF64GERNP $ATi, $XA, RCCp.BToVSRC, Msk4Imm:$XMSK,
                          Msk2Imm:$YMSK)>;
  def : Pat<(v512i1 (int_ppc_mma_pmxvf64gernn v512i1:$ATi, v256i1:$XA, v16i8:$XB,
                                              Msk4Imm:$XMSK, Msk2Imm:$YMSK)),
            (PMXVF64GERNN $ATi, $XA, RCCp.BToVSRC, Msk4Imm:$XMSK,
                          Msk2Imm:$YMSK)>;

  def : Pat<(v512i1 (int_ppc_mma_pmxvbf16ger2 v16i8:$XA, v16i8:$XB, Msk4Imm:$XMSK,
                                              Msk4Imm:$YMSK, Msk2Imm:$PMSK)),
            (PMXVBF16GER2 RCCp.AToVSRC, RCCp.BToVSRC, Msk4Imm:$XMSK,
                          Msk4Imm:$YMSK, Msk2Imm:$PMSK)>;
  def : Pat<(v512i1 (int_ppc_mma_pmxvbf16ger2pp v512i1:$ATi, v16i8:$XA, v16i8:$XB,
                                                Msk4Imm:$XMSK, Msk4Imm:$YMSK,
                                                Msk2Imm:$PMSK)),
            (PMXVBF16GER2PP $ATi, RCCp.AToVSRC, RCCp.BToVSRC, Msk4Imm:$XMSK,
                            Msk4Imm:$YMSK, Msk2Imm:$PMSK)>;
  def : Pat<(v512i1 (int_ppc_mma_pmxvbf16ger2pn v512i1:$ATi, v16i8:$XA, v16i8:$XB,
                                                Msk4Imm:$XMSK, Msk4Imm:$YMSK,
                                                Msk2Imm:$PMSK)),
            (PMXVBF16GER2PN $ATi, RCCp.AToVSRC, RCCp.BToVSRC, Msk4Imm:$XMSK,
                            Msk4Imm:$YMSK, Msk2Imm:$PMSK)>;
  def : Pat<(v512i1 (int_ppc_mma_pmxvbf16ger2np v512i1:$ATi, v16i8:$XA, v16i8:$XB,
                                                Msk4Imm:$XMSK, Msk4Imm:$YMSK,
                                                Msk2Imm:$PMSK)),
            (PMXVBF16GER2NP $ATi, RCCp.AToVSRC, RCCp.BToVSRC, Msk4Imm:$XMSK,
                            Msk4Imm:$YMSK, Msk2Imm:$PMSK)>;
  def : Pat<(v512i1 (int_ppc_mma_pmxvbf16ger2nn v512i1:$ATi, v16i8:$XA, v16i8:$XB,
                                                Msk4Imm:$XMSK, Msk4Imm:$YMSK,
                                                Msk2Imm:$PMSK)),
            (PMXVBF16GER2NN $ATi, RCCp.AToVSRC, RCCp.BToVSRC, Msk4Imm:$XMSK,
                            Msk4Imm:$YMSK, Msk2Imm:$PMSK)>;
  def : Pat<(v512i1 (int_ppc_mma_pmxvi16ger2 v16i8:$XA, v16i8:$XB, Msk4Imm:$XMSK,
                                             Msk4Imm:$YMSK, Msk2Imm:$PMSK)),
            (PMXVI16GER2 RCCp.AToVSRC, RCCp.BToVSRC, Msk4Imm:$XMSK,
                         Msk4Imm:$YMSK, Msk2Imm:$PMSK)>;
  def : Pat<(v512i1 (int_ppc_mma_pmxvi8ger4spp v512i1:$ATi, v16i8:$XA, v16i8:$XB,
                                               Msk4Imm:$XMSK, Msk4Imm:$YMSK,
                                               Msk2Imm:$PMSK)),
            (PMXVI8GER4SPP $ATi, RCCp.AToVSRC, RCCp.BToVSRC, Msk4Imm:$XMSK,
                           Msk4Imm:$YMSK, Msk2Imm:$PMSK)>;
  def : Pat<(v512i1 (int_ppc_mma_pmxvi16ger2pp v512i1:$ATi, v16i8:$XA, v16i8:$XB,
                                               Msk4Imm:$XMSK, Msk4Imm:$YMSK,
                                               Msk2Imm:$PMSK)),
            (PMXVI16GER2PP $ATi, RCCp.AToVSRC, RCCp.BToVSRC, Msk4Imm:$XMSK,
                           Msk4Imm:$YMSK, Msk2Imm:$PMSK)>;
}

def Concats {
  dag VecsToVecPair0 =
    (v256i1 (INSERT_SUBREG
      (INSERT_SUBREG (IMPLICIT_DEF), $vs0, sub_vsx1),
      $vs1, sub_vsx0));
  dag VecsToVecPair1 =
    (v256i1 (INSERT_SUBREG
      (INSERT_SUBREG (IMPLICIT_DEF), $vs2, sub_vsx1),
      $vs3, sub_vsx0));
  dag VecsToVecQuad =
    (BUILD_UACC (INSERT_SUBREG
                  (INSERT_SUBREG (v512i1 (IMPLICIT_DEF)),
                                 (KILL_PAIR VecsToVecPair0), sub_pair0),
                  (KILL_PAIR VecsToVecPair1), sub_pair1));
}

def Extracts {
  dag Pair0 = (v256i1 (EXTRACT_SUBREG $v, sub_pair0));
  dag Pair1 = (v256i1 (EXTRACT_SUBREG $v, sub_pair1));
  dag Vec0 = (v4i32 (EXTRACT_SUBREG Pair0, sub_vsx0));
  dag Vec1 = (v4i32 (EXTRACT_SUBREG Pair0, sub_vsx1));
  dag Vec2 = (v4i32 (EXTRACT_SUBREG Pair1, sub_vsx0));
  dag Vec3 = (v4i32 (EXTRACT_SUBREG Pair1, sub_vsx1));
}

let Predicates = [MMA] in {
  def : Pat<(v512i1 (PPCAccBuild v4i32:$vs1, v4i32:$vs0, v4i32:$vs3, v4i32:$vs2)),
            (XXMTACC Concats.VecsToVecQuad)>;
  def : Pat<(v512i1 (int_ppc_mma_assemble_acc v16i8:$vs1, v16i8:$vs0,
                                              v16i8:$vs3, v16i8:$vs2)),
            (XXMTACC Concats.VecsToVecQuad)>;
  def : Pat<(v512i1 (PPCxxmfacc v512i1:$AS)), (XXMFACC acc:$AS)>;
  def : Pat<(v4i32 (PPCAccExtractVsx acc:$v, 0)),
            Extracts.Vec0>;
  def : Pat<(v4i32 (PPCAccExtractVsx acc:$v, 1)),
            Extracts.Vec1>;
  def : Pat<(v4i32 (PPCAccExtractVsx acc:$v, 2)),
            Extracts.Vec2>;
  def : Pat<(v4i32 (PPCAccExtractVsx acc:$v, 3)),
            Extracts.Vec3>;
}

let Predicates = [PairedVectorMemops] in {
  def : Pat<(v256i1 (PPCPairBuild v4i32:$vs1, v4i32:$vs0)),
            Concats.VecsToVecPair0>;
  def : Pat<(v256i1 (int_ppc_vsx_assemble_pair v16i8:$vs1, v16i8:$vs0)),
            Concats.VecsToVecPair0>;
  def : Pat<(v4i32 (PPCPairExtractVsx vsrpevenrc:$v, 0)),
            (v4i32 (EXTRACT_SUBREG $v, sub_vsx0))>;
  def : Pat<(v4i32 (PPCPairExtractVsx vsrpevenrc:$v, 1)),
            (v4i32 (EXTRACT_SUBREG $v, sub_vsx1))>;
}

let mayLoad = 1, mayStore = 0, Predicates = [PairedVectorMemops] in {
  def LXVP : DQForm_XTp5_RA17_MEM<6, 0, (outs vsrprc:$XTp),
                                  (ins memrix16:$DQ_RA), "lxvp $XTp, $DQ_RA",
                                  IIC_LdStLFD, []>;
  def LXVPX : XForm_XTp5_XAB5<31, 333, (outs vsrprc:$XTp), (ins memrr:$src),
                              "lxvpx $XTp, $src", IIC_LdStLFD,
                              []>;
}

let mayLoad = 0, mayStore = 1, Predicates = [PairedVectorMemops] in {
  def STXVP : DQForm_XTp5_RA17_MEM<6, 1, (outs), (ins vsrprc:$XTp,
                                   memrix16:$DQ_RA), "stxvp $XTp, $DQ_RA",
                                   IIC_LdStLFD, []>;
  def STXVPX : XForm_XTp5_XAB5<31, 461, (outs), (ins vsrprc:$XTp, memrr:$dst),
                               "stxvpx $XTp, $dst", IIC_LdStLFD,
                               []>;
}

let mayLoad = 1, mayStore = 0, Predicates = [PairedVectorMemops, PrefixInstrs] in {
  defm PLXVP :
    8LS_DForm_R_XTp5_SI34_MEM_p<1, 58, (outs vsrprc:$XTp), (ins memri34:$D_RA),
                                (ins memri34_pcrel:$D_RA), "plxvp $XTp, $D_RA",
                                IIC_LdStLFD>;
}

let mayLoad = 0, mayStore = 1, Predicates = [PairedVectorMemops, PrefixInstrs] in {
  defm PSTXVP :
    8LS_DForm_R_XTp5_SI34_MEM_p<1, 62, (outs), (ins vsrprc:$XTp, memri34:$D_RA),
                                (ins vsrprc:$XTp, memri34_pcrel:$D_RA),
                                "pstxvp $XTp, $D_RA", IIC_LdStLFD>;
}

let Predicates = [PairedVectorMemops] in {
  // Intrinsics for Paired Vector Loads.
  def : Pat<(v256i1 (int_ppc_vsx_lxvp iaddrX16:$src)), (LXVP memrix16:$src)>;
  def : Pat<(v256i1 (int_ppc_vsx_lxvp xaddrX16:$src)), (LXVPX xaddrX16:$src)>;
  let Predicates = [PairedVectorMemops, PrefixInstrs] in {
    def : Pat<(v256i1 (int_ppc_vsx_lxvp iaddrX34:$src)), (PLXVP memri34:$src)>;
  }
  // Intrinsics for Paired Vector Stores.
  def : Pat<(int_ppc_vsx_stxvp v256i1:$XSp, iaddrX16:$dst),
            (STXVP $XSp, memrix16:$dst)>;
  def : Pat<(int_ppc_vsx_stxvp v256i1:$XSp, xaddrX16:$dst),
            (STXVPX $XSp, xaddrX16:$dst)>;
  let Predicates = [PairedVectorMemops, PrefixInstrs] in {
    def : Pat<(int_ppc_vsx_stxvp v256i1:$XSp, iaddrX34:$dst),
              (PSTXVP $XSp, memri34:$dst)>;
  }
}

// TODO: We have an added complexity of 500 here. This is only a temporary
// solution to have tablegen consider these patterns first. The way we do
// addressing for PowerPC is complex depending on available D form, X form, or
// aligned D form loads/stores like DS and DQ forms. The prefixed
// instructions in this file also add additional PC Relative loads/stores
// and D form loads/stores with 34 bit immediates. It is very difficult to force
// instruction selection to consistently pick these first without the current
// added complexity. Once pc-relative implementation is complete, a set of
// follow-up patches will address this refactoring and the AddedComplexity will
// be removed.
let Predicates = [PCRelativeMemops], AddedComplexity = 500 in {
  // Load i32
  def : Pat<(i32 (zextloadi1  (PPCmatpcreladdr pcreladdr:$ga))),
            (PLBZpc $ga, 0)>;
  def : Pat<(i32 (extloadi1  (PPCmatpcreladdr pcreladdr:$ga))),
            (PLBZpc $ga, 0)>;
  def : Pat<(i32 (zextloadi8  (PPCmatpcreladdr pcreladdr:$ga))),
            (PLBZpc $ga, 0)>;
  def : Pat<(i32 (extloadi8   (PPCmatpcreladdr pcreladdr:$ga))),
            (PLBZpc $ga, 0)>;
  def : Pat<(i32 (sextloadi16 (PPCmatpcreladdr pcreladdr:$ga))),
            (PLHApc $ga, 0)>;
  def : Pat<(i32 (zextloadi16 (PPCmatpcreladdr pcreladdr:$ga))),
            (PLHZpc $ga, 0)>;
  def : Pat<(i32 (extloadi16 (PPCmatpcreladdr pcreladdr:$ga))),
            (PLHZpc $ga, 0)>;
  def : Pat<(i32 (load (PPCmatpcreladdr pcreladdr:$ga))), (PLWZpc $ga, 0)>;

  // Store i32
  def : Pat<(truncstorei8 i32:$RS, (PPCmatpcreladdr pcreladdr:$ga)),
            (PSTBpc $RS, $ga, 0)>;
  def : Pat<(truncstorei16 i32:$RS, (PPCmatpcreladdr pcreladdr:$ga)),
            (PSTHpc $RS, $ga, 0)>;
  def : Pat<(store i32:$RS, (PPCmatpcreladdr pcreladdr:$ga)),
            (PSTWpc $RS, $ga, 0)>;

  // Load i64
  def : Pat<(i64 (zextloadi1  (PPCmatpcreladdr pcreladdr:$ga))),
            (PLBZ8pc $ga, 0)>;
  def : Pat<(i64 (extloadi1  (PPCmatpcreladdr pcreladdr:$ga))),
            (PLBZ8pc $ga, 0)>;
  def : Pat<(i64 (zextloadi8  (PPCmatpcreladdr pcreladdr:$ga))),
            (PLBZ8pc $ga, 0)>;
  def : Pat<(i64 (extloadi8   (PPCmatpcreladdr pcreladdr:$ga))),
            (PLBZ8pc $ga, 0)>;
  def : Pat<(i64 (sextloadi16 (PPCmatpcreladdr pcreladdr:$ga))),
            (PLHA8pc $ga, 0)>;
  def : Pat<(i64 (zextloadi16 (PPCmatpcreladdr pcreladdr:$ga))),
            (PLHZ8pc $ga, 0)>;
  def : Pat<(i64 (extloadi16 (PPCmatpcreladdr pcreladdr:$ga))),
            (PLHZ8pc $ga, 0)>;
  def : Pat<(i64 (zextloadi32 (PPCmatpcreladdr pcreladdr:$ga))),
            (PLWZ8pc $ga, 0)>;
  def : Pat<(i64 (sextloadi32 (PPCmatpcreladdr pcreladdr:$ga))),
            (PLWA8pc $ga, 0)>;
  def : Pat<(i64 (extloadi32 (PPCmatpcreladdr pcreladdr:$ga))),
            (PLWZ8pc $ga, 0)>;
  def : Pat<(i64 (load (PPCmatpcreladdr pcreladdr:$ga))), (PLDpc $ga, 0)>;

  // Store i64
  def : Pat<(truncstorei8 i64:$RS, (PPCmatpcreladdr pcreladdr:$ga)),
            (PSTB8pc $RS, $ga, 0)>;
  def : Pat<(truncstorei16 i64:$RS, (PPCmatpcreladdr pcreladdr:$ga)),
            (PSTH8pc $RS, $ga, 0)>;
  def : Pat<(truncstorei32 i64:$RS, (PPCmatpcreladdr pcreladdr:$ga)),
            (PSTW8pc $RS, $ga, 0)>;
  def : Pat<(store i64:$RS, (PPCmatpcreladdr pcreladdr:$ga)),
            (PSTDpc $RS, $ga, 0)>;

  // Load f32
  def : Pat<(f32 (load (PPCmatpcreladdr pcreladdr:$addr))), (PLFSpc $addr, 0)>;

  // Store f32
  def : Pat<(store f32:$FRS, (PPCmatpcreladdr pcreladdr:$ga)),
            (PSTFSpc $FRS, $ga, 0)>;

  // Load f64
  def : Pat<(f64 (extloadf32 (PPCmatpcreladdr pcreladdr:$addr))),
            (COPY_TO_REGCLASS (PLFSpc $addr, 0), VSFRC)>;
  def : Pat<(f64 (load (PPCmatpcreladdr pcreladdr:$addr))), (PLFDpc $addr, 0)>;

  // Store f64
  def : Pat<(store f64:$FRS, (PPCmatpcreladdr pcreladdr:$ga)),
            (PSTFDpc $FRS, $ga, 0)>;

  // Load f128
  def : Pat<(f128 (load (PPCmatpcreladdr pcreladdr:$addr))),
            (COPY_TO_REGCLASS (PLXVpc $addr, 0), VRRC)>;

  // Store f128
  def : Pat<(store f128:$XS, (PPCmatpcreladdr pcreladdr:$ga)),
            (PSTXVpc (COPY_TO_REGCLASS $XS, VSRC), $ga, 0)>;

  // Load v4i32
  def : Pat<(v4i32 (load (PPCmatpcreladdr pcreladdr:$addr))), (PLXVpc $addr, 0)>;

  // Store v4i32
  def : Pat<(store v4i32:$XS, (PPCmatpcreladdr pcreladdr:$ga)),
            (PSTXVpc $XS, $ga, 0)>;

  // Load v2i64
  def : Pat<(v2i64 (load (PPCmatpcreladdr pcreladdr:$addr))), (PLXVpc $addr, 0)>;

  // Store v2i64
  def : Pat<(store v2i64:$XS, (PPCmatpcreladdr pcreladdr:$ga)),
            (PSTXVpc $XS, $ga, 0)>;

  // Load v4f32
  def : Pat<(v4f32 (load (PPCmatpcreladdr pcreladdr:$addr))), (PLXVpc $addr, 0)>;

  // Store v4f32
  def : Pat<(store v4f32:$XS, (PPCmatpcreladdr pcreladdr:$ga)),
            (PSTXVpc $XS, $ga, 0)>;

  // Load v2f64
  def : Pat<(v2f64 (load (PPCmatpcreladdr pcreladdr:$addr))), (PLXVpc $addr, 0)>;

  // Store v2f64
  def : Pat<(store v2f64:$XS, (PPCmatpcreladdr pcreladdr:$ga)),
            (PSTXVpc $XS, $ga, 0)>;

  // Atomic Load
  def : Pat<(atomic_load_8 (PPCmatpcreladdr pcreladdr:$ga)),
            (PLBZpc $ga, 0)>;
  def : Pat<(atomic_load_16 (PPCmatpcreladdr pcreladdr:$ga)),
            (PLHZpc $ga, 0)>;
  def : Pat<(atomic_load_32 (PPCmatpcreladdr pcreladdr:$ga)),
            (PLWZpc $ga, 0)>;
  def : Pat<(atomic_load_64 (PPCmatpcreladdr pcreladdr:$ga)),
            (PLDpc $ga, 0)>;

  // Atomic Store
  def : Pat<(atomic_store_8 (PPCmatpcreladdr pcreladdr:$ga), i32:$RS),
            (PSTBpc $RS, $ga, 0)>;
  def : Pat<(atomic_store_16 (PPCmatpcreladdr pcreladdr:$ga), i32:$RS),
            (PSTHpc $RS, $ga, 0)>;
  def : Pat<(atomic_store_32 (PPCmatpcreladdr pcreladdr:$ga), i32:$RS),
            (PSTWpc $RS, $ga, 0)>;
  def : Pat<(atomic_store_8 (PPCmatpcreladdr pcreladdr:$ga), i64:$RS),
            (PSTB8pc $RS, $ga, 0)>;
  def : Pat<(atomic_store_16 (PPCmatpcreladdr pcreladdr:$ga), i64:$RS),
            (PSTH8pc $RS, $ga, 0)>;
  def : Pat<(atomic_store_32 (PPCmatpcreladdr pcreladdr:$ga), i64:$RS),
            (PSTW8pc $RS, $ga, 0)>;
  def : Pat<(atomic_store_64 (PPCmatpcreladdr pcreladdr:$ga), i64:$RS),
            (PSTDpc $RS, $ga, 0)>;

  // Special Cases For PPCstore_scal_int_from_vsr
  def : Pat<(PPCstore_scal_int_from_vsr
              (f64 (PPCcv_fp_to_sint_in_vsr f64:$src)),
              (PPCmatpcreladdr pcreladdr:$dst), 8),
            (PSTXSDpc (XSCVDPSXDS f64:$src), $dst, 0)>;
  def : Pat<(PPCstore_scal_int_from_vsr
              (f64 (PPCcv_fp_to_sint_in_vsr f128:$src)),
              (PPCmatpcreladdr pcreladdr:$dst), 8),
            (PSTXSDpc (COPY_TO_REGCLASS (XSCVQPSDZ f128:$src), VFRC), $dst, 0)>;

  def : Pat<(PPCstore_scal_int_from_vsr
              (f64 (PPCcv_fp_to_uint_in_vsr f64:$src)),
              (PPCmatpcreladdr pcreladdr:$dst), 8),
            (PSTXSDpc (XSCVDPUXDS f64:$src), $dst, 0)>;
  def : Pat<(PPCstore_scal_int_from_vsr
              (f64 (PPCcv_fp_to_uint_in_vsr f128:$src)),
              (PPCmatpcreladdr pcreladdr:$dst), 8),
            (PSTXSDpc (COPY_TO_REGCLASS (XSCVQPUDZ f128:$src), VFRC), $dst, 0)>;

  // If the PPCmatpcreladdr node is not caught by any other pattern it should be
  // caught here and turned into a paddi instruction to materialize the address.
  def : Pat<(PPCmatpcreladdr pcreladdr:$addr), (PADDI8pc 0, $addr)>;
  // PPCtlsdynamatpcreladdr node is used for TLS dynamic models to materialize
  // tls global address with paddi instruction.
  def : Pat<(PPCtlsdynamatpcreladdr pcreladdr:$addr), (PADDI8pc 0, $addr)>;
  // PPCtlslocalexecmataddr node is used for TLS local exec models to
  // materialize tls global address with paddi instruction.
  def : Pat<(PPCaddTls i64:$in, (PPCtlslocalexecmataddr tglobaltlsaddr:$addr)),
            (PADDI8 $in, $addr)>;
}

let Predicates = [PrefixInstrs] in {
  def XXSPLTIW : 8RR_DForm_IMM32_XT6<32, 3, (outs vsrc:$XT),
                                     (ins i32imm:$IMM32),
                                     "xxspltiw $XT, $IMM32", IIC_VecGeneral,
                                     []>;
  def XXSPLTIDP : 8RR_DForm_IMM32_XT6<32, 2, (outs vsrc:$XT),
                                      (ins i32imm:$IMM32),
                                      "xxspltidp $XT, $IMM32", IIC_VecGeneral,
                                      [(set v2f64:$XT,
                                            (PPCxxspltidp i32:$IMM32))]>;
  def XXPERMX :
    8RR_XX4Form_IMM3_XTABC6<34, 0, (outs vsrc:$XT), (ins vsrc:$XA, vsrc:$XB,
                            vsrc:$XC, u3imm:$UIM),
                            "xxpermx $XT, $XA, $XB, $XC, $UIM",
                            IIC_VecPerm, []>;
  def XXBLENDVB :
    8RR_XX4Form_XTABC6<33, 0, (outs vsrc:$XT), (ins vsrc:$XA, vsrc:$XB,
                       vsrc:$XC), "xxblendvb $XT, $XA, $XB, $XC",
                       IIC_VecGeneral, []>;
  def XXBLENDVH :
    8RR_XX4Form_XTABC6<33, 1, (outs vsrc:$XT), (ins vsrc:$XA, vsrc:$XB,
                       vsrc:$XC), "xxblendvh $XT, $XA, $XB, $XC",
                       IIC_VecGeneral, []>;
  def XXBLENDVW :
    8RR_XX4Form_XTABC6<33, 2, (outs vsrc:$XT), (ins vsrc:$XA, vsrc:$XB,
                       vsrc:$XC), "xxblendvw $XT, $XA, $XB, $XC",
                       IIC_VecGeneral, []>;
  def XXBLENDVD :
    8RR_XX4Form_XTABC6<33, 3, (outs vsrc:$XT), (ins vsrc:$XA, vsrc:$XB,
                       vsrc:$XC), "xxblendvd $XT, $XA, $XB, $XC",
                       IIC_VecGeneral, []>;
}

// XXSPLI32DX needs extra flags to make sure the compiler does not attempt
// to spill part of the instruction when the values are similar.
let isReMaterializable = 1, isMoveImm = 1, Predicates = [PrefixInstrs] in {
  def XXSPLTI32DX :
      8RR_DForm_IMM32_XT6_IX<32, 0, (outs vsrc:$XT),
                             (ins vsrc:$XTi, u1imm:$IX, i32imm:$IMM32),
                             "xxsplti32dx $XT, $IX, $IMM32", IIC_VecGeneral,
                             [(set v2i64:$XT,
                                   (PPCxxsplti32dx v2i64:$XTi, i32:$IX,
                                                   i32:$IMM32))]>,
                             RegConstraint<"$XTi = $XT">, NoEncode<"$XTi">;
}

let Predicates = [IsISA3_1] in {
  def SETBC : XForm_XT5_BI5<31, 384, (outs gprc:$RT), (ins crbitrc:$BI),
                            "setbc $RT, $BI", IIC_IntCompare, []>;
  def SETBCR : XForm_XT5_BI5<31, 416, (outs gprc:$RT), (ins crbitrc:$BI),
                             "setbcr $RT, $BI", IIC_IntCompare, []>;
  def SETNBC : XForm_XT5_BI5<31, 448, (outs gprc:$RT), (ins crbitrc:$BI),
                             "setnbc $RT, $BI", IIC_IntCompare, []>;
  def SETNBCR : XForm_XT5_BI5<31, 480, (outs gprc:$RT), (ins crbitrc:$BI),
                              "setnbcr $RT, $BI", IIC_IntCompare, []>;

  let Interpretation64Bit = 1, isCodeGenOnly = 1 in {
    def SETBC8 : XForm_XT5_BI5<31, 384, (outs g8rc:$RT), (ins crbitrc:$BI),
                               "setbc $RT, $BI", IIC_IntCompare, []>;
    def SETBCR8 : XForm_XT5_BI5<31, 416, (outs g8rc:$RT), (ins crbitrc:$BI),
                                "setbcr $RT, $BI", IIC_IntCompare, []>;
    def SETNBC8 : XForm_XT5_BI5<31, 448, (outs g8rc:$RT), (ins crbitrc:$BI),
                                "setnbc $RT, $BI", IIC_IntCompare, []>;
    def SETNBCR8 : XForm_XT5_BI5<31, 480, (outs g8rc:$RT), (ins crbitrc:$BI),
                                 "setnbcr $RT, $BI", IIC_IntCompare, []>;
  }

  def VSLDBI : VNForm_VTAB5_SD3<22, 0, (outs vrrc:$VRT),
                                (ins vrrc:$VRA, vrrc:$VRB, u3imm:$SH),
                                "vsldbi $VRT, $VRA, $VRB, $SH",
                                IIC_VecGeneral, 
                                [(set v16i8:$VRT,
                                      (int_ppc_altivec_vsldbi v16i8:$VRA,
                                                              v16i8:$VRB,
                                                              i32:$SH))]>;
  def VSRDBI : VNForm_VTAB5_SD3<22, 1, (outs vrrc:$VRT),
                                (ins vrrc:$VRA, vrrc:$VRB, u3imm:$SH),
                                "vsrdbi $VRT, $VRA, $VRB, $SH",
                                IIC_VecGeneral,
                                [(set v16i8:$VRT,
                                      (int_ppc_altivec_vsrdbi v16i8:$VRA,
                                                              v16i8:$VRB, 
                                                              i32:$SH))]>;
  defm VSTRIBR : VXForm_VTB5_RCr<13, 1, (outs vrrc:$vT), (ins vrrc:$vB),
                                 "vstribr", "$vT, $vB", IIC_VecGeneral,
				 [(set v16i8:$vT,
                                       (int_ppc_altivec_vstribr v16i8:$vB))]>;
  defm VSTRIBL : VXForm_VTB5_RCr<13, 0, (outs vrrc:$vT), (ins vrrc:$vB),
                                 "vstribl", "$vT, $vB", IIC_VecGeneral,
                                 [(set v16i8:$vT,
                                       (int_ppc_altivec_vstribl v16i8:$vB))]>;
  defm VSTRIHR : VXForm_VTB5_RCr<13, 3, (outs vrrc:$vT), (ins vrrc:$vB),
                                 "vstrihr", "$vT, $vB", IIC_VecGeneral,
                                 [(set v8i16:$vT,
                                       (int_ppc_altivec_vstrihr v8i16:$vB))]>;
  defm VSTRIHL : VXForm_VTB5_RCr<13, 2, (outs vrrc:$vT), (ins vrrc:$vB),
                                 "vstrihl", "$vT, $vB", IIC_VecGeneral,
                                 [(set v8i16:$vT,
                                       (int_ppc_altivec_vstrihl v8i16:$vB))]>;
  def VINSW :
    VXForm_1<207, (outs vrrc:$vD), (ins vrrc:$vDi, u4imm:$UIM, gprc:$rB),
             "vinsw $vD, $rB, $UIM", IIC_VecGeneral,
             [(set v4i32:$vD,
                   (int_ppc_altivec_vinsw v4i32:$vDi, i32:$rB, timm:$UIM))]>,
             RegConstraint<"$vDi = $vD">, NoEncode<"$vDi">;
  def VINSD :
    VXForm_1<463, (outs vrrc:$vD), (ins vrrc:$vDi, u4imm:$UIM, g8rc:$rB),
             "vinsd $vD, $rB, $UIM", IIC_VecGeneral,
             [(set v2i64:$vD,
                   (int_ppc_altivec_vinsd v2i64:$vDi, i64:$rB, timm:$UIM))]>,
             RegConstraint<"$vDi = $vD">, NoEncode<"$vDi">;
  def VINSBVLX :
    VXForm_VTB5_RA5_ins<15, "vinsbvlx",
                        [(set v16i8:$vD,
                              (int_ppc_altivec_vinsbvlx v16i8:$vDi, i32:$rA,
                                                        v16i8:$vB))]>;
  def VINSBVRX :
    VXForm_VTB5_RA5_ins<271, "vinsbvrx",
                        [(set v16i8:$vD,
                              (int_ppc_altivec_vinsbvrx v16i8:$vDi, i32:$rA,
                                                        v16i8:$vB))]>;
  def VINSHVLX :
    VXForm_VTB5_RA5_ins<79, "vinshvlx",
                        [(set v8i16:$vD,
                              (int_ppc_altivec_vinshvlx v8i16:$vDi, i32:$rA,
                                                        v8i16:$vB))]>;
  def VINSHVRX :
    VXForm_VTB5_RA5_ins<335, "vinshvrx",
                        [(set v8i16:$vD,
                              (int_ppc_altivec_vinshvrx v8i16:$vDi, i32:$rA,
                                                        v8i16:$vB))]>;
  def VINSWVLX :
    VXForm_VTB5_RA5_ins<143, "vinswvlx",
                        [(set v4i32:$vD,
                              (int_ppc_altivec_vinswvlx v4i32:$vDi, i32:$rA,
                                                        v4i32:$vB))]>;
  def VINSWVRX :
    VXForm_VTB5_RA5_ins<399, "vinswvrx",
                        [(set v4i32:$vD,
                              (int_ppc_altivec_vinswvrx v4i32:$vDi, i32:$rA,
                                                        v4i32:$vB))]>;
  def VINSBLX :
    VXForm_VRT5_RAB5_ins<527, "vinsblx",
                         [(set v16i8:$vD,
                               (int_ppc_altivec_vinsblx v16i8:$vDi, i32:$rA,
                                                        i32:$rB))]>;
  def VINSBRX :
    VXForm_VRT5_RAB5_ins<783, "vinsbrx",
                         [(set v16i8:$vD,
                               (int_ppc_altivec_vinsbrx v16i8:$vDi, i32:$rA,
                                                        i32:$rB))]>;
  def VINSHLX :
    VXForm_VRT5_RAB5_ins<591, "vinshlx",
                         [(set v8i16:$vD,
                               (int_ppc_altivec_vinshlx v8i16:$vDi, i32:$rA,
                                                        i32:$rB))]>;
  def VINSHRX :
    VXForm_VRT5_RAB5_ins<847, "vinshrx",
                         [(set v8i16:$vD,
                               (int_ppc_altivec_vinshrx v8i16:$vDi, i32:$rA,
                                                        i32:$rB))]>;
  def VINSWLX :
    VXForm_VRT5_RAB5_ins<655, "vinswlx",
                         [(set v4i32:$vD,
                               (int_ppc_altivec_vinswlx v4i32:$vDi, i32:$rA,
                                                        i32:$rB))]>;
  def VINSWRX :
    VXForm_VRT5_RAB5_ins<911, "vinswrx",
                         [(set v4i32:$vD,
                               (int_ppc_altivec_vinswrx v4i32:$vDi, i32:$rA,
                                                        i32:$rB))]>;
  def VINSDLX :
    VXForm_1<719, (outs vrrc:$vD), (ins vrrc:$vDi, g8rc:$rA, g8rc:$rB),
             "vinsdlx $vD, $rA, $rB", IIC_VecGeneral,
              [(set v2i64:$vD,
                    (int_ppc_altivec_vinsdlx v2i64:$vDi, i64:$rA, i64:$rB))]>,
              RegConstraint<"$vDi = $vD">, NoEncode<"$vDi">;
  def VINSDRX :
    VXForm_1<975, (outs vrrc:$vD), (ins vrrc:$vDi, g8rc:$rA, g8rc:$rB),
             "vinsdrx $vD, $rA, $rB", IIC_VecGeneral,
              [(set v2i64:$vD,
                    (int_ppc_altivec_vinsdrx v2i64:$vDi, i64:$rA, i64:$rB))]>,
              RegConstraint<"$vDi = $vD">, NoEncode<"$vDi">;
  def VEXTRACTBM : VXForm_RD5_XO5_RS5<1602, 8, (outs gprc:$rD), (ins vrrc:$vB),
                                      "vextractbm $rD, $vB", IIC_VecGeneral,
                                      [(set i32:$rD,
                                      (int_ppc_altivec_vextractbm v16i8:$vB))]>;
  def VEXTRACTHM : VXForm_RD5_XO5_RS5<1602, 9, (outs gprc:$rD), (ins vrrc:$vB),
                                      "vextracthm $rD, $vB", IIC_VecGeneral,
                                      [(set i32:$rD,
                                      (int_ppc_altivec_vextracthm v8i16:$vB))]>;
  def VEXTRACTWM : VXForm_RD5_XO5_RS5<1602, 10, (outs gprc:$rD), (ins vrrc:$vB),
                                      "vextractwm $rD, $vB", IIC_VecGeneral,
                                      [(set i32:$rD,
                                      (int_ppc_altivec_vextractwm v4i32:$vB))]>;
  def VEXTRACTDM : VXForm_RD5_XO5_RS5<1602, 11, (outs gprc:$rD), (ins vrrc:$vB),
                                      "vextractdm $rD, $vB", IIC_VecGeneral,
                                      [(set i32:$rD,
                                      (int_ppc_altivec_vextractdm v2i64:$vB))]>;
  def VEXTRACTQM : VXForm_RD5_XO5_RS5<1602, 12, (outs gprc:$rD), (ins vrrc:$vB),
                                      "vextractqm $rD, $vB", IIC_VecGeneral,
                                      [(set i32:$rD,
                                      (int_ppc_altivec_vextractqm v1i128:$vB))]>;
  def VEXPANDBM : VXForm_RD5_XO5_RS5<1602, 0, (outs vrrc:$vD), (ins vrrc:$vB),
                                     "vexpandbm $vD, $vB", IIC_VecGeneral,
                                     [(set v16i8:$vD, (int_ppc_altivec_vexpandbm
                                           v16i8:$vB))]>;
  def VEXPANDHM : VXForm_RD5_XO5_RS5<1602, 1, (outs vrrc:$vD), (ins vrrc:$vB),
                                     "vexpandhm $vD, $vB", IIC_VecGeneral,
                                     [(set v8i16:$vD, (int_ppc_altivec_vexpandhm
                                           v8i16:$vB))]>;
  def VEXPANDWM : VXForm_RD5_XO5_RS5<1602, 2, (outs vrrc:$vD), (ins vrrc:$vB),
                                     "vexpandwm $vD, $vB", IIC_VecGeneral,
                                     [(set v4i32:$vD, (int_ppc_altivec_vexpandwm
                                           v4i32:$vB))]>;
  def VEXPANDDM : VXForm_RD5_XO5_RS5<1602, 3, (outs vrrc:$vD), (ins vrrc:$vB),
                                     "vexpanddm $vD, $vB", IIC_VecGeneral,
                                     [(set v2i64:$vD, (int_ppc_altivec_vexpanddm
                                           v2i64:$vB))]>;
  def VEXPANDQM : VXForm_RD5_XO5_RS5<1602, 4, (outs vrrc:$vD), (ins vrrc:$vB),
                                     "vexpandqm $vD, $vB", IIC_VecGeneral,
                                     [(set v1i128:$vD, (int_ppc_altivec_vexpandqm
                                           v1i128:$vB))]>;
  def MTVSRBM : VXForm_RD5_XO5_RS5<1602, 16, (outs vrrc:$vD), (ins g8rc:$rB),
                                   "mtvsrbm $vD, $rB", IIC_VecGeneral,
                                   [(set v16i8:$vD,
                                         (int_ppc_altivec_mtvsrbm i64:$rB))]>;
  def MTVSRHM : VXForm_RD5_XO5_RS5<1602, 17, (outs vrrc:$vD), (ins g8rc:$rB),
                                   "mtvsrhm $vD, $rB", IIC_VecGeneral,
                                   [(set v8i16:$vD,
                                         (int_ppc_altivec_mtvsrhm i64:$rB))]>;
  def MTVSRWM : VXForm_RD5_XO5_RS5<1602, 18, (outs vrrc:$vD), (ins g8rc:$rB),
                                   "mtvsrwm $vD, $rB", IIC_VecGeneral,
                                   [(set v4i32:$vD,
                                         (int_ppc_altivec_mtvsrwm i64:$rB))]>;
  def MTVSRDM : VXForm_RD5_XO5_RS5<1602, 19, (outs vrrc:$vD), (ins g8rc:$rB),
                                   "mtvsrdm $vD, $rB", IIC_VecGeneral,
                                   [(set v2i64:$vD,
                                         (int_ppc_altivec_mtvsrdm i64:$rB))]>;
  def MTVSRQM : VXForm_RD5_XO5_RS5<1602, 20, (outs vrrc:$vD), (ins g8rc:$rB),
                                   "mtvsrqm $vD, $rB", IIC_VecGeneral,
                                   [(set v1i128:$vD,
                                         (int_ppc_altivec_mtvsrqm i64:$rB))]>;
  def MTVSRBMI : DXForm<4, 10, (outs vrrc:$vD), (ins u16imm64:$D),
                        "mtvsrbmi $vD, $D", IIC_VecGeneral,
                        [(set v16i8:$vD,
                              (int_ppc_altivec_mtvsrbm imm:$D))]>;
  def VCNTMBB : VXForm_RD5_MP_VB5<1602, 12, (outs g8rc:$rD),
                                  (ins vrrc:$vB, u1imm:$MP),
                                  "vcntmbb $rD, $vB, $MP", IIC_VecGeneral,
                                  [(set i64:$rD, (int_ppc_altivec_vcntmbb
                                        v16i8:$vB, timm:$MP))]>;
  def VCNTMBH : VXForm_RD5_MP_VB5<1602, 13, (outs g8rc:$rD),
                                  (ins vrrc:$vB, u1imm:$MP),
                                  "vcntmbh $rD, $vB, $MP", IIC_VecGeneral,
                                  [(set i64:$rD, (int_ppc_altivec_vcntmbh
                                        v8i16:$vB, timm:$MP))]>;
  def VCNTMBW : VXForm_RD5_MP_VB5<1602, 14, (outs g8rc:$rD),
                                  (ins vrrc:$vB, u1imm:$MP),
                                  "vcntmbw $rD, $vB, $MP", IIC_VecGeneral,
                                  [(set i64:$rD, (int_ppc_altivec_vcntmbw
                                        v4i32:$vB, timm:$MP))]>;
  def VCNTMBD : VXForm_RD5_MP_VB5<1602, 15, (outs g8rc:$rD),
                                  (ins vrrc:$vB, u1imm:$MP),
                                  "vcntmbd $rD, $vB, $MP", IIC_VecGeneral,
                                  [(set i64:$rD, (int_ppc_altivec_vcntmbd
                                        v2i64:$vB, timm:$MP))]>;
  def VEXTDUBVLX : VAForm_1a<24, (outs vrrc:$vD),
                             (ins vrrc:$vA, vrrc:$vB, gprc:$rC),
                             "vextdubvlx $vD, $vA, $vB, $rC",
                             IIC_VecGeneral,
                             [(set v2i64:$vD,
                                   (int_ppc_altivec_vextdubvlx v16i8:$vA,
                                                               v16i8:$vB,
                                                               i32:$rC))]>;
  def VEXTDUBVRX : VAForm_1a<25, (outs vrrc:$vD),
                             (ins vrrc:$vA, vrrc:$vB, gprc:$rC),
                             "vextdubvrx $vD, $vA, $vB, $rC",
                             IIC_VecGeneral,
                             [(set v2i64:$vD,
                                   (int_ppc_altivec_vextdubvrx v16i8:$vA,
                                                               v16i8:$vB,
                                                               i32:$rC))]>;
  def VEXTDUHVLX : VAForm_1a<26, (outs vrrc:$vD),
                             (ins vrrc:$vA, vrrc:$vB, gprc:$rC),
                             "vextduhvlx $vD, $vA, $vB, $rC",
                             IIC_VecGeneral,
                             [(set v2i64:$vD,
                                   (int_ppc_altivec_vextduhvlx v8i16:$vA,
                                                               v8i16:$vB,
                                                               i32:$rC))]>;
  def VEXTDUHVRX : VAForm_1a<27, (outs vrrc:$vD),
                             (ins vrrc:$vA, vrrc:$vB, gprc:$rC),
                             "vextduhvrx $vD, $vA, $vB, $rC",
                             IIC_VecGeneral,
                             [(set v2i64:$vD,
                                   (int_ppc_altivec_vextduhvrx v8i16:$vA,
                                                               v8i16:$vB,
                                                               i32:$rC))]>;
  def VEXTDUWVLX : VAForm_1a<28, (outs vrrc:$vD),
                             (ins vrrc:$vA, vrrc:$vB, gprc:$rC),
                             "vextduwvlx $vD, $vA, $vB, $rC",
                             IIC_VecGeneral,
                             [(set v2i64:$vD,
                                   (int_ppc_altivec_vextduwvlx v4i32:$vA,
                                                               v4i32:$vB,
                                                               i32:$rC))]>;
  def VEXTDUWVRX : VAForm_1a<29, (outs vrrc:$vD),
                             (ins vrrc:$vA, vrrc:$vB, gprc:$rC),
                             "vextduwvrx $vD, $vA, $vB, $rC",
                             IIC_VecGeneral,
                             [(set v2i64:$vD,
                                   (int_ppc_altivec_vextduwvrx v4i32:$vA,
                                                               v4i32:$vB,
                                                               i32:$rC))]>;
  def VEXTDDVLX : VAForm_1a<30, (outs vrrc:$vD),
                            (ins vrrc:$vA, vrrc:$vB, gprc:$rC),
                            "vextddvlx $vD, $vA, $vB, $rC",
                            IIC_VecGeneral,
                            [(set v2i64:$vD,
                                  (int_ppc_altivec_vextddvlx v2i64:$vA,
                                                             v2i64:$vB,
                                                             i32:$rC))]>;
  def VEXTDDVRX : VAForm_1a<31, (outs vrrc:$vD),
                            (ins vrrc:$vA, vrrc:$vB, gprc:$rC),
                            "vextddvrx $vD, $vA, $vB, $rC",
                            IIC_VecGeneral,
                            [(set v2i64:$vD,
                                  (int_ppc_altivec_vextddvrx v2i64:$vA,
                                                             v2i64:$vB,
                                                             i32:$rC))]>;
   def VPDEPD : VXForm_1<1485, (outs vrrc:$vD), (ins vrrc:$vA, vrrc:$vB),
                         "vpdepd $vD, $vA, $vB", IIC_VecGeneral,
                         [(set v2i64:$vD,
                         (int_ppc_altivec_vpdepd v2i64:$vA, v2i64:$vB))]>;
   def VPEXTD : VXForm_1<1421, (outs vrrc:$vD), (ins vrrc:$vA, vrrc:$vB),
                         "vpextd $vD, $vA, $vB", IIC_VecGeneral,
                         [(set v2i64:$vD,
                         (int_ppc_altivec_vpextd v2i64:$vA, v2i64:$vB))]>;
   def PDEPD : XForm_6<31, 156, (outs g8rc:$rA), (ins g8rc:$rS, g8rc:$rB),
                       "pdepd $rA, $rS, $rB", IIC_IntGeneral,
                       [(set i64:$rA, (int_ppc_pdepd i64:$rS, i64:$rB))]>;
   def PEXTD : XForm_6<31, 188, (outs g8rc:$rA), (ins g8rc:$rS, g8rc:$rB),
                       "pextd $rA, $rS, $rB", IIC_IntGeneral,
                       [(set i64:$rA, (int_ppc_pextd i64:$rS, i64:$rB))]>;
   def VCFUGED : VXForm_1<1357, (outs vrrc:$vD), (ins vrrc:$vA, vrrc:$vB),
                          "vcfuged $vD, $vA, $vB", IIC_VecGeneral,
                          [(set v2i64:$vD,
                          (int_ppc_altivec_vcfuged v2i64:$vA, v2i64:$vB))]>;
   def VGNB : VXForm_RD5_N3_VB5<1228, (outs g8rc:$rD), (ins vrrc:$vB, u3imm:$N),
                                "vgnb $rD, $vB, $N", IIC_VecGeneral,
                                [(set i64:$rD,
                                (int_ppc_altivec_vgnb v1i128:$vB, timm:$N))]>;
   def CFUGED : XForm_6<31, 220, (outs g8rc:$rA), (ins g8rc:$rS, g8rc:$rB),
                        "cfuged $rA, $rS, $rB", IIC_IntGeneral,
                        [(set i64:$rA, (int_ppc_cfuged i64:$rS, i64:$rB))]>;
   def XXEVAL :
     8RR_XX4Form_IMM8_XTAB6<34, 1, (outs vsrc:$XT), (ins vsrc:$XA, vsrc:$XB,
                            vsrc:$XC, u8imm:$IMM),
                            "xxeval $XT, $XA, $XB, $XC, $IMM", IIC_VecGeneral,
                            [(set v2i64:$XT, (int_ppc_vsx_xxeval v2i64:$XA,
                                  v2i64:$XB, v2i64:$XC, timm:$IMM))]>;
   def VCLZDM : VXForm_1<1924, (outs vrrc:$vD), (ins vrrc:$vA, vrrc:$vB),
                         "vclzdm $vD, $vA, $vB", IIC_VecGeneral,
                         [(set v2i64:$vD,
                         (int_ppc_altivec_vclzdm v2i64:$vA, v2i64:$vB))]>;
   def VCTZDM : VXForm_1<1988, (outs vrrc:$vD), (ins vrrc:$vA, vrrc:$vB),
                         "vctzdm $vD, $vA, $vB", IIC_VecGeneral,
                         [(set v2i64:$vD,
                         (int_ppc_altivec_vctzdm v2i64:$vA, v2i64:$vB))]>;
   def CNTLZDM : XForm_6<31, 59, (outs g8rc:$rA), (ins g8rc:$rS, g8rc:$rB),
                         "cntlzdm $rA, $rS, $rB", IIC_IntGeneral,
                         [(set i64:$rA,
                         (int_ppc_cntlzdm i64:$rS, i64:$rB))]>;
   def CNTTZDM : XForm_6<31, 571, (outs g8rc:$rA), (ins g8rc:$rS, g8rc:$rB),
                         "cnttzdm $rA, $rS, $rB", IIC_IntGeneral,
                         [(set i64:$rA,
                         (int_ppc_cnttzdm i64:$rS, i64:$rB))]>;
   def XXGENPCVBM :
     XForm_XT6_IMM5_VB5<60, 916, (outs vsrc:$XT), (ins vrrc:$VRB, s5imm:$IMM),
                        "xxgenpcvbm $XT, $VRB, $IMM", IIC_VecGeneral, []>;
   def XXGENPCVHM :
     XForm_XT6_IMM5_VB5<60, 917, (outs vsrc:$XT), (ins vrrc:$VRB, s5imm:$IMM),
                        "xxgenpcvhm $XT, $VRB, $IMM", IIC_VecGeneral, []>;
   def XXGENPCVWM :
     XForm_XT6_IMM5_VB5<60, 948, (outs vsrc:$XT), (ins vrrc:$VRB, s5imm:$IMM),
                        "xxgenpcvwm $XT, $VRB, $IMM", IIC_VecGeneral, []>;
   def XXGENPCVDM :
     XForm_XT6_IMM5_VB5<60, 949, (outs vsrc:$XT), (ins vrrc:$VRB, s5imm:$IMM),
                        "xxgenpcvdm $XT, $VRB, $IMM", IIC_VecGeneral, []>;
   def VCLRLB : VXForm_1<397, (outs vrrc:$vD), (ins vrrc:$vA, gprc:$rB),
                         "vclrlb $vD, $vA, $rB", IIC_VecGeneral,
                         [(set v16i8:$vD,
                               (int_ppc_altivec_vclrlb v16i8:$vA, i32:$rB))]>;
   def VCLRRB : VXForm_1<461, (outs vrrc:$vD), (ins vrrc:$vA, gprc:$rB),
                         "vclrrb $vD, $vA, $rB", IIC_VecGeneral,
                         [(set v16i8:$vD,
                               (int_ppc_altivec_vclrrb v16i8:$vA, i32:$rB))]>;
  def VMULLD : VXForm_1<457, (outs vrrc:$vD), (ins vrrc:$vA, vrrc:$vB),
                        "vmulld $vD, $vA, $vB", IIC_VecGeneral,
                        [(set v2i64:$vD, (mul v2i64:$vA, v2i64:$vB))]>;
  def VMULHSW : VXForm_1<905, (outs vrrc:$vD), (ins vrrc:$vA, vrrc:$vB),
                         "vmulhsw $vD, $vA, $vB", IIC_VecGeneral,
                         [(set v4i32:$vD, (mulhs v4i32:$vA, v4i32:$vB))]>;
  def VMULHUW : VXForm_1<649, (outs vrrc:$vD), (ins vrrc:$vA, vrrc:$vB),
                         "vmulhuw $vD, $vA, $vB", IIC_VecGeneral,
                         [(set v4i32:$vD, (mulhu v4i32:$vA, v4i32:$vB))]>;
  def VMULHSD : VXForm_1<969, (outs vrrc:$vD), (ins vrrc:$vA, vrrc:$vB),
                         "vmulhsd $vD, $vA, $vB", IIC_VecGeneral,
                         [(set v2i64:$vD, (mulhs v2i64:$vA, v2i64:$vB))]>;
  def VMULHUD : VXForm_1<713, (outs vrrc:$vD), (ins vrrc:$vA, vrrc:$vB),
                         "vmulhud $vD, $vA, $vB", IIC_VecGeneral,
                         [(set v2i64:$vD, (mulhu v2i64:$vA, v2i64:$vB))]>;
  def VMODSW : VXForm_1<1931, (outs vrrc:$vD), (ins vrrc:$vA, vrrc:$vB),
                        "vmodsw $vD, $vA, $vB", IIC_VecGeneral,
                        [(set v4i32:$vD, (srem v4i32:$vA, v4i32:$vB))]>;
  def VMODUW : VXForm_1<1675, (outs vrrc:$vD), (ins vrrc:$vA, vrrc:$vB),
                        "vmoduw $vD, $vA, $vB", IIC_VecGeneral,
                        [(set v4i32:$vD, (urem v4i32:$vA, v4i32:$vB))]>;
  def VMODSD : VXForm_1<1995, (outs vrrc:$vD), (ins vrrc:$vA, vrrc:$vB),
                        "vmodsd $vD, $vA, $vB", IIC_VecGeneral,
                        [(set v2i64:$vD, (srem v2i64:$vA, v2i64:$vB))]>;
  def VMODUD : VXForm_1<1739, (outs vrrc:$vD), (ins vrrc:$vA, vrrc:$vB),
                        "vmodud $vD, $vA, $vB", IIC_VecGeneral,
                        [(set v2i64:$vD, (urem v2i64:$vA, v2i64:$vB))]>;
  def VDIVSW : VXForm_1<395, (outs vrrc:$vD), (ins vrrc:$vA, vrrc:$vB),
                        "vdivsw $vD, $vA, $vB", IIC_VecGeneral,
                        [(set v4i32:$vD, (sdiv v4i32:$vA, v4i32:$vB))]>;
  def VDIVUW : VXForm_1<139, (outs vrrc:$vD), (ins vrrc:$vA, vrrc:$vB),
                        "vdivuw $vD, $vA, $vB", IIC_VecGeneral,
                        [(set v4i32:$vD, (udiv v4i32:$vA, v4i32:$vB))]>;
  def VDIVSD : VXForm_1<459, (outs vrrc:$vD), (ins vrrc:$vA, vrrc:$vB),
                        "vdivsd $vD, $vA, $vB", IIC_VecGeneral,
                        [(set v2i64:$vD, (sdiv v2i64:$vA, v2i64:$vB))]>;
  def VDIVUD : VXForm_1<203, (outs vrrc:$vD), (ins vrrc:$vA, vrrc:$vB),
                        "vdivud $vD, $vA, $vB", IIC_VecGeneral,
                        [(set v2i64:$vD, (udiv v2i64:$vA, v2i64:$vB))]>;
  def VDIVESW : VXForm_1<907, (outs vrrc:$vD), (ins vrrc:$vA, vrrc:$vB),
                         "vdivesw $vD, $vA, $vB", IIC_VecGeneral,
                         [(set v4i32:$vD, (int_ppc_altivec_vdivesw v4i32:$vA,
                               v4i32:$vB))]>;
  def VDIVEUW : VXForm_1<651, (outs vrrc:$vD), (ins vrrc:$vA, vrrc:$vB),
                         "vdiveuw $vD, $vA, $vB", IIC_VecGeneral,
                         [(set v4i32:$vD, (int_ppc_altivec_vdiveuw v4i32:$vA,
                               v4i32:$vB))]>;
  def VDIVESD : VXForm_1<971, (outs vrrc:$vD), (ins vrrc:$vA, vrrc:$vB),
                         "vdivesd $vD, $vA, $vB", IIC_VecGeneral,
                         [(set v2i64:$vD, (int_ppc_altivec_vdivesd v2i64:$vA,
                               v2i64:$vB))]>;
  def VDIVEUD : VXForm_1<715, (outs vrrc:$vD), (ins vrrc:$vA, vrrc:$vB),
                         "vdiveud $vD, $vA, $vB", IIC_VecGeneral,
                         [(set v2i64:$vD, (int_ppc_altivec_vdiveud v2i64:$vA,
                               v2i64:$vB))]>;
  def XVTLSBB : XX2_BF3_XO5_XB6_XO9<60, 2, 475, (outs crrc:$BF), (ins vsrc:$XB),
                                    "xvtlsbb $BF, $XB", IIC_VecGeneral, []>;

  // The XFormMemOp flag for the following 8 instructions is set on
  // the instruction format.
  let mayLoad = 1, mayStore = 0 in {
    def LXVRBX : X_XT6_RA5_RB5<31, 13, "lxvrbx", vsrc, []>;
    def LXVRHX : X_XT6_RA5_RB5<31, 45, "lxvrhx", vsrc, []>;
    def LXVRWX : X_XT6_RA5_RB5<31, 77, "lxvrwx", vsrc, []>;
    def LXVRDX : X_XT6_RA5_RB5<31, 109, "lxvrdx", vsrc, []>;
  }

  let mayLoad = 0, mayStore = 1 in {
    def STXVRBX : X_XS6_RA5_RB5<31, 141, "stxvrbx", vsrc, []>;
    def STXVRHX : X_XS6_RA5_RB5<31, 173, "stxvrhx", vsrc, []>;
    def STXVRWX : X_XS6_RA5_RB5<31, 205, "stxvrwx", vsrc, []>;
    def STXVRDX : X_XS6_RA5_RB5<31, 237, "stxvrdx", vsrc, []>;
  }

  def VMULESD : VXForm_1<968, (outs vrrc:$vD), (ins vrrc:$vA, vrrc:$vB),
                         "vmulesd $vD, $vA, $vB", IIC_VecGeneral,
                         [(set v1i128:$vD, (int_ppc_altivec_vmulesd v2i64:$vA,
                               v2i64:$vB))]>;
  def VMULEUD : VXForm_1<712, (outs vrrc:$vD), (ins vrrc:$vA, vrrc:$vB),
                         "vmuleud $vD, $vA, $vB", IIC_VecGeneral,
                         [(set v1i128:$vD, (int_ppc_altivec_vmuleud v2i64:$vA,
                               v2i64:$vB))]>;
  def VMULOSD : VXForm_1<456, (outs vrrc:$vD), (ins vrrc:$vA, vrrc:$vB),
                         "vmulosd $vD, $vA, $vB", IIC_VecGeneral,
                         [(set v1i128:$vD, (int_ppc_altivec_vmulosd v2i64:$vA,
                               v2i64:$vB))]>;
  def VMULOUD : VXForm_1<200, (outs vrrc:$vD), (ins vrrc:$vA, vrrc:$vB),
                         "vmuloud $vD, $vA, $vB", IIC_VecGeneral,
                         [(set v1i128:$vD, (int_ppc_altivec_vmuloud v2i64:$vA,
                               v2i64:$vB))]>;
  def VMSUMCUD : VAForm_1a<23, (outs vrrc:$vD), (ins vrrc:$vA, vrrc:$vB, vrrc:$vC),
                           "vmsumcud $vD, $vA, $vB, $vC", IIC_VecGeneral,
                           [(set v1i128:$vD, (int_ppc_altivec_vmsumcud
                                 v2i64:$vA, v2i64:$vB, v1i128:$vC))]>;
  def VDIVSQ : VXForm_1<267, (outs vrrc:$vD), (ins vrrc:$vA, vrrc:$vB),
                        "vdivsq $vD, $vA, $vB", IIC_VecGeneral,
                        [(set v1i128:$vD, (sdiv v1i128:$vA, v1i128:$vB))]>;
  def VDIVUQ : VXForm_1<11, (outs vrrc:$vD), (ins vrrc:$vA, vrrc:$vB),
                        "vdivuq $vD, $vA, $vB", IIC_VecGeneral,
                        [(set v1i128:$vD, (udiv v1i128:$vA, v1i128:$vB))]>;
  def VDIVESQ : VXForm_1<779, (outs vrrc:$vD), (ins vrrc:$vA, vrrc:$vB),
                         "vdivesq $vD, $vA, $vB", IIC_VecGeneral,
                         [(set v1i128:$vD, (int_ppc_altivec_vdivesq v1i128:$vA,
			       v1i128:$vB))]>;
  def VDIVEUQ : VXForm_1<523, (outs vrrc:$vD), (ins vrrc:$vA, vrrc:$vB),
                         "vdiveuq $vD, $vA, $vB", IIC_VecGeneral,
                         [(set v1i128:$vD, (int_ppc_altivec_vdiveuq v1i128:$vA,
			       v1i128:$vB))]>;
  def VCMPEQUQ : VCMP <455, "vcmpequq $vD, $vA, $vB" , v1i128>;
  def VCMPGTSQ : VCMP <903, "vcmpgtsq $vD, $vA, $vB" , v1i128>;
  def VCMPGTUQ : VCMP <647, "vcmpgtuq $vD, $vA, $vB" , v1i128>;
  def VCMPEQUQ_rec : VCMP_rec <455, "vcmpequq. $vD, $vA, $vB" , v1i128>;
  def VCMPGTSQ_rec : VCMP_rec <903, "vcmpgtsq. $vD, $vA, $vB" , v1i128>;
  def VCMPGTUQ_rec : VCMP_rec <647, "vcmpgtuq. $vD, $vA, $vB" , v1i128>;
  def VMODSQ : VXForm_1<1803, (outs vrrc:$vD), (ins vrrc:$vA, vrrc:$vB),
                        "vmodsq $vD, $vA, $vB", IIC_VecGeneral,
                        [(set v1i128:$vD, (srem v1i128:$vA, v1i128:$vB))]>;
  def VMODUQ : VXForm_1<1547, (outs vrrc:$vD), (ins vrrc:$vA, vrrc:$vB),
                        "vmoduq $vD, $vA, $vB", IIC_VecGeneral,
                        [(set v1i128:$vD, (urem v1i128:$vA, v1i128:$vB))]>;
  def VEXTSD2Q : VXForm_RD5_XO5_RS5<1538, 27, (outs vrrc:$vD), (ins vrrc:$vB),
                               "vextsd2q $vD, $vB", IIC_VecGeneral,
                               [(set v1i128:$vD, (int_ppc_altivec_vextsd2q v2i64:$vB))]>;
  def VCMPUQ : VXForm_BF3_VAB5<257, (outs crrc:$BF), (ins vrrc:$vA, vrrc:$vB),
                               "vcmpuq $BF, $vA, $vB", IIC_VecGeneral, []>;
  def VCMPSQ : VXForm_BF3_VAB5<321, (outs crrc:$BF), (ins vrrc:$vA, vrrc:$vB),
                               "vcmpsq $BF, $vA, $vB", IIC_VecGeneral, []>;
  def VRLQNM : VX1_VT5_VA5_VB5<325, "vrlqnm",
                               [(set v1i128:$vD,
                                   (int_ppc_altivec_vrlqnm v1i128:$vA,
                                                           v1i128:$vB))]>;
  def VRLQMI : VXForm_1<69, (outs vrrc:$vD),
                        (ins vrrc:$vA, vrrc:$vB, vrrc:$vDi),
                        "vrlqmi $vD, $vA, $vB", IIC_VecFP,
                        [(set v1i128:$vD,
                          (int_ppc_altivec_vrlqmi v1i128:$vA, v1i128:$vB,
                                                  v1i128:$vDi))]>,
                        RegConstraint<"$vDi = $vD">, NoEncode<"$vDi">;
  def VSLQ : VX1_VT5_VA5_VB5<261, "vslq", []>;
  def VSRAQ : VX1_VT5_VA5_VB5<773, "vsraq", []>;
  def VSRQ : VX1_VT5_VA5_VB5<517, "vsrq", []>;
  def VRLQ : VX1_VT5_VA5_VB5<5, "vrlq", []>;
  def XSCVQPUQZ : X_VT5_XO5_VB5<63, 0, 836, "xscvqpuqz", []>;
  def XSCVQPSQZ : X_VT5_XO5_VB5<63, 8, 836, "xscvqpsqz", []>;
  def XSCVUQQP : X_VT5_XO5_VB5<63, 3, 836, "xscvuqqp", []>;
  def XSCVSQQP : X_VT5_XO5_VB5<63, 11, 836, "xscvsqqp", []>;
}

let Predicates = [IsISA3_1, HasVSX] in {
  def XVCVSPBF16 : XX2_XT6_XO5_XB6<60, 17, 475, "xvcvspbf16", vsrc, []>;
  def XVCVBF16SPN : XX2_XT6_XO5_XB6<60, 16, 475, "xvcvbf16spn", vsrc, []>;
}

// Multiclass defining patterns for Set Boolean Extension Reverse Instructions.
// This is analogous to the CRNotPat multiclass but specifically for Power10
// and newer subtargets since the extended forms use Set Boolean instructions.
// The first two anonymous patterns defined are actually a duplicate of those
// in CRNotPat, but it is preferable to define both multiclasses as complete
// ones rather than pulling that small common section out.
multiclass P10ReverseSetBool<dag pattern, dag result> {
  def : Pat<pattern, (crnot result)>;
  def : Pat<(not pattern), result>;

  def : Pat<(i32 (zext pattern)),
            (SETBCR result)>;
  def : Pat<(i64 (zext pattern)),
            (SETBCR8 result)>;

  def : Pat<(i32 (sext pattern)),
            (SETNBCR result)>;
  def : Pat<(i64 (sext pattern)),
            (SETNBCR8 result)>;

  def : Pat<(i32 (anyext pattern)),
            (SETBCR result)>;
  def : Pat<(i64 (anyext pattern)),
            (SETBCR8 result)>;
}

multiclass IntSetP10RevSetBool<SDNode SetCC, ValueType Ty, PatLeaf ZExtTy,
                               ImmLeaf SExtTy, I Cmpi, I Cmpli,
                               I Cmp, I Cmpl> {
  defm : P10ReverseSetBool<(i1 (SetCC Ty:$s1, Ty:$s2, SETUGE)),
                           (EXTRACT_SUBREG (Cmpl $s1, $s2), sub_lt)>;
  defm : P10ReverseSetBool<(i1 (SetCC Ty:$s1, Ty:$s2, SETGE)),
                           (EXTRACT_SUBREG (Cmp $s1, $s2), sub_lt)>;
  defm : P10ReverseSetBool<(i1 (SetCC Ty:$s1, Ty:$s2, SETULE)),
                           (EXTRACT_SUBREG (Cmpl $s1, $s2), sub_gt)>;
  defm : P10ReverseSetBool<(i1 (SetCC Ty:$s1, Ty:$s2, SETLE)),
                           (EXTRACT_SUBREG (Cmp $s1, $s2), sub_gt)>;
  defm : P10ReverseSetBool<(i1 (SetCC Ty:$s1, Ty:$s2, SETNE)),
                           (EXTRACT_SUBREG (Cmp $s1, $s2), sub_eq)>;

  defm : P10ReverseSetBool<(i1 (SetCC Ty:$s1, ZExtTy:$imm, SETUGE)),
                           (EXTRACT_SUBREG (Cmpli $s1, imm:$imm), sub_lt)>;
  defm : P10ReverseSetBool<(i1 (SetCC Ty:$s1, SExtTy:$imm, SETGE)),
                           (EXTRACT_SUBREG (Cmpi $s1, imm:$imm), sub_lt)>;
  defm : P10ReverseSetBool<(i1 (SetCC Ty:$s1, ZExtTy:$imm, SETULE)),
                           (EXTRACT_SUBREG (Cmpli $s1, imm:$imm), sub_gt)>;
  defm : P10ReverseSetBool<(i1 (SetCC Ty:$s1, SExtTy:$imm, SETLE)),
                           (EXTRACT_SUBREG (Cmpi $s1, imm:$imm), sub_gt)>;
  defm : P10ReverseSetBool<(i1 (SetCC Ty:$s1, SExtTy:$imm, SETNE)),
                           (EXTRACT_SUBREG (Cmpi $s1, imm:$imm), sub_eq)>;
  defm : P10ReverseSetBool<(i1 (SetCC Ty:$s1, ZExtTy:$imm, SETNE)),
                           (EXTRACT_SUBREG (Cmpli $s1, imm:$imm), sub_eq)>;
}

multiclass FSetP10RevSetBool<SDNode SetCC, ValueType Ty, I FCmp> {
  defm : P10ReverseSetBool<(i1 (SetCC Ty:$s1, Ty:$s2, SETUGE)),
                           (EXTRACT_SUBREG (FCmp $s1, $s2), sub_lt)>;
  defm : P10ReverseSetBool<(i1 (SetCC Ty:$s1, Ty:$s2, SETGE)),
                           (EXTRACT_SUBREG (FCmp $s1, $s2), sub_lt)>;
  defm : P10ReverseSetBool<(i1 (SetCC Ty:$s1, Ty:$s2, SETULE)),
                           (EXTRACT_SUBREG (FCmp $s1, $s2), sub_gt)>;
  defm : P10ReverseSetBool<(i1 (SetCC Ty:$s1, Ty:$s2, SETLE)),
                           (EXTRACT_SUBREG (FCmp $s1, $s2), sub_gt)>;
  defm : P10ReverseSetBool<(i1 (SetCC Ty:$s1, Ty:$s2, SETUNE)),
                           (EXTRACT_SUBREG (FCmp $s1, $s2), sub_eq)>;
  defm : P10ReverseSetBool<(i1 (SetCC Ty:$s1, Ty:$s2, SETNE)),
                           (EXTRACT_SUBREG (FCmp $s1, $s2), sub_eq)>;
  defm : P10ReverseSetBool<(i1 (SetCC Ty:$s1, Ty:$s2, SETO)),
                           (EXTRACT_SUBREG (FCmp $s1, $s2), sub_un)>;
}

let Predicates = [IsISA3_1] in {
  def : Pat<(i32 (zext i1:$in)),
            (SETBC $in)>;
  def : Pat<(i64 (zext i1:$in)),
            (SETBC8 $in)>;
  def : Pat<(i32 (sext i1:$in)),
            (SETNBC $in)>;
  def : Pat<(i64 (sext i1:$in)),
            (SETNBC8 $in)>;
  def : Pat<(i32 (anyext i1:$in)),
            (SETBC $in)>;
  def : Pat<(i64 (anyext i1:$in)),
            (SETBC8 $in)>;

  // Instantiation of the set boolean reverse patterns for 32-bit integers.
  defm : IntSetP10RevSetBool<setcc, i32, immZExt16, imm32SExt16,
                             CMPWI, CMPLWI, CMPW, CMPLW>;
  defm : P10ReverseSetBool<(i1 (setcc i32:$s1, imm:$imm, SETNE)),
                           (EXTRACT_SUBREG (CMPLWI (XORIS $s1, (HI16 imm:$imm)),
                                           (LO16 imm:$imm)), sub_eq)>;

  // Instantiation of the set boolean reverse patterns for 64-bit integers.
  defm : IntSetP10RevSetBool<setcc, i64, immZExt16, imm64SExt16,
                             CMPDI, CMPLDI, CMPD, CMPLD>;
  defm : P10ReverseSetBool<(i1 (setcc i64:$s1, imm64ZExt32:$imm, SETNE)),
                           (EXTRACT_SUBREG (CMPLDI (XORIS8 $s1, (HI16 imm:$imm)),
                                           (LO16 imm:$imm)), sub_eq)>;
}

// Instantiation of the set boolean reverse patterns for f32, f64, f128.
let Predicates = [IsISA3_1, HasFPU] in {
  defm : FSetP10RevSetBool<setcc, f32, FCMPUS>;
  defm : FSetP10RevSetBool<setcc, f64, FCMPUD>;
  defm : FSetP10RevSetBool<setcc, f128, XSCMPUQP>;
}

//---------------------------- Anonymous Patterns ----------------------------//
let Predicates = [IsISA3_1] in {
  // Exploit the vector multiply high instructions using intrinsics.
  def : Pat<(v4i32 (int_ppc_altivec_vmulhsw v4i32:$vA, v4i32:$vB)),
            (v4i32 (VMULHSW $vA, $vB))>;
  def : Pat<(v4i32 (int_ppc_altivec_vmulhuw v4i32:$vA, v4i32:$vB)),
            (v4i32 (VMULHUW $vA, $vB))>;
  def : Pat<(v2i64 (int_ppc_altivec_vmulhsd v2i64:$vA, v2i64:$vB)),
            (v2i64 (VMULHSD $vA, $vB))>;
  def : Pat<(v2i64 (int_ppc_altivec_vmulhud v2i64:$vA, v2i64:$vB)),
            (v2i64 (VMULHUD $vA, $vB))>;
  def : Pat<(v16i8 (int_ppc_vsx_xxgenpcvbm v16i8:$VRB, imm:$IMM)),
            (v16i8 (COPY_TO_REGCLASS (XXGENPCVBM $VRB, imm:$IMM), VRRC))>;
  def : Pat<(v8i16 (int_ppc_vsx_xxgenpcvhm v8i16:$VRB, imm:$IMM)),
            (v8i16 (COPY_TO_REGCLASS (XXGENPCVHM $VRB, imm:$IMM), VRRC))>;
  def : Pat<(v4i32 (int_ppc_vsx_xxgenpcvwm v4i32:$VRB, imm:$IMM)),
            (v4i32 (COPY_TO_REGCLASS (XXGENPCVWM $VRB, imm:$IMM), VRRC))>;
  def : Pat<(v2i64 (int_ppc_vsx_xxgenpcvdm v2i64:$VRB, imm:$IMM)),
            (v2i64 (COPY_TO_REGCLASS (XXGENPCVDM $VRB, imm:$IMM), VRRC))>;
  def : Pat<(i32 (int_ppc_vsx_xvtlsbb v16i8:$XB, 1)),
            (EXTRACT_SUBREG (XVTLSBB (COPY_TO_REGCLASS $XB, VSRC)), sub_lt)>;
  def : Pat<(i32 (int_ppc_vsx_xvtlsbb v16i8:$XB, 0)),
            (EXTRACT_SUBREG (XVTLSBB (COPY_TO_REGCLASS $XB, VSRC)), sub_eq)>;

  def : Pat <(v1i128 (PPClxvrzx ForceXForm:$src, 8)),
             (v1i128 (COPY_TO_REGCLASS (LXVRBX ForceXForm:$src), VRRC))>;
  def : Pat <(v1i128 (PPClxvrzx ForceXForm:$src, 16)),
             (v1i128 (COPY_TO_REGCLASS (LXVRHX ForceXForm:$src), VRRC))>;
  def : Pat <(v1i128 (PPClxvrzx ForceXForm:$src, 32)),
             (v1i128 (COPY_TO_REGCLASS (LXVRWX ForceXForm:$src), VRRC))>;
  def : Pat <(v1i128 (PPClxvrzx ForceXForm:$src, 64)),
             (v1i128 (COPY_TO_REGCLASS (LXVRDX ForceXForm:$src), VRRC))>;

  def : Pat<(v1i128 (rotl v1i128:$vA, v1i128:$vB)),
            (v1i128 (VRLQ v1i128:$vA, v1i128:$vB))>;

  def : Pat <(v2i64 (PPCxxsplti32dx v2i64:$XT, i32:$XI, i32:$IMM32)),
             (v2i64 (XXSPLTI32DX v2i64:$XT, i32:$XI, i32:$IMM32))>;
}

let Predicates = [IsISA3_1, HasVSX] in {
  def : Pat<(v16i8 (int_ppc_vsx_xvcvspbf16 v16i8:$XA)),
            (COPY_TO_REGCLASS (XVCVSPBF16 RCCp.AToVSRC), VRRC)>;
  def : Pat<(v16i8 (int_ppc_vsx_xvcvbf16spn v16i8:$XA)),
            (COPY_TO_REGCLASS (XVCVBF16SPN RCCp.AToVSRC), VRRC)>;
}

let AddedComplexity = 400, Predicates = [IsISA3_1, IsLittleEndian] in {
  // Store element 0 of a VSX register to memory
  def : Pat<(truncstorei8 (i32 (vector_extract v16i8:$src, 0)), ForceXForm:$dst),
            (STXVRBX (COPY_TO_REGCLASS v16i8:$src, VSRC), ForceXForm:$dst)>;
  def : Pat<(truncstorei16 (i32 (vector_extract v8i16:$src, 0)), ForceXForm:$dst),
            (STXVRHX (COPY_TO_REGCLASS v8i16:$src, VSRC), ForceXForm:$dst)>;
  def : Pat<(store (i32 (extractelt v4i32:$src, 0)), ForceXForm:$dst),
            (STXVRWX $src, ForceXForm:$dst)>;
  def : Pat<(store (f32 (extractelt v4f32:$src, 0)), ForceXForm:$dst),
            (STXVRWX $src, ForceXForm:$dst)>;
  def : Pat<(store (i64 (extractelt v2i64:$src, 0)), ForceXForm:$dst),
            (STXVRDX $src, ForceXForm:$dst)>;
  def : Pat<(store (f64 (extractelt v2f64:$src, 0)), ForceXForm:$dst),
            (STXVRDX $src, ForceXForm:$dst)>;
  // Load element 0 of a VSX register to memory
  def : Pat<(v8i16 (scalar_to_vector (i32 (extloadi16 ForceXForm:$src)))),
            (v8i16 (COPY_TO_REGCLASS (LXVRHX ForceXForm:$src), VSRC))>;
  def : Pat<(v16i8 (scalar_to_vector (i32 (extloadi8 ForceXForm:$src)))),
            (v16i8 (COPY_TO_REGCLASS (LXVRBX ForceXForm:$src), VSRC))>;
 }

// FIXME: The swap is overkill when the shift amount is a constant.
// We should just fix the constant in the DAG.
let AddedComplexity = 400, Predicates = [IsISA3_1, HasVSX] in {
  def : Pat<(v1i128 (shl v1i128:$VRA, v1i128:$VRB)),
            (v1i128 (VSLQ v1i128:$VRA,
                     (XXPERMDI (COPY_TO_REGCLASS $VRB, VSRC),
                               (COPY_TO_REGCLASS $VRB, VSRC), 2)))>;
  def : Pat<(v1i128 (PPCshl v1i128:$VRA, v1i128:$VRB)),
            (v1i128 (VSLQ v1i128:$VRA,
                     (XXPERMDI (COPY_TO_REGCLASS $VRB, VSRC),
                               (COPY_TO_REGCLASS $VRB, VSRC), 2)))>;
  def : Pat<(v1i128 (srl v1i128:$VRA, v1i128:$VRB)),
            (v1i128 (VSRQ v1i128:$VRA,
                     (XXPERMDI (COPY_TO_REGCLASS $VRB, VSRC),
                               (COPY_TO_REGCLASS $VRB, VSRC), 2)))>;
  def : Pat<(v1i128 (PPCsrl v1i128:$VRA, v1i128:$VRB)),
            (v1i128 (VSRQ v1i128:$VRA,
                     (XXPERMDI (COPY_TO_REGCLASS $VRB, VSRC),
                               (COPY_TO_REGCLASS $VRB, VSRC), 2)))>;
  def : Pat<(v1i128 (sra v1i128:$VRA, v1i128:$VRB)),
            (v1i128 (VSRAQ v1i128:$VRA,
                     (XXPERMDI (COPY_TO_REGCLASS $VRB, VSRC),
                               (COPY_TO_REGCLASS $VRB, VSRC), 2)))>;
  def : Pat<(v1i128 (PPCsra v1i128:$VRA, v1i128:$VRB)),
            (v1i128 (VSRAQ v1i128:$VRA,
                     (XXPERMDI (COPY_TO_REGCLASS $VRB, VSRC),
                               (COPY_TO_REGCLASS $VRB, VSRC), 2)))>;
}

class xxevalPattern <dag pattern, bits<8> imm> :
  Pat<(v4i32 pattern), (XXEVAL $vA, $vB, $vC, imm)> {}

let AddedComplexity = 400, Predicates = [PrefixInstrs] in {
 def : Pat<(v4i32 (build_vector i32immNonAllOneNonZero:$A,
                                i32immNonAllOneNonZero:$A,
                                i32immNonAllOneNonZero:$A,
                                i32immNonAllOneNonZero:$A)),
           (v4i32 (XXSPLTIW imm:$A))>;
 def : Pat<(f32 nzFPImmAsi32:$A),
           (COPY_TO_REGCLASS (XXSPLTIDP (getFPAs32BitInt fpimm:$A)),
                             VSFRC)>;
 def : Pat<(f64 nzFPImmAsi32:$A),
           (COPY_TO_REGCLASS (XXSPLTIDP (getFPAs32BitInt fpimm:$A)),
                             VSFRC)>;

// To replace constant pool with XXSPLTI32DX for scalars.
def : Pat<(f32 nzFPImmAsi64:$A),
          (COPY_TO_REGCLASS (XXSPLTI32DX (XXSPLTI32DX(IMPLICIT_DEF), 0,
                                        (getFPAs64BitIntHi $A)),
                                        1, (getFPAs64BitIntLo $A)),
                            VSSRC)>;

def : Pat<(f64 nzFPImmAsi64:$A),
          (COPY_TO_REGCLASS (XXSPLTI32DX (XXSPLTI32DX (IMPLICIT_DEF), 0,
                                        (getFPAs64BitIntHi $A)),
                                        1, (getFPAs64BitIntLo $A)),
                            VSFRC)>;

  // Anonymous patterns for XXEVAL
  // AND
  // and(A, B, C)
  def : xxevalPattern<(and v4i32:$vA, (and v4i32:$vB, v4i32:$vC)), 1>;
  // and(A, xor(B, C))
  def : xxevalPattern<(and v4i32:$vA, (xor v4i32:$vB, v4i32:$vC)), 6>;
  // and(A, or(B, C))
  def : xxevalPattern<(and v4i32:$vA, (or v4i32:$vB, v4i32:$vC)), 7>;
  // and(A, nor(B, C))
  def : xxevalPattern<(and v4i32:$vA, (vnot (or v4i32:$vB, v4i32:$vC))), 8>;
  // and(A, eqv(B, C))
  def : xxevalPattern<(and v4i32:$vA, (vnot (xor v4i32:$vB, v4i32:$vC))), 9>;
  // and(A, nand(B, C))
  def : xxevalPattern<(and v4i32:$vA, (vnot (and v4i32:$vB, v4i32:$vC))), 14>;

  // NAND
  // nand(A, B, C)
  def : xxevalPattern<(vnot (and v4i32:$vA, (and v4i32:$vB, v4i32:$vC))),
                       !sub(255, 1)>;
  // nand(A, xor(B, C))
  def : xxevalPattern<(vnot (and v4i32:$vA, (xor v4i32:$vB, v4i32:$vC))),
                       !sub(255, 6)>;
  // nand(A, or(B, C))
  def : xxevalPattern<(vnot (and v4i32:$vA, (or v4i32:$vB, v4i32:$vC))),
                       !sub(255, 7)>;
  // nand(A, nor(B, C))
  def : xxevalPattern<(or (vnot v4i32:$vA), (or v4i32:$vB, v4i32:$vC)),
                       !sub(255, 8)>;
  // nand(A, eqv(B, C))
  def : xxevalPattern<(or (vnot v4i32:$vA), (xor v4i32:$vB, v4i32:$vC)),
                       !sub(255, 9)>;
  // nand(A, nand(B, C))
  def : xxevalPattern<(or (vnot v4i32:$vA), (and v4i32:$vB, v4i32:$vC)),
                       !sub(255, 14)>;
}

let Predicates = [PrefixInstrs] in {
  def : Pat<(i32 imm34:$imm), (PLI (getImmAs64BitInt imm:$imm))>;
  def : Pat<(i64 imm34:$imm), (PLI8 (getImmAs64BitInt imm:$imm))>;
  def : Pat<(v16i8 (int_ppc_vsx_xxpermx v16i8:$A, v16i8:$B, v16i8:$C, timm:$D)),
            (COPY_TO_REGCLASS (XXPERMX (COPY_TO_REGCLASS $A, VSRC),
                                       (COPY_TO_REGCLASS $B, VSRC),
                                       (COPY_TO_REGCLASS $C, VSRC), $D), VSRC)>;
  def : Pat<(v16i8 (int_ppc_vsx_xxblendvb v16i8:$A, v16i8:$B, v16i8:$C)),
            (COPY_TO_REGCLASS
                   (XXBLENDVB (COPY_TO_REGCLASS $A, VSRC),
                              (COPY_TO_REGCLASS $B, VSRC),
                              (COPY_TO_REGCLASS $C, VSRC)), VSRC)>;
  def : Pat<(v8i16 (int_ppc_vsx_xxblendvh v8i16:$A, v8i16:$B, v8i16:$C)),
            (COPY_TO_REGCLASS
                   (XXBLENDVH (COPY_TO_REGCLASS $A, VSRC),
                              (COPY_TO_REGCLASS $B, VSRC),
                              (COPY_TO_REGCLASS $C, VSRC)), VSRC)>;
  def : Pat<(int_ppc_vsx_xxblendvw v4i32:$A, v4i32:$B, v4i32:$C),
            (XXBLENDVW $A, $B, $C)>;
  def : Pat<(int_ppc_vsx_xxblendvd v2i64:$A, v2i64:$B, v2i64:$C),
            (XXBLENDVD $A, $B, $C)>;
}

def InsertEltShift {
  dag Sub32Left0 = (EXTRACT_SUBREG $rB, sub_32);
  dag Sub32Left1 = (RLWINM (EXTRACT_SUBREG $rB, sub_32), 1, 0, 30);
  dag Sub32Left2 = (RLWINM (EXTRACT_SUBREG $rB, sub_32), 2, 0, 29);
  dag Left3 = (RLWINM8 $rB, 3, 0, 28);
}

let Predicates = [IsISA3_1, HasVSX, IsLittleEndian] in {
  // Indexed vector insert element
  def : Pat<(v16i8 (PPCvecinsertelt v16i8:$vDi, i32:$rA, i64:$rB)),
            (VINSBRX $vDi, InsertEltShift.Sub32Left0, $rA)>;
  def : Pat<(v8i16 (PPCvecinsertelt v8i16:$vDi, i32:$rA, i64:$rB)),
            (VINSHRX $vDi, InsertEltShift.Sub32Left1, $rA)>;
  def : Pat<(v4i32 (PPCvecinsertelt v4i32:$vDi, i32:$rA, i64:$rB)),
            (VINSWRX $vDi, InsertEltShift.Sub32Left2, $rA)>;
  def : Pat<(v2i64 (PPCvecinsertelt v2i64:$vDi, i64:$rA, i64:$rB)),
            (VINSDRX $vDi, InsertEltShift.Left3, $rA)>;

  def : Pat<(v4f32 (PPCvecinsertelt v4f32:$vDi,  f32:$A, i64:$rB)),
            (VINSWRX $vDi, InsertEltShift.Sub32Left2, Bitcast.FltToInt)>;
  def : Pat<(v4f32 (PPCvecinsertelt v4f32:$vDi, (f32 (load iaddr:$rA)), i64:$rB)),
            (VINSWRX $vDi, InsertEltShift.Sub32Left2, (LWZ memri:$rA))>;
  def : Pat<(v4f32 (PPCvecinsertelt v4f32:$vDi, (f32 (load iaddrX34:$rA)), i64:$rB)),
            (VINSWRX $vDi, InsertEltShift.Sub32Left2, (PLWZ memri34:$rA))>;
  def : Pat<(v4f32 (PPCvecinsertelt v4f32:$vDi, (f32 (load xaddr:$rA)), i64:$rB)),
            (VINSWRX $vDi, InsertEltShift.Sub32Left2, (LWZX memrr:$rA))>;

  def : Pat<(v2f64 (PPCvecinsertelt v2f64:$vDi,  f64:$A, i64:$rB)),
            (VINSDRX $vDi, InsertEltShift.Left3, Bitcast.DblToLong)>;
  def : Pat<(v2f64 (PPCvecinsertelt v2f64:$vDi, (f64 (load iaddrX4:$rA)), i64:$rB)),
            (VINSDRX $vDi, InsertEltShift.Left3, (LD memrix:$rA))>;
  def : Pat<(v2f64 (PPCvecinsertelt v2f64:$vDi, (f64 (load iaddrX34:$rA)), i64:$rB)),
            (VINSDRX $vDi, InsertEltShift.Left3, (PLD memri34:$rA))>;
  def : Pat<(v2f64 (PPCvecinsertelt v2f64:$vDi, (f64 (load xaddrX4:$rA)), i64:$rB)),
            (VINSDRX $vDi, InsertEltShift.Left3, (LDX memrr:$rA))>;

  // Immediate vector insert element
  foreach i = [0, 1, 2, 3] in {
    def : Pat<(v4i32 (PPCvecinsertelt v4i32:$vDi, i32:$rA, (i64 i))),
              (VINSW $vDi, !mul(!sub(3, i), 4), $rA)>;
    def : Pat<(v4f32 (PPCvecinsertelt v4f32:$vDi, (f32 (load iaddr:$rA)), (i64 i))),
              (VINSW $vDi, !mul(!sub(3, i), 4), (LWZ memri:$rA))>;
    def : Pat<(v4f32 (PPCvecinsertelt v4f32:$vDi, (f32 (load iaddrX34:$rA)), (i64 i))),
              (VINSW $vDi, !mul(!sub(3, i), 4), (PLWZ memri34:$rA))>;
    def : Pat<(v4f32 (PPCvecinsertelt v4f32:$vDi, (f32 (load xaddr:$rA)), (i64 i))),
              (VINSW $vDi, !mul(!sub(3, i), 4), (LWZX memrr:$rA))>;
  }
  foreach i = [0, 1] in
    def : Pat<(v2i64 (PPCvecinsertelt v2i64:$vDi, i64:$rA, (i64 i))),
              (VINSD $vDi, !mul(!sub(1, i), 8), $rA)>;
}

let Predicates = [IsISA3_1, HasVSX, IsBigEndian, IsPPC32] in {
  // Indexed vector insert element
  def : Pat<(v16i8 (PPCvecinsertelt v16i8:$vDi, i32:$rA, i32:$rB)),
            (VINSBLX $vDi, $rB, $rA)>;
  def : Pat<(v8i16 (PPCvecinsertelt v8i16:$vDi, i32:$rA, i32:$rB)),
            (VINSHLX $vDi, $rB, $rA)>;
  def : Pat<(v4i32 (PPCvecinsertelt v4i32:$vDi, i32:$rA, i32:$rB)),
            (VINSWLX $vDi, $rB, $rA)>;

  def : Pat<(v4f32 (PPCvecinsertelt v4f32:$vDi,  f32:$A, i32:$rB)),
            (VINSWLX $vDi, $rB, Bitcast.FltToInt)>;
  def : Pat<(v4f32 (PPCvecinsertelt v4f32:$vDi, (f32 (load iaddr:$rA)),
                                    i32:$rB)),
            (VINSWLX $vDi, $rB, (LWZ memri:$rA))>;
  def : Pat<(v4f32 (PPCvecinsertelt v4f32:$vDi, (f32 (load iaddrX34:$rA)),
                                    i32:$rB)),
            (VINSWLX $vDi, $rB, (PLWZ memri34:$rA))>;
  def : Pat<(v4f32 (PPCvecinsertelt v4f32:$vDi, (f32 (load xaddr:$rA)),
                                    i32:$rB)),
            (VINSWLX $vDi, $rB, (LWZX memrr:$rA))>;

  // Immediate vector insert element
  foreach i = [0, 1, 2, 3] in {
    def : Pat<(v4i32 (PPCvecinsertelt v4i32:$vDi, i32:$rA, (i32 i))),
              (VINSW $vDi, !mul(i, 4), $rA)>;
    def : Pat<(v4f32 (PPCvecinsertelt v4f32:$vDi, (f32 (load iaddr:$rA)),
                                     (i32 i))),
              (VINSW $vDi, !mul(i, 4), (LWZ memri:$rA))>;
    def : Pat<(v4f32 (PPCvecinsertelt v4f32:$vDi, (f32 (load iaddrX34:$rA)),
                                     (i32 i))),
              (VINSW $vDi, !mul(i, 4), (PLWZ memri34:$rA))>;
    def : Pat<(v4f32 (PPCvecinsertelt v4f32:$vDi, (f32 (load xaddr:$rA)),
                                     (i32 i))),
              (VINSW $vDi, !mul(i, 4), (LWZX memrr:$rA))>;
  }
}

let Predicates = [IsISA3_1, HasVSX, IsBigEndian, IsPPC64] in {
  // Indexed vector insert element
  def : Pat<(v16i8 (PPCvecinsertelt v16i8:$vDi, i32:$rA, i64:$rB)),
            (VINSBLX $vDi, InsertEltShift.Sub32Left0, $rA)>;
  def : Pat<(v8i16 (PPCvecinsertelt v8i16:$vDi, i32:$rA, i64:$rB)),
            (VINSHLX $vDi, InsertEltShift.Sub32Left1, $rA)>;
  def : Pat<(v4i32 (PPCvecinsertelt v4i32:$vDi, i32:$rA, i64:$rB)),
            (VINSWLX $vDi, InsertEltShift.Sub32Left2, $rA)>;
  def : Pat<(v2i64 (PPCvecinsertelt v2i64:$vDi, i64:$rA, i64:$rB)),
            (VINSDLX $vDi, InsertEltShift.Left3, $rA)>;

  def : Pat<(v4f32 (PPCvecinsertelt v4f32:$vDi,  f32:$A, i64:$rB)),
            (VINSWLX $vDi, InsertEltShift.Sub32Left2, Bitcast.FltToInt)>;
  def : Pat<(v4f32 (PPCvecinsertelt v4f32:$vDi, (f32 (load iaddr:$rA)), i64:$rB)),
            (VINSWLX $vDi, InsertEltShift.Sub32Left2, (LWZ memri:$rA))>;
  def : Pat<(v4f32 (PPCvecinsertelt v4f32:$vDi, (f32 (load iaddrX34:$rA)), i64:$rB)),
            (VINSWLX $vDi, InsertEltShift.Sub32Left2, (PLWZ memri34:$rA))>;
  def : Pat<(v4f32 (PPCvecinsertelt v4f32:$vDi, (f32 (load xaddr:$rA)), i64:$rB)),
            (VINSWLX $vDi, InsertEltShift.Sub32Left2, (LWZX memrr:$rA))>;

  def : Pat<(v2f64 (PPCvecinsertelt v2f64:$vDi,  f64:$A, i64:$rB)),
            (VINSDLX $vDi, InsertEltShift.Left3, Bitcast.DblToLong)>;
  def : Pat<(v2f64 (PPCvecinsertelt v2f64:$vDi, (f64 (load iaddrX4:$rA)), i64:$rB)),
            (VINSDLX $vDi, InsertEltShift.Left3, (LD memrix:$rA))>;
  def : Pat<(v2f64 (PPCvecinsertelt v2f64:$vDi, (f64 (load iaddrX34:$rA)), i64:$rB)),
            (VINSDLX $vDi, InsertEltShift.Left3, (PLD memri34:$rA))>;
  def : Pat<(v2f64 (PPCvecinsertelt v2f64:$vDi, (f64 (load xaddrX4:$rA)), i64:$rB)),
            (VINSDLX $vDi, InsertEltShift.Left3, (LDX memrr:$rA))>;

  // Immediate vector insert element
  foreach i = [0, 1, 2, 3] in {
    def : Pat<(v4i32 (PPCvecinsertelt v4i32:$vDi, i32:$rA, (i64 i))),
              (VINSW $vDi, !mul(i, 4), $rA)>;
    def : Pat<(v4f32 (PPCvecinsertelt v4f32:$vDi, (f32 (load iaddr:$rA)), (i64 i))),
              (VINSW $vDi, !mul(i, 4), (LWZ memri:$rA))>;
    def : Pat<(v4f32 (PPCvecinsertelt v4f32:$vDi, (f32 (load iaddrX34:$rA)), (i64 i))),
              (VINSW $vDi, !mul(i, 4), (PLWZ memri34:$rA))>;
    def : Pat<(v4f32 (PPCvecinsertelt v4f32:$vDi, (f32 (load xaddr:$rA)), (i64 i))),
              (VINSW $vDi, !mul(i, 4), (LWZX memrr:$rA))>;
  }
  foreach i = [0, 1] in
    def : Pat<(v2i64 (PPCvecinsertelt v2i64:$vDi, i64:$rA, (i64 i))),
              (VINSD $vDi, !mul(i, 8), $rA)>;
}
