; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -gvn -S | FileCheck %s

; This test checks that we don't hang trying to split a critical edge in loadpre
; when the control flow uses a callbr instruction.

%struct.pluto = type <{ i8, i8 }>

define void @widget(%struct.pluto** %tmp1) {
; CHECK-LABEL: @widget(
; CHECK-NEXT:  bb:
; CHECK-NEXT:    callbr void asm sideeffect "", "i,i"(i8* blockaddress(@widget, [[BB5:%.*]]), i8* blockaddress(@widget, [[BB8:%.*]]))
; CHECK-NEXT:    to label [[BB4:%.*]] [label [[BB5]], label %bb8]
; CHECK:       bb4:
; CHECK-NEXT:    br label [[BB5]]
; CHECK:       bb5:
; CHECK-NEXT:    [[TMP6:%.*]] = load %struct.pluto*, %struct.pluto** [[TMP1:%.*]]
; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr inbounds [[STRUCT_PLUTO:%.*]], %struct.pluto* [[TMP6]], i64 0, i32 1
; CHECK-NEXT:    br label [[BB8]]
; CHECK:       bb8:
; CHECK-NEXT:    [[TMP9:%.*]] = phi i8* [ [[TMP7]], [[BB5]] ], [ null, [[BB:%.*]] ]
; CHECK-NEXT:    [[TMP10:%.*]] = load %struct.pluto*, %struct.pluto** [[TMP1]]
; CHECK-NEXT:    [[TMP11:%.*]] = getelementptr inbounds [[STRUCT_PLUTO]], %struct.pluto* [[TMP10]], i64 0, i32 0
; CHECK-NEXT:    [[TMP12:%.*]] = load i8, i8* [[TMP11]]
; CHECK-NEXT:    tail call void @spam(i8* [[TMP9]], i8 [[TMP12]])
; CHECK-NEXT:    ret void
;
bb:
  callbr void asm sideeffect "", "i,i"(i8* blockaddress(@widget, %bb5), i8* blockaddress(@widget, %bb8))
  to label %bb4 [label %bb5, label %bb8]

bb4:                                              ; preds = %bb
  br label %bb5

bb5:                                              ; preds = %bb4, %bb
  %tmp6 = load %struct.pluto*, %struct.pluto** %tmp1
  %tmp7 = getelementptr inbounds %struct.pluto, %struct.pluto* %tmp6, i64 0, i32 1
  br label %bb8

bb8:                                              ; preds = %bb5, %bb
  %tmp9 = phi i8* [ %tmp7, %bb5 ], [ null, %bb ]
  %tmp10 = load %struct.pluto*, %struct.pluto** %tmp1
  %tmp11 = getelementptr inbounds %struct.pluto, %struct.pluto* %tmp10, i64 0, i32 0
  %tmp12 = load i8, i8* %tmp11
  tail call void @spam(i8* %tmp9, i8 %tmp12)
  ret void
}

declare void @spam(i8*, i8)
