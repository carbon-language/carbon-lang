; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -passes=gvn -enable-split-backedge-in-load-pre -S %s | FileCheck %s

; Test case for PR31651.

target datalayout = "p:16:16"

declare void @use(i16) readonly

define i16 @test_PR31651(ptr %ub.16) {
; CHECK-LABEL: @test_PR31651(
; CHECK-NEXT:    br label [[LOOP_1_HEADER:%.*]]
; CHECK:       loop.1.header:
; CHECK-NEXT:    [[IV_1:%.*]] = phi i16 [ 0, [[TMP0:%.*]] ], [ [[IV_1_NEXT:%.*]], [[LOOP_1_LATCH:%.*]] ]
; CHECK-NEXT:    [[CMP_1:%.*]] = icmp eq i16 [[IV_1]], 0
; CHECK-NEXT:    br i1 [[CMP_1]], label [[CONT_1:%.*]], label [[THEN_1:%.*]]
; CHECK:       then.1:
; CHECK-NEXT:    [[_TMP18:%.*]] = add i16 [[IV_1]], -1
; CHECK-NEXT:    [[GEP_1:%.*]] = getelementptr [4 x i16], ptr [[UB_16:%.*]], i16 1, i16 [[_TMP18]]
; CHECK-NEXT:    [[L_1:%.*]] = load i16, ptr [[GEP_1]], align 2
; CHECK-NEXT:    br label [[CONT_1]]
; CHECK:       cont.1:
; CHECK-NEXT:    [[IV_1_SINK:%.*]] = phi i16 [ [[IV_1]], [[THEN_1]] ], [ 0, [[LOOP_1_HEADER]] ]
; CHECK-NEXT:    [[SINK:%.*]] = phi i16 [ [[L_1]], [[THEN_1]] ], [ 10, [[LOOP_1_HEADER]] ]
; CHECK-NEXT:    [[GEP_2:%.*]] = getelementptr [4 x i16], ptr [[UB_16]], i16 1, i16 [[IV_1_SINK]]
; CHECK-NEXT:    br i1 [[CMP_1]], label [[THEN_2:%.*]], label [[ELSE_2:%.*]]
; CHECK:       then.2:
; CHECK-NEXT:    [[GEP_3:%.*]] = getelementptr [4 x i16], ptr [[UB_16]], i16 1, i16 0
; CHECK-NEXT:    [[L_2:%.*]] = load i16, ptr [[GEP_3]], align 2
; CHECK-NEXT:    call void @use(i16 [[L_2]])
; CHECK-NEXT:    br label [[LOOP_1_LATCH]]
; CHECK:       else.2:
; CHECK-NEXT:    [[GEP_4:%.*]] = getelementptr [4 x i16], ptr [[UB_16]], i16 1, i16 [[IV_1]]
; CHECK-NEXT:    [[L_3:%.*]] = load i16, ptr [[GEP_4]], align 2
; CHECK-NEXT:    call void @use(i16 [[L_3]])
; CHECK-NEXT:    br label [[LOOP_1_LATCH]]
; CHECK:       loop.1.latch:
; CHECK-NEXT:    [[L_42:%.*]] = phi i16 [ [[L_3]], [[ELSE_2]] ], [ [[L_2]], [[THEN_2]] ]
; CHECK-NEXT:    [[IV_1_NEXT]] = add i16 [[IV_1]], 1
; CHECK-NEXT:    [[CMP_3:%.*]] = icmp slt i16 [[IV_1_NEXT]], 2
; CHECK-NEXT:    br i1 [[CMP_3]], label [[LOOP_1_HEADER]], label [[LOOP_2:%.*]]
; CHECK:       loop.2:
; CHECK-NEXT:    [[L_4:%.*]] = phi i16 [ [[L_42]], [[LOOP_1_LATCH]] ], [ [[L_4_PRE:%.*]], [[LOOP_2_LOOP_2_CRIT_EDGE:%.*]] ]
; CHECK-NEXT:    [[IV_2:%.*]] = phi i16 [ 0, [[LOOP_1_LATCH]] ], [ [[IV_2_NEXT:%.*]], [[LOOP_2_LOOP_2_CRIT_EDGE]] ]
; CHECK-NEXT:    [[SUM:%.*]] = phi i16 [ 0, [[LOOP_1_LATCH]] ], [ [[SUM_NEXT:%.*]], [[LOOP_2_LOOP_2_CRIT_EDGE]] ]
; CHECK-NEXT:    [[GEP_5:%.*]] = getelementptr [4 x i16], ptr [[UB_16]], i16 1, i16 [[IV_2]]
; CHECK-NEXT:    [[SUM_NEXT]] = add i16 [[SUM]], [[L_4]]
; CHECK-NEXT:    [[IV_2_NEXT]] = add i16 [[IV_2]], 1
; CHECK-NEXT:    [[CMP_4:%.*]] = icmp slt i16 [[IV_2_NEXT]], 2
; CHECK-NEXT:    br i1 [[CMP_4]], label [[LOOP_2_LOOP_2_CRIT_EDGE]], label [[EXIT:%.*]]
; CHECK:       loop.2.loop.2_crit_edge:
; CHECK-NEXT:    [[GEP_5_PHI_TRANS_INSERT:%.*]] = getelementptr [4 x i16], ptr [[UB_16]], i16 1, i16 [[IV_2_NEXT]]
; CHECK-NEXT:    [[L_4_PRE]] = load i16, ptr [[GEP_5_PHI_TRANS_INSERT]], align 2
; CHECK-NEXT:    br label [[LOOP_2]]
; CHECK:       exit:
; CHECK-NEXT:    ret i16 [[SUM_NEXT]]
;
  br label %loop.1.header

loop.1.header:
  %iv.1 = phi i16 [ 0, %0 ], [ %iv.1.next, %loop.1.latch ]
  %cmp.1 = icmp eq i16 %iv.1, 0
  br i1 %cmp.1 , label %cont.1, label %then.1

then.1:
  %_tmp18 = add i16 %iv.1, -1
  %gep.1 = getelementptr [4 x i16], ptr %ub.16, i16 1, i16 %_tmp18
  %l.1 = load i16, i16* %gep.1, align 2
  br label %cont.1

cont.1:
  %iv.1.sink = phi i16 [ %iv.1, %then.1 ], [ 0, %loop.1.header ]
  %sink = phi i16 [ %l.1, %then.1 ], [ 10, %loop.1.header ]
  %gep.2 = getelementptr [4 x i16], ptr %ub.16, i16 1, i16 %iv.1.sink
  %cmp.2 = icmp eq i16 %iv.1, 0
  br i1 %cmp.2, label %then.2, label %else.2

then.2:
  %gep.3 = getelementptr [4 x i16], ptr %ub.16, i16 1, i16 %iv.1
  %l.2 = load i16, ptr %gep.3, align 2
  call void @use(i16 %l.2)
  br label %loop.1.latch

else.2:
  %gep.4 = getelementptr [4 x i16], ptr %ub.16, i16 1, i16 %iv.1
  %l.3 = load i16, ptr %gep.4, align 2
  call void @use(i16 %l.3)
  br label %loop.1.latch

loop.1.latch:
  %iv.1.next = add i16 %iv.1, 1
  %cmp.3 = icmp slt i16 %iv.1.next, 2
  br i1 %cmp.3, label %loop.1.header, label %loop.2

loop.2:
  %iv.2 = phi i16 [ 0, %loop.1.latch ], [ %iv.2.next, %loop.2 ]
  %sum = phi i16 [ 0, %loop.1.latch ], [ %sum.next, %loop.2 ]
  %gep.5 = getelementptr [4 x i16], ptr %ub.16, i16 1, i16 %iv.2
  %l.4 = load i16, ptr %gep.5, align 2
  %sum.next = add i16 %sum, %l.4
  %iv.2.next = add i16 %iv.2, 1
  %cmp.4 = icmp slt i16 %iv.2.next, 2
  br i1 %cmp.4, label %loop.2, label %exit

exit:
  ret i16 %sum.next

  uselistorder ptr %ub.16, { 4, 3, 2, 0, 1 }
}
