; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -passes=print-predicateinfo < %s 2>&1 | FileCheck %s
; Don't insert predicate info for conditions with a single target.
@a = global i32 6, align 4
@c = global i32 -1, align 4
@e = common global i32 0, align 4
@.str = private unnamed_addr constant [4 x i8] c"%d\0A\00", align 1
@d = common global i32 0, align 4
@b = common global [6 x i32] zeroinitializer, align 16

; Function Attrs: nounwind ssp uwtable
define i32 @main() {
; CHECK-LABEL: @main(
; CHECK-NEXT:    store i32 6, i32* @e, align 4
; CHECK-NEXT:    br label [[TMP1:%.*]]
; CHECK:         [[TMP2:%.*]] = load i32, i32* @d, align 4
; CHECK-NEXT:    [[TMP3:%.*]] = sext i32 [[TMP2]] to i64
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr inbounds [6 x i32], [6 x i32]* @b, i64 0, i64 [[TMP3]]
; CHECK-NEXT:    [[TMP5:%.*]] = load i32, i32* [[TMP4]], align 4
; CHECK-NEXT:    [[TMP6:%.*]] = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 [[TMP5]])
; CHECK-NEXT:    [[TMP7:%.*]] = load i32, i32* @a, align 4
; CHECK-NEXT:    [[TMP8:%.*]] = icmp eq i32 [[TMP7]], 0
; CHECK-NEXT:    br i1 [[TMP8]], label %thread-pre-split, label [[TMP9:%.*]]
; CHECK:         [[TMP10:%.*]] = load i32, i32* @e, align 4
; CHECK-NEXT:    [[TMP11:%.*]] = icmp eq i32 [[TMP10]], 0
; CHECK-NEXT:    br i1 [[TMP11]], label [[TMP12:%.*]], label [[TMP12]]
; CHECK:       thread-pre-split:
; CHECK-NEXT:    [[DOTPR:%.*]] = load i32, i32* @e, align 4
; CHECK-NEXT:    br label [[TMP12]]
; CHECK:         [[TMP13:%.*]] = phi i32 [ [[DOTPR]], %thread-pre-split ], [ [[TMP10]], [[TMP9]] ], [ [[TMP10]], [[TMP9]] ]
; CHECK-NEXT:    [[TMP14:%.*]] = icmp ne i32 [[TMP13]], 0
; CHECK-NEXT:    br i1 [[TMP14]], label [[TMP15:%.*]], label [[TMP15]]
; CHECK:         br i1 [[TMP14]], label [[TMP16:%.*]], label [[TMP17:%.*]]
; CHECK:         br label [[TMP17]]
; CHECK:         [[DOT0:%.*]] = phi i32 [ 1, [[TMP16]] ], [ -1, [[TMP15]] ]
; CHECK-NEXT:    [[TMP18:%.*]] = and i32 [[DOT0]], 8693
; CHECK-NEXT:    [[TMP19:%.*]] = load i32, i32* @c, align 4
; CHECK-NEXT:    [[TMP20:%.*]] = xor i32 [[TMP18]], [[TMP19]]
; CHECK-NEXT:    [[TMP21:%.*]] = xor i32 [[TMP20]], -1
; CHECK-NEXT:    store i32 [[TMP21]], i32* @d, align 4
; CHECK-NEXT:    [[TMP22:%.*]] = icmp slt i32 [[TMP20]], -2
; CHECK-NEXT:    br i1 [[TMP22]], label [[TMP1]], label [[TMP23:%.*]]
; CHECK:         ret i32 0
;
  store i32 6, i32* @e, align 4
  br label %1

; <label>:1:                                      ; preds = %17, %0
  %2 = load i32, i32* @d, align 4
  %3 = sext i32 %2 to i64
  %4 = getelementptr inbounds [6 x i32], [6 x i32]* @b, i64 0, i64 %3
  %5 = load i32, i32* %4, align 4
  %6 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 %5) #2
  %7 = load i32, i32* @a, align 4
  %8 = icmp eq i32 %7, 0
  br i1 %8, label %thread-pre-split, label %9

; <label>:9:                                      ; preds = %1
  %10 = load i32, i32* @e, align 4
  %11 = icmp eq i32 %10, 0
  br i1 %11, label %12, label %12

thread-pre-split:                                 ; preds = %1
  %.pr = load i32, i32* @e, align 4
  br label %12

; <label>:12:                                     ; preds = %thread-pre-split, %9, %9
  %13 = phi i32 [ %.pr, %thread-pre-split ], [ %10, %9 ], [ %10, %9 ]
  %14 = icmp ne i32 %13, 0
  br i1 %14, label %15, label %15

; <label>:15:                                     ; preds = %12, %12
  br i1 %14, label %16, label %17

; <label>:16:                                     ; preds = %15
  br label %17

; <label>:17:                                     ; preds = %16, %15
  %.0 = phi i32 [ 1, %16 ], [ -1, %15 ]
  %18 = and i32 %.0, 8693
  %19 = load i32, i32* @c, align 4
  %20 = xor i32 %18, %19
  %21 = xor i32 %20, -1
  store i32 %21, i32* @d, align 4
  %22 = icmp slt i32 %20, -2
  br i1 %22, label %1, label %23

; <label>:23:                                     ; preds = %17
  ret i32 0
}

declare i32 @printf(i8*, ...)

