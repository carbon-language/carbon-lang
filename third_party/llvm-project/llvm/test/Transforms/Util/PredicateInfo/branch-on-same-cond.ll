; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -S -passes=print-predicateinfo < %s 2>&1 >/dev/null | FileCheck %s

; FIXME:  RenamedOp should be %cmp or %x in all cases here,
; which is the value used in the condition.
define i32 @test(i32 %x) {
; CHECK-LABEL: @test(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[BB1:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[X:%.*]], 0
; CHECK: RenamedOp: [[CMP]]
; CHECK:         [[CMP_0:%.*]] = call i1 @llvm.ssa.copy.{{.*}}(i1 [[CMP]])
; CHECK: RenamedOp: [[X]]
; CHECK:         [[X_0:%.*]] = call i32 @llvm.ssa.copy.{{.*}}(i32 [[X]])
; CHECK-NEXT:    br i1 [[CMP]], label [[BB2:%.*]], label [[EXIT1:%.*]]
; CHECK:       bb2:
; CHECK: RenamedOp: [[CMP_0]]
; CHECK:         [[CMP_0_1:%.*]] = call i1 @llvm.ssa.copy.{{.*}}(i1 [[CMP_0]])
; CHECK: RenamedOp: [[X]]
; CHECK:         [[X_0_1:%.*]] = call i32 @llvm.ssa.copy.{{.*}}(i32 [[X_0]])
; CHECK: RenamedOp: [[X_0]]
; CHECK:         [[X_0_4:%.*]] = call i32 @llvm.ssa.copy.{{.*}}(i32 [[X_0]])
; CHECK-NEXT:    br i1 [[CMP_0]], label [[BB3:%.*]], label [[EXIT2:%.*]]
; CHECK:       bb3:
; CHECK: RenamedOp: [[X]]
; CHECK:         [[X_0_1_2:%.*]] = call i32 @llvm.ssa.copy.{{.*}}(i32 [[X_0_1]])
; CHECK: RenamedOp: [[X_0_1]]
; CHECK:         [[X_0_1_3:%.*]] = call i32 @llvm.ssa.copy.{{.*}}(i32 [[X_0_1]])
; CHECK-NEXT:    br i1 [[CMP_0_1]], label [[EXIT3:%.*]], label [[EXIT4:%.*]]
; CHECK:       exit1:
; CHECK-NEXT:    ret i32 0
; CHECK:       exit2:
; CHECK-NEXT:    ret i32 [[X_0_4]]
; CHECK:       exit3:
; CHECK-NEXT:    ret i32 [[X_0_1_2]]
; CHECK:       exit4:
; CHECK-NEXT:    ret i32 [[X_0_1_3]]
;
entry:
  br label %bb1

bb1:
  %cmp = icmp eq i32 %x, 0
  br i1 %cmp, label %bb2, label %exit1

bb2:
  br i1 %cmp, label %bb3, label %exit2

bb3:
  br i1 %cmp, label %exit3, label %exit4

exit1:
  ret i32 0

exit2:
  ret i32 %x

exit3:
  ret i32 %x

exit4:
  ret i32 %x
}
