; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes=instsimplify -S | FileCheck %s

declare half @llvm.amdgcn.fract.f16(half)
declare float @llvm.amdgcn.fract.f32(float)
declare double @llvm.amdgcn.fract.f64(double)

define void @test_f16(ptr %p) {
; CHECK-LABEL: @test_f16(
; CHECK-NEXT:    store volatile half 0xH0000, ptr [[P:%.*]]
; CHECK-NEXT:    store volatile half 0xH0000, ptr [[P]]
; CHECK-NEXT:    store volatile half 0xH0000, ptr [[P]]
; CHECK-NEXT:    store volatile half 0xH0000, ptr [[P]]
; CHECK-NEXT:    store volatile half 0xH3400, ptr [[P]]
; CHECK-NEXT:    store volatile half 0xH3B00, ptr [[P]]
; CHECK-NEXT:    store volatile half 0xH0400, ptr [[P]]
; CHECK-NEXT:    store volatile half 0xH3BFF, ptr [[P]]
; CHECK-NEXT:    store volatile half 0xH7E00, ptr [[P]]
; CHECK-NEXT:    store volatile half 0xH7E00, ptr [[P]]
; CHECK-NEXT:    store volatile half 0xH7E00, ptr [[P]]
; CHECK-NEXT:    ret void
;
  %p0 = call half @llvm.amdgcn.fract.f16(half +0.0)
  store volatile half %p0, ptr %p
  %n0 = call half @llvm.amdgcn.fract.f16(half -0.0)
  store volatile half %n0, ptr %p
  %p1 = call half @llvm.amdgcn.fract.f16(half +1.0)
  store volatile half %p1, ptr %p
  %n1 = call half @llvm.amdgcn.fract.f16(half -1.0)
  store volatile half %n1, ptr %p
  %p225 = call half @llvm.amdgcn.fract.f16(half +2.25)
  store volatile half %p225, ptr %p
  %n6125 = call half @llvm.amdgcn.fract.f16(half -6.125)
  store volatile half %n6125, ptr %p
  %ptiny = call half @llvm.amdgcn.fract.f16(half 0xH0400) ; +min normal
  store volatile half %ptiny, ptr %p
  %ntiny = call half @llvm.amdgcn.fract.f16(half 0xH8400) ; -min normal
  store volatile half %ntiny, ptr %p
  %pinf = call half @llvm.amdgcn.fract.f16(half 0xH7C00) ; +inf
  store volatile half %pinf, ptr %p
  %ninf = call half @llvm.amdgcn.fract.f16(half 0xHFC00) ; -inf
  store volatile half %ninf, ptr %p
  %nan = call half @llvm.amdgcn.fract.f16(half 0xH7E00) ; nan
  store volatile half %nan, ptr %p
  ret void
}

define void @test_f32(ptr %p) {
; CHECK-LABEL: @test_f32(
; CHECK-NEXT:    store volatile float 0.000000e+00, ptr [[P:%.*]]
; CHECK-NEXT:    store volatile float 0.000000e+00, ptr [[P]]
; CHECK-NEXT:    store volatile float 0.000000e+00, ptr [[P]]
; CHECK-NEXT:    store volatile float 0.000000e+00, ptr [[P]]
; CHECK-NEXT:    store volatile float 2.500000e-01, ptr [[P]]
; CHECK-NEXT:    store volatile float 8.750000e-01, ptr [[P]]
; CHECK-NEXT:    store volatile float 0x3810000000000000, ptr [[P]]
; CHECK-NEXT:    store volatile float 0x3FEFFFFFE0000000, ptr [[P]]
; CHECK-NEXT:    store volatile float 0x7FF8000000000000, ptr [[P]]
; CHECK-NEXT:    store volatile float 0x7FF8000000000000, ptr [[P]]
; CHECK-NEXT:    store volatile float 0x7FF8000000000000, ptr [[P]]
; CHECK-NEXT:    ret void
;
  %p0 = call float @llvm.amdgcn.fract.f32(float +0.0)
  store volatile float %p0, ptr %p
  %n0 = call float @llvm.amdgcn.fract.f32(float -0.0)
  store volatile float %n0, ptr %p
  %p1 = call float @llvm.amdgcn.fract.f32(float +1.0)
  store volatile float %p1, ptr %p
  %n1 = call float @llvm.amdgcn.fract.f32(float -1.0)
  store volatile float %n1, ptr %p
  %p225 = call float @llvm.amdgcn.fract.f32(float +2.25)
  store volatile float %p225, ptr %p
  %n6125 = call float @llvm.amdgcn.fract.f32(float -6.125)
  store volatile float %n6125, ptr %p
  %ptiny = call float @llvm.amdgcn.fract.f32(float 0x3810000000000000) ; +min normal
  store volatile float %ptiny, ptr %p
  %ntiny = call float @llvm.amdgcn.fract.f32(float 0xB810000000000000) ; -min normal
  store volatile float %ntiny, ptr %p
  %pinf = call float @llvm.amdgcn.fract.f32(float 0x7FF0000000000000) ; +inf
  store volatile float %pinf, ptr %p
  %ninf = call float @llvm.amdgcn.fract.f32(float 0xFFF0000000000000) ; -inf
  store volatile float %ninf, ptr %p
  %nan = call float @llvm.amdgcn.fract.f32(float 0x7FF8000000000000) ; nan
  store volatile float %nan, ptr %p
  ret void
}

define void @test_f64(ptr %p) {
; CHECK-LABEL: @test_f64(
; CHECK-NEXT:    store volatile double 0.000000e+00, ptr [[P:%.*]]
; CHECK-NEXT:    store volatile double 0.000000e+00, ptr [[P]]
; CHECK-NEXT:    store volatile double 0.000000e+00, ptr [[P]]
; CHECK-NEXT:    store volatile double 0.000000e+00, ptr [[P]]
; CHECK-NEXT:    store volatile double 2.500000e-01, ptr [[P]]
; CHECK-NEXT:    store volatile double 8.750000e-01, ptr [[P]]
; CHECK-NEXT:    store volatile double 2.000000e-308, ptr [[P]]
; CHECK-NEXT:    store volatile double 0x3FEFFFFFFFFFFFFF, ptr [[P]]
; CHECK-NEXT:    store volatile double 0x7FF8000000000000, ptr [[P]]
; CHECK-NEXT:    store volatile double 0x7FF8000000000000, ptr [[P]]
; CHECK-NEXT:    store volatile double 0x7FF8000000000000, ptr [[P]]
; CHECK-NEXT:    ret void
;
  %p0 = call double @llvm.amdgcn.fract.f64(double +0.0)
  store volatile double %p0, ptr %p
  %n0 = call double @llvm.amdgcn.fract.f64(double -0.0)
  store volatile double %n0, ptr %p
  %p1 = call double @llvm.amdgcn.fract.f64(double +1.0)
  store volatile double %p1, ptr %p
  %n1 = call double @llvm.amdgcn.fract.f64(double -1.0)
  store volatile double %n1, ptr %p
  %p225 = call double @llvm.amdgcn.fract.f64(double +2.25)
  store volatile double %p225, ptr %p
  %n6125 = call double @llvm.amdgcn.fract.f64(double -6.125)
  store volatile double %n6125, ptr %p
  %ptiny = call double @llvm.amdgcn.fract.f64(double +2.0e-308) ; +min normal
  store volatile double %ptiny, ptr %p
  %ntiny = call double @llvm.amdgcn.fract.f64(double -2.0e-308) ; -min normal
  store volatile double %ntiny, ptr %p
  %pinf = call double @llvm.amdgcn.fract.f64(double 0x7FF0000000000000) ; +inf
  store volatile double %pinf, ptr %p
  %ninf = call double @llvm.amdgcn.fract.f64(double 0xFFF0000000000000) ; -inf
  store volatile double %ninf, ptr %p
  %nan = call double @llvm.amdgcn.fract.f64(double 0x7FF8000000000000) ; nan
  store volatile double %nan, ptr %p
  ret void
}
