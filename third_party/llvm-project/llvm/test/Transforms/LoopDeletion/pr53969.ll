; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -passes="loop(indvars,loop-deletion)" -S  < %s | FileCheck %s

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128-ni:1-p2:32:8:8:32-ni:2"
target triple = "x86_64-unknown-linux-gnu"

; Make sure we don't crash.
define void @test() {
; CHECK-LABEL: @test(
; CHECK-NEXT:  bb:
; CHECK-NEXT:    br label [[BB1:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    [[TMP2:%.*]] = phi i32 [ 11, [[BB:%.*]] ]
; CHECK-NEXT:    [[TMP3:%.*]] = add nsw i32 112, -1
; CHECK-NEXT:    [[TMP4:%.*]] = add nuw nsw i32 [[TMP2]], 1
; CHECK-NEXT:    [[TMP5:%.*]] = mul i32 [[TMP3]], [[TMP3]]
; CHECK-NEXT:    [[TMP6:%.*]] = mul nsw i32 [[TMP2]], -6
; CHECK-NEXT:    [[TMP7:%.*]] = mul nsw i32 [[TMP6]], [[TMP5]]
; CHECK-NEXT:    [[TMP8:%.*]] = add nuw nsw i32 [[TMP7]], [[TMP2]]
; CHECK-NEXT:    [[TMP9:%.*]] = and i32 undef, 1
; CHECK-NEXT:    [[TMP10:%.*]] = icmp eq i32 [[TMP9]], 0
; CHECK-NEXT:    br i1 [[TMP10]], label [[BB33_LOOPEXIT1:%.*]], label [[BB34_PREHEADER:%.*]]
; CHECK:       bb34.preheader:
; CHECK-NEXT:    br label [[BB34:%.*]]
; CHECK:       bb11:
; CHECK-NEXT:    [[TMP2_LCSSA12:%.*]] = phi i32 [ 11, [[BB34]] ]
; CHECK-NEXT:    br label [[BB33_LOOPEXIT:%.*]]
; CHECK:       bb12:
; CHECK-NEXT:    [[TMP0:%.*]] = add i64 [[TMP40:%.*]], 0
; CHECK-NEXT:    br label [[BB14:%.*]]
; CHECK:       bb14:
; CHECK-NEXT:    br i1 true, label [[BB32:%.*]], label [[BB22:%.*]]
; CHECK:       bb22:
; CHECK-NEXT:    [[TMP1:%.*]] = trunc i64 4 to i32
; CHECK-NEXT:    [[TMP23:%.*]] = or i32 [[TMP1]], undef
; CHECK-NEXT:    [[TMP24:%.*]] = add i32 [[TMP23]], undef
; CHECK-NEXT:    br i1 false, label [[BB42:%.*]], label [[BB25:%.*]]
; CHECK:       bb25:
; CHECK-NEXT:    br label [[BB31:%.*]]
; CHECK:       bb31:
; CHECK-NEXT:    unreachable
; CHECK:       bb32:
; CHECK-NEXT:    ret void
; CHECK:       bb33.loopexit:
; CHECK-NEXT:    [[TMP2_LCSSA9:%.*]] = phi i32 [ [[TMP2_LCSSA12]], [[BB11:%.*]] ]
; CHECK-NEXT:    br label [[BB33:%.*]]
; CHECK:       bb33.loopexit1:
; CHECK-NEXT:    [[TMP2_LCSSA:%.*]] = phi i32 [ [[TMP2]], [[BB1]] ]
; CHECK-NEXT:    br label [[BB33]]
; CHECK:       bb33:
; CHECK-NEXT:    [[TMP210:%.*]] = phi i32 [ [[TMP2_LCSSA]], [[BB33_LOOPEXIT1]] ], [ [[TMP2_LCSSA9]], [[BB33_LOOPEXIT]] ]
; CHECK-NEXT:    call void @use(i32 [[TMP210]])
; CHECK-NEXT:    ret void
; CHECK:       bb34:
; CHECK-NEXT:    [[TMP36:%.*]] = xor i32 0, [[TMP8]]
; CHECK-NEXT:    [[TMP38:%.*]] = add i32 [[TMP36]], undef
; CHECK-NEXT:    [[TMP39:%.*]] = add i32 [[TMP38]], undef
; CHECK-NEXT:    [[TMP40]] = sext i32 [[TMP39]] to i64
; CHECK-NEXT:    br i1 false, label [[BB11]], label [[BB12:%.*]]
; CHECK:       bb42:
; CHECK-NEXT:    [[TMP24_LCSSA:%.*]] = phi i32 [ [[TMP24]], [[BB22]] ]
; CHECK-NEXT:    [[TMP18_LCSSA4:%.*]] = phi i64 [ [[TMP0]], [[BB22]] ]
; CHECK-NEXT:    store atomic i64 [[TMP18_LCSSA4]], i64 addrspace(1)* undef unordered, align 8
; CHECK-NEXT:    call void @use(i32 [[TMP24_LCSSA]])
; CHECK-NEXT:    ret void
;
bb:
  br label %bb1

bb1:                                              ; preds = %bb31, %bb
  %tmp = phi i32 [ %tmp29, %bb31 ], [ undef, %bb ]
  %tmp2 = phi i32 [ %tmp4, %bb31 ], [ 11, %bb ]
  %tmp3 = add nsw i32 112, -1
  %tmp4 = add nuw nsw i32 %tmp2, 1
  %tmp5 = mul i32 %tmp3, %tmp3
  %tmp6 = mul nsw i32 %tmp2, -6
  %tmp7 = mul i32 %tmp6, %tmp5
  %tmp8 = add i32 %tmp7, %tmp2
  %tmp9 = and i32 undef, 1
  %tmp10 = icmp eq i32 %tmp9, 0
  br i1 %tmp10, label %bb33, label %bb34

bb11:                                             ; preds = %bb34
  br i1 undef, label %bb33, label %bb34

bb12:                                             ; preds = %bb34
  %tmp13 = icmp eq i8 addrspace(1)* undef, null
  br label %bb14

bb14:                                             ; preds = %bb25, %bb12
  %tmp15 = phi i32 [ %tmp29, %bb25 ], [ %tmp37, %bb12 ]
  %tmp16 = phi i64 [ undef, %bb25 ], [ %tmp41, %bb12 ]
  %tmp17 = phi i32 [ %tmp26, %bb25 ], [ 4, %bb12 ]
  %tmp18 = add i64 %tmp16, undef
  %tmp19 = add i32 %tmp15, 1
  %tmp20 = and i32 %tmp19, 1
  %tmp21 = icmp eq i32 %tmp20, 0
  br i1 %tmp21, label %bb32, label %bb22

bb22:                                             ; preds = %bb14
  %tmp23 = or i32 %tmp17, undef
  %tmp24 = add i32 %tmp23, undef
  br i1 %tmp13, label %bb42, label %bb25

bb25:                                             ; preds = %bb22
  %tmp26 = add nuw nsw i32 %tmp17, 1
  %tmp27 = zext i32 %tmp26 to i64
  %tmp28 = getelementptr inbounds i32, i32 addrspace(1)* undef, i64 %tmp27
  %tmp29 = add i32 %tmp15, 3
  %tmp30 = icmp ugt i32 %tmp17, 110
  br i1 %tmp30, label %bb31, label %bb14

bb31:                                             ; preds = %bb25
  br label %bb1

bb32:                                             ; preds = %bb14
  ret void

bb33:                                             ; preds = %bb11, %bb1
  call void @use(i32 %tmp2)
  ret void

bb34:                                             ; preds = %bb11, %bb1
  %tmp35 = phi i32 [ %tmp37, %bb11 ], [ %tmp, %bb1 ]
  %tmp36 = xor i32 0, %tmp8
  %tmp37 = add i32 %tmp35, 2
  %tmp38 = add i32 %tmp36, undef
  %tmp39 = add i32 %tmp38, undef
  %tmp40 = sext i32 %tmp39 to i64
  %tmp41 = add i64 undef, %tmp40
  br i1 undef, label %bb11, label %bb12

bb42:                                             ; preds = %bb22
  store atomic i64 %tmp18, i64 addrspace(1)* undef unordered, align 8
  call void @use(i32 %tmp24)
  ret void
}

declare void @use(i32)
