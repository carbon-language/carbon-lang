; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -instcombine -S | FileCheck %s

%"struct.std::complex" = type { { float, float } }
@dd = external global %"struct.std::complex", align 4
@dd2 = external global %"struct.std::complex", align 4

define void @_Z3fooi(i32 signext %n) {
; CHECK-LABEL: @_Z3fooi(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[TMP0:%.*]] = phi float [ 0.000000e+00, [[ENTRY:%.*]] ], [ [[ADD_I:%.*]], [[FOR_BODY:%.*]] ]
; CHECK-NEXT:    [[TMP1:%.*]] = phi float [ 0.000000e+00, [[ENTRY]] ], [ [[ADD4_I:%.*]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[I_0:%.*]] = phi i32 [ 0, [[ENTRY]] ], [ [[INC:%.*]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[I_0]], [[N:%.*]]
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY]], label [[FOR_END:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    [[TMP2:%.*]] = load float, float* getelementptr inbounds (%"struct.std::complex", %"struct.std::complex"* @dd, i64 0, i32 0, i32 0), align 4
; CHECK-NEXT:    [[TMP3:%.*]] = load float, float* getelementptr inbounds (%"struct.std::complex", %"struct.std::complex"* @dd, i64 0, i32 0, i32 1), align 4
; CHECK-NEXT:    [[TMP4:%.*]] = load float, float* getelementptr inbounds (%"struct.std::complex", %"struct.std::complex"* @dd2, i64 0, i32 0, i32 0), align 4
; CHECK-NEXT:    [[TMP5:%.*]] = load float, float* getelementptr inbounds (%"struct.std::complex", %"struct.std::complex"* @dd2, i64 0, i32 0, i32 1), align 4
; CHECK-NEXT:    [[MUL_I:%.*]] = fmul float [[TMP2]], [[TMP4]]
; CHECK-NEXT:    [[MUL4_I:%.*]] = fmul float [[TMP3]], [[TMP5]]
; CHECK-NEXT:    [[SUB_I:%.*]] = fsub float [[MUL_I]], [[MUL4_I]]
; CHECK-NEXT:    [[MUL5_I:%.*]] = fmul float [[TMP3]], [[TMP4]]
; CHECK-NEXT:    [[MUL6_I:%.*]] = fmul float [[TMP2]], [[TMP5]]
; CHECK-NEXT:    [[ADD_I4:%.*]] = fadd float [[MUL5_I]], [[MUL6_I]]
; CHECK-NEXT:    [[ADD_I]] = fadd float [[SUB_I]], [[TMP0]]
; CHECK-NEXT:    [[ADD4_I]] = fadd float [[ADD_I4]], [[TMP1]]
; CHECK-NEXT:    [[INC]] = add nuw nsw i32 [[I_0]], 1
; CHECK-NEXT:    br label [[FOR_COND]]
; CHECK:       for.end:
; CHECK-NEXT:    store float [[TMP0]], float* getelementptr inbounds (%"struct.std::complex", %"struct.std::complex"* @dd, i64 0, i32 0, i32 0), align 4
; CHECK-NEXT:    store float [[TMP1]], float* getelementptr inbounds (%"struct.std::complex", %"struct.std::complex"* @dd, i64 0, i32 0, i32 1), align 4
; CHECK-NEXT:    ret void
;
entry:
  br label %for.cond

for.cond:
  %ldd.sroa.0.0 = phi i32 [ 0, %entry ], [ %5, %for.body ]
  %ldd.sroa.6.0 = phi i32 [ 0, %entry ], [ %7, %for.body ]
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %cmp = icmp slt i32 %i.0, %n
  br i1 %cmp, label %for.body, label %for.end

for.body:
  %0 = load float, float* getelementptr inbounds (%"struct.std::complex", %"struct.std::complex"* @dd, i64 0, i32 0, i32 0), align 4
  %1 = load float, float* getelementptr inbounds (%"struct.std::complex", %"struct.std::complex"* @dd, i64 0, i32 0, i32 1), align 4
  %2 = load float, float* getelementptr inbounds (%"struct.std::complex", %"struct.std::complex"* @dd2, i64 0, i32 0, i32 0), align 4
  %3 = load float, float* getelementptr inbounds (%"struct.std::complex", %"struct.std::complex"* @dd2, i64 0, i32 0, i32 1), align 4
  %mul.i = fmul float %0, %2
  %mul4.i = fmul float %1, %3
  %sub.i = fsub float %mul.i, %mul4.i
  %mul5.i = fmul float %1, %2
  %mul6.i = fmul float %0, %3
  %add.i4 = fadd float %mul5.i, %mul6.i
  %4 = bitcast i32 %ldd.sroa.0.0 to float
  %add.i = fadd float %sub.i, %4
  %5 = bitcast float %add.i to i32
  %6 = bitcast i32 %ldd.sroa.6.0 to float
  %add4.i = fadd float %add.i4, %6
  %7 = bitcast float %add4.i to i32
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:
  store i32 %ldd.sroa.0.0, i32* bitcast (%"struct.std::complex"* @dd to i32*), align 4
  store i32 %ldd.sroa.6.0, i32* bitcast (float* getelementptr inbounds (%"struct.std::complex", %"struct.std::complex"* @dd, i64 0, i32 0, i32 1) to i32*), align 4
  ret void

}


define void @multi_phi(i32 signext %n) {
; CHECK-LABEL: @multi_phi(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[TMP0:%.*]] = phi float [ 0.000000e+00, [[ENTRY:%.*]] ], [ [[TMP6:%.*]], [[ODD_BB:%.*]] ]
; CHECK-NEXT:    [[I_0:%.*]] = phi i32 [ 0, [[ENTRY]] ], [ [[INC:%.*]], [[ODD_BB]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[I_0]], [[N:%.*]]
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY:%.*]], label [[FOR_END:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    [[TMP1:%.*]] = load float, float* getelementptr inbounds (%"struct.std::complex", %"struct.std::complex"* @dd, i64 0, i32 0, i32 0), align 4
; CHECK-NEXT:    [[TMP2:%.*]] = load float, float* getelementptr inbounds (%"struct.std::complex", %"struct.std::complex"* @dd, i64 0, i32 0, i32 1), align 4
; CHECK-NEXT:    [[TMP3:%.*]] = load float, float* getelementptr inbounds (%"struct.std::complex", %"struct.std::complex"* @dd2, i64 0, i32 0, i32 0), align 4
; CHECK-NEXT:    [[TMP4:%.*]] = load float, float* getelementptr inbounds (%"struct.std::complex", %"struct.std::complex"* @dd2, i64 0, i32 0, i32 1), align 4
; CHECK-NEXT:    [[MUL_I:%.*]] = fmul float [[TMP1]], [[TMP3]]
; CHECK-NEXT:    [[MUL4_I:%.*]] = fmul float [[TMP2]], [[TMP4]]
; CHECK-NEXT:    [[SUB_I:%.*]] = fsub float [[MUL_I]], [[MUL4_I]]
; CHECK-NEXT:    [[ADD_I:%.*]] = fadd float [[SUB_I]], [[TMP0]]
; CHECK-NEXT:    [[INC]] = add nuw nsw i32 [[I_0]], 1
; CHECK-NEXT:    [[BIT0:%.*]] = and i32 [[INC]], 1
; CHECK-NEXT:    [[EVEN:%.*]] = icmp eq i32 [[BIT0]], 0
; CHECK-NEXT:    br i1 [[EVEN]], label [[EVEN_BB:%.*]], label [[ODD_BB]]
; CHECK:       even.bb:
; CHECK-NEXT:    [[TMP5:%.*]] = fadd float [[SUB_I]], [[ADD_I]]
; CHECK-NEXT:    br label [[ODD_BB]]
; CHECK:       odd.bb:
; CHECK-NEXT:    [[TMP6]] = phi float [ [[ADD_I]], [[FOR_BODY]] ], [ [[TMP5]], [[EVEN_BB]] ]
; CHECK-NEXT:    br label [[FOR_COND]]
; CHECK:       for.end:
; CHECK-NEXT:    store float [[TMP0]], float* getelementptr inbounds (%"struct.std::complex", %"struct.std::complex"* @dd, i64 0, i32 0, i32 0), align 4
; CHECK-NEXT:    ret void
;
entry:
  br label %for.cond

for.cond:
  %ldd.sroa.0.0 = phi i32 [ 0, %entry ], [ %9, %odd.bb ]
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %odd.bb ]
  %cmp = icmp slt i32 %i.0, %n
  br i1 %cmp, label %for.body, label %for.end

for.body:
  %0 = load float, float* getelementptr inbounds (%"struct.std::complex", %"struct.std::complex"* @dd, i64 0, i32 0, i32 0), align 4
  %1 = load float, float* getelementptr inbounds (%"struct.std::complex", %"struct.std::complex"* @dd, i64 0, i32 0, i32 1), align 4
  %2 = load float, float* getelementptr inbounds (%"struct.std::complex", %"struct.std::complex"* @dd2, i64 0, i32 0, i32 0), align 4
  %3 = load float, float* getelementptr inbounds (%"struct.std::complex", %"struct.std::complex"* @dd2, i64 0, i32 0, i32 1), align 4
  %mul.i = fmul float %0, %2
  %mul4.i = fmul float %1, %3
  %sub.i = fsub float %mul.i, %mul4.i
  %4 = bitcast i32 %ldd.sroa.0.0 to float
  %add.i = fadd float %sub.i, %4
  %5 = bitcast float %add.i to i32
  %inc = add nsw i32 %i.0, 1
  %bit0 = and i32 %inc, 1
  %even = icmp slt i32 %bit0, 1
  br i1 %even, label %even.bb, label %odd.bb

even.bb:
  %6 = bitcast i32 %5 to float
  %7 = fadd float %sub.i, %6
  %8 = bitcast float %7 to i32
  br label %odd.bb

odd.bb:
  %9 = phi i32 [ %5, %for.body ], [ %8, %even.bb ]
  br label %for.cond

for.end:
  store i32 %ldd.sroa.0.0, i32* bitcast (%"struct.std::complex"* @dd to i32*), align 4
  ret void

}
