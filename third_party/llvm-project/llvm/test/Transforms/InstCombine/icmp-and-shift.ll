; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes=instcombine -S | FileCheck %s

declare void @use(i8)

define i32 @icmp_eq_and_pow2_shl1(i32 %0) {
; CHECK-LABEL: @icmp_eq_and_pow2_shl1(
; CHECK-NEXT:    [[CMP:%.*]] = icmp ne i32 [[TMP0:%.*]], 4
; CHECK-NEXT:    [[CONV:%.*]] = zext i1 [[CMP]] to i32
; CHECK-NEXT:    ret i32 [[CONV]]
;
  %shl = shl i32 1, %0
  %and = and i32 %shl, 16
  %cmp = icmp eq i32 %and, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

define <2 x i32> @icmp_eq_and_pow2_shl1_vec(<2 x i32> %0) {
; CHECK-LABEL: @icmp_eq_and_pow2_shl1_vec(
; CHECK-NEXT:    [[CMP:%.*]] = icmp ne <2 x i32> [[TMP0:%.*]], <i32 4, i32 4>
; CHECK-NEXT:    [[CONV:%.*]] = zext <2 x i1> [[CMP]] to <2 x i32>
; CHECK-NEXT:    ret <2 x i32> [[CONV]]
;
  %shl = shl <2 x i32> <i32 1, i32 1>, %0
  %and = and <2 x i32> %shl, <i32 16, i32 16>
  %cmp = icmp eq <2 x i32> %and, <i32 0, i32 0>
  %conv = zext <2 x i1> %cmp to <2 x i32>
  ret <2 x i32> %conv
}

define i32 @icmp_ne_and_pow2_shl1(i32 %0) {
; CHECK-LABEL: @icmp_ne_and_pow2_shl1(
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[TMP0:%.*]], 4
; CHECK-NEXT:    [[CONV:%.*]] = zext i1 [[CMP]] to i32
; CHECK-NEXT:    ret i32 [[CONV]]
;
  %shl = shl i32 1, %0
  %and = and i32 %shl, 16
  %cmp = icmp ne i32 %and, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

define <2 x i32> @icmp_ne_and_pow2_shl1_vec(<2 x i32> %0) {
; CHECK-LABEL: @icmp_ne_and_pow2_shl1_vec(
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq <2 x i32> [[TMP0:%.*]], <i32 4, i32 4>
; CHECK-NEXT:    [[CONV:%.*]] = zext <2 x i1> [[CMP]] to <2 x i32>
; CHECK-NEXT:    ret <2 x i32> [[CONV]]
;
  %shl = shl <2 x i32> <i32 1, i32 1>, %0
  %and = and <2 x i32> %shl, <i32 16, i32 16>
  %cmp = icmp ne <2 x i32> %and, <i32 0, i32 0>
  %conv = zext <2 x i1> %cmp to <2 x i32>
  ret <2 x i32> %conv
}

define i32 @icmp_eq_and_pow2_shl_pow2(i32 %0) {
; CHECK-LABEL: @icmp_eq_and_pow2_shl_pow2(
; CHECK-NEXT:    [[TMP2:%.*]] = icmp ne i32 [[TMP0:%.*]], 3
; CHECK-NEXT:    [[TMP3:%.*]] = zext i1 [[TMP2]] to i32
; CHECK-NEXT:    ret i32 [[TMP3]]
;
  %shl = shl i32 2, %0
  %and = and i32 %shl, 16
  %cmp = icmp eq i32 %and, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

define <2 x i32> @icmp_eq_and_pow2_shl_pow2_vec(<2 x i32> %0) {
; CHECK-LABEL: @icmp_eq_and_pow2_shl_pow2_vec(
; CHECK-NEXT:    [[TMP2:%.*]] = icmp ne <2 x i32> [[TMP0:%.*]], <i32 2, i32 2>
; CHECK-NEXT:    [[TMP3:%.*]] = zext <2 x i1> [[TMP2]] to <2 x i32>
; CHECK-NEXT:    ret <2 x i32> [[TMP3]]
;
  %shl = shl <2 x i32> <i32 4, i32 4>, %0
  %and = and <2 x i32> %shl, <i32 16, i32 16>
  %cmp = icmp eq <2 x i32> %and, <i32 0, i32 0>
  %conv = zext <2 x i1> %cmp to <2 x i32>
  ret <2 x i32> %conv
}

define i32 @icmp_ne_and_pow2_shl_pow2(i32 %0) {
; CHECK-LABEL: @icmp_ne_and_pow2_shl_pow2(
; CHECK-NEXT:    [[TMP2:%.*]] = icmp eq i32 [[TMP0:%.*]], 3
; CHECK-NEXT:    [[AND_LOBIT:%.*]] = zext i1 [[TMP2]] to i32
; CHECK-NEXT:    ret i32 [[AND_LOBIT]]
;
  %shl = shl i32 2, %0
  %and = and i32 %shl, 16
  %cmp = icmp ne i32 %and, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

define <2 x i32> @icmp_ne_and_pow2_shl_pow2_vec(<2 x i32> %0) {
; CHECK-LABEL: @icmp_ne_and_pow2_shl_pow2_vec(
; CHECK-NEXT:    [[TMP2:%.*]] = icmp eq <2 x i32> [[TMP0:%.*]], <i32 2, i32 2>
; CHECK-NEXT:    [[AND_LOBIT:%.*]] = zext <2 x i1> [[TMP2]] to <2 x i32>
; CHECK-NEXT:    ret <2 x i32> [[AND_LOBIT]]
;
  %shl = shl <2 x i32> <i32 4, i32 4>, %0
  %and = and <2 x i32> %shl, <i32 16, i32 16>
  %cmp = icmp ne <2 x i32> %and, <i32 0, i32 0>
  %conv = zext <2 x i1> %cmp to <2 x i32>
  ret <2 x i32> %conv
}

define i32 @icmp_eq_and_pow2_shl_pow2_negative1(i32 %0) {
; CHECK-LABEL: @icmp_eq_and_pow2_shl_pow2_negative1(
; CHECK-NEXT:    [[SHL:%.*]] = shl i32 11, [[TMP0:%.*]]
; CHECK-NEXT:    [[AND:%.*]] = lshr i32 [[SHL]], 4
; CHECK-NEXT:    [[AND_LOBIT:%.*]] = and i32 [[AND]], 1
; CHECK-NEXT:    [[TMP2:%.*]] = xor i32 [[AND_LOBIT]], 1
; CHECK-NEXT:    ret i32 [[TMP2]]
;
  %shl = shl i32 11, %0
  %and = and i32 %shl, 16
  %cmp = icmp eq i32 %and, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

define i32 @icmp_eq_and_pow2_shl_pow2_negative2(i32 %0) {
; CHECK-LABEL: @icmp_eq_and_pow2_shl_pow2_negative2(
; CHECK-NEXT:    [[SHL:%.*]] = shl i32 2, [[TMP0:%.*]]
; CHECK-NEXT:    [[AND:%.*]] = and i32 [[SHL]], 14
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[AND]], 0
; CHECK-NEXT:    [[CONV:%.*]] = zext i1 [[CMP]] to i32
; CHECK-NEXT:    ret i32 [[CONV]]
;
  %shl = shl i32 2, %0
  %and = and i32 %shl, 14
  %cmp = icmp eq i32 %and, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

define i32 @icmp_eq_and_pow2_shl_pow2_negative3(i32 %0) {
; CHECK-LABEL: @icmp_eq_and_pow2_shl_pow2_negative3(
; CHECK-NEXT:    ret i32 1
;
  %shl = shl i32 32, %0
  %and = and i32 %shl, 16
  %cmp = icmp eq i32 %and, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}


define i32 @icmp_eq_and_pow2_minus1_shl1(i32 %0) {
; CHECK-LABEL: @icmp_eq_and_pow2_minus1_shl1(
; CHECK-NEXT:    [[CMP:%.*]] = icmp ugt i32 [[TMP0:%.*]], 3
; CHECK-NEXT:    [[CONV:%.*]] = zext i1 [[CMP]] to i32
; CHECK-NEXT:    ret i32 [[CONV]]
;
  %shl = shl i32 1, %0
  %and = and i32 %shl, 15
  %cmp = icmp eq i32 %and, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

define <2 x i32> @icmp_eq_and_pow2_minus1_shl1_vec(<2 x i32> %0) {
; CHECK-LABEL: @icmp_eq_and_pow2_minus1_shl1_vec(
; CHECK-NEXT:    [[CMP:%.*]] = icmp ugt <2 x i32> [[TMP0:%.*]], <i32 3, i32 3>
; CHECK-NEXT:    [[CONV:%.*]] = zext <2 x i1> [[CMP]] to <2 x i32>
; CHECK-NEXT:    ret <2 x i32> [[CONV]]
;
  %shl = shl <2 x i32> <i32 1, i32 1>, %0
  %and = and <2 x i32> %shl, <i32 15, i32 15>
  %cmp = icmp eq <2 x i32> %and, <i32 0, i32 0>
  %conv = zext <2 x i1> %cmp to <2 x i32>
  ret <2 x i32> %conv
}

define i32 @icmp_ne_and_pow2_minus1_shl1(i32 %0) {
; CHECK-LABEL: @icmp_ne_and_pow2_minus1_shl1(
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[TMP0:%.*]], 4
; CHECK-NEXT:    [[CONV:%.*]] = zext i1 [[CMP]] to i32
; CHECK-NEXT:    ret i32 [[CONV]]
;
  %shl = shl i32 1, %0
  %and = and i32 %shl, 15
  %cmp = icmp ne i32 %and, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

define <2 x i32> @icmp_ne_and_pow2_minus1_shl1_vec(<2 x i32> %0) {
; CHECK-LABEL: @icmp_ne_and_pow2_minus1_shl1_vec(
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult <2 x i32> [[TMP0:%.*]], <i32 4, i32 4>
; CHECK-NEXT:    [[CONV:%.*]] = zext <2 x i1> [[CMP]] to <2 x i32>
; CHECK-NEXT:    ret <2 x i32> [[CONV]]
;
  %shl = shl <2 x i32> <i32 1, i32 1>, %0
  %and = and <2 x i32> %shl, <i32 15, i32 15>
  %cmp = icmp ne <2 x i32> %and, <i32 0, i32 0>
  %conv = zext <2 x i1> %cmp to <2 x i32>
  ret <2 x i32> %conv
}

define i32 @icmp_eq_and_pow2_minus1_shl_pow2(i32 %0) {
; CHECK-LABEL: @icmp_eq_and_pow2_minus1_shl_pow2(
; CHECK-NEXT:    [[SHL:%.*]] = shl i32 2, [[TMP0:%.*]]
; CHECK-NEXT:    [[AND:%.*]] = and i32 [[SHL]], 14
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[AND]], 0
; CHECK-NEXT:    [[CONV:%.*]] = zext i1 [[CMP]] to i32
; CHECK-NEXT:    ret i32 [[CONV]]
;
  %shl = shl i32 2, %0
  %and = and i32 %shl, 15
  %cmp = icmp eq i32 %and, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

define <2 x i32> @icmp_eq_and_pow2_minus1_shl_pow2_vec(<2 x i32> %0) {
; CHECK-LABEL: @icmp_eq_and_pow2_minus1_shl_pow2_vec(
; CHECK-NEXT:    [[SHL:%.*]] = shl <2 x i32> <i32 4, i32 4>, [[TMP0:%.*]]
; CHECK-NEXT:    [[AND:%.*]] = and <2 x i32> [[SHL]], <i32 12, i32 12>
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq <2 x i32> [[AND]], zeroinitializer
; CHECK-NEXT:    [[CONV:%.*]] = zext <2 x i1> [[CMP]] to <2 x i32>
; CHECK-NEXT:    ret <2 x i32> [[CONV]]
;
  %shl = shl <2 x i32> <i32 4, i32 4>, %0
  %and = and <2 x i32> %shl, <i32 15, i32 15>
  %cmp = icmp eq <2 x i32> %and, <i32 0, i32 0>
  %conv = zext <2 x i1> %cmp to <2 x i32>
  ret <2 x i32> %conv
}

define i32 @icmp_ne_and_pow2_minus1_shl_pow2(i32 %0) {
; CHECK-LABEL: @icmp_ne_and_pow2_minus1_shl_pow2(
; CHECK-NEXT:    [[SHL:%.*]] = shl i32 2, [[TMP0:%.*]]
; CHECK-NEXT:    [[AND:%.*]] = and i32 [[SHL]], 14
; CHECK-NEXT:    [[CMP:%.*]] = icmp ne i32 [[AND]], 0
; CHECK-NEXT:    [[CONV:%.*]] = zext i1 [[CMP]] to i32
; CHECK-NEXT:    ret i32 [[CONV]]
;
  %shl = shl i32 2, %0
  %and = and i32 %shl, 15
  %cmp = icmp ne i32 %and, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

define <2 x i32> @icmp_ne_and_pow2_minus1_shl_pow2_vec(<2 x i32> %0) {
; CHECK-LABEL: @icmp_ne_and_pow2_minus1_shl_pow2_vec(
; CHECK-NEXT:    [[SHL:%.*]] = shl <2 x i32> <i32 4, i32 4>, [[TMP0:%.*]]
; CHECK-NEXT:    [[AND:%.*]] = and <2 x i32> [[SHL]], <i32 12, i32 12>
; CHECK-NEXT:    [[CMP:%.*]] = icmp ne <2 x i32> [[AND]], zeroinitializer
; CHECK-NEXT:    [[CONV:%.*]] = zext <2 x i1> [[CMP]] to <2 x i32>
; CHECK-NEXT:    ret <2 x i32> [[CONV]]
;
  %shl = shl <2 x i32> <i32 4, i32 4>, %0
  %and = and <2 x i32> %shl, <i32 15, i32 15>
  %cmp = icmp ne <2 x i32> %and, <i32 0, i32 0>
  %conv = zext <2 x i1> %cmp to <2 x i32>
  ret <2 x i32> %conv
}

define i32 @icmp_eq_and_pow2_minus1_shl1_negative1(i32 %0) {
; CHECK-LABEL: @icmp_eq_and_pow2_minus1_shl1_negative1(
; CHECK-NEXT:    [[SHL:%.*]] = shl i32 3, [[TMP0:%.*]]
; CHECK-NEXT:    [[AND:%.*]] = and i32 [[SHL]], 15
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[AND]], 0
; CHECK-NEXT:    [[CONV:%.*]] = zext i1 [[CMP]] to i32
; CHECK-NEXT:    ret i32 [[CONV]]
;
  %shl = shl i32 3, %0
  %and = and i32 %shl, 15
  %cmp = icmp eq i32 %and, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

define i32 @icmp_eq_and_pow2_minus1_shl1_negative2(i32 %0) {
; CHECK-LABEL: @icmp_eq_and_pow2_minus1_shl1_negative2(
; CHECK-NEXT:    ret i32 1
;
  %shl = shl i32 32, %0
  %and = and i32 %shl, 15
  %cmp = icmp eq i32 %and, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}


define i32 @icmp_eq_and1_lshr_pow2(i32 %0) {
; CHECK-LABEL: @icmp_eq_and1_lshr_pow2(
; CHECK-NEXT:    [[CMP:%.*]] = icmp ne i32 [[TMP0:%.*]], 3
; CHECK-NEXT:    [[CONV:%.*]] = zext i1 [[CMP]] to i32
; CHECK-NEXT:    ret i32 [[CONV]]
;
  %lshr = lshr i32 8, %0
  %and  = and i32 %lshr, 1
  %cmp  = icmp eq i32 %and, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

define <2 x i32> @icmp_eq_and1_lshr_pow2_vec(<2 x i32> %0) {
; CHECK-LABEL: @icmp_eq_and1_lshr_pow2_vec(
; CHECK-NEXT:    [[CMP:%.*]] = icmp ne <2 x i32> [[TMP0:%.*]], <i32 3, i32 3>
; CHECK-NEXT:    [[CONV:%.*]] = zext <2 x i1> [[CMP]] to <2 x i32>
; CHECK-NEXT:    ret <2 x i32> [[CONV]]
;
  %lshr = lshr <2 x i32> <i32 8, i32 8>, %0
  %and  = and <2 x i32> %lshr, <i32 1, i32 1>
  %cmp  = icmp eq <2 x i32> %and, <i32 0, i32 0>
  %conv = zext <2 x i1> %cmp to <2 x i32>
  ret <2 x i32> %conv
}

define i32 @icmp_ne_and1_lshr_pow2(i32 %0) {
; CHECK-LABEL: @icmp_ne_and1_lshr_pow2(
; CHECK-NEXT:    [[CMP:%.*]] = icmp ne i32 [[TMP0:%.*]], 3
; CHECK-NEXT:    [[CONV:%.*]] = zext i1 [[CMP]] to i32
; CHECK-NEXT:    ret i32 [[CONV]]
;
  %lshr = lshr i32 8, %0
  %and  = and i32 %lshr, 1
  %cmp  = icmp eq i32 %and, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

define <2 x i32> @icmp_ne_and1_lshr_pow2_vec(<2 x i32> %0) {
; CHECK-LABEL: @icmp_ne_and1_lshr_pow2_vec(
; CHECK-NEXT:    [[AND:%.*]] = lshr <2 x i32> <i32 2, i32 2>, [[TMP0:%.*]]
; CHECK-NEXT:    [[AND_LOBIT:%.*]] = and <2 x i32> [[AND]], <i32 1, i32 1>
; CHECK-NEXT:    ret <2 x i32> [[AND_LOBIT]]
;
  %lshr = lshr <2 x i32> <i32 8, i32 8>, %0
  %and  = and <2 x i32> %lshr, <i32 4, i32 4>
  %cmp  = icmp ne <2 x i32> %and, <i32 0, i32 0>
  %conv = zext <2 x i1> %cmp to <2 x i32>
  ret <2 x i32> %conv
}

define i32 @icmp_eq_and_pow2_lshr_pow2(i32 %0) {
; CHECK-LABEL: @icmp_eq_and_pow2_lshr_pow2(
; CHECK-NEXT:    [[AND:%.*]] = lshr i32 2, [[TMP0:%.*]]
; CHECK-NEXT:    [[AND_LOBIT:%.*]] = and i32 [[AND]], 1
; CHECK-NEXT:    [[TMP2:%.*]] = xor i32 [[AND_LOBIT]], 1
; CHECK-NEXT:    ret i32 [[TMP2]]
;
  %lshr = lshr i32 8, %0
  %and  = and i32 %lshr, 4
  %cmp  = icmp eq i32 %and, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

define i32 @icmp_eq_and_pow2_lshr_pow2_case2(i32 %0) {
; CHECK-LABEL: @icmp_eq_and_pow2_lshr_pow2_case2(
; CHECK-NEXT:    ret i32 1
;
  %lshr = lshr i32 4, %0
  %and  = and i32 %lshr, 8
  %cmp  = icmp eq i32 %and, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

define <2 x i32> @icmp_eq_and_pow2_lshr_pow2_vec(<2 x i32> %0) {
; CHECK-LABEL: @icmp_eq_and_pow2_lshr_pow2_vec(
; CHECK-NEXT:    [[AND:%.*]] = lshr <2 x i32> <i32 2, i32 2>, [[TMP0:%.*]]
; CHECK-NEXT:    [[AND_LOBIT:%.*]] = and <2 x i32> [[AND]], <i32 1, i32 1>
; CHECK-NEXT:    [[TMP2:%.*]] = xor <2 x i32> [[AND_LOBIT]], <i32 1, i32 1>
; CHECK-NEXT:    ret <2 x i32> [[TMP2]]
;
  %lshr = lshr <2 x i32> <i32 8, i32 8>, %0
  %and  = and <2 x i32> %lshr, <i32 4, i32 4>
  %cmp  = icmp eq <2 x i32> %and, <i32 0, i32 0>
  %conv = zext <2 x i1> %cmp to <2 x i32>
  ret <2 x i32> %conv
}

define i32 @icmp_ne_and_pow2_lshr_pow2(i32 %0) {
; CHECK-LABEL: @icmp_ne_and_pow2_lshr_pow2(
; CHECK-NEXT:    [[AND:%.*]] = lshr i32 2, [[TMP0:%.*]]
; CHECK-NEXT:    [[AND_LOBIT:%.*]] = and i32 [[AND]], 1
; CHECK-NEXT:    [[TMP2:%.*]] = xor i32 [[AND_LOBIT]], 1
; CHECK-NEXT:    ret i32 [[TMP2]]
;
  %lshr = lshr i32 8, %0
  %and  = and i32 %lshr, 4
  %cmp  = icmp eq i32 %and, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

define i32 @icmp_ne_and_pow2_lshr_pow2_case2(i32 %0) {
; CHECK-LABEL: @icmp_ne_and_pow2_lshr_pow2_case2(
; CHECK-NEXT:    ret i32 1
;
  %lshr = lshr i32 4, %0
  %and  = and i32 %lshr, 8
  %cmp  = icmp eq i32 %and, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

define <2 x i32> @icmp_ne_and_pow2_lshr_pow2_vec(<2 x i32> %0) {
; CHECK-LABEL: @icmp_ne_and_pow2_lshr_pow2_vec(
; CHECK-NEXT:    [[AND:%.*]] = lshr <2 x i32> <i32 2, i32 2>, [[TMP0:%.*]]
; CHECK-NEXT:    [[AND_LOBIT:%.*]] = and <2 x i32> [[AND]], <i32 1, i32 1>
; CHECK-NEXT:    ret <2 x i32> [[AND_LOBIT]]
;
  %lshr = lshr <2 x i32> <i32 8, i32 8>, %0
  %and  = and <2 x i32> %lshr, <i32 4, i32 4>
  %cmp  = icmp ne <2 x i32> %and, <i32 0, i32 0>
  %conv = zext <2 x i1> %cmp to <2 x i32>
  ret <2 x i32> %conv
}

define i32 @icmp_eq_and1_lshr_pow2_negative1(i32 %0) {
; CHECK-LABEL: @icmp_eq_and1_lshr_pow2_negative1(
; CHECK-NEXT:    [[LSHR:%.*]] = lshr i32 7, [[TMP0:%.*]]
; CHECK-NEXT:    [[AND:%.*]] = and i32 [[LSHR]], 1
; CHECK-NEXT:    [[TMP2:%.*]] = xor i32 [[AND]], 1
; CHECK-NEXT:    ret i32 [[TMP2]]
;
  %lshr = lshr i32 7, %0
  %and  = and i32 %lshr, 1
  %cmp  = icmp eq i32 %and, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

define i32 @icmp_eq_and1_lshr_pow2_negative2(i32 %0) {
; CHECK-LABEL: @icmp_eq_and1_lshr_pow2_negative2(
; CHECK-NEXT:    [[LSHR:%.*]] = lshr i32 8, [[TMP0:%.*]]
; CHECK-NEXT:    [[AND:%.*]] = and i32 [[LSHR]], 3
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[AND]], 0
; CHECK-NEXT:    [[CONV:%.*]] = zext i1 [[CMP]] to i32
; CHECK-NEXT:    ret i32 [[CONV]]
;
  %lshr = lshr i32 8, %0
  %and  = and i32 %lshr, 3
  %cmp  = icmp eq i32 %and, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}
