; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -S -memcpyopt < %s | FileCheck %s

; The memcpy here is *not* dead, because it reads memory written in a previous
; loop iteration.

define void @test(i1 %c, i8* nocapture noundef readonly %path, i8* noundef writeonly %name) {
; CHECK-LABEL: @test(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP:%.*]] = alloca [260 x i8], align 16
; CHECK-NEXT:    br label [[WHILE_BODY:%.*]]
; CHECK:       while.body:
; CHECK-NEXT:    [[IV:%.*]] = phi i64 [ [[IV_NEXT:%.*]], [[WHILE_BODY]] ], [ 259, [[ENTRY:%.*]] ]
; CHECK-NEXT:    [[IV_NEXT]] = add nsw i64 [[IV]], -1
; CHECK-NEXT:    [[TMP_IV:%.*]] = getelementptr inbounds [260 x i8], [260 x i8]* [[TMP]], i64 0, i64 [[IV]]
; CHECK-NEXT:    store i8 42, i8* [[TMP_IV]], align 1
; CHECK-NEXT:    br i1 [[C:%.*]], label [[WHILE_BODY]], label [[EXIT:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    [[TMP_IV_1:%.*]] = getelementptr inbounds i8, i8* [[TMP_IV]], i64 1
; CHECK-NEXT:    [[LEN:%.*]] = sub nsw i64 259, [[IV]]
; CHECK-NEXT:    call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 [[NAME:%.*]], i8* nonnull align 1 [[TMP_IV_1]], i64 [[LEN]], i1 false)
; CHECK-NEXT:    ret void
;
entry:
  %tmp = alloca [260 x i8], align 16
  br label %while.body

while.body:
  %iv = phi i64 [ %iv.next, %while.body ], [ 259, %entry ]
  %iv.next = add nsw i64 %iv, -1
  %tmp.iv = getelementptr inbounds [260 x i8], [260 x i8]* %tmp, i64 0, i64 %iv
  store i8 42, i8* %tmp.iv, align 1
  br i1 %c, label %while.body, label %exit

exit:
  %tmp.iv.1 = getelementptr inbounds i8, i8* %tmp.iv, i64 1
  %len = sub nsw i64 259, %iv
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %name, i8* nonnull align 1 %tmp.iv.1, i64 %len, i1 false)
  ret void
}

declare void @llvm.memcpy.p0i8.p0i8.i64(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i64 %2, i1 immarg %3)
