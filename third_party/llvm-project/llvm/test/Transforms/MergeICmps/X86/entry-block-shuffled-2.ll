; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -S -mergeicmps < %s | FileCheck %s

target triple = "x86_64-unknown-linux-gnu"

%"struct.a::c" = type { i32, i32*, i8* }

; The entry block cannot be merged as the comparison is not continuous.
; While it compares the highest address, it should not be moved after the
; other comparisons, as that would make the allocas non-dominating.

define i1 @test() {
; CHECK-LABEL: @test(
; CHECK-NEXT:  "land.lhs.true+entry":
; CHECK-NEXT:    [[H:%.*]] = alloca %"struct.a::c", align 8
; CHECK-NEXT:    [[I:%.*]] = alloca %"struct.a::c", align 8
; CHECK-NEXT:    call void @init(%"struct.a::c"* [[H]])
; CHECK-NEXT:    call void @init(%"struct.a::c"* [[I]])
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds %"struct.a::c", %"struct.a::c"* [[H]], i64 0, i32 1
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds %"struct.a::c", %"struct.a::c"* [[I]], i64 0, i32 1
; CHECK-NEXT:    [[CSTR:%.*]] = bitcast i32** [[TMP0]] to i8*
; CHECK-NEXT:    [[CSTR2:%.*]] = bitcast i32** [[TMP1]] to i8*
; CHECK-NEXT:    [[MEMCMP:%.*]] = call i32 @memcmp(i8* [[CSTR]], i8* [[CSTR2]], i64 16)
; CHECK-NEXT:    [[TMP2:%.*]] = icmp eq i32 [[MEMCMP]], 0
; CHECK-NEXT:    br i1 [[TMP2]], label [[LAND_RHS1:%.*]], label [[LAND_END:%.*]]
; CHECK:       land.rhs1:
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds %"struct.a::c", %"struct.a::c"* [[H]], i64 0, i32 0
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr inbounds %"struct.a::c", %"struct.a::c"* [[I]], i64 0, i32 0
; CHECK-NEXT:    [[TMP5:%.*]] = load i32, i32* [[TMP3]], align 4
; CHECK-NEXT:    [[TMP6:%.*]] = load i32, i32* [[TMP4]], align 4
; CHECK-NEXT:    [[TMP7:%.*]] = icmp eq i32 [[TMP5]], [[TMP6]]
; CHECK-NEXT:    br label [[LAND_END]]
; CHECK:       land.end:
; CHECK-NEXT:    [[V9:%.*]] = phi i1 [ [[TMP7]], [[LAND_RHS1]] ], [ false, %"land.lhs.true+entry" ]
; CHECK-NEXT:    ret i1 [[V9]]
;
entry:
  %h = alloca %"struct.a::c", align 8
  %i = alloca %"struct.a::c", align 8
  call void @init(%"struct.a::c"* %h)
  call void @init(%"struct.a::c"* %i)
  %e = getelementptr inbounds %"struct.a::c", %"struct.a::c"* %h, i64 0, i32 2
  %v3 = load i8*, i8** %e, align 8
  %e2 = getelementptr inbounds %"struct.a::c", %"struct.a::c"* %i, i64 0, i32 2
  %v4 = load i8*, i8** %e2, align 8
  %cmp = icmp eq i8* %v3, %v4
  br i1 %cmp, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  %d = getelementptr inbounds %"struct.a::c", %"struct.a::c"* %h, i64 0, i32 1
  %v5 = load i32*, i32** %d, align 8
  %d3 = getelementptr inbounds %"struct.a::c", %"struct.a::c"* %i, i64 0, i32 1
  %v6 = load i32*, i32** %d3, align 8
  %cmp4 = icmp eq i32* %v5, %v6
  br i1 %cmp4, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %j = getelementptr inbounds %"struct.a::c", %"struct.a::c"* %h, i64 0, i32 0
  %v7 = load i32, i32* %j, align 8
  %j5 = getelementptr inbounds %"struct.a::c", %"struct.a::c"* %i, i64 0, i32 0
  %v8 = load i32, i32* %j5, align 8
  %cmp6 = icmp eq i32 %v7, %v8
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %entry
  %v9 = phi i1 [ false, %land.lhs.true ], [ false, %entry ], [ %cmp6, %land.rhs ]
  ret i1 %v9
}

declare void @init(%"struct.a::c"*)
