; XFAIL: *
; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -mergeicmps -verify-dom-info -mtriple=x86_64-unknown-unknown -S | FileCheck %s

; This is a more involved test: clang generates this weird pattern for
; tuple<uint8_t, uint8_t, uint8_t, uint8_t>. Right now we skip the entry block
; (which defines the base pointer for other blocks) and the last one (which
; does not have the expected structure). Only middle blocks (bytes [1,2]) are
; merged.

%"class.std::tuple" = type { %"struct.std::_Tuple_impl" }
%"struct.std::_Tuple_impl" = type { %"struct.std::_Tuple_impl.0", %"struct.std::_Head_base.6" }
%"struct.std::_Tuple_impl.0" = type { %"struct.std::_Tuple_impl.1", %"struct.std::_Head_base.5" }
%"struct.std::_Tuple_impl.1" = type { %"struct.std::_Tuple_impl.2", %"struct.std::_Head_base.4" }
%"struct.std::_Tuple_impl.2" = type { %"struct.std::_Head_base" }
%"struct.std::_Head_base" = type { i8 }
%"struct.std::_Head_base.4" = type { i8 }
%"struct.std::_Head_base.5" = type { i8 }
%"struct.std::_Head_base.6" = type { i8 }

define zeroext i1 @opeq(
; CHECK-LABEL: @opeq(
;
; These 2 instructions are split. Then we can merge 3 bytes, instead of 2.
; CHECK:         br label [[LAND_ELEM0:%.*]]
; CHECK:       land.elem1:
; CHECK-NEXT:    [[A_ELEM1_ADDR:%.*]] = getelementptr inbounds i8, i8* %a.base, i64 1
; CHECK-NEXT:    [[B_ELEM1_ADDR:%.*]] = getelementptr inbounds i8, i8* %b.base, i64 1
; CHECK-NEXT:    [[MEMCMP:%.*]] = call i32 @memcmp(i8* [[A_ELEM1_ADDR]], i8* [[B_ELEM1_ADDR]], i64 3)
; CHECK-NEXT:    [[TMP2:%.*]] = icmp eq i32 [[MEMCMP]], 0
; CHECK-NEXT:    br label [[OPEQ_EXIT:%.*]]
; CHECK:       land.elem0:
; CHECK:         [[A_BASE:%.*]] = getelementptr inbounds %"class.std::tuple", %"class.std::tuple"* [[A:%.*]], i64 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0
; CHECK:         [[B_BASE:%.*]] = getelementptr inbounds %"class.std::tuple", %"class.std::tuple"* [[B:%.*]], i64 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0 
; CHECK-NEXT:    [[TMP3:%.*]] = load i8, i8* [[A_BASE]], align 1
; CHECK-NEXT:    [[TMP4:%.*]] = load i8, i8* [[B_BASE]], align 1
; CHECK-NEXT:    [[CMP_ELEM0:%.*]] = icmp eq i8 [[TMP3]], [[TMP4]]
; CHECK-NEXT:    br i1 [[CMP_ELEM0]], label [[LAND_ELEM1:%.*]], label [[OPEQ_EXIT]]
; CHECK:       opeq.exit:
; CHECK-NEXT:    [[TMP5:%.*]] = phi i1 [ [[CMP_ELEM0]], [[LAND_ELEM0]] ], [ [[TMP2]], [[LAND_ELEM1]] ]
; CHECK-NEXT:    ret i1 [[TMP5]]
;
  %"class.std::tuple"* nocapture readonly dereferenceable(4) %a,
  %"class.std::tuple"* nocapture readonly dereferenceable(4) %b) local_unnamed_addr #1 {
entry:
  %a.base = getelementptr inbounds %"class.std::tuple", %"class.std::tuple"* %a, i64 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0
  %a.elem3.addr = getelementptr inbounds i8, i8* %a.base, i64 3
  %0 = load i8, i8* %a.elem3.addr, align 1
  %b.base = getelementptr inbounds %"class.std::tuple", %"class.std::tuple"* %b, i64 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0
  %b.elem3.addr = getelementptr inbounds i8, i8* %b.base, i64 3
  %1 = load i8, i8* %b.elem3.addr, align 1
  %cmp.elem3 = icmp eq i8 %0, %1
  br i1 %cmp.elem3, label %land.elem2, label %opeq.exit

land.elem2:
  %a.elem2.addr = getelementptr inbounds i8, i8* %a.base, i64 2
  %2 = load i8, i8* %a.elem2.addr, align 1
  %b.elem2.addr = getelementptr inbounds i8, i8* %b.base, i64 2
  %3 = load i8, i8* %b.elem2.addr, align 1
  %cmp.elem2 = icmp eq i8 %2, %3
  br i1 %cmp.elem2, label %land.elem1, label %opeq.exit

land.elem1:
  %a.elem1.addr = getelementptr inbounds i8, i8* %a.base, i64 1
  %4 = load i8, i8* %a.elem1.addr, align 1
  %b.elem1.addr = getelementptr inbounds i8, i8* %b.base, i64 1
  %5 = load i8, i8* %b.elem1.addr, align 1
  %cmp.elem1 = icmp eq i8 %4, %5
  br i1 %cmp.elem1, label %land.elem0, label %opeq.exit

land.elem0:
  %6 = load i8, i8* %a.base, align 1
  %7 = load i8, i8* %b.base, align 1
  %cmp.elem0 = icmp eq i8 %6, %7
  br label %opeq.exit

opeq.exit:
  %8 = phi i1 [ false, %entry ], [ false, %land.elem2 ], [ false, %land.elem1 ], [ %cmp.elem0, %land.elem0 ]
  ret i1 %8
}

