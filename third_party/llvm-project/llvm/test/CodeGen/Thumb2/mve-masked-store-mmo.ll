; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=thumbv8.1m.main-none-none-eabi -mattr=+mve -verify-machineinstrs %s -o - | FileCheck %s

define i32 @incorrectmmo() {
; CHECK-LABEL: incorrectmmo:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    .pad #12
; CHECK-NEXT:    sub sp, #12
; CHECK-NEXT:    movw r0, #1023
; CHECK-NEXT:    vmsr p0, r0
; CHECK-NEXT:    adr r0, .LCPI0_0
; CHECK-NEXT:    vldrw.u32 q0, [r0]
; CHECK-NEXT:    add.w r0, sp, #2
; CHECK-NEXT:    vpst
; CHECK-NEXT:    vstrbt.8 q0, [r0]
; CHECK-NEXT:    ldrb.w r0, [sp, #2]
; CHECK-NEXT:    ldrb.w r1, [sp, #3]
; CHECK-NEXT:    ldrb.w r2, [sp, #4]
; CHECK-NEXT:    add r0, r1
; CHECK-NEXT:    ldrb.w r3, [sp, #10]
; CHECK-NEXT:    add r0, r2
; CHECK-NEXT:    ldrb.w r1, [sp, #11]
; CHECK-NEXT:    add r0, r3
; CHECK-NEXT:    add r0, r1
; CHECK-NEXT:    add sp, #12
; CHECK-NEXT:    bx lr
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  @ %bb.1:
; CHECK-NEXT:  .LCPI0_0:
; CHECK-NEXT:    .byte 0 @ 0x0
; CHECK-NEXT:    .byte 1 @ 0x1
; CHECK-NEXT:    .byte 2 @ 0x2
; CHECK-NEXT:    .byte 3 @ 0x3
; CHECK-NEXT:    .byte 4 @ 0x4
; CHECK-NEXT:    .byte 5 @ 0x5
; CHECK-NEXT:    .byte 6 @ 0x6
; CHECK-NEXT:    .byte 7 @ 0x7
; CHECK-NEXT:    .byte 8 @ 0x8
; CHECK-NEXT:    .byte 9 @ 0x9
; CHECK-NEXT:    .zero 1
; CHECK-NEXT:    .zero 1
; CHECK-NEXT:    .zero 1
; CHECK-NEXT:    .zero 1
; CHECK-NEXT:    .zero 1
; CHECK-NEXT:    .zero 1
entry:
  %x = alloca [10 x i8], align 1
  %0 = getelementptr inbounds [10 x i8], [10 x i8]* %x, i32 0, i32 0
  call void @llvm.lifetime.start.p0i8(i64 10, i8* nonnull %0)
  %1 = bitcast [10 x i8]* %x to <16 x i8>*
  call void @llvm.masked.store.v16i8.p0v16i8(<16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 4, i8 5, i8 6, i8 7, i8 8, i8 9, i8 poison, i8 poison, i8 poison, i8 poison, i8 poison, i8 poison>, <16 x i8>* %1, i32 1, <16 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false>)
  %2 = load i8, i8* %0, align 1
  %conv1 = zext i8 %2 to i32
  %arrayidx2 = getelementptr inbounds [10 x i8], [10 x i8]* %x, i32 0, i32 1
  %3 = load i8, i8* %arrayidx2, align 1
  %conv3 = zext i8 %3 to i32
  %add = add nuw nsw i32 %conv3, %conv1
  %arrayidx4 = getelementptr inbounds [10 x i8], [10 x i8]* %x, i32 0, i32 2
  %4 = load i8, i8* %arrayidx4, align 1
  %conv5 = zext i8 %4 to i32
  %add6 = add nuw nsw i32 %add, %conv5
  %arrayidx7 = getelementptr inbounds [10 x i8], [10 x i8]* %x, i32 0, i32 8
  %5 = load i8, i8* %arrayidx7, align 1
  %conv8 = zext i8 %5 to i32
  %add9 = add nuw nsw i32 %add6, %conv8
  %arrayidx10 = getelementptr inbounds [10 x i8], [10 x i8]* %x, i32 0, i32 9
  %6 = load i8, i8* %arrayidx10, align 1
  %conv11 = zext i8 %6 to i32
  %add12 = add nuw nsw i32 %add9, %conv11
  call void @llvm.lifetime.end.p0i8(i64 10, i8* nonnull %0)
  ret i32 %add12
}

declare void @llvm.masked.store.v16i8.p0v16i8(<16 x i8>, <16 x i8>*, i32, <16 x i1>)
declare void @llvm.lifetime.start.p0i8(i64 immarg, i8* nocapture)
declare void @llvm.lifetime.end.p0i8(i64 immarg, i8* nocapture)
