# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
# RUN: llc -o - %s -mtriple=thumbv8.1m.main-none-none-eabi -run-pass=prologepilog | FileCheck %s
--- |
  ; Function Attrs: noinline nounwind optnone
  define dso_local i64 @f() #0 {
  entry:
    %a = alloca [10 x i64], align 8
    %arrayidx = getelementptr inbounds [10 x i64], [10 x i64]* %a, i32 0, i32 1
    store volatile i64 1, i64* %arrayidx, align 8
    %arrayidx1 = getelementptr inbounds [10 x i64], [10 x i64]* %a, i32 0, i32 1
    %0 = load volatile i64, i64* %arrayidx1, align 8
    ret i64 %0
  }

...
---
name:            f
alignment:       2
tracksRegLiveness: true
frameInfo:
  maxAlignment:    8
  maxCallFrameSize: 0
  localFrameSize:  80
stack:
  - { id: 0, name: a, size: 80, alignment: 8, local-offset: -80 }
machineFunctionInfo: {}
body:             |
  bb.0.entry:
    ; CHECK-LABEL: name: f
    ; CHECK: $sp = frame-setup tSUBspi $sp, 20, 14 /* CC::al */, $noreg
    ; CHECK: frame-setup CFI_INSTRUCTION def_cfa_offset 80
    ; CHECK: renamable $r0 = t2MOVi 0, 14 /* CC::al */, $noreg, $noreg
    ; CHECK: renamable $r1 = t2MOVi 1, 14 /* CC::al */, $noreg, $noreg
    ; CHECK: t2STRDi8 killed $r1, killed $r0, $sp, 8, 14 /* CC::al */, $noreg :: (volatile store (s64) into %ir.arrayidx)
    ; CHECK: $r0, $r1 = t2LDRDi8 $sp, 8, 14 /* CC::al */, $noreg :: (volatile dereferenceable load (s64) from %ir.arrayidx1)
    ; CHECK: $sp = frame-destroy tADDspi $sp, 20, 14 /* CC::al */, $noreg
    ; CHECK: tBX_RET 14 /* CC::al */, $noreg, implicit $r0, implicit $r1
    renamable $r0 = t2MOVi 0, 14 /* CC::al */, $noreg, $noreg
    renamable $r1 = t2MOVi 1, 14 /* CC::al */, $noreg, $noreg
    t2STRDi8 killed $r1, killed $r0, %stack.0.a, 8, 14 /* CC::al */, $noreg :: (volatile store (s64) into %ir.arrayidx)
    $r0, $r1 = t2LDRDi8 %stack.0.a, 8, 14 /* CC::al */, $noreg :: (volatile dereferenceable load (s64) from %ir.arrayidx1)
    tBX_RET 14 /* CC::al */, $noreg, implicit $r0, implicit $r1

...
