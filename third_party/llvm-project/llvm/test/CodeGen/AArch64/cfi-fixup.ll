; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=aarch64-linux %s -o - | FileCheck %s

define i32 @f0(i32 %x) #0 {
; CHECK-LABEL: f0:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    .cfi_offset w30, -16
; CHECK-NEXT:    .cfi_remember_state
; CHECK-NEXT:    cbz w0, .LBB0_4
; CHECK-NEXT:  // %bb.1: // %entry
; CHECK-NEXT:    cmp w0, #2
; CHECK-NEXT:    b.eq .LBB0_5
; CHECK-NEXT:  // %bb.2: // %entry
; CHECK-NEXT:    cmp w0, #1
; CHECK-NEXT:    b.ne .LBB0_6
; CHECK-NEXT:  // %bb.3: // %if.then2
; CHECK-NEXT:    bl g1
; CHECK-NEXT:    add w0, w0, #1
; CHECK-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .cfi_def_cfa_offset 0
; CHECK-NEXT:    .cfi_restore w30
; CHECK-NEXT:    ret
; CHECK-NEXT:  .LBB0_4:
; CHECK-NEXT:    .cfi_restore_state
; CHECK-NEXT:    .cfi_remember_state
; CHECK-NEXT:    mov w0, #1
; CHECK-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .cfi_def_cfa_offset 0
; CHECK-NEXT:    .cfi_restore w30
; CHECK-NEXT:    ret
; CHECK-NEXT:  .LBB0_5: // %if.then5
; CHECK-NEXT:    .cfi_restore_state
; CHECK-NEXT:    .cfi_remember_state
; CHECK-NEXT:    bl g0
; CHECK-NEXT:    mov w8, #1
; CHECK-NEXT:    sub w0, w8, w0
; CHECK-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .cfi_def_cfa_offset 0
; CHECK-NEXT:    .cfi_restore w30
; CHECK-NEXT:    ret
; CHECK-NEXT:  .LBB0_6: // %if.end7
; CHECK-NEXT:    .cfi_restore_state
; CHECK-NEXT:    mov w0, wzr
; CHECK-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .cfi_def_cfa_offset 0
; CHECK-NEXT:    .cfi_restore w30
; CHECK-NEXT:    ret
entry:
  switch i32 %x, label %if.end7 [
    i32 0, label %return
    i32 1, label %if.then2
    i32 2, label %if.then5
  ]

if.then2:
  %call = tail call i32 @g1(i32 1)
  %add = add nsw i32 %call, 1
  br label %return

if.then5:
  %call6 = tail call i32 @g0(i32 2)
  %sub = sub nsw i32 1, %call6
  br label %return

if.end7:
  br label %return

return:
  %retval.0 = phi i32 [ %add, %if.then2 ], [ %sub, %if.then5 ], [ 0, %if.end7 ], [ 1, %entry ]
  ret i32 %retval.0
}

declare i32 @g1(i32)

declare i32 @g0(i32)

define i32 @f1(i32 %x) #0 {
; CHECK-LABEL: f1:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    cbz w0, .LBB1_2
; CHECK-NEXT:  // %bb.1: // %if.end
; CHECK-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    .cfi_offset w30, -16
; CHECK-NEXT:    bl g0
; CHECK-NEXT:    add w0, w0, #1
; CHECK-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .cfi_def_cfa_offset 0
; CHECK-NEXT:    .cfi_restore w30
; CHECK-NEXT:  .LBB1_2: // %return
; CHECK-NEXT:    ret
entry:
  %cmp = icmp eq i32 %x, 0
  br i1 %cmp, label %return, label %if.end

if.end:
  %call = tail call i32 @g0(i32 %x)
  %add = add nsw i32 %call, 1
  br label %return

return:
  %retval.0 = phi i32 [ %add, %if.end ], [ 0, %entry ]
  ret i32 %retval.0
}

define i32 @f2(i32 %x) #0 {
; CHECK-LABEL: f2:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    .cfi_offset w30, -16
; CHECK-NEXT:    .cfi_remember_state
; CHECK-NEXT:    cbz w0, .LBB2_2
; CHECK-NEXT:  // %bb.1: // %if.end
; CHECK-NEXT:    bl g1
; CHECK-NEXT:    mov w8, #1
; CHECK-NEXT:    sub w0, w8, w0
; CHECK-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .cfi_def_cfa_offset 0
; CHECK-NEXT:    .cfi_restore w30
; CHECK-NEXT:    ret
; CHECK-NEXT:  .LBB2_2: // %if.then
; CHECK-NEXT:    .cfi_restore_state
; CHECK-NEXT:    bl g0
; CHECK-NEXT:    add w0, w0, #1
; CHECK-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .cfi_def_cfa_offset 0
; CHECK-NEXT:    .cfi_restore w30
; CHECK-NEXT:    ret
entry:
  %cmp = icmp eq i32 %x, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:
  %call = tail call i32 @g0(i32 0)
  %add = add nsw i32 %call, 1
  br label %return

if.end:
  %call1 = tail call i32 @g1(i32 %x)
  %sub = sub nsw i32 1, %call1
  br label %return

return:
  %retval.0 = phi i32 [ %add, %if.then ], [ %sub, %if.end ]
  ret i32 %retval.0
}

attributes #0 = { uwtable }
