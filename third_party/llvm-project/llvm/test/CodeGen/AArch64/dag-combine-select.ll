; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple arm64-none-eabi -o - %s | FileCheck %s

@out = internal global i32 0, align 4

; Ensure that we transform select(C0, x, select(C1, x, y)) towards
; select(C0 | C1, x, y) so we can use CMP;CCMP for the implementation.
define i32 @test0(i32 %v0, i32 %v1, i32 %v2) {
; CHECK-LABEL: test0:
; CHECK:       // %bb.0:
; CHECK-NEXT:    cmp w0, #7
; CHECK-NEXT:    ccmp w1, #0, #0, ne
; CHECK-NEXT:    csel w0, w1, w2, gt
; CHECK-NEXT:    ret
  %cmp1 = icmp eq i32 %v0, 7
  %cmp2 = icmp sgt i32 %v1, 0
  %sel0 = select i1 %cmp1, i32 %v1, i32 %v2
  %sel1 = select i1 %cmp2, i32 %v1, i32 %sel0
  ret i32 %sel1
}

; Usually we keep select(C0 | C1, x, y) as is on aarch64 to create CMP;CCMP
; sequences. This case should be transformed to select(C0, select(C1, x, y), y)
; anyway to get CSE effects.
define void @test1(i32 %bitset, i32 %val0, i32 %val1) {
; CHECK-LABEL: test1:
; CHECK:       // %bb.0:
; CHECK-NEXT:    cmp w0, #7
; CHECK-NEXT:    adrp x8, out
; CHECK-NEXT:    csel w9, w1, w2, eq
; CHECK-NEXT:    cmp w9, #13
; CHECK-NEXT:    csel w9, w1, w2, lo
; CHECK-NEXT:    cmp w0, #42
; CHECK-NEXT:    csel w10, w1, w9, eq
; CHECK-NEXT:    str w9, [x8, :lo12:out]
; CHECK-NEXT:    str w10, [x8, :lo12:out]
; CHECK-NEXT:    ret
  %cmp1 = icmp eq i32 %bitset, 7
  %cond = select i1 %cmp1, i32 %val0, i32 %val1
  %cmp5 = icmp ult i32 %cond, 13
  %cond11 = select i1 %cmp5, i32 %val0, i32 %val1
  %cmp3 = icmp eq i32 %bitset, 42
  %or.cond = or i1 %cmp3, %cmp5
  %cond17 = select i1 %or.cond, i32 %val0, i32 %val1
  store volatile i32 %cond11, i32* @out, align 4
  store volatile i32 %cond17, i32* @out, align 4
  ret void
}
