; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=aarch64-linux-gnu -mattr=+sve < %s | FileCheck %s

define <vscale x 2 x i64> @sti64ldi64(<vscale x 2 x i64>* nocapture %P, <vscale x 2 x i64> %v) {
; CHECK-LABEL: sti64ldi64:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    ptrue p0.d
; CHECK-NEXT:    st1d { z0.d }, p0, [x0, #1, mul vl]
; CHECK-NEXT:    ret
entry:
  %arrayidx0 = getelementptr inbounds <vscale x 2 x i64>, <vscale x 2 x i64>* %P, i64 1
  store <vscale x 2 x i64> %v, <vscale x 2 x i64>* %arrayidx0
  %arrayidx1 = getelementptr inbounds <vscale x 2 x i64>, <vscale x 2 x i64>* %P, i64 1
  %0 = load <vscale x 2 x i64>, <vscale x 2 x i64>* %arrayidx1
  ret <vscale x 2 x i64> %0
}

define <vscale x 2 x double> @stf64ldf64(<vscale x 2 x double>* nocapture %P, <vscale x 2 x double> %v) {
; CHECK-LABEL: stf64ldf64:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    ptrue p0.d
; CHECK-NEXT:    st1d { z0.d }, p0, [x0, #1, mul vl]
; CHECK-NEXT:    ret
entry:
  %arrayidx0 = getelementptr inbounds <vscale x 2 x double>, <vscale x 2 x double>* %P, i64 1
  store <vscale x 2 x double> %v, <vscale x 2 x double>* %arrayidx0
  %arrayidx1 = getelementptr inbounds <vscale x 2 x double>, <vscale x 2 x double>* %P, i64 1
  %0 = load <vscale x 2 x double>, <vscale x 2 x double>* %arrayidx1
  ret <vscale x 2 x double> %0
}

define <vscale x 2 x i64> @sti32ldi32ext(<vscale x 2 x i32>* nocapture %P, <vscale x 2 x i64> %v) {
; CHECK-LABEL: sti32ldi32ext:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    ptrue p0.d
; CHECK-NEXT:    mov z1.d, z0.d
; CHECK-NEXT:    sxtw z0.d, p0/m, z0.d
; CHECK-NEXT:    st1w { z1.d }, p0, [x0]
; CHECK-NEXT:    ret
entry:
  %0 = trunc <vscale x 2 x i64> %v to <vscale x 2 x i32>
  store <vscale x 2 x i32> %0, <vscale x 2 x i32>* %P
  %1 = load <vscale x 2 x i32>, <vscale x 2 x i32>* %P
  %2 = sext <vscale x 2 x i32> %1 to <vscale x 2 x i64>
  ret <vscale x 2 x i64> %2
}

define <2 x i64> @sti64ldfixedi64(<vscale x 2 x i64>* nocapture %P, <vscale x 2 x i64> %v) {
; CHECK-LABEL: sti64ldfixedi64:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    ptrue p0.d
; CHECK-NEXT:    rdvl x8, #1
; CHECK-NEXT:    st1d { z0.d }, p0, [x0, #1, mul vl]
; CHECK-NEXT:    ldr q0, [x0, x8]
; CHECK-NEXT:    ret
entry:
  %arrayidx0 = getelementptr inbounds <vscale x 2 x i64>, <vscale x 2 x i64>* %P, i64 1
  store <vscale x 2 x i64> %v, <vscale x 2 x i64>* %arrayidx0
  %arrayidx1 = bitcast <vscale x 2 x i64>* %arrayidx0 to <2 x i64>*
  %0 = load <2 x i64>, <2 x i64>* %arrayidx1
  ret <2 x i64> %0
}

define <vscale x 4 x i32> @sti64ldi32(<vscale x 2 x i64>* nocapture %P, <vscale x 2 x i64> %v) {
; CHECK-LABEL: sti64ldi32:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    ptrue p0.d
; CHECK-NEXT:    st1d { z0.d }, p0, [x0, #1, mul vl]
; CHECK-NEXT:    ptrue p0.s
; CHECK-NEXT:    ld1w { z0.s }, p0/z, [x0, #1, mul vl]
; CHECK-NEXT:    ret
entry:
  %0 = bitcast <vscale x 2 x i64>* %P to <vscale x 4 x i32>*
  %arrayidx0 = getelementptr inbounds <vscale x 2 x i64>, <vscale x 2 x i64>* %P, i64 1
  store <vscale x 2 x i64> %v, <vscale x 2 x i64>* %arrayidx0
  %arrayidx1 = getelementptr inbounds <vscale x 4 x i32>, <vscale x 4 x i32>* %0, i64 1
  %1 = load <vscale x 4 x i32>, <vscale x 4 x i32>* %arrayidx1
  ret <vscale x 4 x i32> %1
}

define <vscale x 2 x i64> @stf64ldi64(<vscale x 2 x double>* nocapture %P, <vscale x 2 x double> %v) {
; CHECK-LABEL: stf64ldi64:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    ptrue p0.d
; CHECK-NEXT:    st1d { z0.d }, p0, [x0, #1, mul vl]
; CHECK-NEXT:    ld1d { z0.d }, p0/z, [x0, #1, mul vl]
; CHECK-NEXT:    ret
entry:
  %0 = bitcast <vscale x 2 x double>* %P to <vscale x 2 x i64>*
  %arrayidx0 = getelementptr inbounds <vscale x 2 x double>, <vscale x 2 x double>* %P, i64 1
  store <vscale x 2 x double> %v, <vscale x 2 x double>* %arrayidx0
  %arrayidx1 = getelementptr inbounds <vscale x 2 x i64>, <vscale x 2 x i64>* %0, i64 1
  %1 = load <vscale x 2 x i64>, <vscale x 2 x i64>* %arrayidx1
  ret <vscale x 2 x i64> %1
}
