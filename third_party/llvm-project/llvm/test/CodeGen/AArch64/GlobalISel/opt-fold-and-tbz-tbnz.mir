# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
# RUN: llc -mtriple aarch64-unknown-unknown -run-pass=instruction-select -global-isel-abort=1 -verify-machineinstrs %s -o - | FileCheck %s
#
# Check folding an AND into a G_BRCOND which has been matched as a TB(N)Z.
...
---
name:            fold_and_rhs
alignment:       4
legalized:       true
regBankSelected: true
body:             |
  ; CHECK-LABEL: name: fold_and_rhs
  ; CHECK: bb.0:
  ; CHECK:   successors: %bb.0(0x40000000), %bb.1(0x40000000)
  ; CHECK:   %copy:gpr64all = COPY $x0
  ; CHECK:   [[COPY:%[0-9]+]]:gpr32all = COPY %copy.sub_32
  ; CHECK:   [[COPY1:%[0-9]+]]:gpr32 = COPY [[COPY]]
  ; CHECK:   TBNZW [[COPY1]], 3, %bb.1
  ; CHECK:   B %bb.0
  ; CHECK: bb.1:
  ; CHECK:   RET_ReallyLR
  bb.0:
    successors: %bb.0, %bb.1
    liveins: $x0
    %copy:gpr(s64) = COPY $x0
    %bit:gpr(s64) = G_CONSTANT i64 8
    %zero:gpr(s64) = G_CONSTANT i64 0
    %fold_cst:gpr(s64) = G_CONSTANT i64 8

    ; tbnz (and x, 8), 3 == tbnz x, 3 because the third bit of x & 8 is 1 when
    ; the third bit of x is 1.
    %fold_me:gpr(s64) = G_AND %copy, %fold_cst

    %and:gpr(s64) = G_AND %fold_me, %bit
    %cmp:gpr(s32) = G_ICMP intpred(ne), %and(s64), %zero
    %cmp_trunc:gpr(s1) = G_TRUNC %cmp(s32)
    G_BRCOND %cmp_trunc(s1), %bb.1
    G_BR %bb.0
  bb.1:
    RET_ReallyLR
...
---
name:            fold_and_lhs
alignment:       4
legalized:       true
regBankSelected: true
body:             |
  ; CHECK-LABEL: name: fold_and_lhs
  ; CHECK: bb.0:
  ; CHECK:   successors: %bb.0(0x40000000), %bb.1(0x40000000)
  ; CHECK:   %copy:gpr64all = COPY $x0
  ; CHECK:   [[COPY:%[0-9]+]]:gpr32all = COPY %copy.sub_32
  ; CHECK:   [[COPY1:%[0-9]+]]:gpr32 = COPY [[COPY]]
  ; CHECK:   TBNZW [[COPY1]], 3, %bb.1
  ; CHECK:   B %bb.0
  ; CHECK: bb.1:
  ; CHECK:   RET_ReallyLR
  bb.0:
    successors: %bb.0, %bb.1
    liveins: $x0
    %copy:gpr(s64) = COPY $x0
    %bit:gpr(s64) = G_CONSTANT i64 8
    %zero:gpr(s64) = G_CONSTANT i64 0
    %fold_cst:gpr(s64) = G_CONSTANT i64 8

    ; Same as above, but with the constant on the other side.
    %fold_me:gpr(s64) = G_AND %fold_cst, %copy

    %and:gpr(s64) = G_AND %fold_me, %bit
    %cmp:gpr(s32) = G_ICMP intpred(ne), %and(s64), %zero
    %cmp_trunc:gpr(s1) = G_TRUNC %cmp(s32)
    G_BRCOND %cmp_trunc(s1), %bb.1
    G_BR %bb.0
  bb.1:
    RET_ReallyLR
...
---
name:            dont_fold_and
alignment:       4
legalized:       true
regBankSelected: true
body:             |
  ; CHECK-LABEL: name: dont_fold_and
  ; CHECK: bb.0:
  ; CHECK:   successors: %bb.0(0x40000000), %bb.1(0x40000000)
  ; CHECK:   %copy:gpr64 = COPY $x0
  ; CHECK:   %fold_me:gpr64sp = ANDXri %copy, 4098
  ; CHECK:   [[COPY:%[0-9]+]]:gpr32all = COPY %fold_me.sub_32
  ; CHECK:   [[COPY1:%[0-9]+]]:gpr32 = COPY [[COPY]]
  ; CHECK:   TBNZW [[COPY1]], 3, %bb.1
  ; CHECK:   B %bb.0
  ; CHECK: bb.1:
  ; CHECK:   RET_ReallyLR
  bb.0:
    successors: %bb.0, %bb.1
    liveins: $x0
    %copy:gpr(s64) = COPY $x0
    %bit:gpr(s64) = G_CONSTANT i64 8
    %zero:gpr(s64) = G_CONSTANT i64 0

    ; tbnz (and x, 7), 3 != tbnz x, 3, because the third bit of x & 7 is always
    ; zero.
    %fold_cst:gpr(s64) = G_CONSTANT i64 7

    %fold_me:gpr(s64) = G_AND %copy, %fold_cst
    %and:gpr(s64) = G_AND %fold_me, %bit
    %cmp:gpr(s32) = G_ICMP intpred(ne), %and(s64), %zero
    %cmp_trunc:gpr(s1) = G_TRUNC %cmp(s32)
    G_BRCOND %cmp_trunc(s1), %bb.1
    G_BR %bb.0
  bb.1:
    RET_ReallyLR
