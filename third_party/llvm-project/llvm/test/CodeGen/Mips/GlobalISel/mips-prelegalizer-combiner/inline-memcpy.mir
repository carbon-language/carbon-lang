# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
# RUN: llc -O0 -mtriple=mipsel-linux-gnu -run-pass=mips-prelegalizer-combiner -verify-machineinstrs %s -o - | FileCheck %s -check-prefixes=MIPS32
--- |
  ; ModuleID = '../llvm/test/CodeGen/Mips/GlobalISel/mips-prelegalizer-combiner/inline-memcpy.ll'
  source_filename = "../llvm/test/CodeGen/Mips/GlobalISel/mips-prelegalizer-combiner/inline-memcpy.ll"
  target datalayout = "e-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64"
  target triple = "mipsel-pc-linux-gnu"

  declare void @llvm.memcpy.inline.p0i8.p0i8.i64(i8* noalias nocapture writeonly, i8* noalias nocapture readonly, i64 immarg, i1 immarg) #0

  define void @test_memcpy_inline(i32* nocapture %dst, i32* nocapture readonly %src) local_unnamed_addr {
  entry:
    %0 = bitcast i32* %dst to i8*
    %1 = bitcast i32* %src to i8*
    tail call void @llvm.memcpy.inline.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 2, i1 false)
    ret void
  }

  attributes #0 = { argmemonly nofree nounwind willreturn }

...
---
name:            test_memcpy_inline
alignment:       4
tracksRegLiveness: true
registers:
  - { id: 0, class: _ }
  - { id: 1, class: _ }
  - { id: 2, class: _ }
  - { id: 3, class: _ }
liveins:
  - { reg: '$a0' }
  - { reg: '$a1' }
frameInfo:
  maxAlignment:    1
machineFunctionInfo: {}
body:             |
  bb.1.entry:
    liveins: $a0, $a1

    ; MIPS32-LABEL: name: test_memcpy_inline
    ; MIPS32: liveins: $a0, $a1
    ; MIPS32: [[COPY:%[0-9]+]]:_(p0) = COPY $a0
    ; MIPS32: [[COPY1:%[0-9]+]]:_(p0) = COPY $a1
    ; MIPS32: [[LOAD:%[0-9]+]]:_(s8) = G_LOAD [[COPY1]](p0) :: (load (s8) from %ir.1, align 4)
    ; MIPS32: G_STORE [[LOAD]](s8), [[COPY]](p0) :: (store (s8) into %ir.0, align 4)
    ; MIPS32: [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 1
    ; MIPS32: [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY1]], [[C]](s32)
    ; MIPS32: [[LOAD1:%[0-9]+]]:_(s8) = G_LOAD [[PTR_ADD]](p0) :: (load (s8) from %ir.1 + 1, basealign 4)
    ; MIPS32: [[PTR_ADD1:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C]](s32)
    ; MIPS32: G_STORE [[LOAD1]](s8), [[PTR_ADD1]](p0) :: (store (s8) into %ir.0 + 1, basealign 4)
    ; MIPS32: RetRA
    %0:_(p0) = COPY $a0
    %1:_(p0) = COPY $a1
    %2:_(s64) = G_CONSTANT i64 2
    %3:_(s32) = G_TRUNC %2(s64)
    G_MEMCPY_INLINE %0(p0), %1(p0), %3(s32) :: (store (s8) into %ir.0, align 4), (load (s8) from %ir.1, align 4)
    RetRA

...
