# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
# RUN: llc -O0 -mtriple=mipsel-linux-gnu -run-pass=instruction-select -verify-machineinstrs %s -o - | FileCheck %s -check-prefixes=MIPS32
--- |

  @.str = private unnamed_addr constant [11 x i8] c"string %s\0A\00", align 1
  declare void @llvm.va_start(i8*) #0
  declare void @llvm.va_copy(i8*, i8*) #0
  declare i32 @printf(i8*, ...)

  define void @testVaCopyArg(i8* %fmt, ...) {
  entry:
    %fmt.addr = alloca i8*, align 4
    %ap = alloca i8*, align 4
    %aq = alloca i8*, align 4
    %s = alloca i8*, align 4
    store i8* %fmt, i8** %fmt.addr, align 4
    %ap1 = bitcast i8** %ap to i8*
    call void @llvm.va_start(i8* %ap1)
    %0 = bitcast i8** %aq to i8*
    %1 = bitcast i8** %ap to i8*
    call void @llvm.va_copy(i8* %0, i8* %1)
    %argp.cur = load i8*, i8** %aq, align 4
    %argp.next = getelementptr inbounds i8, i8* %argp.cur, i32 4
    store i8* %argp.next, i8** %aq, align 4
    %2 = bitcast i8* %argp.cur to i8**
    %3 = load i8*, i8** %2, align 4
    store i8* %3, i8** %s, align 4
    %4 = load i8*, i8** %s, align 4
    %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i32 0, i32 0), i8* %4)
    ret void
  }

...
---
name:            testVaCopyArg
alignment:       4
legalized:       true
regBankSelected: true
tracksRegLiveness: true
liveins:
  - { reg: '$a0' }
fixedStack:
  - { id: 0, offset: 12, size: 4, alignment: 4, isImmutable: true }
  - { id: 1, offset: 8, size: 4, alignment: 8, isImmutable: true }
  - { id: 2, offset: 4, size: 4, alignment: 4, isImmutable: true }
  - { id: 3, offset: 4, size: 4, alignment: 4, isImmutable: true }
stack:
  - { id: 0, name: fmt.addr, size: 4, alignment: 4 }
  - { id: 1, name: ap, size: 4, alignment: 4 }
  - { id: 2, name: aq, size: 4, alignment: 4 }
  - { id: 3, name: s, size: 4, alignment: 4 }
machineFunctionInfo: {}
body:             |
  bb.1.entry:
    liveins: $a0, $a1, $a2, $a3

    ; MIPS32-LABEL: name: testVaCopyArg
    ; MIPS32: liveins: $a0, $a1, $a2, $a3
    ; MIPS32: [[COPY:%[0-9]+]]:gpr32 = COPY $a0
    ; MIPS32: [[COPY1:%[0-9]+]]:gpr32 = COPY $a1
    ; MIPS32: [[ADDiu:%[0-9]+]]:gpr32 = ADDiu %fixed-stack.1, 0
    ; MIPS32: SW [[COPY1]], [[ADDiu]], 0 :: (store (s32) into %fixed-stack.1)
    ; MIPS32: [[COPY2:%[0-9]+]]:gpr32 = COPY $a2
    ; MIPS32: [[ADDiu1:%[0-9]+]]:gpr32 = ADDiu %fixed-stack.2, 0
    ; MIPS32: SW [[COPY2]], [[ADDiu1]], 0 :: (store (s32) into %fixed-stack.2)
    ; MIPS32: [[COPY3:%[0-9]+]]:gpr32 = COPY $a3
    ; MIPS32: [[ADDiu2:%[0-9]+]]:gpr32 = ADDiu %fixed-stack.3, 0
    ; MIPS32: SW [[COPY3]], [[ADDiu2]], 0 :: (store (s32) into %fixed-stack.3)
    ; MIPS32: [[LUi:%[0-9]+]]:gpr32 = LUi target-flags(mips-abs-hi) @.str
    ; MIPS32: [[ADDiu3:%[0-9]+]]:gpr32 = ADDiu [[LUi]], target-flags(mips-abs-lo) @.str
    ; MIPS32: [[ADDiu4:%[0-9]+]]:gpr32 = ADDiu %stack.0.fmt.addr, 0
    ; MIPS32: [[ADDiu5:%[0-9]+]]:gpr32 = ADDiu %stack.1.ap, 0
    ; MIPS32: [[ADDiu6:%[0-9]+]]:gpr32 = ADDiu %stack.2.aq, 0
    ; MIPS32: [[ADDiu7:%[0-9]+]]:gpr32 = ADDiu %stack.3.s, 0
    ; MIPS32: SW [[COPY]], [[ADDiu4]], 0 :: (store (p0) into %ir.fmt.addr)
    ; MIPS32: [[LEA_ADDiu:%[0-9]+]]:gpr32 = LEA_ADDiu %stack.0.fmt.addr, 0
    ; MIPS32: SW [[LEA_ADDiu]], [[ADDiu5]], 0
    ; MIPS32: [[LW:%[0-9]+]]:gpr32 = LW [[ADDiu5]], 0 :: (load (s32))
    ; MIPS32: SW [[LW]], [[ADDiu6]], 0 :: (store (s32))
    ; MIPS32: [[LW1:%[0-9]+]]:gpr32 = LW [[ADDiu6]], 0 :: (load (p0) from %ir.aq)
    ; MIPS32: [[ORi:%[0-9]+]]:gpr32 = ORi $zero, 4
    ; MIPS32: [[ADDu:%[0-9]+]]:gpr32 = ADDu [[LW1]], [[ORi]]
    ; MIPS32: SW [[ADDu]], [[ADDiu6]], 0 :: (store (p0) into %ir.aq)
    ; MIPS32: [[LW2:%[0-9]+]]:gpr32 = LW [[LW1]], 0 :: (load (p0) from %ir.2)
    ; MIPS32: SW [[LW2]], [[ADDiu7]], 0 :: (store (p0) into %ir.s)
    ; MIPS32: [[LW3:%[0-9]+]]:gpr32 = LW [[ADDiu7]], 0 :: (load (p0) from %ir.s)
    ; MIPS32: ADJCALLSTACKDOWN 16, 0, implicit-def $sp, implicit $sp
    ; MIPS32: $a0 = COPY [[ADDiu3]]
    ; MIPS32: $a1 = COPY [[LW3]]
    ; MIPS32: JAL @printf, csr_o32, implicit-def $ra, implicit-def $sp, implicit $a0, implicit $a1, implicit-def $v0
    ; MIPS32: ADJCALLSTACKUP 16, 0, implicit-def $sp, implicit $sp
    ; MIPS32: RetRA
    %0:gprb(p0) = COPY $a0
    %1:gprb(s32) = COPY $a1
    %2:gprb(p0) = G_FRAME_INDEX %fixed-stack.2
    G_STORE %1(s32), %2(p0) :: (store (s32) into %fixed-stack.2)
    %3:gprb(s32) = COPY $a2
    %4:gprb(p0) = G_FRAME_INDEX %fixed-stack.1
    G_STORE %3(s32), %4(p0) :: (store (s32) into %fixed-stack.1)
    %5:gprb(s32) = COPY $a3
    %6:gprb(p0) = G_FRAME_INDEX %fixed-stack.0
    G_STORE %5(s32), %6(p0) :: (store (s32) into %fixed-stack.0)
    %18:gprb(p0) = G_GLOBAL_VALUE @.str
    %17:gprb(p0) = COPY %18(p0)
    %7:gprb(p0) = G_FRAME_INDEX %stack.0.fmt.addr
    %8:gpr32(p0) = G_FRAME_INDEX %stack.1.ap
    %9:gpr32(p0) = G_FRAME_INDEX %stack.2.aq
    %10:gprb(p0) = G_FRAME_INDEX %stack.3.s
    G_STORE %0(p0), %7(p0) :: (store (p0) into %ir.fmt.addr)
    G_VASTART %8(p0) :: (store (p0) into %ir.ap1, align 1)
    %19:gpr32 = LW %8(p0), 0 :: (load (s32))
    SW %19, %9(p0), 0 :: (store (s32))
    %11:gprb(p0) = G_LOAD %9(p0) :: (load (p0) from %ir.aq)
    %12:gprb(s32) = G_CONSTANT i32 4
    %13:gprb(p0) = G_PTR_ADD %11, %12(s32)
    G_STORE %13(p0), %9(p0) :: (store (p0) into %ir.aq)
    %14:gprb(p0) = G_LOAD %11(p0) :: (load (p0) from %ir.2)
    G_STORE %14(p0), %10(p0) :: (store (p0) into %ir.s)
    %15:gprb(p0) = G_LOAD %10(p0) :: (load (p0) from %ir.s)
    ADJCALLSTACKDOWN 16, 0, implicit-def $sp, implicit $sp
    $a0 = COPY %17(p0)
    $a1 = COPY %15(p0)
    JAL @printf, csr_o32, implicit-def $ra, implicit-def $sp, implicit $a0, implicit $a1, implicit-def $v0
    ADJCALLSTACKUP 16, 0, implicit-def $sp, implicit $sp
    RetRA

...
