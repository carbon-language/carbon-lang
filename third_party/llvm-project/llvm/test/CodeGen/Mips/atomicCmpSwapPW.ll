; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -O0 -mtriple=mipsel-unknown-linux-gnu -mcpu=mips32r2 -target-abi=o32 < %s -filetype=asm -o - \
; RUN:   | FileCheck -check-prefixes=O32 %s
; RUN: llc -O0 -mtriple=mips64el-unknown-linux-gnu -mcpu=mips64r2 -target-abi=n32 < %s -filetype=asm -o - \
; RUN:   | FileCheck  -check-prefixes=N32 %s
; RUN: llc -O0 -mtriple=mips64el-unknown-linux-gnu -mcpu=mips64r2 -target-abi=n64 < %s -filetype=asm -o - \
; RUN:   | FileCheck -check-prefixes=N64 %s

@sym = external global i32 *

define void @foo(i32 %new, i32 %old) {
; O32-LABEL: foo:
; O32:       # %bb.0: # %entry
; O32-NEXT:    lui $1, %hi(sym)
; O32-NEXT:    lw $3, %lo(sym)($1)
; O32-NEXT:    sync
; O32-NEXT:  $BB0_1: # %entry
; O32-NEXT:    # =>This Inner Loop Header: Depth=1
; O32-NEXT:    ll $1, 0($3)
; O32-NEXT:    bne $1, $4, $BB0_3
; O32-NEXT:    nop
; O32-NEXT:  # %bb.2: # %entry
; O32-NEXT:    # in Loop: Header=BB0_1 Depth=1
; O32-NEXT:    move $2, $5
; O32-NEXT:    sc $2, 0($3)
; O32-NEXT:    beqz $2, $BB0_1
; O32-NEXT:    nop
; O32-NEXT:  $BB0_3: # %entry
; O32-NEXT:    sync
; O32-NEXT:    jr $ra
; O32-NEXT:    nop
;
; N32-LABEL: foo:
; N32:       # %bb.0: # %entry
; N32-NEXT:    move $1, $5
; N32-NEXT:    sll $5, $1, 0
; N32-NEXT:    move $1, $4
; N32-NEXT:    sll $4, $1, 0
; N32-NEXT:    lui $1, %hi(sym)
; N32-NEXT:    lw $3, %lo(sym)($1)
; N32-NEXT:    sync
; N32-NEXT:  .LBB0_1: # %entry
; N32-NEXT:    # =>This Inner Loop Header: Depth=1
; N32-NEXT:    ll $1, 0($3)
; N32-NEXT:    bne $1, $4, .LBB0_3
; N32-NEXT:    nop
; N32-NEXT:  # %bb.2: # %entry
; N32-NEXT:    # in Loop: Header=BB0_1 Depth=1
; N32-NEXT:    move $2, $5
; N32-NEXT:    sc $2, 0($3)
; N32-NEXT:    beqz $2, .LBB0_1
; N32-NEXT:    nop
; N32-NEXT:  .LBB0_3: # %entry
; N32-NEXT:    sync
; N32-NEXT:    jr $ra
; N32-NEXT:    nop
;
; N64-LABEL: foo:
; N64:       # %bb.0: # %entry
; N64-NEXT:    move $1, $5
; N64-NEXT:    sll $5, $1, 0
; N64-NEXT:    move $1, $4
; N64-NEXT:    sll $4, $1, 0
; N64-NEXT:    lui $1, %highest(sym)
; N64-NEXT:    daddiu $1, $1, %higher(sym)
; N64-NEXT:    dsll $1, $1, 16
; N64-NEXT:    daddiu $1, $1, %hi(sym)
; N64-NEXT:    dsll $1, $1, 16
; N64-NEXT:    ld $3, %lo(sym)($1)
; N64-NEXT:    sync
; N64-NEXT:  .LBB0_1: # %entry
; N64-NEXT:    # =>This Inner Loop Header: Depth=1
; N64-NEXT:    ll $1, 0($3)
; N64-NEXT:    bne $1, $4, .LBB0_3
; N64-NEXT:    nop
; N64-NEXT:  # %bb.2: # %entry
; N64-NEXT:    # in Loop: Header=BB0_1 Depth=1
; N64-NEXT:    move $2, $5
; N64-NEXT:    sc $2, 0($3)
; N64-NEXT:    beqz $2, .LBB0_1
; N64-NEXT:    nop
; N64-NEXT:  .LBB0_3: # %entry
; N64-NEXT:    sync
; N64-NEXT:    jr $ra
; N64-NEXT:    nop
entry:
  %0 = load i32 *, i32 ** @sym
  cmpxchg i32 * %0, i32 %new, i32 %old seq_cst seq_cst
  ret void
}

