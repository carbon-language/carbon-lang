; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=mips-- -mattr=-fp64 | FileCheck %s -check-prefix=CHECK-FP32
; RUN: llc < %s -mtriple=mips-- -mcpu=mips32r2 -mattr=+fp64 | FileCheck %s -check-prefix=CHECK-FP64

; This test case is a simplified version of an llvm-stress generated test with
; seed=3718491962.
; It originally failed on MIPS32 with FP64 with the following error:
;     LLVM ERROR: ran out of registers during register allocation
; This was caused by impossible register class restrictions caused by the use
; of BuildPairF64 instead of BuildPairF64_64.

; FIXME: A redundant mthc1 is currently emitted.
define void @autogen_SD3718491962(double %a0) {
; CHECK-FP32-LABEL: autogen_SD3718491962:
; CHECK-FP32:       # %bb.0: # %BB
; CHECK-FP32-NEXT:    lui $1, %hi($CPI0_0)
; CHECK-FP32-NEXT:    ldc1 $f0, %lo($CPI0_0)($1)
; CHECK-FP32-NEXT:    mtc1 $zero, $f2
; CHECK-FP32-NEXT:    mtc1 $zero, $f3
; CHECK-FP32-NEXT:  $BB0_1: # %CF88
; CHECK-FP32-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-FP32-NEXT:    c.ueq.d $f12, $f0
; CHECK-FP32-NEXT:    addiu $1, $zero, 1
; CHECK-FP32-NEXT:    movf $1, $zero, $fcc0
; CHECK-FP32-NEXT:    c.olt.d $f12, $f2
; CHECK-FP32-NEXT:    addiu $2, $zero, 1
; CHECK-FP32-NEXT:    movt $2, $zero, $fcc0
; CHECK-FP32-NEXT:    and $1, $2, $1
; CHECK-FP32-NEXT:    bnez $1, $BB0_1
; CHECK-FP32-NEXT:    nop
; CHECK-FP32-NEXT:  # %bb.2: # %CF85
; CHECK-FP32-NEXT:    jr $ra
; CHECK-FP32-NEXT:    nop
;
; CHECK-FP64-LABEL: autogen_SD3718491962:
; CHECK-FP64:       # %bb.0: # %BB
; CHECK-FP64-NEXT:    lui $1, %hi($CPI0_0)
; CHECK-FP64-NEXT:    ldc1 $f0, %lo($CPI0_0)($1)
; CHECK-FP64-NEXT:    mtc1 $zero, $f1
; CHECK-FP64-NEXT:    mthc1 $zero, $f1
; CHECK-FP64-NEXT:  $BB0_1: # %CF88
; CHECK-FP64-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-FP64-NEXT:    c.ueq.d $f12, $f0
; CHECK-FP64-NEXT:    addiu $1, $zero, 1
; CHECK-FP64-NEXT:    movf $1, $zero, $fcc0
; CHECK-FP64-NEXT:    c.olt.d $f12, $f1
; CHECK-FP64-NEXT:    addiu $2, $zero, 1
; CHECK-FP64-NEXT:    movt $2, $zero, $fcc0
; CHECK-FP64-NEXT:    and $1, $2, $1
; CHECK-FP64-NEXT:    bnez $1, $BB0_1
; CHECK-FP64-NEXT:    nop
; CHECK-FP64-NEXT:  # %bb.2: # %CF85
; CHECK-FP64-NEXT:    jr $ra
; CHECK-FP64-NEXT:    nop
BB:
  %Cmp = fcmp ule double 0.000000e+00, %a0
  %Cmp11 = fcmp ueq double 0xFDBD965CF1BB7FDA, %a0
  br label %CF88

CF88:                                             ; preds = %CF86
  %Sl18 = select i1 %Cmp, i1 %Cmp11, i1 %Cmp
  br i1 %Sl18, label %CF88, label %CF85

CF85:                                             ; preds = %CF88
  ret void
}
