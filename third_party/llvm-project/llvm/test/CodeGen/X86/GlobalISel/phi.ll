; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=x86_64-linux-gnu -global-isel -verify-machineinstrs < %s -o - | FileCheck %s --check-prefix=ALL

define i8 @test_i8(i32 %a, i8 %f, i8 %t) {
; ALL-LABEL: test_i8:
; ALL:       # %bb.0: # %entry
; ALL-NEXT:    xorl %ecx, %ecx
; ALL-NEXT:    cmpl %ecx, %edi
; ALL-NEXT:    setg %cl
; ALL-NEXT:    testb $1, %cl
; ALL-NEXT:    je .LBB0_2
; ALL-NEXT:  # %bb.1:
; ALL-NEXT:    movl %esi, %eax
; ALL-NEXT:    # kill: def $al killed $al killed $eax
; ALL-NEXT:    retq
; ALL-NEXT:  .LBB0_2: # %cond.false
; ALL-NEXT:    movl %edx, %eax
; ALL-NEXT:    # kill: def $al killed $al killed $eax
; ALL-NEXT:    retq
entry:
  %cmp = icmp sgt i32 %a, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8 [ %f, %cond.true ], [ %t, %cond.false ]
  ret i8 %cond
}

define i16 @test_i16(i32 %a, i16 %f, i16 %t) {
; ALL-LABEL: test_i16:
; ALL:       # %bb.0: # %entry
; ALL-NEXT:    xorl %ecx, %ecx
; ALL-NEXT:    cmpl %ecx, %edi
; ALL-NEXT:    setg %cl
; ALL-NEXT:    testb $1, %cl
; ALL-NEXT:    je .LBB1_2
; ALL-NEXT:  # %bb.1:
; ALL-NEXT:    movl %esi, %eax
; ALL-NEXT:    # kill: def $ax killed $ax killed $eax
; ALL-NEXT:    retq
; ALL-NEXT:  .LBB1_2: # %cond.false
; ALL-NEXT:    movl %edx, %eax
; ALL-NEXT:    # kill: def $ax killed $ax killed $eax
; ALL-NEXT:    retq
entry:
  %cmp = icmp sgt i32 %a, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i16 [ %f, %cond.true ], [ %t, %cond.false ]
  ret i16 %cond
}

define i32 @test_i32(i32 %a, i32 %f, i32 %t) {
; ALL-LABEL: test_i32:
; ALL:       # %bb.0: # %entry
; ALL-NEXT:    movl %esi, %eax
; ALL-NEXT:    xorl %ecx, %ecx
; ALL-NEXT:    cmpl %ecx, %edi
; ALL-NEXT:    setg %cl
; ALL-NEXT:    testb $1, %cl
; ALL-NEXT:    je .LBB2_1
; ALL-NEXT:  # %bb.2: # %cond.end
; ALL-NEXT:    retq
; ALL-NEXT:  .LBB2_1: # %cond.false
; ALL-NEXT:    movl %edx, %eax
; ALL-NEXT:    retq
entry:
  %cmp = icmp sgt i32 %a, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %f, %cond.true ], [ %t, %cond.false ]
  ret i32 %cond
}

define i64 @test_i64(i32 %a, i64 %f, i64 %t) {
; ALL-LABEL: test_i64:
; ALL:       # %bb.0: # %entry
; ALL-NEXT:    movq %rsi, %rax
; ALL-NEXT:    xorl %ecx, %ecx
; ALL-NEXT:    cmpl %ecx, %edi
; ALL-NEXT:    setg %cl
; ALL-NEXT:    testb $1, %cl
; ALL-NEXT:    je .LBB3_1
; ALL-NEXT:  # %bb.2: # %cond.end
; ALL-NEXT:    retq
; ALL-NEXT:  .LBB3_1: # %cond.false
; ALL-NEXT:    movq %rdx, %rax
; ALL-NEXT:    retq
entry:
  %cmp = icmp sgt i32 %a, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %f, %cond.true ], [ %t, %cond.false ]
  ret i64 %cond
}

define float @test_float(i32 %a, float %f, float %t) {
; ALL-LABEL: test_float:
; ALL:       # %bb.0: # %entry
; ALL-NEXT:    xorl %eax, %eax
; ALL-NEXT:    cmpl %eax, %edi
; ALL-NEXT:    setg %al
; ALL-NEXT:    testb $1, %al
; ALL-NEXT:    je .LBB4_1
; ALL-NEXT:  # %bb.2: # %cond.end
; ALL-NEXT:    retq
; ALL-NEXT:  .LBB4_1: # %cond.false
; ALL-NEXT:    movaps %xmm1, %xmm0
; ALL-NEXT:    retq
entry:
  %cmp = icmp sgt i32 %a, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi float [ %f, %cond.true ], [ %t, %cond.false ]
  ret float %cond
}

define double @test_double(i32 %a, double %f, double %t) {
; ALL-LABEL: test_double:
; ALL:       # %bb.0: # %entry
; ALL-NEXT:    xorl %eax, %eax
; ALL-NEXT:    cmpl %eax, %edi
; ALL-NEXT:    setg %al
; ALL-NEXT:    testb $1, %al
; ALL-NEXT:    je .LBB5_1
; ALL-NEXT:  # %bb.2: # %cond.end
; ALL-NEXT:    retq
; ALL-NEXT:  .LBB5_1: # %cond.false
; ALL-NEXT:    movaps %xmm1, %xmm0
; ALL-NEXT:    retq
entry:
  %cmp = icmp sgt i32 %a, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi double [ %f, %cond.true ], [ %t, %cond.false ]
  ret double %cond
}
