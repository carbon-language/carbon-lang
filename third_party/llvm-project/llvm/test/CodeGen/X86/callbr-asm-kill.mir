# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
# RUN: llc -mtriple=x86_64-unknown-linux-gnu -verify-machineinstrs -O2 -run-pass=livevars,phi-node-elimination -o - %s | FileCheck %s

# Check that the COPY from [[MOV64rm]] is not killed, because there is a
# subsequent use of [[MOV64rm]] in the INLINEASM_BR instruction which should be
# killed instead.
--- |
  ; ModuleID = '<stdin>'
  source_filename = "<stdin>"
  target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
  target triple = "x86_64-unknown-linux-gnu"

  declare void @foo(i8*)

  ; Function Attrs: nounwind
  define void @test1(i8* %arg, i8** %mem) #0 {
  entry:
    br label %loop

  loop:                                             ; preds = %loop, %entry
    %a = phi i8* [ %arg, %entry ], [ %b, %loop ]
    %b = load i8*, i8** %mem, align 8
    call void @foo(i8* %a)
    callbr void asm sideeffect "", "*m,i"(i8* elementtype(i8) %b, i8* blockaddress(@test1, %loop))
            to label %end [label %loop]

  end:                                              ; preds = %loop
    ret void
  }

  attributes #0 = { nounwind }

...
---
name:            test1
alignment:       16
tracksRegLiveness: true
registers:
  - { id: 0, class: gr64 }
  - { id: 1, class: gr64 }
  - { id: 2, class: gr64 }
  - { id: 3, class: gr64 }
liveins:
  - { reg: '$rdi', virtual-reg: '%2' }
  - { reg: '$rsi', virtual-reg: '%3' }
frameInfo:
  maxAlignment:    1
  hasCalls:        true
machineFunctionInfo: {}
body:             |
  ; CHECK-LABEL: name: test1
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   successors: %bb.1(0x80000000)
  ; CHECK-NEXT:   liveins: $rdi, $rsi
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:gr64 = COPY killed $rsi
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:gr64 = COPY killed $rdi
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:gr64 = COPY killed [[COPY1]]
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1.loop (address-taken, inlineasm-br-indirect-target):
  ; CHECK-NEXT:   successors: %bb.2(0x80000000), %bb.1(0x00000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY3:%[0-9]+]]:gr64 = COPY killed [[COPY2]]
  ; CHECK-NEXT:   [[MOV64rm:%[0-9]+]]:gr64 = MOV64rm [[COPY]], 1, $noreg, 0, $noreg :: (load (s64) from %ir.mem)
  ; CHECK-NEXT:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ; CHECK-NEXT:   $rdi = COPY killed [[COPY3]]
  ; CHECK-NEXT:   CALL64pcrel32 target-flags(x86-plt) @foo, csr_64, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp
  ; CHECK-NEXT:   ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ; CHECK-NEXT:   [[COPY4:%[0-9]+]]:gr64 = COPY [[MOV64rm]]
  ; CHECK-NEXT:   INLINEASM_BR &"", 9 /* sideeffect mayload attdialect */, 196654 /* mem:m */, killed [[MOV64rm]], 1, $noreg, 0, $noreg, 13 /* imm */, blockaddress(@test1, %ir-block.loop)
  ; CHECK-NEXT:   JMP_1 %bb.2
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.2.end:
  ; CHECK-NEXT:   RET 0
  bb.0.entry:
    liveins: $rdi, $rsi

    %3:gr64 = COPY killed $rsi
    %2:gr64 = COPY killed $rdi

  bb.1.loop (address-taken, inlineasm-br-indirect-target):
    successors: %bb.2(0x80000000), %bb.1(0x00000000)

    %0:gr64 = PHI %2, %bb.0, %1, %bb.1
    %1:gr64 = MOV64rm %3, 1, $noreg, 0, $noreg :: (load (s64) from %ir.mem)
    ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
    $rdi = COPY killed %0
    CALL64pcrel32 target-flags(x86-plt) @foo, csr_64, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp
    ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
    INLINEASM_BR &"", 9 /* sideeffect mayload attdialect */, 196654 /* mem:m */, %1, 1, $noreg, 0, $noreg, 13 /* imm */, blockaddress(@test1, %ir-block.loop)
    JMP_1 %bb.2

  bb.2.end:
    RET 0

...
