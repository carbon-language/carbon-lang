; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=x86_64-windows-gnu -exception-model=dwarf < %s | FileCheck %s

%struct.A = type { [4096 x i8] }

@a = common global i32 0, align 4
@b = common global i32 0, align 4

define void @fn1() nounwind uwtable {
; CHECK-LABEL: fn1:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movl $4136, %eax # imm = 0x1028
; CHECK-NEXT:    callq ___chkstk_ms
; CHECK-NEXT:    subq %rax, %rsp
; CHECK-NEXT:    .cfi_def_cfa_offset 4144
; CHECK-NEXT:    movl a(%rip), %eax
; CHECK-NEXT:    testl %eax, %eax
; CHECK-NEXT:    jne .LBB0_2
; CHECK-NEXT:  # %bb.1: # %select.true.sink
; CHECK-NEXT:    cltq
; CHECK-NEXT:    imulq $715827883, %rax, %rax # imm = 0x2AAAAAAB
; CHECK-NEXT:    movq %rax, %rcx
; CHECK-NEXT:    shrq $63, %rcx
; CHECK-NEXT:    shrq $32, %rax
; CHECK-NEXT:    addl %ecx, %eax
; CHECK-NEXT:  .LBB0_2: # %select.end
; CHECK-NEXT:    movl %eax, b(%rip)
; CHECK-NEXT:    leaq {{[0-9]+}}(%rsp), %rcx
; CHECK-NEXT:    # kill: def $ecx killed $ecx killed $rcx
; CHECK-NEXT:    callq fn2
; CHECK-NEXT:    addq $4136, %rsp # imm = 0x1028
; CHECK-NEXT:    retq
entry:
  %ctx = alloca %struct.A, align 1
  %0 = load i32, i32* @a, align 4
  %tobool = icmp eq i32 %0, 0
  %div = sdiv i32 %0, 6
  %cond = select i1 %tobool, i32 %div, i32 %0
  store i32 %cond, i32* @b, align 4
  %1 = getelementptr inbounds %struct.A, %struct.A* %ctx, i64 0, i32 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 4096, i8* nonnull %1)
  %2 = ptrtoint %struct.A* %ctx to i64
  %3 = trunc i64 %2 to i32
  call void @fn2(i32 %3)
  call void @llvm.lifetime.end.p0i8(i64 4096, i8* nonnull %1)
  ret void
}

declare void @fn2(i32)
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture)
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture)

