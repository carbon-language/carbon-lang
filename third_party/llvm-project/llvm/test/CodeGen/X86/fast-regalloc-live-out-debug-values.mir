# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
# RUN: llc -O0 -mtriple=x86_64-unknown-linux-gnu -start-before=regallocfast -stop-after=livedebugvalues -verify-machineinstrs -o - %s | FileCheck %s
# DBG_VALUEs for %0 should be present in the use blocks

--- |
  define dso_local i32 @foo(i32 %a) #0 !dbg !6 {
  entry:
    %a.addr = alloca i32, align 4
    %saved_stack = alloca i8*, align 8
    %__vla_expr0 = alloca i64, align 8
    %i = alloca i32, align 4
    store i32 %a, i32* %a.addr, align 4
    call void @llvm.dbg.declare(metadata i32* %a.addr, metadata !11, metadata !DIExpression()), !dbg !12
    %0 = load i32, i32* %a.addr, align 4, !dbg !13
    %1 = zext i32 %0 to i64, !dbg !14
    %2 = call i8* @llvm.stacksave(), !dbg !14
    store i8* %2, i8** %saved_stack, align 8, !dbg !14
    %vla = alloca i32, i64 %1, align 16, !dbg !14
    store i64 %1, i64* %__vla_expr0, align 8, !dbg !14
    call void @llvm.dbg.declare(metadata i64* %__vla_expr0, metadata !15, metadata !DIExpression()), !dbg !17
    call void @llvm.dbg.declare(metadata i32* %vla, metadata !18, metadata !DIExpression()), !dbg !22
    call void @llvm.dbg.declare(metadata i32* %i, metadata !23, metadata !DIExpression()), !dbg !25
    store i32 0, i32* %i, align 4, !dbg !25
    br label %for.cond, !dbg !26

  for.cond:                                         ; preds = %for.inc, %entry
    %3 = load i32, i32* %i, align 4, !dbg !27
    %4 = load i32, i32* %a.addr, align 4, !dbg !29
    %cmp = icmp slt i32 %3, %4, !dbg !30
    br i1 %cmp, label %for.body, label %for.end, !dbg !31

  for.body:                                         ; preds = %for.cond
    %5 = load i32, i32* %a.addr, align 4, !dbg !32
    %6 = load i32, i32* %i, align 4, !dbg !33
    %sub = sub nsw i32 %5, %6, !dbg !34
    %7 = load i32, i32* %i, align 4, !dbg !35
    %idxprom = sext i32 %7 to i64, !dbg !36
    %arrayidx = getelementptr inbounds i32, i32* %vla, i64 %idxprom, !dbg !36
    store i32 %sub, i32* %arrayidx, align 4, !dbg !37
    br label %for.inc, !dbg !36

  for.inc:                                          ; preds = %for.body
    %8 = load i32, i32* %i, align 4, !dbg !38
    %inc = add nsw i32 %8, 1, !dbg !38
    store i32 %inc, i32* %i, align 4, !dbg !38
    br label %for.cond, !dbg !39, !llvm.loop !40

  for.end:                                          ; preds = %for.cond
    %9 = load i32, i32* %a.addr, align 4, !dbg !42
    %sub1 = sub nsw i32 %9, 1, !dbg !43
    %idxprom2 = sext i32 %sub1 to i64, !dbg !44
    %arrayidx3 = getelementptr inbounds i32, i32* %vla, i64 %idxprom2, !dbg !44
    %10 = load i32, i32* %arrayidx3, align 4, !dbg !44
    %11 = load i8*, i8** %saved_stack, align 8, !dbg !45
    call void @llvm.stackrestore(i8* %11), !dbg !45
    ret i32 %10, !dbg !45
  }

  declare void @llvm.dbg.declare(metadata, metadata, metadata) #1
  declare i8* @llvm.stacksave() #2
  declare void @llvm.stackrestore(i8*) #2

  attributes #0 = { noinline nounwind optnone uwtable }
  attributes #1 = { nounwind readnone speculatable willreturn }
  attributes #2 = { nounwind }

  !llvm.dbg.cu = !{!0}
  !llvm.module.flags = !{!3, !4, !5}

  !0 = distinct !DICompileUnit(language: DW_LANG_C99, file: !1, producer: "clang version 12.0.0 (git@github.com:llvm/llvm-project.git 954995d0a45729c7935b82258c166524ee87ad3f)", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !2, splitDebugInlining: false, nameTableKind: None)
  !1 = !DIFile(filename: "/home/matt/src/llvm-project/lldb/test/API/lang/c/vla/main.c", directory: "/home/matt/src/llvm-project/build_debug_lldbg")
  !2 = !{}
  !3 = !{i32 7, !"Dwarf Version", i32 4}
  !4 = !{i32 2, !"Debug Info Version", i32 3}
  !5 = !{i32 1, !"wchar_size", i32 4}
  !6 = distinct !DISubprogram(name: "foo", scope: !7, file: !7, line: 3, type: !8, scopeLine: 3, flags: DIFlagPrototyped, spFlags: DISPFlagDefinition, unit: !0, retainedNodes: !2)
  !7 = !DIFile(filename: "lldb/test/API/lang/c/vla/main.c", directory: "/home/matt/src/llvm-project")
  !8 = !DISubroutineType(types: !9)
  !9 = !{!10, !10}
  !10 = !DIBasicType(name: "int", size: 32, encoding: DW_ATE_signed)
  !11 = !DILocalVariable(name: "a", arg: 1, scope: !6, file: !7, line: 3, type: !10)
  !12 = !DILocation(line: 3, column: 13, scope: !6)
  !13 = !DILocation(line: 4, column: 11, scope: !6)
  !14 = !DILocation(line: 4, column: 3, scope: !6)
  !15 = !DILocalVariable(name: "__vla_expr0", scope: !6, type: !16, flags: DIFlagArtificial)
  !16 = !DIBasicType(name: "long unsigned int", size: 64, encoding: DW_ATE_unsigned)
  !17 = !DILocation(line: 0, scope: !6)
  !18 = !DILocalVariable(name: "vla", scope: !6, file: !7, line: 4, type: !19)
  !19 = !DICompositeType(tag: DW_TAG_array_type, baseType: !10, elements: !20)
  !20 = !{!21}
  !21 = !DISubrange(count: !15)
  !22 = !DILocation(line: 4, column: 7, scope: !6)
  !23 = !DILocalVariable(name: "i", scope: !24, file: !7, line: 6, type: !10)
  !24 = distinct !DILexicalBlock(scope: !6, file: !7, line: 6, column: 3)
  !25 = !DILocation(line: 6, column: 12, scope: !24)
  !26 = !DILocation(line: 6, column: 8, scope: !24)
  !27 = !DILocation(line: 6, column: 19, scope: !28)
  !28 = distinct !DILexicalBlock(scope: !24, file: !7, line: 6, column: 3)
  !29 = !DILocation(line: 6, column: 23, scope: !28)
  !30 = !DILocation(line: 6, column: 21, scope: !28)
  !31 = !DILocation(line: 6, column: 3, scope: !24)
  !32 = !DILocation(line: 7, column: 14, scope: !28)
  !33 = !DILocation(line: 7, column: 16, scope: !28)
  !34 = !DILocation(line: 7, column: 15, scope: !28)
  !35 = !DILocation(line: 7, column: 9, scope: !28)
  !36 = !DILocation(line: 7, column: 5, scope: !28)
  !37 = !DILocation(line: 7, column: 12, scope: !28)
  !38 = !DILocation(line: 6, column: 26, scope: !28)
  !39 = !DILocation(line: 6, column: 3, scope: !28)
  !40 = distinct !{!40, !31, !41}
  !41 = !DILocation(line: 7, column: 16, scope: !24)
  !42 = !DILocation(line: 10, column: 14, scope: !6)
  !43 = !DILocation(line: 10, column: 15, scope: !6)
  !44 = !DILocation(line: 10, column: 10, scope: !6)
  !45 = !DILocation(line: 11, column: 1, scope: !6)

...
---
name:            foo
tracksRegLiveness: true
frameInfo:
  hasCalls:        true
stack:
  - { id: 0, name: a.addr, size: 4, alignment: 4, debug-info-variable: '!11',
      debug-info-expression: '!DIExpression()', debug-info-location: '!12' }
  - { id: 1, name: __vla_expr0, size: 8, alignment: 8, debug-info-variable: '!15',
      debug-info-expression: '!DIExpression()', debug-info-location: '!17' }
  - { id: 2, name: i, size: 4, alignment: 4, debug-info-variable: '!23',
      debug-info-expression: '!DIExpression()', debug-info-location: '!25' }
  - { id: 3, name: vla, type: variable-sized, alignment: 1 }
body:             |
  ; CHECK-LABEL: name: foo
  ; CHECK: bb.0.entry:
  ; CHECK:   successors: %bb.1(0x80000000)
  ; CHECK:   liveins: $edi, $rbx
  ; CHECK:   frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  ; CHECK:   CFI_INSTRUCTION def_cfa_offset 16
  ; CHECK:   CFI_INSTRUCTION offset $rbp, -16
  ; CHECK:   $rbp = frame-setup MOV64rr $rsp
  ; CHECK:   CFI_INSTRUCTION def_cfa_register $rbp
  ; CHECK:   frame-setup PUSH64r killed $rbx, implicit-def $rsp, implicit $rsp, debug-location !13
  ; CHECK:   $rsp = frame-setup SUB64ri8 $rsp, 40, implicit-def dead $eflags
  ; CHECK:   CFI_INSTRUCTION offset $rbx, -24
  ; CHECK:   renamable $eax = MOV32rm $rbp, 1, $noreg, -12, $noreg, debug-location !13 :: (dereferenceable load (s32) from %ir.a.addr)
  ; CHECK:   renamable $rax = KILL killed renamable $eax, debug-location !13
  ; CHECK:   $rcx = MOV64rr $rsp, debug-location !14
  ; CHECK:   MOV64mr $rbp, 1, $noreg, -40, $noreg, $rcx :: (store (s64) into %stack.4)
  ; CHECK:   DBG_VALUE $rbp, 0, !18, !DIExpression(DW_OP_constu, 40, DW_OP_minus, DW_OP_deref), debug-location !22
  ; CHECK:   $rsp = MOV64rr $rcx, debug-location !14
  ; CHECK:   MOV64mr $rbp, 1, $noreg, -24, $noreg, killed renamable $rax, debug-location !14 :: (store (s64) into %ir.__vla_expr0)
  ; CHECK:   DBG_VALUE renamable $rcx, 0, !18, !DIExpression(), debug-location !22
  ; CHECK:   MOV32mi $rbp, 1, $noreg, -28, $noreg, 0, debug-location !25 :: (store (s32) into %ir.i)
  ; CHECK:   DBG_VALUE $rbp, 0, !18, !DIExpression(DW_OP_constu, 40, DW_OP_minus, DW_OP_deref), debug-location !22
  ; CHECK: bb.1.for.cond:
  ; CHECK:   successors: %bb.4(0x40000000), %bb.2(0x40000000)
  ; CHECK:   DBG_VALUE $rbp, 0, !18, !DIExpression(DW_OP_constu, 40, DW_OP_minus, DW_OP_deref), debug-location !22
  ; CHECK:   renamable $eax = MOV32rm $rbp, 1, $noreg, -28, $noreg, debug-location !27 :: (load (s32) from %ir.i)
  ; CHECK:   CMP32rm killed renamable $eax, $rbp, 1, $noreg, -12, $noreg, implicit-def $eflags, debug-location !30 :: (load (s32) from %ir.a.addr)
  ; CHECK:   JCC_1 %bb.4, 13, implicit killed $eflags, debug-location !31
  ; CHECK: bb.2.for.body:
  ; CHECK:   successors: %bb.3(0x80000000)
  ; CHECK:   DBG_VALUE $rbp, 0, !18, !DIExpression(DW_OP_constu, 40, DW_OP_minus, DW_OP_deref), debug-location !22
  ; CHECK:   $rax = MOV64rm $rbp, 1, $noreg, -40, $noreg :: (load (s64) from %stack.4)
  ; CHECK:   renamable $edx = MOV32rm $rbp, 1, $noreg, -12, $noreg, debug-location !32 :: (load (s32) from %ir.a.addr)
  ; CHECK:   renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -28, $noreg, debug-location !36 :: (load (s32) from %ir.i)
  ; CHECK:   MOV32mr renamable $rax, 4, killed renamable $rcx, 0, $noreg, killed renamable $edx, debug-location !37 :: (store (s32) into %ir.arrayidx)
  ; CHECK: bb.3.for.inc:
  ; CHECK:   successors: %bb.1(0x80000000)
  ; CHECK:   DBG_VALUE $rbp, 0, !18, !DIExpression(DW_OP_constu, 40, DW_OP_minus, DW_OP_deref), debug-location !22
  ; CHECK:   JMP_1 %bb.1, debug-location !39
  ; CHECK: bb.4.for.end:
  ; CHECK:   DBG_VALUE $rbp, 0, !18, !DIExpression(DW_OP_constu, 40, DW_OP_minus, DW_OP_deref), debug-location !22
  ; CHECK:   $rax = IMPLICIT_DEF
  ; CHECK:   $rax = MOV64rm $rbp, 1, $noreg, -40, $noreg :: (load (s64) from %stack.4)
  ; CHECK:   dead $rbx = IMPLICIT_DEF
  ; CHECK:   dead $rcx = IMPLICIT_DEF
  ; CHECK:   dead $rdx = IMPLICIT_DEF
  ; CHECK:   renamable $rcx = IMPLICIT_DEF
  ; CHECK:   renamable $eax = MOV32rm killed renamable $rax, 4, killed renamable $rcx, 0, $noreg, debug-location !44 :: (load (s32) from %ir.arrayidx3)
  ; CHECK:   $rsp = LEA64r $rbp, 1, $noreg, -8, $noreg, debug-location !45
  ; CHECK:   $rbx = frame-destroy POP64r implicit-def $rsp, implicit $rsp, debug-location !45
  ; CHECK:   $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp, debug-location !45
  ; CHECK:   CFI_INSTRUCTION def_cfa $rsp, 8, debug-location !45
  ; CHECK:   RETQ implicit killed $eax, debug-location !45
  bb.0.entry:
    liveins: $edi

    %0:gr32 = COPY $edi
    %1:gr32 = MOV32rm %stack.0.a.addr, 1, $noreg, 0, $noreg, debug-location !13 :: (dereferenceable load (s32) from %ir.a.addr)
    %2:gr64_nosp = SUBREG_TO_REG 0, killed %1, %subreg.sub_32bit, debug-location !13
    ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp, debug-location !14
    %3:gr64 = COPY $rsp, debug-location !14
    $rsp = COPY %3, debug-location !14
    ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp, debug-location !14
    MOV64mr %stack.1.__vla_expr0, 1, $noreg, 0, $noreg, %2, debug-location !14 :: (store (s64) into %ir.__vla_expr0)
    DBG_VALUE %3, 0, !18, !DIExpression(), debug-location !22
    MOV32mi %stack.2.i, 1, $noreg, 0, $noreg, 0, debug-location !25 :: (store (s32) into %ir.i)

  bb.1.for.cond:
    %4:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg, debug-location !27 :: (load (s32) from %ir.i)
    CMP32rm %4, %stack.0.a.addr, 1, $noreg, 0, $noreg, implicit-def $eflags, debug-location !30 :: (load (s32) from %ir.a.addr)
    JCC_1 %bb.4, 13, implicit $eflags, debug-location !31

  bb.2.for.body:
    %5:gr32 = MOV32rm %stack.0.a.addr, 1, $noreg, 0, $noreg, debug-location !32 :: (load (s32) from %ir.a.addr)
    %6:gr64_nosp = MOVSX64rm32 %stack.2.i, 1, $noreg, 0, $noreg, debug-location !36 :: (load (s32) from %ir.i)
    MOV32mr %3, 4, %6, 0, $noreg, killed %5, debug-location !37 :: (store (s32) into %ir.arrayidx)

  bb.3.for.inc:
    JMP_1 %bb.1, debug-location !39

  bb.4.for.end:
    $rax = IMPLICIT_DEF
    $rbx = IMPLICIT_DEF
    $rcx = IMPLICIT_DEF
    $rdx = IMPLICIT_DEF
    %7:gr64_nosp = IMPLICIT_DEF
    %8:gr32 = MOV32rm %3, 4, %7, 0, $noreg, debug-location !44 :: (load (s32) from %ir.arrayidx3)
    $eax = COPY %8, debug-location !45
    RETQ implicit $eax, debug-location !45

...
