; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -verify-machineinstrs -mtriple=powerpc64le-unknown-linux-gnu -O1 \
; RUN:   -mcpu=pwr10 -ppc-asm-full-reg-names -ppc-vsr-nums-as-vr < %s | \
; RUN:   FileCheck %s -check-prefixes=CHECK-LE
; RUN: llc -verify-machineinstrs -mtriple=powerpc64-unknown-linux-gnu -O1 \
; RUN:   -mcpu=pwr10 -ppc-asm-full-reg-names -ppc-vsr-nums-as-vr < %s | \
; RUN:   FileCheck %s -check-prefixes=CHECK-BE

@GlobLd1 = dso_local local_unnamed_addr global [20 x i1] zeroinitializer, align 1
@GlobSt1 = dso_local local_unnamed_addr global [20 x i1] zeroinitializer, align 1

define i1 @i64_ExtLoad_i1() {
; CHECK-LE-LABEL: i64_ExtLoad_i1:
; CHECK-LE:       # %bb.0: # %entry
; CHECK-LE-NEXT:    plbz r3, GlobLd1@PCREL(0), 1
; CHECK-LE-NEXT:    blr
;
; CHECK-BE-LABEL: i64_ExtLoad_i1:
; CHECK-BE:       # %bb.0: # %entry
; CHECK-BE-NEXT:    addis r3, r2, GlobLd1@toc@ha
; CHECK-BE-NEXT:    lbz r3, GlobLd1@toc@l(r3)
; CHECK-BE-NEXT:    blr
entry:
  %0 = load i1, i1* getelementptr inbounds ([20 x i1], [20 x i1]* @GlobLd1, i64 0, i64 0), align 1
  ret i1 %0
}

define zeroext i1 @i64_ZextLoad_i1() {
; CHECK-LE-LABEL: i64_ZextLoad_i1:
; CHECK-LE:       # %bb.0: # %entry
; CHECK-LE-NEXT:    plbz r3, GlobLd1@PCREL(0), 1
; CHECK-LE-NEXT:    blr
;
; CHECK-BE-LABEL: i64_ZextLoad_i1:
; CHECK-BE:       # %bb.0: # %entry
; CHECK-BE-NEXT:    addis r3, r2, GlobLd1@toc@ha
; CHECK-BE-NEXT:    lbz r3, GlobLd1@toc@l(r3)
; CHECK-BE-NEXT:    blr
entry:
  %0 = load i1, i1* getelementptr inbounds ([20 x i1], [20 x i1]* @GlobLd1, i64 0, i64 0), align 1
  ret i1 %0
}

define void @i32_ZextLoad_i1() {
; CHECK-LE-LABEL: i32_ZextLoad_i1:
; CHECK-LE:       # %bb.0: # %entry
; CHECK-LE-NEXT:    plbz r3, GlobLd1@PCREL(0), 1
; CHECK-LE-NEXT:    pstb r3, GlobSt1@PCREL(0), 1
; CHECK-LE-NEXT:    blr
;
; CHECK-BE-LABEL: i32_ZextLoad_i1:
; CHECK-BE:       # %bb.0: # %entry
; CHECK-BE-NEXT:    addis r3, r2, GlobLd1@toc@ha
; CHECK-BE-NEXT:    addis r4, r2, GlobSt1@toc@ha
; CHECK-BE-NEXT:    lbz r3, GlobLd1@toc@l(r3)
; CHECK-BE-NEXT:    stb r3, GlobSt1@toc@l(r4)
; CHECK-BE-NEXT:    blr
entry:
  %0 = load i1, i1* getelementptr inbounds ([20 x i1], [20 x i1]* @GlobLd1, i64 0, i64 0), align 1
  store i1 %0, i1* getelementptr inbounds ([20 x i1], [20 x i1]* @GlobSt1, i64 0, i64 0), align 1
  ret void
}

%1 = type { i64 }
@Glob1 = external dso_local global %1, align 8
@Glob2 = external dso_local unnamed_addr constant [11 x i8], align 1
declare i32 @Decl(%1*, i8*) local_unnamed_addr #0

define dso_local i1 @i32_ExtLoad_i1() local_unnamed_addr #0 {
; CHECK-LE-LABEL: i32_ExtLoad_i1:
; CHECK-LE:       # %bb.0: # %bb
; CHECK-LE-NEXT:    mflr r0
; CHECK-LE-NEXT:    std r0, 16(r1)
; CHECK-LE-NEXT:    stdu r1, -32(r1)
; CHECK-LE-NEXT:    .cfi_def_cfa_offset 32
; CHECK-LE-NEXT:    .cfi_offset lr, 16
; CHECK-LE-NEXT:    paddi r3, 0, Glob1@PCREL, 1
; CHECK-LE-NEXT:    paddi r4, 0, Glob2@PCREL, 1
; CHECK-LE-NEXT:    bl Decl@notoc
; CHECK-LE-NEXT:    plbz r4, GlobLd1@PCREL(0), 1
; CHECK-LE-NEXT:    cmplwi r3, 0
; CHECK-LE-NEXT:    li r3, 1
; CHECK-LE-NEXT:    iseleq r3, 0, r3
; CHECK-LE-NEXT:    and r3, r3, r4
; CHECK-LE-NEXT:    addi r1, r1, 32
; CHECK-LE-NEXT:    ld r0, 16(r1)
; CHECK-LE-NEXT:    mtlr r0
; CHECK-LE-NEXT:    blr
;
; CHECK-BE-LABEL: i32_ExtLoad_i1:
; CHECK-BE:       # %bb.0: # %bb
; CHECK-BE-NEXT:    mflr r0
; CHECK-BE-NEXT:    std r0, 16(r1)
; CHECK-BE-NEXT:    stdu r1, -112(r1)
; CHECK-BE-NEXT:    .cfi_def_cfa_offset 112
; CHECK-BE-NEXT:    .cfi_offset lr, 16
; CHECK-BE-NEXT:    addis r3, r2, Glob1@toc@ha
; CHECK-BE-NEXT:    addis r4, r2, Glob2@toc@ha
; CHECK-BE-NEXT:    addi r3, r3, Glob1@toc@l
; CHECK-BE-NEXT:    addi r4, r4, Glob2@toc@l
; CHECK-BE-NEXT:    bl Decl
; CHECK-BE-NEXT:    nop
; CHECK-BE-NEXT:    addis r4, r2, GlobLd1@toc@ha
; CHECK-BE-NEXT:    cmplwi r3, 0
; CHECK-BE-NEXT:    li r3, 1
; CHECK-BE-NEXT:    lbz r4, GlobLd1@toc@l(r4)
; CHECK-BE-NEXT:    iseleq r3, 0, r3
; CHECK-BE-NEXT:    and r3, r3, r4
; CHECK-BE-NEXT:    addi r1, r1, 112
; CHECK-BE-NEXT:    ld r0, 16(r1)
; CHECK-BE-NEXT:    mtlr r0
; CHECK-BE-NEXT:    blr
bb:
  %i = call signext i32 @Decl(%1* nonnull dereferenceable(32) @Glob1, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @Glob2, i64 0, i64 0)) #1
  %i1 = icmp eq i32 %i, 0
  %i2 = load i1, i1* getelementptr inbounds ([20 x i1], [20 x i1]* @GlobLd1, i64 0, i64 0), align 1
  %i3 = select i1 %i1, i1 false, i1 %i2
  ret i1 %i3
}
