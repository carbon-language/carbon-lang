; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -enable-ppc-gen-scalar-mass -O3 -mtriple=powerpc64le-unknown-linux-gnu < %s | FileCheck --check-prefix=CHECK-LNX %s
; RUN: llc -enable-ppc-gen-scalar-mass -O3 -mtriple=powerpc-ibm-aix-xcoff < %s | FileCheck --check-prefix=CHECK-AIX %s

define void @cos_f64(double* %arg) {
; CHECK-LNX-LABEL: cos_f64:
; CHECK-LNX:       # %bb.0: # %bb
; CHECK-LNX-NEXT:    mflr 0
; CHECK-LNX-NEXT:    std 0, 16(1)
; CHECK-LNX-NEXT:    stdu 1, -32(1)
; CHECK-LNX-NEXT:    .cfi_def_cfa_offset 32
; CHECK-LNX-NEXT:    .cfi_offset lr, 16
; CHECK-LNX-NEXT:    addis 3, 2, .LCPI0_0@toc@ha
; CHECK-LNX-NEXT:    lfs 1, .LCPI0_0@toc@l(3)
; CHECK-LNX-NEXT:    bl __xl_cos_finite
; CHECK-LNX-NEXT:    nop
; CHECK-LNX-NEXT:    xssqrtdp 0, 0
; CHECK-LNX-NEXT:    xsmuldp 0, 0, 1
; CHECK-LNX-NEXT:    .p2align 4
; CHECK-LNX-NEXT:  .LBB0_1: # %bb2
; CHECK-LNX-NEXT:    #
; CHECK-LNX-NEXT:    stfd 0, 0(3)
; CHECK-LNX-NEXT:    b .LBB0_1
;
; CHECK-AIX-LABEL: cos_f64:
; CHECK-AIX:       # %bb.0: # %bb
; CHECK-AIX-NEXT:    mflr 0
; CHECK-AIX-NEXT:    stw 0, 8(1)
; CHECK-AIX-NEXT:    stwu 1, -64(1)
; CHECK-AIX-NEXT:    stfd 31, 56(1) # 8-byte Folded Spill
; CHECK-AIX-NEXT:    bl .sqrt[PR]
; CHECK-AIX-NEXT:    nop
; CHECK-AIX-NEXT:    lwz 3, L..C0(2) # %const.0
; CHECK-AIX-NEXT:    fmr 31, 1
; CHECK-AIX-NEXT:    lfs 0, 0(3)
; CHECK-AIX-NEXT:    fmr 1, 0
; CHECK-AIX-NEXT:    bl .__xl_cos_finite[PR]
; CHECK-AIX-NEXT:    nop
; CHECK-AIX-NEXT:    fmul 0, 31, 1
; CHECK-AIX-NEXT:  L..BB0_1: # %bb2
; CHECK-AIX-NEXT:    #
; CHECK-AIX-NEXT:    stfd 0, 0(3)
; CHECK-AIX-NEXT:    b L..BB0_1
bb:
  %i = bitcast double* %arg to i8*
  %i1 = getelementptr i8, i8* %i, i64 undef
  br label %bb2

bb2:
  %i3 = getelementptr inbounds i8, i8* %i1, i64 undef
  %i4 = bitcast i8* %i3 to double*
  store double undef, double* %i4, align 8
  %i5 = getelementptr inbounds i8, i8* %i1, i64 0
  %i6 = bitcast i8* %i5 to double*
  %i7 = tail call fast double @llvm.sqrt.f64(double undef)
  %i8 = fmul fast double undef, 0x401921FB54442D28
  %i9 = tail call fast double @llvm.cos.f64(double %i8) #2
  %i10 = fmul fast double %i7, %i9
  store double %i10, double* %i6, align 8
  br label %bb2
}

define void @log_f64(double* %arg) {
; CHECK-LNX-LABEL: log_f64:
; CHECK-LNX:       # %bb.0: # %bb
; CHECK-LNX-NEXT:    mflr 0
; CHECK-LNX-NEXT:    std 0, 16(1)
; CHECK-LNX-NEXT:    stdu 1, -32(1)
; CHECK-LNX-NEXT:    .cfi_def_cfa_offset 32
; CHECK-LNX-NEXT:    .cfi_offset lr, 16
; CHECK-LNX-NEXT:    addis 3, 2, .LCPI1_0@toc@ha
; CHECK-LNX-NEXT:    lfs 1, .LCPI1_0@toc@l(3)
; CHECK-LNX-NEXT:    bl __xl_log_finite
; CHECK-LNX-NEXT:    nop
; CHECK-LNX-NEXT:    xssqrtdp 0, 0
; CHECK-LNX-NEXT:    xsmuldp 0, 0, 1
; CHECK-LNX-NEXT:    .p2align 4
; CHECK-LNX-NEXT:  .LBB1_1: # %bb2
; CHECK-LNX-NEXT:    #
; CHECK-LNX-NEXT:    stfd 0, 0(3)
; CHECK-LNX-NEXT:    b .LBB1_1
;
; CHECK-AIX-LABEL: log_f64:
; CHECK-AIX:       # %bb.0: # %bb
; CHECK-AIX-NEXT:    mflr 0
; CHECK-AIX-NEXT:    stw 0, 8(1)
; CHECK-AIX-NEXT:    stwu 1, -64(1)
; CHECK-AIX-NEXT:    stfd 31, 56(1) # 8-byte Folded Spill
; CHECK-AIX-NEXT:    bl .sqrt[PR]
; CHECK-AIX-NEXT:    nop
; CHECK-AIX-NEXT:    lwz 3, L..C1(2) # %const.0
; CHECK-AIX-NEXT:    fmr 31, 1
; CHECK-AIX-NEXT:    lfs 0, 0(3)
; CHECK-AIX-NEXT:    fmr 1, 0
; CHECK-AIX-NEXT:    bl .__xl_log_finite[PR]
; CHECK-AIX-NEXT:    nop
; CHECK-AIX-NEXT:    fmul 0, 31, 1
; CHECK-AIX-NEXT:  L..BB1_1: # %bb2
; CHECK-AIX-NEXT:    #
; CHECK-AIX-NEXT:    stfd 0, 0(3)
; CHECK-AIX-NEXT:    b L..BB1_1
bb:
  %i = bitcast double* %arg to i8*
  %i1 = getelementptr i8, i8* %i, i64 undef
  br label %bb2

bb2:
  %i3 = getelementptr inbounds i8, i8* %i1, i64 undef
  %i4 = bitcast i8* %i3 to double*
  store double undef, double* %i4, align 8
  %i5 = getelementptr inbounds i8, i8* %i1, i64 0
  %i6 = bitcast i8* %i5 to double*
  %i7 = tail call fast double @llvm.sqrt.f64(double undef)
  %i8 = fmul fast double undef, 0x401921FB54442D28
  %i9 = tail call fast double @llvm.log.f64(double %i8) #2
  %i10 = fmul fast double %i7, %i9
  store double %i10, double* %i6, align 8
  br label %bb2
}

declare double @llvm.sqrt.f64(double)
declare double @llvm.cos.f64(double)
declare double @llvm.log.f64(double)
