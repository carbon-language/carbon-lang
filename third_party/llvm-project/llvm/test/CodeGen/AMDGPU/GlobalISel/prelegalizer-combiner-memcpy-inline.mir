# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
# RUN: llc -global-isel -mtriple=amdgcn-amd-amdhsa -mcpu=gfx900 -run-pass=amdgpu-prelegalizer-combiner -verify-machineinstrs -o - %s | FileCheck %s
--- |
  target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-G1-ni:7"
  target triple = "amdgcn-amd-amdhsa"

  declare void @llvm.memcpy.inline.p0i8.p0i8.i64(i8* noalias nocapture writeonly, i8* noalias nocapture readonly, i64 immarg, i1 immarg) #0

  define void @test_memcpy_inline(i32* nocapture %dst, i32* nocapture readonly %src) local_unnamed_addr #1 {
  entry:
    %0 = bitcast i32* %dst to i8*
    %1 = bitcast i32* %src to i8*
    tail call void @llvm.memcpy.inline.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 13, i1 false)
    ret void
  }

  attributes #0 = { argmemonly nofree nounwind willreturn "target-cpu"="gfx900" }
  attributes #1 = { "target-cpu"="gfx900" }

...
---
name:            test_memcpy_inline
alignment:       1
tracksRegLiveness: true
registers:
  - { id: 0, class: _ }
  - { id: 1, class: _ }
  - { id: 2, class: sgpr_64 }
  - { id: 3, class: _ }
  - { id: 4, class: _ }
  - { id: 5, class: _ }
  - { id: 6, class: _ }
  - { id: 7, class: _ }
  - { id: 8, class: ccr_sgpr_64 }
liveins:
  - { reg: '$sgpr30_sgpr31', virtual-reg: '%2' }
frameInfo:
  maxAlignment:    1
machineFunctionInfo:
  maxKernArgAlign: 1
  scratchRSrcReg:  '$sgpr0_sgpr1_sgpr2_sgpr3'
  frameOffsetReg:  '$sgpr33'
  stackPtrOffsetReg: '$sgpr32'
  argumentInfo:
    privateSegmentBuffer: { reg: '$sgpr0_sgpr1_sgpr2_sgpr3' }
  occupancy:       10
body:             |
  bb.1.entry:
    liveins: $vgpr0, $vgpr1, $vgpr2, $vgpr3, $sgpr30_sgpr31

    ; CHECK-LABEL: name: test_memcpy_inline
    ; CHECK: liveins: $vgpr0, $vgpr1, $vgpr2, $vgpr3, $sgpr30_sgpr31
    ; CHECK: [[COPY:%[0-9]+]]:_(s32) = COPY $vgpr0
    ; CHECK: [[COPY1:%[0-9]+]]:_(s32) = COPY $vgpr1
    ; CHECK: [[MV:%[0-9]+]]:_(p0) = G_MERGE_VALUES [[COPY]](s32), [[COPY1]](s32)
    ; CHECK: [[COPY2:%[0-9]+]]:_(s32) = COPY $vgpr2
    ; CHECK: [[COPY3:%[0-9]+]]:_(s32) = COPY $vgpr3
    ; CHECK: [[MV1:%[0-9]+]]:_(p0) = G_MERGE_VALUES [[COPY2]](s32), [[COPY3]](s32)
    ; CHECK: [[COPY4:%[0-9]+]]:sgpr_64 = COPY $sgpr30_sgpr31
    ; CHECK: [[LOAD:%[0-9]+]]:_(s64) = G_LOAD [[MV1]](p0) :: (load (s64) from %ir.1, align 4)
    ; CHECK: G_STORE [[LOAD]](s64), [[MV]](p0) :: (store (s64) into %ir.0, align 4)
    ; CHECK: [[C:%[0-9]+]]:_(s64) = G_CONSTANT i64 5
    ; CHECK: [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[MV1]], [[C]](s64)
    ; CHECK: [[LOAD1:%[0-9]+]]:_(s64) = G_LOAD [[PTR_ADD]](p0) :: (load (s64) from %ir.1 + 5, align 1, basealign 4)
    ; CHECK: [[PTR_ADD1:%[0-9]+]]:_(p0) = G_PTR_ADD [[MV]], [[C]](s64)
    ; CHECK: G_STORE [[LOAD1]](s64), [[PTR_ADD1]](p0) :: (store (s64) into %ir.0 + 5, align 1, basealign 4)
    ; CHECK: [[COPY5:%[0-9]+]]:ccr_sgpr_64 = COPY [[COPY4]]
    ; CHECK: S_SETPC_B64_return [[COPY5]]
    %3:_(s32) = COPY $vgpr0
    %4:_(s32) = COPY $vgpr1
    %0:_(p0) = G_MERGE_VALUES %3(s32), %4(s32)
    %5:_(s32) = COPY $vgpr2
    %6:_(s32) = COPY $vgpr3
    %1:_(p0) = G_MERGE_VALUES %5(s32), %6(s32)
    %2:sgpr_64 = COPY $sgpr30_sgpr31
    %7:_(s64) = G_CONSTANT i64 13
    G_MEMCPY_INLINE %0(p0), %1(p0), %7(s64) :: (store (s8) into %ir.0, align 4), (load (s8) from %ir.1, align 4)
    %8:ccr_sgpr_64 = COPY %2
    S_SETPC_B64_return %8

...
