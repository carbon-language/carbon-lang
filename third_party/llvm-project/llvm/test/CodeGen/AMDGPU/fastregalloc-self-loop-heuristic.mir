# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
# RUN: llc -verify-machineinstrs -mtriple=amdgcn-amd-amdhsa -mcpu=gfx900 -run-pass=regallocfast -o - %s | FileCheck -check-prefix=GCN %s

---
name: self_loop_single_def_use
tracksRegLiveness: true
machineFunctionInfo:
  isEntryFunction: true
  scratchRSrcReg:  '$sgpr0_sgpr1_sgpr2_sgpr3'
  stackPtrOffsetReg: '$sgpr32'
body:             |
  ; GCN-LABEL: name: self_loop_single_def_use
  ; GCN: bb.0:
  ; GCN:   successors: %bb.1(0x80000000)
  ; GCN:   liveins: $vgpr0_vgpr1
  ; GCN:   SI_SPILL_V64_SAVE killed $vgpr0_vgpr1, %stack.0, $sgpr32, 0, implicit $exec :: (store (s64) into %stack.0, align 4, addrspace 5)
  ; GCN: bb.1:
  ; GCN:   successors: %bb.1(0x40000000), %bb.2(0x40000000)
  ; GCN:   $vgpr0_vgpr1 = SI_SPILL_V64_RESTORE %stack.0, $sgpr32, 0, implicit $exec :: (load (s64) from %stack.0, align 4, addrspace 5)
  ; GCN:   renamable $vgpr2 = GLOBAL_LOAD_DWORD renamable $vgpr0_vgpr1, 0, 0, implicit $exec
  ; GCN:   GLOBAL_STORE_DWORD renamable $vgpr0_vgpr1, killed renamable $vgpr2, 0, 0, implicit $exec
  ; GCN:   S_CBRANCH_EXECZ %bb.1, implicit $exec
  ; GCN: bb.2:
  ; GCN:   S_ENDPGM 0
  bb.0:
    liveins: $vgpr0_vgpr1
    %0:vreg_64 = COPY $vgpr0_vgpr1

  bb.1:
    %1:vgpr_32 = GLOBAL_LOAD_DWORD %0, 0, 0, implicit $exec
    GLOBAL_STORE_DWORD %0, %1, 0, 0, implicit $exec
    S_CBRANCH_EXECZ %bb.1, implicit $exec

  bb.2:
    S_ENDPGM 0

...

---
name: self_loop_multi_def
tracksRegLiveness: true
machineFunctionInfo:
  isEntryFunction: true
  scratchRSrcReg:  '$sgpr0_sgpr1_sgpr2_sgpr3'
  stackPtrOffsetReg: '$sgpr32'
body:             |
  ; GCN-LABEL: name: self_loop_multi_def
  ; GCN: bb.0:
  ; GCN:   successors: %bb.1(0x80000000)
  ; GCN:   liveins: $vgpr0_vgpr1
  ; GCN:   SI_SPILL_V64_SAVE killed $vgpr0_vgpr1, %stack.0, $sgpr32, 0, implicit $exec :: (store (s64) into %stack.0, align 4, addrspace 5)
  ; GCN: bb.1:
  ; GCN:   successors: %bb.1(0x40000000), %bb.2(0x40000000)
  ; GCN:   $vgpr0_vgpr1 = SI_SPILL_V64_RESTORE %stack.0, $sgpr32, 0, implicit $exec :: (load (s64) from %stack.0, align 4, addrspace 5)
  ; GCN:   renamable $vgpr2 = GLOBAL_LOAD_DWORD renamable $vgpr0_vgpr1, 0, 0, implicit $exec
  ; GCN:   GLOBAL_STORE_DWORD renamable $vgpr0_vgpr1, renamable $vgpr2, 0, 0, implicit $exec
  ; GCN:   renamable $vgpr2 = GLOBAL_LOAD_DWORD renamable $vgpr0_vgpr1, 0, 0, implicit $exec
  ; GCN:   SI_SPILL_V32_SAVE $vgpr2, %stack.1, $sgpr32, 0, implicit $exec :: (store (s32) into %stack.1, addrspace 5)
  ; GCN:   GLOBAL_STORE_DWORD renamable $vgpr0_vgpr1, renamable $vgpr2, 0, 0, implicit $exec
  ; GCN:   S_CBRANCH_EXECZ %bb.1, implicit $exec
  ; GCN: bb.2:
  ; GCN:   S_ENDPGM 0
  bb.0:
    liveins: $vgpr0_vgpr1
    %0:vreg_64 = COPY $vgpr0_vgpr1

  bb.1:
    %1:vgpr_32 = GLOBAL_LOAD_DWORD %0, 0, 0, implicit $exec
    GLOBAL_STORE_DWORD %0, %1, 0, 0, implicit $exec
    %1:vgpr_32 = GLOBAL_LOAD_DWORD %0, 0, 0, implicit $exec
    GLOBAL_STORE_DWORD %0, %1, 0, 0, implicit $exec
    S_CBRANCH_EXECZ %bb.1, implicit $exec

  bb.2:
    S_ENDPGM 0

...

# There's a single def inside the self loop, but it's also a use.

---
name: self_loop_def_use_same_inst
tracksRegLiveness: true
machineFunctionInfo:
  isEntryFunction: true
  scratchRSrcReg:  '$sgpr0_sgpr1_sgpr2_sgpr3'
  stackPtrOffsetReg: '$sgpr32'
body:             |
  ; GCN-LABEL: name: self_loop_def_use_same_inst
  ; GCN: bb.0:
  ; GCN:   successors: %bb.1(0x80000000)
  ; GCN:   liveins: $vgpr0_vgpr1
  ; GCN:   SI_SPILL_V64_SAVE killed $vgpr0_vgpr1, %stack.0, $sgpr32, 0, implicit $exec :: (store (s64) into %stack.0, align 4, addrspace 5)
  ; GCN: bb.1:
  ; GCN:   successors: %bb.1(0x40000000), %bb.2(0x40000000)
  ; GCN:   $vgpr0_vgpr1 = SI_SPILL_V64_RESTORE %stack.0, $sgpr32, 0, implicit $exec :: (load (s64) from %stack.0, align 4, addrspace 5)
  ; GCN:   renamable $vgpr2 = V_ADD_U32_e32 1, undef $vgpr0, implicit $exec
  ; GCN:   SI_SPILL_V32_SAVE $vgpr2, %stack.1, $sgpr32, 0, implicit $exec :: (store (s32) into %stack.1, addrspace 5)
  ; GCN:   GLOBAL_STORE_DWORD renamable $vgpr0_vgpr1, renamable $vgpr2, 0, 0, implicit $exec
  ; GCN:   S_CBRANCH_EXECZ %bb.1, implicit $exec
  ; GCN: bb.2:
  ; GCN:   S_ENDPGM 0
  bb.0:
    liveins: $vgpr0_vgpr1
    %0:vreg_64 = COPY $vgpr0_vgpr1

  bb.1:
    %1:vgpr_32 = V_ADD_U32_e32 1, undef %1, implicit $exec
    GLOBAL_STORE_DWORD %0, %1, 0, 0, implicit $exec
    S_CBRANCH_EXECZ %bb.1, implicit $exec

  bb.2:
    S_ENDPGM 0

...

---
name: self_loop_def_after_use
tracksRegLiveness: true
machineFunctionInfo:
  isEntryFunction: true
  scratchRSrcReg:  '$sgpr0_sgpr1_sgpr2_sgpr3'
  stackPtrOffsetReg: '$sgpr32'
body:             |
  ; GCN-LABEL: name: self_loop_def_after_use
  ; GCN: bb.0:
  ; GCN:   successors: %bb.1(0x80000000)
  ; GCN:   liveins: $vgpr0_vgpr1
  ; GCN:   SI_SPILL_V64_SAVE killed $vgpr0_vgpr1, %stack.0, $sgpr32, 0, implicit $exec :: (store (s64) into %stack.0, align 4, addrspace 5)
  ; GCN: bb.1:
  ; GCN:   successors: %bb.1(0x40000000), %bb.2(0x40000000)
  ; GCN:   $vgpr0_vgpr1 = SI_SPILL_V64_RESTORE %stack.0, $sgpr32, 0, implicit $exec :: (load (s64) from %stack.0, align 4, addrspace 5)
  ; GCN:   GLOBAL_STORE_DWORD renamable $vgpr0_vgpr1, undef renamable $vgpr0, 0, 0, implicit $exec
  ; GCN:   renamable $vgpr0 = V_ADD_U32_e64 1, 1, 0, implicit $exec
  ; GCN:   SI_SPILL_V32_SAVE killed $vgpr0, %stack.1, $sgpr32, 0, implicit $exec :: (store (s32) into %stack.1, addrspace 5)
  ; GCN:   S_CBRANCH_EXECZ %bb.1, implicit $exec
  ; GCN: bb.2:
  ; GCN:   S_ENDPGM 0
  bb.0:
    liveins: $vgpr0_vgpr1
    %0:vreg_64 = COPY $vgpr0_vgpr1

  bb.1:
    GLOBAL_STORE_DWORD %0, undef %1, 0, 0, implicit $exec
    %1:vgpr_32 = V_ADD_U32_e64 1, 1, 0, implicit $exec
    S_CBRANCH_EXECZ %bb.1, implicit $exec

  bb.2:
    S_ENDPGM 0

...

---
name: self_loop_single_subreg_def_use
tracksRegLiveness: true
machineFunctionInfo:
  isEntryFunction: true
  scratchRSrcReg:  '$sgpr0_sgpr1_sgpr2_sgpr3'
  stackPtrOffsetReg: '$sgpr32'
body:             |
  ; GCN-LABEL: name: self_loop_single_subreg_def_use
  ; GCN: bb.0:
  ; GCN:   successors: %bb.1(0x80000000)
  ; GCN:   liveins: $vgpr0_vgpr1
  ; GCN:   SI_SPILL_V64_SAVE killed $vgpr0_vgpr1, %stack.0, $sgpr32, 0, implicit $exec :: (store (s64) into %stack.0, align 4, addrspace 5)
  ; GCN: bb.1:
  ; GCN:   successors: %bb.1(0x40000000), %bb.2(0x40000000)
  ; GCN:   $vgpr0_vgpr1 = SI_SPILL_V64_RESTORE %stack.0, $sgpr32, 0, implicit $exec :: (load (s64) from %stack.0, align 4, addrspace 5)
  ; GCN:   undef renamable $vgpr3 = GLOBAL_LOAD_DWORD renamable $vgpr0_vgpr1, 0, 0, implicit $exec, implicit-def dead $vgpr2_vgpr3
  ; GCN:   GLOBAL_STORE_DWORD renamable $vgpr0_vgpr1, undef renamable $vgpr1, 0, 0, implicit $exec
  ; GCN:   S_CBRANCH_EXECZ %bb.1, implicit $exec
  ; GCN: bb.2:
  ; GCN:   S_ENDPGM 0
  bb.0:
    liveins: $vgpr0_vgpr1
    %0:vreg_64 = COPY $vgpr0_vgpr1

  bb.1:
    undef %1.sub1:vreg_64 = GLOBAL_LOAD_DWORD %0, 0, 0, implicit $exec
    GLOBAL_STORE_DWORD %0, undef %1.sub1, 0, 0, implicit $exec
    S_CBRANCH_EXECZ %bb.1, implicit $exec

  bb.2:
    S_ENDPGM 0

...
