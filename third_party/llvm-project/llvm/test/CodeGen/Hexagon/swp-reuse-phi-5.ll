; RUN: llc -march=hexagon -hexagon-bit=false < %s
; REQUIRES: asserts

; Fix for an undefined virtual register assert that was caused by an
; incorrect phi generated by the pipeliner. In this case, there is a
; phi that defines a value used by another phi in the next iteration.
; The pipeliner code for generating new phis was assuming that the
; definition is processed before the use, so an incorrect value was
; used.

; Function Attrs: nounwind
define void @f0() local_unnamed_addr #0 {
b0:
  br label %b1

b1:                                               ; preds = %b1, %b0
  %v0 = phi i64 [ 0, %b0 ], [ %v5, %b1 ]
  %v1 = phi i64 [ undef, %b0 ], [ %v9, %b1 ]
  %v2 = phi i32 [ 0, %b0 ], [ %v10, %b1 ]
  %v3 = phi i32 [ undef, %b0 ], [ %v4, %b1 ]
  %v4 = phi i32 [ undef, %b0 ], [ %v8, %b1 ]
  %v5 = tail call i64 @llvm.hexagon.M2.vdmacs.s0(i64 %v0, i64 %v1, i64 undef)
  %v6 = tail call i64 @llvm.hexagon.A2.combinew(i32 %v3, i32 %v3)
  %v7 = tail call i64 @llvm.hexagon.M2.vdmacs.s0(i64 undef, i64 %v6, i64 undef)
  %v8 = tail call i32 @llvm.hexagon.A2.combine.ll(i32 undef, i32 undef)
  %v9 = tail call i64 @llvm.hexagon.A2.combinew(i32 %v8, i32 %v4)
  %v10 = add nuw nsw i32 %v2, 1
  %v11 = icmp eq i32 %v10, undef
  br i1 %v11, label %b2, label %b1

b2:                                               ; preds = %b1
  %v12 = lshr i64 %v7, 32
  %v13 = trunc i64 %v12 to i32
  store i32 %v13, i32* undef, align 4
  %v14 = lshr i64 %v5, 32
  ret void
}

declare i32 @llvm.hexagon.A2.combine.ll(i32, i32) #1
declare i64 @llvm.hexagon.A2.combinew(i32, i32) #1
declare i64 @llvm.hexagon.M2.vdmacs.s0(i64, i64, i64) #1

attributes #0 = { nounwind "target-cpu"="hexagonv65" }
attributes #1 = { nounwind readnone }
