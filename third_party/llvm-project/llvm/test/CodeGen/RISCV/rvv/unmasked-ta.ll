; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: sed 's/iXLen/i32/g' %s | llc -mtriple=riscv32 -mattr=+v,+zfh \
; RUN:   -verify-machineinstrs -target-abi=ilp32d | FileCheck %s --check-prefix=RV32
; RUN: sed 's/iXLen/i64/g' %s | llc -mtriple=riscv64 -mattr=+v,+zfh \
; RUN:   -verify-machineinstrs -target-abi=lp64d | FileCheck %s --check-prefix=RV64

declare <vscale x 1 x float> @llvm.riscv.vfmacc.nxv1f32.nxv1f32(
  <vscale x 1 x float>,
  <vscale x 1 x float>,
  <vscale x 1 x float>,
  iXLen,
  iXLen);

define <vscale x 1 x float>  @intrinsic_vfmacc_vv_nxv1f32_nxv1f32_nxv1f32(<vscale x 1 x float> %0, <vscale x 1 x float> %1, <vscale x 1 x float> %2, iXLen %3) nounwind {
; RV32-LABEL: intrinsic_vfmacc_vv_nxv1f32_nxv1f32_nxv1f32:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    vsetvli zero, a0, e32, mf2, ta, mu
; RV32-NEXT:    vfmacc.vv v8, v10, v9
; RV32-NEXT:    ret
;
; RV64-LABEL: intrinsic_vfmacc_vv_nxv1f32_nxv1f32_nxv1f32:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    vsetvli zero, a0, e32, mf2, ta, mu
; RV64-NEXT:    vfmacc.vv v8, v10, v9
; RV64-NEXT:    ret
entry:
  %a = call <vscale x 1 x float> @llvm.riscv.vfmacc.nxv1f32.nxv1f32(
    <vscale x 1 x float> %0,
    <vscale x 1 x float> %1,
    <vscale x 1 x float> %2,
    iXLen %3, iXLen 1)

  ret <vscale x 1 x float> %a
}

declare <vscale x 1 x float> @llvm.riscv.vfmadd.nxv1f32.nxv1f32(
  <vscale x 1 x float>,
  <vscale x 1 x float>,
  <vscale x 1 x float>,
  iXLen,
  iXLen);

define <vscale x 1 x float>  @intrinsic_vfmadd_vv_nxv1f32_nxv1f32_nxv1f32(<vscale x 1 x float> %0, <vscale x 1 x float> %1, <vscale x 1 x float> %2, iXLen %3) nounwind {
; RV32-LABEL: intrinsic_vfmadd_vv_nxv1f32_nxv1f32_nxv1f32:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    vsetvli zero, a0, e32, mf2, ta, mu
; RV32-NEXT:    vfmadd.vv v8, v9, v10
; RV32-NEXT:    ret
;
; RV64-LABEL: intrinsic_vfmadd_vv_nxv1f32_nxv1f32_nxv1f32:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    vsetvli zero, a0, e32, mf2, ta, mu
; RV64-NEXT:    vfmadd.vv v8, v9, v10
; RV64-NEXT:    ret
entry:
  %a = call <vscale x 1 x float> @llvm.riscv.vfmadd.nxv1f32.nxv1f32(
    <vscale x 1 x float> %0,
    <vscale x 1 x float> %1,
    <vscale x 1 x float> %2,
    iXLen %3, iXLen 1)

  ret <vscale x 1 x float> %a
}

declare <vscale x 1 x float> @llvm.riscv.vfmsac.nxv1f32.nxv1f32(
  <vscale x 1 x float>,
  <vscale x 1 x float>,
  <vscale x 1 x float>,
  iXLen,
  iXLen);

define <vscale x 1 x float>  @intrinsic_vfmsac_vv_nxv1f32_nxv1f32_nxv1f32(<vscale x 1 x float> %0, <vscale x 1 x float> %1, <vscale x 1 x float> %2, iXLen %3) nounwind {
; RV32-LABEL: intrinsic_vfmsac_vv_nxv1f32_nxv1f32_nxv1f32:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    vsetvli zero, a0, e32, mf2, ta, mu
; RV32-NEXT:    vfmsac.vv v8, v10, v9
; RV32-NEXT:    ret
;
; RV64-LABEL: intrinsic_vfmsac_vv_nxv1f32_nxv1f32_nxv1f32:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    vsetvli zero, a0, e32, mf2, ta, mu
; RV64-NEXT:    vfmsac.vv v8, v10, v9
; RV64-NEXT:    ret
entry:
  %a = call <vscale x 1 x float> @llvm.riscv.vfmsac.nxv1f32.nxv1f32(
    <vscale x 1 x float> %0,
    <vscale x 1 x float> %1,
    <vscale x 1 x float> %2,
    iXLen %3, iXLen 1)

  ret <vscale x 1 x float> %a
}

declare <vscale x 1 x float> @llvm.riscv.vfmsub.nxv1f32.nxv1f32(
  <vscale x 1 x float>,
  <vscale x 1 x float>,
  <vscale x 1 x float>,
  iXLen,
  iXLen);

define <vscale x 1 x float>  @intrinsic_vfmsub_vv_nxv1f32_nxv1f32_nxv1f32(<vscale x 1 x float> %0, <vscale x 1 x float> %1, <vscale x 1 x float> %2, iXLen %3) nounwind {
; RV32-LABEL: intrinsic_vfmsub_vv_nxv1f32_nxv1f32_nxv1f32:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    vsetvli zero, a0, e32, mf2, ta, mu
; RV32-NEXT:    vfmsub.vv v8, v9, v10
; RV32-NEXT:    ret
;
; RV64-LABEL: intrinsic_vfmsub_vv_nxv1f32_nxv1f32_nxv1f32:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    vsetvli zero, a0, e32, mf2, ta, mu
; RV64-NEXT:    vfmsub.vv v8, v9, v10
; RV64-NEXT:    ret
entry:
  %a = call <vscale x 1 x float> @llvm.riscv.vfmsub.nxv1f32.nxv1f32(
    <vscale x 1 x float> %0,
    <vscale x 1 x float> %1,
    <vscale x 1 x float> %2,
    iXLen %3, iXLen 1)

  ret <vscale x 1 x float> %a
}

declare <vscale x 1 x float> @llvm.riscv.vfnmacc.nxv1f32.nxv1f32(
  <vscale x 1 x float>,
  <vscale x 1 x float>,
  <vscale x 1 x float>,
  iXLen,
  iXLen);

define <vscale x 1 x float>  @intrinsic_vfnmacc_vv_nxv1f32_nxv1f32_nxv1f32(<vscale x 1 x float> %0, <vscale x 1 x float> %1, <vscale x 1 x float> %2, iXLen %3) nounwind {
; RV32-LABEL: intrinsic_vfnmacc_vv_nxv1f32_nxv1f32_nxv1f32:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    vsetvli zero, a0, e32, mf2, ta, mu
; RV32-NEXT:    vfnmacc.vv v8, v10, v9
; RV32-NEXT:    ret
;
; RV64-LABEL: intrinsic_vfnmacc_vv_nxv1f32_nxv1f32_nxv1f32:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    vsetvli zero, a0, e32, mf2, ta, mu
; RV64-NEXT:    vfnmacc.vv v8, v10, v9
; RV64-NEXT:    ret
entry:
  %a = call <vscale x 1 x float> @llvm.riscv.vfnmacc.nxv1f32.nxv1f32(
    <vscale x 1 x float> %0,
    <vscale x 1 x float> %1,
    <vscale x 1 x float> %2,
    iXLen %3, iXLen 1)

  ret <vscale x 1 x float> %a
}

declare <vscale x 1 x float> @llvm.riscv.vfnmadd.nxv1f32.nxv1f32(
  <vscale x 1 x float>,
  <vscale x 1 x float>,
  <vscale x 1 x float>,
  iXLen,
  iXLen);

define <vscale x 1 x float>  @intrinsic_vfnmadd_vv_nxv1f32_nxv1f32_nxv1f32(<vscale x 1 x float> %0, <vscale x 1 x float> %1, <vscale x 1 x float> %2, iXLen %3) nounwind {
; RV32-LABEL: intrinsic_vfnmadd_vv_nxv1f32_nxv1f32_nxv1f32:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    vsetvli zero, a0, e32, mf2, ta, mu
; RV32-NEXT:    vfnmadd.vv v8, v9, v10
; RV32-NEXT:    ret
;
; RV64-LABEL: intrinsic_vfnmadd_vv_nxv1f32_nxv1f32_nxv1f32:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    vsetvli zero, a0, e32, mf2, ta, mu
; RV64-NEXT:    vfnmadd.vv v8, v9, v10
; RV64-NEXT:    ret
entry:
  %a = call <vscale x 1 x float> @llvm.riscv.vfnmadd.nxv1f32.nxv1f32(
    <vscale x 1 x float> %0,
    <vscale x 1 x float> %1,
    <vscale x 1 x float> %2,
    iXLen %3, iXLen 1)

  ret <vscale x 1 x float> %a
}

declare <vscale x 1 x float> @llvm.riscv.vfnmsac.nxv1f32.nxv1f32(
  <vscale x 1 x float>,
  <vscale x 1 x float>,
  <vscale x 1 x float>,
  iXLen,
  iXLen);

define <vscale x 1 x float>  @intrinsic_vfnmsac_vv_nxv1f32_nxv1f32_nxv1f32(<vscale x 1 x float> %0, <vscale x 1 x float> %1, <vscale x 1 x float> %2, iXLen %3) nounwind {
; RV32-LABEL: intrinsic_vfnmsac_vv_nxv1f32_nxv1f32_nxv1f32:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    vsetvli zero, a0, e32, mf2, ta, mu
; RV32-NEXT:    vfnmsac.vv v8, v10, v9
; RV32-NEXT:    ret
;
; RV64-LABEL: intrinsic_vfnmsac_vv_nxv1f32_nxv1f32_nxv1f32:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    vsetvli zero, a0, e32, mf2, ta, mu
; RV64-NEXT:    vfnmsac.vv v8, v10, v9
; RV64-NEXT:    ret
entry:
  %a = call <vscale x 1 x float> @llvm.riscv.vfnmsac.nxv1f32.nxv1f32(
    <vscale x 1 x float> %0,
    <vscale x 1 x float> %1,
    <vscale x 1 x float> %2,
    iXLen %3, iXLen 1)

  ret <vscale x 1 x float> %a
}

declare <vscale x 1 x float> @llvm.riscv.vfnmsub.nxv1f32.nxv1f32(
  <vscale x 1 x float>,
  <vscale x 1 x float>,
  <vscale x 1 x float>,
  iXLen,
  iXLen);

define <vscale x 1 x float>  @intrinsic_vfnmsub_vv_nxv1f32_nxv1f32_nxv1f32(<vscale x 1 x float> %0, <vscale x 1 x float> %1, <vscale x 1 x float> %2, iXLen %3) nounwind {
; RV32-LABEL: intrinsic_vfnmsub_vv_nxv1f32_nxv1f32_nxv1f32:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    vsetvli zero, a0, e32, mf2, ta, mu
; RV32-NEXT:    vfnmsub.vv v8, v9, v10
; RV32-NEXT:    ret
;
; RV64-LABEL: intrinsic_vfnmsub_vv_nxv1f32_nxv1f32_nxv1f32:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    vsetvli zero, a0, e32, mf2, ta, mu
; RV64-NEXT:    vfnmsub.vv v8, v9, v10
; RV64-NEXT:    ret
entry:
  %a = call <vscale x 1 x float> @llvm.riscv.vfnmsub.nxv1f32.nxv1f32(
    <vscale x 1 x float> %0,
    <vscale x 1 x float> %1,
    <vscale x 1 x float> %2,
    iXLen %3, iXLen 1)

  ret <vscale x 1 x float> %a
}

declare <vscale x 1 x float> @llvm.riscv.vfwmacc.nxv1f32.nxv1f16(
  <vscale x 1 x float>,
  <vscale x 1 x half>,
  <vscale x 1 x half>,
  iXLen,
  iXLen);

define <vscale x 1 x float>  @intrinsic_vfwmacc_vv_nxv1f32_nxv1f16_nxv1f16(<vscale x 1 x float> %0, <vscale x 1 x half> %1, <vscale x 1 x half> %2, iXLen %3) nounwind {
; RV32-LABEL: intrinsic_vfwmacc_vv_nxv1f32_nxv1f16_nxv1f16:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    vsetvli zero, a0, e16, mf4, ta, mu
; RV32-NEXT:    vfwmacc.vv v8, v9, v10
; RV32-NEXT:    ret
;
; RV64-LABEL: intrinsic_vfwmacc_vv_nxv1f32_nxv1f16_nxv1f16:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    vsetvli zero, a0, e16, mf4, ta, mu
; RV64-NEXT:    vfwmacc.vv v8, v9, v10
; RV64-NEXT:    ret
entry:
  %a = call <vscale x 1 x float> @llvm.riscv.vfwmacc.nxv1f32.nxv1f16(
    <vscale x 1 x float> %0,
    <vscale x 1 x half> %1,
    <vscale x 1 x half> %2,
    iXLen %3, iXLen 1)

  ret <vscale x 1 x float> %a
}

declare <vscale x 1 x float> @llvm.riscv.vfwmsac.nxv1f32.nxv1f16(
  <vscale x 1 x float>,
  <vscale x 1 x half>,
  <vscale x 1 x half>,
  iXLen,
  iXLen);

define <vscale x 1 x float>  @intrinsic_vfwmsac_vv_nxv1f32_nxv1f16_nxv1f16(<vscale x 1 x float> %0, <vscale x 1 x half> %1, <vscale x 1 x half> %2, iXLen %3) nounwind {
; RV32-LABEL: intrinsic_vfwmsac_vv_nxv1f32_nxv1f16_nxv1f16:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    vsetvli zero, a0, e16, mf4, ta, mu
; RV32-NEXT:    vfwmsac.vv v8, v9, v10
; RV32-NEXT:    ret
;
; RV64-LABEL: intrinsic_vfwmsac_vv_nxv1f32_nxv1f16_nxv1f16:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    vsetvli zero, a0, e16, mf4, ta, mu
; RV64-NEXT:    vfwmsac.vv v8, v9, v10
; RV64-NEXT:    ret
entry:
  %a = call <vscale x 1 x float> @llvm.riscv.vfwmsac.nxv1f32.nxv1f16(
    <vscale x 1 x float> %0,
    <vscale x 1 x half> %1,
    <vscale x 1 x half> %2,
    iXLen %3, iXLen 1)

  ret <vscale x 1 x float> %a
}

declare <vscale x 1 x float> @llvm.riscv.vfwnmacc.nxv1f32.nxv1f16(
  <vscale x 1 x float>,
  <vscale x 1 x half>,
  <vscale x 1 x half>,
  iXLen,
  iXLen);

define <vscale x 1 x float>  @intrinsic_vfwnmacc_vv_nxv1f32_nxv1f16_nxv1f16(<vscale x 1 x float> %0, <vscale x 1 x half> %1, <vscale x 1 x half> %2, iXLen %3) nounwind {
; RV32-LABEL: intrinsic_vfwnmacc_vv_nxv1f32_nxv1f16_nxv1f16:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    vsetvli zero, a0, e16, mf4, ta, mu
; RV32-NEXT:    vfwnmacc.vv v8, v9, v10
; RV32-NEXT:    ret
;
; RV64-LABEL: intrinsic_vfwnmacc_vv_nxv1f32_nxv1f16_nxv1f16:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    vsetvli zero, a0, e16, mf4, ta, mu
; RV64-NEXT:    vfwnmacc.vv v8, v9, v10
; RV64-NEXT:    ret
entry:
  %a = call <vscale x 1 x float> @llvm.riscv.vfwnmacc.nxv1f32.nxv1f16(
    <vscale x 1 x float> %0,
    <vscale x 1 x half> %1,
    <vscale x 1 x half> %2,
    iXLen %3, iXLen 1)

  ret <vscale x 1 x float> %a
}

declare <vscale x 1 x float> @llvm.riscv.vfwnmsac.nxv1f32.nxv1f16(
  <vscale x 1 x float>,
  <vscale x 1 x half>,
  <vscale x 1 x half>,
  iXLen,
  iXLen);

define <vscale x 1 x float>  @intrinsic_vfwnmsac_vv_nxv1f32_nxv1f16_nxv1f16(<vscale x 1 x float> %0, <vscale x 1 x half> %1, <vscale x 1 x half> %2, iXLen %3) nounwind {
; RV32-LABEL: intrinsic_vfwnmsac_vv_nxv1f32_nxv1f16_nxv1f16:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    vsetvli zero, a0, e16, mf4, ta, mu
; RV32-NEXT:    vfwnmsac.vv v8, v9, v10
; RV32-NEXT:    ret
;
; RV64-LABEL: intrinsic_vfwnmsac_vv_nxv1f32_nxv1f16_nxv1f16:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    vsetvli zero, a0, e16, mf4, ta, mu
; RV64-NEXT:    vfwnmsac.vv v8, v9, v10
; RV64-NEXT:    ret
entry:
  %a = call <vscale x 1 x float> @llvm.riscv.vfwnmsac.nxv1f32.nxv1f16(
    <vscale x 1 x float> %0,
    <vscale x 1 x half> %1,
    <vscale x 1 x half> %2,
    iXLen %3, iXLen 1)

  ret <vscale x 1 x float> %a
}

declare <vscale x 1 x i64> @llvm.riscv.vmacc.nxv1i64.i64(
  <vscale x 1 x i64>,
  i64,
  <vscale x 1 x i64>,
  iXLen,
  iXLen);

define <vscale x 1 x i64>  @intrinsic_vmacc_vx_nxv1i64_i64_nxv1i64(<vscale x 1 x i64> %0, i64 %1, <vscale x 1 x i64> %2, iXLen %3) nounwind {
; RV32-LABEL: intrinsic_vmacc_vx_nxv1i64_i64_nxv1i64:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    addi sp, sp, -16
; RV32-NEXT:    sw a1, 12(sp)
; RV32-NEXT:    sw a0, 8(sp)
; RV32-NEXT:    vsetvli zero, a2, e64, m1, ta, mu
; RV32-NEXT:    addi a0, sp, 8
; RV32-NEXT:    vlse64.v v10, (a0), zero
; RV32-NEXT:    vmacc.vv v8, v9, v10
; RV32-NEXT:    addi sp, sp, 16
; RV32-NEXT:    ret
;
; RV64-LABEL: intrinsic_vmacc_vx_nxv1i64_i64_nxv1i64:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    vsetvli zero, a1, e64, m1, ta, mu
; RV64-NEXT:    vmacc.vx v8, a0, v9
; RV64-NEXT:    ret
entry:
  %a = call <vscale x 1 x i64> @llvm.riscv.vmacc.nxv1i64.i64(
    <vscale x 1 x i64> %0,
    i64 %1,
    <vscale x 1 x i64> %2,
    iXLen %3, iXLen 1)

  ret <vscale x 1 x i64> %a
}

declare <vscale x 1 x i64> @llvm.riscv.vmadd.nxv1i64.i64(
  <vscale x 1 x i64>,
  i64,
  <vscale x 1 x i64>,
  iXLen,
  iXLen);

define <vscale x 1 x i64>  @intrinsic_vmadd_vx_nxv1i64_i64_nxv1i64(<vscale x 1 x i64> %0, i64 %1, <vscale x 1 x i64> %2, iXLen %3) nounwind {
; RV32-LABEL: intrinsic_vmadd_vx_nxv1i64_i64_nxv1i64:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    addi sp, sp, -16
; RV32-NEXT:    sw a1, 12(sp)
; RV32-NEXT:    sw a0, 8(sp)
; RV32-NEXT:    vsetvli zero, a2, e64, m1, ta, mu
; RV32-NEXT:    addi a0, sp, 8
; RV32-NEXT:    vlse64.v v10, (a0), zero
; RV32-NEXT:    vmadd.vv v8, v10, v9
; RV32-NEXT:    addi sp, sp, 16
; RV32-NEXT:    ret
;
; RV64-LABEL: intrinsic_vmadd_vx_nxv1i64_i64_nxv1i64:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    vsetvli zero, a1, e64, m1, ta, mu
; RV64-NEXT:    vmadd.vx v8, a0, v9
; RV64-NEXT:    ret
entry:
  %a = call <vscale x 1 x i64> @llvm.riscv.vmadd.nxv1i64.i64(
    <vscale x 1 x i64> %0,
    i64 %1,
    <vscale x 1 x i64> %2,
    iXLen %3, iXLen 1)

  ret <vscale x 1 x i64> %a
}

declare <vscale x 1 x i64> @llvm.riscv.vnmsac.nxv1i64.i64(
  <vscale x 1 x i64>,
  i64,
  <vscale x 1 x i64>,
  iXLen,
  iXLen);

define <vscale x 1 x i64>  @intrinsic_vnmsac_vx_nxv1i64_i64_nxv1i64(<vscale x 1 x i64> %0, i64 %1, <vscale x 1 x i64> %2, iXLen %3) nounwind {
; RV32-LABEL: intrinsic_vnmsac_vx_nxv1i64_i64_nxv1i64:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    addi sp, sp, -16
; RV32-NEXT:    sw a1, 12(sp)
; RV32-NEXT:    sw a0, 8(sp)
; RV32-NEXT:    vsetvli zero, a2, e64, m1, ta, mu
; RV32-NEXT:    addi a0, sp, 8
; RV32-NEXT:    vlse64.v v10, (a0), zero
; RV32-NEXT:    vnmsac.vv v8, v9, v10
; RV32-NEXT:    addi sp, sp, 16
; RV32-NEXT:    ret
;
; RV64-LABEL: intrinsic_vnmsac_vx_nxv1i64_i64_nxv1i64:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    vsetvli zero, a1, e64, m1, ta, mu
; RV64-NEXT:    vnmsac.vx v8, a0, v9
; RV64-NEXT:    ret
entry:
  %a = call <vscale x 1 x i64> @llvm.riscv.vnmsac.nxv1i64.i64(
    <vscale x 1 x i64> %0,
    i64 %1,
    <vscale x 1 x i64> %2,
    iXLen %3, iXLen 1)

  ret <vscale x 1 x i64> %a
}

declare <vscale x 1 x i64> @llvm.riscv.vnmsub.nxv1i64.i64(
  <vscale x 1 x i64>,
  i64,
  <vscale x 1 x i64>,
  iXLen,
  iXLen);

define <vscale x 1 x i64>  @intrinsic_vnmsub_vx_nxv1i64_i64_nxv1i64(<vscale x 1 x i64> %0, i64 %1, <vscale x 1 x i64> %2, iXLen %3) nounwind {
; RV32-LABEL: intrinsic_vnmsub_vx_nxv1i64_i64_nxv1i64:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    addi sp, sp, -16
; RV32-NEXT:    sw a1, 12(sp)
; RV32-NEXT:    sw a0, 8(sp)
; RV32-NEXT:    vsetvli zero, a2, e64, m1, ta, mu
; RV32-NEXT:    addi a0, sp, 8
; RV32-NEXT:    vlse64.v v10, (a0), zero
; RV32-NEXT:    vnmsub.vv v8, v10, v9
; RV32-NEXT:    addi sp, sp, 16
; RV32-NEXT:    ret
;
; RV64-LABEL: intrinsic_vnmsub_vx_nxv1i64_i64_nxv1i64:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    vsetvli zero, a1, e64, m1, ta, mu
; RV64-NEXT:    vnmsub.vx v8, a0, v9
; RV64-NEXT:    ret
entry:
  %a = call <vscale x 1 x i64> @llvm.riscv.vnmsub.nxv1i64.i64(
    <vscale x 1 x i64> %0,
    i64 %1,
    <vscale x 1 x i64> %2,
    iXLen %3, iXLen 1)

  ret <vscale x 1 x i64> %a
}

declare <vscale x 1 x i16> @llvm.riscv.vwmacc.nxv1i16.nxv1i8(
  <vscale x 1 x i16>,
  <vscale x 1 x i8>,
  <vscale x 1 x i8>,
  iXLen,
  iXLen);

define <vscale x 1 x i16>  @intrinsic_vwmacc_vv_nxv1i16_nxv1i8_nxv1i8(<vscale x 1 x i16> %0, <vscale x 1 x i8> %1, <vscale x 1 x i8> %2, iXLen %3) nounwind {
; RV32-LABEL: intrinsic_vwmacc_vv_nxv1i16_nxv1i8_nxv1i8:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    vsetvli zero, a0, e8, mf8, ta, mu
; RV32-NEXT:    vwmacc.vv v8, v9, v10
; RV32-NEXT:    ret
;
; RV64-LABEL: intrinsic_vwmacc_vv_nxv1i16_nxv1i8_nxv1i8:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    vsetvli zero, a0, e8, mf8, ta, mu
; RV64-NEXT:    vwmacc.vv v8, v9, v10
; RV64-NEXT:    ret
entry:
  %a = call <vscale x 1 x i16> @llvm.riscv.vwmacc.nxv1i16.nxv1i8(
    <vscale x 1 x i16> %0,
    <vscale x 1 x i8> %1,
    <vscale x 1 x i8> %2,
    iXLen %3, iXLen 1)

  ret <vscale x 1 x i16> %a
}

declare <vscale x 1 x i16> @llvm.riscv.vwmaccsu.nxv1i16.nxv1i8(
  <vscale x 1 x i16>,
  <vscale x 1 x i8>,
  <vscale x 1 x i8>,
  iXLen,
  iXLen);

define <vscale x 1 x i16>  @intrinsic_vwmaccsu_vv_nxv1i16_nxv1i8_nxv1i8(<vscale x 1 x i16> %0, <vscale x 1 x i8> %1, <vscale x 1 x i8> %2, iXLen %3) nounwind {
; RV32-LABEL: intrinsic_vwmaccsu_vv_nxv1i16_nxv1i8_nxv1i8:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    vsetvli zero, a0, e8, mf8, ta, mu
; RV32-NEXT:    vwmaccsu.vv v8, v9, v10
; RV32-NEXT:    ret
;
; RV64-LABEL: intrinsic_vwmaccsu_vv_nxv1i16_nxv1i8_nxv1i8:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    vsetvli zero, a0, e8, mf8, ta, mu
; RV64-NEXT:    vwmaccsu.vv v8, v9, v10
; RV64-NEXT:    ret
entry:
  %a = call <vscale x 1 x i16> @llvm.riscv.vwmaccsu.nxv1i16.nxv1i8(
    <vscale x 1 x i16> %0,
    <vscale x 1 x i8> %1,
    <vscale x 1 x i8> %2,
    iXLen %3, iXLen 1)

  ret <vscale x 1 x i16> %a
}

declare <vscale x 1 x i16> @llvm.riscv.vwmaccu.nxv1i16.nxv1i8(
  <vscale x 1 x i16>,
  <vscale x 1 x i8>,
  <vscale x 1 x i8>,
  iXLen,
  iXLen);

define <vscale x 1 x i16>  @intrinsic_vwmaccu_vv_nxv1i16_nxv1i8_nxv1i8(<vscale x 1 x i16> %0, <vscale x 1 x i8> %1, <vscale x 1 x i8> %2, iXLen %3) nounwind {
; RV32-LABEL: intrinsic_vwmaccu_vv_nxv1i16_nxv1i8_nxv1i8:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    vsetvli zero, a0, e8, mf8, ta, mu
; RV32-NEXT:    vwmaccu.vv v8, v9, v10
; RV32-NEXT:    ret
;
; RV64-LABEL: intrinsic_vwmaccu_vv_nxv1i16_nxv1i8_nxv1i8:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    vsetvli zero, a0, e8, mf8, ta, mu
; RV64-NEXT:    vwmaccu.vv v8, v9, v10
; RV64-NEXT:    ret
entry:
  %a = call <vscale x 1 x i16> @llvm.riscv.vwmaccu.nxv1i16.nxv1i8(
    <vscale x 1 x i16> %0,
    <vscale x 1 x i8> %1,
    <vscale x 1 x i8> %2,
    iXLen %3, iXLen 1)

  ret <vscale x 1 x i16> %a
}

declare <vscale x 1 x i16> @llvm.riscv.vwmaccus.nxv1i16.i8(
  <vscale x 1 x i16>,
  i8,
  <vscale x 1 x i8>,
  iXLen,
  iXLen);

define <vscale x 1 x i16>  @intrinsic_vwmaccus_vx_nxv1i16_i8_nxv1i8(<vscale x 1 x i16> %0, i8 %1, <vscale x 1 x i8> %2, iXLen %3) nounwind {
; RV32-LABEL: intrinsic_vwmaccus_vx_nxv1i16_i8_nxv1i8:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    vsetvli zero, a1, e8, mf8, ta, mu
; RV32-NEXT:    vwmaccus.vx v8, a0, v9
; RV32-NEXT:    ret
;
; RV64-LABEL: intrinsic_vwmaccus_vx_nxv1i16_i8_nxv1i8:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    vsetvli zero, a1, e8, mf8, ta, mu
; RV64-NEXT:    vwmaccus.vx v8, a0, v9
; RV64-NEXT:    ret
entry:
  %a = call <vscale x 1 x i16> @llvm.riscv.vwmaccus.nxv1i16.i8(
    <vscale x 1 x i16> %0,
    i8 %1,
    <vscale x 1 x i8> %2,
    iXLen %3, iXLen 1)

  ret <vscale x 1 x i16> %a
}

declare <vscale x 8 x i8> @llvm.riscv.vredsum.nxv8i8.nxv1i8(
  <vscale x 8 x i8>,
  <vscale x 1 x i8>,
  <vscale x 8 x i8>,
  iXLen);

define <vscale x 8 x i8> @intrinsic_vredsum_vs_nxv8i8_nxv1i8_nxv8i8(<vscale x 1 x i8> %0, <vscale x 8 x i8> %1, iXLen %2) nounwind {
; RV32-LABEL: intrinsic_vredsum_vs_nxv8i8_nxv1i8_nxv8i8:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    vsetvli zero, a0, e8, mf8, ta, mu
; RV32-NEXT:    vredsum.vs v8, v8, v9
; RV32-NEXT:    ret
;
; RV64-LABEL: intrinsic_vredsum_vs_nxv8i8_nxv1i8_nxv8i8:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    vsetvli zero, a0, e8, mf8, ta, mu
; RV64-NEXT:    vredsum.vs v8, v8, v9
; RV64-NEXT:    ret
entry:
  %a = call <vscale x 8 x i8> @llvm.riscv.vredsum.nxv8i8.nxv1i8(
    <vscale x 8 x i8> undef,
    <vscale x 1 x i8> %0,
    <vscale x 8 x i8> %1,
    iXLen %2)

  ret <vscale x 8 x i8> %a
}

declare <vscale x 8 x i8> @llvm.riscv.vredand.nxv8i8.nxv1i8(
  <vscale x 8 x i8>,
  <vscale x 1 x i8>,
  <vscale x 8 x i8>,
  iXLen);

define <vscale x 8 x i8> @intrinsic_vredand_vs_nxv8i8_nxv1i8_nxv8i8(<vscale x 1 x i8> %0, <vscale x 8 x i8> %1, iXLen %2) nounwind {
; RV32-LABEL: intrinsic_vredand_vs_nxv8i8_nxv1i8_nxv8i8:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    vsetvli zero, a0, e8, mf8, ta, mu
; RV32-NEXT:    vredand.vs v8, v8, v9
; RV32-NEXT:    ret
;
; RV64-LABEL: intrinsic_vredand_vs_nxv8i8_nxv1i8_nxv8i8:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    vsetvli zero, a0, e8, mf8, ta, mu
; RV64-NEXT:    vredand.vs v8, v8, v9
; RV64-NEXT:    ret
entry:
  %a = call <vscale x 8 x i8> @llvm.riscv.vredand.nxv8i8.nxv1i8(
    <vscale x 8 x i8> undef,
    <vscale x 1 x i8> %0,
    <vscale x 8 x i8> %1,
    iXLen %2)

  ret <vscale x 8 x i8> %a
}

declare <vscale x 8 x i8> @llvm.riscv.vredor.nxv8i8.nxv1i8(
  <vscale x 8 x i8>,
  <vscale x 1 x i8>,
  <vscale x 8 x i8>,
  iXLen);

define <vscale x 8 x i8> @intrinsic_vredor_vs_nxv8i8_nxv1i8_nxv8i8(<vscale x 1 x i8> %0, <vscale x 8 x i8> %1, iXLen %2) nounwind {
; RV32-LABEL: intrinsic_vredor_vs_nxv8i8_nxv1i8_nxv8i8:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    vsetvli zero, a0, e8, mf8, ta, mu
; RV32-NEXT:    vredor.vs v8, v8, v9
; RV32-NEXT:    ret
;
; RV64-LABEL: intrinsic_vredor_vs_nxv8i8_nxv1i8_nxv8i8:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    vsetvli zero, a0, e8, mf8, ta, mu
; RV64-NEXT:    vredor.vs v8, v8, v9
; RV64-NEXT:    ret
entry:
  %a = call <vscale x 8 x i8> @llvm.riscv.vredor.nxv8i8.nxv1i8(
    <vscale x 8 x i8> undef,
    <vscale x 1 x i8> %0,
    <vscale x 8 x i8> %1,
    iXLen %2)

  ret <vscale x 8 x i8> %a
}

declare <vscale x 8 x i8> @llvm.riscv.vredxor.nxv8i8.nxv1i8(
  <vscale x 8 x i8>,
  <vscale x 1 x i8>,
  <vscale x 8 x i8>,
  iXLen);

define <vscale x 8 x i8> @intrinsic_vredxor_vs_nxv8i8_nxv1i8_nxv8i8(<vscale x 1 x i8> %0, <vscale x 8 x i8> %1, iXLen %2) nounwind {
; RV32-LABEL: intrinsic_vredxor_vs_nxv8i8_nxv1i8_nxv8i8:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    vsetvli zero, a0, e8, mf8, ta, mu
; RV32-NEXT:    vredxor.vs v8, v8, v9
; RV32-NEXT:    ret
;
; RV64-LABEL: intrinsic_vredxor_vs_nxv8i8_nxv1i8_nxv8i8:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    vsetvli zero, a0, e8, mf8, ta, mu
; RV64-NEXT:    vredxor.vs v8, v8, v9
; RV64-NEXT:    ret
entry:
  %a = call <vscale x 8 x i8> @llvm.riscv.vredxor.nxv8i8.nxv1i8(
    <vscale x 8 x i8> undef,
    <vscale x 1 x i8> %0,
    <vscale x 8 x i8> %1,
    iXLen %2)

  ret <vscale x 8 x i8> %a
}

declare <vscale x 8 x i8> @llvm.riscv.vredminu.nxv8i8.nxv1i8(
  <vscale x 8 x i8>,
  <vscale x 1 x i8>,
  <vscale x 8 x i8>,
  iXLen);

define <vscale x 8 x i8> @intrinsic_vredminu_vs_nxv8i8_nxv1i8_nxv8i8(<vscale x 1 x i8> %0, <vscale x 8 x i8> %1, iXLen %2) nounwind {
; RV32-LABEL: intrinsic_vredminu_vs_nxv8i8_nxv1i8_nxv8i8:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    vsetvli zero, a0, e8, mf8, ta, mu
; RV32-NEXT:    vredminu.vs v8, v8, v9
; RV32-NEXT:    ret
;
; RV64-LABEL: intrinsic_vredminu_vs_nxv8i8_nxv1i8_nxv8i8:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    vsetvli zero, a0, e8, mf8, ta, mu
; RV64-NEXT:    vredminu.vs v8, v8, v9
; RV64-NEXT:    ret
entry:
  %a = call <vscale x 8 x i8> @llvm.riscv.vredminu.nxv8i8.nxv1i8(
    <vscale x 8 x i8> undef,
    <vscale x 1 x i8> %0,
    <vscale x 8 x i8> %1,
    iXLen %2)

  ret <vscale x 8 x i8> %a
}

declare <vscale x 8 x i8> @llvm.riscv.vredmin.nxv8i8.nxv1i8(
  <vscale x 8 x i8>,
  <vscale x 1 x i8>,
  <vscale x 8 x i8>,
  iXLen);

define <vscale x 8 x i8> @intrinsic_vredmin_vs_nxv8i8_nxv1i8_nxv8i8(<vscale x 1 x i8> %0, <vscale x 8 x i8> %1, iXLen %2) nounwind {
; RV32-LABEL: intrinsic_vredmin_vs_nxv8i8_nxv1i8_nxv8i8:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    vsetvli zero, a0, e8, mf8, ta, mu
; RV32-NEXT:    vredmin.vs v8, v8, v9
; RV32-NEXT:    ret
;
; RV64-LABEL: intrinsic_vredmin_vs_nxv8i8_nxv1i8_nxv8i8:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    vsetvli zero, a0, e8, mf8, ta, mu
; RV64-NEXT:    vredmin.vs v8, v8, v9
; RV64-NEXT:    ret
entry:
  %a = call <vscale x 8 x i8> @llvm.riscv.vredmin.nxv8i8.nxv1i8(
    <vscale x 8 x i8> undef,
    <vscale x 1 x i8> %0,
    <vscale x 8 x i8> %1,
    iXLen %2)

  ret <vscale x 8 x i8> %a
}

declare <vscale x 8 x i8> @llvm.riscv.vredmaxu.nxv8i8.nxv1i8(
  <vscale x 8 x i8>,
  <vscale x 1 x i8>,
  <vscale x 8 x i8>,
  iXLen);

define <vscale x 8 x i8> @intrinsic_vredmaxu_vs_nxv8i8_nxv1i8_nxv8i8(<vscale x 1 x i8> %0, <vscale x 8 x i8> %1, iXLen %2) nounwind {
; RV32-LABEL: intrinsic_vredmaxu_vs_nxv8i8_nxv1i8_nxv8i8:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    vsetvli zero, a0, e8, mf8, ta, mu
; RV32-NEXT:    vredmaxu.vs v8, v8, v9
; RV32-NEXT:    ret
;
; RV64-LABEL: intrinsic_vredmaxu_vs_nxv8i8_nxv1i8_nxv8i8:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    vsetvli zero, a0, e8, mf8, ta, mu
; RV64-NEXT:    vredmaxu.vs v8, v8, v9
; RV64-NEXT:    ret
entry:
  %a = call <vscale x 8 x i8> @llvm.riscv.vredmaxu.nxv8i8.nxv1i8(
    <vscale x 8 x i8> undef,
    <vscale x 1 x i8> %0,
    <vscale x 8 x i8> %1,
    iXLen %2)

  ret <vscale x 8 x i8> %a
}

declare <vscale x 8 x i8> @llvm.riscv.vredmax.nxv8i8.nxv1i8(
  <vscale x 8 x i8>,
  <vscale x 1 x i8>,
  <vscale x 8 x i8>,
  iXLen);

define <vscale x 8 x i8> @intrinsic_vredmax_vs_nxv8i8_nxv1i8_nxv8i8(<vscale x 1 x i8> %0, <vscale x 8 x i8> %1, iXLen %2) nounwind {
; RV32-LABEL: intrinsic_vredmax_vs_nxv8i8_nxv1i8_nxv8i8:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    vsetvli zero, a0, e8, mf8, ta, mu
; RV32-NEXT:    vredmax.vs v8, v8, v9
; RV32-NEXT:    ret
;
; RV64-LABEL: intrinsic_vredmax_vs_nxv8i8_nxv1i8_nxv8i8:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    vsetvli zero, a0, e8, mf8, ta, mu
; RV64-NEXT:    vredmax.vs v8, v8, v9
; RV64-NEXT:    ret
entry:
  %a = call <vscale x 8 x i8> @llvm.riscv.vredmax.nxv8i8.nxv1i8(
    <vscale x 8 x i8> undef,
    <vscale x 1 x i8> %0,
    <vscale x 8 x i8> %1,
    iXLen %2)

  ret <vscale x 8 x i8> %a
}

declare <vscale x 4 x i16> @llvm.riscv.vwredsumu.nxv4i16.nxv1i8(
  <vscale x 4 x i16>,
  <vscale x 1 x i8>,
  <vscale x 4 x i16>,
  iXLen);

define <vscale x 4 x i16> @intrinsic_vwredsumu_vs_nxv4i16_nxv1i8_nxv4i16(<vscale x 1 x i8> %0, <vscale x 4 x i16> %1, iXLen %2) nounwind {
; RV32-LABEL: intrinsic_vwredsumu_vs_nxv4i16_nxv1i8_nxv4i16:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    vsetvli zero, a0, e8, mf8, ta, mu
; RV32-NEXT:    vwredsumu.vs v8, v8, v9
; RV32-NEXT:    ret
;
; RV64-LABEL: intrinsic_vwredsumu_vs_nxv4i16_nxv1i8_nxv4i16:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    vsetvli zero, a0, e8, mf8, ta, mu
; RV64-NEXT:    vwredsumu.vs v8, v8, v9
; RV64-NEXT:    ret
entry:
  %a = call <vscale x 4 x i16> @llvm.riscv.vwredsumu.nxv4i16.nxv1i8(
    <vscale x 4 x i16> undef,
    <vscale x 1 x i8> %0,
    <vscale x 4 x i16> %1,
    iXLen %2)

  ret <vscale x 4 x i16> %a
}

declare <vscale x 4 x i16> @llvm.riscv.vwredsum.nxv4i16.nxv1i8(
  <vscale x 4 x i16>,
  <vscale x 1 x i8>,
  <vscale x 4 x i16>,
  iXLen);

define <vscale x 4 x i16> @intrinsic_vwredsum_vs_nxv4i16_nxv1i8_nxv4i16(<vscale x 1 x i8> %0, <vscale x 4 x i16> %1, iXLen %2) nounwind {
; RV32-LABEL: intrinsic_vwredsum_vs_nxv4i16_nxv1i8_nxv4i16:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    vsetvli zero, a0, e8, mf8, ta, mu
; RV32-NEXT:    vwredsum.vs v8, v8, v9
; RV32-NEXT:    ret
;
; RV64-LABEL: intrinsic_vwredsum_vs_nxv4i16_nxv1i8_nxv4i16:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    vsetvli zero, a0, e8, mf8, ta, mu
; RV64-NEXT:    vwredsum.vs v8, v8, v9
; RV64-NEXT:    ret
entry:
  %a = call <vscale x 4 x i16> @llvm.riscv.vwredsum.nxv4i16.nxv1i8(
    <vscale x 4 x i16> undef,
    <vscale x 1 x i8> %0,
    <vscale x 4 x i16> %1,
    iXLen %2)

  ret <vscale x 4 x i16> %a
}

declare <vscale x 4 x half> @llvm.riscv.vfredosum.nxv4f16.nxv1f16(
  <vscale x 4 x half>,
  <vscale x 1 x half>,
  <vscale x 4 x half>,
  iXLen);

define <vscale x 4 x half> @intrinsic_vfredosum_vs_nxv4f16_nxv1f16_nxv4f16(<vscale x 1 x half> %0, <vscale x 4 x half> %1, iXLen %2) nounwind {
; RV32-LABEL: intrinsic_vfredosum_vs_nxv4f16_nxv1f16_nxv4f16:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    vsetvli zero, a0, e16, mf4, ta, mu
; RV32-NEXT:    vfredosum.vs v8, v8, v9
; RV32-NEXT:    ret
;
; RV64-LABEL: intrinsic_vfredosum_vs_nxv4f16_nxv1f16_nxv4f16:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    vsetvli zero, a0, e16, mf4, ta, mu
; RV64-NEXT:    vfredosum.vs v8, v8, v9
; RV64-NEXT:    ret
entry:
  %a = call <vscale x 4 x half> @llvm.riscv.vfredosum.nxv4f16.nxv1f16(
    <vscale x 4 x half> undef,
    <vscale x 1 x half> %0,
    <vscale x 4 x half> %1,
    iXLen %2)

  ret <vscale x 4 x half> %a
}

declare <vscale x 4 x half> @llvm.riscv.vfredusum.nxv4f16.nxv1f16(
  <vscale x 4 x half>,
  <vscale x 1 x half>,
  <vscale x 4 x half>,
  iXLen);

define <vscale x 4 x half> @intrinsic_vfredusum_vs_nxv4f16_nxv1f16_nxv4f16(<vscale x 1 x half> %0, <vscale x 4 x half> %1, iXLen %2) nounwind {
; RV32-LABEL: intrinsic_vfredusum_vs_nxv4f16_nxv1f16_nxv4f16:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    vsetvli zero, a0, e16, mf4, ta, mu
; RV32-NEXT:    vfredusum.vs v8, v8, v9
; RV32-NEXT:    ret
;
; RV64-LABEL: intrinsic_vfredusum_vs_nxv4f16_nxv1f16_nxv4f16:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    vsetvli zero, a0, e16, mf4, ta, mu
; RV64-NEXT:    vfredusum.vs v8, v8, v9
; RV64-NEXT:    ret
entry:
  %a = call <vscale x 4 x half> @llvm.riscv.vfredusum.nxv4f16.nxv1f16(
    <vscale x 4 x half> undef,
    <vscale x 1 x half> %0,
    <vscale x 4 x half> %1,
    iXLen %2)

  ret <vscale x 4 x half> %a
}

declare <vscale x 4 x half> @llvm.riscv.vfredmax.nxv4f16.nxv1f16(
  <vscale x 4 x half>,
  <vscale x 1 x half>,
  <vscale x 4 x half>,
  iXLen);

define <vscale x 4 x half> @intrinsic_vfredmax_vs_nxv4f16_nxv1f16_nxv4f16(<vscale x 1 x half> %0, <vscale x 4 x half> %1, iXLen %2) nounwind {
; RV32-LABEL: intrinsic_vfredmax_vs_nxv4f16_nxv1f16_nxv4f16:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    vsetvli zero, a0, e16, mf4, ta, mu
; RV32-NEXT:    vfredmax.vs v8, v8, v9
; RV32-NEXT:    ret
;
; RV64-LABEL: intrinsic_vfredmax_vs_nxv4f16_nxv1f16_nxv4f16:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    vsetvli zero, a0, e16, mf4, ta, mu
; RV64-NEXT:    vfredmax.vs v8, v8, v9
; RV64-NEXT:    ret
entry:
  %a = call <vscale x 4 x half> @llvm.riscv.vfredmax.nxv4f16.nxv1f16(
    <vscale x 4 x half> undef,
    <vscale x 1 x half> %0,
    <vscale x 4 x half> %1,
    iXLen %2)

  ret <vscale x 4 x half> %a
}

declare <vscale x 4 x half> @llvm.riscv.vfredmin.nxv4f16.nxv1f16(
  <vscale x 4 x half>,
  <vscale x 1 x half>,
  <vscale x 4 x half>,
  iXLen);

define <vscale x 4 x half> @intrinsic_vfredmin_vs_nxv4f16_nxv1f16_nxv4f16(<vscale x 1 x half> %0, <vscale x 4 x half> %1, iXLen %2) nounwind {
; RV32-LABEL: intrinsic_vfredmin_vs_nxv4f16_nxv1f16_nxv4f16:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    vsetvli zero, a0, e16, mf4, ta, mu
; RV32-NEXT:    vfredmin.vs v8, v8, v9
; RV32-NEXT:    ret
;
; RV64-LABEL: intrinsic_vfredmin_vs_nxv4f16_nxv1f16_nxv4f16:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    vsetvli zero, a0, e16, mf4, ta, mu
; RV64-NEXT:    vfredmin.vs v8, v8, v9
; RV64-NEXT:    ret
entry:
  %a = call <vscale x 4 x half> @llvm.riscv.vfredmin.nxv4f16.nxv1f16(
    <vscale x 4 x half> undef,
    <vscale x 1 x half> %0,
    <vscale x 4 x half> %1,
    iXLen %2)

  ret <vscale x 4 x half> %a
}

declare <vscale x 2 x float> @llvm.riscv.vfwredosum.nxv2f32.nxv1f16(
  <vscale x 2 x float>,
  <vscale x 1 x half>,
  <vscale x 2 x float>,
  iXLen);

define <vscale x 2 x float> @intrinsic_vfwredosum_vs_nxv2f32_nxv1f16_nxv2f32(<vscale x 1 x half> %0, <vscale x 2 x float> %1, iXLen %2) nounwind {
; RV32-LABEL: intrinsic_vfwredosum_vs_nxv2f32_nxv1f16_nxv2f32:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    vsetvli zero, a0, e16, mf4, ta, mu
; RV32-NEXT:    vfwredosum.vs v8, v8, v9
; RV32-NEXT:    ret
;
; RV64-LABEL: intrinsic_vfwredosum_vs_nxv2f32_nxv1f16_nxv2f32:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    vsetvli zero, a0, e16, mf4, ta, mu
; RV64-NEXT:    vfwredosum.vs v8, v8, v9
; RV64-NEXT:    ret
entry:
  %a = call <vscale x 2 x float> @llvm.riscv.vfwredosum.nxv2f32.nxv1f16(
    <vscale x 2 x float> undef,
    <vscale x 1 x half> %0,
    <vscale x 2 x float> %1,
    iXLen %2)

  ret <vscale x 2 x float> %a
}
declare <vscale x 2 x float> @llvm.riscv.vfwredusum.nxv2f32.nxv1f16(
  <vscale x 2 x float>,
  <vscale x 1 x half>,
  <vscale x 2 x float>,
  iXLen);

define <vscale x 2 x float> @intrinsic_vfwredusum_vs_nxv2f32_nxv1f16_nxv2f32(<vscale x 1 x half> %0, <vscale x 2 x float> %1, iXLen %2) nounwind {
; RV32-LABEL: intrinsic_vfwredusum_vs_nxv2f32_nxv1f16_nxv2f32:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    vsetvli zero, a0, e16, mf4, ta, mu
; RV32-NEXT:    vfwredusum.vs v8, v8, v9
; RV32-NEXT:    ret
;
; RV64-LABEL: intrinsic_vfwredusum_vs_nxv2f32_nxv1f16_nxv2f32:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    vsetvli zero, a0, e16, mf4, ta, mu
; RV64-NEXT:    vfwredusum.vs v8, v8, v9
; RV64-NEXT:    ret
entry:
  %a = call <vscale x 2 x float> @llvm.riscv.vfwredusum.nxv2f32.nxv1f16(
    <vscale x 2 x float> undef,
    <vscale x 1 x half> %0,
    <vscale x 2 x float> %1,
    iXLen %2)

  ret <vscale x 2 x float> %a
}

declare <vscale x 1 x i8> @llvm.riscv.vslidedown.nxv1i8(
  <vscale x 1 x i8>,
  <vscale x 1 x i8>,
  iXLen,
  iXLen);

define <vscale x 1 x i8> @intrinsic_vslidedown_vx_nxv1i8_nxv1i8(<vscale x 1 x i8> %0, iXLen %1, iXLen %2) nounwind {
; RV32-LABEL: intrinsic_vslidedown_vx_nxv1i8_nxv1i8:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    vsetvli zero, a1, e8, mf8, ta, mu
; RV32-NEXT:    vslidedown.vx v8, v8, a0
; RV32-NEXT:    ret
;
; RV64-LABEL: intrinsic_vslidedown_vx_nxv1i8_nxv1i8:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    vsetvli zero, a1, e8, mf8, ta, mu
; RV64-NEXT:    vslidedown.vx v8, v8, a0
; RV64-NEXT:    ret
entry:
  %a = call <vscale x 1 x i8> @llvm.riscv.vslidedown.nxv1i8(
    <vscale x 1 x i8> undef,
    <vscale x 1 x i8> %0,
    iXLen %1,
    iXLen %2)

  ret <vscale x 1 x i8> %a
}

declare <vscale x 1 x i8> @llvm.riscv.vslideup.nxv1i8(
  <vscale x 1 x i8>,
  <vscale x 1 x i8>,
  iXLen,
  iXLen);

define <vscale x 1 x i8> @intrinsic_vslideup_vx_nxv1i8_nxv1i8(<vscale x 1 x i8> %0, iXLen %1, iXLen %2) nounwind {
; RV32-LABEL: intrinsic_vslideup_vx_nxv1i8_nxv1i8:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    vsetvli zero, a1, e8, mf8, ta, mu
; RV32-NEXT:    vslideup.vx v9, v8, a0
; RV32-NEXT:    vmv1r.v v8, v9
; RV32-NEXT:    ret
;
; RV64-LABEL: intrinsic_vslideup_vx_nxv1i8_nxv1i8:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    vsetvli zero, a1, e8, mf8, ta, mu
; RV64-NEXT:    vslideup.vx v9, v8, a0
; RV64-NEXT:    vmv1r.v v8, v9
; RV64-NEXT:    ret
entry:
  %a = call <vscale x 1 x i8> @llvm.riscv.vslideup.nxv1i8(
    <vscale x 1 x i8> undef,
    <vscale x 1 x i8> %0,
    iXLen %1,
    iXLen %2)

  ret <vscale x 1 x i8> %a
}

declare <vscale x 1 x i64> @llvm.riscv.vmv.s.x.nxv1i64(<vscale x 1 x i64>, i64, iXLen);

define <vscale x 1 x i64> @intrinsic_vmv.s.x_x_nxv1i64(i64 %0, iXLen %1) nounwind {
; RV32-LABEL: intrinsic_vmv.s.x_x_nxv1i64:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    addi sp, sp, -16
; RV32-NEXT:    sw a1, 12(sp)
; RV32-NEXT:    sw a0, 8(sp)
; RV32-NEXT:    vsetvli zero, a2, e64, m1, ta, mu
; RV32-NEXT:    addi a0, sp, 8
; RV32-NEXT:    vlse64.v v8, (a0), zero
; RV32-NEXT:    addi sp, sp, 16
; RV32-NEXT:    ret
;
; RV64-LABEL: intrinsic_vmv.s.x_x_nxv1i64:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    vsetvli zero, a1, e64, m1, ta, mu
; RV64-NEXT:    vmv.s.x v8, a0
; RV64-NEXT:    ret
entry:
  %a = call <vscale x 1 x i64> @llvm.riscv.vmv.s.x.nxv1i64(<vscale x 1 x i64> undef, i64 %0, iXLen %1)
  ret <vscale x 1 x i64> %a
}

declare <vscale x 1 x half> @llvm.riscv.vfmv.s.f.nxv1f16(<vscale x 1 x half>, half, iXLen)

define <vscale x 1 x half> @intrinsic_vfmv.s.f_f_nxv1f16(half %0, iXLen %1) nounwind {
; RV32-LABEL: intrinsic_vfmv.s.f_f_nxv1f16:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    vsetvli zero, a0, e16, mf4, ta, mu
; RV32-NEXT:    vfmv.s.f v8, fa0
; RV32-NEXT:    ret
;
; RV64-LABEL: intrinsic_vfmv.s.f_f_nxv1f16:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    vsetvli zero, a0, e16, mf4, ta, mu
; RV64-NEXT:    vfmv.s.f v8, fa0
; RV64-NEXT:    ret
entry:
  %a = call <vscale x 1 x half> @llvm.riscv.vfmv.s.f.nxv1f16(<vscale x 1 x half> undef, half %0, iXLen %1)
  ret <vscale x 1 x half> %a
}

declare <vscale x 1 x i8> @llvm.riscv.vcompress.nxv1i8(
  <vscale x 1 x i8>,
  <vscale x 1 x i8>,
  <vscale x 1 x i1>,
  iXLen);

define <vscale x 1 x i8> @intrinsic_vcompress_um_nxv1i8_nxv1i8(<vscale x 1 x i8> %0, <vscale x 1 x i1> %1, iXLen %2) nounwind {
; RV32-LABEL: intrinsic_vcompress_um_nxv1i8_nxv1i8:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    vsetvli zero, a0, e8, mf8, ta, mu
; RV32-NEXT:    vcompress.vm v9, v8, v0
; RV32-NEXT:    vmv1r.v v8, v9
; RV32-NEXT:    ret
;
; RV64-LABEL: intrinsic_vcompress_um_nxv1i8_nxv1i8:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    vsetvli zero, a0, e8, mf8, ta, mu
; RV64-NEXT:    vcompress.vm v9, v8, v0
; RV64-NEXT:    vmv1r.v v8, v9
; RV64-NEXT:    ret
entry:
  %a = call <vscale x 1 x i8> @llvm.riscv.vcompress.nxv1i8(
    <vscale x 1 x i8> undef,
    <vscale x 1 x i8> %0,
    <vscale x 1 x i1> %1,
    iXLen %2)

  ret <vscale x 1 x i8> %a
}
